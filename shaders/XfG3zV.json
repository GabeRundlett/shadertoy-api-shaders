{
    "Shader": {
        "info": {
            "date": "1712954997",
            "description": "restoring \"Zen Panels\" stb shader ( was 111 likes )",
            "flags": 32,
            "hasliked": 0,
            "id": "XfG3zV",
            "likes": 29,
            "name": "[stb] Zen Panels",
            "published": 3,
            "tags": [
                "stb"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "// buffer texture\n#define t2d(p) texture(iChannel0, p)\n\nfloat mapH(vec3 p) {\n    return - p.z + .1 * (t2d(p.xy).a - .015*pow(t2d(p.xy).r, .125));\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 d = vec2(1., 1.) / iResolution.xy;\n    return\n        normalize(\n            vec3(\n                mapH(p+vec3(d.x, 0., 0.)) - mapH(p+vec3(-d.x, 0., 0.)),\n                mapH(p+vec3(0., d.y, 0.)) - mapH(p+vec3(0., -d.y, 0.)),\n                mapH(p+vec3(0., 0., d.y)) - mapH(p+vec3(0., 0., -d.y))\n            )\n        );\n}\n\n// not totally unlike ambient occlusion\nfloat getProx(vec3 p, float dist) {\n    vec2 d = vec2(iResolution.y/iResolution.x, 1.) * dist;\n    return\n        (\n            (\n                mapH(p+vec3(d.x, 0., 0.)) + mapH(p+vec3(-d.x, 0., 0.)) +\n                mapH(p+vec3(0., d.y, 0.)) + mapH(p+vec3(0., -d.y, 0.)) +\n                mapH(p+vec3(0., 0., d.y)) + mapH(p+vec3(0., 0., -d.y))\n            )\n        ) / 6.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.xy;\n    \n    // input height\n    float h = .1 * (t2d(uv).a-0.);\n    \n    // input color\n    vec3 col = t2d(uv).rgb;\n    \n    // 3D vec\n    vec3 p = vec3(uv, h);\n    \n    // set up light\n    vec3 lightPos = vec3(0, 1., .5);\n    //vec3 lightDir = normalize(lightPos);\n    \n    // surface normal\n    vec3 norm = getNorm(p);\n    \n    // just yer basic diffuse reflection\n    float diffuse = 64. * max(0., dot(norm, normalize(p-lightPos-.5)));\n    \n    // adjustments...\n    diffuse = 3.5 * diffuse;\n    diffuse *= mix(1., h, .75);\n    diffuse += 20.;\n    \n    // basic ao\n    float prox = 0.;\n    prox -= 512. * h * getProx(p, .005);\n    prox -= 512. * h * getProx(p, .0075);\n    prox -= 512. * h * getProx(p, .01);\n    diffuse *= mix(1., prox, .5);\n    \n    // fade from light source\n    diffuse /= pow(distance(p-.5, lightPos)*4., 2.);\n    \n    fragColor = vec4(col * diffuse, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int\tSubDiv\t= 16;\t\t// number of subdivisions (loop iterations)\nconst float Bailout\t= 0.0025;\t// bailout threshold for small rectangles (speed)\n\nfloat seed\t= 0.02;\t\t// initial random seed\nfloat pw\t= 8.0;\t\t// affects trim roundness (even ints only)\nfloat fat\t= 0.003;\t// overall trim width\nfloat rate\t= 0.035;\t// affects trim scaling\n\n// trim & panel texture/color\n#define t2d(p) mix(vec4(.5), texture(iChannel0, p), .8)\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord-res/2.) / res.y;\n    \n    // out\n    float height = 0.;\n    vec3 col = vec3(0.);\n    \n    vec2 size = vec2(res.x/res.y, 1.);\t// initial rectangle size\n    vec2 p = uv / size + .5;\t\t\t// uvs\n    \n    fat = pow(fat, pw);\n    float rad = 0.;\n    \n    float R;\n    for(int i=0; i<SubDiv; i++) {\n        \n        rad += rate;\n        \n        // splitting methods (uncomment one)\n        if(mod(float(i), 2.)<1.)\t// split rect alternately\n        //if(hash11(seed+3.2134)<.5)\t// split rect randomly\n        //if(size.x>=size.y)\t\t\t// split rect by longest side (breaks animation)\n        \n        // horizontal split\n        {   \n            // exit loop if width is under bailout threshold\n            if(size.x<Bailout)\n                break;\n\n            // time var\n            float t = .125 * iTime;\n            \n            // 1D smooth noise\n            float h = mix(hash11(floor(seed*32.3)+floor(t)), hash11(floor(seed*32.3)+1.+floor(t)), smoothstep(0., 1., fract(t)));\n            \n            // value for the split's position\n            R = mix(.5, h, .985);\n\n            // vertical trim height\n            float h2 = 1. - pow((p.x-R)*size.x*rad, pw)/fat-pow(rad, 1./pw);\n            \n            // combine trim height & texture\n            if(h2>=height) {\n                height = h2;\n                col = t2d(vec2(p.y-.5, 4.*(-p.x+R))*vec2(size.y, size.x)/1.+seed).rgb;\n                col *= pow(1.-abs(p.y-.5)*2., .15);\n            }\n            \n            // adjust uvs & size and update seed\n            if(p.x < R) { // left rect\n                p.x /= R;\n                p.x = 1. - p.x;\n                size.x *= R;\n                seed += .67231 + hash11(seed);\n            }\n            else { // right rect\n                p.x -= R;\n                p.x /= 1. - R;\n                size.x *= 1. - R;\n                seed += .21645 + hash11(seed*1.43);\n            }\n        }\n        \n        // vertical split\n        else {\n            // exit loop if height is under bailout threshold\n            if(size.y<Bailout)\n                break;\n\n            // time var\n            float t = .1524251731 * iTime;\n            \n            // 1D smooth noise\n            float h = mix(hash11(floor(seed*32.5)+floor(t)), hash11(floor(seed*32.5)+1.+floor(t)), smoothstep(0., 1., fract(t)));\n            \n            // value for the split's position\n            float R = mix(.5, h, .985);\n\n            // horizontal trim height\n            float h2 = 1.-pow((p.y-R)*size.y*rad, pw)/fat-pow(rad, 1./pw);\n            \n            // combine trim height & texture\n            if(h2>=height) {\n                height = h2;\n                col = t2d(vec2(p.x-.5, 4.*(p.y-R))*size/1.+seed).rgb;\n                col *= pow(1.-abs(p.x-.5)*2., .15);\n            }\n\n            // adjust uvs & size and update seed\n            if(p.y < R) { // bottom rect\n                p.y /= R;\n                p.y = 1.-p.y;\n                size.y *= R;\n                seed += .63354+hash11(seed*1.8219);\n            }\n            else { // top rect\n                p.y -= R;\n                p.y /= 1.-R;\n                size.y *= 1.-R;\n                seed += .3165+hash11(seed*.73);\n            }\n        }\n        \n    } // for i\n    \n    // adjust and clamp trim height\n    height = clamp(height*sqrt(pw)/1.15, -1., 1.);\n    \n    // place panels\n    if(height<=0.) {\n        // common panel texture\n        col = 1. * t2d((p-.5) * vec2(size.x/1., size.y*4.)-seed).rgb;\n        \n        // the rare panel\n        if(hash11(seed)<.003) {\n            vec2 p2 = .25 + (p-vec2(.5, 0.)) * vec2(.15, size.y/size.x);\n            col =\n                mix(\n                    .3 * col,\n                    vec3(1., .9, .7) * texture(iChannel1, p2).rgb,\n\t\t\t\t\ttexture(iChannel1, p2).a\n                );\n        }\n        \n        // darken panels near trim (could be better)\n    \tcol *= 1. - .75*pow(max(2.*abs(p.x-.5), 2.*abs(p.y-.5)), 6.);\n    }\n    \n    fragColor = vec4(col, height);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}