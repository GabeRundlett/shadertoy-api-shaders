{
    "Shader": {
        "info": {
            "date": "1496244714",
            "description": "Testing out Mattz's hexagonal prismatic voxel traversal formula.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dsBz4",
            "likes": 73,
            "name": "Hex Voxel Scene",
            "published": 3,
            "tags": [
                "voxel",
                "hexagon"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 5627
        },
        "renderpass": [
            {
                "code": "/* \n    hex voxels, by mattz\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    Idea: raytrace through stacked hexagonal boxes, based on Shane's comment\n    in hexwaves - https://www.shadertoy.com/view/XsBczc\n\n\tHex Voxel Scene\n\t---------------\n\n\tTesting out Mattz's hexagonal prismatic voxel traversal formula on a basic scene.\n\n\tI've always been curious as to what a simple scene would look like using a non-standard\n\tvoxel traversal, especially the hexagonal box one, but have never got around to putting\n\tit into effect. Thankfully, Mattz is a more efficient coder than myself and wrote a \n\thexagonal prismatic voxel traversal (thanks for the technical term, IQ) not too long ago. \n\tOn a side note, he wrote it in what seemed to be a couple of hours, at most. It takes me  \n    that long just to choose a texture. :)\n\n\tThere are numerous standard cubic voxel examples around, but not too many featuring other \n\tkinds. Mattz's \"hex voxel\" example is the first hexagonal box voxel traversal I've seen \n\tin shader form.\n\n\tAnyway, most of this is Mattz's work. I simply plugged a different scene in, rearranged \n\tthings in a hurry, and changed a few settings here and there, so if the code looks patched \n\ttogether, that's because it is. :)\n\n    Hopefully, it'll work well enough, but it needs a tidy up. In addition, I put it together \n\ton a pretty fast machine, so am not yet aware of the frame rate on slower machines. Having\n\tsaid that, I tried to choose a simplistic scene with cheap operations, so hopefully, there \n\twon't be too many issues.\n\n\t\n\tBased On:\n\t\n\t// The original this is based on. Much neater code. :)\n\thex voxels - mattz\n\thttps://www.shadertoy.com/view/ldBcDd\n\n\t// Cool 2D hexagon traversal.\n\thexwaves - mattz\n\thttps://www.shadertoy.com/view/XsBczc\n\n*/\n\n\n#define FAR 100. // Maximum ray distance. Analogous to the far plane.\n\n// Fabrice's succinct, 2D rotation formula. Apparently slower than the standard one, but\n// only used for its compactness here.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\nfloat objID, svObjID; // Object ID \n\n\n// square root of 3 over 2\nconst float hex_factor = 0.8660254037844386;\n\n// ratio of cell height to hex radius\nconst float cell_height = 1.75;\n\n// relationship between integer grid cells & sizes\nconst vec3 cell_size = vec3(hex_factor, 1.0, cell_height);\n\n// ambient occlusion falloff - smaller is darker\nconst float ao_falloff = 3.5;\n\n// ambient occlusion strength - bigger is darker\nconst float ao_strength = 0.65;\n\n// higher resolution discretizes more finely but needs more grid steps to render\nconst float resolution = 1.5;\n\n// number of steps to take to render\nconst int grid_steps = 160;\n\n// light direction\n//vec3 light_dir;\nvec3 lp;\n\n\n#define HEX_FROM_CART(p) vec2(p.x / hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n\n//////////////////////////////////////////////////////////////////////\n// Used to draw top borders\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Given a 2D position, find integer coordinates of center of nearest\n// hexagon in plane.\n\nvec2 nearestHexCell(in vec2 pos) {\n    \n    // integer coords in hex center grid -- will need to be adjusted\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    // adjust integer coords\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    // difference vector\n    vec2 gdiff = gpos - hex_int;\n\n    // figure out which side of line we are on and modify\n    // hex center if necessary\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Flip normal if necessary to have positive dot product with d\n\nvec2 alignNormal(vec2 h, vec2 d) {\n    return h * sign(dot(h, CART_FROM_HEX(d)));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Intersect a ray with a hexagon wall with normal n\n\nvec3 rayHexIntersect(in vec2 ro, in vec2 rd, in vec2 h) {\n    \n    //return vec3(0); \n\n    vec2 n = CART_FROM_HEX(h);\n\n    // solve for u such that dot(n, ro+u*rd) = 1.0\n    float u = (1.0 - dot(n, ro)) / dot(n, rd);\n    \n    // return the \n    return vec3(h, u);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Choose the vector whose z coordinate is minimal\n\nvec3 rayMin(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Straight path.\n    return vec2(sin(z*.085)*8., cos(z*.085)*6.); // Windy path.\n    \n}\n\n\n\n\n// The terrain setup up.\nfloat map(vec3 p){\n     \n    // The original uses a different coordinate system, so this is a quick hack\n    // to enable me to drop in a \"Z into the page\" coordinate system.\n    p = p.yzx; \n    \n    // A gyroid-like perturbation to add to a plane. I'm doing it prior to the\n    // wrapping the objects around the path, but there's no rule saying you can't\n    // wrap this as well.\n    float trSf = dot(sin(p*3.14159/16. - cos(p.yzx*3.14159/12.)), vec3(8));\n \n    p.xy -= path(p.z); // Wrap the object (to follow) around the path.\n\n   \n    // Add the perturbation to the plane, then carve out a tunnel. I named the resultant object\n    // \"surr\" for surroundings - I was in a hurry. :)\n    float surr = smax(4. - length(p.xy*vec2(1, .75)), p.y - 4. + (.5 - trSf), 2.);\n    float rail = max(abs(abs(p.x) - 4.) - 1., p.y + 2.); // Some rails for the path below.\n    \n    // Attaching the rails to the surroundings - instead of the path - for color reasons.\n    surr = min(surr, rail); \n    \n    // A windy path - Everything above a certain height is omitted.\n    float path = max(abs(p.x) - 3.5, p.y + 4.); \n\n    objID = step(surr, path); // Object ID - Surrounding or path floor.\n\n    return min(surr, path); // Return the minimum hit point.\n \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n     \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Just for coloring the sky\n\nvec3 sky(vec3 ro, vec3 rd) {\n    \n    float s = 0.5*dot(normalize(lp - ro), rd) + 0.5;\n    return mix(vec3(1, .8, .7), vec3(.75, .92, 1), s)*vec3(1.35, 1.2, 1);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Surface shading function. hit_nt holds normal and ray distance,\n// bdist holds distance to voxel edge, ndist holds distance to \n// neighbors (useful for AO).\n\nvec3 shade(vec3 ro, vec3 rd, vec4 hit_nt, float bdist, float ndist, float diffuse) {\n    \n    // Surface point.\n    vec3 p = ro + rd*hit_nt.w;\n    \n    // get the normal\n    vec3 n = hit_nt.xyz;\n    \n    // Light direction vector.\n    vec3 ld = normalize(lp - p);\n    \n\n    // gotta deal with borders\n\n    // need to antialias more far away\n    float border_scale = 3.0/iResolution.y;\n    float border_size = 0.01;\n    float border = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n    \n    border_scale = 4.0/iResolution.y;\n    border_size = 0.01*3.;\n    float border2 = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n\n\n\n    // diffuse + ambient term\n    diffuse = min(diffuse, clamp(dot(ld, n), 0.0, 1.0));\n    float spec = pow(max( dot( reflect(-ld, n), -rd ), 0.0 ), 32.0);\n    \n    //float atten = 3./(1. + hit_nt.w*.1);\n    \n    //float fres = clamp(1. + dot(rd, n), 0., 1.);\n    \n    float ao = 1.0 - ao_strength*exp(-ao_falloff*ndist); // Ambient occlusion.\n\n    // Surface color.\n    vec3 color = (tex3D(iChannel0, p/4., n)*.66+tex3D(iChannel0, p/2., n)*.34);\n    color *= vec3(1, .8, .6)*1.5;\n    \n    float gr = dot(color, vec3(.299, .587, .114));\n   \n    // Color the path and the surrounds slightly different colors.\n    if(svObjID == 0.) { // Path.\n        color = mix(color*vec3(1, 1.5, 1), vec3(1)*gr, .35)*1.5;//*vec3(1, .7, .4); // Terrain.\n        color *= vec3(1.5, 1.25, 1); \n        //color = color.xxx;\n    }\n    else { // Surrounds.\n         \n        color = mix(color*vec3(1, 1.5, 1), vec3(1)*gr, .5);\n        color *= vec3(1.5, 1.25, 1); \n        //color = color.xxx;\n    }\n  \n    // Fake reflection. Doesn't really work well here.    \n    //vec3 ref = tex3D(iChannel1, (p + reflect(rd, n)*2.)/64., n).xyz;//*vec3(.5, .7, 1)*.2;\n    //color += ref*.25;      \n    \n    // add in border color\n    color = mix((color*2.5 + gr*.75), color, border2);\n    color *= border*.97 + .03;\n \n    \n    // multiply by diffuse/ambient\n    color = color*(diffuse + 0.25*ao + vec3(.5, .7, 1)*spec*2.);// + color*fres*fres*ao*.125;\n\n\n    // consider AO\n    color *= ao;\n    \n\n\treturn color;\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Compute min distance between point on vertical side of a hexagon \n// and corners of occupied cells. This checks just the four cells \n// needed.\n\nfloat vertEdgeDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n \n    // Get difference on integer hex grid\n    vec3 cell_diff = prev_cell - hit_cell;\n    \n    // Normal direction across cell boundary\n    vec2 n = CART_FROM_HEX(cell_diff.xy);\n    \n    // Perpendicular vector, scaled to correct length to check corners\n    vec2 np = vec2(-n.y, n.x) * 0.5 / hex_factor;\n        \n    // Coordinates of cell center\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // We only care about difference from center when measuring distances\n    p -= cell_pos;\n    \n    // These are \"rotation\" matrices that rotate directions on the\n    // integer hex grid.  \n    const mat2 M0 = mat2(0.5, 0.75, -1.0, 0.5);\n    const mat2 M1 = mat2(0.5, -0.75, 1.0, 0.5);\n    \n    // Get directions to left and right neighbors, along with sign\n    // for perpendicular to normal\n    vec3 h[2];\n    h[0] = vec3(M0 * cell_diff.xy, 1.0);\n    h[1] = vec3(M1 * cell_diff.xy, -1.0);\n    \n    // Initialize distance to large value\n    float rval = 1e5;\n    \n    // For each neighbor direction\n    for (int i=0; i<2; ++i) {\n        \n        // Check below and above on grid\n        for (float d=-1.0; d<=1.0; d+=2.0) {\n            \n            // Get the neighbor cell\n            vec3 neighbor_cell = hit_cell + vec3(h[i].xy, d);\n            vec3 neighbor_pos = neighbor_cell * cell_size;\n            \n            // If it's occupied\n            if (map(neighbor_pos/resolution) < 0.0) {\n                \n                // Get corner with this neighbor                  \n                vec3 corner = 0.5*(vec3(np*h[i].z, cell_height*d) - cell_diff*cell_size);\n                \n                // Check distance to corner\n                rval = min(rval, length(p - corner));\n                \n            }\n        }\n    }\n    \n    return rval;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Get minimum distance to all eight connected neighbors across a \n// face, except for the occupied one (which would have\n// distance of zero).\n\nfloat neighborDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n            \n    // Get cell center position\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // Only care about distances relative to center\n    p -= cell_pos;\n    \n    // Cancel out some multiplication that will happen down below\n    p.z *= 2.0/cell_height;\n    \n    // Set up four neighbors and distances to walls\n    vec4 h[4];\n    \n    h[0] = vec4(0.0,  1.0, 0.0, 1.0);\n    h[1] = vec4(1.0,  0.5, 0.0, 1.0);\n    h[2] = vec4(1.0, -0.5, 0.0, 1.0);\n    h[3] = vec4(0.0,  0.0, 0.5, 0.5*cell_height);\n    \n    // Initialize return value to large number\n    float rval = 1e5;\n   \n    // For each neighbor direction...\n    for (int i=0; i<4; ++i) {\n        \n        // ...and its opposite direction\n        for (float s=-1.0; s<=1.0; s+=2.0) {\n            \n            // Get the neighbor integer grid coords\n            vec3 neighbor_cell = prev_cell + 2.0*s*h[i].xyz;\n            \n            // Ignore the one we already know is occupied\n            if (neighbor_cell != hit_cell) {\n                \n                // Get neighbor center position\n                vec3 neighbor_pos = neighbor_cell * cell_size;\n                \n                // If occupied...\n                if (map(neighbor_pos/resolution) < 0.0) {\n                \n                    // Get normal\n                    vec3 n = s * h[i].xyz * cell_size;\n                    \n                    // Update using distance to neighbor along normal\n                    rval = min(rval, h[i].w - dot(n, p));\n                \n                }   \n            }\n        }\n    }\n    \n    // Return minimum distance\n    return rval;\n    \n}\n\n \n\n//////////////////////////////////////////////////////////////////////\n// Return the normal and intersection distance for ray with origin\n// ro and direction rd.\n\nvoid raytrace(in vec3 ro, in vec3 rd,\n              out vec4 hit_nt, \n              out vec3 prev_cell,\n              out vec3 cur_cell) {\n    \n \n    \n    // find nearest hex cell center to ray origin    \n    cur_cell = vec3(nearestHexCell(ro.xy), floor(ro.z/cell_height + 0.5));\n    \n    // we also will care about the cell we entered in from\n    prev_cell = cur_cell;\n    \n    // current cell center\n    vec3 cur_center = cur_cell * cell_size;\n\n    // see if ray is pointed up or down\n    float dz = rd.z < 0.0 ? -1.0 : 1.0;\n\n    // get the three candidate wall directions for this ray (i.e. the\n    // three hex side directions that correspond to normals with positive\n    // dot products to ray direction)\n    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);\n    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);\n    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);\n\n\t// have we hit a hex yet?    \n    bool hit = false;\n    \n    // initialize normal to zero and intersection distance to negative\n    hit_nt = vec4(0, 0, 0, -1.0);    \n\n    // march along ray, one iteration per cell\n    for (int i=0; i<grid_steps; ++i) {\n        \n        // once we hit we're good\n        if (hit) { continue; }\n        \n        // distance from ray origin to current cell center\n        vec3 rdelta = ro-cur_center;\n        \n        // first, test intersections with sides:\n        // after three tests, ht.xy holds the direction, ht.z holds the\n        // ray distance parameter with intersecting sides\n        vec3 ht = rayHexIntersect(rdelta.xy, rd.xy, h0);\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h1));\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h2));\n        \n        // next, test intersection with top/bottom \n        float tz = (0.5*dz*cell_height - rdelta.z) / rd.z;\n        \n        // now we will need to figure out how to update the current cell\n        // either horizontally or vertically.\n        \n        // stash the previous cell\n        prev_cell = cur_cell;        \n\n        // variable to hold return value if we do hit\n        vec4 new_nt;\n \n        // check whether we hit top/bottom before side\n        if (tz < ht.z) {\n            \n            // hit top/bottom first, so march vertically\n            cur_cell.z += dz;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(0, 0, -dz, tz);\n            \n        } else {\n            \n            // hit side first, so march horizontally\n            cur_cell.xy += 2.0*ht.xy;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(-CART_FROM_HEX(ht.xy), 0, ht.z);\n            \n        }\n        \n        // we updated the current cell, now update the cell center position\n        cur_center = cur_cell * cell_size;\n            \n        // see if the new cell center is occupied\n        if (map(cur_center/resolution) < 0.0) {\n            hit = true;\n            hit_nt = new_nt;\n        }\n        \n        \n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Return the color for a ray with origin ro and direction rd\n\nvec3 ray_shade(in vec3 ro, in vec3 rd) {\n    \n    // handle resolution scaling\n    ro *= resolution;\n\n    // hit_nt will hold normal and distance\n    vec4 hit_nt;\n    \n    // prev_cell and hit_cell store cell before and after intersection\n    vec3 prev_cell, hit_cell;\n    \n    // do raytrace\n    raytrace(ro, rd, hit_nt, prev_cell, hit_cell);\n    \n    svObjID = objID;\n    \n    // output color\n    vec3 color = vec3(0);\n    \n    //vec3 light_dir = normalize(lp - ro);\n    vec3 sk = sky(ro, rd);\n    color = sk;\n    \n    // if ray hit\n    if (hit_nt.w >= 0.0) {\n        \n        // get the cell center where it hit\n        vec3 cell_center = hit_cell * cell_size;\n        \n        // get the intersection point\n        vec3 pintersect = ro + rd * hit_nt.w;\n        \n        // store distance to border, to neighbor cell\n        float bdist, ndist;\n        \n        // see if we hit top/bottom or side\n        if (abs(hit_nt.z) > 0.0) {\n            \n            // was top/bottom\n            bdist = hexDist(pintersect.xy - cell_center.xy);\n            ndist = neighborDist(prev_cell, hit_cell, pintersect); \n            \n        } else {\n            \n            // was side\n            vec2 n = hit_nt.xy;\n            bdist = abs(fract(pintersect.z/cell_height)-0.5)*cell_height;\n                    \n            vec2 p = pintersect.xy - cell_center.xy;\n            p -= n * dot(p, n);\n            bdist = min(bdist, abs(length(p) - 0.5/hex_factor));\n            \n            ndist = neighborDist(prev_cell, hit_cell, pintersect);\n            ndist = min(ndist, vertEdgeDist(prev_cell, hit_cell, pintersect));\n\n        }\n        \n        // default case: assume shadow - note for \"realism\" we would set 0.0 here\n        float diffuse = 0.05;\n        \n        // A distant point light, so it's almost directional, but it still has a\n        // slight point light feel... if that makes any sense. :)\n        vec3 light_dir = normalize(lp - pintersect);\n        \n        // see if on lit side\n        if (dot(hit_nt.xyz, light_dir) > 0.0) {\n            \n            // shadow ray\n            vec4 shadow_nt;\n            raytrace(pintersect + 0.001*hit_nt.xyz, light_dir, \n                     shadow_nt, prev_cell, hit_cell);\n            \n            // full light if shadow ray missed\n            if (shadow_nt.w < 0.0) { diffuse = 1.0; }\n\n            \n        }\n        \n        // shade the hit point\n        color = shade(ro, rd, hit_nt, bdist, ndist, diffuse);\n\n        \n    } \n    \n    color = mix(color, sk, smoothstep(0., .95, hit_nt.w*.6/100.));\n    \n\treturn color;\n\t\n}\t\n \n\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\t\n\tconst float yscl = 800.0;\n\tconst float f = 450.0;\n\t\n    vec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uv = uvn*yscl;\n    \n    \n    vec3 rd = normalize(vec3(uv, f));\n    rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.15)); // Subtle lens distortion.\n\t\n\tvec3 ro = vec3(0, 0, iTime*5.);\n\tvec3 tgt = ro + vec3(0, 0, .25);\n\tvec3 up = vec3(0, 0, 1);\n    \n    \n    \n    lp = ro + vec3(FAR*.24, FAR*.52, FAR*.78);\n    \n\n\n    vec2 sw = path(tgt.z);\n    \n    ro.xy += path(ro.z);\n\ttgt.xy += sw;\n     \n    // The original uses a different coordinate system, so this is a quick hack\n    // to enable me to drop in a \"Z into the page\" coordinate system.\n    ro = ro.zxy;\n    tgt = tgt.zxy;\n    lp = lp.zxy;    \n\t\n\tvec3 rz = normalize(tgt - ro);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n    \n    mat3 R = mat3(rx,ry,rz);\n     \n\n    \n\tfloat thetax = sw.y/32.;\n\tfloat thetay = 0.; // sw.x/64.\n\n/*  \n    // Mouse camera direction overide.\n\tif (iMouse.y > 10.0 || iMouse.x > 10.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * -1.25/iResolution.y;\n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * 6.28/iResolution.x; \n\t}\n*/ \n    \n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(cx, 0, -sx, 0, 1, 0, sx, 0, cx);\n    mat3 Ry = mat3(cy, -sy, 0, sy, cy, 0, 0, 0, 1);\n\t\n    ro = Ry*Rx*(ro-tgt) + tgt;\n    rd = Ry*Rx*R*rd;\n\n    rd.yz *= r2(-sw.x/64.);\n\n    \n    vec3 color = ray_shade(ro, rd);\n    \n    // Some post processing. Wasn't used.\n    //color = mix(color, color.xxx, .8);\n    //color = mix(color.xxx, pow(color.xxx, vec3(1, 2, 3)), .35);\n    \n   \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    color *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    \n\tcolor = sqrt(color);\n\n    fragColor = vec4(color, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}