{
    "Shader": {
        "info": {
            "date": "1622121182",
            "description": "Learning shadow and trying to enhance my personal boiler plate code for shader performance",
            "flags": 0,
            "hasliked": 0,
            "id": "Nll3WN",
            "likes": 1,
            "name": "小龙猫 - Shadow Experiment",
            "published": 3,
            "tags": [
                "shadow"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "/*\n\nExperiment on Shadow  + Code Refinement\n\nThe scene is slighty more than just a surface and a volume.\nThe light is between the \"planets\" and the \"torus\" and moving on X axis (so left to right)\n* Little planet should have a shadow on the big planet and torus\n* Big planet should ahve shadow on the torus\n* The Torus **should not** cast any shadow \n\n(Big learning on my side for the algo, if you don't stop properly, \nit's \"bounce back the shadow\" which isn't what we want ... but maybe intersting for effects  ? Who knows ?)\n\n*/\n\n#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n  vec2 h;\n  h.x=length(p)-1.;\n  h.y=1.;\n  vec2 t;\n  t.y=1.;\n  \n  t.x=length(vec2(length(p.xz)-10.,p.y+1.+sin(fGlobalTime+atan(p.x,p.z)*3.)))-.5;\n  h=t.x<h.x?t:h;\n  \n   t.x = length(p+vec3(-0.5,+0.01,+1.9))-.1;\n    h=t.x<h.x?t:h;\n  return h;\n}\n\n#define q(s)s*sdf(p+s).x\nvec2 nv=vec2(-.01,.01);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yyx)+q(nv.yxy)+q(nv.xxx));}\n\nfloat raym(inout vec3 rp,vec3 rd, out vec2 mat) { // Yeah trying ways to organise all this sh***. Not sure will keep that way\n      \n      float i=0.;\n      float accDist = 0.; \n      for(;i<=69.;i++){\n          vec2 d = sdf(rp);\n          if(d.x<=0.001){\n               mat = d;\n               return accDist;\n          }\n          rp+=d.x*rd;\n          accDist +=d.x;\n      }\n      return accDist;\n }\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(.01);\n\n    vec3 ro=vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.)),rp=ro;\n    vec3 light=vec3(sin(fGlobalTime)*3.63,.0,-3.3);\n\n    vec2 mat;\n    float res = raym(rp,rd,mat);\n    if(res <= 40.){ // Which correspond to the usual \"far plane limit\" ? \n        vec3 n=norm(rp);\n        col=vec3(.05)+vec3(1.)*max(dot(normalize(light-rp),n),.0);\n    }\n\n    // Shadow compute, march along rp -> light, if you reach something it's a match for shadow, if you reach the light, call a monk\n    rd=normalize(light-rp);\n    float maxLightDist = length(light-rp); // The maximum travel to the light from the point, if the ray pass this limit, then it means nothing was between surface an light = no shadow\n    rp+=rd*.1; // Need to march a little bit to avoid the algo to be lost. I would call that \"L'Offset du cul\"\n    res = raym(rp,rd,mat); // reuse of function, WooOOOOooW\n    if(res < maxLightDist){\n     col *=vec3(.1); // Some people put a value, I tried with a mul, do what please you.\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}