{
    "Shader": {
        "info": {
            "date": "1403370610",
            "description": "Some raytraced fog.  Using definite integrals of sine waves to make some variation in the fog density.  Could probably be refined some more to look nicer.  No reflect or refract due to instruction count limits ):\nDrag the mouse to move the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldfXzB",
            "likes": 14,
            "name": "Ray Fog",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "fog"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 1289
        },
        "renderpass": [
            {
                "code": "// TODO: try different amplitudes and frequencies\n\n\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nstruct SMaterial\n{\n\tvec3 m_diffuseColor;\n\tfloat m_specular;\n\tvec3 m_specularColor;\n};\n\n//=======================================================================================\nstruct SCollisionInfo\n{\n\tint\t\t\tm_Id;\n\tbool\t\tm_foundHit;\n\tbool \t\tm_fromInside;\n\tfloat \t\tm_collisionTime;\n\tvec3\t\tm_intersectionPoint;\n\tvec3\t\tm_surfaceNormal;\n\tSMaterial \tm_material;\n};\n\n//=======================================================================================\nstruct SSphere\n{\n\tint\t\t\tm_Id;\n\tvec3   \t\tm_center;\n\tfloat  \t\tm_radius;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SAxisAlignedBox\n{\n\tint\t\t\tm_Id;\n\tvec3\t\tm_pos;\n\tvec3\t\tm_scale;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SPointLight\n{\n\tvec3\t\tm_pos;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SDirLight\n{\n\tvec3\t\tm_reverseDir;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SShadingStackItem\n{\n\tvec3\t\tm_addColor;\n\tvec4\t\tm_fogColorAndAmount;\n};\n\t\n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n\t\n//----- settings\n#define DO_SHADOWS true // setting this to false will speed up rendering\n\t\n//----- camera\n#define mouse (iMouse.xy / iResolution.xy)\n\nvec3 getCameraPos ()\n{\n\treturn iMouse.z > 0.0 ? vec3(mouse.x * -8.0 + 4.0, 1.0, mouse.y*8.0 - 8.0) : vec3(0,1.0,-4.0);\n}\n\nvec3 getCameraAt ()\n{\n\tvec3 pos = getCameraPos();\n\t\n\treturn pos + vec3(0.0,-1.0,4.0);\n}\n\n#define cameraPos\t getCameraPos()\n#define cameraAt \tgetCameraAt()\n\n#define cameraFwd  normalize(cameraAt - cameraPos)\n#define cameraLeft  normalize(vec3(-1.0,0.0,0.0))\n#define cameraUp   normalize(cross(cameraLeft, cameraFwd))\n\n#define cameraViewWidth\t6.0\n#define cameraViewHeight cameraViewWidth * iResolution.y / iResolution.x\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\n//----- shading stack\nSShadingStackItem shadingStack;\n\n//----- lights\nvec3 lightAmbient\t\t\t\t= vec3(0.1,0.1,0.1);\n\nvec3 fogColor = vec3(0.5,0.5,0.5);\n\nSDirLight lightDir1 =\n\tSDirLight\n\t(\n\t\tnormalize(vec3(-1.0,1.0,-1.0)),\n\t\tvec3(1.0,1.0,1.0)\n\t);\n\nSPointLight GetLightPoint1()\n{\n\treturn SPointLight\n\t(\n\t\tvec3(sin(1.57 + iTime*1.3),0.3,cos(1.57 + iTime*1.3)),\n\t\tvec3(0.7,0.3,0.7)\n\t);\n}\n\n\n#define lightPoint1 GetLightPoint1()\n\n//----- primitives\nSSphere GetLightPoint1Sphere()\n{\n\treturn SSphere\n\t(\n\t\t1,\t\t\t\t\t\t//id\n\t\tlightPoint1.m_pos,\t\t//center\n\t\t0.06,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tlightPoint1.m_color,//diffuse color\n\t\t\t1.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0)\t//specular color\n\t\t)\n\t);\t\n}\n\n#define lightPoint1Sphere GetLightPoint1Sphere()\n\nSSphere GetSphere1()\n{\n\treturn SSphere\n\t(\n\t\t2,\t\t\t\t\t\t//id\n\t\tvec3(0.0,0.0,0.0),\t\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.0,1.0,0.0),\t//diffuse color\n\t\t\t10.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define sphere1 GetSphere1()\n\nSSphere GetSphere2()\n{\n\treturn SSphere\n\t(\n\t\t3,\t\t\t\t\t\t//id\n\t\tvec3(sin(iTime*1.3),sin(3.14 + iTime * 1.4)*0.25,cos(iTime*1.3)),\t//center\n\t\t0.15,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.0,1.0,1.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define sphere2 GetSphere2()\n\nSAxisAlignedBox GetOrbitBox()\n{\n\treturn SAxisAlignedBox\n\t(\n\t\t4,\t\t\t\t\t\t//Id\n\t\tvec3(sin(2.0 + iTime*1.3),-0.2,cos(2.0 + iTime*1.3)),\t//center\n\t\tvec3(0.5,0.5,0.5),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(1.0,0.0,0.0),\t//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define orbitBox GetOrbitBox()\n\nSAxisAlignedBox GetFloorBox()\n{\n\treturn SAxisAlignedBox\n\t(\n\t\t5,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,-1.6,0.0),\t\t//center\n\t\tvec3(10.0,0.1,10.0),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(1.0,1.0,1.0),\t//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define floorBox GetFloorBox()\n\nSAxisAlignedBox GetbackBox1()\n{\n\treturn SAxisAlignedBox\n\t(\n\t\t6,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,0.0,3.0),\t\t//center\n\t\tvec3(10.0,3.0,0.1),\t\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.0,0.0,0.8),  //diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define backBox1 GetbackBox1()\n\nSSphere GetfloorSphere1()\n{\n\treturn SSphere\n\t(\n\t\t7,\t\t\t\t\t\t//id\n\t\tvec3(1.5, -1.0, 0.0),\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.8,0.8,0.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\nSSphere GetfloorSphere2()\n{\n\treturn SSphere\n\t(\n\t\t8,\t\t\t\t\t\t//id\n\t\tvec3(1.5, -1.0, 1.0),\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.8,0.8,0.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\nSSphere GetfloorSphere3()\n{\n\treturn SSphere\n\t(\n\t\t9,\t\t\t\t\t\t//id\n\t\tvec3(1.5, -1.0, 2.0),\t//center\n\t\t0.2,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\tvec3(0.8,0.8,0.0),\t//diffuse color\n\t\t\t3.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0)\t//specular color\n\t\t)\n\t);\n}\n\n#define floorSphere1 GetfloorSphere1()\n#define floorSphere2 GetfloorSphere2()\n#define floorSphere3 GetfloorSphere3()\n\n//----- macro lists\n\n// sphere primitive list\n#define SPHEREPRIMLIST PRIM(sphere1) PRIM(sphere2) PRIM(floorSphere1) PRIM(floorSphere2) PRIM(floorSphere3)\n\n// sphere primitive list with light primitives\n#define SPHEREPRIMLISTWITHLIGHTS SPHEREPRIMLIST PRIM(lightPoint1Sphere)\n\n// box primitive list\n#define BOXPRIMLIST PRIM(orbitBox) PRIM(floorBox) PRIM(backBox1)\n\n// point light list\n#define POINTLIGHTLIST LIGHT(lightPoint1)\n\n// directional light list\n#define DIRLIGHTLIST LIGHT(lightDir1)\n\n//=======================================================================================\nbool RayIntersectSphere (in SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == sphere.m_Id)\n\t\treturn false;\n\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.m_center;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.m_radius * sphere.m_radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//not inside til proven otherwise\n\tbool fromInside = false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t{\n\t\tcollisionTime = -b + sqrt(discr);\n\t\tfromInside = true;\n\t}\n\n\t//enforce a max distance if we should\n\tif(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)\n\t\treturn false;\n\n\t// set all the info params since we are garaunteed a hit at this point\n\tinfo.m_fromInside = fromInside;\n\tinfo.m_collisionTime = collisionTime;\n\tinfo.m_material = sphere.m_material;\n\n\t//compute the point of intersection\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// calculate the normal\n\tinfo.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;\n\tinfo.m_surfaceNormal = normalize(info.m_surfaceNormal);\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = sphere.m_Id;\n\treturn true;\n}\n\n//=======================================================================================\nbool RayIntersectAABox (in SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == box.m_Id)\n\t\treturn false;\n\t\n\tfloat rayMinTime = 0.0;\n\tfloat rayMaxTime = FLT_MAX;\n\t\n\t//enforce a max distance\n\tif(info.m_collisionTime >= 0.0)\n\t{\n\t\trayMaxTime = info.m_collisionTime;\n\t}\t\n\t\n\t// find the intersection of the intersection times of each axis to see if / where the\n\t// ray hits.\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\t//calculate the min and max of the box on this axis\n\t\tfloat axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;\n\t\tfloat axisMax = axisMin + box.m_scale[axis];\n\n\t\t//if the ray is paralel with this axis\n\t\tif(abs(rayDir[axis]) < 0.0001)\n\t\t{\n\t\t\t//if the ray isn't in the box, bail out we know there's no intersection\n\t\t\tif(rayPos[axis] < axisMin || rayPos[axis] > axisMax)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//figure out the intersection times of the ray with the 2 values of this axis\n\t\t\tfloat axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];\n\t\t\tfloat axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];\n\n\t\t\t//make sure min < max\n\t\t\tif(axisMinTime > axisMaxTime)\n\t\t\t{\n\t\t\t\tfloat temp = axisMinTime;\n\t\t\t\taxisMinTime = axisMaxTime;\n\t\t\t\taxisMaxTime = temp;\n\t\t\t}\n\n\t\t\t//union this time slice with our running total time slice\n\t\t\tif(axisMinTime > rayMinTime)\n\t\t\t\trayMinTime = axisMinTime;\n\n\t\t\tif(axisMaxTime < rayMaxTime)\n\t\t\t\trayMaxTime = axisMaxTime;\n\n\t\t\t//if our time slice shrinks to below zero of a time window, we don't intersect\n\t\t\tif(rayMinTime > rayMaxTime)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//if we got here, we do intersect, return our collision info\n\tinfo.m_fromInside = (rayMinTime == 0.0);\n\tif(info.m_fromInside)\n\t\tinfo.m_collisionTime = rayMaxTime;\n\telse\n\t\tinfo.m_collisionTime = rayMinTime;\n\tinfo.m_material = box.m_material;\n\t\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// figure out the surface normal by figuring out which axis we are closest to\n\tfloat closestDist = FLT_MAX;\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\tfloat distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));\n\n\t\tif(distFromEdge < closestDist)\n\t\t{\n\t\t\tclosestDist = distFromEdge;\n\t\t\tinfo.m_surfaceNormal = vec3(0.0,0.0,0.0);\n\t\t\tif(info.m_intersectionPoint[axis] < box.m_pos[axis])\n\t\t\t\tinfo.m_surfaceNormal[axis] = -1.0;\n\t\t\telse\n\t\t\t\tinfo.m_surfaceNormal[axis] =  1.0;\n\t\t}\n\t}\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = box.m_Id;\n\treturn true;\t\n}\n\n//=======================================================================================\nbool PointCanSeePoint(in vec3 startPos, in vec3 targetPos, in int ignorePrimitiveId)\n{\n\t// see if we can hit the target point from the starting point\n\tSCollisionInfo collisionInfo =\n\t\tSCollisionInfo\n\t\t(\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\t-1.0,\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tSMaterial(\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t1.0,\n\t\t\t\tvec3(0.0,0.0,0.0)\n\t\t\t)\n\t\t);\t\n\t\n\tvec3 rayDir = targetPos - startPos;\n\tcollisionInfo.m_collisionTime = length(rayDir);\n\trayDir = normalize(rayDir);\n\n\t// run intersection against all non light primitives. return false on first hit found\n\treturn true\n\t#define PRIM(x) && !RayIntersectSphere(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n\tSPHEREPRIMLIST\n\t#undef PRIM\n\t#define PRIM(x) && !RayIntersectAABox(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n\tBOXPRIMLIST\n\t#undef PRIM\n\t;\n}\n\n//=======================================================================================\nvoid ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in vec3 rayDir)\n{\n\tif (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, light.m_pos, collisionInfo.m_Id))\n\t{\n\t\t// diffuse\n\t\tvec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, hitToLight);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;\n\t\t\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;\n\t}\n}\n\n//=======================================================================================\nvoid ApplyDirLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SDirLight light, in vec3 rayDir)\n{\n\tif (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, collisionInfo.m_intersectionPoint + light.m_reverseDir * 1000.0, collisionInfo.m_Id))\n\t{\n\t\t// diffuse\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, light.m_reverseDir);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;\n\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(light.m_reverseDir, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;\t\t\t\n\t}\n}\n\n//=======================================================================================\nfloat DefiniteIntegral (in float x, in float amplitude, in float frequency, in float motionFactor)\n{\n\t// Fog density on an axis:\n\t// (1 + sin(x*F)) * A\n\t//\n\t// indefinite integral:\n\t// (x - cos(F * x)/F) * A\n\t//\n\t// ... plus a constant (but when subtracting, the constant disappears)\n\t//\n\tx += iTime * motionFactor;\n\treturn (x - cos(frequency * x)/ frequency) * amplitude;\n}\n\n//=======================================================================================\nfloat AreaUnderCurveUnitLength (in float a, in float b, in float amplitude, in float frequency, in float motionFactor)\n{\n\t// we calculate the definite integral at a and b and get the area under the curve\n\t// but we are only doing it on one axis, so the \"width\" of our area bounding shape is\n\t// not correct.  So, we divide it by the length from a to b so that the area is as\n\t// if the length is 1 (normalized... also this has the effect of making sure it's positive\n\t// so it works from left OR right viewing).  The caller can then multiply the shape\n\t// by the actual length of the ray in the fog to \"stretch\" it across the ray like it\n\t// really is.\n\treturn (DefiniteIntegral(a, amplitude, frequency, motionFactor) - DefiniteIntegral(b, amplitude, frequency, motionFactor)) / (a - b);\n}\n\n//=======================================================================================\nfloat FogAmount (in vec3 src, in vec3 dest, in float fogMod)\n{\n\tfloat len = length(dest - src);\n\t\n\t// calculate base fog amount (constant density over distance)\t\n\tfloat amount = len * 0.1;\n\t\n\t// calculate definite integrals across axes to get moving fog adjustments\n\tfloat adjust = 0.0;\n\tadjust += AreaUnderCurveUnitLength(dest.x, src.x, 0.01, 0.6, 2.0);\n\tadjust += AreaUnderCurveUnitLength(dest.y, src.y, 0.01, 1.2, 1.4);\n\tadjust += AreaUnderCurveUnitLength(dest.z, src.z, 0.01, 0.9, 2.2);\n\tadjust *= len;\n\t\n\treturn min(amount+adjust+fogMod, 1.0);\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, in float fogMod)\n{\n\tint lastHitPrimitiveId = 0;\n\t\n\tvec3 rayToCameraDir = rayDir;\n\t\n\tvec3 pixelColor = vec3(0.0,0.0,0.0);\t\n\tSCollisionInfo collisionInfo =\n\t\tSCollisionInfo\n\t\t(\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\t-1.0,\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tSMaterial(\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t1.0,\n\t\t\t\tvec3(0.0,0.0,0.0)\n\t\t\t)\n\t\t);\n\n\t// run intersection against all objects, including light objects\t\t\n\t#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\tSPHEREPRIMLISTWITHLIGHTS\n\t#undef PRIM\n\t\t\t\n\t// run intersections against all boxes\n\t#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\tBOXPRIMLIST\n\t#undef PRIM\n\n\tif (collisionInfo.m_foundHit)\n\t{\t\n\t\t\t\n\t\t// do texture sampling for the floorbox\n\t\tif (collisionInfo.m_Id == floorBox.m_Id)\n\t\t{\n\t\t\tcollisionInfo.m_material.m_diffuseColor = \n\t\t\ttexture(iChannel0, collisionInfo.m_intersectionPoint.xz * 0.25).xyz;\n\t\t}\n\t\t\t\n\t\t// point lights\n\t\t#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, rayDir);\n\t\tPOINTLIGHTLIST\n\t\t#undef LIGHT\n\t\t\t\t\n\t\t// directional lights\n\t\t#define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, rayDir);\n\t\tDIRLIGHTLIST\t\t\t\t\n\t\t#undef LIGHT\n\n\t\t// ambient light\n\t\tpixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor;\n\t\t\t\t\t\n\t\tvec4 fog = vec4(fogColor, FogAmount(rayPos, collisionInfo.m_intersectionPoint, fogMod));\n\n\t\tshadingStack.m_addColor = pixelColor;\n\t\tshadingStack.m_fogColorAndAmount = fog;\n\t}\n\t// no hit means all fog\n\telse\n\t\tshadingStack.m_fogColorAndAmount = vec4(fogColor,1.0);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t\n\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\trayPos = cameraPos;\n\t\n\tvec3 rayDir = normalize(rayTarget);\n\n\tfloat fogMod = mod( fragCoord.x + fragCoord.y, 2.0 ) / 255.0;\n\t\n\tTraceRay(rayPos, rayDir, fogMod);\n\t\n\tvec3 pixelColor = mix(shadingStack.m_addColor, shadingStack.m_fogColorAndAmount.xyz, shadingStack.m_fogColorAndAmount.w);\n\t\n\tfragColor = vec4(pixelColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}