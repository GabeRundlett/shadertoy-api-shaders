{
    "Shader": {
        "info": {
            "date": "1507494255",
            "description": "practical application of analytical AA for disks ( https://www.shadertoy.com/view/XtfyWs ) and\nSpherical Fibonacci Mapping ( http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/ )\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XlfyWl",
            "likes": 62,
            "name": "oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo",
            "published": 3,
            "tags": [
                "ooooo"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 8069
        },
        "renderpass": [
            {
                "code": "// oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\npractical application of analytical AA for disks ( https://www.shadertoy.com/view/XtfyWs ) and\nSpherical Fibonacci Mapping ( http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/ )\npartly inspired by \"A Spiral of Circles\" by knarkowicz ( https://www.shadertoy.com/view/Md2yWR )\n*/\n\n#define SPOT_COUNT_MUL 12.0\n\n// uses 5x super sampling on top of the analytical AA; mainly improves quality at acute viewing angles\n// #define USE_SSAA\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi2  = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define If(cond, tru, fls) mix(fls, tru, cond)\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n// Spherical Fibonacci Mapping\n// http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/\n// Authors: Benjamin Keinert, Matthias Innmann, Michael Sänger, Marc Stamminger\n// (code copied from: https://www.shadertoy.com/view/4t2XWK)\n//-------------------------------------------------------------------------------------------------//\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nProjSphereArea - returns the screen space area of the projection of a sphere (assuming its an ellipse)\n\nIN:\n\trdz- z component of the unnormalized ray direction in camera space\n\tp  - center position of the sphere in camera space\n\trr - squared radius of the sphere\n\n\"Sphere - projection\" code used under\nThe MIT License\nCopyright © 2014 Inigo Quilez\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nfloat ProjSphereArea(float rdz, vec3 p, float rr)\n{\n\tfloat zz = p.z * p.z;\t\n\tfloat ll = dot(p, p);\n\t\n\t//return Pi * rdz*rdz * rr * sqrt(abs((rr - ll) / (zz - rr))) / (zz - rr);\n    return Pi * rdz*rdz * rr * rsqrt(abs(Pow3(rr - zz) / (rr - ll)));\n}\n\n// https://www.shadertoy.com/view/XtfyWs\nvec4 ProjDisk(vec3 rd, vec3 p, vec3 n, float rr)\n{   \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;  \n\n    mat3 k_mat = mat3(vec3( np0.y + np0.z,  np2.x        ,  np1.x        ),\n\t\t\t\t\t\t  vec3(-np2.y        ,  np1.y        , -np0.x - np0.z),\n\t\t\t\t\t\t  vec3(-np1.z        , -np0.x - np0.y,  np2.z        ));    \n    \n    vec3 u =     k_mat * rd;\n    vec3 k = u * k_mat;\n    \n    \n    float nrd = dot(n, rd);\n    \n    float nrd_rr = nrd * rr;\n\n    \n    float v = dot(u, u) - nrd * nrd_rr; \n    vec3  g =    (k     - n   * nrd_rr) * 2.0;   \n    \n    return vec4(g.xy, 0.0, v);\n}\n\n\n\nfloat Sph(float x, float rr) { return sqrt(rr - x*x); }\nfloat SphX0(float d, float rr0, float rr1) { return 0.5 * (d + (rr0 - rr1) / d); }\n\nvec3 EvalSceneCol(vec3 cpos, mat3 cam_mat, float focalLen, vec2 uv0)\n{      \n    const vec3 cBG = 0.014 * vec3(0.9, 1.0, 1.2);\n\n        \n    vec2 uv2 = uv0 - PixelCount.xy * 0.5;\n    \n  \tvec3 rdir0 = vec3(uv2, focalLen);\n    \n    float rdir0S = 0.5 * PixelCount.x;\n    rdir0 /= rdir0S;\n    \n    vec3 rdir = normalize(cam_mat * rdir0); \n    \n    \n    vec2 t;\n\tfloat hit = Intersect_Ray_Sphere(cpos, rdir, vec3(0.0), 1.0, OUT t);\n    \n    if(hit <= 0.0) return cBG;\n\n\n    vec3 pf = cpos + rdir * t.x;\n    vec3 pb = cpos + rdir * t.y;\n\n\tvec3 col = cBG;\n\n    //float lerpF = 0.0;\n    \n    float rra = 0.0;\n\n    vec3 p2;\n    float rr;\n    {\n\tconst float s = SPOT_COUNT_MUL;        \n    const float n = 1024.0*s;\n        \n    float id = sf2id(pf.xzy, n);\n    \t  p2 = id2sf(id,     n).xzy;        \n\n    float u = id / n;\n    float arg = (-u* 615.5*2.0*s) + Time * 1.0;//238-3 384.-2 615-1\n        \n    rra = sin(arg);\n    \n    #if 0    \n\t//for(float i = 0.0; i < 2.0; ++i)        \n\trra = (Pow2(rra)*2.-1.);\n    #endif\n        \n\trra = mix(abs(rra), Pow2(rra), 0.75);        \n      \n    rr = 0.0025/s * rra; \n    }\n    \n    \n    vec3 n2 = normalize(p2);\n    \n    const float maskS = 0.5;// sharpness\n\n    \n    if(SqrLen(pf - p2) > rr) return cBG;\n\n    float d = length(p2);\n\n    float x0 = SphX0(d, 1.0, rr);        \n    vec3 d0c = n2 * x0;\n\n    float d0rr = 1.0 - x0*x0;\n\n    vec3 dp_c = (d0c - cpos) * cam_mat;\n    vec3 dn_c = n2 * cam_mat;\n\n    vec4 r = ProjDisk(rdir0, dp_c, dn_c, d0rr);        \n\n    float cmask = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n\n    float cmask2 = 0.0;\n    {\n        vec3 d1c = n2 * (x0 - 0.005);\n\n        vec4 r = ProjDisk(rdir0, (d1c - cpos) * cam_mat, n2 * cam_mat, (1.0 - x0*x0)*rra);\n        cmask2 = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n    }\n\n\n    #if 1\t\n    float A = ProjSphereArea(rdir0.z, dp_c, d0rr);        \n    A *= rdir0S*rdir0S;\n\n    float NdV = abs(dot(dn_c, normalize(dp_c)));\n\n    A *= NdV;\n    \n    #ifndef USE_SSAA\n    A *= NdV;\n    cmask *= clamp01((A -2.0)*0.125);\n    #else\n    A = mix(A, A*NdV, 0.5);\n    cmask *= clamp01((A - 3.)*0.125);\n    #endif\n\n\n    #endif\n\n\n    const vec3 cB = vec3(0.1, 0.4, 1.0);\n    const vec3 cR = vec3(1., 0.02, 0.2);\n\n    //vec3 cX = mix(cB, cR, lerpF);\n    //vec3 cY = mix(cR, cB, lerpF);\n\n    return mix(cBG, mix(cR, vec3(0.0), cmask2), cmask);        \n    //return mix(cBG, mix(cR, cB, cmask2), cmask);\n    //return mix(cBG, mix(cX, cY, cmask2), cmask);        \n    //return mix(cBG, mix(cW, cX, cmask2), cmask);\n    //return mix(cBG, vec3(1.0), cmask);\n    //return vec3(-r.w*10.0);\n    //return vec3(1.0);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n  \n    \n    //vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.3);\n    //ang += mouseAccu.xy * 0.008;\n\n    #if 1\n    ang.x += Time * 0.15;\n    //ang.y = sin(Time * 0.2 * Pi) *0.2;\n    \n    //ang.y += Time * 0.073;\n    #endif\n\n    float fov = Pi * 0.5;\n    \n    mat3 cam_mat;\n    float focalLen;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        vec3 up    = cross(right, front);\n\n        focalLen = PixelCount.x * 0.5 * tan(Pi05 - fov * 0.5);\n        \n        cam_mat = mat3(right, up, front);\n    }\n    \n    //vec3 cpos = -cam_mat[2] * (exp2(-0.3 + mouseAccu.w * 0.03));\n    vec3 cpos = -cam_mat[2] * (exp2(-0.3));\n\n    cpos.y += .75;\n\n    \n    #ifndef USE_SSAA\n    \n\tcol = EvalSceneCol(cpos, cam_mat, focalLen, uv0);\n    \n\t#elif 1\n    \n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9));   \n    col *= 0.2;\n    \n \t#elif 1\n    \n    float o = 1.;\n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1) * o - 0.5*o+0.5) * vec3(1.5, 0.75, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3) * o - 0.5*o+0.5) * vec3(0.0, 0.0, 3.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5) * o - 0.5*o+0.5) * vec3(0.0, 3.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7) * o - 0.5*o+0.5) * vec3(3.0, 0.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9) * o - 0.5*o+0.5) * vec3(0.0, 0.75, 1.5);   \n    \n    col /= vec3(4.5, 4.5, 4.5);\n\n    #endif\n\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}