{
    "Shader": {
        "info": {
            "date": "1537386586",
            "description": "a large and still quite messy library\nit dares to define automatic differenciation #define's´s that work on multiple different structs and vector types\ni fixed my oöd aöpha compositing, so you see all the demo layers on top of another....",
            "flags": 0,
            "hasliked": 0,
            "id": "MlKcRt",
            "likes": 6,
            "name": "AutomaticDifferenciation lib",
            "published": 3,
            "tags": [
                "derivative",
                "library",
                "ad",
                "chainrule",
                "common",
                "hgsdg"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//alphacompositing fixed\n//lacks root-solving shapes (parabola-ellipse)\n//canvas \"TinyBri300OHGDAPo14\"\n//lots of code from [inogo quilez] [mercury] [dr2] [David Hoskins]\n//has iFrame fixed\n//has unified smin() smooth-Boolean-fuzzy-logic variants\n//has complex 2d transforms (possibly buggy,checked as much as i care and know this stuff)\n//has some rgba-colorspace-gradients/indicators (but surely not all that i care for,cieluelch is missing)\n//has noise (upper ones are better for (hyperplanes of) less domains\n//- tri,which is food for very fast volumetric storms\n//- h41=[fastest fbm with normals],that is just fast fbm noise with (poorly estimated) 3d normals\n//- hfd=[hash(fract(dot()))],that does not use sin(fract(a)),by David Hopkins\n//- cel=cellular noise,parallelized/fast vorley noise with 2 shortest distances in 2d or 3d,with hash as additional static domain.\n//- s13=[simplex],highest quality/performance noise,generally too slow for 3d spheretracking (as displacement or heightmap)\n//- - lacks bayerMatrix,blueHash<-part of higher-domain content.\n//has DA derivative arithmetic\n//- has issues with Param2:\n//- - decapitated filling lists with zeroes,seems VERY nonsensical\n//- - DA mixing differs from MAT mixin,not just in structure.\n//- - ... previous DA shaders made the error od declaring DA-mixing as MAT-mixind with DA-parameters?\n//- - ... or was that just cases where MAT is identical to DA?\n//has alias-folds fixed,with mercury.sexy/hg_sdf\n//- are declared as defines,for\n//- - N-dimensional inputs,where that function still makes sense in higher dimensions\n//- - uses the same labels as DA,so depending on input it can also calculate derivatives\n//- Includes minified HG_SDF by Mercury mercury.sexy/hg_sdf\n//- omitted platonic solids because the original code uses arrays\n//- Some functions are converted to macros because they would be even smaller when preprocessed.\n//- Another macro,_M,is really filling up almost identical code as to make the result even smaller,\n\n//has AD=automatic Differentiation via chain rule but only demoes it in 1d\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n\n#define vec1 float\n#define norma normalize\n//#define ss smoothstep\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define cl(a,b,c) mi(ma(a,0.),1.)//till i define this for AD\n#define sat(x) cl(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define u5cos(a) u5(cos(a))\nstruct v11{vec1 a;vec1 b;};\nstruct v22{vec2 a;vec2 b;};\nstruct v33{vec3 a;vec3 b;};//for 2 domains(density/distance field)\nstruct v44{vec4 a;vec4 b;};\nstruct v444{vec4 a;vec4 b;vec4 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v333{vec3 a;vec3 b;vec3 c;};\nstruct v3333{vec3 a;vec3 b;vec3 c;vec3 d;};\nstruct v222{vec2 a;vec2 b;vec2 c;};\n//v222 g222(vec3 a,vec3 b){return v222(vec2(a.x,b.x),vec2(a.y,b.y),vec2(a.z,b.z));}\nv222 g222(v33 a){return v222(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv3333 muv(v3333 a,vec4 b){return v3333(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nvec4 ddv(v3333 a){return vec4(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD,wherelater spaces are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\nstruct DAm2{w13 x;w13 y;w13 z;};//for 3 domains (density/distance field) \nstruct DAm1{w12 x;w12 y;};//for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w11 x;};//for 2 domains (heightmap,isoline,contour)\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n\n\n\n\n\n\n\nw11 ma(w11 a,vec1 b){return w11(max(a.a,b),max(a.b,b));}\nw11 mi(w11 a,vec1 b){return w11(min(a.a,b),min(a.b,b));}\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n//DAm2 maxdm(DAm2 a,v2 p){return DAm2(maxd(a.a,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\n//DAm2 mindm(DAm2 a,v2 p){return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\n//DAm2 maxdm(DAm2 a,vec1 p){return maxdm(a,v2(p));}\n//DAm2 mindm(DAm2 a,vec1 p){return mindm(a,v2(p));}//needed for fast clamping\n//w13 maxdm(w13 a,w13 b,w13 c){return maxd(maxd(a,b),c);}\n//w13 maxdm(DAm2 a){return maxdm(a.a,a.y,a.z);}\n//The 3(or 2)dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN p)]:\n//where N=number of domains,range [0..3]\nv444 da_domain(vec3 p){return v444(vec4(p.x,1,0,0),vec4(p.y,0,1,0),vec4(p.z,0,0,1));}\nv33 da_domain(vec2 p){return v33(vec3(p.x,1,0),vec3(p.y,0,1));}\nvec2 da_domain(vec1 p){return vec2(p,1);}//for 1 domain(linear equation)\n//vNN() declares c11() c22() c33() c44()... for implicit typecasting into structs; v11 v22 v33 v44\nv11 c11(vec1 a,vec1 b){return v11(a,b);}\nv11 c11(vec1 a){return v11(a,a);}\n#define vNNv(z,x) {return z(x(a),x(b));}\n#define vNNu(z,x,y) z x(vec1 a,y b)vNNv(z,y) z x(y a,vec1 b)vNNv(z,y) z x(vec1 a,vec1 b)vNNv(z,y)\n#define vNN(z,y,x) vNNu(z,y,x) z y(x a,x b){return z(a,b);} z y(x a){return z(a,a);}\nvNN(v22,c22,vec2)\nvNN(v33,c33,vec3)\nvNN(v44,c44,vec4)\n\n\n//param1MAT dreaming of vec5 and vec2x2,also,this keeps define-namespace unused,by declating function sets!\n//lets me type \" a=min(vec3(a),float(b)) a=pow(vec3(a),float(b)) \" with less explicit typecasting and shorter aliases:\n//negate,reciprocal,abs,log,sin,asin,cos,acos,tan,atan,fract,floor\n#define NE(y,z) z ne(z a){return -a;}y ne(y a){return y(-a.a,-a.b);}\nNE(v11,vec1)NE(v22,vec2)NE(v33,vec3)NE(v44,vec4)\nw13 ne(w13 a){return w13(-a.a,-a.b);}\nw12 ne(w12 a){return w12(-a.a,-a.b);}\nw11 ne(w11 a){return w11(-a.a,-a.b);}\n#define def1E(z,y,x) x z(x a){return y(a);}\n#define def1(a,b) def1E(a,b,vec1) def1E(a,b,vec2) def1E(a,b,vec3) def1E(a,b,vec4)\n#define re(a) di(1.,b)\ndef1(ab,abs)def1(sg,sign)def1(sq,sqrt)\ndef1(ln,log)def1(ex,exp)\ndef1(si,sin)def1(asi,asin)\ndef1(co,cos)def1(aco,acos)\ndef1(ta,tan)def1(ata,atan)\ndef1(fr,fract)\ndef1(fl,floor)\n//----param2MAT\n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(ne(a)))\n#define def2U(z,y,x) x z(vec1 a,x b){return y(x(a),b);} x z(x a,vec1 b){return y(a,x(b));}\n#define def2E(z,y,x) x z(x a,x b){return y(a,b);}\n#define def2(a,b) def2E(a,b,vec1) def2E(a,b,vec2) def2E(a,b,vec3) def2E(a,b,vec4)\n#define defU(a,b) def2(a,b) def2U(a,b,vec2) def2U(a,b,vec3) def2U(a,b,vec4)\n#define sub(a,b) ((a)-(b))\n#define add(a,b) ((a)+(b))//sub(a,ne(b))\n#define div(a,b) ((a)/(b))\n#define mul(a,b) ((a)*(b)) //di(a,re(b)) reciprocal define may lose time&precision\n//a lot of these just reserve namespaces //dot() is special for folding to a vec1 uses defD()\n#define def2D(z,y,x) vec1 z(vec1 a,x b){return y(x(a),b);} vec1 z(x a,vec1 b){return y(a,x(b));}\n#define def2F(z,y,x) vec1 z(x a,x b){return y(a,b);}\n#define defF(a,b) def2F(a,b,vec1) def2F(a,b,vec2) def2F(a,b,vec3) def2F(a,b,vec4)\n#define defD(a,b) defF(a,b) def2D(a,b,vec2) def2D(a,b,vec3) def2D(a,b,vec4)\n//vNN operands foldlike this:\n#define vXX(z,y) z(y(a.a,b),y(a.b,b))\n#define vXY(z,y) z(y(a.a,b.a),y(a.b,b.a))\n#define vvZ(z,w,v,y) w z(w a,v b){return y(w,z);}w z(w a,vec1 b){return y(w,z);}w z(v11 a,v b){return y(w,z);}\n#define vvY(z,w,v,y) w z(w a,v b){return y(w,z);}w z(v a,w b){return y(w,z);}w z(w a,w b){return y(w,z);}\n#define vvX(y,w,v) vvZ(y,w,v,vXX) vvY(y,w,v11,vXY)\n#define vMM(z) vvX(z,v22,vec2)vvX(z,v33,vec3)vvX(z,v44,vec4)v11 z(v11 a,v11 b){return vXY(v11,z);}v11 z(v11 a,vec1 b){return vXX(v11,z);}\n//alias2_NinputAsVec; due to symmetrically defined alising,in favor of min() max() functions (previously called miv() mav()):\n//note that dt(vec4 a)==dot(dot(a.x,a.y),dot(a.z,a.w)),equivalent to ad(vec4 a)\n//note that po(vec4 a)==pow(pow(a.x,a.y),pow(a.z,a.w)),which is quite silly\n//note that su(vec4 a)==(a.x-a.y)-(a.z-a.w)=a.x+a.w-a.y-a.z=a.x+a.w-(a.y+a.z)\n//note that di(vec4 a)==(a.x/a.y)/(a.z/a.w)=a.x*a.w/a.y/a.z=a.x*a.w-(a.y*a.z)\n//alternatively fo() couls also be defined as dot(a,1.),where parts of a are negated or reciprocal\n#define Fo1(u,t) vec1 u(t a){return u(a.x,a.y);}\n#define Fo2(u,t) vec1 u(t a){return u(u(a.xy),a.z);}\n#define Fo3(u,t) vec1 u(t a){return u(u(a.xy),u(a.zw));}\n#define Fon(u) Fo1(u,vec2) Fo2(u,vec3) Fo3(u,vec4)\n#define defM(a,b) defU(a,b) vMM(a) Fon(a)\ndefM(po,pow)\ndefM(mi,min)defM(ma,max)\ndefM(su,sub)defM(di,div)\ndefM(ad,add)defM(mu,mul)\ndefM(mo,mod)\ndefM(st,step)\n//higher domains for high-domain-permutations/zOrder/Noise\n//v33 su(vec3 a,v33 b){return v33(a-b.a,a-b.b);}\nv33 g33(vec2 a){return v33(vec3(a.x),vec3(a.y));}\nv333 su(vec3 a,v333 b){return v333(a-b.a,a-b.b,a-b.c);}\nv333 g333(v33 a,vec3 b){return v333(a.a,a.b,b);}\nv3333 g3333(vec3 a,v333 b){return v3333(a,b.a,b.b,b.c);}\nv44 fl(v44 a){return v44(fl(a.a),fl(a.b));}\nv44 fr(v44 a){return v44(fr(a.a),fr(a.b));}\n//polar Complex dot()\nconst vec3 vs=vec3(-1,0,1);\n#define le(a) sq(dd(a))\ndefD(dt,dot)\n#define dd(a) dot(a,a)\n//vMM(dt)//breaks a pattern,due to being a foldingprojection\nFon(dt)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n//\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(vec1 a){return cs(vec2(a,a));}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)-(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\nmat2 r1(vec1 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}//rotate point by eightRotation (part of hg_sdf)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(le(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 sqc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}//vec2 po2c(vec2 a){return muc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nvec2 lgc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 lgc(vec4 a){return vec4(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nvec2 suc(vec2 a,vec2 b){return a-b;}vec2 adc(vec2 a,vec2 b){return a+b;}///complex addition is trivial\nvec2 muc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 muc(vec2 a,vec2 b,vec2 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 muc(vec4 a){return muc(a.xy,a.zw);}//parallel mult\nvec2 dic(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nvec2 lgc(vec2 a,vec2 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 lgc(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nvec2 exc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//vec2 lgc(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 poc(vec2 a,vec2 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 poc(vec2 w,vec2 z,float c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nvec2 lgc(vec2 a,vec2 b,float c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nvec2 wrtc(vec2 a,vec2 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtc(vec2 a,vec2 b,float c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//vec2 sqc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\nvec2 sic(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sic(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sic(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 coc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n\n//obsoleted vec2 coc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 coc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tac(vec2 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nvec2 cotc(vec2 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sihc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 cohc(vec2 z){return coc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 vec2 tahc(vec2 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 vec2 cothc(vec2 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(vec2 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl2.0 vec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//cosh(x)==(pow(e,x)+pow(e,-x)*.5\n//sinh(x)==(pow(e,x)-pow(e,-x)*.5\n//\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nvec2 arsic(vec2 z){return c2(lgc(perp(z)+sqc(c2(po2c(z.yx)))+vec2(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsic(vec2 z){vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcoc(vec2 z){return-c2(lgc(z+c2(sqc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcoc(vec2 z){ vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=lgc(vec2(p+q-z.y,-z.x)/r);vec2 b=lgc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nvec2 artac(vec2 z){return sub2(c4(lgc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artac(vec2 z){ vec2 a=lgc(vec2(1.0+z.y,-z.x));vec2 b=lgc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(sub2(c4(vec4(z,sqc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=su(u);return lgc(c2(z)+sqc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r+p-q,-2.0*z.x*z.y));a=lgc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return lgc(z+sqc(po2c(z)+vec2(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return lgc(z+muc(sqc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-su(z*z);z*=2.;return .5*lgc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return lgc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return lgc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=su(z*z);return lgc(c2(z)+muc(sqc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2);return float(b.x==b.y);}\nfloat checkerBool(hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a\n ;}\n \n//---param3MAT\n//SF3() is a hot mess to be simplified a lot! //only allows for vec1 ot vecmax\n//explicit namespace fold for scalar operations\n#define fi3(m,z,a,b,c) {return z(m(a),m(b),m(c));}\n#define Q3(z,a,b,c){return z(a,b,c);}\n#define SF3(n,y,z,a,b,c) n y(n a,n b,n c)fi3(n,z,a,b,c) n y(n a,n b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,n b,n c)fi3(n,z,a,b,c) n y(vec1 a,n b,vec1 c)fi3(n,z,a,b,c)\n#define scalar3(y,z) vec1 y(vec1 a,vec1 b,vec1 c)Q3(z,a,b,c) SF3(vec2,y,z,a,b,c) SF3(vec3,y,z,a,b,c) SF3(vec4,y,z,a,b,c)\nscalar3(mx,mix)\n//---param1AD Automatic Differenciation (needs param2MAT)\n//todo AD for;tan,asin,acos,atan,reciprocal\n//memo museum: for consistency structure changed: d->v00->v11;d1->v01->w12;d2->v02->w13\n//...the swivels oof d; are .xd ,the swivels of v0N (and [w*]) are .ab\nvec1 rec(float a){return(a==0.)?a:1./a;}//return [1/a] ,work safe//sqrt()and divisions require a worksave reciprocal operator:\n#define sqD(h)h sq(h a){vec1 q=sq(a.a);return h(q,.5*rec(q)*a.b);}\n#define cmD(h,i) h cmd(w11 a,i b){return h(a.a,mu(a.b,b));}\ncmD(w11,vec1)cmD(w12,vec2)cmD(w13,vec3)cmD(w14,vec4)//cmd() is special case of component-wise-multiplication,special because a.x==1: is subroutine of abs()\n//i am not too sure about my implementation on fr();\n//the hell,just use mo()instead,mo()has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)-=.0)\nvec1 jud(vec1 a){return mx(a,-1.,st(fr(a),0.)*st(0.,fract(a)));}\nvec2 jud(vec2 a){return vec2(jud(a.x),jud(a.y));}\nvec3 jud(vec3 a){return vec3(jud(a.x),jud(a.y),jud(a.z));}\nvec4 jud(vec4 a){return vec4(jud(a.x),jud(a.y),jud(a.z),jud(a.w));}\n//i should definitely define this by fract,and not by floor.\n//because fm-modulation taught me that i need fract()a lot more than floor()\n#define frD(h)h fr(h a){return h(fl(a.a),jud(a.b));}\n#define abD(h)h ab(h a){return cmd(w11(ab(a.a),sg(a.a)),a.b);}//w13(abs(a.x),sign(a.x)*a.d);}\n#define siD(h)h si(h a){return h(si(a.a),mu(co(a.a),a.b));}\n#define coD(h)h co(h a){return h(co(a.a),mu(ne(si(a.a)),a.b));}\n#define lgD(h)h ln(h a){return h(ln(a.a),di(a.b,a.a));}\n#define exD(h)h ex(h a){vec1 x=exp(a.a);return h(x,x*a.b);}\n#define DA1(h)h(w11)h(w12)h(w13)h(w14)\nDA1(abD)DA1(siD)DA1(coD)DA1(lgD)DA1(exD)DA1(sqD)DA1(frD)//because different functions have unique derivatives,\n//fl(a)=a-fr(a); hasvery slightly lower precision?rarely relevant.fract()has great precision on float!\n#define fl(a) su(a,fr(a))\n//---Param2AD are trickier: https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mo()mx()mi()ma()\n//AD_mo() ideally should be replaced by fr(),but that adds 1dvd()and 1mu(),BUT DA_mo(a,b) outperforms mu(fr(di(a,b)),b),via [reciprocal product rule]\n#define moD(h,i)h mo(h a,i b){return h(mo(a.a,b  ),fr(a.b));}\n#define moE(h,i)h mo(h a,i b){return h(mo(a.a,b.a),fr(a.b));}\n#define moF(h,i)h(w11,i)h(w12,i)h(w13,i)h(w14,i)\nmoF(moD,vec1)moF(moE,w11)\n#define miG(r,h,j) r mo(h a,r b){return r(mod(a.a,b.a),j(0));}\nmiG(w14,w13,vec4)miG(w14,w12,vec4)miG(w14,w11,vec4)miG(w13,w11,vec3)miG(w13,w12,vec3)\nw13 mo(vec1 a,w13 b){return w13(mod(a,b.a),vec3(0));}\nw12 mo(vec1 a,w12 b){return w12(mod(a,b.a),vec2(0));}\nw11 mo(vec1 a,w11 b){return w11(mod(a,b.a),0.);}\n//substraction is simple,because \"differentiation is integration\"; https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for; https://en.wikipedia.org/wiki/Translation_(geometry)\n//BUT if we substract a struct da from a vec1 or w11,we must negate the .b part.\n//i possibly messed this one up by not flipping the .a part,but i an not sure there.\n#define suNN(h,i,j)h su(i a,j b){return h(su(a.a,b.a),a.b);}h su(j a,i b){return h(su(a.a,b.a),-b.b);}\nsuNN(w12,w12,w11)suNN(w13,w13,w11)suNN(w13,w13,w12)//the leftmost param equals the larger param of the other 2 params\nsuNN(w14,w14,w11)suNN(w14,w14,w12)suNN(w14,w14,w13)//..the rightmost param is always smaller than the middle param\n#define suNM(t)t su(t a,vec1 b){return t(su(a.a,b),a.b);}t su(vec1 a,t b){return t(su(a,b.a),-b.b);}\n#define suMM(t)suNM(t)t su(t a,t b){return t(su(a.a,b.a),su(a.b,b.b));}\nsuMM(w11)suMM(w12)suMM(w13)suMM(w14)\n//in the end mix() has an identity,and that identity does translate into DA:\n#define mixd(a,b,c) ad(mu(c,su(a,b),a)\n//a big issue of this is that mixd() and mind() where defined as MAT-functions,vut using the AD-labeling\n//so is just deleted that junk code\n//I define mind()and=maxd(-,-)instead of maxd()and=mind(-,-)\n//because min()is far more common than max(),for z-buffering.\n//negation identity:max(a,b)--min(-a,-b),requires struct negation\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n//AD_mu simplifies contextually ,scalar multiplication is tautological product_rule.\n#define adM2(h) h mu(h a,vec1 b){return h(mu(a.a,b),mu(a.b,b));}\n#define adM1(h) adM2(h)h mu(vec1 a,h b){return mu(b,a);}\n#define atta(h,i,j) h mu(i a,j b){return h(mu(a.a,b.a),ad(mu(a.b,b.a),mu(a.a,b.b)));}\n#define attA(h) atta(h,h,w11)atta(h,h,h)atta(h,w11,h)\nadM1(w11)adM1(w12)adM1(w13)adM1(w14)\natta(w11,w11,w11)attA(w12)attA(w13)attA(w14)//oh i really like this attA()-way of folding it\nDAm2 mu(DAm2 p,vec3 s){return DAm2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nDAm1 mu(DAm1 p,vec2 s){return DAm1(mu(p.x,s.x),mu(p.y,s.y));}\nDAm0 mu(DAm0 p,vec1 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define rXX(h) h di(h a,vec1 b){return h(di(a.a,b),di(a.b,b));}h di(vec1 a,h b){return h(di(a,b.a),di((mu(ne(a),b.b)),mu(b.a,b.a)));}\nrXX(w11)rXX(w12)rXX(w13)rXX(w14)\n//inverse scalar multiplication is a tautolotgy.\n//some of these may be nonsensical\n#define rXY(h,i,j) i di(h a,i b){return i(di(a.a,b.a),di((mu(ne(a.a),b.b)),(b.a*b.a)));}i di(i a,j b){return i(di(a.a,b.a),di((su(mu(a.b,b.a),mu(a.a,b.b))),(mu(b.a,b.a))));}\nrXY(w13,w12,w11)\nrXY(w11,w13,w13)\nrXY(w12,w13,w11)\nrXY(w11,w14,w14)//just guessing this line\nrXY(w12,w14,w11)//just guessing this line\n//All exponential functions utilize their Base_E_identity:...which is still not efficient,but comes down to O(exp(n*log(n)))\n//pow (x,y)-=exp(log(x)*y)//baseE exponential and logarythmic functions.\n#define po(x,y)ex(mu(ln(x),x))\n/*\n//It gets trickier with functions that take 3 parameters:,applying the\n//https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem)with first derivatives.\n#define v0q vec1 q=length(vec2(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nw11 le(w11 x,w11 y){v0q;return w11(ll2\nw12 le(w12 x,w12 y){v0q;return w12(ll2\nw13 le(w13 x,w13 y){v0q;return w13(ll2\nw13 lengthw13(DAm2 u){return le(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters.below is 3d length.\nw13 le(w13 x,w13 y,w13 z){float q=length(vec3(x.a,y.a,z.a));return w13(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nw13 le(DAm2 u){return le(u.x,u.y,u.z);}//3*3domain\n//the utility of a length()function is clear.*/\n//su(ab(p),s)equals a translation away from the origin by [s] AND mirroring at origin,via abs()\n//...so it it clamps a an implicit surface to a limited \"thickness\" (in 3 domains),also translating its first derivatives.\nw12 suab(w12 p,vec1 s){return su(ab(p),s);}\nw11 suab(w11 p,vec1 s){return su(ab(p),s);}\nw13 suab(w13 p,vec1 s){return su(ab(p),s);}\nDAm2 suab(DAm2 p,vec3 s){return DAm2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nDAm1 suab(DAm1 p,vec2 s){return DAm1(suab(p.x,s.x),suab(p.y,s.y));}\nDAm0 suab(DAm0 p,vec1 s){return DAm0(suab(p.x,s));}\n\n\n//spheretracker /ePr is referenced by bicapsule() and other unsigned distances\n//ideally only a 4d marcher is defined,with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\nconst float iterRm=256.;\nconst float eRm=.00001;\nconst float zFar=20000.;\nfloat df(vec3 p);\nvec3 dNormal(vec3 p){const vec2 e=vec2(.005,0);return norma(vec3\n (df(p+e.xyy)-df(p-e.xyy)\n ,df(p+e.yxy)-df(p-e.yxy)\n ,df(p+e.yyx)-df(p-e.yyx)));}\n \nvec4 trace(v33 a\n){float t=0.\n ;for(float i=0.;i<iterRm;++i\n ){float d=df(a.a)\n  ;if(d<eRm)return vec4(a.a,i);\n  ;if(t>zFar)return vec4(0)\n  ;a.a+=d*a.b*.5//this marther has its first step overstep way too often,doubling lipschitz evades this(poorly)\n  ;t+=d;}return vec4(a.a,iterRm);}\nvec4 trace(vec3 a,vec3 b){return trace(v33(a,b));}//legacy compatible\n\n\n\n\n//\"crossproduct\" and \"determinant\" are related,cross() is the bilin()* of a lin()_determinant()\n//therefore i can fold the detemrinant() mnamespace onto the cross() namespace.\n//a cross() has 2 inpouts,where a determinant() has 1 input\n//we generalize \"crossproduct\" into its ternary: \"find the only vector that in a 90deg angle to all inputs\"\nvec2 cr(vec2 a){return a.yx*vec2(-1,1);}//rotBy4\nvec3 cr(vec3 a,vec3 b){return cross(a,b);}\n//vec4 cr(vec4 a,vec4 b,vec4 c){\n//solve LinearEquation for   dot(a,d)=0;dot(b,d)=0;dot(c,d)=0;with additional constrains to length(d)==1\n//}\n//[a bilinear (2 input vectors) product with a vector result only exists in 3d and 7d,in 7f it has more than 2 results (handedness,signs)\n//7d_dotproduct() is the octonion_pairing to 3d_quaternion.\nfloat det2d(vec2 a,vec2 b){return dot(a,cr(b));}//a.x*b.y-a.y*b.x//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct perpdot dotperp\n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos,p.zy),perm2(u5cos,p.zx),perm2(u5cos,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//noronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 su(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 mu(float a,v33 b){return v33(a*b.a,a*b.b);}\nmat3 su(mat3 a,mat3 b){return a-b;}\nmat3 addf(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n\n//fast cellular noise,optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares,1 is maximum jitter. (known bug,iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend,is ideally 1/7,but others can be fine too.use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime.\n//the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1,.y is L2 according to [worley noise]\n//this uses a lot of mat2,or the v33 struct,and permute()functions similar to ahsima-simplex noise,defers the sorting,for performance.\n//Cellular noise (\"Worley noise\")in 3D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license.\n//See LICENSE file for details.\n//https://github.com/stegu/webgl-noise\n#define mous (iResolution.xyxy-iMouse.xyzw)//flip mouse everywhere,for shadertoy fun\nmat3 fr(mat3 a){return mat3(fr(a[0]),fr(a[1]),fr(a[2]));}\n//mat3 fl(mat3 a){return mat3(fl(a[0]),fl(a[1]),fl(a[2]));}\nmat3 addd(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n//th7 is for the 2d noise,should be (iResolution.y/7.),BUT i managed to make other values look fine,too\n#define th7 (mous.y/iResolution.y)//usually==1./7.,because mod(a,7)is famous for old LCGs.\n//th8 is for the 3d noise,should be (iResolution.y/7.),other values may work,but they tend to barely work at all,try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))//seems to be fine bounds,not too sure.\nvec3 mod2893d(vec3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}//Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n//Permutation polynomial:(34x^2+x)mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n#define Kcel 1./th8//1/7\n#define Kcel2 1./th8/th8//1/(7*7)\n#define Kcelo (1.-Kcel)*.5//1/2-Kcel/2\n#define Kcelz 1./(th8-1.)//1/6\n#define Kcelzo .5-2./(th8-1.)//0.416666666667//1/2-1/6*2\n#define jitter mous.x/iResolution.x//smaller jitter gives more regular pattern\nmat3 perM3(vec3 p){return mat3(permute3d(p-1.),permute3d(p),permute3d(p+1.));}\nmat3 perM3(vec3 p,vec3 b){vec3 p1=permute3d(p+b.x-1.);vec3 p2=permute3d(p+b.y);vec3 p3=permute3d(p+b.z+1.);return mat3(p1,p2,p3);}\n#define maa(a,b,c) ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a)a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c)mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n//todo,make it traversable bny getting distance2Border.\nvec2 cellular(vec3 P,float m//not to be confuced with a voronoi3d,but can look similar.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=addf(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perM3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perM3(pp[0]+p.z)\n ;mat3 p2=perM3(pp[1]+p.z)\n ;mat3 p3=perM3(pp[2]+p.z)\n ;mat3 ox=fr(p1*Kcel)-Kcelo\n ;mat3 ox2=fr(p2*Kcel)-Kcelo\n ;mat3 ox3=fr(p3*Kcel)-Kcelo \n ;mat3 oz=fl(p1*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz2=fl(p2*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz3=fl(p3*Kcel2)*Kcelz-Kcelzo \n ;mat3 oy=mod73d(fl(p1*Kcel))*Kcel-Kcelo\n ;mat3 oyy=mod73d(fl(p2*Kcel))*Kcel-Kcelo\n ;mat3 oy3=mod73d(fl(p3*Kcel))*Kcel-Kcelo\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=addf(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=addf(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n ;mat3 a\n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared==is dot(r,r)\n //Sort out the two smallest distances (F1,F2)\n #if 0\n ;vec3 d1=min(min(d11,d12),d13) //sort out only F1\n ;vec3 d2=min(min(d21,d22),d23)\n ;vec3 d3=min(min(d31,d32),d33)\n ;vec3 d=min(min(d1,d2),d3)//shortest of 9 distances,except its 9*vec3()\n ;d.x=min(min(d.x,d.y),d.z)\n ;return vec2(sqrt(d.x));}//F1 F1\n #else\n ;vec3 d1a=min(d11,d12)//sort out F1 and F2\n ;d12=max(d11,d12)\n ;d11=min(d1a,d13)//Smallest now not in d12 or d13\n ;d13=max(d1a,d13)\n ;d12=min(d12,d13)//2nd smallest now not in d13\n ;vec3 d2a=min(d21,d22)\n ;d22=max(d21,d22)\n ;d21=min(d2a,d23)//Smallest now not in d22 or d23\n ;d23=max(d2a,d23)\n ;d22=min(d22,d23)//2nd smallest now not in d23\n ;vec3 d3a=min(d31,d32)\n ;d32=max(d31,d32)\n ;d31=min(d3a,d33)//Smallest now not in d32 or d33\n ;d33=max(d3a,d33)\n ;d32=min(d32,d33)//2nd smallest now not in d33\n ;vec3 da=min(d11,d21)\n ;d21=max(d11,d21)\n ;d11=min(da,d31)//Smallest now in d11\n ;d31=max(da,d31)//2nd smallest now not in d31\n ;d11.xy=(d11.x<d11.y)?d11.xy:d11.yx\n ;d11.xz=(d11.x<d11.z)?d11.xz:d11.zx//d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy)//nor in d12.yz\n ;d11.y=min(d11.y,d12.z)//Only two more to go\n ;d11.y=min(d11.y,d11.z)//Done! (Phew!)\n ;return sqrt(d11.xy);}//F1,F2\n#endif\n//crunched by ollj\n//Cellular noise (\"Worley noise\")in 2D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license of://https://github.com/stegu/webgl-noise\n//mod(a,289.)without a division (only multiplications),because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}//Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}//Permutation polynomial:(34x^2+x)mod 289\n#define tt3(p,f,j,m,a)square(su(j,su(v33(vec3(a),f),mu(m,mu(m,modth7(ff(p*th7)))))))\n#define permi(c)p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c)r[d]=tt3(p,f,k.a,m,e);permi(c)\n//Cellular noise,returning F1 and F2 in a vec2//3x3-hood reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity)m=1./7.,by sqiveling this parameter,you get+0.7 domain very cheaply\n//as in by making m a 3rd parameter,you ALMMOST get cheap cellular3d noise,BUT it is likely a bit flawed,more repetitive,shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop.the permute()function marks+1 iteration/tap//is 4tap voronoi in O(3)\n){v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1),f=o+.5,px=permute(o+k.b.x),permi(x)\n ;mat3 r\n ;ppm(0,-.5,y)//it seems that the loop got unrolled and al lits min()fucntions fold into the below\n ;ppm(1,+.5,z)//...//which is quite a lot of symmetry folding,surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line ,because r[0].y is a return value.\n ;r[0].y=min(mi(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n//simplex noise3d (simplex noise is worth it for higher dimensions)\n//Original:https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute(vec4 x){return mod(x*x*34.+x,289.);}\nfloat simplex1(vec3 v//ashima simplex3d,early optimizations by @makio64,structure by @ollj  https://www.shadertoy.com/view/Xd3GRf\n){const vec2 C=1./vec2(6,3);const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy)),x0=v-i+dot(i,C.xxx),g=step(x0.yzx,x0.xyz),l=1.-g//is a sequence of 4,no parallelization\n ;v33 f=v33(min(g.xyz,l.zxy),max(g.xyz,l.zxy));v3333 d=g3333(x0,su(x0,g333(su(f,g33(C)),D.yyy)))\n ;i=mod(i,289.);v222 F=g222(f);vec3 ns=.142857142857*D.wyz-D.xzx\n ;vec4 p=permute(permute(permute(i.z+vec4(0,F.c,1))+i.y+vec4(0,F.b,1))+i.x+vec4(0,F.a,1)),j=p-49.*floor(p*ns.z*ns.z),k=floor(j*ns.z)\n ;v44 t=ad(mu(v44(k,floor(j-7.*k)),ns.x),ns.y)\n ;vec4 h=1.-abs(t.a)-abs(t.b),a=-step(h,vec4(0))\n ;v44 b=v44(vec4(t.a.xy,t.b.xy),vec4(t.a.zw,t.b.zw))\n ;b=ad(v44(b.a.xzyw,b.b.xzyw),mu(v44(a.xxyy,a.zzww),ad(mu(fl(v44(b.a.xzyw,b.b.xzyw)),2.),1.)))\n ;v3333 q=v3333(vec3(b.a.xy,h.x),vec3(b.a.zw,h.y),vec3(b.b.xy,h.z),vec3(b.b.zw,h.w))\n ;q=muv(q,inversesqrt(ddv(q)));vec4 m=max(.6-ddv(d),0.)\n ;return .5+12.*dot(m*m*m,vec4(dot(q.a,d.a),dot(q.b,d.b),dot(q.c,d.c),dot(q.d,d.d)));}\n\n//fbm of dr2 noise (with multitap normals),is a bit crude,in favor for fast normals.\n#define fBm(a) vec2 b=vec2(0,1);for(int i=0;i<a;i++){b=vec2(b.x,0)+vec2(noise1(p),.5)*b.y;p*=2.;}return b.x/(2.-b.y);}\nvec1 fbm(vec1 p){fBm(5)vec1 fbm(vec2 p){fBm(5)vec1 fbm(vec3 p){fBm(5)vec1 fbms(vec3 p){fBm(3)\nvec1 fbmn(vec3 p,vec3 n){vec4 r=vec4(0,0,0,1);for(int i=0;i<4;i++\n){r=vec4(r.xyz,0)+r.w*vec4(vec3(noise1(p.yz),noise1(p.zx),noise1(p.xy)),.5);p*=2.;}return dot(r.xyz,abs(n));}\nvec3 VaryNf(vec3 p,vec3 n,vec1 f\n){vec2 e=vec2(.1,0);vec3 g=vec3(fbmn(p+e.xyy,n),fbmn(p+e.yxy,n),fbmn(p+e.yyx,n))-fbmn(p,n)\n ;return norma(n+f*(g-n*dot(n,g)));}\nfloat fbma(vec3 p//fbm of ashima simplex (no normals,duh)\n){float f\n ;f=.5*(simplex1(p));p=p*2.01\n ;f+=.25*(simplex1(p));p=p*2.02\n ;f+=.125*(simplex1(p));p=p*2.03\n ;f+=.0625*(simplex1(p));p=p*2.04\n ;f+=.03125*(simplex1(p));return f;}\n\n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\nfrflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)frflpm(v44,c44)\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\nfloat Blob(vec3 p){p=ab(p);p=mx(p,p.yzx,st(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-a)))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a))//i am not convinced by this one\n#define box(a,b) roundit(abm(a,b))\nfloat fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define segment2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,segment()sub ,is squared distance\n#define segment(a,b,c) sq(segment2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n#define segmentY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u,vec4 m){\n//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x);//calculate dorated differential\n return dot(u-m.xy,(f));//signed distance to line \n//more generally,f should be normalized here for proper caling.\n//but scaling is irrelevant as we only care fror the sign \n}\n#define  rac mix(.5,3.,sin(iTime)*.5+.5)\n//earvageg is still far from standardized. rac is the central radius, should be parametric.\nfloat EarVagEgg(vec2 u,vec2 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (sd2l(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(sd2l(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\nfloat CylEarVagEgg(vec3 u,vec2 m,float h\n){float a=abs(EarVagEgg(u.xy,m))-.01\n ;a=abs(a-.05)-.02\n ;float b=abs(u.z)-h\n ;return ma(b,a);}\n#define tiny .000001\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\nfloat debugHg2(vec3 u){\n ;float r=0.\n ;float t=cos(iTime)*.4+.5\n ;//r=box(u,vec3(1))-t\n ;//r=length(u-bicapsule3(u,vec3(-.5,0,2),vec3(.5,0,2),.7,.2))-.1;\n ;r=CylEarVagEgg(u*.5,.5*iMouse.xy/iResolution.xy,.2)\n //bicapsule(u,vec3(1,0,0),vec3(0,0,1),.5,2.)\n ;//r=Blob(u)\n ;//r=fPlane(abs(u),vec3(1,1,1),-1.5)//the raymarcher is not ideal for this one,with its alpha fadeout.\n ;//r=boxf(u,vec3(1))-.5\n ;//r=corner(u.xy)\n ;//r=cylinder(u,1.,1.)\n ;//failed to make a rounded cylinder via roundit()\n ;//r=segment(u,vec3(0),vec3(1,2,3))-t\n ;//r=segmentY(u,vec2(1,2))//could not get it to work instantly\n ;//r=torus(u,1.)-1.\n ;//r=disc(u,vec2(1.))-2.//could not get it to work instantly\n ;//r=hexCircum(u,1.)-1.\n ;//r=fCone(u,1.,2.)\n ;return r;}\n//2-distance input unions\n//note,for higher dimensions,i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances,b is a radius //todo,compare with mima()\n#define miRound(a,b) mi(ma0(a),-b)+le(ma0(b+a))//is likely wrong\n#define maRound(a,b) -fOpRoundMin(-a,b)//is likely wrong\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}//is likely wrong\n/*\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat micolumns _M(1.)\n ;p.x+=sqrt(.5)*-r+c*sqrt(2.)\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b)\n ;}\n\nfloat macolumns _M(-1.)\n p.y+=c;p.x=sqrt(.5)*(r+c)/p.x\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=-mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b);}//fails on its own\n#define mecolumns(a,b,r,n) -macolumns(a,-b,r,n)/**/\n\n\nmat2 r2(float a){vec2 b=cs(a);return mat2(b.x,b.y,-b.y,b.x);}\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return mi(mi(a,b),.5*(u+a+abs(mo(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\nvec2 debugHg(vec3 u){\n ;return vec2(debugHg2(u),1)\n ;float r=0.\n ;u.z-=1.\n ;float t=cos(iTime)*.4+.5\n ;float a=box(u   ,vec3(1))-t\n ;//u.xy*=r2(1.)\n ;float b=box(u-1.,vec3(1))-.2\n ;//return mi(a,b)\n ;//return ma(a,b)\n ;//return ma(a,-b)\n ;//return miChamfer(a,b,0.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return miChamfer(a,b,3.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return maChamfer(a,b,.5)//not sure if broken or tracer issue\n ;//return meChamfer(a,b,.5)\n ;//return chamfer180(a,b,.5)//round chamfer is best\n ;//return -chamfer180(-a,-b,.5)//max() round chamfer is weird but fun\n ;//return -chamfer180(-a,b,.23)//max(a,-b) round chamfer easily gets discotinuous\n ;//return chamfer180(a,b,3.5)//overchamfering round is bumpy\n ;//return miRound(a,b)//todo fixme\n ;//return mistairs(a,b,.5,13.)\n ;//return mistairs(a,b,.5,13.)\n ;//return mestairs(a,b,.5,13.)\n ;a=micolumns(a,b,.5,4.)\n ;//return mecolumns(a,b,.5,4.)\n ;//return mucolumns(a,b,.5,4.) \n ;//return macolumns(a,b,.5,4.)//macolumns fails\n ;//return mecolumns(a,b,.5,4.)\n ;//return pipe(a,b,.2)\n ;//return engrave(a,b,.5)\n ;//return -groove(-a,b,.5,.1)\n ;//return tongue(a,b,.5,.1)\n ;return vec2(a,1);}\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5cos(2.*pi*ab012(a,b));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below,but close\nvec3 hsv2rgb(const vec3 c){return c.z*mx(1.,sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n\n\n\n\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\nstruct v21{vec2 a;vec1 b;};//currently only for alpha compositing plans\nstruct v31{vec3 a;vec1 b;};//...for MAT arithmetic\nstruct v41{vec4 a;vec1 b;};\nv21 su(v21 a,v21 b){return v21(a.a-b.a,a.b-b.b);}\nv21 mu(v21 a,v21 b){return v21(a.a*b.a,a.b*b.b);}\nv21 mu(v21 a,vec1 b){return v21(a.a*b,a.b*b);}\nv31 su(v31 a,v31 b){return v31(a.a-b.a,a.b-b.b);}\nv31 mu(v31 a,v31 b){return v31(a.a*b.a,a.b*b.b);}\nv31 mu(v31 a,vec1 b){return v31(a.a*b,a.b*b);}\nv41 su(v41 a,v41 b){return v41(a.a-b.a,a.b-b.b);}\nv41 mu(v41 a,v41 b){return v41(a.a*b.a,a.b*b.b);}\nv41 mu(v41 a,vec1 b){return v41(a.a*b,a.b*b);}\n//generalizing alpha-compositing functions,named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent,.W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes],this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions,that return a or b,for simplicity\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n\n\n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\nw11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nvec4 demoSmin(vec2 u,vec2 m,vec2 n//smin (exponential and polinomial) , with automativDifferenciation\n){w11 a=w11(u.x-m.x*9.,1.)\n ;w11 b=w11(u.x-m.x*9.,1.)\n ;m.x=abs(m.x)+.2//optional evasion of very short wavelength\n ;vec4 c=vec4(0)\n ;float amp=1.//m.y\n ;a=   mu(co(di(a,di(m.x,mu(pi,.5)))),amp)//a.b is analytic first derivative of a.a\n ;b=ad(mu(si(di(b,di(m.x,mu(pi,.5)))),amp),mu(si(b),.3))//b.b is analytic first derivative of b.a\n ;a=su(co(mu(a,2.)),mu(a,.2))\n ;b=su(si(mu(b,2.)),mu(b,.561))\n ;w11 d=mae(a,b,1./m.y)\n ;w11 e=mae(a,b,1./m.y)\n ;w11 f=mas(a,b,3.*m.y)\n ;c.y=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.x=abs(b.a-u.y)/sqrt(1.+b.b*b.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.z=abs(d.a-u.y)/sqrt(1.+d.b*d.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.w=abs(f.a-u.y)/sqrt(1.+f.b*f.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;//c=abs(c-.2)-.1//optional shows how this is NOT distance2Sin()\n ;c=abs(c-aaa*2.)-aaa*.5//optional double line\n ;c=smoothstep(aaa,-aaa,c)\n ;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n ;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec4 y=vec4(angleToColor(vec3(rainb.y,1,1)),c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(angleToColor(vec3(rainb.z,1,1)),c.z)//coordinate system in magenta/pink\n ;vec4 w=vec4(angleToColor(vec3(rainb.w,1,1)),c.w)//coordinate system in magenta/pink\n ;x.xyz*=x.w;y.xyz*=y.w;z.xyz*=z.w;w.xyz*=w.w//alpha premultiplied\n ;x=pdOver(y,x)\n ;x=pdOver(z,x)\n ;x=pdOver(w,x)\n ;return x;}\n\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n\n\n\n\n\n\n\n// \"Generalized Distance Functions\" by Akleman and Chen ,often included in hg_sdf\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 norma(vec3(1,1,1))\n#define GDFVector4 norma(vec3(-1,1,1))\n#define GDFVector5 norma(vec3(1,-1,1))\n#define GDFVector6 norma(vec3(1,1,-1))\n#define GDFVector7 norma(vec3(0,1,PHI+1.))\n#define GDFVector8 norma(vec3(0,-1,PHI+1.))\n#define GDFVector9 norma(vec3(PHI+1.,0,1))\n#define GDFVector10 norma(vec3(-PHI-1.,0,1))\n#define GDFVector11 norma(vec3(1,PHI+1.,0))\n#define GDFVector12 norma(vec3(-1,PHI+1.,0))\n#define GDFVector13 norma(vec3(0,PHI,1))\n#define GDFVector14 norma(vec3(0,-PHI,1))\n#define GDFVector15 norma(vec3(1,0,PHI))\n#define GDFVector16 norma(vec3(-1,0,PHI))\n#define GDFVector17 norma(vec3(PHI,1,0))\n#define GDFVector18 norma(vec3(-PHI,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d+=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) \n fGDFExp(GDFVector4) \n fGDFExp(GDFVector5) \n fGDFExp(GDFVector6)\n fGDFExpEnd}\n \n/*\nfloat fDodecahedron(vec3 p,float r,float e){\n fGDFBegin\n ;d+=pow(abs(dot(p,norma(vec3(0,PHI,1)))),e);\n //fGDFExp(GDFVector13)\n fGDFExp(GDFVector14)\n fGDFExp(GDFVector15)\n fGDFExp(GDFVector16)\n fGDFExp(GDFVector17)\n fGDFExp(GDFVector18)\n fGDFExpEnd}\n /*\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\n\n*/\n\n\n\n//someone overthought checkerboard patterns\n//float xnor(float x,float y){return abs(x+y-1.);}// abs(0+0-1)-1 abs(1+0-1)-0 abs(0+1-1)-0 abs(1+1-1)-1\n//xnor(xnor(e.x,e.y),e.z)//checkerboard3d\n\n\n\n\n\n\n\n\n\n\n\n\n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv33 cam(vec2 u\n){\n  ;vec4 mouse=  iMouseZwFix(iMouse,true)\n ;float camOrbit=5.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=-.03*(mouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*iTime)//autopilot\n ;m=mx(n,m,step(0.,mouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v33(pos,dir);}\n\n\n\n//Phong+debugPlanes\n//\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n#define tracePlane(po,pd,o,d) dot(po-(o),pd)/dot(d,pd)\n//traceR if(t<0) return -1; return t;\n#define traceR(t) mix(-1.,t,step(t,0.))\n#define raytrace_plane(po,pd,o,d) traceR(tracePlane2(po,pd,o,d))\nvec1 planeDebug2(vec3 o,vec3 d,float c,inout float t,vec2 n,const int f//ray,ray,curPlane,time,domainLengths\n){if(n.x<c&&n.y>0.//debug plane //n.x=o.y n.y=d.y\n ){vec3 a=(mat3(1)*c)[1]\n //above line needs gl1.0 0:1318: '[]' : Index expression must be constant//\n  ;float p=tracePlane(a,a*t,o,d)\n  //;if(abs(p)<9.){\n   ;p=df(o+d*p)\n   ;float q=fract(p*8.)/(p*p*p*p+4.)\n   ;p=mix(q,mix(.3,.7,q),step(p,0.))\n   ;return p\n   ;}//}\n ;return 0.;}\n//x can be y,beware that z may be hidden from some cameras,need to rotate camera asound.\n//d is linked to e; e=x f=0 ; e=y f=1 ; e=z f=2 (; e=w f=3)\n#define planeDebug(a,b,c,d,e,f) planeDebug2(a,b,c,d,vec2(a.e,b.e),f)\n\nvec4 DebugPlanes(vec3 o,vec3 d,float t\n){float c0=sin(iTime*.5)*2.\n ;vec4 a=planeDebug(o,d,c0,t,x,0)*vec4(0,1,.5,1)\n ;vec4 b=planeDebug(o,d,c0,t,y,1)*vec4(.5,0,1,1)\n ;vec4 c=planeDebug(o,d,c0,t,z,2)*vec4(1,.5,0,1)\n ;return sat((a+b+c)*2.);}\nvec3 tex(vec3 u//textureid is 2 integers, .x one sets hue, .y sets saturation.\n){return cellular(u*5.,iTime).xyx\n //;return fract(u*4.+cos(iTime))\n ;}\n\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n \n//these likely have simpler expressions,its too late timeofday for me to bother now.\nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n\n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(iTime*.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1])\n ;y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(ma(dt(p,y))-o.x*3.,sq(mi(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\nvec3 dfPoly(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 pol=vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;return pol;}\n\n\nfloat df(vec3 p){\n#if 0\n ;p.xz=-p.xz;\n ;vec2 q=pModMirror2(p.xz,vec2(4.5))//repetition\n#endif\n ;//return dfPoly(p).x//array of 16 different spheroid\n ;return debugHg(p).x//hg_sdf debug playgound\n //;float dodec=fDodecahedron(p-vec3(-9,2,-4)/4.,.7)//i like how this is placed n the mirroring plane\n ;float b=fBox(p-vec3(0,-.1,0),vec3(1))\n ;float s=length(p-vec3(1.+sin(iTime*.25)*.2,.8,1))-1.//sphere\n ;s=min(b,s)\n //;return s;\n ;float d=mistairs(b,s,.7,4.)\n ;p.xz*=r1(iTime*.041);p.zy*=r1(iTime*.021)//lazy small rotation\n ;vec2 n=cellular(p*5.61,1./7.)\n ;//d-=(n.y-n.x)*.05//too much foreach march iteration.\n ;return d;}\n //;return min(d,dodec);}\n\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal(u.xyz)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=dfPoly(u.xyz).yz//surfaceID is distanceField specific\n ;tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(0,.1,.3),vec3(1,1,.9),diffuse)*surf+spec*vec3(1,1,.9)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n\n\n\n\nvec4 demo2NoiseCel(vec2 u,vec2 m\n){vec3 o=vec3(u*6.,cos(iTime)*4.)\n ;o.xz*=r1(iTime*.041);o.zy*=r1(iTime*.021)//lazy small rotation\n ;return vec4(cellular(o,iTime*.161),0,1);}\n\nvec4 demoHg3d(vec2 u\n){vec3 lir=norma(vec3(.5,1.0,-.25))\n ;v33 ray=cam(u)\n ;//v12 dt=trace(ray.a,ray.b)//td.a is distanceToCamera dt.b is a 2d textureId\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return c;}\n\nvec4 demoAd2d(vec2 u,vec2 m//deomes 1d automatic differentiation\n){vec3 c=vec3(0)\n ;w11 a=w11(u.x*9.,1.)\n ;a=w11(u.x,1.)\n ;a=si(ex((a)))//a.b is analytic first derivative of a.a\n //;a=(si(fr(a)))\n ;c.x=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float o=c.x\n ;c.y=a.b\n ;c.yz-=u.y\n ;c.yz=abs(c.yz)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;c=smoothstep(aaa,-aaa,c-aaa)\n ;if(abs(a.b)<aaa*50.)c.z=max(c.z,pow(1.-abs(a.b)*2.,4.))//mark local extrema with vertical lines (better line width would need 2nd derivative)\n ;c=c.zyx//;c=mix(c,c.yzx,iMouse.x/iResolution.x)*2.#\n ;vec4 x=vec4(0  ,c.x,c.x,c.x)//first derivative\n ;vec4 y=vec4(c.y,0  ,c.y,c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(c.z,c.z,0  ,c.z)//coordinate system in magenta/pink\n ;x=pdOver(y,x)//2 graphs,one is 1st derivative  in cyan/blue\n ;x=pdOver(z,x)//add coordinate system that highlights loccal extrema\n ;return x;}\n\nvec4 demo2d1(vec2 u,vec2 m,vec2 n\n){vec4 c=vec4(0)\n ;c.x=dd(m-u);c.y=dd(n-u);c.w=dd(mix(n,m,abs(cos(iTime*2.)))-u)//abs(cos())bounce fopr direction\n ;c.xyw=sqrt(c.xyw)\n ;u=abs(u)\n ;c.z=ma(u)\n ;float thick=.005,diam=.1\n ;c=smoothstep(.01,-.01,abs(abs(c-diam)-diam+thick)-thick)//i know theres better ways to do this abs(abs())identities...\n ;c.xy+=c.w;return vec4(c.xyz,ma(c.xyz))\n ;vec4 a=pdOver(vec4(0,c.y,0,c.y),vec4(c.x,0,0,c.x))//green over red\n ;c     =pdOver(vec4(c.w,c.w,0,c.w),vec4(0,0,c.z,c.z))//yellow over blue\n ;c     =pdOver(a,c)//green over red over yellow over blue\n ;return c;}\n\nvec3 ss(float a,vec3 b){return smoothstep(a,-a,b);}\n\nvec4 pd(vec2 u\n){vec2 m=fra(iMouse.xy)\n ;if(iMouse.z<.0)m=-vec2(.5)//while(mouse up)simulate mouse down.\n ;vec2 s=-vec2(1.,sin(iTime))//vector moves over time.\n ;vec3 e=vec3(dd(u)\n ,dd(u-m)\n ,dd(u-s))//eucliden distance projection.\n ;e=sqrt(e)//delayed square root\n ;e-=.5//circle radius\n ;e=abs(e)-.2;//turn cirlce into ring\n ;float SSAA=(cos(iTime)+1.25)*12./min(iResolution.x,iResolution.y);//screen-space-anti-aliasing\n ;e=ss(SSAA,e)\n ;e=sat(e)\n ;vec3 g=vec3(.96,.25,.05)//color ramp equals cheap colorblind mode.\n ;vec4 c0=vec4(g,e.x)\n ;vec4 c1=vec4(g.yzx,e.y)\n ;vec4 c2=vec4(g.zxy,e.z)//some colors with e.rgb as alpha channel.\n ;c0.rgb*=c0.w//general form scales .rgb by alpha,\n ;c1.rgb*=c1.w//...this acoids some division by 0 cases\n ;c2.rgb*=c2.w\n ;vec4 O=pdOver(c0,c1);O=pdOver(O,c2)\n ;//O=sXor(c0,c1);O=sXor(O,c2)\n ;//O=sAtop(c0,c1);O=sAtop(O,c2)\n ;vec4 bg=vec4(vec3((checkerBool2(u))),u.y)\n //;bg.rgb=pow(bg.rgb,vec3(2.2))\n ;if(O.w!=0.)O.rgb/=O.w\n ;O=pdOver(O,bg);\n ;O.rgb=pow(O.rgb,vec3(1./2.2))/**/\n ;return O;}\n\nvoid mainImage(out vec4 O,vec2 u\n){u=fra(u)\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 m=fra(mouse.xy)\n ;vec2 n=fra(mouse.zw)\n ;O=vec4(0)\n ;O=pdOver(O,demo2d1(u,m,n))//mouseCoords\n ;//O=pdOver(O,demoAd2d(u,m))//ad 1d\n ;O=pdOver(O,demoSmin(u,m,n))//ad 1d smin\n ;O=pdOver(O,demoHg3d(u/2.))//hg_sdf,u-scaling sets camera distance to center\n ;O=pdOver(O,demoComplex(u,m,n))\n ;//O=pdOver(O,demo2NoiseCel(u,m)*vec4(.3,.3,.3,1.))//celularNoise\n ;O=pdOver(O,vec4(vec3((checkerBoolT(u*1.61))*.5+.25),u.y))//checkerboard background\n ;}\n\n\n\n\n\n\n\n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dSegment(a,b,c) segment(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return segmentY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return segment(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}