{
    "Shader": {
        "info": {
            "date": "1725468137",
            "description": "Polynomial approximation of the optical depth of a gaussian layer.\nMouse click to select order.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcByRy",
            "likes": 4,
            "name": "Polynomial airglow approx.",
            "published": 3,
            "tags": [
                "atmosphere",
                "chapman",
                "airmass"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 92
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Polynomial-based alternative to \"Gaussian-ish airglow\n// approx.\" shader (https://www.shadertoy.com/view/MXGSRc).\n// Mouse click to select order.\n\n// Computing integral on a segment in bubble-like scalar field,\n// using polynomials, as opposed to quartic gaussian from\n// https://www.shadertoy.com/view/MXGSRc (which was involved,\n// not very fast, nor particularly accurate).\n// We consider a field of the form\n//            ⎧ (1-(r^2-R^2)^2/(R^2*w^2))^n, if |r^2-R^2|<R^2*w^2\n//     f(r) = ⎨\n//            ⎩ 0                          , otherwise\n// with bubble radius R and thickness parameter w (we only\n// consider non-negative integer n). Note that (r^2-R^2)/(2*R)\n// serves as an approximation of height above R. See\n// https://www.shadertoy.com/view/4csXDM for relationship\n// between (1-x^2)^n and exp(-x^2).\n// The exact bounds for non-zero field are\n//     sqrt(R*(R-w)) < |r| < sqrt(R*(R+w))\n// and the thickness is\n//     sqrt(R*(R+w))-sqrt(R*(R-w)) = 2*R*w/(sqrt(R+w)+sqrt(R-w))\n// For w/R->0, the thickness approaches w, and the integral\n// on (-∞;+∞) approaches\n//     w * sqrt(π)*Γ(n+1)/Γ(n+3/2) = w * 2^(2*n+1)*(n!)^2/(2*n+1)/(2*n)!\n// The expression being polynomial, its integral (also\n// a polynomial) can be easily found explicitly.\n// The expressions are, however, both moderately long, and,\n// more to the point, numerically poorly-behaved (at least\n// when evaluated straightforwardly).\n// However, since the expressions are polynomials of order 4*n,\n// a (2*n+1)-tap Gauss-Legendre quadrature evaluates them\n// exactly, and so can be seen as alternative explicit expression,\n// which happens to be well-behaved.\n// In this shader only calculations for n equal 0, 1, 2 are provided.\n// Interested reader can easily write their own.\n// See e.g. https://pomax.github.io/bezierinfo/legendre-gauss.html\n// for tabulated values of Gauss-Legendre quadratures of higher\n// orders.\n\nconst float pi=3.14159265358979;\n\n// Compute ∫ (1-(x^2+y^2-R^2)^2)^n dx on region of [l;h]\n// where (...)^n is positive.\nfloat integral(int n,float R,float y,float l,float h)\n{\n    float ret=0.0;\n    float D=(R-y)*(R+y);\n    float R0=sqrt(max(D-1.0,0.0));\n    float R1=sqrt(max(D+1.0,0.0));\n    vec2 L=vec2(-R1,-R0),H=vec2(+R0,+R1);\n    L.x=max(L.x,l);   H.x=max(H.x,l);\n    L.y=min(L.y,h);   H.y=min(H.y,h);\n    L.x=min(L.x,L.y); H.x=min(H.x,H.y);\n    vec2 S=L;\n    for(int k=0;k<2;++k)\n    {\n        float c=0.5*(S.x+S.y),d=0.5*(S.y-S.x),x,z;\n        switch(n)\n        {\n            case 0:\n                // No need to evaluate pow(...,0).\n                ret+=2.0*d;\n                break;\n            case 1:\n                x=c-0.7745966692414834*d; z=x*x-D; ret+=0.5555555555555556*d*(1.0-z*z);\n                x=c                     ; z=x*x-D; ret+=0.8888888888888888*d*(1.0-z*z);\n                x=c+0.7745966692414834*d; z=x*x-D; ret+=0.5555555555555556*d*(1.0-z*z);\n                break;\n            case 2:\n                // We hope that compiler optimizes pow(...,2).\n                x=c-0.9061798459386640*d; z=x*x-D; ret+=0.2369268850561891*d*pow(1.0-z*z,2.0);\n                x=c-0.5384693101056831*d; z=x*x-D; ret+=0.4786286704993665*d*pow(1.0-z*z,2.0);\n                x=c                     ; z=x*x-D; ret+=0.5688888888888889*d*pow(1.0-z*z,2.0);\n                x=c+0.5384693101056831*d; z=x*x-D; ret+=0.4786286704993665*d*pow(1.0-z*z,2.0);\n                x=c+0.9061798459386640*d; z=x*x-D; ret+=0.2369268850561891*d*pow(1.0-z*z,2.0);\n                break;\n        }\n        S=H;\n    }\n    return ret;\n}\n\nfloat integral(int n,vec3 c,float R,float w,vec3 ro,vec3 rd,float lo,float hi)\n{\n    float W=sqrt(w*R);\n    vec3 r=ro-c;\n    R/=W;\n    r/=W;\n    lo/=W;\n    hi/=W;\n    float y=length(r-dot(r,rd)*rd);\n    lo=lo+dot(r,rd);\n    hi=hi+dot(r,rd);\n    return W*integral(n,R,y,lo,hi);\n}\n\n// Or use actual infinity, if available.\nconst float INF=1e17;\n\n// Solve equation x^2+2*p*x+q=0.\nvec2 quadratic_solve(float p,float q)\n{\n    float d=p*p-q;\n    float h=-p+(p>=0.0?-sqrt(d):sqrt(d));\n    float l=q/h;\n    return d<0.0?vec2(+INF,-INF):vec2(min(l,h),max(l,h));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 Q=vec3(1.0,2.0/3.0,8.0/15.0);\n    int N=1;\n    if(length(iMouse.xy)>16.0) N=int(3.0*iMouse.x/iResolution.x);\n    // Much of airglow data is from\n    //     The 1997 reference of diffuse night sky brightness Ch. Leinert, S. Bowyer, L. K. Haikala, M. S. Hanner, M. G. Hauser, A.-Ch. Levasseur-Regourd, I. Mann, K. Mattila, W. T. Reach, W. Schlosser, H. J. Staude, G. N. Toller, J. L. Weiland, J. L. Weinberg and A. N. Witt Astron. Astrophys. Suppl. Ser., 127 1 (1998) 1-99 DOI: https://doi.org/10.1051/aas:1998105\n    //     https://aas.aanda.org/articles/aas/abs/1998/01/ds1449/ds1449.html\n    const float Re=6.3781e6;                // Nominal Earth equatorial radius, in m.\n    // There are several sources of airglow, with roughly\n    // similar width, at ~90 km.\n    const float H=90e3;                     // Height of airglow layer.\n    const float W=10e3;                     // Width (FWHM) of airglow layer.\n    float w=W/(sqrt(8.0*log(2.0)/pi)*Q[N]); // Effective width.\n    const float R=Re+H;\n    float h=Re/4096.0;\n    // Background color. Since starlight and airglow\n    // are roughly similar in magnitude, it is not black.\n    vec3 col=3e-2*vec3(0.433,0.3257,0.27655); // Cosmic latte (CIE xz=(0.345,0.345)).\n    // RGB of 557.1 nm airglow OI line.\n    vec3 color=vec3(0.232,1.345,-0.168);\n    float k=5.0/R;   // Density (pretty arbitrary).\n    float z=mix(0.0,2.0*R,smoothstep(-1.0,+1.0,sin(0.5*iTime)));\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,Re+h,z);           // Ray origin.\n    vec3 rd=normalize(vec3(xy,-1.5)); // Ray direction.\n    float lo=0.0,hi=INF;              // Ray bounds.\n    // Render stars.\n    vec3 S=round(1024.0*rd);\n    S+=sin(S*S.yzx);\n    S=normalize(S);\n    col+=exp(-4.0*(1.0-sin(1e3*S.x)))*exp(-1e8*dot(rd-S,rd-S));\n    // Render planet.\n    vec2 s=quadratic_solve(dot(ro,rd),dot(ro,ro)-Re*Re);\n    if(s.x<s.y&&s.x>0.0) // Real roots exist and both positive.\n    {\n        vec3 l=normalize(vec3(1)); // Direction to lightsource.\n        hi=s.x;\n        vec3 r=ro+s.x*rd;\n        vec3 n=normalize(r);\n        col=vec3(0.2,0.125,0.05)*(0.0625+0.125*max(dot(n,l),0.0)); // Fake Lambertian shading.\n    }\n    // Render airglow.\n    col+=k*color*integral(N,vec3(0),R,w,ro,rd,lo,hi);\n    col=max(col,0.0);\n    col=1.0-exp(-1.0*col); // Tonemap.\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}