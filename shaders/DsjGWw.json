{
    "Shader": {
        "info": {
            "date": "1667842707",
            "description": "First experiment on 1-step refraction rendering",
            "flags": 0,
            "hasliked": 0,
            "id": "DsjGWw",
            "likes": 6,
            "name": "Transparent worms",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "worms",
                "lightningmodel"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 250;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 20.0;\nconst float PRECISION = 0.005;\n#define AA 1\n#define PI 3.14159\n\nstruct worm{\n    float depth;\n    vec3 col;\n    float id;\n    float cnt;\n    float eta;\n};\n\n\nfloat Worm(vec3 p, out worm W){\n    float d = 1e10;\n        \n    vec3 q = p;\n    q.y += .3*sin(p.x*1.3+2.);\n    q.x -= .3*cos(p.y*1.);\n    q.z += .3*cos(p.x*1.7+1.);\n    q.z += .42*cos(q.x*2.+iTime);    vec3 a = vec3(0.), b = -vec3(2.,0.,0.);\n    float r = .1;\n    float d2 = sdCapsule(q/2., a, b, r);\n    if (d2<d){\n        W.col = vec3(.3,0.,0.);\n        d = d2;\n        W.id = 1.;\n        W.eta = .9;\n     }\n     \n    vec2 t = vec2(.5, .65);\n    q = rotateZ(PI/2.)*q;\n    q.y = q.y - .3*clamp(round(q.y/.3), 0., 12.);\n    q.y *= 2.;\n    d2 = sdTorus(q/2., t/10.);\n    if (d2<d){\n        W.col = vec3(2.,0.,0.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 2.;\n        d = d2;\n        W.eta = 1.;\n     }    \n     \n    q = p;\n    q.x -= .3*cos(p.y*1.);    \n    q.y += .3*sin(p.x*1.3+2.);\n    q.z += .3*cos(p.x*1.7+1.);\n\n    q.y += .42*sin(q.x*2.+iTime);     a = vec3(0.), b = -vec3(2.,0.,0.);\n     r = .1;\n     d2 = sdCapsule(q/2., a, b, r);\n    if (d2<d){\n        W.col = vec3(0.,.3,0.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 1.5;\n        d = d2;\n        W.eta = .9;\n\n\n     }\n     \n     \n    q = rotateZ(PI/2.)*q;\n    q.y = q.y - .3*clamp(round(q.y/.3), 0., 12.);\n    q.y *= 2.;\n    d2 = sdTorus(q/2., t/10.);\n    if (d2<d){\n        W.col = vec3(0.,2.,0.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 2.5;\n        d = d2;\n        W.eta = 1.;\n   }\n   \n   \n    q = p;\n    q.x -= .3*cos(p.y*1.);    \n    q.y += .3*sin(p.x*1.3+2.);\n    q.z += .3*cos(p.x*1.7+1.);\n    \n    q.z += .55*sin(q.x*2.+iTime);   \n    q.y += .55*cos(q.x*2.+iTime);\n     r = .1;\n     d2 = sdCapsule(q/2., a, b, r);\n    if (d2<d){\n        W.col = vec3(0.,0.,.3);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 1.5;\n        d = d2;\n        W.eta = .9;\n\n\n     }\n     \n     \n    q = rotateZ(PI/2.)*q;\n    q.y = q.y - .3*clamp(round(q.y/.3), 0., 12.);\n    q.y *= 2.;\n    d2 = sdTorus(q/2., t/10.);\n    if (d2<d){\n        W.col = vec3(0.,0.,2.);\n        W.cnt = smoothstep(.0, .015, abs(d-d2)-.001);\n        W.id = 2.5;\n        d = d2;\n        W.eta = 1.;\n   }    \n    return d;\n}\n\n\nfloat map(vec3 p, out worm W){\n    float d = 1e10;    \n    p += vec3(1., 0., 1.);\n    d = Worm(p, W);\n    return d;\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, float start, out worm W1) {\n  float depth = start;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = map(p, W1);\n    depth += d*.5;\n    if (d < PRECISION){\n        W1.depth = depth;\n        break;\n        }\n    else W1.id = 0.;\n    if (d>MAX_DIST){\n        W1.depth = 1e10;\n        break;\n    }\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    vec3 c;\n    worm obj;\n    return normalize(\n      e.xyy * map(p + e.xyy, obj) +\n      e.yyx * map(p + e.yyx, obj) +\n      e.yxy * map(p + e.yxy, obj) +\n      e.xxx * map(p + e.xxx, obj));\n}\n\nvec4 rayTransp(vec3 ro, vec3 rd, float depth, out worm W2, out float density, vec3 normal, float eta) {\n  vec3 p = ro + depth*rd;\n  ro = p;\n  depth = 0.;\n  float d=1.;\n  int iter = 0;\n  float dit = (fract(sin(dot(p, vec3(10.4886, 14.214654, 21.4567)))))*0.0002;\n  while (d>0.){\n      p = ro+depth*rd;\n      d = map(p, W2);\n      depth += .01;\n      iter += 1;\n      if (iter>10) break;\n  }\n  rd = refract(rd, normal, eta);\n  \n  for (int i = 0; i < 400; i++) {\n    p = ro + depth * rd;\n    d = map(p, W2);\n    depth += 0.002;\n    if (d<0.) density += 0.00025;\n        else break;\n     }\n   \n   return vec4(depth*rd, depth);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col, float spec) {\n  // ambient\n  float N = 2.;\n  vec3 ambient = (col*N)/N;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = (col * dotLN*N)/N;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal)/1.4, -rd), 0., 1.);\n  vec3 specular = 50.*spec*((.5*col+vec3(.5)) * pow(dotRV, 15.)*N)/N;\n\n  return ambient + diffuse + specular;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1)*4.;\n  \n  vec3 col = vec3(0);\n  float density = 0.;\n  vec3 col_tot = vec3(0.);\n  vec3 col_tot2 = vec3(0.);\n\n  vec3 ro = vec3(1., 1., 3.);\n  vec2 m = iMouse.xy/iResolution.xy;\n  if (m.xy == vec2(0.)){\n      m.x = .35;\n      m.y = .8;\n  }\n    vec3 tmp = vec3(-2., 0.,0. );\n  vec3 lookat = tmp;\n  ro.yz = ro.yz * 1. * rot(mix(PI/2., 0., m.y));\n  ro.xz = ro.xz * rot(mix(-PI, PI, m.x)) + vec2(lookat.x, lookat.z); \n  vec3 rd = camera(ro, lookat)*normalize(vec3(uv, -1));\n  worm W1 = worm(1e10, vec3(0.,0.,0.), 0., 0., 1.);\n  worm W2 = W1;\n  vec3 normal, normal2;\n  float d, d2;\n  for (int i = 0; i<AA+1; i++){\n      for (int j = 0; j<AA+1; j++){\n                    \n          vec3 rd2 = rd + vec3(float(i), float(j), 0.)*(.0005);\n          rayMarch(ro, rd2, MIN_DIST, W1); \n          float d = W1.depth;\n          if (d > MAX_DIST) {\n            col_tot = vec3(0.); \n          } else {\n            d = W1.depth;\n            vec3 p = ro + rd * d;\n            normal = calcNormal(p);\n            vec3 lightPosition = vec3(1, 1, 2);\n            vec3 lightDirection = normalize(lightPosition - p);\n            float lint = 5.;\n            \n            float eta = W1.eta;\n            vec4 rt = rayTransp(ro, rd2, d, W2, density, normal, eta);\n            \n            col_tot += 2.*density*lint*phong(lightDirection, normal, rd, W1.col/5., 3.);\n            \n            vec3 odir = refract(rd, normal, eta);\n            rayMarch(rt.xyz+ro, rd, d+dot(normalize(rd), normalize(odir))*rt.w+.1, W2);\n            \n            d2 = W2.depth;\n            if (d2 > MAX_DIST) {\n             col_tot += vec3(0.); \n            } else {\n                vec3 p = ro + rd * d2;\n                normal = calcNormal(p);\n                vec3 lightPosition = vec3(1, 1, 2);\n                vec3 lightDirection = normalize(lightPosition - p);\n                float lint = 5.;\n                col_tot2 += .1*(1.-density)*6.*phong(lightDirection, normal, rd, W2.col/5., 3.);\n            }\n\n       }\n    }\n    \n  }  \n  // Output to screen\n  fragColor = vec4(vec3(col_tot+col_tot2)/float(AA+1)/float(AA+1), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}