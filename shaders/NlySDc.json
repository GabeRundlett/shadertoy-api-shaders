{
    "Shader": {
        "info": {
            "date": "1641421978",
            "description": "My creation for #genuary #genuary2022 Genuary 2022 Day 5 day5 genuary5 05 five “Destroy a Square”\n[url]https://genuary.art/prompts#jan5[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "NlySDc",
            "likes": 13,
            "name": "#Genuary Day 5 Destroy a Square",
            "published": 3,
            "tags": [
                "slice",
                "rubix",
                "slicing",
                "rubiks",
                "genuary",
                "genuary2022"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "// Title: #Genuary Day 5\n// Started: 2022 1/5\n// Tags: slice, rubix, slicing, rubiks, genuary, genuary2022\n// Description: My creation for #genuary #genuary2022 Genuary 2022 Day 5 day5 genuary5 05 five “Destroy a Square”\n// [url]https://genuary.art/prompts#jan5[/url]\n\n\n\n// i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582097494459230\n//7816406286208998628\n#define TAU PI*2.\n\n#define arg mod(float(iFrame)/60./6.+.6, 1.)\n\n\n\n\n\n\n\n\n\n// sky map\n#define sund normalize(vec3(0., 0., -1.))\nvec3 sky_map (vec3 d) {\n    //return abs(d);\n    //return vec3(1.);\n    // return vec3(0., 0., 100./255.);\n    return vec3(1., 0., 0.);\n    \n    float dimness = .5+.5*clamp(cos(d.y*PI), -.8, .8);\n    \n    //return texture(iChannel2, d).rgb;\n    \n    vec3 aus = vec3(0.);\n    float licht;\n    licht = clamp(dot(d, normalize(vec3(1., 1., 1.)) ), 0., 1.);\n    aus += vec3(1.)*pow(licht, 1.);\n    licht = clamp(dot(d, normalize(vec3(0., 1., 1.)) ), 0., 1.);\n    aus += vec3(0., 0., 1.)*pow(licht, 5.);\n    \n    \n    //vec2 pl = d.xz/d.y*6.;\n    //if (d.y < 0.) { aus += mod(floor(pl.x)+floor(pl.y), 2.); }\n    \n    //return clamp(aus, 0., 1.);\n    \n    float a = 2.;\n    float ah = dot(vec3(d.x, -abs(d.y), d.z), normalize(vec3(0., -a, 0.)) );\n    float h = a/ah;\n    float o = sqrt(h*h-a*a);\n    float th = atan(d.z, d.x);\n    // g is where it hits the ground/sky\n    vec2 g = vec2(cos(th)*o, sin(th)*o);\n    \n    // get ths sky color\n    float cloudamt = 0.;\n    cloudamt += .7*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt += .3*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt = pow(cloudamt, 2.);\n    // cloudamt *= .4;\n    // cloudamt += .0*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/90.).r;\n    \n    vec3 SKY_COLOR = vec3(.0, .5, 1.);\n    SKY_COLOR += cloudamt;\n        // dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n    if (d.y > .2) {\n        return clamp(SKY_COLOR*pow(dimness, .05), 0., 1.);\n    }\n    else {\n        // return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n        vec3 GROUND_COLOR = vec3(.3, .5, .3)*(\n            .0+.8*texture(iChannel1, g/5.).r);\n        \n        GROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-\n            2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n        GROUND_COLOR *= 4.;\n        GROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n        \n        float puddleamt = .5+.5*sin(g.x*o*.05);\n        puddleamt = .5*puddleamt+.5*texture(iChannel1, vec2(g.x, g.y)/20.).r;\n        puddleamt = pow(puddleamt, .3);\n        dimness = mix(dimness, 1., puddleamt)*.5;\n        \n        if (puddleamt > .8) {\n            float amt = (puddleamt-.3)/.6;\n            amt = clamp(amt, 0., 1.);\n            amt = pow(amt, 2.);\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n        }\n        if (-.2 <= d.y && d.y <= .2) {\n            float amt = (d.y+.2)/.4;\n            dimness = mix(\n                dimness,\n                mix(\n                    dimness*2.,\n                    1.,\n                    -puddleamt\n                ),\n                amt\n            );\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n        }\n        return clamp(GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.)), 0., 1.);\n    \n    }\n\n}\n\n\n\n\n\n// related to tracing onto things (return distance and normal)\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n// plane - one liner lol\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n\n#define inter_plane_short(p, d, c, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(c-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, c, n) (\\\n//dot(n, d) > 1e-6 ? dot(c-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n// sphere\n#define SDF_sphere(p, c, r) ( length(p-c)-r )\n\n// #define inter_sphere(p, d, c, r) ( dot(d, c-p)\n\n\n// SDF\n\n#define SDF_sq(p) ( length(max(abs(p)-vec3(.98,.98,.1), 0.))-.01 )\n//#define SDF_core(p) ( length(max(abs(p)-.8, 0.))-.015 )\n//#define SDF(p) max(SDF_sq(p), -SDF_core(p) )\n#define SDF(p) SDF_sq(p)\n//#define SDF(p) ( length(p)-2. )\n\n\n\n\n#define inf vec2(1e-3, 0.)\n\n#define dSDF(p) normalize(vec3(SDF(p+inf.xyy),SDF(p+inf.yxy),SDF(p+inf.yyx))-SDFp)*sign(SDFp)\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // return inter_sphere(p, d, vec3(0.), .5);\n    float SDFp;\n    \n    vec3 camp = p;\n    \n    //for (int i=0; i<1333222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        if (abs(SDFp) < 1e-4) {\n            return vec4(dSDF(p), length(p-camp));\n        }\n        //p += d*abs(SDFp)*.5;\n        p += d*abs(SDFp);\n        if (abs(SDFp) > 10.) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\n\n\nvoid shift_shard (inout vec3 p, inout vec3 d, vec3 c, vec3 n, float angtot, float amt, out mat3 rot) {\n    #define iv .4\n    //p += n*.1*clamp(amt/iv, 0., 1.);\n    //p += n*.01;\n    //p -= n*.1*clamp((amt-iv)/(1.-iv), 0., 1.);\n    //p += n*.05;\n    p += n*.2*amt;\n    \n    float arg4 = clamp((amt-iv)/(1.-iv), 0., 1.);\n    \n    #define easen 5.\n    //arg4 = 1.- pow(.3, floor(arg4*(easen*2.-1.)/2.-.5)+1.) * abs(sin(PI*( arg4*(easen*2.-1.)/2. - .5)  ));\n    #undef easen\n    \n    //arg4 = .5-.5*cos(arg4*PI);\n    \n    p -= c;\n    // d -= c;\n    \n    \n    // https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    float th = arg4*angtot;\n    float costh = cos(th);\n    float ONE_MIN = 1.-costh;\n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    p = rot*p;\n    d = rot*d;\n    \n    th = -th;\n    costh = cos(th);\n    ONE_MIN = 1.-costh;\n    /*rot = mat3(\n        cos(th)+n.x*n.x*(1.-cos(th)),     n.x*n.y*(1.-cos(th))-n.z*sin(th), n.x*n.z*(1.-cos(th))+n.y*sin(th),\n        n.y*n.x*(1.-cos(th))+n.z*sin(th), cos(th)+n.y*n.y*(1.-cos(th)),     n.y*n.z*(1.-cos(th))-n.x*sin(th),\n        n.z*n.x*(1.-cos(th))-n.y*sin(th), n.z*n.y*(1.-cos(th))+n.x*sin(th), cos(th)+n.z*n.z*(1.-cos(th))\n    );*/\n    \n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    //nc = n;\n    //nc = vec3(1., 0., 0.);\n    \n    p += c;\n    // d += c;\n    //#undef iv\n}\n\n\n#define numpanes 5\nvec4 inter_shattered (vec3 p, vec3 d, vec3 panec[numpanes],\n    vec3 panen[numpanes], float angtot[numpanes], inout vec3 pT, inout vec3 dT, out int midspace) {\n    //pT = p; dT = d; return inter_SDF(p, d);\n    float arg2 = min(arg*2., 2.-arg*2.);\n    //arg2 = max(1.+(arg2-1.)*1.0, 0.);\n    arg2 = min(arg2*1.4, 1.);\n    arg2 = max(1.-(1.-arg2)*1.4, 0.);\n    vec4 inter_closest;\n    vec4 inter_pane1;\n    vec4 inter_pane1T;\n    vec4 inter_SDF1;\n    //\n    float arg3; mat3 rottot = mat3(1.); mat3 rottot_; mat3 rot;\n    // for jumps\n    inter_closest = inter_sky;\n    pT = p;\n    dT = d;\n    midspace = 0;\n    //for (int i=0; i<numpanes; ++i) {\n    for (int i=numpanes-1; i>=0; --i) {\n        pT = p;\n        dT = d;\n        arg3 = clamp(arg2*float(numpanes)-float(i), 0., 1.);\n        if (arg3 == 0.) {continue;}\n        \n        if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n            // upper space - no transform\n            inter_pane1 = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            if (inter_pane1.w < inter_closest.w) {\n                inter_closest = inter_pane1;\n            }\n        }\n        else {\n            // keep track of plane in original space\n            inter_pane1 = inter_plane(p, d, panec[i], panen[i]);\n            // warp space and check stuff\n            shift_shard(pT, dT, panec[i], panen[i], angtot[i],\n                arg3, rot\n            );\n            \n            rottot_ = rottot;\n            // rottot = rot*rottot;\n            rottot = rottot * rot;\n            \n            inter_pane1T = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            \n            if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n                // midspace - can only trace onto 2 planes to escape\n                midspace += 1;\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n                if (inter_pane1.w < inter_closest.w) {\n                    // we are dealing in untransformed space\n                    // this one pane gets the texture coords of\n                    // upper space\n                    pT = p;\n                    dT = d;\n                    inter_closest = inter_pane1;\n                    inter_closest.xyz = rottot_ * inter_closest.xyz;\n                }\n            }\n            else {\n                // lower space - can only trace onto transformed\n                // pane or obj\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n            }\n            \n        }\n        p = pT;\n        d = dT;\n    }\n    if (midspace == 0) {\n        inter_SDF1 = inter_SDF(pT, dT);\n        if (inter_SDF1.w < inter_closest.w) {\n            inter_closest = inter_SDF1;\n        }\n        inter_closest.xyz = rottot*inter_closest.xyz;\n    }\n    \n    \n    \n    return inter_closest;\n    //return inter_sky;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 panec[numpanes];\n    vec3 panen[numpanes];\n    float angtot[numpanes];\n    \n    panec[0] = vec3(.0, .0, .0);\n    panec[1] = vec3(.0, .0, .0);\n    panec[2] = vec3(.0, .0, .0);\n    panec[3] = vec3(.0, .0, .0);\n    panec[4] = vec3(.0, .0, .0);\n    \n    panen[0] = normalize(vec3(2., 3., 0.));\n    panen[1] = normalize(vec3(0., 0., 1.));\n    panen[2] = normalize(vec3(2., 1., 0.));\n    panen[3] = normalize(vec3(-1., 6., 0.));\n    panen[4] = normalize(vec3(-1., 1., 0.));\n    \n    /*angtot[0] = PI;\n    angtot[1] = PI*.5;\n    angtot[2] = PI*.5;\n    angtot[3] = TAU/3.;\n    angtot[4] = PI;*/\n    angtot[0] = PI;\n    angtot[1] = PI/3.;\n    angtot[2] = PI;\n    angtot[3] = PI;\n    angtot[4] = PI;\n    \n    #define spw 1.\n    vec3 finalCol = vec3(0.);\n    float ox; float oy;\n    for (ox=0.; ox<spw; ++ox) {\n        for (oy=0.; oy<spw; ++oy) {\n            vec2 screen = (fragCoord.xy+vec2(ox, oy)/spw-iResolution.xy/2.)/iResolution.y;\n\n            // camera\n            #if 0\n            // perspective\n            vec3 camp = vec3(0., 0., -2.);\n            vec3 camd = normalize(vec3(screen.x, screen.y, .5));\n            //vec3 p = vec3(0.);\n            //vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n            #else\n            // orthogonal\n            vec3 camp = vec3(screen.x, screen.y, 0.)*6.*(sqrt(2.)/2.);///cos(30.*PI/180.);\n            vec3 camd = normalize(vec3(0., 0., 1.));\n            camp -= camd*4.;\n            #endif\n            \n            float ph = 0.;\n            float th = 0.;\n            th += clamp((arg-.1)/(1.-.1), 0., 1.)*TAU+PI;\n            //if (iMouse.z > 0.0001) {\n            if (iMouse.x >= 0.0001) {\n                ph = (iMouse.y/iResolution.y*2.-1.)*4.;\n                th = (iMouse.x/iResolution.x*2.-1.)*TAU;\n            }\n            mat2 zenith = mat2(\n                cos(ph), cos(PI*.5+ph),\n                sin(ph), sin(PI*.5+ph)\n            );\n            camd.yz *= zenith;\n            camp.yz *= zenith;\n            mat2 azimuth = mat2(\n                cos(th), cos(PI*.5+th),\n                sin(th), sin(PI*.5+th)\n            );\n            camd.xz *= azimuth;\n            camp.xz *= azimuth;\n\n            // retina color at point from raytracing\n            vec3 retina = vec3(0.);\n            float shiny = 1.;\n            vec4 inter_shattered1;\n            vec3 p = camp;\n            vec3 d = camd;\n            vec3 pT;\n            vec3 dT;\n            int midspace;\n            bool wasout;\n            bool isout;\n            vec3 pT2;\n            vec3 dT2;\n\n            //vec4 inter_cam = inter_plane(\n            //    p, d, normalize(p)*.5, normalize(p-vec3(0.))\n            //);\n            //p += d*inter_cam.w;\n\n            for (int bounces=0; bounces<37; ++bounces) {\n                if (shiny < .1) {\n                    break;\n                }\n                inter_shattered1 = inter_shattered(\n                    p, d, panec, panen, angtot, pT, dT, midspace\n                );\n                if (inter_shattered1.w >= inter_sky.w) {\n                    // too far - hits sky\n                    break;\n                }\n                else {\n                    p += d*inter_shattered1.w;\n                    pT += dT*inter_shattered1.w;\n\n\n                    wasout = midspace > 0 || SDF(pT) > 1e-3;\n                    inter_shattered(\n                        p+d*1e-2, d, panec, panen, angtot, pT2, dT2, midspace);\n\n                    if (abs(SDF(pT)) < 1e-3 ) {\n                    //if (abs(SDF(pT)) < 1e-3 || SDF(pT) < 1e-2 &&\n                    //    sign_shattered(p+d*1e-2, panec, panen) !=\n                    //    sign_shattered(p-d*1e-2, panec, panen) ) {\n                    //if (wasout != isout) {\n                    //if (abs(SDF(pT)) < 1e-3 ||\n                    //    wasout != (midspace > 0 || SDF(pT2+dT2*1e-2) > 1e-3)) {\n\n                        // hits object - have distance to intersection and normal\n\n                        /*//vec3 TEXp = .5+.5*(inter_shattered1.xyz);\n                        float SDFp = SDF(pT);\n                        vec3 seid = abs(dSDF(pT) );\n\n                        vec3 TEXp = vec3(0., 0., 0.);\n                        float ang1;\n\n                        ang1 = acos(dot(seid, vec3(0., 1., 0.) ));\n                        TEXp = mix(TEXp, vec3(0., 1., 1.), 1.-clamp(\n                            ang1/(PI*.5),\n                            0., 1.\n                        ));\n\n                        ang1 = acos(dot(seid, vec3(1., 0., 0.) ));\n                        TEXp = mix(TEXp, vec3(1., 1., 1.), 1.-clamp(\n                            ang1/(PI*.5),\n                            0., 1.\n                        ));\n\n                        ang1 = acos(dot(seid, vec3(0., 0., 1.) ));\n                        TEXp = mix(TEXp, vec3(0., 0., 1.), 1.-clamp(\n                            ang1/(PI*.5),\n                            0., 1.\n                        ));\n\n                        #if 1\n                        TEXp = mix(\n                            TEXp,\n                            vec3(.3),\n                            .0+.3*mod(floor(pT.x*9.+.001)+floor(pT.y*9.+.001)+floor(pT.z*9.+.001), 2.)\n                        );\n                        #endif\n                        //TEXp = abs(inter_shattered1.xyz);\n                        //TEXp = vec3(0.);\n                        */\n                        vec4 inter_closest = inter_shattered1;\n                        //vec3 specular = sky_map(reflect(camd, inter_closest.xyz));\n                        float specularh = clamp(dot(reflect(d, inter_closest.xyz), sund ), 0., 1.);\n                        //float specularh = length(specular)/sqrt(3.);\n                        vec3 TEXp;\n\n                        #define cz1 10.\n\n                        //if (mod(floor(pT.x*cz1-inf.x)+floor(pT.y*cz1-inf.x)+floor(pT.z*cz1-inf.x), 2.) < 1.) {\n                        //if (abs(SDF(pT)) < 1e-3 && !(length(pT-vec3(1., 0., 0.)) < .5) ) {\n                        //if (abs(SDF(pT)) < 1e-3) {\n                        if (true) {\n                            if (pT.z > 0.) {\n                                // pearly white\n                                float diffuse = clamp(dot(inter_closest.xyz, sund ), 0., 1.);\n                                // specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, 4.);\n                                float gx = clamp(.5+.5*pT.x, 0., 1.);\n                                float gy = clamp(.5+.5*pT.y, 0., 1.);\n                                TEXp = vec3(0., gx, gy)+specularh*.7;\n\n\n                                #define shininess .9993\n                                //#define shininess clamp(.5+2.*pT.y, 0.2, 1.)\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                            else {\n                                // shiny black\n                                float diffuse = clamp(dot(inter_closest.xyz, sund ), 0., 1.);\n                                // specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, .4);\n                                TEXp = vec3(.0)+specularh*.7;\n\n\n                                #define shininess .9993\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                        }\n                        else {\n                            // heres for blue bubble\n                            /*vec4 inter_inside = inter_sphere(camp, camd, closest_center, closest_r, true);\n                            vec2 glob = vec2(\n                                .5+.5*dot(inter_inside.xyz, normalize(vec3(0., -1., .5)) ),\n                                .5+.5*dot(inter_closest.xyz, normalize(vec3(0., -1., .5)) )\n                            );\n                            float glo = length(glob)/sqrt(2.);*/\n                            float glo = 1.-(.5+.5*p.y); //mod(p.y*cz1, 1.);\n\n                            glo = 3.*glo*glo-2.*glo*glo*glo;\n                            //glo = pow(glo, 1.7);\n\n                            specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                            specularh = pow(specularh, 1.5);\n\n                            float glo2 = pow(glo, 2.);\n                            TEXp = vec3(.0, .3, .5) + vec3(.0*glo2, .5*glo2, .5*glo) + vec3(1.)*specularh*.95;\n\n\n                            #define shininess .002999\n                            retina += TEXp*shiny*shininess;\n                            shiny *= 1.-shininess;\n                            //d = reflect(d, inter_shattered1.xyz);\n                            p += d*1e-3;\n                            #undef shininess\n                        }\n                    }\n                    else {\n                        // hits pane - translucency if want debug\n\n                        vec3 TEXp = abs(inter_shattered1.xyz)*0.+mod(\n                            floor(p.x+1e-3)+floor(p.y+1e-3)+floor(p.z+1e-3),\n                            2.\n                        );\n                        #define shininess .0\n                        retina += TEXp*shiny*shininess;\n                        shiny *= 1.-shininess;\n\n                        //d = reflect(d, inter_shattered1.xyz);\n                        p += d*1e-4;\n                        #undef shininess\n                    }\n                }\n            }\n\n            if (shiny == 1.) {\n                // white background if never hit obj\n                retina = vec3(0., 0., 100./255.);\n                shiny *= 0.;\n            }\n\n            // add sky color to last reflection/refaction etc.\n            retina += shiny*sky_map(d);\n            finalCol += retina;\n        }\n    }\n    finalCol /= float(spw*spw);\n    fragColor = vec4(finalCol, 1.);\n    \n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}