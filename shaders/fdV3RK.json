{
    "Shader": {
        "info": {
            "date": "1631805657",
            "description": "My first time working with physics in shaders and trying some new effects.\nYeah the car model sucks but you get the idea\n\nNOTE: You can drive the car by uncommenting line 9 in Buffer A",
            "flags": 48,
            "hasliked": 0,
            "id": "fdV3RK",
            "likes": 9,
            "name": "Simple drifting",
            "published": 3,
            "tags": [
                "2d",
                "smoke",
                "physics",
                "car",
                "opacity"
            ],
            "usePreview": 0,
            "username": "NLIBS",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "float heightmap(vec2 pos)\n{\n    float h1 = exp(-length(pos)*5.)*0.08+0.92;\n    pos *= vec2(3,1);\n    float h2 = 2.0-max(abs(pos.x),min(abs(pos.y)+0.03,.05+0.03))*.6;\n    return h1*h2;\n}\n\nvec2 diff(vec2 pos)\n{\n    vec2 d = heightmap(pos) - heightmap(pos+vec2(0.001,0))*vec2(1,0) - heightmap(pos+vec2(0,0.001))*vec2(0,1);\n    return d/0.001;\n}\n\nvec3 gradient(float x)\n{\n    return vec3(0.3,0.0,0.7)+clamp(x,0.,1.3)*vec3(0.5,0.5,-0.2);\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R  = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    float txl = 1./R.x;\n    \n    vec3 col = gradient(U.x/R.x);\n    col *= 1.0-pow(texelFetch(iChannel1,ivec2(U),0).rgb,vec3(0.9))*0.7;\n         \n    vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n    pv.x = mod(pv.x+50.,100.)-50.;\n    vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n    vec2 p = pv.xy;\n    vec2 v = pv.zw;\n     \n    mat2 rot = mat2(cos(ra.x),sin(ra.x),-sin(ra.x),cos(ra.x));\n    \n    vec2 d = abs((p-uv)*rot)*vec2(1,2);\n    float m = pow(pow(d.x,6.0)+pow(d.y,6.0),1./6.);\n    vec4 car = vec4(1,0.05,0,smoothstep(0.04+txl*4.,0.04,m));\n    \n    vec2 n2 = -diff((p-uv)*rot*vec2(1,2)) * inverse(rot);\n    vec3 n = normalize(vec3(n2,1.5));\n    vec3 ref = reflect(vec3(uv,-10.0),n);\n    float t = -heightmap(d) / ref.z;\n    t=abs(t);\n    vec2 hit = U/R +  t*ref.xy*.1;\n    \n    car.rgb = gradient(hit.x);\n    car.rgb *= 1.0-texture(iChannel1,hit).rgb*0.7;\n    car.rgb = mix(gradient(hit.x)*0.2+0.6,car.rgb,exp(-3.*texture(iChannel2,hit).r));\n    car.rgb = vec3(1,1,0.1)*gradient(U.x/R.x+1.*n.x)*0.5 + car.rgb*0.5;\n    \n    col = mix(pow(gradient(U.x/R.x),vec3(0.3)),col,exp(-3.*texelFetch(iChannel2,ivec2(U),0).r));\n\n    O = mix(vec4(col,0),car,car.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Buffer A: Physics\n\n#define ENGINE 1.0\n#define GRIP 0.00125\n#define TURNING 0.15\n#define DRAG 0.005\n#define DT iTimeDelta\n\n#define AUTONOMOUS\n\n// keysw\nint kA=65,kD=68,kS=83,kW=87;\nint kLeft=37,kUp=38,kRight=39,kDown=40;\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    //Position and Velocity\n    if (ivec2(U)==ivec2(0)) {\n        vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n        pv.x = mod(pv.x+50.,100.)-50.;\n        \n        vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n        \n        #ifdef AUTONOMOUS\n        float drive = DT;\n        #else \n        float drive = (min(texelFetch(iChannel1,ivec2(kW,0),0).x+texelFetch(iChannel1,ivec2(kUp  ,0),0).x,1.0)\n                      -min(texelFetch(iChannel1,ivec2(kS,0),0).x+texelFetch(iChannel1,ivec2(kDown,0),0).x,1.0) )*DT;\n        #endif\n\n        vec2 fwrd_dir = vec2(cos(ra.x),sin(ra.x));\n        vec2 rght_dir = fwrd_dir.yx*vec2(-1,1);\n        float fwrd = dot(pv.zw,fwrd_dir);\n        float rght = dot(pv.zw,rght_dir);\n        \n        //Accelerating, braking\n        fwrd = (max(drive,0.)*min(ENGINE,GRIP)+fwrd+max(min(drive,0.)*sign(fwrd)*GRIP,-abs(fwrd)));           \n        //Sideways tire grip\n        rght = max(abs(rght)-GRIP*DT,0.)*sign(rght);\n        pv.zw = fwrd_dir*fwrd  +  rght_dir*rght;\n        \n        float m = length(pv.zw)+.0001;\n        pv.zw *= max(m-DRAG*m*m,0.)/m;\n        \n        pv.xy += pv.zw*DT*144.;\n        pv.xy = (fract(pv.xy*R.x/R.xy*.47+.5)-0.5)/0.47*R.y/R.yx;\n        \n        if (abs(rght)>GRIP/60. || drive<0.&&fwrd>0.)\n            pv.x += 100.;\n        if (drive*ENGINE>GRIP+m*3.)\n            pv.x += 100.;\n        \n        O = pv;\n        \n    //Angle and Rotation speed\n    } else if (ivec2(U)==ivec2(1,0)) {\n        vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n        vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n        \n        pv.x = mod(pv.x+50.,100.)-50.;\n        vec2 fwrd_dir = vec2(cos(ra.x),sin(ra.x));\n        float fwrd = abs(dot(pv.zw,fwrd_dir));\n        fwrd *= 0.3+0.7*step(0.,fwrd);\n        \n        #ifdef AUTONOMOUS\n        float t = iTime*0.5;\n        float a = (sin(t*2.)/2.+sin(t*5.4)/5.4+sin(t*11.5)/11.5)*1.2985;\n        ra.y += min(sqrt(abs(a))*0.7,1.0)*sign(a)*DT*TURNING;\n        #else \n        ra.y += (min(texelFetch(iChannel1,ivec2(kA,0),0).x+texelFetch(iChannel1,ivec2(kLeft ,0),0).x,1.0)\n                -min(texelFetch(iChannel1,ivec2(kD,0),0).x+texelFetch(iChannel1,ivec2(kRight,0),0).x,1.0) )*DT*TURNING*min(fwrd*500.,1.);\n        #endif\n        \n        ra.y *= pow(.001,DT);\n        ra.x+=ra.y*DT*144.;\n        ra.x = mod(ra.x,6.283185);\n        \n        O = ra;\n    }\n    if (iFrame<1) O-=O;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Buffer B: Tyre rubber effect\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R  = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    float txl = 1./R.x;\n    \n    vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n    float slip = pv.x;\n    pv.x = mod(pv.x+50.,100.)-50.;\n    vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n    float speed = length(pv.zw);\n    vec2 noise = texelFetch(iChannel2,ivec2(U)%1024,0).rg;\n    vec2 p = pv.xy - pv.zw*noise*iTimeDelta*144.;\n    vec2 v = pv.zw;\n    \n    vec4 col = texelFetch(iChannel1,ivec2(U),0)*pow(0.98,iTimeDelta);\n    col.a = 0.;\n    //col = texelFetch(iChannel1,ivec2(U+pv.zw*R*1.),0);\n    //col = texture(iChannel1,U/R+pv.zw);\n     \n    mat2 rot = mat2(cos(ra.x),sin(ra.x),-sin(ra.x),cos(ra.x));\n    \n    //float car = step(dot(p-uv,p-uv),0.0005);\n    float rubber = 0.0;\n    float slip_front = step(50.,slip)*0.5;\n    float slip_rear  = slip_front+step(100.,slip)*0.5;\n    \n    \n    //Rear right\n    vec2 d = abs((p-uv - vec2(0.032,0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_rear;\n    //Rear left\n    d = abs((p-uv - vec2(0.032,-0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_rear;\n    //Front right\n    d = abs((p-uv - vec2(-0.032,0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_front;\n    //Front left\n    d = abs((p-uv - vec2(-0.032,-0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_front;\n    \n    \n    rubber = min(rubber,1.0)*0.3*min(speed*200.,5.)*iTimeDelta*144.;\n    \n\n    O = col+rubber;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Buffer C: Smoke effect\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R  = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    float txl = 1./R.x;\n    \n    vec4 col = vec4(0);\n    \n    for (int i = 0; i<9; i++) {\n        col += texelFetch(iChannel1,ivec2(U)+ivec2(i%3-1,i/3-1),0);\n    }\n    col *= 0.11111*pow(0.94,iTimeDelta);\n    \n    float new_rubber = texelFetch(iChannel0,ivec2(U),0).a;\n    col += new_rubber*0.6;\n    \n    O = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}