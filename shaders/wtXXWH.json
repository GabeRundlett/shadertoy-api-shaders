{
    "Shader": {
        "info": {
            "date": "1562700419",
            "description": "Use mouse to get aliasing. Noise added in left half but aliasing sometimes present anyway. 8 times anti aliasing at bottom half not perfect either. Nor their combination at bottom left. Are there any other methods to prevent aliasing?",
            "flags": 0,
            "hasliked": 0,
            "id": "wtXXWH",
            "likes": 0,
            "name": "Counter aliasing of curves",
            "published": 3,
            "tags": [
                "aliasing"
            ],
            "usePreview": 0,
            "username": "davidjonsson",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "// Examples of aliasing and means to lessen it.\n// Bottom half is using traditional anti aliasing by taking averages in subpixels.\n// Left half adds noise to the sine function.\n// has22(...) is taken from Dave Hoskins \"Hash wihout Sine\".\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 relativeMouse = iMouse.xy/iResolution.xy;\n    vec2 relativePixelSize = vec2(1.) / iResolution.xy; \n    vec3 col;\n    vec2 pos = vec2(fragCoord.xy *.3) + 500. + 50.0;\n\tvec2 middleUv = uv + vec2(-.5, -.5);\n\t\n    // nothing done to signal\n    col = .5 -.5*sin(10000.*distance(relativeMouse * middleUv, vec2(.0, .0))) * vec3(1.);\n\t\n    // add noise in sin() distributed between 0 and pixel size\n    vec3 colWithNoise;\n    vec2 randomness;\n    randomness = relativePixelSize  * hash22(pos);\n    colWithNoise = .5 -.5*sin(10000.*distance(relativeMouse * (middleUv + randomness), vec2(.0, .0))) * vec3(1.);             \n    \n    // make anti aliasing\n    vec3 colAntiAliasing = vec3(0.);\n    vec3 colAntiAliasingWithNoise = vec3(0.);\n    int antiAliasingSize = 8;\n    for (int i = 0; i < antiAliasingSize; i++) {\n        for (int j = 0; j < antiAliasingSize; j++) {\n            vec2  fragCoordAA = fragCoord + \n                vec2(float(i)/float(antiAliasingSize), float(j)/float(antiAliasingSize));\n            middleUv = fragCoordAA/iResolution.xy + vec2(-.5, -.5);\n            colAntiAliasing += .5 -.5*sin(10000.*distance(relativeMouse * middleUv, vec2(.0, .0))) * vec3(1.);             \n    // make anti aliasing and noise\n    \t\tpos = vec2(fragCoordAA *.3) + 500. + 50.0;\n            randomness = relativePixelSize * hash22(pos);\n            colAntiAliasingWithNoise += .5 -.5*sin(10000.*distance(relativeMouse * (middleUv + randomness), vec2(.0, .0))) * vec3(1.);             \n        }\n    }\n\tcolAntiAliasing /= float(antiAliasingSize * antiAliasingSize);\n\tcolAntiAliasingWithNoise /= float(antiAliasingSize * antiAliasingSize);\n        \n    col = vec3(mix(col, colWithNoise, step(uv.x, .5)));\n    col = vec3(mix(col, colAntiAliasing, step(uv.y, .5)));\n    col = vec3(mix(col, colAntiAliasingWithNoise, step(uv.x, .5) * step(uv.y, .5)));\n    col = mix(vec3(.4, 0.0, .6), col, smoothstep(.5, .495, uv.x) + smoothstep(.5, .505, uv.x));\n    col = mix(vec3(.4, 0.0, .6), col, smoothstep(.5, .49, uv.y) + smoothstep(.5, .51, uv.y));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}