{
    "Shader": {
        "info": {
            "date": "1634987330",
            "description": "NoxWings Logo",
            "flags": 32,
            "hasliked": 0,
            "id": "fsVXzy",
            "likes": 2,
            "name": "NoxWings Logo",
            "published": 3,
            "tags": [
                "noxwingslogo"
            ],
            "usePreview": 0,
            "username": "NoxWings",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "#define USE_POST             1\n\n#define BARREL_DISTORTION    1\n#define SCAN_LINES\t\t\t 1\n#define CHROMATIC_ABERRATION 1\n#define VIGNETTE             1\n\nfloat POST_INTENSITY() {\n    return 0.7;\n}\n\nfloat crtCurve(in vec2 uv)\n{\n    float domeCurvature = 3.0;\n    float domex = 1.0 - pow(abs(uv.x), domeCurvature);\n    float domey = 1.0 - pow(abs(uv.y), domeCurvature);\n    return domex * domey;\n}\n\nvec2 crtDistortedUV(in vec2 uv, in float strength)\n{\n    vec2 s = 1.0/iResolution.xy;\n    vec2 offset = vec2(1, 0);\n\n    float p = crtCurve(uv);\n    float h1 = crtCurve(uv + s * offset.xy);\n    float v1 = crtCurve(uv + s * offset.yx);\n\n   \treturn uv - (p - vec2(h1, v1)) * strength;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 texUV = uv;\n    vec3 color = vec3(0);\n\n#if USE_POST == 1\n    #if BARREL_DISTORTION == 1\n    {\n        float distortion = 30.0;\n        distortion = mix(0.0, distortion, POST_INTENSITY());\n        vec2 compression = distortion / vec2(300.0, 200.0);\n\n        // Compression\n        uv2 *= 1.0 + compression;\n        // Distortion\n        uv2 = crtDistortedUV(uv2, distortion);\n\n        if (abs(uv2.x) > 1.0 || abs(uv2.y) > 1.0)\n        {\n            fragColor = vec4(vec3(0), 1.0);\n            return;\n        }\n\n        texUV = uv2 * 0.5 + 0.5;\n    }\n    #endif\n#endif\n\n    vec4 buffer = texture(iChannel0, texUV);\n    color = buffer.rgb;\n\n#if USE_POST == 1\n    #if CHROMATIC_ABERRATION == 1\n    {\n\t\tfloat intensity = 0.00007 * POST_INTENSITY();\n        float lensDistortion = 0.4;\n\n        float radialIntensity = pow(length(uv2), lensDistortion);\n    \tvec2 radialDirection = normalize(uv2);\n\n        //fragColor = vec4(radialIntensity); return;\n\n\t    vec3 waveLengths = vec3(440, 575, 650);\n\t    vec3 offsets = (waveLengths.g - waveLengths) * intensity * radialIntensity;\n\n        float mixed = clamp(length(uv2) + 0.1, 0.0, 1.0);\n\n    \tcolor.r = mix(color.r, texture(iChannel0, texUV + radialDirection * offsets.r).r, mixed);\n    \tcolor.b = mix(color.b, texture(iChannel0, texUV + radialDirection * offsets.b).b, mixed);\n    }\n    #endif\n\n\t#if VIGNETTE == 1\n    {\n    \tfloat radial = 1.0 - clamp(-0.2 + pow(length(uv2 / 1.4), 2.2), 0.0, 1.0);\n        radial = mix(1.0, radial, POST_INTENSITY());\n    \tcolor.rgb *= vec3(radial);\n    }\n    #endif\n\n    #if SCAN_LINES == 1\n    {\n        float lines = iResolution.y / 6.0;\n        float scan = smoothstep(0.03, 0.2, fract(uv.y * lines));\n        scan = mix(1.0, scan, POST_INTENSITY());\n\t    color *= scan;\n    }\n    #endif\n#endif\n\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//------------------------------------------------------------------------------\n// Math\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float HALF_PI = PI * 0.5;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = TAU/360.;\n\nmat2 rot2D(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\n#define AA .01\n#define S(x, y, z) smoothstep(x, y, z)\n#define animTime (mod(iTime, 10.))\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,animTime))\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circle(vec2 uv, float r) {\n    return S(r+AA, r, length(uv));\n}\n\nfloat arc(vec2 uv, vec2 rs, float offset) {\n    vec3 r = vec3(rs, 0);\n    vec2 o2 = vec2(offset/2., 0);\n\n    float shape = circle(uv + r.xz - o2, rs.x);\n    return clamp(shape - circle(uv + r.yz + o2, rs.y), 0.0, 1.0);\n}\n\nmat3 translation(vec2 m) {\n    return mat3(1, 0, m.x, 0, 1, m.y, 0, 0, 1);\n}\n\nmat3 rotation(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat3(ca, sa, 0, -sa, ca, 0, 0, 0, 1);\n}\n\nmat3 rotateAroundMatrix(vec2 pivot, float angle) {\n    return translation(pivot) * rotation(angle) * translation(-pivot);\n}\n\nvec2 rotateAround(vec2 point, vec2 pivot, float angle) {\n    return vec2(vec3(point, 1) * rotateAroundMatrix(pivot, angle));\n}\n\nfloat logo(vec2 uv, float t) {\n    float invT = 1.0 - t;\n\n    vec2 arcOffset = vec2(.45, .3);\n    vec2 arcBalls = vec2(.6, .65);\n    float arcWidth = .055;\n\n    // the last rot2D(invT) is not exact\n    vec2 topArcPosition = (uv * rot2D(.25) - arcOffset) * rot2D(invT);\n    vec2 botArcPosition = (uv * rot2D(PI + .25) - arcOffset) * rot2D(invT);\n\n    float turns = 5.;\n    topArcPosition = rotateAround(topArcPosition, vec2(arcBalls.x, 0), turns*TAU*invT);\n    botArcPosition = rotateAround(botArcPosition, vec2(arcBalls.x, 0), turns*TAU*invT);\n\n    float topArc = arc(topArcPosition, arcBalls, arcWidth);\n    float bottomArc = arc(botArcPosition, arcBalls, arcWidth);\n\n    float shape = topArc;\n    shape += bottomArc;\n    shape += circle(uv, .15);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1);\n\n    vec3 col = vec3(0);\n\n   \tfloat logoFadeIn = S(0.0, 1.0, animTime);\n    float shapeFadeIn = S(0.0, 5.0, animTime);\n    float shapeTurn = S(0.0, 5.0, animTime);\n    float logoFadeOut = S(7.5, 10., animTime);\n\n    float shape = logo(uv, shapeTurn) * shapeFadeIn;\n    col = vec3(hash12(uv * 100. * (1. + animTime))) - vec3( shape );\n    col = mix(vec3(0), col, logoFadeIn);\n    col = mix(col, vec3(0), logoFadeOut);\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}