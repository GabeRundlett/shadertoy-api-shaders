{
    "Shader": {
        "info": {
            "date": "1672770608",
            "description": "For genuary day three, made a glitchy thing!",
            "flags": 0,
            "hasliked": 0,
            "id": "ct2Gzz",
            "likes": 5,
            "name": "Glitched lines",
            "published": 3,
            "tags": [
                "glitch",
                "genuary",
                "genuary2023",
                "genuary3"
            ],
            "usePreview": 1,
            "username": "callumacrae",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "#define LINES 20.0\n#define LINE_WIDTH 4.0\n#define LINE_SMOOTH_WIDTH 1.5\n\n#define GLITCH_COLOR_INVERT_ENABLED true\n#define GLITCH_COLOR_SPLIT_ENABLED true\n#define GLITCH_COLOR_SWAP_ENABLED true\n\n#define GLITCH_POSITION_RECT_SWAP_ENABLED true\n#define GLITCH_POSITION_Y_BAND_SHIFT_ENABLED true\n#define GLITCH_POSITION_FLIP_ENABLED true\n\n#define GLITCH_OTHER_BREAK_REFLECTION_ENABLED true\n#define GLITCH_OTHER_BLANK_ENABLED true\n#define GLITCH_OTHER_LINE_WIDTH_CHANGES_ENABLED true\n\n/** VENDOR START **/\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(int n) { return rand(float(n)) * 1000.0; }\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){ const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }\n\n// https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n/** VENDOR END **/\n\nfloat drawLine(vec2 fragCoord, float i) {\n  float lineWidth = LINE_WIDTH;\n\n  if (GLITCH_OTHER_LINE_WIDTH_CHANGES_ENABLED) {\n    float lineWidthNoise = snoise(vec2(iTime * 2.0 + rand(35), 0.0));\n    if (lineWidthNoise < -0.7) {\n      lineWidth *= 3.0;\n    }\n  }\n\n  float innerWidth = lineWidth / 2.0;\n  float outerWidth = lineWidth / 2.0 + LINE_SMOOTH_WIDTH;\n\n  float lineY = iResolution.y / LINES * (i + 0.5) ;\n  float angleRoot = snoise(vec2(iTime * 0.1 + rand(1), 0.0)) * 0.2;\n  float angleFactor = snoise(vec2(iTime * 0.08 + rand(2), 0.0)) * 0.015;\n  float angle = angleRoot + (LINES / 2.0 - i) * angleFactor;\n\n  float x = fragCoord.x;\n\n  bool shouldReflect = !GLITCH_OTHER_BREAK_REFLECTION_ENABLED ||\n    snoise(vec2(iTime * 1.2 + rand(15), 0.0)) > -0.5;\n  float reflectAt = iResolution.x * 0.33 + snoise(vec2(iTime * 0.1 + rand(3), 0.0)) * 100.0;\n  float reflectedMultFact = 1.5 + snoise(vec2(iTime * 0.12 + rand(4), 0.0)) * 1.0;\n  x = shouldReflect && x < reflectAt\n    ? reflectAt + reflectedMultFact * (reflectAt - x)\n    : x;\n\n  float lineYAtX = lineY - x * tan(angle);\n\n  if (fragCoord.y > lineYAtX - outerWidth && fragCoord.y < lineYAtX + outerWidth) {\n    return smoothstep(outerWidth, innerWidth, abs(fragCoord.y - lineYAtX));\n  }\n  return 0.0;\n}\n\nvoid generateRectangle(out float width, out float height, out vec2 topLeft,\n    int randFrom, float minWidth, float maxWidth, float widthVar,\n    float minHeight, float maxHeight, float heightVar) {\n  float widthNoise = (snoise(vec2(iTime * widthVar + rand(randFrom + 12))) + 1.0) / 2.0;\n  width = iResolution.x * (minWidth + widthNoise * (maxWidth - minWidth));\n  float heightNoise = (snoise(vec2(iTime * heightVar + rand(randFrom + 13))) + 1.0) / 2.0;\n  height = iResolution.x * (minHeight + heightNoise * (maxHeight - minHeight));\n\n  topLeft = iResolution.xy * (vec2(\n    snoise(vec2(iTime * 0.05 + rand(randFrom + 6), 0.0)),\n    snoise(vec2(iTime * 0.1 + rand(randFrom + 7), 0.0))\n  ) * 0.5 + 0.5) - width / 2.0;\n}\n\nbool isInRectangle(float width, float height, vec2 topLeft, vec2 fragCoord) {\n  return fragCoord.x > topLeft.x && fragCoord.x < topLeft.x + width &&\n    fragCoord.y > topLeft.y && fragCoord.y < topLeft.y + height;\n}\n\nvoid swapRectangle(inout vec2 fragCoord, int randFrom, int randFromB) {\n  float width;\n  float height;\n  vec2 topLeftA;\n\n  generateRectangle(width, height, topLeftA, randFrom, 0.2, 0.5, 0.01, 0.2, 0.5, 0.01);\n\n  // Copied from generateRectangle\n  vec2 topLeftB = iResolution.xy * (vec2(\n    snoise(vec2(iTime * 0.05 + rand(randFromB + 10), 0.0)),\n    snoise(vec2(iTime * 0.05 + rand(randFromB + 11), 0.0))\n  ) * 0.5 + 0.5) - height / 2.0;\n\n  if (isInRectangle(width, height, topLeftA, fragCoord)) {\n    fragCoord.x = fragCoord.x - topLeftA.x + topLeftB.x;\n    fragCoord.y = fragCoord.y - topLeftA.y + topLeftB.y;\n  } else if (isInRectangle(width, height, topLeftB, fragCoord)) {\n    fragCoord.x = fragCoord.x - topLeftB.x + topLeftA.x;\n    fragCoord.y = fragCoord.y - topLeftB.y + topLeftA.y;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 colorOut = vec3(0.0);\n\n  if (GLITCH_POSITION_RECT_SWAP_ENABLED) {\n    int randFrom = int(floor(snoise(vec2(iTime * 0.2 + rand(35), 0.0)) * 2.0));\n    int randFromB = int(floor(snoise(vec2(iTime * 0.2 + rand(36), 0.0)) * 2.0));\n    float rectSwapNoise = snoise(vec2(iTime * 2.0 + rand(14), 0.0));\n    if (rectSwapNoise < -0.6) swapRectangle(fragCoord, randFrom, randFromB);\n    if (rectSwapNoise < -0.9) swapRectangle(fragCoord, randFrom + 1000, randFromB + 1000);\n    if (rectSwapNoise < -0.05 && rectSwapNoise > -0.15) swapRectangle(fragCoord, randFrom + 2000, randFromB + 2000);\n    if (rectSwapNoise > 0.6) swapRectangle(fragCoord, randFrom + 10000, randFromB + 10000);\n    if (rectSwapNoise > 0.9) swapRectangle(fragCoord, randFrom + 11000, randFromB + 11000);\n  }\n\n  float bandShiftNoise = snoise(vec2(iTime * 1.3 + rand(23), 0.0));\n  if (GLITCH_POSITION_Y_BAND_SHIFT_ENABLED && bandShiftNoise < -0.3) {\n    float randAmount = rand(floor(snoise(vec2(iTime * 0.2 + rand(37), 0.0)) * 4.0)) * 80.0;\n    float bandHeight = 40.0 + randAmount; // TODO: randomise this per band?\n    fragCoord.x += rand(floor(fragCoord.y / bandHeight)) * 300.0;\n  }\n\n  if (GLITCH_POSITION_FLIP_ENABLED) {\n    float flipNoise = snoise(vec2(iTime * 1.5 + rand(27), 0.0));\n    float flipDirectionNoise = snoise(vec2(iTime * 8.0 + rand(28), 0.0));\n\n    if (flipNoise < -0.85) {\n      if (flipDirectionNoise < 0.0) {\n        fragCoord.x = iResolution.x - fragCoord.x;\n      } else {\n        fragCoord.y = iResolution.y - fragCoord.y;\n      }\n    } else if (flipNoise < 0.5 && flipNoise > 0.2) {\n        int randFrom = 9292 + int(floor(snoise(vec2(iTime * 3.0 + rand(29), 0.0)) * 2.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.2, 0.7, 0.15, 0.3, 0.7, 0.15);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          if (flipDirectionNoise < 0.0) {\n            fragCoord.x = 2.0 * glitchTopLeft.x + glitchWidth - fragCoord.x;\n          } else {\n            fragCoord.y = 2.0 * glitchTopLeft.y + glitchHeight - fragCoord.y;\n          }\n        }\n    }\n  }\n\n  for (float i = -5.0; i != LINES + 5.0; ++i) {\n    float color = drawLine(fragCoord, i);\n    if (color > 0.0) {\n      colorOut = vec3(color);\n    }\n\n    // TODO: move out of loop for perf somehow?\n    if (GLITCH_COLOR_SPLIT_ENABLED) {\n      bool shouldGlitchColor1 = snoise(vec2(iTime * 3.0 + rand(18), 0.0)) < -0.5;\n      if (shouldGlitchColor1) {\n        int randFrom = 2347 + int(floor(snoise(vec2(iTime * 4.0 + rand(30), 0.0)) * 2.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.1, 1.3, 0.2, 0.1, 1.3, 0.2);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          if (color > 0.0) {\n            colorOut.r = 0.0;\n          }\n\n          // Multiplying the noise, flooring it, and using it to generate a random\n          // number creates a sort of jerking effect\n          vec2 colorSplitDist = vec2(\n              50.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(16), 0.0)) * 100.0))),\n              7.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(17), 0.0)) * 40.0)))\n              );\n          float otherColor = drawLine(fragCoord + colorSplitDist, i);\n          if (otherColor > 0.0) {\n            colorOut.r = otherColor;\n          }\n        }\n      }\n\n      // Yes this is duplicated im sorry lol\n      bool shouldGlitchColor2 = snoise(vec2(iTime * 3.0 + rand(24), 0.0)) < -0.5;\n      if (shouldGlitchColor2) {\n        int randFrom = 8374 + int(floor(snoise(vec2(iTime * 5.0 + rand(31), 0.0)) * 2.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.1, 1.3, 0.4, 0.1, 1.3, 0.15);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          if (color > 0.0) {\n            colorOut.r = 0.0;\n          }\n\n          // Multiplying the noise, flooring it, and using it to generate a random\n          // number creates a sort of jerking effect\n          vec2 colorSplitDist = vec2(\n              60.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(25), 0.0)) * 100.0))),\n              4.0 * rand(floor((snoise(vec2(iTime * 0.01 + rand(26), 0.0)) * 40.0)))\n              );\n          float otherColor = drawLine(fragCoord + colorSplitDist, i);\n          if (otherColor > 0.0) {\n            colorOut.r = otherColor;\n          }\n        }\n      }\n    }\n  }\n\n  float blankNoise = snoise(vec2(iTime * 0.7 + rand(19), 0.0));\n  if (GLITCH_OTHER_BLANK_ENABLED) {\n    if (blankNoise < -0.8) {\n      colorOut = vec3(0.0);\n    } else if (blankNoise > 0.3) {\n      float blankNoise2 = snoise(vec2(iTime * 1.6 + rand(20), 0.0));\n      if (blankNoise2 < -0.1) {\n        int randFrom = 2479 + int(floor(snoise(vec2(iTime * 2.0 + rand(32), 0.0)) * 1.5));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.1, 0.7, 0.06, 0.2, 0.6, 0.05);\n\n      if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n        colorOut = vec3(0.0);\n      }\n    }\n    }\n  }\n\n  float invertColorNoise = snoise(vec2(iTime * 0.6 + rand(5), 0.0));\n  if (GLITCH_COLOR_INVERT_ENABLED) {\n    if (invertColorNoise < -0.85) {\n      colorOut = vec3(1.0) - colorOut;\n    } else if (invertColorNoise > 0.4) {\n      float invertColorNoise2 = snoise(vec2(iTime * 3.2 + rand(18), 0.0));\n      if (invertColorNoise2 < -0.3) {\n        int randFrom = 7254 + int(floor(snoise(vec2(iTime * 2.0 + rand(33), 0.0)) * 2.5));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.2, 0.6, 0.18, 0.2, 0.6, 0.22);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          colorOut = vec3(1.0) - colorOut;\n        }\n      }\n    }\n  }\n\n  float swapColorNoise = snoise(vec2(iTime * 0.6 + rand(21), 0.0));\n  if (GLITCH_COLOR_SWAP_ENABLED && colorOut.r + colorOut.g + colorOut.b > 2.5) {\n    float hue = snoise(vec2(iTime * 0.3 + rand(23), 0.0)) / 2.0 + 0.5;\n    vec3 newColor = hsv2rgb(vec3(hue, 0.75, 0.75));\n\n    if (swapColorNoise < -0.75) {\n      colorOut = newColor;\n    } else if (swapColorNoise > 0.4) {\n      float swapColorNoise2 = snoise(vec2(iTime * 2.6 + rand(22), 0.0));\n      if (swapColorNoise2 < -0.3) {\n        int randFrom = 29482 + int(floor(snoise(vec2(iTime * 0.5 + rand(34), 0.0)) * 5.0));\n        float glitchWidth;\n        float glitchHeight;\n        vec2 glitchTopLeft;\n        generateRectangle(glitchWidth, glitchHeight, glitchTopLeft, randFrom, 0.2, 0.6, 0.2, 0.2, 0.6, 0.2);\n\n        if (isInRectangle(glitchWidth, glitchHeight, glitchTopLeft, fragCoord)) {\n          colorOut = newColor;\n        }\n      }\n    }\n  }\n\n  fragColor = vec4(colorOut, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}