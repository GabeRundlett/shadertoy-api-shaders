{
    "Shader": {
        "info": {
            "date": "1461011182",
            "description": "if you gaze long into an abyss, the abyss also gazes into you",
            "flags": 8,
            "hasliked": 0,
            "id": "MddXzl",
            "likes": 22,
            "name": "Quantum Foam",
            "published": 3,
            "tags": [
                "mistake",
                "tootiredforthis"
            ],
            "usePreview": 0,
            "username": "finalman",
            "viewed": 1145
        },
        "renderpass": [
            {
                "code": "const int MAX_STEPS = 12;\nconst float EPSILON = 1e-10;\nconst vec4 HASHSCALE4 = vec4(1031, .1030, .0973, .1099);\n\n\nvec4 hash43(vec3 p)\n{\n    // By Dave_Hoskins\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\nvec4 sphereAt(vec3 p)\n{\n    vec4 sphere = hash43(p) + vec4(p, 0.0);\n    \n    sphere.w *= smoothstep(1.0, 8.0, distance(sphere.xyz, vec3(0, 0, iTime * 0.5)));\n    \n    return sphere;\n}\n\nfloat df(vec3 p)\n{\n    vec3 tile = floor(p);\n    float result = 1.0;\n    \n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec4 sphere = sphereAt(tile + vec3(float(x), float(y), float(z)));\n                if (sphere.w > 0.0)\n                {\n                \tresult = min(result, distance(p, sphere.xyz) - sphere.w);\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n\nvec3 normal(vec3 p)\n{\n    float N = 0.01;\n    float c = df(p);\n    return normalize(vec3(\n        (df(p + vec3(N, 0, 0)) - c) / N,\n        (df(p + vec3(0, N, 0)) - c) / N,\n        (df(p + vec3(0, 0, N)) - c) / N\n\t));\n}\n\nvec3 march(vec3 o, vec3 d)\n{\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = df(o);\n        \n        o += d * dist * 10.0;\n        \n        if (dist < EPSILON)\n        {\n            break;\n        }\n    }\n    \n    return o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 o = vec3(sin(iTime), 0, iTime * 0.5);\n    vec3 d = normalize(vec3((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.7));\n\t\n    vec3 p = march(o, d);\n    vec3 n = normal(p);\n    \n\tvec3 color = vec3(dot(n, normalize(vec3(-0.5, 1.0, -2.0))));\n                      \n    fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define HASHSCALE1 .1031\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sound(float time, float freq)\n{\n    time *= 3.5;\n    float t = fract(time);\n    float f = exp(hash11(floor(time)) * 3.0) * 50.0;\n    \n    return atan(sin(6.2831*f*t*0.33*freq)*sin(6.2831*f*t*freq)*exp(-3.0*t)*6.0) * 0.025;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    vec2 result = vec2(0.0);\n    \n    for (int i = 0; i < 50; i++)\n    {\n        float t = float(i);\n        float s = sound(time - t * 0.1821, exp(-t*0.01 + 0.1)) * exp(-t * 0.1);\n        result += vec2(s + cos(t) * s, s + sin(t) * s);\n    }\n    \n    return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}