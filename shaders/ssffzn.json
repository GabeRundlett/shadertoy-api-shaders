{
    "Shader": {
        "info": {
            "date": "1644473598",
            "description": "I decided to see what it took to actually use pathtracing and try to accurately simulate the light of the glass. This two shader experience has just taught me how much I hate shading glass and will probably never attempt it again lol. Use mouse to look.",
            "flags": 32,
            "hasliked": 0,
            "id": "ssffzn",
            "likes": 9,
            "name": "Glass Table Pathtraced",
            "published": 3,
            "tags": [
                "shadow",
                "glass",
                "pathtracer",
                "table",
                "reflect",
                "refract"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 col, in vec2 coord) {\n    vec4 buf = texture(iChannel0, coord/iResolution.xy);\n    col = buf / buf.w;\n    \n    // red bar is used as a rough sample counter\n    // when it spans across the screen there's at least 100,000\n    // samples done\n    if(coord.y < 2.) {\n        float x = iResolution.x * buf.w / 100000.;\n        if(coord.x < x) {\n            col = vec4(1.,0.,0.,1.);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Material {\n    vec3 diffuse;\n    vec3 emission;\n    float smoothness;\n};\n\n// distance functions\n// source: https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// source: https://www.shadertoy.com/view/MsdGzl\n//------------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\nvec3 cosineDirection(in vec3 nor) {\n    float u = frand();\n    float v = frand();\n    \n    // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define MAX_ITER 80\n#define MAX_DIST 15.\n#define MIN_DIST .001\n\n#define BOUNCES 6\n\nconst vec3 SUN_DIR = normalize(vec3(45.,30.,-45.));\nconst vec3 SUN_COL = vec3(1.);\n\nvec2 dstMin(vec2 a, float bt, float bm) {\n    return a.x < bt ? a : vec2(bt,bm);\n}\n\nvec2 dstScene(vec3 p, bool noGlass) {\n    vec2 d = vec2(p.y,0.);\n    \n    d = dstMin(d, sdBoxFrame(p-vec3(0.,.4,0.), vec3(1.,.4,.8), .05), 1.);\n    d = dstMin(d, length(p-vec3(.4,1.06,0.))-.2, 3.);\n    \n    \n    d = dstMin(d, length(p-vec3(-.8,1.06,.5))-.2, 3.);\n    \n    if(!noGlass) {\n        d = dstMin(d, sdCappedCylinder(p-vec3(0.,.85,0.), 1.3, .02), 2.);\n    }\n    return d;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float mint, bool noGlass) {\n    float t = mint;\n    float m = -1.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec2 d = dstScene(ro+rd*t, noGlass);\n        if(abs(d.x) < MIN_DIST || t > MAX_DIST) break;\n        t += d.x;\n        m  = d.y;\n    }\n    return vec2(t,m);\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 e = vec2(.001*t,0.);\n    vec3 n = vec3(\n        dstScene(p+e.xyy,false).x-dstScene(p-e.xyy,false).x,\n        dstScene(p+e.yxy,false).x-dstScene(p-e.yxy,false).x,\n        dstScene(p+e.yyx,false).x-dstScene(p-e.yyx,false).x\n    );\n    return normalize(n);\n}\n\nvoid material(inout Material mat, in float id, in vec3 p) {\n    if(id == 0.) { // ground\n        mat.diffuse    = texture(iChannel0, p.xz / 2.).rgb;\n        mat.smoothness = 0.;\n    } else if(id == 1.) { // metal frame\n        mat.diffuse    = vec3(.5);\n        mat.smoothness = .9;\n    } else if(id == 2.) { // glass top\n        mat.diffuse    = vec3(.4,.4,.6); \n        mat.smoothness = 1.;\n    } else if(id == 3.) { // ball\n        mat.diffuse    = vec3(1., .2, .2);\n        mat.smoothness = .1;\n    }\n}\n\nvec3 lightRay(in vec3 n, in vec3 r, in Material mat) {\n    if(frand() < .05) return mix(SUN_DIR,cosineDirection(n),.01);\n    else if(frand() < mat.smoothness) return r;\n    else return cosineDirection(n);\n}\n\n//void refractionRayThroughSurface(inout vec3 ro, inout vec3 rd, in vec3 n) {\n//    rd = normalize(refract(rd, n, 1./1.52));\n//    ro = ro + rd * .001;\n//    // if the point is still inside the glass surface, march until\n//    // it's not anymore\n//    float d = dstScene(ro, false).x;\n//    if(d < 0.) {\n//        ro += rd * -d;\n//        d = dstScene(ro, false).x;\n//    }\n//}\n\nvec3 glassLightRay(in vec3 n, in vec3 r, in vec3 rd, in Material mat, in int s, inout bool refr) {\n    float fres = pow(max(-dot(rd,n),0.),.3);\n    if(frand() < fres) {\n        refr = true;\n        return normalize(refract(rd,n,1./1.52));\n    } else {\n        return lightRay(n, r, mat);\n    }\n}\n\nvec3 sky(in vec3 rd) {\n    float sunDot = dot(SUN_DIR,rd);\n    float sunFac = smoothstep(sunDot,.98,1.);\n    return mix(vec3(.8),vec3(20.),1.-pow(sunFac,5.));\n}\n\nvec3 shade(vec3 ro, vec3 rd) {\n    vec3 col   = vec3(0.);\n    vec3 mask  = vec3(1.);\n    float dist = MAX_DIST;\n    \n    for(int i = 0; i < BOUNCES; i++) {\n        vec2 hit = raymarch(ro, rd, 0., false);\n        \n        if(hit.x < MAX_DIST) {\n            vec3 p = ro+rd*hit.x;\n            vec3 n = normal(p, hit.x);\n            vec3 r = normalize(reflect(rd, n));\n        \n            // get material data and direct lighting\n            Material mat;\n            material(mat, hit.y, p);\n            \n            // get next ray based on material\n            bool refr = false;\n            if(hit.y == 2.) {\n                rd = glassLightRay(n, r, rd, mat, i, refr);\n            }\n            else rd = lightRay(n, r, mat);\n            \n            // calculate new mask\n            mask *= mat.diffuse;\n            if(hit.y != 2.) {\n                mask *= max(dot(rd,n),0.);\n            }\n            \n            // calculate new ray origin depending on if\n            // the next ray is reflection or refraction\n            if(!refr) {\n                ro = p+n*.02;\n            } else {\n                ro = p+rd*.07;\n            }\n            \n            if(i == 0) dist = hit.x;\n        } else {\n            col += mask * sky(rd);\n            break;\n        }\n    }\n    \n    float fog = min(exp(dist-MAX_DIST),1.);\n    col = mix(col, vec3(.8), fog);\n    return col;\n}\n\nvec3 cameraPath() {\n    if(iMouse.xy == vec2(0.)) {\n        float a = 14.36 * .5;\n        float d = 3.;\n        return vec3(cos(a),1.5/d,sin(a))*d+vec3(0.,.4,0.);\n    } else {\n        vec2 m = iMouse.xy/iResolution.xy;\n        float rx = 1.27079632679 * m.y;\n        float ry = 6.28318530718 * m.x;\n        float cx = cos(rx), sx = sin(rx);\n        float cy = cos(ry), sy = sin(ry);\n        return vec3(0.,.4,0.)+vec3(cy*cx,sx,sy*cx)*3.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n    \n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = cameraPath();\n    vec3 rd = vec3(uv, 1.);\n    \n    vec3  f = normalize(-ro);\n    vec3  u = normalize(cross(f, vec3(0.,1.,0.)));\n    vec3  v = normalize(cross(u,f));\n    \n    rd = mat3(u,v,f) * rd;\n    \n    vec4 accum = texture(iChannel1, fragCoord/iResolution.xy);\n    if(iFrame == 0 || iMouse.z > 0.) accum = vec4(0.);\n    \n    fragColor.rgb = accum.rgb + shade(ro, normalize(rd));\n    fragColor.a   = accum.a + 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}