{
    "Shader": {
        "info": {
            "date": "1563801004",
            "description": "    The three body trilogy tells the story of the rise and fall of the earth civilization in the universe, it is about Ye Wenjie in the \"Cultural Revolution\" who exposed the coordinate of the earth to aliens on three  bodies.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wtsSRX",
            "likes": 6,
            "name": "Three Body",
            "published": 3,
            "tags": [
                "3d",
                "universe",
                "sciencefiction"
            ],
            "usePreview": 0,
            "username": "ChenYixue",
            "viewed": 784
        },
        "renderpass": [
            {
                "code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 3;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 3;\nconst float PI = 3.1415926;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    /*Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;*/\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 1.0 * cos(iTime), 1.0 * sin(iTime), 0.0 );\n    Sphere[0].radius = 0.6;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.0 * cos(iTime + 2.0 * PI / 3.0), 1.0 * sin(iTime + 2.0 * PI / 3.0), 0.0);\n    Sphere[1].radius = 0.6;\n    Sphere[1].materialID = 2;\n    \n    Sphere[2].center = vec3( 1.0 * cos(iTime - 2.0 * PI / 3.0), 1.0 * sin(iTime - 2.0 * PI / 3.0), 0.0);\n    Sphere[2].radius = 0.6;\n    Sphere[2].materialID = 0;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // blue metal material.\n    Material[1].k_d = vec3( 0.5, 0.7, 0.9 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Purple plastic material.\n    Material[2].k_d = vec3( 0.3, 0.0, 0.7 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.4 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 sphere_center = sph.center;\n    vec3 ray_orig = ray.o;\n    vec3 relative_orig = ray_orig - sphere_center;\n    float a = 1.0;\n    float b = dot(ray.d , relative_orig) * 2.0;\n    float c = dot(relative_orig, relative_orig ) -sph.radius * sph.radius;\n    float b2_4ac = b*b - 4.0*a*c;\n    if(b2_4ac<0.0)\n    {\n        return false; \n    }\n    else\n    {\n        float relative_intersect_t1 = (-b + sqrt(b2_4ac))/(2.0*a);\n        float relative_intersect_t2 = (-b - sqrt(b2_4ac))/(2.0*a);\n        float intersect_t;\n        if(relative_intersect_t1>=tmin&&relative_intersect_t1<=tmax)\n        {\n            if(relative_intersect_t2>= tmin&&relative_intersect_t2<=tmax)\n            {\n                intersect_t = min(relative_intersect_t1,relative_intersect_t2);\n            }\n            else\n            {\n                intersect_t = relative_intersect_t1;\n            }\n        }\n        else{\n             if(relative_intersect_t2>= tmin&&relative_intersect_t2<=tmax)\n            {\n                intersect_t = relative_intersect_t2;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        t = intersect_t;\n        hitPos = ray_orig + t* ray.d;\n        hitNormal = hitPos - sphere_center;\n        hitNormal = normalize(hitNormal);\n        return true;\n    }\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 sphere_center = sph.center;\n    vec3 ray_orig = ray.o;\n    vec3 relative_orig = ray_orig - sphere_center;\n    float a = 1.0;\n    float b = dot(ray.d , relative_orig) * 2.0;\n    float c = dot(relative_orig, relative_orig ) -sph.radius * sph.radius;\n    float b2_4ac = b*b - 4.0*a*c;\n    if(b2_4ac<0.0)\n    {\n        return false; \n    }\n    else\n    {\n        float relative_intersect_t1 = (-b + sqrt(b2_4ac))/(2.0*a);\n        float relative_intersect_t2 = (-b - sqrt(b2_4ac))/(2.0*a);\n        return ((relative_intersect_t1>=tmin&&relative_intersect_t1<=tmax) ||(relative_intersect_t2>=tmin&&relative_intersect_t2<=tmax));\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. \n    /////////////////////////////////\n    for( int i =0;i<NUM_PLANES;i++)\n    {\n        Plane_t pln = Plane[i];\n        temp_hasHit = IntersectPlane(pln, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit)\n        {\n            hasHitSomething = true;\n            if(temp_t<= nearest_t)\n            {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = pln.materialID;\n            }\n        } \n    }\n    for( int i =0;i<NUM_SPHERES;i++)\n    {\n        Sphere_t sphere = Sphere[i];\n        temp_hasHit = IntersectSphere(sphere, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit)\n        {\n            if(temp_t<= nearest_t)\n            {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = sphere.materialID;\n            }\n        }    \n        \n        \n    }\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for(int i=0;i<NUM_LIGHTS;i++)\n    {\n        Light_t light = Light[i];\n        vec3 shadowRay = light.position - nearest_hitPos ;\n        Ray_t sRay ;\n        sRay.o = nearest_hitPos;\n        sRay.d = normalize(shadowRay);\n        bool hitObject = false;\n        // for( int i =0;i<NUM_PLANES && (!hitObject);i++)\n        // {\n        //     Plane_t pln = Plane[i];\n        //     temp_hasHit = IntersectPlane(pln, sRay, DEFAULT_TMIN, DEFAULT_TMAX);\n        //     if(temp_hasHit)\n        //         hitObject = true;\n        // }\n        for( int i =0;i<NUM_SPHERES && (!hitObject);i++)\n        {\n            Sphere_t sphere = Sphere[i];\n            temp_hasHit = IntersectSphere(sphere, sRay, DEFAULT_TMIN, DEFAULT_TMAX);\n            if(temp_hasHit)\n                hitObject = true;\n        }\n        //vec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                   // in Material_t mat, in Light_t light )\n        I_local += PhongLighting(normalize(shadowRay), normalize(nearest_hitNormal), -ray.d, hitObject, Material[nearest_hitMatID], light);\n        // I_local += PhongLighting(-ray.d, normalize(nearest_hitNormal), normalize(-shadowRay),hitObject, Material[nearest_hitMatID], light);\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\nfloat sphDistance( in vec3 ro, in vec3 rd, in Sphere_t sph )\n{\n\tvec3 oc = ro - sph.center;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float h = b*b - c;\n    float d = sqrt( max(0.0, sph.radius * sph.radius - h)) - sph.radius;\n    return d;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n\tfloat d = min(min(sphDistance( ro, rd, Sphere[0] ), sphDistance( ro, rd, Sphere[1] )), sphDistance( ro, rd, Sphere[2]));//#\n    vec3 glo = vec3(0.0);\n    glo += vec3(0.6,0.7,1.0) * 0.3 * exp(-2.0*abs(d)) * step(0.0,d);\n    glo += 0.6 * vec3(0.6,0.7,1.0) * 0.3 * exp(-8.0 * abs(d));\n    glo += 0.6 * vec3(0.8,0.9,1.0) * 0.4 * exp(-100.0 * abs(d));\n    col += glo * 2.0;              \n    return col;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 5.0 * cos(iTime), 0.0, 5.0 * sin(iTime) + 5.0 );\n    //vec3 cam_pos = vec3( 5.0, 0.0, 10.0 );\n    vec3 cam_lookat = vec3(0.0, 0.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    \n    \n    //universe\n    //get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1, fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    \n    //light circle\n    vec3 col = render( pRay.o, pRay.d );\n\n    fragColor = vec4( I_result + v*.01 + col, 1.0 );\n    //fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}