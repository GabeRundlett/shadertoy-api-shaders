{
    "Shader": {
        "info": {
            "date": "1641647915",
            "description": "An extruded double Mobius spiral.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlKXWt",
            "likes": 73,
            "name": "Extruded Mobius Spiral",
            "published": 3,
            "tags": [
                "raymarch",
                "spiral",
                "atan",
                "mobius",
                "complex",
                "complex",
                "extrude"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2228
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Mobius Spiral\n    ----------------------\n    \n    As you can see, this is an extruded Mobius spiral pattern. It's an \n    extension of MLA's nicely written \"Complex Atanh\" example. If you're \n    interested in complex transformations, Mobius spirals etc, that \n    particular example is the one I'd recommend looking at.\n    \n    Technically, there's not a lot to this: Perform the required 2D\n    transformations then pass the results into an extrusion algorithm.\n    The code looks more complicated than it has to be due to the decision \n    on my part to both extrude the cells and cater for three different \n    pylon shapes -- It seemed like a good idea at the time. :)\n    \n    A double spiral is a simple addition to the regular Mobius spiral \n    combination that most people use, but I couldn't for the life of me \n    remember how to produce one, so was pretty happy to see how to do \n    that in MLA's original. \n    \n    I wasn't really sure whether this would work or not, since I figured \n    mutating space so much prior to raymarching would make the surface \n    very difficult to home in on, but relatively speaking, things came\n    together surprisingly well, and I can thank MLA's attention to \n    function order, scaling, etc. Even so, the hackory police and the \n    Lipschitz Surface Constraint Commission probably won't be happy with \n    this example at all. :D\n    \n    Anyway, there are a few define options below: SHAPE, ROW_OFFSET, etc.\n    When using the one spiral option, the surface kind of has the feel of \n    a traced out Doyle spiral, but I'd like to produce the real thing at \n    some stage. \n\n\n\tBased on the following:\n    \n\t// The original and cleaner looking 2D version.\n    Complex Atanh - mla\n\thttps://www.shadertoy.com/view/tsBXRW \n    \n    // Another one of those shaders that somehow slipped under\n    // radar. Some of the visuals are strikingly beautiful.\n    Complex Atanh Revisited - mla\n    https://www.shadertoy.com/view/fldGRB\n\n*/\n\n\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Pylon cross section shape.\n// Square: 0, Circle: 1, Hexagon: 2.\n#define SHAPE 2\n\n// Colorful face decorations.\n#define FACE_DECO\n\n// Double spiral. The single version is cleaner, but not as interesting. \n// Thanks to Mla for this addition.\n#define DOUBLE_SPIRAL\n\n// Boring out holes in the blocks.\n//#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n//#define RIDGES\n\n// Originally for debug purposes, but it's decorative in its own way\n//#define VERT_LINES\n\n\n// The hexagons must use offset rows.\n#if SHAPE == 2\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n#ifdef ROW_OFFSET\n#if SHAPE >= 1\nconst vec2 rDim = vec2(1, 2.*.8660254);\n#else\nconst vec2 rDim = vec2(1, 2);\n#endif\n#else\nconst vec2 rDim = vec2(1, 2);\n#endif\n\n// Global tile scale.\nvec2 scale = vec2(1./8.);\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nfloat hash21(vec2 p){ \n    \n    /*\n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.333);\n    return fract((p3.x + p3.y)*p3.z);\n    */\n    \n    //p = mod(p, (vec2(B, A)*K));\n    \n    // IQ's vec2 to float hash.\n    //p = floor(p*32768.)/32768.;\n    return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); \n    \n}\n\n/*\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n#if SHAPE == 2\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n      // Flat top.\n      //const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      // Pointed top.\n      const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      // Flat top.\n      //return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      // Pointed top.\n      return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n    \n}\n#endif\n\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n     return (sin(6.2831*(p.y*2. + p.x) + iTime*2.)*.5 + .5); \n    \n    // Regular random values.\n    // This won't work for the sqrt(3.) scaling, but there are\n    // ways around it. It's not used in this example anyway.\n    //float h = hash21(p);\n    //return (sin(6.2831*h + iTime*2.)*.5 + .5);\n    \n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n\n// Global local 2D grid coordinates. Hacked in.\nvec2 gP; \n// A global responsible for tempering the height of the pylong near\n// the pylon center.\nfloat tempR;\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #if SHAPE == 2 // Hexagon.\n    vec2 hSc = vec2(1);//vec2(1, scale.y/scale.x*2./1.732);\n    #elif SHAPE == 1 // Circle with an offset.\n    #ifdef ROW_OFFSET\n    vec2 hSc = vec2(1);//vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    #endif\n    \n    \n    \n    float minSc = min(scale.x, scale.y);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]); // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + .5 + ps4[i])*s;\n        \n        p -= idi; // New local position.\n        \n \n        // The extruded block height. See the height map function, above.\n        // An extra line is needed for this example.\n        vec2 index = mod(idi, rDim.yx)/rDim.yx; \n        \n        // We also have an additional height tempering value for \n        // the spiral centers.\n        float h = hm(index)*tempR*.1;\n            \n         \n        #if SHAPE == 2\n        // Hexagon option: Multiply scale by \"vec2(1, 1.732/2.)\".\n        float di2D = sHexS(p, minSc/1.732 - .0035, .015);\n        #elif SHAPE == 1\n        // Circle.\n        #ifdef ROW_OFFSET\n        float di2D = length(p) - minSc/1.732 + .0035;\n        #else\n        float di2D = length(p) - l.x/2. + .0035;\n        #endif\n        #else\n        // Square.\n        float di2D = sBoxS(p, l/2. - .0035, .02);\n        #endif\n        \n        \n        \n        #ifdef HOLES\n        // Boring out the objects.\n        di2D = max(di2D, -(di2D + minSc/3.));\n        #endif\n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h - 1.), h + 1.);\n        \n         \n        \n        // Lego.\n        //float cap = opExtrusion(di2D + .0465, (q3.z + h - 1. + .035), h + 1.);\n        //di = min(di, cap);\n        \n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.5*tempR;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += smoothstep(-.5, .5, sin(di2D/minSc*6.2831*3.))*.01;\n        #endif\n        \n         \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;         \n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n            \n            gP = p;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n//////\n\n// Mla's complex functions: Most people have a copy of these lying\n// around. They're pretty easy to derive.\n//\nvec2 cMul(vec2 z, vec2 w){ return mat2(z, -z.y, z.x)*w; }\n\nvec2 cInv(vec2 z){ return vec2(z.x, -z.y)/dot(z, z); }\n\nvec2 cDiv(vec2 z, vec2 w){ return cMul(z, cInv(w)); }\n\nvec2 cLog(vec2 z){ return vec2(log(length(z)), atan(z.y, z.x)); }\n\n// Inverse hyperbolic tangent: The pattern looks loxodromic. I'm not \n// technically sure what you're supposed to call this particular \n// combination, but there's complex division and polar stuff, so it's\n// not surprising that it looks like a Mobius spiral combination. \nvec2 caTanh(vec2 z, float sc) {\n \n    // You could take the functions above and start grouping things if you \n    // wanted more compactness, and possibly speed, but I'm leaving it as is.\n    return cLog(cDiv(vec2(sc, 0) + z, vec2(sc, 0) - z));\n}\n\n//////\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n \n \n// The scene's distance function.\nfloat map(vec3 p){\n    \n   \n    // Back plane.\n    float fl = -p.z + .01;\n    \n    //////////////\n    // Complex transformations.\n\n    // Performing some complex operations on \"p.xy\" to make some cool looking\n    // Mobius spirals. Complex, as in the complex plane; The operations are\n    // actually quite simple. :)\n   \n    // Rotation about the XY plane. Equivalent to a 2D complex multiplication operation.\n    vec2 z = rot2(-sin(iTime/3.)*.65)*p.xy; // Same as: cmul(vec2(cos(a), sin(a))*c, z2);\n    // Tempering the extrusion height toward the spiral origins to lessen Moire effects\n    // and general artifacts.\n    const float sc = 1.5; // Effects spiral distance.\n    float r = min(length(z - vec2(sc, 0)), length(z - vec2(-sc, 0)));\n    tempR = r;\n    z = caTanh(-z, sc)/6.2831;\n \n    \n    #ifdef DOUBLE_SPIRAL\n    vec2 z2 = rot2(-cos(iTime/3.)*.65*2.)*p.xy;    \n    // Performing another inverse hyperbolic tangent operation. It's very simple\n    // to do, once someone shows you the answer. :)\n    const float sc2 = .75;\n    float r2 = min(length(z2.xy - vec2(sc2, 0)), length(z2.xy - vec2(-sc2, 0)));\n    tempR = min(tempR, r2);\n    z += caTanh(z2, sc2)/6.2831;\n    #endif \n    \n    // Tempering the height of the pylons eminating from the spiral centers.\n    // It looks way too messy if you don't do this.\n    tempR = smoothstep(.1, .5, tempR);\n\n    // More movement. Not necessary, but it looks more interesting.\n    z.y = fract(z.y + iTime*.1);\n    // More scaling.\n    z = cMul(rDim, z);\n    \n    // I like this addition, but I think it dizzies things too much.\n    //z.y -= iTime/6.;\n \n    // Set the XY plane coordinates to the new transformed ones.\n    p.xy = z;\n    \n    //////////////\n  \n \n    // Extrude.\n    vec4 d4 = blocks(p);\n    gID = d4; // Save the distance, cell ID, and 2D face distance.\n   \n    \n    // Object ID.\n    objID = d4.x < fl? 0. : 1.;\n    \n    // Minimum distance for the scene.\n    return min(d4.x, fl);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines. This one is pretty standard.\n// I'm assuming this one based on IQ's original.\nfloat calcAO(vec3 p, vec3 n){\n    \n    float occ = 1.; // Occlusion.\n    float ds = .01; // Analogous to sample spread. // .01*t           \n    float k = .05/ds;  // Intensity.\n    float dst = ds*2.; // Initial distance.          \n    \n    for(int i = 0; i<5; i++){\n        occ -= (dst - map(p + n*dst))*k;\n        dst += ds;\n        k *= .5;\n    }\n    \n    return clamp(occ, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef ROW_OFFSET\n    #if SHAPE >= 1\n    scale *= vec2(2./1.732, 1);\n    #endif\n    #endif\n    \n\t// Camera Setup.\n    // Slightly tilted camera, just to prove it's 3D. :)\n    vec3 ro = vec3(0, -1, -2.2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .1, .25); // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.5, 1, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    // Object ID.\n    float svObjID = objID;\n    \n    // Height tempering for the spiral centers.\n    float svTempR = tempR;\n    \n    // Pylon face local coordinates.\n    vec2 svP = gP;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6);   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Wrapping the colors properly.\n            vec2 index = mod(svGID.yz, rDim.yx)/rDim.yx; \n            //index = floor(index*8.)/8. + 1./16.;\n            \n\n            // Using the color index to produce two different colors.\n            vec3 col1 = .5 + .45*cos(6.2831*index.y + vec3(0, 1, 2)*2.);\n            vec3 col2 = .5 + .45*cos(6.2831*index.y + 3.14159/2.5 + vec3(0, 1, 2)*1.35);\n\n            texCol = col1;\n\n            // Debug coloring.\n            //texCol = mod(floor(index.x*16.), 2.)<.5? vec3(.05) :  texCol;\n            //texCol = mod(floor(index.y*8.), 2.)<.5?  vec3(.05) : vec3(.9);\n            //texCol = vec3(.05);\n             \n            \n            // The dark lines, etc, need to look crisp, so we need a derivative\n            // based smoothing factor. This can either be done the easy way via\n            // hardware, or the harder but more maliable and reliable way. The\n            // hardware version is below for a comparison.\n            #if 1\n            float di2D = svGID.w;\n            float tmp = map(sp - vec3(3./450., 0, 0)); // Nearby X sample.\n            float di2DX = gID.w; // dX.\n            tmp = map(sp - vec3(0, 3./450., 0)); // Nearby Y sample.\n            float di2DY = gID.w; // dY.\n            //tmp = map(sp - vec3(0, 0, 3./450.)); \n            //float di2DZ = gID.w;//\n            \n            vec3 dF = (vec3(di2DX, di2DY, 1e5) - di2D); // Rought partial differential.\n            // Technically not fwidth, but I prefer it.\n            float sf = length(dF.xy); // Fwidth: abs(dF.x) + abs(dF.y);\n            #else\n            // The one line hardware version. Much cheaper, but not always reliable.\n            float sf = fwidth(svGID.w);\n            #endif\n            \n            \n            #ifdef VERT_LINES\n            // Lines eminating from the center to the vertices.\n            #if SHAPE == 2\n            const float aNum = 6.;\n            vec2 z = rot2(3.14159/aNum)*svP; \n            //float ch = smoothstep(-sf, sf, (abs(fract(a*6. - .5) - .5) - .45)/6.);\n            #else\n            const float aNum = 4.;\n            vec2 z = svP; \n            #endif\n            float a = mod(atan(z.x, z.y), 6.2831)/6.2831;\n            a = (floor(a*aNum) + .5)/aNum;\n            z *= rot2(a*6.2831);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(z.x) - .001))*.95);     \n            #endif\n            \n            \n            #ifdef FACE_DECO\n            float rim = .04;\n            #ifdef ROW_OFFSET\n            #if SHAPE >= 1\n            rim /= .8660254;\n            #endif\n            #endif\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, svGID.w + rim))*.95);\n            texCol = mix(texCol, col2, (1. - smoothstep(0., sf, svGID.w + rim + .005)));\n            #endif\n \n \n            // Dark edges.\n            float h = hm(index); // Pylon height.\n            float lw = .0035;\n            float dS = abs(svGID.w) - lw/2.; // 2D face field value.\n            texCol = mix(texCol, texCol/3., (1. - smoothstep(0., sf, dS)));\n            dS = max(dS, abs(sp.z + h*.1*svTempR*2.) - lw/2.); // Just the rim.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, dS))*.95);\n             \n \n        }\n        else {\n            \n            // The dark floor in the background.\n            texCol = vec3(.05);\n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}