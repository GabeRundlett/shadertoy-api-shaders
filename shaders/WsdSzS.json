{
    "Shader": {
        "info": {
            "date": "1572277335",
            "description": "I published a simpler version of this a while ago, but i just kept adding, modifying and improving stuff so here is (probably) the last version of this shader.\nIf you notice any mistake or some kind of improvement please let me know so i can add/fix it.<3",
            "flags": 0,
            "hasliked": 0,
            "id": "WsdSzS",
            "likes": 14,
            "name": "Raytraced glass spheres.",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "refraction",
                "sphere",
                "glass",
                "metal",
                "material",
                "beer",
                "absortion",
                "fresnell",
                "beerlambert"
            ],
            "usePreview": 0,
            "username": "Txoka",
            "viewed": 701
        },
        "renderpass": [
            {
                "code": "const float pi=atan(1.)*4.;\n\nconst float n_air=1.0002;\nconst float n_vidrio=1.52;\n\nconst int N=7;\n\nconst int BOUNCES=16;\nconst int SAMPLES=64;\nconst float gamma=1.8;\n\n#define AA\n//#define eyes\n\n//\t\t\t0/1 => different sampling\n#define RAND 0\n\nstruct sph{\n    vec3 c;\n\tfloat r;\n    float n;\n    float l;\n    vec3 absorb;\n    float ref;\n};\nstruct ray{\n    vec3 ro;\n\tvec3 rd;\n    int which;\n};\n\nsph spheres[N]=sph[N](\n      //vec3(x,y,z),\trad,\tn,\t\tlight,\tabsorb,\t\t\treflectivity\n    sph(vec3(0),\t\t1.,\t\t1.4,\t0.,\t\tvec3(.1),\t\t0.05),\n    sph(vec3(2,0,0),\t0.5,\t1.,\t\t0.,\t\tvec3(0,0,0),\t1.),\n    sph(vec3(0,2,0),\t0.5,\t3.,\t\t0.,\t\tvec3(0,0,2.),\t0.),\n    sph(vec3(0,0,2),\t0.5,\t1.4,\t0.,\t\tvec3(0,1.,0),\t0.1),\n    sph(vec3(-2,0,-2),\t0.5,\t1.1,\t0.,\t\tvec3(.5,0,0),\t0.1),\n    sph(vec3(0,-2,0),\t0.5,\t1.,\t\t2.,\t\tvec3(0,0,0),\t0.),\n    sph(vec3(2,0,-2),\t0.5,\t1.,\t\t0.,\t\tvec3(0,0,0),\t1.)\n);\n\nconst uint k = 1103515245U;\nvec3 hash33( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat sphere(ray r, sph s, float n){\n\tvec3 rc = r.ro-s.c;\n\tfloat c = dot(rc, rc) - (s.r*s.r);\n\tfloat b = dot(r.rd, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - n*sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn max(0.,mix(-1., t, st));\n}\n\nvec3 back(vec3 rd){\n    return texture(iChannel0,rd).rgb;\n}\n\nfloat fresnel(float n1, float n2, vec3 normal, vec3 incident,float ref){\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2){\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n        ret = (ref + (1.0-ref) * ret);\n        return ret;\n}\n\nbool next(ray r,float rand,out ray r_out,out float l,inout vec3 ab){\n    vec3 normal;\n    int spn;\n    float p;\n    if(r.which==-1){\n        float d=0.;\n        float di;\n        \n        for(int i=0;i<N;i++){\n\t\t\tdi=sphere(r,spheres[i],1.);\n            if((di!=0.&&di<d)||d==0.){\n                d=di;\n                spn=i;\n            }\n        }\n        if(d==0.)return true;\n        l=spheres[spn].l;\n        if(l!=0.)return true;\n        vec3 surf=r.ro+r.rd*d;\n        \n        r_out.ro=surf;\n        normal=(surf-spheres[spn].c)/spheres[spn].r;\n        p=fresnel(n_air,spheres[spn].n,normal,r.rd,spheres[spn].ref);\n        if(rand<p){\n        \tr_out.rd=normalize(reflect(r.rd,normal));\n            r_out.which=-1;\n        }else{\n        \tr_out.rd=normalize(refract(r.rd,normal,n_air/spheres[spn].n));\n        \tr_out.which=spn;\n            /*if(length(r_out.rd)==0.){\n                r_out.rd=normalize(reflect(r.rd,normal));\n            \tr_out.which=r.which;\n            }*/\n        }\n    }else{\n    \tfloat d=sphere(r,spheres[r.which],-1.);\n        vec3 surf=r.ro+r.rd*d;\n        ab*=exp(-d*spheres[r.which].absorb);\n        \n        r_out.ro=surf;\n        normal=(spheres[r.which].c-surf)/spheres[r.which].r;\n        p=fresnel(spheres[r.which].n,n_air,normal,r.rd,spheres[r.which].ref);\n        if(rand<p){\n        \tr_out.rd=normalize(reflect(r.rd,normal));\n            r_out.which=r.which;\n        }else{\n        \tr_out.rd=normalize(refract(r.rd,normal,spheres[r.which].n/n_air));\n        \tr_out.which=-1;\n            /*if(length(r_out.rd)==0.){\n                r_out.rd=normalize(reflect(r.rd,normal));\n            \tr_out.which=r.which;\n            }*/\n        }\n    }\n    \n    return false;\n}\n\nvec3 render(ray r,uvec3 uv,float pix){\n    ray\tr_out;\n    ray k=r;\n    float l;\n    float rand=0.;\n    float u=1.;\n    vec3 col=vec3(0);\n    for(int s=0;s<SAMPLES;s++){\n        vec3 abso=vec3(1);\n        r=k;\n        #ifdef AA\n        r.rd+=(hash33(uv+uvec3(0,0,s))*2.-1.)*pix;\n    \tr.rd=normalize(r.rd);\n        #endif\n        for(int i=0;i<BOUNCES;i++){\n            #if RAND==1\n            rand=hash12(vec2(i,s)+rand*423.323);\n            #else\n            rand=hash13(vec3(uv)+vec3(s*21,i*32,0)+rand*423.323);\n            #endif\n            if(next(r,rand,r_out,l,abso)){\n                if(l!=0.){\n                    col+=pow(l*abso,vec3(gamma));\n                }else{\n                \tcol+=pow(back(r.rd)*abso,vec3(gamma));\n                }\n                break;\n            }\n            r=r_out;\n\t\t}\n    }\n    \n\treturn pow(col/float(SAMPLES),vec3(1./gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //ray origin and dir\n    vec3 uv = vec3((fragCoord*2.-iResolution.xy)/iResolution.y,-3);\n    vec2 m=(iMouse.xy*2.-iResolution.xy)/iResolution.xy;\n    m*=vec2(1,0.5)*pi;\n    if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    \n    #ifdef eyes\n    vec3 ro=vec3(-0.2,0,-4);\n    if(uv.x<0.)ro.x=0.2;\n    uv.xy+=ro.xy*5.;\n    #else\n    vec3 ro=vec3(0,0,-4);\n    #endif\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    vec3 rd=normalize(uv-ro);\n   \t\n    ray r=ray(ro,rd,-1);\n    uvec3 seed=uvec3(fragCoord,iFrame);\n    \n    vec3 col=render(r,seed,1./iResolution.y);\n    \n    fragColor=vec4(col,1);\n\n    //fragColor=vec4(rand(fragCoord+iTime));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}