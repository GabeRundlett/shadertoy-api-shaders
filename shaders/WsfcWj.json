{
    "Shader": {
        "info": {
            "date": "1585602980",
            "description": "electrogel 14",
            "flags": 0,
            "hasliked": 0,
            "id": "WsfcWj",
            "likes": 8,
            "name": "electrogel 14",
            "published": 3,
            "tags": [
                "electrogel14"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nfloat smAdd(float m1, float m2, float k)\n{\n    float h = clamp(.5 + .5*(m2 - m1)/k, 0., 1.);\n    return mix(m2, m1, h) - k*h*(1. - h);\n}\n\nfloat bump(vec3 p, float offs)\n{\n    return .25*sin(p.x*3.4 + (iTime + offs)*.73) *\n        \t   cos(p.y*3.7 + (iTime + offs)*.81) *\n        \t  (sin(p.z*4.0 + (iTime + offs)*.83) + cos(p.z*2.9 + (iTime + offs)*.57));\n}\n\nvec2 sph(vec3 p, float s, float offs, float matId)\n{\n    return vec2(length(p + bump(p, offs)) - s, matId);\n}\n\nvec2 map(vec3 p)\n{   \n    float matId1 = 0.;\n    float matId2 = 1.;\n    float dist = 1.1*sin(iTime*.7) + 3.;\n    vec2 m1 = sph(vec3(p.x + dist/2., p.y, p.z), 1.5, 133., matId1);\n    vec2 m2 = sph(vec3(p.x - dist/2., p.y, p.z), 1.5, 0., matId2);\n    float matmix = mix(matId1, matId2, abs(m2.x - m1.x));\n    vec2 m = vec2(smAdd(m1.x, m2.x, .6), matmix);\n    glo += .1 / (1.5 + m.x*m.x*5000.);\n    return m;\n}\n\nfloat sss(vec3 p, vec3 l, float d)\n{\n\treturn smoothstep(0., 1., map(p + l*d).x/d);\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 10.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .0001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .2;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = -1.;\n\treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 ro = vec3(cos(.15*iTime),\n                   sin(-.15*iTime),\n                   -3.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(.07, .07, -10.);\n    vec3 lightPos2 = vec3(-5.07, -5.07, -12);\n  \tvec3 lightPos3 = vec3(5.07, -5.07, -12);\n    \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = .7 * vec3(sin(.151*((iTime+180.) + 44.)),\n                       \t\tsin(.227*((iTime+180.) + 55.)),\n                       \t\tsin(.317*((iTime+180.) + 79.))) + 1.35;\n\n    if (t.y > -1.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        vec3 lightDir2 = normalize(lightPos2 - hit);\n        vec3 lightDir3 = normalize(lightPos3 - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n\n        vec3 l = -lightDir;\n        float sub = 0.;\n        float steps = 750.;\n\n        for(float i = 1.; i < steps; i++)\n        {\n            float dist = i*2. / steps;\n            sub += sss(hit, l, dist);\n        }\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float spec2 = pow(max(dot(rd, reflect(norm, lightDir2)), 0.), 80.);\n        float spec3 = pow(max(dot(rd, reflect(norm, lightDir3)), 0.), 45.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .3 * colRot * (t.y + .3);\n        col += sub * colRot * .006;\n        col *= .15 * ao;\n        col += .65 * diff * (colRot.yzx/(t.y*6.));\n        col += .7 * spec * vec3(1., 1., 1.);\n        col += .7 * spec2 * vec3(1., 1., 1.);\n        col += .9 * spec3 * vec3(1., 1., 1.);\n        \n        col += glo*.01*colRot.xzy*(t.y);\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.01*colRot.yzx*t.y, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}