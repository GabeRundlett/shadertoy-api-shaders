{
    "Shader": {
        "info": {
            "date": "1632577914",
            "description": "Gabor Filter Kernel ( http://www.cse.yorku.ca/~kosta/CompVis_Notes/gabor_filters.pdf )\n(*) Gaussian is not Normalized.",
            "flags": 0,
            "hasliked": 0,
            "id": "NscXzH",
            "likes": 7,
            "name": "Gabor Filter Kernel",
            "published": 3,
            "tags": [
                "2d",
                "imageprocessing",
                "spatialfilter"
            ],
            "usePreview": 0,
            "username": "mosan_hoshi",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "// writen by mossan-hoshi\n//// twitter : https://twitter.com/mossan_hoshi\n//// GitHub : https://github.com/mossan-hoshi/\n//// ShaderToy : https://www.shadertoy.com/user/mosan_hoshi\n//\n// Gabor Filter ( http://www.cse.yorku.ca/~kosta/CompVis_Notes/gabor_filters.pdf )\n//\n\n\n#define PI 3.14159265359\n#define MARGIN 0.01\n#define PADDING 0.1\n#define TILE_LOCAL_LENGTH 10.\n#define TILE_LENGTH ((1. - 2. * ( MARGIN + PADDING)) / 3.)\n#define LEFT_CENTER   vec2(MARGIN + .5 * TILE_LENGTH                               , MARGIN + .5 * TILE_LENGTH)\n#define CENTER_CENTER vec2(MARGIN + .5 * TILE_LENGTH +       PADDING + TILE_LENGTH , MARGIN + .5 * TILE_LENGTH)\n#define RIGHT_CENTER  vec2(MARGIN + .5 * TILE_LENGTH + 2. * (PADDING + TILE_LENGTH), MARGIN + .5 * TILE_LENGTH)\n#define TEXT_WIDTH   (0.068)\n#define TEXT_START_Y (2. * MARGIN + TILE_LENGTH)\n#define TEXT_START_X (.3)\n// gaussian\n#define SIGMA_MIN .75\n#define SIGMA_MAX 3.\n#define GAUSSIAN_CONST_GAIN 0.3989422804  // 1./sqrt(2*PI)\n#define GAUSSIAN_TRANSITION_PERIOD 3.8\n// carrier\n#define CARRIER_WAVELENGTH_MIN .2\n#define CARRIER_WAVELENGTH_MAX .8\n#define CARRIER_WAVELENGTH_PERIOD 3.8\n#define CARRIER_ROTATION_PERIOD 20.\n\n\nvec3 displayGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n  vec3 val1 = 12.92 * rgb;\n  vec3 val2 = vec3(pow(rgb.x, 1.0 / 2.2),pow(rgb.y, 1.0 / 2.2),pow(rgb.z, 1.0 / 2.2)) * 1.055 - 0.055;\n  return (1.0 - step(0.0031308,rgb)) * val1 + step(0.0031308,rgb) * val2;\n}\n\nfloat errorCheckUV(vec2 checkUV){\n  return float((checkUV.x < .0)||(checkUV.y < .0)||(checkUV.x > 1.)||(checkUV.y > 1.));\n}\n\nvec2 errorCheckUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckUV(checkUV);\n  return step(0.1,errorFlg) * (-1.,-1.) + (1.0 - step(0.1,errorFlg)) * returnUV;\n}\n\nfloat errorCheckLocalUV(vec2 checkUV){\n  return float((abs(checkUV.x) > .5 * TILE_LOCAL_LENGTH)||(abs(checkUV.y) > .5 * TILE_LOCAL_LENGTH));\n}\n\nvec2 errorCheckLocalUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckLocalUV(checkUV);\n  return step(.1, errorFlg) * (-1. * TILE_LOCAL_LENGTH, -1. * TILE_LOCAL_LENGTH) + step(.1, 1. - errorFlg) * returnUV;\n}\n\nvec2 uv2LocalUV(vec2 uv, vec2 centerPoint){\n  vec2 localUV = TILE_LOCAL_LENGTH * vec2((uv.x - centerPoint.x)/ TILE_LENGTH, \n                                          (uv.y - centerPoint.y)/ TILE_LENGTH);\n  return errorCheckLocalUV(localUV, localUV);\n}\n\nfloat waveValue(float period,float  minVal,float  maxVal){\n  return (cos(2. * PI * iTime / period) + 1.) * .5 * (maxVal - minVal) + minVal;\n}\n\nvec2 localUV2uv(vec2 localUV, vec2 startPoint){\n  vec2 gainedLocalUV = vec2(localUV.x * TILE_LENGTH, \n                            localUV.y * TILE_LENGTH);\n  vec2 uv = vec2((gainedLocalUV.x + startPoint.x) , \n                 (gainedLocalUV.y + startPoint.y) );\n  return errorCheckUV(localUV, uv);\n}\n\nvec3 gaussian(vec2 uv, float sigma){\n  float channelValue = GAUSSIAN_CONST_GAIN * exp(-dot(uv,uv)/(2. * sigma * sigma)); // / sigma; // Here I don't apply normalization because of visibility.\n  return vec3(channelValue, channelValue, channelValue);\n}\n\nvec3 carrier(vec2 uv, float carrier_wavelength, float rotation_angle){\n  vec2[2] rotation_matrix = vec2[](\n    vec2(cos(rotation_angle),-sin(rotation_angle)),\n    vec2(sin(rotation_angle), cos(rotation_angle))\n  );\n  vec2 rotatedUV = vec2(dot(rotation_matrix[0],uv),\n                        dot(rotation_matrix[1],uv));\n  float channelValue = (cos(rotatedUV.x / carrier_wavelength) ) ;\n  return vec3(channelValue, channelValue, channelValue);\n}\n\nfloat lineMask(vec2 uv, vec2 linePoint1,vec2 linePoint2, float threshold){\n  // rotate line to y-axis\n  vec2 v1 = (linePoint1 - linePoint2);\n  float lineLength = sqrt(dot(v1,v1));\n  v1 = v1 / lineLength;\n  float theta = atan(v1.x, v1.y);\n  vec2[2] rotateMat = vec2[](\n    vec2(cos(theta), -sin(theta)),\n    vec2(sin(theta),  cos(theta))\n  );\n  vec2 rotatedUV = vec2((dot(rotateMat[0], (uv - linePoint2))),\n                        (dot(rotateMat[1], (uv - linePoint2))));\n  return float(\n               (abs(rotatedUV.x ) < threshold)&&\n               (rotatedUV.y       > -threshold)&&\n               (rotatedUV.y       < lineLength + threshold)\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const\n  float sigma = waveValue(GAUSSIAN_TRANSITION_PERIOD, SIGMA_MAX, SIGMA_MIN);\n  float carrier_wavelength = waveValue(CARRIER_WAVELENGTH_PERIOD, CARRIER_WAVELENGTH_MAX, CARRIER_WAVELENGTH_MIN);\n  float rotation_angle = mod(2. * PI * iTime / CARRIER_ROTATION_PERIOD, 2. * PI);\n\n  // normalize position(x,y:.0~1.0)\n  vec2 uv = fragCoord.xy/ iResolution.x;\n\n  // get local positions\n  vec2 leftUV = uv2LocalUV(uv, LEFT_CENTER);\n  vec2 centerUV = uv2LocalUV(uv, CENTER_CENTER);\n  vec2 rightUV = uv2LocalUV(uv, RIGHT_CENTER);\n\n  // draw gaussian (center)\n  vec3 leftGaussianRegion = gaussian(leftUV, sigma);\n  // draw gaussian (center)\n  vec3 centerCarrierRegion = carrier(centerUV, carrier_wavelength, rotation_angle);\n  \n  // draw gaussian (center)\n  vec3 rightGaussianRegion = gaussian(rightUV, sigma);\n  vec3 rightCarrierRegion = carrier(rightUV, carrier_wavelength, rotation_angle);\n  \n  // draw left side(image(iChannel0))\n  float leftMask = 1. - errorCheckLocalUV(leftUV);\n  float centerMask = 1. - errorCheckLocalUV(centerUV);\n  float rightMask = 1. - errorCheckLocalUV(rightUV);\n  vec3 rgb = leftMask   * (.5 + leftGaussianRegion) + \n             centerMask * centerCarrierRegion + \n             rightMask  * (.5 + rightGaussianRegion * rightCarrierRegion);\n  float lineMaskAll = // multiply\n                      lineMask(uv, vec2(.35, .1),vec2(.3 , .15), .004) + \n                      lineMask(uv, vec2(.3,  .1),vec2(.35, .15), .004) + \n                      // equal\n                      lineMask(uv, vec2(.65,  .12),vec2(.7, .12), .004) + \n                      lineMask(uv, vec2(.65,  .14),vec2(.7, .14), .004) +\n                      // text(gabor)\n                      //// G\n                      lineMask(uv, vec2(.055  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .01  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.055  + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_START_X, .05  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .025 + TEXT_START_Y), .003) +  \n                      lineMask(uv, vec2(.07   + TEXT_START_X, .025 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .025 + TEXT_START_Y), .003) +\n                      //// A\n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y), .003) +\n                      //// B\n                      lineMask(uv, vec2(.056  + 2. * TEXT_WIDTH + TEXT_START_X, .05  + TEXT_START_Y),\n                                   vec2(.075  + 2. * TEXT_WIDTH + TEXT_START_X, .036 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.056  + 2. * TEXT_WIDTH + TEXT_START_X, .033 + TEXT_START_Y),\n                                   vec2(.076  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .03  + TEXT_START_Y),\n                                   vec2(.073  + 2. * TEXT_WIDTH + TEXT_START_X, .03  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.072  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y), .003) +\n                      //// O\n                      lineMask(uv, vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .05 + TEXT_START_Y),\n                                   vec2(.08   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .05 + TEXT_START_Y),\n                                   vec2(.05   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.08   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y),\n                                   vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .01 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.05   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y),\n                                   vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .01 + TEXT_START_Y), .003) +\n                      //// R\n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .035 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .035 + TEXT_START_Y), .003) \n                      ;\n  rgb = lineMaskAll * 1. + (1. - lineMaskAll) * rgb;\n\n  rgb = displayGamma(rgb);\n\n  fragColor=vec4(rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}