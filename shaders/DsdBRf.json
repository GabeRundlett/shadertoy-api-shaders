{
    "Shader": {
        "info": {
            "date": "1698348549",
            "description": "TP  informatique graphique ",
            "flags": 0,
            "hasliked": 0,
            "id": "DsdBRf",
            "likes": 2,
            "name": "REZGUI &BOUAKAZ",
            "published": 3,
            "tags": [
                "tpfinal"
            ],
            "usePreview": 0,
            "username": "kolloss",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "struct Ellipsoid {\n    vec3 center;\n    vec3 radius;\n    int i;// Texture Id\n};\nstruct Box {\n    vec3 min; // Minimum corner of the box\n    vec3 max; // Maximum corner of the box\n    int i;    // Texture Id\n};\n\nstruct Sphere {\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Cylinder {\n    vec3 start;  // Start point of the cylinder\n    vec3 end;    // End point of the cylinder\n    float radius;  // Radius of the cylinder\n    int i;        // Texture Id\n};\nstruct Torus {\n    vec3 center;   // Center of the torus\n    float majorRadius;  // Major radius of the torus\n    float minorRadius;  // Minor radius of the torus\n    int i;    // Color of the torus\n};\n\nstruct Capsule {\n    vec3 start;     // Start point of the capsule\n    vec3 end;       // End point of the capsule\n    float radius;   // Radius of the capsule\n    int i;          // Texture Id\n};\n\nstruct Plane {\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit {\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray {\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n    vec3 reflectivity; // Niveau de réflexion\n\n};\n\nfloat Checkers(in vec2 p) {\n    // Filter kernel\n    vec2 w = fwidth(p) + .001;\n    // Box box filter\n    vec2 i = 2. * (abs(fract((p - .5 * w) * .5) - .5) - abs(fract((p + .5 * w) * .5) - .5)) / w;\n    // xor pattern\n    return .5 - .5 * i.x * i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = i.x + i.y * 157.0 + i.z * 113.0;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fractalNoise(vec3 p, int octaves, float lacunarity, float persistence) {\n    float sum = 0.0;\n    float amplitude = 1.0;\n\n    for(int i = 0; i < octaves; i++) {\n        sum += noise(p) * amplitude;\n        p *= lacunarity;\n        amplitude *= persistence;\n    }\n\n    return sum;\n}\n\nvec3 marbleTexture(vec3 position, float scale, int octaves, float lacunarity, float persistence, vec3 color1, vec3 color2) {\n    vec3 p = position * scale;\n    float turbulence = fractalNoise(p, octaves, lacunarity, persistence);\n\n    // Adjust the contrast and brightness\n    float brightness = 0.5;\n    float contrast = 0.5;\n\n    // Interpolate between color1 and color2 based on turbulence\n    vec3 marbleColor = mix(color1, color2, turbulence);\n\n    // Apply contrast and brightness\n    marbleColor = mix(marbleColor - brightness, marbleColor + brightness, turbulence);\n\n    return marbleColor;\n}\n\n// Fonction de texture uniforme\nvec3 UniformTexture(vec3 p) {\n    return p; // Couleur RGB \n}\n\n// Fonction du Damier Volumique\nvec3 CheckerTexture(vec3 position, float checkerSize, vec3 Couleur1, vec3 Couleur2) {\n    float checkerValue = Checkers(position.xy / checkerSize);\n    return mix(Couleur1, Couleur2, checkerValue);\n}\n\nvec3 ConcentricColorTexture(vec3 position, vec3 center, vec3 innerColor, vec3 outerColor) {\n    // Calculez la distance entre le point et le centre\n    float distance = length(position - center);\n\n    // Normalisez la distance pour obtenir une valeur entre 0 et 1\n    float normalizedDistance = distance / max(length(innerColor), length(outerColor));\n\n    // Interpolez entre les couleurs intérieure et extérieure en fonction de la distance\n    vec3 color = mix(innerColor, outerColor, normalizedDistance);\n\n    return color;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i) {\n    vec3 diffuseColor = vec3(0.8, 0.5, 0.4);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n\n    if(i == 1) {\n        return Material(vec3(.8, .5, .4), vec3(.2, .2, .2), vec3(0.5, 0.5, 0.5), vec3(0.0, 1.0, 1.0));\n    }\n    if(i == 2) {\n        return Material(UniformTexture(vec3(.8, 0.0, 0.0)), vec3(.1, .1, .1), vec3(1., 1., 1.), vec3(1.0, 0.0, 0.0));// ROUGE \n\n    }\n    if(i == 3) {\n        return Material(UniformTexture(vec3(0.0, 1.0, 0.0)), vec3(.2, .2, .2), vec3(0.1, 0.1, 0.1), vec3(0.0, 1.0, 0.0));// Vert \n    }\n    if(i == 4) {\n        return Material(UniformTexture(vec3(0.0, 0.0, 1.0)), vec3(.2, .2, .2), vec3(0.1, 0.1, 0.1), vec3(0.0, 0.0, 1.0));// Bleu \n    }\n    if(i == 5) {\n        return Material(UniformTexture(vec3(1.0, 1.0, 1.0)), vec3(.2, .2, .2), vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5));// blanc grisatre \n    }\n    if(i == 6) {\n        return Material(CheckerTexture(p, 2.0, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)), vec3(.2, .2, .2), vec3(0.5, 0.5, 0.5), vec3(0.0, 0.0, 0.0));//DAMIER NOIR ET BLANC \n    }\n    if(i == 7) {\n        // Utilisez ConcentricColorTexture pour calculer la couleur en fonction de la distance\n        return Material(ConcentricColorTexture(p, vec3(0.0, 0.0, 0.0), vec3(6.0, 0.0, 0.0), vec3(0.0, 0.0, 4.0)), vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.0, 1.0));\n    }\n\n    if(i == 8) {\n        // Créez une texture damier alternant entre la couleur diffuse et spéculaire\n        float checkerSize = 2.0;  // Taille du damier\n        float checkerValue = Checkers(p.xy / checkerSize);\n        if(checkerValue > 0.5) {\n            return Material(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.2), vec3(0.0, 0.0, .0), vec3(0.0, 0.0, 0.0)); // Diffuse\n        } else {\n            return Material(vec3(0.0, 0.0, .0), vec3(0.2, 0.2, 0.2), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)); // Spéculaire\n        }\n    }\n    if(i == 9) {\n                //4.0, 10, 3.0, 0.6\n        return Material(marbleTexture(p, 6.0, 20, 4.0, 0.6, vec3(0.858, 0.843, 0.698) ,vec3(0.937, 0.917, 0.839)), vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5), vec3(0.0, 0.0, 0.0));\n    } else if(i == 0) {\n        // compute checkboard\n        float f = Checkers(.5 * p.xy);\n        vec3 col = vec3(.4, .5, .7) + f * vec3(.1);\n        return Material(col, vec3(.1, .1, .1), vec3(0.3, 0.3, 0.3), vec3(1.0, 0.0, 0.0));\n    }\n    return Material(vec3(0), vec3(0), vec3(0), vec3(0));\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x) {\n    vec3 oc = ray.o - sph.c;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float d = b * b - c;\n    if(d > 0.) {\n        float t = -b - sqrt(d);\n        if(t > 0.) {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - sph.c), sph.i);\n\n            return true;\n        }\n    }\n    return false;\n\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 oc = ray.o - ellipsoid.center;\n    vec3 invRadius = 1.0 / ellipsoid.radius;\n\n    vec3 rayDir = ray.d * invRadius;\n    vec3 rayOrigin = oc * invRadius;\n\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if(discriminant > 0.0) {\n        float t0 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t0, t1);\n\n        if(t > 0.0) {\n            vec3 p = ray.o + ray.d * t;\n            vec3 normal = (p - ellipsoid.center) / ellipsoid.radius;\n\n            x = Hit(t, normalize(normal), ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool intersectTorus(Ray ray, Torus torus, out Hit hit) {\n    hit.t = -1.0;  // Initialize hit.t to a negative value to indicate no intersection\n\n    vec3 ro = ray.o - torus.center;\n    vec3 rd = ray.d;\n\n    float Ra2 = torus.majorRadius * torus.majorRadius;\n    float ra2 = torus.minorRadius * torus.minorRadius;\n\n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * rd.z * rd.z + k;\n    float k1 = k * n + Ra2 * ro.z * rd.z;\n    float k0 = k * k + Ra2 * ro.z * ro.z - Ra2 * ra2;\n\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n\n    if(h < 0.0) {\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    } else {\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\n\n    z = c2 - z;\n\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n\n    if(abs(d1) < 1.0e-4) {\n        if(d2 < 0.0) {\n            return false;  // No intersection\n        }\n        d2 = sqrt(d2);\n    } else {\n        if(d1 < 0.0) {\n            return false;  // No intersection\n        }\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        float t2 = -d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = t1;\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n\n    h = d1 * d1 - z - d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        float t2 = d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = min(result, t1);\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n    \n     if (result < 1e20) {\n    hit.t = result;  // Update the hit structure with the intersection depth\n\n    // Compute the normal vector\n    vec3 q = ray.o + ray.d * hit.t;\n    vec3 normal = normalize(vec3(\n        2.0 * (q.x - torus.center.x),\n        2.0 * (q.y - torus.center.y),\n        2.0 * (q.z - torus.center.z)\n    ));\n    hit.n = normal;\n\n    hit.i = torus.i;  // Assign the color or texture ID to the hit structure\n    return true;  // Intersection found\n}\n    \n    return false;  // No intersection\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    vec3 tMin = (box.min - ray.o) / ray.d;\n    vec3 tMax = (box.max - ray.o) / ray.d;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if(tNear > tFar || tFar < 0.0) {\n        return false;\n    }\n\n    float tHit = (tNear < 0.0) ? tFar : tNear;\n\n    vec3 hitPoint = Point(ray, tHit);\n    vec3 normal = vec3(0.0); // Initialize the normal vector to (0, 0, 0)\n\n    // Calculate normal based on which face of the box was hit\n    if(abs(hitPoint.x - box.min.x) < 0.0001) {\n        normal = vec3(-1.0, 0.0, 0.0); // Left face\n    } else if(abs(hitPoint.x - box.max.x) < 0.0001) {\n        normal = vec3(1.0, 0.0, 0.0); // Right face\n    } else if(abs(hitPoint.y - box.min.y) < 0.0001) {\n        normal = vec3(0.0, -1.0, 0.0); // Bottom face\n    } else if(abs(hitPoint.y - box.max.y) < 0.0001) {\n        normal = vec3(0.0, 1.0, 0.0); // Top face\n    } else if(abs(hitPoint.z - box.min.z) < 0.0001) {\n        normal = vec3(0.0, 0.0, -1.0); // Back face\n    } else if(abs(hitPoint.z - box.max.z) < 0.0001) {\n        normal = vec3(0.0, 0.0, 1.0); // Front face\n    }\n\n    x = Hit(tHit, normal, box.i);\n    return true;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if(t > 0.) {\n\n        x = Hit(t, vec3(0, 0, 1), pl.i);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    // Initialize the hit to a default value\n    x = Hit(1000.0, vec3(0.0), -1);\n\n    // Check for intersection with the first sphere (start point)\n    Sphere sphere1 = Sphere(capsule.start, capsule.radius, capsule.i);\n    Hit sphereHit1;\n    bool hitSphere1 = IntersectSphere(ray, sphere1, sphereHit1);\n\n    // Check for intersection with the second sphere (end point)\n    Sphere sphere2 = Sphere(capsule.end, capsule.radius, capsule.i);\n    Hit sphereHit2;\n    bool hitSphere2 = IntersectSphere(ray, sphere2, sphereHit2);\n\n    // Check for intersection with the cylindrical part (the tube)\n    vec3 tubeDir = normalize(capsule.end - capsule.start);\n    vec3 oc = ray.o - capsule.start;\n    float a = dot(ray.d - dot(ray.d, tubeDir) * tubeDir, ray.d - dot(ray.d, tubeDir) * tubeDir);\n    float b = 2.0 * dot(ray.d - dot(ray.d, tubeDir) * tubeDir, oc - dot(oc, tubeDir) * tubeDir);\n    float c = dot(oc - dot(oc, tubeDir) * tubeDir, oc - dot(oc, tubeDir) * tubeDir) - capsule.radius * capsule.radius;\n\n    // Calculate the discriminant\n    float discriminant = b * b - 4.0 * a * c;\n\n    if(discriminant >= 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Check if t1 and t2 are within the bounds of the cylindrical part\n        float h1 = dot(ray.o + t1 * ray.d - capsule.start, tubeDir);\n        float h2 = dot(ray.o + t2 * ray.d - capsule.start, tubeDir);\n\n        if(t1 >= 0.0 && h1 >= 0.0 && h1 <= length(capsule.end - capsule.start)) {\n            if(t1 < x.t) {\n                vec3 hitPoint = Point(ray, t1);\n                vec3 normal = normalize(hitPoint - (capsule.start + h1 * tubeDir));\n                x = Hit(t1, normal, capsule.i);\n            }\n        }\n\n        if(t2 >= 0.0 && h2 >= 0.0 && h2 <= length(capsule.end - capsule.start)) {\n            if(t2 < x.t) {\n                vec3 hitPoint = Point(ray, t2);\n                vec3 normal = normalize(hitPoint - (capsule.start + h2 * tubeDir));\n                x = Hit(t2, normal, capsule.i);\n            }\n        }\n    }\n\n    // Check if there was an intersection with either of the spheres\n    if(hitSphere1 && sphereHit1.t < x.t) {\n        x = sphereHit1;\n    }\n\n    if(hitSphere2 && sphereHit2.t < x.t) {\n        x = sphereHit2;\n    }\n\n    return (hitSphere1 || hitSphere2 || x.t < 1000.0);\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit hit) {\n    // Initialize the hit to a default value\n    hit.t = 1000.0;\n    \n    vec3 cylinderAxis = normalize(cyl.end - cyl.start);\n    vec3 oc = ray.o - cyl.start;\n    \n    float a = dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, ray.d - dot(ray.d, cylinderAxis) * cylinderAxis);\n    float b = 2.0 * dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, oc - dot(oc, cylinderAxis) * cylinderAxis);\n    float c = dot(oc - dot(oc, cylinderAxis) * cylinderAxis, oc - dot(oc, cylinderAxis) * cylinderAxis) - cyl.radius * cyl.radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    float h1 = dot(ray.o + t1 * ray.d - cyl.start, cylinderAxis);\n    float h2 = dot(ray.o + t2 * ray.d - cyl.start, cylinderAxis);\n    \n    if (discriminant >= 0.0) {\n        if (t1 >= 0.0 && h1 >= 0.0 && h1 <= length(cyl.end - cyl.start) && t1 < hit.t) {\n            vec3 hitPoint = Point(ray, t1);\n            vec3 normal = normalize(hitPoint - (cyl.start + h1 * cylinderAxis));\n            hit = Hit(t1, normal, cyl.i);\n        }\n        \n        if (t2 >= 0.0 && h2 >= 0.0 && h2 <= length(cyl.end - cyl.start) && t2 < hit.t) {\n            vec3 hitPoint = Point(ray, t2);\n            vec3 normal = normalize(hitPoint - (cyl.start + h2 * cylinderAxis));\n            hit = Hit(t2, normal, cyl.i);\n        }\n    }\n    \n    float tTopCap = dot((cyl.start - ray.o), cylinderAxis) / dot(ray.d, cylinderAxis);\n    float distanceTopCap = distance(Point(ray, tTopCap), cyl.start);\n    \n    if (tTopCap >= 0.0 && distanceTopCap <= cyl.radius && tTopCap < hit.t) {\n        hit = Hit(tTopCap, cylinderAxis, cyl.i);\n    }\n    \n    float tBottomCap = dot((cyl.end - ray.o), -cylinderAxis) / dot(ray.d, -cylinderAxis);\n    float distanceBottomCap = distance(Point(ray, tBottomCap), cyl.end);\n    \n    if (tBottomCap >= 0.0 && distanceBottomCap <= cyl.radius && tBottomCap < hit.t) {\n        hit = Hit(tBottomCap, -cylinderAxis, cyl.i);\n    }\n    \n    return hit.t < 1000.0;\n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x) {\n    // Spheres\n    const Sphere sph1 = Sphere(vec3(0., 1., 2.), 1., 3);\n    const Sphere sph2 = Sphere(vec3(2., 0., 2.), 1., 3);\n    const Plane pl = Plane(vec3(0., 0., 1.), vec3(0., 0., 0.), 8);\n\n    // Ellipsoid\n    const Ellipsoid ell = Ellipsoid(vec3(4., -1., 1.), vec3(2., 2., 1.), 7);\n\n    // Torus\n    const Torus torus = Torus(vec3(-1.0, -2.0, 2.0), 1.0, 0.3, 5);\n\n    // Box\n    const Box box1 = Box(vec3(2.0, 2.0, 1.0), vec3(4.0, 4.0, 3.0), 9);\n\n    const Cylinder cyl = Cylinder(vec3(-3.0, 3.0, 5.0), vec3(-3.0, 3.0, 2.0), 1.0, 4);\n    const Capsule cap = Capsule(vec3(-1.0, 3.0, 4.0), vec3(1.0, 3.0, 4.0), 0.5, 2);\n\n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n    if(IntersectSphere(ray, sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectEllipsoid(ray, ell, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    // Check torus intersection\n    if(intersectTorus(ray, torus, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if(IntersectCylinder(ray, cyl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    // Check box intersection\n    if(IntersectBox(ray, box1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if(IntersectCapsule(ray, cap, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    return ret;\n}\n\nvec3 Background(vec3 rd) {\n    return mix(vec3(.8, .8, .9), vec3(.7, .7, .8), rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m, vec3 n, vec3 p, vec3 viewDir) {\n    vec3 ambient = m.ambient;\n    vec3 diffuse = m.diffuse;\n    vec3 specular = m.specular;\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); // light direction\n    Hit temp;\n\n    // Calculate the normal and light direction\n    vec3 norm = normalize(n);\n\n    if(!Intersect(Ray(p + norm * 0.01, lightDir), temp)) {\n     // Calculate diffuse and specular terms\n        float diff = clamp(dot(norm, lightDir), 0., 1.);\n        vec3 reflectDir = -lightDir - 2.0 * dot(-lightDir, norm) * norm;\n        float spec = max(dot(reflectDir, viewDir), 0.0);\n\n    // Calculate the final color\n        vec3 ambientColor = ambient;\n        vec3 diffuseColor = diff * diffuse;\n        vec3 specularColor = spec * specular;\n\n        return ambientColor + diffuseColor + specularColor;\n\n    } else {\n\n        return vec3(.2, .2, .2);\n\n    }\n\n}\n\n// Hemisphere direction\n\nvec3 Hemisphere(int seed, vec3 n) {\n\n    float a = fract(sin(176.19 * float(seed)));// Uniform randoms\n\n    float b = fract(sin(164.19 * float(seed)));\n\n    float u = 2. * 3.1415 * a;// Random angle\n\n    float v = acos(2. * b - 1.);// Arcosine distribution to compensate for poles\n\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));// Direction\n\n    if(dot(d, n) < 0.) {\n        d = -d;\n    }// Hemishpere\n\n    return d;\n\n}\n\n// Ambient occlusion\n\n// p : Point\n\n// n : Normal\n\n// N : Number of samples\n\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    if(N == 0) {\n        return 1.0;  // No occlusion for N=0\n    }\n\n    float ao = 0.0;\n\n    for(int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // d dans la demi-sphere\n\n        // Create a shadow ray from the point to the sample point\n        Ray shadowRay;\n        shadowRay.o = p + 0.01 * n;\n        shadowRay.d = d;\n        \n        Hit hit;\n        bool hitSomething = Intersect(shadowRay, hit);\n\n        if(hitSomething && hit.t < 1000.) {\n            // The sample point is occluded, decrease ambient occlusion\n            ao += 1.0;\n        }\n    }\n\n    // Normalize the accumulated occlusion value to the range [0, 1]\n    ao = 1.0 - ao / float(N);\n\n    return ao;\n}\n\nvec3 Shade(Ray ray, int maxReflectionLevel, int N) {\n    vec3 accumulatedColor = vec3(0.0);\n\n    for(int reflectionLevel = 0; reflectionLevel <= maxReflectionLevel; reflectionLevel++) {\n        Hit x;\n        bool hitSomething = Intersect(ray, x);\n\n        if(!hitSomething) {\n            accumulatedColor += Background(ray.d);\n            break;\n        }\n\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n        vec3 norm = normalize(x.n);\n\n        // Calculate the base color (diffuse + ambient + specular)\n        vec3 baseColor = Color(mat, x.n, p, normalize(ray.o - p));\n\n        // Calculate ambient occlusion\n        float ambientOcclusion = AmbientOcclusion(p, x.n, N);\n\n        // Apply ambient occlusion to the base color\n        baseColor *= ambientOcclusion;\n\n        // Handle reflection\n        if(reflectionLevel < maxReflectionLevel && (mat.reflectivity.x > 0.0 || mat.reflectivity.y > 0.0 || mat.reflectivity.z > 0.0)) {\n            // Calculate the reflection direction\n            vec3 reflectDir = normalize(ray.d - 2.0 * dot(ray.d, norm) * norm);\n\n            // Create a reflected ray\n            ray.o = p + 0.01 * reflectDir; // Offset origin slightly to avoid self-intersection\n            ray.d = reflectDir;\n\n            // Accumulate reflected color\n            accumulatedColor += baseColor * mat.reflectivity;\n        } else {\n            accumulatedColor += baseColor;\n            break;\n        }\n    }\n\n    return accumulatedColor;\n}\n\n//Rotation\nRay RotateRay(Ray ray, float angle, vec3 axis) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n\n    vec3 ax = normalize(axis);\n    \n    mat3 rotation = mat3(\n        t * ax.x * ax.x + c, t * ax.x * ax.y - s * ax.z, t * ax.x * ax.z + s * ax.y,\n        t * ax.x * ax.y + s * ax.z, t * ax.y * ax.y + c, t * ax.y * ax.z - s * ax.x,\n        t * ax.x * ax.z - s * ax.y, t * ax.y * ax.z + s * ax.x, t * ax.z * ax.z + c\n    );\n    \n    ray.d = rotation * ray.d;\n    return ray;\n}\n\n//homothétie\nRay ScaleRay(Ray ray, vec3 scale) {\n    ray.d *= scale;\n    return ray;\n}\n\n//Transtlation\nRay TranslateRay(Ray ray, vec3 translation) {\n    ray.o += translation;\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    Ray ray;\n\n    // Ray origin\n    vec3 ro = 12. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n    vec3 ta = vec3(0., 0., 1.5);\n    mat3 ca = setCamera(ro, ta);\n\n    // Ray\n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n    ray.o = ro;\n    ray.d = rd;\n\n    //ray = RotateRay(ray, radians(45.0), vec3(0.0, 0.0, 1.0));\n    //ray = TranslateRay(ray, vec3(1.0, 2.0, 3.0));\n    //ray = ScaleRay(ray, vec3(2.0, 2.0, 2.0));\n\n    // Reflection Level\n    int Reflection = 10;\n\n    //Render\n\n    vec3 col = Shade(ray, Reflection, 128);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}