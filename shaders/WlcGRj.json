{
    "Shader": {
        "info": {
            "date": "1576789757",
            "description": "MDTMJVM = Middecembertomidjanuaryvember\nCoding daily at http://twitch.tv/wwrighter",
            "flags": 0,
            "hasliked": 0,
            "id": "WlcGRj",
            "likes": 26,
            "name": "[Twitch] Day 1 of MDTMJVM",
            "published": 3,
            "tags": [
                "tunnel",
                "repetition",
                "twitch",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 921
        },
        "renderpass": [
            {
                "code": "\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x + up*uv.y;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;  \n}\nfloat sdTube(vec3 p, float r) {\n    return length(p.xy) - r;\n}\n#define pi acos(-1.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat sdRuby (vec3 p, float r){\n  //p.z \n  p = abs(p);\n  p.z -= r;\n  p.yz *= rot(0.125*pi);\n  p.zx *= rot(-0.125*pi);\n  return p.z;\n}\n\n\n#define pi acos(-1.)\n\nfloat mpow(float num, float times) {\n    for (float i = 0.; i < times; i++) {\n    \tnum *= num;\n    }\n    return num;\n}\n\nfloat getScale(float z) {\n  //return 1;\n  \n  return 2.;\n  float sep = 3.;\n  z = mod(z, sep);\n  float id = floor(mod(z, sep));\n  if (id == sep - 1.) {\n    \n      return 1. + mpow(sin(fract(z - sep + 1.)*pi), 4.);\n  } else {\n    \n      return 1.;\n  }\n}\n\nfloat r21(vec2 u){\n\treturn fract(sin(u.y*3515125.1 + u.x *124215.125125)*1224115.125235);\n}\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*3515125.1 + u.x *124215.125125 + u.z*12525.215215215)*1224115.125235);\n}\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup =  mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup =  mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return j;\n    float h = mix(i, j, fd.z); \n        \n    float res = h;\n    \n\treturn res;\n}\n\nfloat fbm(vec3 uv){\n  uv.z = mod(uv.z, 20.);\n\tfloat res = 0.;\n  float amp = 1.;\n  float gain= 0.5;\n  float lac = 2.;\n  \n  for (float i = 0.; i < 1.;i++){\n    uv = abs(uv);\n    res += valueNoise(uv*lac)*amp;\t\n    amp *= gain;\n    lac *=2.;    \n  }\n\n\treturn res;\n}\n\n\n#define dmin(dA, dB) (dA.x < dB.x) ? dA : dB\nvec3 camOffs(float z){\n  z *= 0.2;\n  return vec3(\n    sin(z) + sin(z*0.2)*0.4,\n    cos(z),\n    0\n  )* ( 1. - getScale(z)) * 0.5;\n}\n\nvec3 pipeOffset(float z, float idx) {\n  float zScale = z*0.2;\n  float scale = 1.;\n  float scaleMod = 0.5 - getScale(zScale ) ;\n  if (idx == 0.) {\n    return vec3(\n      cos(z),\n      sin(z),\n      0\n    )*scale*scaleMod;    \n  } else if (idx == 2.) {\n    return vec3(\n      cos(z + 2.4),\n      sin(z + 2.4),\n      0\n    )*scale*scaleMod;    \n  } else if (idx == 3.) {\n    return vec3(\n      cos(z + 4.6),\n      sin(z + 4.6),\n      0\n    )*scale*scaleMod*0.6;    \n  } else if (idx == 4.) {\n    return vec3(\n      cos(z + 5.1),\n      sin(z + 5.4),\n      0\n    )*scale*scaleMod*2.;    \n  }\n}\n\n#define dmod(p, x) (mod(p, x) - x*0.5)\n\nfloat getTube(vec3 p, float idx) {\n  float d = 10e3;\n  p.z *= 0.5;\n  if (idx == 0.) {\n    vec3 pPipe = p - pipeOffset(p.z, 0.);\n    float dTube = sdTube(pPipe,0.2);\n    \n    pPipe.xy *= rot(p.z*1.6 + sin(iTime + p.z));\n    vec2 uv = vec2(atan(pPipe.x, pPipe.y));\n    \n      \n    dTube -= sin(uv.x*10. + sin(uv.y)*1. + iTime*5.)*0.07;\n    \n    return dTube/2.;  \n  } else if (idx == 2.) {\n    vec3 pPipe = p - pipeOffset(p.z, 2.);\n    float dTube = sdTube(pPipe,0.2);\n    \n      float dbetween = 0.2;\n      vec3 pSphere = dmod(p+ vec3(0,0,iTime*0.1), dbetween) ;\n      dTube = max(dTube, sdSphere(pSphere, 0.08));  \n    \n    return dTube;\n  } else if (idx == 3.) {\n    \n    vec3 pPipe = p - pipeOffset(p.z, 3.);\n    float dbetween = 0.2;\n    vec3 pRuby= pPipe + vec3(0,0,iTime*0.1);\n    pRuby.xy *= rot(0.2 + iTime*0.1 + sin(iTime + p.z));\n    \n    pRuby.z = dmod(p.z, dbetween);\n    \n    float id = floor(p.z);\n    \n    pRuby.y *= 0.9;\n    float dTube = sdTube(pPipe,0.1);\n    \n    float dRuby = sdRuby(pRuby, 0.056);\n    \n    dTube = min(dTube, dRuby);\n    \n    //dTube = max(dTube, sdRuby(pRuby, 0.5));\n      \n    \n    return dTube;\n  } else if (idx == 4.) {\n    vec3 pPipe = p - pipeOffset(p.z, 4.);\n    float dTube = sdTube(pPipe,0.2) - fbm(vec3(p.x*1.,p.y*3.,p.z))*0.07;\n    \n    \n    return dTube;\n  }\n  \n \n  return d;\n}\n\n\nvec2 map(vec3 p){\n  p.xy -= 5.;\n  p.xy = dmod(p.xy, 10.);\n  vec2 d = vec2(10e3, 100);\n  \n  d = dmin(d, vec2(getTube(p, 0.), 0.));\n  d = dmin(d, vec2(getTube(p, 2.), 2.));\n  d = dmin(d, vec2(getTube(p, 3.), 3.));\n  d = dmin(d, vec2(getTube(p, 4.), 4.));\n  \n  //d = dmin(d, vec2(sdRuby(p - vec3(0,0,iTime + 3), 0.2), 3.));\n  \n  \n  \n  return d/3.;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.006,0);\n    return normalize(\n      vec3(map(p).x) - vec3(\n        map(p + t.xyy).x,\n        map(p + t.yxy).x,\n        map(p + t.yyx).x\n      )  \n    );\n}\n\n#define spectra(inp) (0. + 0.6*sin(vec3(0.9,0.7,5.1) + inp))\n\nvec3 glow = vec3(0);\nvec4 render(vec2 uv) {\n  \n  vec3 col = vec3(0);\n  vec3 ro = vec3(0.,0.,0. + iTime*3.) ;\n  vec3 lookAt = ro + vec3(0. + sin(iTime*0.25)*0.6,0. + sin(iTime*0.25)*0.6,5.);\n  ro += camOffs(ro.z);\n  \n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  vec2 t = vec2(0);\n  vec3 p = ro;\n  \n  for (int i = 0; i < 150; i++) {\n      vec2 d = map(p);\n      \n      glow += spectra(d.x*20.)*0.0002;\n      if (d.x < 0.001) {\n        // collision\n        \n        vec3 posLightA = lookAt - vec3(0,3,2);// + vec3(cos(iTime*0.2), sin(iTime*0.2), 0);\n        \n        float diff = 0.;\n        float spec = 0.;\n        \n        vec3 n = getNormal(p);\n        \n        vec3 l = normalize(posLightA - p);\n        \n        if (d.y == 0.) {\n          float fres = max(pow(1. - dot(-rd, n), 5.), 0.);\n          float diff = max(dot(n,l),0.);\n          float spec = max(dot(normalize(ro - p), n),0.);\n          col += vec3(0.1) * (spec + diff);\n          //col = vec3(1.);\n        } else if (d.y == 1.) {\n          float fres = max(pow(1. - dot(rd, n), 5.), 0.);\n          float diff = max(dot(n,l),0.);\n          col += vec3(0.03) *(fres*diff);\n        } else if (d.y == 2.) {\n          float fres = max(pow(1. - dot(rd, n), 5.), 0.);\n          float diff = max(dot(n,l),0.);\n          col += vec3(0.1) *(fres);\n        } else if (d.y == 3.) {\n          float fres = max(pow(1. - dot(-rd, n), 1.), 0.);\n          float diff = max(dot(n,l),0.);\n          float thingie = max(dot(normalize(ro - p), n),0.);\n          col += vec3(2) *(thingie + diff);\n        }else  {\n          float fres = max(pow(0.6 - dot(rd, n), 1.), 0.);\n          float diff = max(dot(n,l),0.);\n          col += vec3(0.06) * fres;\n        }\n        \n        //col *= spectra(d.y*1 + 5);\n        break;\n      }\n      if (d.x > 2000.) {\n        // wall\n        col = vec3(0.0);\n        break;\n      }\n      t.x += d.x;\n      p = ro + t.x * rd;\n  }\n  col += glow;\n  col = pow(col, vec3(0.44));\n  \n  return vec4(col, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    col.g *= 0.5;\n    col.b *= 0.2;\n    col *= 4.6;\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}