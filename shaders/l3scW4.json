{
    "Shader": {
        "info": {
            "date": "1726204945",
            "description": "origianls  https://glslsandbox.com/e#59829.0",
            "flags": 0,
            "hasliked": 0,
            "id": "l3scW4",
            "likes": 3,
            "name": "fractalic place #2",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 93
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*2.5+.5)\n#define pi acos(-1.)\n#define TAU (2.* pi)\n#define t iTime\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n#define PI 3.141592\n\nvec2 randomVec2( vec2 p )\n{\n\tmat2 m = mat2( 15.27, 47.63,\n\t\t       99.41, 88.98 );\n\t\n\treturn fract( sin(m * p) * 46839.32 );\n}\n\nfloat cust_rand(vec2 co){\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 cust_rand_2(vec2 co){\n    return vec2(cust_rand(co), cust_rand(co + vec2(0.23)) );\n}\n\nvec2 voronoi( vec2 p )\n{\n\t\n\tvec2 grid_point = floor( p );\n\tvec2 distance_from_middle = fract(p);\n\t\n\tfloat t = 2.0;\n\t\n\tvec2 result;\n\t\n\t\n\tfloat minDistance = 100000.0;\n\t\n\tfor( int y = -1; y <= 1; ++y )\n\t{\n\t\tfor( int x = -1; x <= 1; ++x )\n\t\t{\n\t\t\t\t\t\t\n\t\t\tvec2 lattice = vec2( x, y );\n\t\t\tvec2 offset = cust_rand_2(lattice + grid_point);\n\t\t\t\n\t\t\t//float d = distance( lattice + vec2((sin( time * offset) * 0.5 + 0.5) ), f);\n\t\t\tfloat d = distance(lattice + offset, distance_from_middle);\n\t\t\t\n\t\t\tif( d < minDistance )\n\t\t\t{\t\n\t\t\t\tminDistance = d;\n\t\t\t\tresult = offset;\n\t\t\t}\n\t\t\t\n\t\t\tresult = offset;\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\treturn result;\n}\n\nvec2 test(vec2 p){\n\tvec2 grid_point = floor( p );\n\tvec2 distance_from_middle = fract(p);\n\t\n\treturn cust_rand_2(grid_point);\n}\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 1.0; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 64.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 50.0, -0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat sphere(vec3 p)\n{\n\treturn length(p)-5.;\n}\n\nfloat displacement(vec3 p)\n{\n\treturn sin(p.x) + sin(p.y) + sin(p.z);\n}\n\nfloat opDisplace( vec3 p )\n{\n\tfloat d1 = sphere(p);\n\tvec3 s = p;\n\t// mercury ftw\n    \tfloat d2 = displacement(s);\n\td2 += displacement(vec3(d2 * 3.0)) * 0.5;\n\td2 += displacement(vec3(d2 * 5.0)) * 0.1;\n\n\t\n    \treturn max(d1,-(d2/6.0));\n}\n#define time iTime\n#define resolution iResolution.xy\nvoid mainImage(out vec4 O, vec2 C)\n\n{\n    O=vec4(0);\n    vec4 o = O;\n    vec2 u = C;\n    vec2 r = iResolution.xy;\n         u = (u - r / 2.) / r.y;\n   float zoom = 0.3;\n\t\n\n\n\t//vec3 finalColor = cos(c.x * 10.23 + vec3( 1.0, 2.0, 3.0)) * 0.5 + 0.5;\n\n    u = vec2(\n           atan(u.x, u.y) + t * .1,\n           log(length(u)) + cos(t * .3) - t * .3\n        );\n\n    float g = 24.;\n    u = fract(u / TAU) * g;\n    \n    u.y /= g/39.;\n    u += u.x;  \n    \n    \n    vec2 k = floor(u);   \n    u -= k;              \n    \n    float d = mod(k.x + k.y, 3.);     \n    \n    k -= step(u + 1., u.yx + d);\n    \n    \n    o = mod(k.xyyy + 1., .4) * 3.\n            //* (1. - length(u + .3) * .5)  // shadows\n                + .0                 // brights\n                ;\n    vec3 p,q,r2=iResolution,\n    d2=normalize(vec3((C*2.-r2.xy)/r2.y,1));  \n    \n    vec2 uv = (C-.5*iResolution.xy)/iResolution.y;\nuv*=Rot(iTime);\n\tuv.x += resolution.x / resolution.y;\n\tuv.x = dot(uv,uv);\n    \n    \n\tvec2 c2 = test( uv / zoom );\n    \n    vec2 p2 = -1. + 2.*gl_FragCoord.xy / resolution.xy;\n\tp2.x *= resolution.x/resolution.y;\n\t\n\t//Camera animation\n  vec3 vuv=vec3(0,1,0);//Change camere up vector here\n  vec3 vrp=vec3(0,1,0); //Change camere view here\n  vec3 prp=vec3(sin(time*0.2)*8.0,4,cos(time*0.2)*8.0); //Change camera path position here\n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u2=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u2);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+p2.x*u2+p2.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  //Raymarching\n  const vec3 e=vec3(0.1,0,0);\n  const float maxd=16.0; //Max depth\n\n  float s=0.1;\n  vec3 c,p1,n;\n\n  float f=1.0;\n  for(int i=0;i<16;i++){\n   // if (abs(s)<.01||f>maxd) break;//eliminating break so I can try out w/ core image.-gtoledo\n    f+=s;\n    p1=prp+scp*f;\n    s=opDisplace(p1);\n  }\n  \t\n\t//replacing if/else with ternary to try out with apple's \"core image\"-gtoledo\n\tc=vec3(.1,0.5,0.8);\n    \tn=normalize(\n      \tvec3(s-opDisplace(p1-e.xyy),\n           s-opDisplace(p1-e.yxy),\n           s-opDisplace(p1-e.yyx)));\n    \tfloat b=dot(n,normalize(prp-p1));\n    \tvec4 tex=vec4((b*c+pow(b,8.0))*(1.0-f*.01),1.0);\n\tvec4 background=vec4(0,0,1,0);\n\t\n\tvec4 Color=(f<maxd)?tex:background;\n\t\n    \n\n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.1,1.,10.),H(g*.1),.8)*10./e/8e3\n    )\n    {\n        p=g*d2 ;\n       p.z+=iTime;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n        \n            p=.23-abs(p);\n           \n            p.x<p.z?p=p.xzy:p;\n            p.z<p.y?p=p.xzy:p;\n          \n            s*=e=1.4+sin(iTime*.001)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 )*c2.x+c2.y;\n         }\n         g+=e=length(p.yxz)/s;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}