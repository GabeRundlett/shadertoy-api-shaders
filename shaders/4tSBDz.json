{
    "Shader": {
        "info": {
            "date": "1515282010",
            "description": "A grid of spheres, inverted in another sphere. Based on [url]https://www.shadertoy.com/view/4lBfWR[/url]\n\n'i' shows uninverted grid. 'a','d','s' turn on and off the Phong shading elements - default is just ambient and specular.",
            "flags": 17,
            "hasliked": 0,
            "id": "4tSBDz",
            "likes": 12,
            "name": "Another Grid of Spheres",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "grid",
                "spheres",
                "inversion"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 4899
        },
        "renderpass": [
            {
                "code": "bool doAmbient = true;\nbool doDiffuse = true;\nbool doSpecular = true;\nbool doInversion = true;\n\nconst float EPSILON = 0.001;\nconst float limit = 100.0;\n//material parameters\nconst float ks = 3.0;\nconst float kd = 3.0;\nconst float ka = 1.0;\nconst float al = 4.0;\n//light parameters\nconst float ia = 1.0;\nvec3 lm = normalize(vec3(1,3,1));\nconst float id = 1.0;\nconst float is = 1.0;\n\nconst float PI = 3.14159;\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.y*PI;\n    p.yz = rotate(p.yz,phi);\n    p.zx = rotate(p.zx,phi);\n  }\n  //p.yz = rotate(p.yz,0.1*iTime * 0.125);\n  p.zx = rotate(p.zx,0.1*iTime);\n  return p;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat map(vec3 p){\n    float k = 1.0;\n    if (doInversion) {\n        k = dot(p,p);\n    \tp /= k;\n    \tp.y += 0.5*iTime;\n    \tp += vec3(0.1,0.2,0.3);\n    }\n\n    vec3 q = p-round(p);\n\n    return k*(length(q)-0.3);\n}\n\nfloat march(vec3 o, vec3 r){\n \tfloat t = 0.1;\n    float precis = 1e-4;\n    for(int i=0;i<200;++i){\n        vec3 p = o+r*t;\n        float d = map(p);\n        if (abs(d) < t*precis) return t;\n        t += d/(1.0+0.3*d);\n        if(t>limit || t < 0.0){\n            return limit;\n        }\n    }\n    return t;\n}\n\nfloat phong(vec3 n, vec3 v) {\n    float k = dot(lm,n);\n    vec3 rm = 2.0*k*n-lm;\n    rm *= float(k>0.0);\n    \n    float ip = 0.0;\n    if (doAmbient) ip += ka*ia;\n    if (doDiffuse) ip += kd*max(dot(lm,n),0.0)*id;\n    if (doSpecular) ip += ks*pow(max(dot(rm,v),0.0),al)*is;\n    \n    return 0.3*ip;\n        \n   }\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x+EPSILON,p.y,p.z))-map(vec3(p.x-EPSILON,p.y,p.z)),\n        map(vec3(p.x,p.y+EPSILON,p.z))-map(vec3(p.x,p.y-EPSILON,p.z)),\n        map(vec3(p.x,p.y,p.z+EPSILON))-map(vec3(p.x,p.y,p.z-EPSILON))\n    ));\n}\n\nbool keypress(int code) {\n#if __VERSION__ < 300\n    return false;\n#else\n\treturn texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n\nvec4 solve(vec3 o, vec3 r) {\n    float t = march(o,r);\n\n    if((t == limit) || map(t * r + o)>EPSILON){\n        return vec4(0,0,0,1);\n    } else {\n        \n    float intensity = phong(getNormal(t*r+o),-r);\n        vec3 p = o + t*r;\n        if (doInversion) {\n        \tp /= dot(p,p);\n        \tp.y += 0.5*iTime;    \n            p += vec3(0.1,0.2,0.3);\n        }\n    ivec3 ip = ivec3(round(p));\n    float h = fract(float(ip.x + ip.y + ip.z)/9.9);\n\t\n\treturn vec4(pow(hsv2rgb_smooth(vec3(h,1,intensity)),vec3(0.4545)), 1);\n\n    }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord,\n             in vec3 fragRayOrigin, in vec3 fragRayDir) {\n  fragRayOrigin.z += 2.5;\n  fragColor = solve(fragRayOrigin,fragRayDir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    doAmbient = !keypress(CHAR_A);\n    doDiffuse = keypress(CHAR_D);\n    doSpecular = !keypress(CHAR_S);\n    doInversion = !keypress(CHAR_I);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    vec3 r = normalize(vec3(uv,2));\n\n    vec3 o = vec3(0,0,-2); //vec3(iTime,0,iTime);\n\n    if (iMouse.y > 0.0) {\n      o *= 2.0*iMouse.y/iResolution.y;\n    }\n    o = transform(o);\n    r = transform(r);\n    lm = transform(lm);\n    fragColor = solve(o,r);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}