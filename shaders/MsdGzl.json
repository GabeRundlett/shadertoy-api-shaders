{
    "Shader": {
        "info": {
            "date": "1451942717",
            "description": "A simple pathtracer, with progressive rendering. The random numbers are really bad quality, so this is probably noisier than it should, and biased. I have disabled the specular reflections.",
            "flags": 32,
            "hasliked": 0,
            "id": "MsdGzl",
            "likes": 223,
            "name": "Basic Montecarlo",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "gi",
                "global",
                "pathtracing",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 36498
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 col = data.xyz/data.w;\n\n    // tonemap\n    col = col*1.4/(1.0+col);\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    // vignetting\n\tvec2 uv = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// Pathtrace the scene. One path per pixel. Samples the sun light\n// and the sky dome light at each vertex of the path.\n//\n// More info: https://iquilezles.org/articles/simplepathtracing\n\n//------------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n//------------------------------------------------------------------\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand();\n    float v = frand();\n\n    // Method 1 and 2 first generate a frame of reference to use\n    // with an arbitrary distribution, cosine in this case.\n    // Method 3 (invented by fizzer) specializes the whole math to\n    // the cosine distribution and simplifies the result to a more\n    // compact version that does not even need constructing a frame\n    // of reference.\n\n    #if 0\n        // method 1 by http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n        vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n        vec3 uu = vec3( tc.x, tc.z, -nor.x );\n        vec3 vv = vec3( tc.z, tc.y, -nor.y );\n        float a = 6.2831853*v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n    #endif\n\t#if 0\n                               \n    \t// method 2 by pixar: https://graphics.pixar.com/library/OrthonormalB/paper.pdf or http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n    #endif\n    #if 1\n    \t// method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n        float a = 6.2831853*v; float b = 2.0*u-1.0;\n        vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n        return normalize( nor + dir );\n    #endif\n}\nvec3 uniformVector(void)\n{\n    float phi = frand()*6.28318530718;\n    float x = frand()*2.0-1.0;\n    float z = frand();\n\treturn pow(z,1.0/3.0)*vec3(sqrt(1.0-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n    \n//------------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = max(di.x,max(di.y,di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nvec2 map( vec3 p )\n{\n    vec3 w = p;\n    vec3 q = p;\n\n    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;\n    \n    float d = sdBox(q,vec3(1.0));\n    float s = 1.0;\n    for( int m=0; m<6; m++ )\n    {\n        float h = float(m)/6.0;\n\n        p =  q - 0.5*sin( abs(p.y) + float(m)*3.0+vec3(0.0,3.0,1.0));\n\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        d = max( c, d );\n   }\n\n   vec2 res = vec2(d,1.0);\n    \n   {\n   d = length(w-vec3(0.22,0.35,0.4)) - 0.09;\n   if( d<res.x ) res=vec2(d,2.0);\n   }\n   \n   {\n   d = w.y + 0.22;\n   if( d<res.x ) res=vec2(d,3.0);\n   }\n    \n   return res;\n}\n\n//------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 eps = vec2(0.0001,0.0);\n    return normalize( vec3(\n      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,\n      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,\n      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n    float tmax = 16.0;\n    float t = 0.01;\n    for(int i=0; i<128; i++ )\n    {\n        vec2 h = map(ro+rd*t);\n        res = vec2(t,h.y);\n        if( h.x<0.0001 || t>tmax ) break;\n        t += h.x;\n    }\n    \n    if( t>tmax ) res.x = -1.0;;\n\n    return res;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t).x;\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    return (t<tmax) ? res : 1.0;\n}\n\nconst float epsilon = 0.0001;\nvec3 light( vec3 surfColor, float surfSpecN, bool surfIsMetal,\n            vec3 pos, vec3 nor, vec3 rd, \n            vec3 ligDir, vec3 ligColor )\n{\n    vec3 fo = (!surfIsMetal) ? vec3(0.04) : surfColor;\n\n    vec3  hal = normalize(ligDir-rd);\n    float dif = max(0.0, dot(ligDir, nor));\n    float sha = 1.0; if( dif > 0.00001 ) sha = shadow( pos + nor*epsilon, ligDir);\n    float spe = (surfSpecN+0.0)/8.0*pow(clamp(dot(nor,hal),0.0,1.0),surfSpecN);\n    vec3  fre = fo + (1.0-fo)*pow(clamp(1.0-dot(hal,ligDir),0.0,1.0),5.0);\n    \n    vec3 res = vec3(0.0);\n\n    if( !surfIsMetal )\n    res += surfColor * ligColor * dif * sha;\n    res +=             ligColor * dif * sha * spe * fre * 3.0;\n    return res;\n}\n\nconst vec3 sunDir = normalize(vec3(-0.3,1.3,0.1));\nconst vec3 sunCol = 12.0*vec3(1.1,0.8,0.6);\nconst vec3 skyCol = 6.0*vec3(0.2,0.5,0.8);\n\nvec3 calculateColor(vec3 ro, vec3 rd )\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n\n    float fdis = 0.0;\n    for( int bounce = 0; bounce<4; bounce++ ) // bounces of GI\n    {\n        //rd = normalize(rd);\n       \n        //-----------------------\n        // trace\n        //-----------------------\n        vec2 tm = intersect( ro, rd );\n        float t = tm.x;\n        if( t < 0.0 )\n        {\n            if( bounce==0 ) return mix( 0.1*vec3(0.8,0.9,1.0), skyCol, smoothstep(0.05,0.1,rd.y) );\n            break;\n        }\n\n        if( bounce==0 ) fdis = t;\n\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal( pos );\n        \n        //-----------------------\n        // material\n        //-----------------------\n\n        vec3  surfColor;\n        float surfSpecN;\n        bool  surfIsMetal;\n        if( tm.y<1.5 )\n        {\n        surfColor= vec3(0.38)*vec3(1.2,0.8,0.6);\n        surfIsMetal = false;\n        surfSpecN = 8.0;\n        }\n        else if( tm.y<2.5 )\n        {\n        //surfColor = vec3(0.37);\n        surfColor = vec3(0.9,0.8,0.5);\n        surfIsMetal = true;\n        surfSpecN = 2000.0;\n        }\n        else //if( tm.y<2.5 )\n        {\n        surfColor = vec3(0.38)*vec3(1.2,0.8,0.6);\n        surfIsMetal = false;\n        surfSpecN = 8.0;\n        }\n\n\n        //-----------------------\n        // sample light sources\n        //-----------------------\n\n        // light 1 : sun\n        accumulatedColor += light(surfColor*colorMask,surfSpecN,surfIsMetal,\n                                  pos,nor,rd,\n                                  sunDir, sunCol );\n\n        // light 2 : sky\n        #if 0\n        // sample sky uniformly\n        vec3 skyDir = uniformVector();\n        if( skyDir.y<0.0 ) skyDir=-skyDir;\n        accumulatedColor += light(surfColor*colorMask,surfSpecN,surfIsMetal,\n                                  pos,nor,rd,\n                                  skyDir, skyCol )*3.1415;\n        #else\n        // sample sky cosine weighted\n        vec3 skyDir = cosineDirection(nor);\n        if( skyDir.y<0.0 ) skyDir=-skyDir;\n        accumulatedColor += light(surfColor*colorMask,surfSpecN,surfIsMetal,\n                                  pos,nor,rd,\n                                  skyDir, skyCol )/(dot(nor,skyDir)+0.00001);\n        #endif                          \n\n        //---------------------------------\n        // bounce and gather indirect light\n        //---------------------------------\n        \n        if( surfIsMetal )\n        {\n            // TODO: I feel need to multiply colorMask by fresnel\n            colorMask *= surfColor;\n            float glo = clamp(1.0-surfSpecN/2048.0,0.0,1.0);\n            glo = glo*glo;\n            rd = normalize(reflect(rd,nor)) + glo*uniformVector();\n        }\n        else\n        {\n            //float isDif = 1.0;\n            //if( frand() < isDif )\n            {\n               colorMask *= surfColor;\n               rd = cosineDirection(nor);\n            }\n            //else\n            //{\n            //    float glo = clamp(1.0-surfSpecN/2048.0,0.0,1.0);\n            //    glo = glo*glo;\n            //    rd = normalize(reflect(rd,nor)) + glo*uniformVector();\n           // }\n        }\n        ro = pos;\n   }\n\n   float ff = exp2(-0.2*fdis);\n   accumulatedColor *= ff; \n   accumulatedColor += (1.0-ff)*(1.0-ff)*0.1*vec3(0.8,0.9,1.0);\n\n\n   \n   \n   return accumulatedColor;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms\n    srand( ivec2(fragCoord), iFrame );\n\n    \n    vec2 of = -0.5 + vec2( frand(), frand()  );\n    vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec3 ta = vec3(1.5,0.7,1.5);\n\n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-1.3) );\n\n    vec4 data = texture( iChannel0, fragCoord/iResolution.xy );\n    if( iFrame==0 ) data = vec4(0.0);\n    \n    data += vec4( calculateColor( ro, rd ), 1.0 );\n\n    fragColor = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}