{
    "Shader": {
        "info": {
            "date": "1541461718",
            "description": "part8 eas a messy union",
            "flags": 8,
            "hasliked": 0,
            "id": "llcfWl",
            "likes": 1,
            "name": "starguitar 9",
            "published": 3,
            "tags": [
                "intersect",
                "synthesis",
                "aperiodic",
                "culling",
                "aabv",
                "kerning",
                "starguitar",
                "quadraticfield",
                "hash41",
                "nancarrow"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 894
        },
        "renderpass": [
            {
                "code": "void mainImage(out ve3 o,ve1 u\n){o=entryImage(iTime,u,iResolution,iMouse)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//lesson:\n//just use sg7 [ Xl3fWf ] and evaluate each frequency in a VERY seperate floor() context\n//that disregards all other frequencies.\n//meaning, a note that is not in a frewuency is a \"null-note\" for THIS frequency!\n//this \"null note\" is defined by range[-noteinf,-noteinf]\n//\n// sg11: https://www.shadertoy.com/view/4ltBWl   <- 2d xor failure , realization that sg7 is best and simplest\n// sg10: https://www.shadertoy.com/view/Ml3BDs   <- 2d xor failure\n//  sg9: https://www.shadertoy.com/view/llcfWl   <- 2d 2 notes fine, 3 notes fail (cheesy)\n//  sg8: https://www.shadertoy.com/view/llcfDX   <- 2d xor attempt 1\n//  SG7: https://www.shadertoy.com/view/Xl3fWf   <- 1d SOLUTION (with 2 and 3...)   <-!!!!!!!!\n//  sg5: https://www.shadertoy.com/view/ltdBWj   <- 1d badphase & abs()\n//  sg4: https://www.shadertoy.com/view/XlcBDj   <- 1d kerning arithmetic works!\n//  sg3: https://www.shadertoy.com/view/lldfDB   <- 1d kerning arithmetic beta\n//  sg2: https://www.shadertoy.com/view/MttfWB   <- 2d very experimental\n//  sg1: https://www.shadertoy.com/view/MtdBWB   <- 2d concept analysis\n\n//kerning, synthesis, aperiodic, culling, aabv, starguitar, quadraticfield, hash41, nancarrow,intersect\n\n// sg10:  still fails in extending to 3: https://www.shadertoy.com/view/Ml3BDs\n\n/*\ndrag mouse to set blue boxes  (starguitar 5,7 fold to 1d)\n- source is 2 blue boxes, that either\n- - contain another\n- - intersect\n- - are seperate\n- target is 1 yellow box; iff(not seperate) return AABV; else return box that is closer to uv.\n- - composites of all red boxes become a hull-curve, that auto-merge where they overlap\n\niMouse.xz set centers of 2 boxes\niMouse.zw set 2 halfwidths of 2 boxes\ncan be represented as triangles (red and green)\n, where imouse.xy sets +one triangle top\n, where imouse.zw sets +one triangle top\nline intersections (2 o 3 yellow dots) equate box intersections\n//if (bottom intersection.y<=0) the boxes intersect ([<=] for closedInterval, [<] for openInterval boxes)\n//top intersection.xy sets an AABV upper bound of both boxes\n\nIt alway bugged me how to define midi sheets, but also as distance field.x\n, where a note stops and another note starts, often at the same moment\nthis is a min() of 2 notes, that may or may not be the same single long note.\nthe whole .y domain is only relevant for visualization here.\nin a \nhttps://www.shadertoy.com/results?query=starguitar\nshader the .y domain will be \"frequency\" or \"keyboard key\" == frequency, scaled by a note key using;\nhttps://www.shadertoy.com/view/4ttBD4\n*/\n\n/*\nassume uv.x to be time\nassume uv.y to be frequency (piano key id)\n\nblue is a usual distance field, for now only rectangles are defined with this the \"starguitar\" extension\n- bright blue  means negative distance to a box surface\n- bright green means \"-(green) more iTime till first note starts\" (it counts up)\n\ngreen or red only measure Distance.x\ngreen is the (negative) distance to the nearest box to the right.\nred   is the (negative) distance to the nearest box to the left.\n\nuv.xy taps one point in time for one freuency. if its blue, there is a note played at iTime.x\n- green == how long this note has been played (till iTime == now)\n- red   == how long till this note ends       (till iTime == now) //not needed for pluck/percussion instruments\n\nred and green are negated (!)\n- to avoid overlap, when using the same fract() or smin() functions as for \"blue\"\n- to make the inherent (parallel projection) frustrum culling debugging easier.\n\nand only an min() union is defined, that was tricky enough\n- any break between 2 notes will appear yellow (or black with negateRG)\n- , this the negative-color of the note in terms of duration.\nred and green are negated to use the same smin() function to make them visible\n, without overlapping too much.\n*/\n\n//invert redGreen\n//#define negateRG\n\n//alternative color sceme fallof; *=1.-log(abs())\n#define showGradLog\n\n/*\n\"starguitar\" defines shapes, where .w is the usual distance field as in the hg_sdf collection\nwhile .xy define center and (half)length of a note\nthe min() max() mixing cases for this had to be debugged in here\nbecause there are multiple different ways to bound this.\n\na possible extension to this, with derivatives, may even generate\nhttps://www.youtube.com/watch?v=4t0jDUQ2aJ4\nhttps://www.youtube.com/watch?v=RIz3klPET3o\nhttps://www.youtube.com/watch?v=XJpVbUICUb4\nbut procedurally\n*/\n\n\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 19.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(t,u,r,m)(u-.5*r.xy)*ViewZoom/r.y\n\n//array indexing srarts at 0 within chinese remainders.\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n\nve0 ma(ve1 a){return max(a.x,a.y);}\n\n#define inf 99999.\n#define noteInf 9999.\n\n//elementary\nfloat si(float i){return sin(fract(i)* pi*2.); }\n//clamped siene sounds more like a metallic flute if(with overtones)\nfloat csi(float i){return clamp(si(i),-.707,.707); }             \nfloat saw(float i){return fract(i)*2.-1.;}\nfloat sq(float i){return mix(0.,1.,step(fract(i),.5));}\n//(https://www.shadertoy.com/view/4sSSWz)\n//elementary\n#define trunc(a) float(int(a))\nfloat notetrunc(float t){return trunc(sin(0.25*t)*4.+cos(0.375*t)*4.0);}\n//https://www.shadertoy.com/view/4sXSWf\n//elementary noteKey to freuency\nfloat n2f      (float n){return 55. *pow(2.,(n- 3.)/12.);}\nfloat noteFreq (int n  ){return n2f(float(n+39));}\nfloat noteMIDI (float n){return 440.*pow(2.,(n-69.)/12.);}\nfloat calcHertz(float n){return 440.*pow(2.,(n    )/12.);}\n\n//base shape of [starguitar]\nvec3 ng(vec2 u,vec2 c,vec2 w//u,center,width ;returns \"star guitar note\"\n){c.y=floor(c.y)// assert floored c.y \n ;if(fract(w.y/2.)*2.>0.)u.y-=.5\n ;w.y=w.y*.5\n ;float start0=-noteInf\n ;float end0=-noteInf\n ;if(abs(u.y-c.y)<w.y //u.y must be in the condition that sets start/end\n ){\n  ;start0= c.x-w.x\n  ;end0  =-c.x-w.x//but u.x can be kept out of start0 and end0\n  ;}\n  ;float blue0=abs(ma(abs(u-c)-w))\n ;return vec3(start0,end0,blue0)\n ;}\n\n//the min() function of [starguitar] 2 notes in, 1 note out; u=uv.\nvec3 mig(vec2 u ,vec3 a,vec3 b\n){vec4 c=vec4(0)\n //min note fold:  \n ;a.z=min(a.z,b.z)\n ;vec4 w=vec4(a.x,a.y,b.x,b.y)\n ;//if(max(w.x,-w.y)-u.x>0.){a.z=0. ;}//compare with right line of right box   \n ;//if(max(w.z,-w.w)-u.x>0.){a.z=0. ;}//compare with right line of left  box\n ;//if(min(w.x,-w.y)-u.x>0.){a.z=0. ;}//compare with left  line of right box\n ;//if(min(w.z,-w.w)-u.x>0.){a.z=0. ;}//compare with left  line of left  box\n ;if((int(a.x>-noteInf) ^ int(b.x>-noteInf))>0\n     //||b.x>-noteInf\n ){//a.z=.0;\n  ;a.x=max(a.x,b.x) \n  ;a.y=max(a.y,b.y)\n ;}else{\n  ;if(mix(a.x,-a.y,.5)<mix(b.x,-b.y,.5))w=w.zwxy//sort boxes by box center\n  ;if(w.x+w.w>0.){//boxes are speerate\n   ;a.x=min(w.z,-w.w) \n   ;a.y=-max(w.x,-w.y)\n   ;if(min(w.z,-w.w) -u.x<0.&&min(w.x,-w.y)-u.x>0.){a.y=-max(w.z,-w.w);}//green works!!!\n   ;if(max(w.x,-w.y)-u.x>0.&&max(w.z,-w.w)-u.x<0.){a.x= min(w.x,-w.y);}//red works!!!\n  ;}else{//boxes are not seperate\n   ;a.x=min(a.x,b.x)  \n   ;a.y=min(a.y,b.y)\n  ;}\n ;}\n ;c.w-=.1\n ;return a; /**/\n;}\n\n\n//skeletons and intervals:\n//vec2 interval=vec2(start,end)    , assumes startyend     , otherwise resersd\n//vec2 skeleton=vec2(center,width) , assumes positive width, otherwise resersd\n//i2s() or a2i() to NOT sort outputs, but maintain the reversed-state.\nvec2 i2s(vec2 a){return (a.y+vec2(1,-1)*a.x)*.5;}//interval vec2(start,end) to skeleton vec2(center,width)\nvec2 s2i(vec2 a){return (a.x+vec2(-1,1)*a.y);}//skeleton vec2(center,width) to interval vec2(start,end)\n\n\nvec4 starGuitar(float t,vec2 u,vec3 r,vec4 m){\n ;ve3 c=ve3(0,0,0,1)\n ;//m.yw=floor(m.yw) //integrated into   ng()\n ;vec3 a=ng(u,m.xy,vec2(2.,1.))//a short jazz-chord  (7short notes)\n ;vec3 b=ng(u,m.zw,vec2(4.,1.))//a long chord        (3 notes long)\n ;a=mig(u,a,b)  //union of 2 notes (repeat to define a song) \n //you likely want to do floor() instead, and deal with c0Continuity mantually.\n     \n ;float key=floor(u.y+floor(ViewZoom))//note keyID\n ;u.y=fract(u.y) //optional lattice.y to show more than 1 waveform\n\n ;key=noteMIDI(key+69.-24.)//midi key 69 mapos to C3 440hZ , thre is some screenspace offset.\n ;float phase=a.x\n ;c.x=sin(pi*2.*key*u.x)\n     //55*8=440 hz for a C3-frequency\n     //n2f() uses a *55. scale\n     //all this is a compromise between making a waveform visible and audible.\n ;//frequency=key//should be audible\n    \n\n ;u.y=u.y*2.-1.//optional, show negative space of waveform\n ;if(a.x>-noteInf\n ){\n  ;vec2 am=vec2(0)\n  ;am.x=sat(1.-u.x+a.x)\n  ;am.y=sat(1.+u.x+a.y)\n  ;am=smoothstep(vec2(-1),vec2(0),am-1.)-1. //lerp  hermite3 (optional)\n  ;c.w=max(am.x,am.y)                       //clamp linear \n  ;//c.w=smoothstep(0.,1.,c.w)\n  ;c.x=sin(pi*2.*key*u.x)*c.w\n  ;c.y=cos((u.x-phase)*key/55.*2.)*c.w//visible waveform (scaled down) \n  ;//c.x=(c.x*.9+u.y) //no, do not mess with c.x, it needs ti be pure for the audio rendering!\n\n  ;c.y=c.y*.9+u.y\n  ;c.w=c.w*.9+u.y\n  ;c.w=abs(c.w)-.01\n  ;//c.x=abs(c.x)-.05 //no, do not mess with c.x, it needs ti be pure for the audio rendering!\n  ;c.y=abs(c.y)-.05\n ;}else c.xy=vec2(0,1)     \n ;c.z=a.z-.03\n ;c.yzw=smoothstep(.1,-.1,c.yzw)\n ;c.yzw=sat(c.yzw)\n ;c.y+=sat(c.w)\n ;return c;}\n\nve3 entryImage(ve0 t,ve1 u,ve2 r,ve3 m\n){\n ;//t=0.//override time for vis\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.){\n  ;m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{//iMouse is cos(hash41Aperiodic())\n   ;m=sqrt(vec4(5,11,3,13))-vec4(21,2,1,17) //QuadraticField: see: https://www.shadertoy.com/view/Xt3BDB\n   ;m=sin(m*t*.04)//time as seed for hash m.\n   ;//m=fract(m*4500.)//optional obfuscation\n   ;m.yw=m.yw*.5+.5//mirror symmetry on y=0\n   ;m.yw=m.yw*.3+.3//minimum key width\n   ;m*=ViewZoom*.4//view scale\n ;}\n ;vec4 c=starGuitar(t,u,r,m)\n ;c.x-=fract(u.y)*2.-1.\n ;c.x=abs(c.x)\n ;c.x=smoothstep(.1,-.1,c.x)*.5\n ;//c.x=0.//c.x is the audible scaling of c.y, ou likely only want to see c.y\n ;c.x+=sat(c.w)\n ;c.w=1.\n ;return c\n ;}\n\n\nfloat instrumentKey(float t//instrument only has some keys (imagine piano with missing keys)\n){//this equals a NoteKey+Instrument setup, usually a usefull simplification.\n ;//its easier to defien chords as closed interval, for instruments with missing keys.\n  //though this is a lazy approach that only works for silly simple melodies.\n  //that have null key changes.\n ;vec4 c=vec4(0);\n ;float r=0.;\n ;float key=1.;c=starGuitar(t,vec2(t,key),vec3(0),vec4(1));r+=c.x \n ;      key=3.;c=starGuitar(t,vec2(t,key),vec3(0),vec4(1));r+=c.x\n ;      key=5.;c=starGuitar(t,vec2(t,key),vec3(0),vec4(1));r+=c.x\n ;r/=3.\n ;return r;\n ;}\n\n\nve1 entrySound(ve0 t,ve1 u,ve2 r,ve3 m\n){\n ;float key=4.\n ;vec4 c=starGuitar(t,vec2(t,key),r,vec4(1))\n ;//return vec2( sin(6.2831*440.0*t)*exp(-3.0*t) )\n ;return vec2(instrumentKey(t))\n ;return vec2( c.x)\n ;return vec2( sin(pi*2.*noteMIDI(69.)*t))\n ;}\n    ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound( in int samp, float time\n){\n ;return entrySound(time,vec2(0),vec3(0),vec4(0))\n ;return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );   \n ;}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}