{
    "Shader": {
        "info": {
            "date": "1442189575",
            "description": "Another arrangement",
            "flags": 0,
            "hasliked": 0,
            "id": "MljSRD",
            "likes": 99,
            "name": "Ray Marching Experiment nÂ°33bis",
            "published": 3,
            "tags": [
                "ray",
                "experiment",
                "marching",
                "33",
                "bis"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 6859
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\nSpace Body \nmy goal was to introduce some sub-surface scattering with hot color but the result is not as expected\nnormaly less thikness is more cold than big thickness. here this is the inverse ^^ its not wanted\n*/\n\n#define BLOB\n\n#define shape(p) length(p)-2.8\n\nfloat dstepf = 0.0;\nfloat df0, df1;\n    \n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n#ifdef BLOB\n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n#else\n    return max(v.x, v.y); // Maximum, or regular value for the regular Voronoi aesthetic.  Range [0, 1].\n#endif\n}\n\n///////////////////////////////////\n\nvoid commonMap(vec3 p, out float df0, out float df1)\n{\n\tfloat voro = Voronesque(p);\n \tfloat sp = shape(p);\n    float spo = sp - voro;\n    float spi = sp + voro * .5;\n\tfloat e = sin(iTime*.5)*.4 +.35;\n    df0 = max(-spi, spo + e);\n    df1 = sp + 1.;\n}\n\nfloat map(vec3 p)\n{\n    dstepf += 0.002;\n    commonMap(p, df0, df1);          \n\treturn min(df0, df1);\n}\n\nfloat mat(vec3 p)\n{\n    commonMap(p, df0, df1);      \n\tif (df0 < df1) \n\t\treturn 0.0;\n    return 1.0;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy) - map(pos-e.xyy),\n    map(pos+e.yxy) - map(pos-e.yxy),\n    map(pos+e.yyx) - map(pos-e.yyx) );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 561e5 * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 352e5 * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n        \nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f = vec4(0,0,0,1);\n    \n    vec2 si = iResolution.xy;\n\tfloat t = iTime;\n    \n    float ca = t*.2; // angle z\n    float ce = 2.; // elevation\n    float cd = 4.; // distance to origin axis\n   \t\n    vec3 cu=vec3(0,1,0);//Change camere up vector here\n    vec3 cv=vec3(0,0,0); //Change camere view here\n    vec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); //\n    vec3 rd = cam(uv, ro, cu, cv);\n\n    float md = 12.0;\n\n    float d = 0.0;\n\tfloat s = 1.0;\n    for(int i=0;i<200;++i)\n    {      \n\t\tif(d*d/abs(s) > 1e6 || d>md) break;\n        s = map(ro+rd*d);\n\t\td += s * 0.25;\n   \t}\n\n\tif (d<md)\n    {\n        vec3 p = ro + rd * d;\n\t\tvec3 n = nor(p, .01);\n        float m = mat(p);\n\t\tif ( m < 0.5) // icy color\n        {\n\t\t\trd = reflect(rd, n);\n\t\t\tp += rd * d;\t\t\n\t\t\td += map(p) * .001;\n\t\t\tf.rgb = exp(-d / vec3(.2,.4,.58) / 15.);\n\t\t}\n\t\telse if( m < 1.5) // kernel\n\t\t{\n\t\t\tfloat b = dot(n,normalize(ro-p))*0.9;\n            f = (b*vec4(blackbody(2000.),0.9)+pow(b,0.2))*(1.0-d*.01);\n\t\t}\t\n   \t}\n    \n    f = mix( f, vec4(0,.02,.15, 1.), 1.0 - exp( -d*dstepf) ); \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}