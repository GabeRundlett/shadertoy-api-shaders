{
    "Shader": {
        "info": {
            "date": "1665968137",
            "description": "My very own FP32 benchmark, it gave me results (~706.5 GFLOPS) near what my manufacturer provided (1075.2-1126.4 GFLOPS) but please read the disclaimer. Not all FLOPS are created equal...",
            "flags": 0,
            "hasliked": 0,
            "id": "msX3Dr",
            "likes": 1,
            "name": "FLOPS Benchmark Thingy",
            "published": 3,
            "tags": [
                "bench",
                "point",
                "float",
                "core",
                "benchmark",
                "floating",
                "gpu",
                "flop",
                "hardware",
                "mark",
                "flops",
                "fp32"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "// FLOPS formula: 1 / (t / (n * x * y))\n// where `t` is the frametime in seconds (Can be measured with the Shadertoy Unofficial Plugin,\n// otherwise you can use 1 / [frames per second]), `n` is the FLOP's per pixel (~347 in this case,\n// see more info below), `x` is the resolution in the x-axis, and `y` is the resolution in the y-axis.\n//\n// NOTE #1: This is NOT a good benchmark. It's just my interperitation of a FLOP, which varies depending\n// on things like cycles per instruction per GPU. E.g. addition and square root take a different number of\n// cycles to execute (depending on the GPU and architecture) but I still consider each to be 1 FLOP, so\n// depending on the distribution of each operation you perform, you will get a different FLOPS measurement.\n// I think the FLOPS measurements that manufacturers and other benchmarks produce are based on a somewhat\n// equal distribution of each operation a GPU can perform, so they aren't as high as what this shader yields.\n// Still, it's kinda cool.\n//\n// NOTE #2: the precision loss (or even cap) of the framerate counter and overhead of rendering a new frame\n// can skew results so I recommend using the Shadertoy Unofficial Plugin and Shadertoy Frame Exporter browser\n// extensions, the Unofficial Plugin to display a frametime counter (in milliseconds) and the Frame Exporter\n// to set the resolution to something like 1024x1024 or more depending on your GPU. You can press the preview\n// button (a part of the frame exporter and then set the resolution and press [Alt]-[1] to lock the resolution,\n// and then you can turn off the preview thing and it will still render at the resolution you entered and the\n// rest of the GUI won't be scaled funny. On High-DPI displays, zoom out 50% or whatever it takes to get\n// everything to be 100% resolution, as these plugins act funny.\n//\n// Example Result and Calculation:\n// With Intel Iris Plus Graphics (Intel Core i7-1065G7 integrated graphics) I get ~8.24 ms (0.00824 seconds)\n// per frame when rendering at 4096x4096. 1/(0.00824/(347*4096*4096)) = 706,516,256,311 which divided by\n// 1,000,000,000 is 706.516256311 GFLOPS.\n// \n// More info about my GPU:\n// https://en.wikipedia.org/wiki/Intel_Graphics_Technology#Ice_Lake\n// https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units#Gen9\n// 64 Execution Units, 512 Shading Units, FP16 2150.4-2252.8 GFLOPS, FP32 1075.2-1126.4 GFLOPS,\n// Device ID 8A52, Core Configuration 512:64:8 (GT2), Clock Rate min/max 300/1100 MHz, Mem Bandwidth 59.7 GB/s\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float     PI = 3.141592653589793; // Pi\nconst float TWO_PI = 6.283185307179586; // 2 * Pi = \"Tau\"\nconst float INV_PI = 0.318309886183791; // 1 / Pi\n//const float     PI = uintBitsToFloat(0x40490FDBu); // Pi\n//const float TWO_PI = uintBitsToFloat(0x40C90FDBu); // 2 * Pi = \"Tau\"\n//const float INV_PI = uintBitsToFloat(0x3EA2F983u); // 1 / Pi\n\n// Triangle Ray-Surface Intersection Function\n// https://iquilezles.org/articles/intersectors/\nvec3 triangleIntersect(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 v1v0 = v1 - v0; // ~3 FLOP (3x SUB)\n    vec3 v2v0 = v2 - v0; // ~3 FLOP (3x SUB)\n    vec3 rov0 = ro - v0; // ~3 FLOP (3x SUB)\n\n    vec3 n = cross(v1v0, v2v0); // ~9 FLOP (6x MUL, 3x SUB)\n    vec3 q = cross(rov0, rd  ); // ~9 FLOP (6x MUL, 3x SUB)\n\n    float d = 1.0 / dot(rd, n); // ~6 FLOP (3x MUL, 2x ADD, 1x DIV)\n\n    float u = d * dot(-q, v2v0); // ~7 FLOP (1x NEG, 3x MUL, 2x ADD, 1x MUL)\n    float v = d * dot( q, v1v0); // ~6 FLOP (3x MUL, 2x ADD, 1x MUL)\n    float t = d * dot(-n, rov0); // ~7 FLOP (1x NEG, 3x MUL, 2x ADD, 1x MUL)\n\n    t = (u < 0.0 || v < 0.0 || (u + v) > 1.0) ? -1.0 : t; // no intersection, ~9 FLOP (2x LESS, 1x ADD, 1x GREAT, 2x MAX, 1x SUB, 2x MUL)\n\n    return vec3(t, u, v); // Total: ~62? FLOP (16x SUB, 29x MUL, 1x DIV, 7x ADD, 2x NEG, 2x LESS, 1x GREAT, 2x MAX)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // MSAA Sampling Pattern\n    const vec2 s0 = vec2(-0.375, -0.125);\n    const vec2 s1 = vec2( 0.125, -0.375);\n    const vec2 s2 = vec2(-0.125,  0.375);\n    const vec2 s3 = vec2( 0.375,  0.125);\n\n    // Triangle Vertex Positions\n    const vec3 v0 = vec3( 1.000, -1.000, -1.000);\n    const vec3 v1 = vec3(-1.000,  1.000, -1.000);\n    const vec3 v2 = vec3(-1.000, -1.000,  1.000);\n\n    vec2 hres = 0.5 * iResolution.xy; // ~2 FLOP (2x ADD)\n\n    float ires = 1.0 / max(hres.x, hres.y); // ~2 FLOP (1x MAX, 1x DIV)\n\n    vec2 uv0 = fragCoord.xy + s0; // ~2 FLOP (2x ADD)\n    vec2 uv1 = fragCoord.xy + s1; // ~2 FLOP (2x ADD)\n    vec2 uv2 = fragCoord.xy + s2; // ~2 FLOP (2x ADD)\n    vec2 uv3 = fragCoord.xy + s3; // ~2 FLOP (2x ADD)\n\n    uv0 = ires * (uv0 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n    uv1 = ires * (uv1 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n    uv2 = ires * (uv2 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n    uv3 = ires * (uv3 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n\n    float theta = TWO_PI * fract(0.5 * iTime); // ~3 FLOP (1x MUL, 1x MOD, 1x MUL)\n\n    float cos_theta = cos(theta), sin_theta = sin(theta); // ~2 FLOP (1x COS, 1x SIN)\n\n    vec3 ro = vec3(sin_theta, cos_theta, 5.0);\n\n    vec3 rd0 = normalize(vec3(uv0, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n    vec3 rd1 = normalize(vec3(uv1, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n    vec3 rd2 = normalize(vec3(uv2, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n    vec3 rd3 = normalize(vec3(uv3, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n\n    vec3 t0 = triangleIntersect(ro, rd0, v0, v1, v2); // ~62 FLOP\n    vec3 t1 = triangleIntersect(ro, rd1, v0, v1, v2); // ~62 FLOP\n    vec3 t2 = triangleIntersect(ro, rd2, v0, v1, v2); // ~62 FLOP\n    vec3 t3 = triangleIntersect(ro, rd3, v0, v1, v2); // ~62 FLOP\n\n    fragColor.xy = vec2(0);\n\n    fragColor.xy += t0.x >= 0.0 ? t0.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n    fragColor.xy += t1.x >= 0.0 ? t1.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n    fragColor.xy += t2.x >= 0.0 ? t2.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n    fragColor.xy += t3.x >= 0.0 ? t3.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n\n    fragColor.xy *= 0.25; // ~2 FLOP (2x MUL)\n\n    fragColor = vec4(fragColor.xy, 0.0, 1.0); // Total: 347 FLOP per pixel\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}