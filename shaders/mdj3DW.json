{
    "Shader": {
        "info": {
            "date": "1667634714",
            "description": "My result at the end. This version differs from the original, had to remove some parts (apparently I did too much backbuffer fuckery)",
            "flags": 32,
            "hasliked": 0,
            "id": "mdj3DW",
            "likes": 21,
            "name": "Inercia Shader Royale 2022",
            "published": 3,
            "tags": [
                "glitch",
                "livecoding"
            ],
            "usePreview": 0,
            "username": "kostik1337",
            "viewed": 353
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define time iTime\nconst float BPM = 120.;\n#define beat (time*BPM/60.)\n\nvec3 ct(vec3 p) {\n  if(p.x<p.y) p.xy=p.yx;\n  if(p.y<p.z) p.yz=p.zy;\n  if(p.x<p.y) p.xy=p.yx;\n  return p;\n}\n\n#define mr(t) (mat2(cos(t), sin(t), -sin(t), cos(t)))\n#define quant(p,x) (floor(p/x)*x)\n#define rep(p,s) (mod(p,(s))-(s)/2.)\n#define rep2(p,s) (abs(rep(p,(2.*s)))-(s)/2.)\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define INF (1e10)\n\nfloat hash(float x) {return fract(sin(x*325.88913));}\n\nvec4 back(vec2 uv) {return texture(iChannel0, uv);}\nfloat ffti(float t) {return iTime * (1./(t+1.));}\n\nvec3 glow = vec3(0.);\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec3 calcglow(float m) {\n  return .003*vec3(1.,1.2,1.4) / abs(m-.05*vec3(1.3, 1.2, .9));\n}\n\nfloat mycube(vec3 p) {\n  vec3 p2 = p;\n  float m = INF;\n  vec3 s = vec3(.2 + .02*smoothstep(.6, 1., fract(beat)));\n  float gi = floor(4.*fract(beat));\n  for(float i=0.;i<4.;++i) {\n    s.xz *= mr(2.31*floor(beat));\n    s.yz *= mr(1.19*floor(beat));\n    s = abs(s)/1.5;\n    if(i==2.) p.xz *= mr(PI/4.);\n    p = abs(p)-s;\n    p=ct(p);\n    vec3 p1 = p;\n    float qf = fract(beat + hash(dot(vec3(.12,.34,.32),quant(p2, .1))));\n    p1 = quant(p1, mix(.001, .05, qf));\n    float mm = length(p1.xy)-s.x/64.;\n    m = min(m, mm);\n    if (i==gi) glow += calcglow(mm);\n  }\n  return m;\n}\n\nfloat map(vec3 op) {\n  vec3 p=op;\n  p.xy *= mr(time);\n  p.xz *= mr(floor(beat) + smoothstep(0., .5, fract(beat)));\n  p.yz *= mr(1.12* (floor(beat) + smoothstep(0., .5, fract(beat))));\n  p.xz *= mr(ffti(.13)*4.);\n  float m;\n  float h = hash(floor(beat));\n  if(h < .1) {\n    p = abs(p);\n    m = dot(p, normalize(vec3(1.)))-.3;\n    glow += calcglow(m);\n  } else if(h < .2) {\n    m = box(p, vec3(.3));\n    glow += calcglow(m);\n  } else if(h < .3) {\n    p = abs(p)-.2;\n    p = abs(p)-.1;\n    m = length(p)-.05;\n    glow += calcglow(m);\n  } else if(h < .4) {\n    p = ct(abs(p));\n    m = box(p, vec3(.01, .01, .5).zxy);\n    glow += calcglow(m);\n  } else {\n    m = mycube(p);\n  }\n  vec3 s;\n  \n  p = op;\n  p.z += 8.*ffti(.2);\n  s = vec3(12.2);\n  float maxx = -box(op, vec3(2.,1., INF));\n  for(float i = 0.;i<4.;++i) {\n    float t = i==1.? .01*(floor(beat) + smoothstep(0., .3, beat)) : 0.;\n    s.xy *= mr(.12+t);\n    s.yz *= mr(.23+t);\n    s = abs(s)/2.;\n    p = rep2(p, s);\n    p = ct(p);\n    vec3 pp = p;\n    pp = quant(pp, mix(.001, .05, fract(beat+.5)));\n    float mm = length(pp.yz)-s.x/128.;\n    mm = max(mm, maxx);\n    m = min(m, mm/1.3);\n    glow += .0005 * (sin(4.*op.z-1.3*time)*.5+.5) / abs(mm-.01*vec3(1.,1.4,1.2));\n  }\n  \n  return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 c = vec3(0.);\n  vec3 O = vec3(0., 0., -2.), D = vec3(uv, 1.);\n  \n  mat2 m = mr(.1*sin(time) + .07*sin(1.1*time));\n  O.xz *= m;\n  D.xz *= m;\n  m = mr(.08*sin(1.2*time) + .06*sin(1.3*time));\n  O.xz *= m;\n  D.xz *= m;\n  O.z -= .5+.5*sin(PI/16.*beat);\n  \n  D.xy *= mr(PI/4.*smoothstep(.0, .1, fract(beat/4.)));\n  \n  float d = 0.;\n  float hit = 0.;\n  for(float i=0.;i<64.;++i) {\n    vec3 p=O+D*d;\n    float m = map(p);\n    d += m;\n    if(m < .01*d) {\n      c += (1.-i/64.)*.1 * exp(-d*.5);\n      float thresh = mix(10., 64., fract(beat/4.));\n      hit = i > thresh ? 1. : 0.;\n      break;\n    }\n  }\n  glow *= exp(-d*.2);\n  c += glow;\n  \n  uv = fragCoord/iResolution.xy;\n  float gg = 1.;\n  if (fract(beat) < .05) {\n    uv = quant(uv, .05);\n    gg = 1.2;\n  }\n  vec4 prev = back(uv);\n  vec2 e = vec2(.01, .0);\n  e *= 8. * smoothstep(.9, 1., fract(beat/4.));\n  e *= mr(floor(beat));\n  e *= hash(quant(uv.y, .05))-.5;\n  prev = vec4(\n    back(uv-e).r,\n    back(uv).g,\n    back(uv+e).b,\n    prev.a\n  )*gg;\n  prev = clamp(vec4(0.),vec4(1.), prev);\n  float mf = mix(.6, .8, prev.a);\n  \n  c = mix(c, prev.rgb, mf);\n  c *= 1.-hit;\n\n\tfragColor = vec4(c, glow);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}