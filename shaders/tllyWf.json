{
    "Shader": {
        "info": {
            "date": "1593333776",
            "description": "License CC0: Once upon time... in space\nWhen I grew up I loved the french kid show \"Once upon time... space\". The show had a big influence on me and 30+ years I wanted to make a homage to it. Song: https://www.youtube.com/watch?v=9IsGy0LvV9M\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tllyWf",
            "likes": 22,
            "name": "Once upon time... space",
            "published": 3,
            "tags": [
                "raymarching",
                "scifi"
            ],
            "usePreview": 1,
            "username": "mrange",
            "viewed": 616
        },
        "renderpass": [
            {
                "code": "// License CC0: Once upon time... space\n//  When I grew up I loved the french kid show \"Once upon time... space\". \n//  The show had a big influence on me and 30+ years I wanted to make a homage to it. \n//  Song: https://www.youtube.com/watch?v=9IsGy0LvV9M\n\n//  Shader takes a long time to load, sorry!\n//  Code \"borrowed\" from the usual suspects\n\n// ------------------------------==> COMMON <==--------------------------------\n\nstruct Effect {\n  int      major  ;\n  int      minor  ;\n  float    seq    ;\n  bool     fade   ;\n  float    input0 ;\n  float    input1 ;\n};\n\n#define PI         3.141592654\n#define TAU        (2.0*PI)\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\n#define DURATION1  6.85\n#define DURATION   5.13\n#define DURATIONT  172.0\n\n#define FADEIN     1.0\n#define FADEOUT    2.0\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define SCA(a)      vec2(sin(a), cos(a))\n\n// Uncomment to speed up experimentation\n//#define EXPERIMENTING\n\n#define MINOR_NONE          0\n\n#define MAJOR_NOEFFECT      0\n\n#define MAJOR_IMPULSE       1\n#define MINOR_INTRO         0\n#define MINOR_OUTRO         1\n\n#define MAJOR_ORRERY        2\n#define MINOR_SUNRISE       0\n#define MINOR_CLOSEUP       1\n#define MINOR_APPROACH      2\n#define MINOR_ESCAPE        3\n\n#define MAJOR_WATERWORLD    3\n\n#define MAJOR_BARRENMOON    4\n\n#define MAJOR_GALAXY        5\n\n#define MAJOR_SPACESHIP     6\n#define MINOR_FROM_BEHIND   0\n#define MINOR_CYLINDER_SEA  1\n#define MINOR_FROM_FRONT    2\n\n//#define EXPERIMENTING\n\n#ifdef EXPERIMENTING\n#define ENABLE_IMPULSE\n\nconst Effect effects[] = Effect[](\n    Effect(MAJOR_IMPULSE     , MINOR_INTRO          , 0.0, false , 0.0       , 0.0) // This is special in that it's 7 seconds long, all other about ~5.1 long\n  );\n\n#else\n#define ENABLE_NOEFFECT\n#define ENABLE_IMPULSE\n#define ENABLE_ORRERY\n#define ENABLE_BARRENMOON\n#define ENABLE_WATERWORLD\n#define ENABLE_GALAXY\n#define ENABLE_SPACESHIP\n\nconst Effect effects[] = Effect[](\n    Effect(MAJOR_IMPULSE     , MINOR_NONE           , 0.0, false , 0.0       , 0.0) // This is special in that it's 7 seconds long, all other about ~5.1 long\n  , Effect(MAJOR_ORRERY      , MINOR_SUNRISE        , 0.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_SUNRISE        , 1.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_CLOSEUP        , 0.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_CLOSEUP        , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 0.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 1.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 2.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 0.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 1.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 2.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_ORRERY      , MINOR_APPROACH       , 0.0, true  , -1.1      , 1.0)\n  , Effect(MAJOR_ORRERY      , MINOR_APPROACH       , 1.0, true  , -1.1      , 1.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 0.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 1.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 2.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 3.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 0.0, true  , 0.0       , 0.0) // 20\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 2.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 3.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 0.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 1.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 2.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 0.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 1.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 2.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 0.0, true  , 0.4       , 0.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 1.0, true  , 0.4       , 0.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 0.0, true  , 2.0       , 2.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 1.0, true  , 2.0       , 2.5)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 0.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 2.0, true  , 0.0       , 0.0)\n  );\n#endif\n\n// From planet surface\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = skyCol1*skyCol1*skyCol1*3.0;\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.9,0.8);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.8);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  planetCol     = sqrt(vec3(0.9, 0.8, 0.7));\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst vec3  mountainColor = sqrt(vec3(0.95, 0.65, 0.45));\n\n// From space\nconst vec3  sunDirection         = normalize(vec3(0.0, 0.5, -10.0));\nconst vec3  sunColor1            = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2            = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection    = normalize(vec3(-2.0, -3.5, -10.0));\nconst vec3  smallSunColor1       = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2       = vec3(1.0, 0.3, 0.6);\n\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n\n  float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n  float q = -abs(pos.x)/(4.0*k*k);\n\n  float h = q*q + p*p*p;\n  float r = sqrt(abs(h));\n\n  float x = (h>0.0) ? pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) : 2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// Not an exact distance field\nfloat softBox(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat capsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n  return length(p.xy-c.xy)-c.z;\n}\n\n\nfloat l2(vec2 p) {\n  return dot(p, p);\n}\n\nfloat l2(vec3 p) {\n  return dot(p, p);\n}\nfloat spow(float v, float p) {\n  return sign(v)*pow(abs(v), p);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat smoother(float f, float r) {\n  return tanh(f/r)*r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 cylinderCoord(vec3 p) {\n  return vec2(p.z, atan(p.x, -p.y));\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat roundIntersection(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\nfloat chamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat roundDiff (float a, float b, float r) {  return roundIntersection(a, -b, r);\n}\nfloat pcos(float f) {\n  return 0.5 + 0.5*cos(f);\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec4 cyl) {\n  vec3  oc = ro - cb;\n  float card = dot(cyl.xyz ,rd);\n  float caoc = dot(cyl.xyz, oc);\n  float a = 1.0 - card*card;\n  float b = dot(oc, rd) - caoc*card;\n  float c = dot(oc, oc) - caoc*caoc - cyl.w*cyl.w;\n  float h = b*b - a*c;\n  if (h<0.0) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n\n  if (h<0.0) return vec2(-1.0);\n  h = sqrt(h);\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  return mix(vec2(-1.0), vec2(t1, t2),step(0.0, t2));\n}\n\n\nvec3 raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n\n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if (h<0.0) return vec3(-1.0, -1.0, 0.0);\n  h = sqrt(h);\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if (t2<0.0 || t1>ndbuffer) return vec3(-1.0, -1.0, 0.0);\n  t1 = max(t1, 0.0);\n  t2 = min(t2, ndbuffer);\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return vec3(sph.w*t1, sph.w*t2, (i2-i1)*(3.0/4.0));\n}\n\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n\n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif\n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n\n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nvec4 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash2(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nconst vec2 sca0 = SCA(0.0);\n\nfloat letteri(vec2 p) {\n  p.y -= 0.25;\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letterm(vec2 p) {\n  p.y = -p.y;\n  float l = horseshoe(p - vec2(+0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  float r = horseshoe(p - vec2(-0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  return min(l, r);\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  rot(p, -PI/6.0);\n  rot(p, -PI/2.0);\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  rot(p, PI);\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat impulse(vec2 p) {\n  p.x += 0.6;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float di = letteri(p - vec2(oi, 0.0));\n  float dm = letterm(p - vec2(om, 0.0));\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n  float dx = abs(p.y) - oo;\n  dx = abs(dx) - oo*0.5;\n  float d = 1000000.0;\n  d = min(d, di);\n  d = min(d, dm);\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = max(d, -dx);\n\n  return d;\n}\n\nfloat star(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n\n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n\n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n\n  vec3 final = vec3(0.0);\n\n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n\n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n//  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n// ------------------------------==> COMMON <==--------------------------------\n\n// -----------------------------==> NOEFFECT <==-------------------------------\n\n#ifdef ENABLE_NOEFFECT\n\nvec3 noeffect_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  return vec3(0.0, 0.5, 0.0);\n}\n\n#endif\n\n// -----------------------------==> NOEFFECT <==-------------------------------\n\n// -----------------------------==> IMPULSE <==--------------------------------\n\n#ifdef ENABLE_IMPULSE\n\nfloat impulse_planet(vec2 p) {\n  p.y = abs(p.y);\n  float dc1 = circle(p, 2.0);\n  float dc2 = circle(p+vec2(0.0, 0.035), 2.0);\n  float dc = max(dc1, -dc2)+0.0025;\n  return dc;\n}\n\nfloat impulse_moon(vec2 p) {\n  float dc5 = circle(p-vec2(-3.6, 1.45), 0.25);\n  float dc6 = circle(p-vec2(-3.6, 1.45)+0.025*vec2(-1.0, 1.0), 0.25);\n  float dc0 = max(dc5, -dc6);\n  return dc0;\n}\n\n\nfloat impulse_stars(vec2 p, float ltime) {\n  const float count = 27.0;\n  const float radius = 5.0;\n  vec2 pp = toPolar(p);\n  pp.y += ltime*TAU/(count*2.0);\n  float n = mod1(pp.y, TAU/count);\n  p = toRect(pp);\n  p -= vec2(radius, 0.0);\n  float ds = (star(p, 0.35, 0.35));\n  return ds;\n}\n\nfloat impulse_df(vec2 p, float s, float ltime, bool stars) {\n  p /= s;\n\n  float di = impulse(p);\n  di = min(abs(di-0.0275) - 0.0155*pow(s, -0.25), di);\n  float dp = impulse_planet(p);\n  float dm = impulse_moon(p);\n  float ds = impulse_stars(p, ltime);\n  float d = di;\n  d = min(d, dp);\n  d = min(d, dm);\n  if (stars) d = min(d, ds);\n  return d*s;\n}\n\nfloat impulse_fbm(vec2 p) {\n  vec2 op = p;\n  const float aa   = 0.3;\n  const float ff   = 2.03;\n  const float tt   = PI/2.5;\n  const float oo   = 1.93;\n\n  float a = 1.0;\n  float o = 0.4;\n  float s = 0.0;\n  float d = 0.0;\n\n  p*=0.55;\n  for (int i; i < 3;++i) {\n    float nn = a*vnoise(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  return 0.65*(s/d);\n}\n\nfloat impulse_warp(vec2 p, float ltime, out vec2 v, out vec2 w) {\n  rot(p, -1.0);\n  p.x += 0.75;\n\n  vec2 o1 = vec2(1.0)*0.125;\n  vec2 o2 = vec2(-1.0)*0.125;\n  vec2 o3 = vec2(1.0)*0.125;\n  vec2 o4 = vec2(-1.0)*0.125;\n  rot(o1, ltime*sqrt(0.5));\n  rot(o2, ltime*sqrt(0.45));\n  rot(o3, -ltime*sqrt(0.35));\n  rot(o4, -ltime);\n  vec2 vv = vec2(impulse_fbm(p + o1), impulse_fbm(p + o2));\n  vv *= -5.0;\n  vec2 ww = vec2(impulse_fbm(p + vv + o2), impulse_fbm(p + vv + o3));\n  ww *= -5.0;\n  v = vv;\n  w = ww;\n  return impulse_fbm(p + ww + o4);\n}\n\nfloat impulse_height(vec2 p, float ltime) {\n  vec2 v;\n  vec2 w;\n  return impulse_warp(p, ltime, v, w);\n}\n\nvec3 impulse_normal(vec2 p, float ltime) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n\n  vec3 n;\n  n.x = impulse_height(p + e.xy, ltime) - impulse_height(p - e.xy, ltime);\n  n.y = 2.0*e.x;\n  n.z = impulse_height(p + e.yx, ltime) - impulse_height(p - e.yx, ltime);\n\n  return normalize(n);\n}\n\nvec3 impulse_intro(float ltime, vec2 p, vec2 q) {\n  // Hard coded to 7 fadein and fadeout\n  float pixel = 5.0/RESOLUTION.y;\n  float s = 30.0/(10.0 + ltime*(100.0/DURATION1));\n  float d = impulse_df(p, s, ltime, true);\n  vec2 op = p;\n  vec3 col = vec3(0.0);\n  p *= 0.5;\n  p -= 0.2;\n\n  vec2 v;\n  vec2 w;\n\n  float h = impulse_warp(p, ltime, v, w);\n  vec3 n = impulse_normal(p, ltime);\n  vec3 lp1 = vec3(-4.0, -2.0, 3.0);\n  vec3 ld1 = normalize(vec3(p.x, h, p.y) - lp1);\n  float dif1 = max(dot(n, ld1), 0.0);\n\n  float vv = 0.8;\n\n  vec3 col1 = hsv2rgb(vec3(0.95*v.yx, vv));\n  vec3 col2 = hsv2rgb(vec3(-0.65*w, vv));\n\n  col = (col1 + col2)*pow(dif1, 2.25);\n\n  col = mix(col, vec3(1.0), smoothstep(0.0, pixel, -d));\n\n  col = postProcess(col, q);\n\n  float fadeIn  = smoothstep(0.0, 2.0, ltime);\n  float fadeOut = smoothstep(DURATION1 - 4.0, DURATION1, ltime);\n\n  col = col + (1.0 - fadeIn);\n  col = mix(col, vec3(0.0), fadeOut*fadeOut);\n\n  return col;\n}\n\nvec3 impulse_outro(float ltime, vec2 p, vec2 q) {\n  float pixel = 5.0/RESOLUTION.y;\n  float s = 10.0/(10.0 + 0.5*ltime*(3.0/DURATION));\n  s *= 0.2;\n  float d = impulse_df(p, s, ltime, false);\n\n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(1.0), smoothstep(0.0, pixel, -d));\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvec3 impulse_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 col = vec3(0.5);\n  switch(minor) {\n  case MINOR_INTRO:\n    col = impulse_intro(ltime, p, q);\n    break;\n  case MINOR_OUTRO:\n    col = impulse_outro(ltime, p, q);\n    break;\n  }\n  return col;\n}\n\n#endif\n\n// -----------------------------==> IMPULSE <==--------------------------------\n\n// ------------------------------==> ORRERY <==--------------------------------\n\n#ifdef ENABLE_ORRERY\n\nconst vec3  orrery_moonColor            = vec3(0.6, 0.5, 0.4);\nconst float orrery_farAway              = 1E6;\nconst vec4  orrery_vgasGiant            = vec4(0.0, 0.0, 0.0, 10);\nconst vec4  orrery_vmoon                = vec4(-19.0, 0.7, 0.0, 0.5);\n\nvec3 orrery_skyColor(vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2*1.0;\n\n  col += pow(smallDiff, 10000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 1000.0)*smallSunColor2*0.25;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.25;\n\n  return col;\n}\n\nvec4 orrery_moon(float input0) {\n  vec3 p = orrery_vmoon.xyz;\n  rot(p.xz, input0);\n  p.y *= pcos(input0);\n  return vec4(p, orrery_vmoon.w);\n}\n\nvec4 orrery_rings(float input0, vec3 ro, vec3 rd, inout float pd) {\n  float rsd = (0.0 - ro.y)/rd.y;\n  vec3 p = ro + rd*rsd;\n\n  vec3 pn = vec3(0.0, 1.0, 0.0);\n  vec3 pr = reflect(rd, pn);\n  vec3 pref = orrery_skyColor(pr);\n  float pfres = pow(1.0-abs(dot(rd, pn)), 10.0);\n  float pl = length(p);\n  float pdf = pl-22.0;\n  pdf = abs(pdf) - 3.2;\n  pdf = abs(pdf) - 2.1;\n  pdf = abs(pdf) - 1.0;\n  vec4 pcol = vec4(1.0);\n  pcol.xyz = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 1.0, 1.0), 0.5 - 0.5*cos(15.0*pl))*sunColor1;\n  pcol.xyz = pow(pcol.xyz, vec3(0.75));\n  pcol.w = psin(20.0*pl)*psin(14.0*pl)*psin(21.0*pl);\n  pcol.w *= 0.5*step(pdf, 0.0);\n  pcol.xyz += pfres*pref;\n\n  vec3 rsn = vec3(0.0, 1.0, 0.0);\n\n  pcol.w = pow(pcol.w, 1.0*pow(abs(dot(rd, rsn)), 0.4));\n\n  vec2 psi1 = raySphere(p, sunDirection, orrery_vgasGiant);\n  pcol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi1.y - psi1.x)/(2.0*orrery_vgasGiant.w)));\n\n  vec4 vm = orrery_moon(input0);\n  vec2 psi2 = raySphere(p, sunDirection, vm);\n  pcol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi2.y - psi2.x)/(2.0*vm.w)));\n\n  pd = mix(pd, rsd, pcol.w > 0.0);\n\n  return pcol;\n}\n\nvec4 orrery_gasGiant(float input0, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec3 srsd = raySphereDensity(ro, rd, orrery_vgasGiant, orrery_farAway);\n  vec2 si = srsd.xy;\n  float sdens = srsd.z;\n  vec3 sp = ro + rd*si.x;\n  vec3 smp = ro + rd*(si.x+si.y)*0.5;\n  float smd = length(smp)/orrery_vgasGiant.w;\n  vec3 sn = normalize(sp - orrery_vgasGiant.xyz);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = orrery_skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 15.0);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  float sf = (si.y - si.x)/(2.0*orrery_vgasGiant.w);\n  vec3 sbeer = exp(-90.0*sdens*vec3(0.30, 0.25, 0.22)*pow(smd, -3.0));\n  float srayl = pow(1.0 - abs(dot(rd, sn)), 5.0);\n\n  float slo = atan(sp.z, sp.x);\n  float slat = PI*sp.y/orrery_vgasGiant.w;\n  vec3 scol = vec3(0.8);\n\n  scol = mix(scol, vec3(0.7, 0.7, 0.8), pow(pcos(20.0*slat), 5.0));\n  scol = mix(scol, vec3(0.75, 0.7, 0.8), pow(pcos(14.0*slat), 20.0));\n  scol = mix(scol, vec3(0.2), pow(pcos(21.0*slat)*pcos(13.0*slat+1.0), 15.0));\n  scol = tanh(scol);\n  scol *= pow(sunColor1, vec3(0.66));\n  scol += vec3(0.0, 0.0, srayl*0.5) ;\n\n  vec4 vm = orrery_moon(input0);\n  vec2 mi = raySphere(sp, sunDirection, vm);\n\n  float msha = (1.0  - smoothstep(0.0, 1.0, (mi.y - mi.x)/(2.0*vm.w)));\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + pow(skyCol, vec3(0.85))*sbeer + scol*pow(sdiff, 0.75);\n    col.xyz *= msha;\n    col.w = 1.0;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec4 orrery_moon(float input0, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec4 vm = orrery_moon(input0);\n\n  vec2 si = raySphere(ro, rd, vm);\n  vec3 sp = ro + rd*si.x;\n  vec3 sn = normalize(sp - vm.xyz);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = orrery_skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 5.0);\n  float sf = (si.y - si.x)/(2.0*vm.w);\n\n  vec2 gi = raySphere(sp, sunDirection, orrery_vgasGiant);\n\n  float gsha = (1.0  - smoothstep(0.0, 1.0, (gi.y - gi.x)/(2.0*orrery_vgasGiant.w)));\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + orrery_moonColor*pow(sdiff, 0.75);\n    col.w = (1.0 - exp(-7.0*sf))*gsha;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec4 orrery_ship(float ltime, float input0, float input1, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  const vec3 normal = normalize(-vec3(-1.0, -1.0, -1.0));\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n  const vec3 xx = cross(up, normal);\n  const vec3 yy = cross(xx, normal);\n  const float exc = 0.1;\n\n  vec4 vm = orrery_moon(input0);\n\n  vec4 p = vec4(normal, -dot(normal, vm.xyz));\n  float d = rayPlane(ro, rd, p);\n  vec3 pp = ro + rd*d - vm.xyz;\n\n  vec2 p2 = vec2(dot(xx, pp), dot(yy, pp));\n  p2.y *= -1.0;\n  p2 += vec2(0.0, 2.0*vm.w);\n\n  const float posY = 0.15;\n  const float posX = sqrt(posY/exc);\n\n  float dp = parabola(p2, exc);\n  dp = abs(dp)-0.001;\n\n  float trailt = smoothstep(0.0125+p2.y*p2.y*0.01, 0.0, dp);\n\n  float fadeOut = (smoothstep(10.0, posY, p2.y));\n\n  trailt *= fadeOut*(step(posY, p2.y))*step(p2.x, 0.0);\n  trailt *= 1.5-1.0*smoothstep(0.0, 0.75, p2.y);\n\n  vec4 trailCol = vec4(hsv2rgb(vec3(0.99, 0.0, 1.0)-vec3(0.5, -1.0, 0.5)*(1.0-fadeOut)), trailt);\n\n  float sc = circle(p2-vec2(-posX, posY), 0.0);\n\n  vec4 shipCol = vec4(2.0*vec3(1.5, 1.0, 2.0), 1.0)*smoothstep(-7.0, 1.0, sin(ltime*4.0*TAU))*smoothstep(0.125, 0.0, sc);\n\n  vec4 col = mix(trailCol, shipCol, shipCol.w)*input1;\n\n  pd = mix(pd, d, col.w > 0.0);\n\n\n  return col;\n}\n\nvec3 orrery_render(float ltime, float input0, float input1, vec3 ro, vec3 rd) {\n  vec3 skyCol = orrery_skyColor(rd);\n\n  vec4 col = vec4(skyCol, 1.0);\n  float cold = orrery_farAway;\n\n  vec4 ggcol = orrery_gasGiant(input0, ro, rd, skyCol, cold);\n\n  col.xyz = mix(col.xyz, ggcol.xyz, ggcol.w);\n\n  float md = orrery_farAway;\n  vec4 mcol = orrery_moon(input0, ro, rd, skyCol, md);\n\n  col.xyz = mix(col.xyz, mcol.xyz, mcol.w*step(md, cold));\n  cold = mix(cold, md, step(md, cold));\n\n  float rsd = orrery_farAway;\n  vec3 rsp;\n  vec4 rscol = orrery_rings(input0, ro, rd, rsd);\n\n  col.xyz = mix(col.xyz, rscol.xyz, rscol.w*step(rsd, cold));\n  cold = mix(cold, rsd, step(rsd, cold));\n\n  float sd = orrery_farAway;\n  vec4 scol = orrery_ship(ltime, input0, input1, ro, rd, skyCol, sd);\n\n  col.xyz = mix(col.xyz, scol.xyz, scol.w*step(sd, cold));\n  cold = mix(cold, sd, step(sd, cold));\n\n  return col.xyz;\n}\n\nvec3 orrery_fragment(float ltime, float input0, float input1, vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  vec3 col = orrery_render(ltime, input0, input1, ro, rd);\n  return col;\n}\n\nvec3 orrery_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro = vec3(0.0, 0.0, 52.0);\n  vec3 la = vec3(0.0, 0.0,0.0);\n  vec3 up = vec3(-0.0, 1.0, 0.0);\n\n  switch(minor) {\n  case MINOR_SUNRISE:\n    ro.y += ltime*4.0/(2.0*DURATION)+3.0;\n    la = vec3(0.0, 0.0, -orrery_farAway);\n    break;\n  case MINOR_CLOSEUP:\n    ro = vec3(0.0, 0.0, -25.0);\n    rot(ro.yz, 1.0-0.1*ltime/(2.0*DURATION));\n    la = vec3(0.0, 0.0, 0.0);\n    up = vec3(-0.25, 1.0, 0.0);\n    break;\n  case MINOR_APPROACH:\n    ro = (0.75-ltime/(3.0*DURATION)*0.15)*vec3(-25.0, -20.0, -40.0);\n    la = orrery_moon(input0).xyz;\n    break;\n  case MINOR_ESCAPE:\n    ro = vec3(0.0, 5.0, 30.0);\n    la = vec3(0.0, 0.0, -orrery_farAway);\n    ro.x += -6.0*ltime/(3.0*DURATION);\n    ro.y += 12.0*ltime/(3.0*DURATION);\n    ro.z += 60.0*ltime/(3.0*DURATION);\n    up = vec3(-1.0, 1.0, 0.0);\n    break;\n  default:\n    break;\n  }\n\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n  col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o1);\n\n  col = clamp(col, 0.0, 1.0);\n\n  // Adaptive AA? Is that a good idea?\n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+0.01);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n\n  if (de > 0.1) {\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p-o1);\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o2);\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ------------------------------==> ORRERY <==--------------------------------\n\n// ----------------------------==> WATERWORLD <==------------------------------\n\n#ifdef ENABLE_WATERWORLD\n\n#define WATERWORLD_TOLERANCE       0.00001\n#define WATERWORLD_MAX_ITER        55\n#define WATERWORLD_MAX_DISTANCE    31.0\n\nfloat waterworld_heightMod(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += -pp.x*0.2;\n  p = toRect(pp);\n  return pow((psin(1.0*p.x)*psin(1.0*p.y)), max(0.25, pp.x*0.20))*0.8;\n}\n\nfloat waterworld_height(vec2 p, float dd, int mx) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n\n  float hm = waterworld_heightMod(p);\n\n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n\n  int i = 0;\n\n  p *= 2.0;\n\n  for (; i < mx;++i) {\n    float nn = a*(vnoise(p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n\n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat waterworld_loheight(vec2 p, float d) {\n  return waterworld_height(p, d, 3);\n}\n\nfloat waterworld_height(vec2 p, float d) {\n  return waterworld_height(p, d, 5);\n}\n\nfloat waterworld_hiheight(vec2 p, float d) {\n  return waterworld_height(p, d, 6);\n}\n\nvec3 waterworld_normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = (waterworld_hiheight(p - eps.xy, d) - waterworld_hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (waterworld_hiheight(p - eps.yx, d) - waterworld_hiheight(p + eps.yx, d));\n\n  return normalize(n);\n}\n\nfloat waterworld_march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < WATERWORLD_MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = waterworld_height(p.xz, d);\n\n    if (d > WATERWORLD_MAX_DISTANCE) {\n      max_iter = i;\n      return WATERWORLD_MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < WATERWORLD_TOLERANCE) {\n      return d;\n    }\n\n    const float sl = 0.9;\n\n    dt = max(hd*sl, WATERWORLD_TOLERANCE+0.0005*d);\n    lastd = d;\n    d += dt;\n  }\n\n  max_iter = WATERWORLD_MAX_ITER;\n  return WATERWORLD_MAX_DISTANCE;\n}\n\nvec3 waterworld_sunDirection() {\n  return normalize(vec3(-0.5, 0.2, 1.0));\n}\n\nvec3 waterworld_smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 waterworld_skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = waterworld_sunDirection();\n  vec3 smallSunDir = waterworld_smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  float dustTransparency = smoothstep(-0.15, 0.075, rd.y);\n\n  vec3 skyCol = mix(skyCol1, skyCol2, sqrt(dustTransparency));\n  skyCol *= (1.0-dustTransparency);\n\n  vec3 planetCol = gasGiant(ro, rd, sunDir)*dustTransparency;\n\n  vec3 final = planetCol + skyCol + sunCol + smallSunCol;\n\n  return final;\n}\n\nvec3 waterworld_shipColor(vec2 p, float ltime) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.05;\n  p = toRect(pp);\n\n  float n = mod1(p.x, 0.15);\n  p.y += 3.0-ltime*0.5+0.05*abs(n*n);\n\n  float td = abs(p.x) - (0.005-p.y*0.002);\n  td = abs(td) - (0.02*pow(-p.y, 0.25));\n  float sd = circle(p, 0.05);\n\n  vec3 trailCol = vec3(0.5)*smoothstep(-5.0, 0.0, p.y)*step(p.y, 0.0)*smoothstep(0.0, 0.025, -td);\n  vec3 shipCol = vec3(0.5+smoothstep(-1.0, 1.0, sin(ltime*15.0*TAU+n)))*smoothstep(0.0, 0.075, -sd);\n\n  vec3 col = trailCol;\n  col += shipCol;\n\n  float sm = step(abs(n), 2.0);\n\n  return col*sm;\n}\n\nvec3 waterworld_getColor(vec3 ro, vec3 rd, float ltime) {\n  int max_iter = 0;\n  vec3 skyCol = waterworld_skyColor(ro, rd);\n  vec3 col = vec3(0);\n\n  const float shipHeight = 1.0;\n  const float seaHeight = 0.0;\n  const float cloudHeight = 0.2;\n  const float upperCloudHeight = 0.5;\n\n  float id = (cloudHeight - ro.y)/rd.y;\n\n  if (id > 0.0) {\n    float d = waterworld_march(ro, rd, id, max_iter);\n    vec3 sunDir = waterworld_sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, 1.0, -1.0);\n    vec3 p = ro + d*rd;\n\n    float loh = waterworld_loheight(p.xz, d);\n    float loh2 = waterworld_loheight(p.xz+sunDir.xz*0.05, d);\n    float hih = waterworld_hiheight(p.xz, d);\n    vec3 normal = waterworld_normal(p.xz, d);\n\n    float ud = (upperCloudHeight - 4.0*loh - ro.y)/rd.y;\n\n    float sd = (seaHeight - ro.y)/rd.y;\n    vec3 sp = ro + sd*rd;\n    float scd = (cloudHeight - sp.y)/sunDir.y;\n    vec3 scp = sp + sunDir*scd;\n\n    float sloh = waterworld_loheight(scp.xz, d);\n    float cshd = exp(-15.0*sloh);\n\n    float amb = 0.3;\n\n    vec3 seaNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 seaRef = reflect(rd, seaNormal);\n    vec3 seaCol = .25*waterworld_skyColor(p, seaRef);\n    seaCol += pow(max(dot(seaNormal, sunDir), 0.0), 2.0);\n    seaCol *= cshd;\n    seaCol += 0.075*pow(vec3(0.1, 1.3, 4.0), vec3(max(dot(seaNormal, seaRef), 0.0)));\n\n    float spe = pow(max(dot(sunDir, reflect(rd, normal)), 0.0), 3.0);\n    float fre = pow(1.0-dot(normal, -rd), 2.0);\n\n    col = seaCol;\n\n    const float level = 0.00;\n    const float level2 = 0.3;\n    // REALLY fake shadows and lighting\n    vec3 scol = sunCol1*(smoothstep(level, level2, hih) - smoothstep(level, level2, loh2));\n    col = mix(vec3(1.0), col, exp(-17.0*(hih-0.25*loh)));\n    col = mix(vec3(0.75), col, exp(-10.0*loh*(max(d-ud, 0.0))));\n    col += scol;\n\n    col += vec3(0.5)*spe*fre;\n\n    float ssd = (shipHeight - ro.y)/rd.y;\n\n    col += waterworld_shipColor((ro + rd*ssd).xz, ltime);\n\n    col = mix(col, skyCol, smoothstep(0.5*WATERWORLD_MAX_DISTANCE, 1.*WATERWORLD_MAX_DISTANCE, d));\n\n  } else {\n    col = skyCol;\n  }\n\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 waterworld_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro  = vec3(0.5, 5.5, -2.0);\n  vec3 la  = ro + vec3(0.0, -1.+0.75*ltime/(4.0*DURATION),  1.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = waterworld_getColor(ro, rd, ltime)  ;\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n//\n\n\n// ----------------------------==> WATERWORLD <==------------------------------\n\n// ----------------------------==> BARRENMOON <==------------------------------\n\n#ifdef ENABLE_BARRENMOON\n\n#define BARRENMOON_TOLERANCE       0.00001\n#define BARRENMOON_MAX_ITER        65\n#define BARRENMOON_MIN_DISTANCE    0.01\n#define BARRENMOON_MAX_DISTANCE    9.0\n\nconst float barrenmoon_near = 0.3;\nconst float barrenmoon_far  = 0.5;\n\nconst vec3 barrenmoon_sunCol1      = pow(sunCol1, vec3(1.0, 4.0, 4.0));\nconst vec3 barrenmoon_sunCol2      = pow(sunCol2, vec3(2));\nconst vec3 barrenmoon_smallSunCol1 = smallSunCol1;\nconst vec3 barrenmoon_smallSunCol2 = smallSunCol2;\n\nvec2 barrenmoon_hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat barrenmoon_circles(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = barrenmoon_hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  const float r = 0.225;\n\n  float d = circle(p, 2.0*r);\n\n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat barrenmoon_craters(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = barrenmoon_hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  const float r = 0.45;\n\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n\n  float h = -abs(hh.x)*(smoothstep(0.0, r, -2.0*d)-0.3*smoothstep(0.0, 0.2*r, -d));\n\n  return h*0.275;\n}\n\n\nfloat barrenmoon_height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n\n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.075*sin(p.x+p.y);\n  float d = 0.0;\n\n  int i = 0;\n\n  for (; i < 4;++i) {\n    float nn = a*barrenmoon_craters(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/BARRENMOON_MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, barrenmoon_far)));\n\n  for (; i < mx; ++i) {\n    float nn = a*barrenmoon_circles(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float hid = (s/d);\n\n  float m = smoothstep(barrenmoon_near, barrenmoon_far, rdd);\n  return mix(hid, lod, m*m);\n}\n\nfloat barrenmoon_height(vec2 p, float d) {\n  return barrenmoon_height(p, d, 6);\n}\n\nfloat barrenmoon_hiheight(vec2 p, float d) {\n  return barrenmoon_height(p, d, 8);\n}\n\nvec3 barrenmoon_normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = (barrenmoon_hiheight(p - eps.xy, d) - barrenmoon_hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (barrenmoon_hiheight(p - eps.yx, d) - barrenmoon_hiheight(p + eps.yx, d));\n\n  return normalize(n);\n}\n\nfloat barrenmoon_march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  const float initialStep = 1.0;\n  const float secondaryStep = 0.25;\n  float currentStepDist = initialStep;\n  float lastd = d;\n  float mint = -0.005/rd.y;\n  for (int i = 0; i < BARRENMOON_MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = barrenmoon_height(p.xz, d);\n\n    if (d > BARRENMOON_MAX_DISTANCE) {\n      max_iter = i;\n      return BARRENMOON_MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < BARRENMOON_TOLERANCE) {\n      if (currentStepDist < initialStep) {\n        max_iter = i;\n        return d;\n      }\n\n      d = lastd;\n      currentStepDist = secondaryStep;\n      continue;\n    }\n\n    dt = max(hd, mint)*currentStepDist;\n    lastd = d;\n    d += dt;\n  }\n\n  max_iter = BARRENMOON_MAX_ITER;\n  return BARRENMOON_MAX_DISTANCE;\n}\n\nvec3 barrenmoon_sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 barrenmoon_smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 barrenmoon_rocketDirection(float ltime) {\n  return normalize(vec3(0.0, -0.2+mod(ltime, 90.0)*0.0125, 1.0));\n}\n\nvec3 barrenmoon_skyColor(float ltime, vec3 ro, vec3 rd) {\n  vec3 sunDir = barrenmoon_sunDirection();\n  vec3 smallSunDir = barrenmoon_smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, vec3(0.0), smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n\n  vec3 sunCol = 0.5*barrenmoon_sunCol1*pow(sunDot, 20.0) + 8.0*barrenmoon_sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*barrenmoon_smallSunCol1*pow(smallSunDot, 200.0) + 4.0*barrenmoon_smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(barrenmoon_sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n\n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n\n  vec3 rocketDir = barrenmoon_rocketDirection(ltime);\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(ltime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency;\n\n  vec3 planetCol = gasGiant(ro, rd, sunDir)*dustTransparency;\n\n  vec3 final = planetCol + skyCol + sunCol + smallSunCol + dust + rocketCol;\n\n  return final;\n}\n\nvec3 barrenmoon_getColor(float ltime, vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = barrenmoon_skyColor(ltime, ro, rd);\n  vec3 col = vec3(0);\n\n  float id = (0.125 - ro.y)/rd.y;\n\n  if (id > 0.0)   {\n    float d = barrenmoon_march(ro, rd, id, max_iter);\n    vec3 sunDir = barrenmoon_sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = barrenmoon_normal(p.xz, d);\n    vec3 dnx = dFdx(normal);\n    vec3 dny = dFdy(normal);\n    float ff = dot(dnx, dnx) + dot(dny, dny);\n    normal = normalize(normal + vec3(0.0, 5.0*ff, 0.0));\n\n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = barrenmoon_sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = barrenmoon_sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = barrenmoon_skyColor(ltime, p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;\n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*BARRENMOON_MAX_DISTANCE, BARRENMOON_MAX_DISTANCE, d));\n\n  } else {\n    col = skyCol;\n  }\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 barrenmoon_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  ltime = ltime + input0;\n  float off = 0.5*ltime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.00,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = barrenmoon_getColor(ltime, ro, rd)  ;\n\n//  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ----------------------------==> BARRENMOON <==------------------------------\n\n// ------------------------------==> GALAXY <==--------------------------------\n\n#ifdef ENABLE_GALAXY\n\nconst float galaxy_twirly   = 2.5;\nconst vec3  galaxy_colDust  = vec3(1.0, 0.9, 0.75);\n\nfloat galaxy_noise(float ttime, vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n  float tm = ttime;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5)+tm);\n  float d = cos(p.y*sqrt(1.5)+tm);\n\n  return a*b*c*d;\n}\n\nvec2 galaxy_twirl(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*galaxy_twirly + a;\n  p = toRect(pp);\n\n  p *= z;\n\n  return p;\n}\n\nfloat galaxy_galaxy(float ttime, vec2 p, float a, float z) {\n  p = galaxy_twirl(p, a, z);\n\n  return galaxy_noise(ttime, p);\n}\n\nvec3 galaxy_stars(vec2 p) {\n  float l = length(p);\n\n  vec2 pp = toPolar(p);\n  pp.x /= (1.0+length(pp.x))*0.5;\n  p = toRect(pp);\n\n  float sz = 0.0075;\n\n  vec3 s = vec3(10000.0);\n\n  for (int i = 0; i < 3; ++i) {\n    rot(p, 0.5);\n    vec2 ip = p;\n    vec2 n = mod2(ip, vec2(sz));\n    float r = hash(n);\n    vec2 o = -1.0 + 2.0*vec2(r, fract(r*1000.0));\n    s.x = min(s.x, length(ip-0.25*sz*o));\n    s.yz = n*0.1;\n  }\n\n  return s;\n}\n\nfloat galaxy_height(float ttime, vec2 p) {\n  float ang = atan(p.y, p.x);\n  float l = length(p);\n  float sp = mix(1.0, pow(0.75 + 0.25*sin(2.0*(ang + l*galaxy_twirly)), 3.0), tanh(6.0*l));\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 11; ++i) {\n    float g = a*galaxy_galaxy(ttime, p, ttime*(0.025*float(i)), f);\n    s += g;\n    a *= sqrt(0.45);\n    f *= sqrt(2.0);\n    d += a;\n  }\n\n  s *= sp;\n\n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 galaxy_normal(float ttime, vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = galaxy_height(ttime, p - eps.xy) - galaxy_height(ttime, p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = galaxy_height(ttime, p - eps.yx) - galaxy_height(ttime, p + eps.yx);\n\n  return normalize(n);\n}\n\nvec3 galaxy_galaxy(float ttime, vec2 p, vec3 ro, vec3 rd, float d) {\n  rot(p, 0.5*ttime);\n\n  float h = galaxy_height(ttime, p);\n  vec3 s = galaxy_stars(p);\n  float th = tanh(h);\n  vec3 n = galaxy_normal(ttime, p);\n\n  vec3 p3 = vec3(p.x, th, p.y);\n  float lh = 0.5;\n  vec3 lp1 = vec3(-0.0, lh, 0.0);\n  vec3 ld1 = normalize(lp1 - p3);\n  vec3 lp2 = vec3(0.0, lh, 0.0);\n  vec3 ld2 = normalize(lp2 - p3);\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n//  col += vec3(0.5)*pow(diff1, 20.0);\n  col += 0.25*pow(diff2, 4.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n//  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10*l*l);\n\n\n  float sr = hash(s.yz);\n  float si = pow(th*sr, 0.25)*0.001;\n  vec3 scol = sr*5.0*exp(-2.5*l*l)*tanh(pow(si/(s.x), 2.5))*mix(vec3(0.5, 0.75, 1.0), vec3(1.0, 0.75, 0.5), sr*0.6);\n  float sd = length(ro);\n  scol = clamp(scol, 0.0, 1.0);\n  // TODO: Smooth out stars, but it works for the purpose of this shader\n  col += step(sd, 1.5)*scol*smoothstep(0.0, 0.35, 1.0-n.y);\n\n  float ddust = (h - ro.y)/rd.y;\n  if (ddust < d) {\n    float t = d - ddust;\n    col += 0.7*galaxy_colDust*(1.0-exp(-2.0*t));\n  }\n\n  return col;\n}\n\nvec3 galaxy_render(float ttime, vec3 ro, vec3 rd) {\n  float dgalaxy = (0.0 - ro.y)/rd.y;\n\n  vec3 col = vec3(0);\n\n  if (dgalaxy > 0.0) {\n    col = vec3(0.5);\n    vec3 p = ro + dgalaxy*rd;\n\n    col = galaxy_galaxy(ttime, p.xz, ro, rd, dgalaxy);\n  }\n\n  vec2 cgalaxy = raySphere(ro, rd, vec4(vec3(0.0), 0.125));\n\n  float t;\n\n  if (dgalaxy > 0.0 && cgalaxy.x > 0.0) {\n    float t0 = max(dgalaxy - cgalaxy.x, 0.0);\n    float t1 = cgalaxy.y - cgalaxy.x;\n    t = min(t0, t1);\n  } else if (cgalaxy.x < cgalaxy.y){\n    t = cgalaxy.y - cgalaxy.x;\n  }\n\n  col += 1.7*galaxy_colDust*(1.0-exp(-1.0*t));\n\n\n  return col;\n}\n\nvec3 galaxy_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro = vec3(0.0, 0.7, 2.0)*mix(input0, input1, ltime/(2.0*DURATION));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(-0.5, 1.0, 0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float ttime = 0.05*ltime;\n  vec3 col = galaxy_render(ttime, ro, rd);\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ------------------------------==> GALAXY <==--------------------------------\n\n// -----------------------------==> SPACESHIP <==------------------------------\n\n#ifdef ENABLE_SPACESHIP\n\n#define SPACESHIP_TOLERANCE           0.001\n#define SPACESHIP_NORM_OFF            0.001\n#define SPACESHIP_MAX_RAY_LENGTH      100.0\n\n#define SPACESHIP_MAX_RAY_MARCHES     60\n\nconst float spaceship_refractRatio = 0.95;\n\nconst vec3  spaceship_seaCol1      = vec3(0.15, 0.45, 0.55);\nconst vec3  spaceship_seaCol2      = spaceship_seaCol1*spaceship_seaCol1*spaceship_seaCol1*3.0;\n\nconst float spaceship_innerLength  = 4.0;\nconst float spaceship_outerLength  = 6.25;\nconst vec3  spaceship_sunPos       = vec3(0.0, 0.0, spaceship_innerLength);\nconst vec3  spaceship_sunCol1      = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3  spaceship_sunCol2      = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\nconst vec3  spaceship_engineCol1   = vec3(8.0/8.0,6.0/8.0,6.0/8.0);\nconst vec3  spaceship_engineCol2   = vec3(8.0/8.0,5.0/8.0,6.0/8.0);\n\nconst vec3  spaceship_start       = vec3(0.0);\n\nvec3 spaceship_sunColor(vec3 ro, vec3 rd, float input0, float input1) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 spaceship_skyColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n  vec3 gcol = gasGiant(ro+vec3(input0*input1/TAU, 0.0, input1), rd, sunDirection);\n\n  return scol+gcol;\n}\n\nvec3 spaceship_refColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n\n  vec3 final = vec3(0.0);\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  final *= 0.5;\n  final += scol;\n\n  return final;\n}\n\nvec3 spaceship_domeColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n\n  vec3 final = mix(vec3(0.125, 0.25, 0.5), vec3(0.25), 0.5 + 0.5*rd.y)*0.5;\n  final += scol;\n\n  return final;\n}\n\nvec4 spaceship_backplane(vec3 ro, vec3 rd, inout vec3 scol) {\n  float ed = (spaceship_innerLength - ro.z)/rd.z;\n  vec3 ep = ro + rd*ed;\n  vec3 en = vec3(0.0, 0.0, 1.0);\n\n  float lr = 0.5;\n  float er = (lr*lr-dot(ep.xy, ep.xy))/(lr*lr);\n  float eradius = length(ep.xy);\n  float emradius = eradius;\n  float eangle = atan(ep.y, ep.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.1);\n  mod1(emangle, TAU/60.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n\n  float efadeout = 1.0 - smoothstep(0.0, 0.9, eradius);\n\n  scol = vec3(0.0);\n  scol += 8.0*spaceship_sunCol1*pow(clamp(er, 0.0, 1.0), 8.0);\n  scol += spaceship_sunCol1*pow(clamp(er, 0.0, 1.0), 1.0);\n  scol += spaceship_sunCol2*efadeout*efadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += scol;\n  ecol += elinec*smoothstep(0.01, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.015, 0.0, abs(emangle))*efadeout;\n\n  return vec4(ecol, eradius < 1.0);\n}\n\nfloat spaceship_fbm(vec2 p, int mx) {\n  const float aa = 0.45;\n  const float pp = 2.08;\n  const float rr = 1.0;\n\n  float a = 1.0;\n  float s = 0.0;\n  float d = 0.0;\n\n  for (int i = 0; i < mx; ++i) {\n    s += a*vnoise(p);\n    d += abs(a);\n    a *= aa;\n    p *= pp;\n    rot(p, rr);\n  }\n\n  return 1.0*s/d;\n}\n\nvec3 spaceship_normal(vec2 p, int mx) {\n  vec2 eps = -vec2(0.0001, 0.0);\n\n  vec3 nor;\n\n  nor.x = spaceship_fbm(p + eps.xy, mx) - spaceship_fbm(p - eps.xy, mx);\n  nor.y = 2.0*eps.x;\n  nor.z = spaceship_fbm(p + eps.yx, mx) - spaceship_fbm(p - eps.yx, mx);\n\n  return normalize(nor);\n}\n\nvec3 spaceship_islands(vec3 col, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.7;\n  float beachLevel = level + 0.025;\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n\n  sp *= 2.0;\n  float hih = spaceship_fbm(sp, 6);\n  float loh = spaceship_fbm(sp+vec2(0.075-0.075*sp.x/spaceship_innerLength, 0.0), 3);\n  vec3 hn = spaceship_normal(sp, 6);\n\n  vec3 nn = normalize(hn + n);\n\n  const vec3 sandCol = vec3(1.0, 0.95, 0.9);\n\n  float fdiff = pow(max(dot(sunDir, nn), 0.0), 0.5);\n\n  vec4 treePattern = voronoi(sp*40.0);\n  vec3 islandCol  = mix(vec3(0.5, 0.75, 0.0), vec3(0.1, 0.45, 0.0), treePattern.y*fdiff*2.0);\n  islandCol *= 1.0 - treePattern.x * 0.75;\n\n  col = mix(0.0, 1.0, hih < level)*mix(sandCol, col , 1.0 - exp(8.0*vec3(2.0, 1.0, 1.0)*(hih-level)));\n  col = mix(col, sandCol, vec3((beachLevel >  hih) && (hih > level)));\n  col = mix(col, islandCol, vec3(hih > beachLevel));\n  // Really REALLY fake lighting+shadows\n  const float hh = 0.125;\n  vec3 scol = vec3(1.0)*(smoothstep(level, level+hh, hih) - smoothstep(level, level+hh, loh));\n  col = col+scol*0.5;\n\n  return col;\n}\n\nvec3 spaceship_clouds(vec3 col, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.5;\n\n  vec3 ref = reflect(rd, n);\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n  float sunL2 = l2(spaceship_sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe1 = 0.5*pow(max(dot(sunDir, ref), 0.0), 10.0);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  sp *= 2.0;\n  sp += 100.0;\n  float hih = max(spaceship_fbm(sp, 6) - level, 0.0);\n  float loh = max(spaceship_fbm(sp, 3) - level, 0.0);;\n\n  // More fake stuff\n  float m = clamp(1.0- exp(-15.0*(hih-0.5*loh)), 0.0, 1.0);\n\n  col = mix(col, vec3(1.25)*spaceship_sunCol1*(sunIll + spe1 + spe2), m*m*m);\n\n  return col;\n}\n\nvec3 spaceship_cloudShadows(vec3 col, vec3 p, float level) {\n  level += 0.5;\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n\n  vec2 ci = rayCylinder(p, sunDir, spaceship_start, vec4(0.0, 0.0, 1.0, 0.8));\n\n  vec3 pp = p + ci.x*sunDir;\n  vec2 pp2 = cylinderCoord(pp);\n\n  pp2 *= 2.0;\n  pp2 += 100.0;\n  float loh = max(spaceship_fbm(pp2, 3) - level, 0.0);\n\n  return col*mix(0.3, 1.0, exp(-3.0\n  *loh));\n}\n\nvec3 spaceship_sea(vec3 ro, vec3 rd, vec3 n, vec3 p, vec2 sp) {\n\n  vec3 ref = reflect(rd, n);\n  ref = normalize(ref + 0.025*psin(mix(110.0, 220.0, psin(2.0*p.z+0.2*p.x))*p.z));\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n  float sunL2 = l2(spaceship_sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  vec3 seaCol = vec3(0.0);\n  seaCol += 1.0*spaceship_seaCol2*pow(1.0-max(dot(n, ref), 0.0), 0.45);\n  seaCol += spaceship_seaCol1*0.5*sunIll;\n  seaCol += spaceship_seaCol1*spaceship_sunCol1*sunDiff*sunIll;\n  seaCol += spaceship_sunCol1*spe2;\n\n  return seaCol;\n}\n\nvec3 spaceship_shipInterior(vec3 ro, vec3 rd, float input0, float input1) {\n  ro += rd*0.05;\n\n  float fd = (0.0 - ro.z)/rd.z;\n  vec2 di = raySphere(ro, rd, vec4(spaceship_start, 1.0));\n  vec2 ci = rayCylinder(ro, rd, spaceship_start, vec4(0.0, 0.0, 1.0, 0.8));\n  vec2 gi = rayCylinder(ro, rd, spaceship_start, vec4(0.0, 0.0, 1.0, 0.9));\n\n  vec3 dp = ro + rd*di.y;\n  vec3 dn = -normalize(dp  -spaceship_start);\n  vec3 drefr = refract(dp, dn, 1.0/spaceship_refractRatio);\n  vec3 dcol = 0.9*spaceship_domeColor(dp, drefr, input0, input1);\n\n  vec3 gp = ro + rd*gi.y;\n  vec3 gpy = ro + rd*gi.x;\n  vec3 gn = -normalize(vec3(gp.xy-spaceship_start.xy, 0.0));\n  vec2 gp2 = cylinderCoord(gp);\n\n  vec3 cp = ro + rd*ci.y;\n  vec3 cn = -normalize(vec3(cp.xy-spaceship_start.xy, 0.0));\n\n  vec3 fpcol = vec3(0.0);\n\n  vec3 scol;\n  vec4 bpcol = spaceship_backplane(ro, rd, scol);\n  vec3 bpn = vec3(0.0, 0.0, 1.0);\n  float bpdiff = max(dot(rd, bpn), 0.0);\n\n  vec3 col = vec3(0.0);\n\n  col = mix(col, fpcol, vec3(fd > gi.y));\n  col = mix(col, dcol, vec3(dp.z < 0.0));\n  col = mix(col, bpcol.xyz, bpcol.w);\n\n  if (gp.z > 0.0 && gpy.z < 0.0 && gp.z < spaceship_innerLength) {\n    float level = 0.0;\n    level += 1.0-smoothstep(0.0, 0.1*spaceship_innerLength, gp2.x);\n    level += 1.0-smoothstep(0.0, 0.1*spaceship_innerLength, spaceship_innerLength-gp2.x);\n\n    /*\n    // Too fix discontinuity. Alternative approach, place the camera correctly ;)\n    level += 1.0-smoothstep(-PI, -PI+0.5, gp2.y);\n    level += 1.0-smoothstep(PI, PI-0.5, gp2.y);\n    */\n\n    level *= 0.125;\n    vec3 gcol = spaceship_sea(ro, rd, gn, gp, gp2);\n    gcol = spaceship_islands(gcol, gp, gn, gp2, level);\n    gcol = spaceship_cloudShadows(gcol, gp, level);\n    gcol = spaceship_clouds(gcol, ro, rd, cp, cn, cylinderCoord(cp), level);\n    col = gcol;\n  }\n\n  float id = max(gi.y-max(gi.x, 0.0), 0.0);\n  col = mix(col, spaceship_sunCol1, 1.0-exp(-0.05*id*id));\n  col = mix(col, 0.75*scol + 1.25*spaceship_sunCol1, pow(bpdiff, 35.0));\n\n  return col;\n}\n\nfloat spaceship_theShip(float ltime, vec3 p, out float nx, out float ny, out int m) {\n  const float rep = 5.0;\n  const float tradius = 1.2;\n  const float sstep = TAU*1.125/rep;\n  const float sradius = 0.45*TAU*1.125/rep;\n  rot(p.xy, ltime*TAU/60.0);\n  float dcapsule = capsule(p, spaceship_outerLength, 1.0);\n  dcapsule = pmin(dcapsule, softBox(p, 0.75), 0.25);\n  float dglobe = max(dcapsule, p.z);\n\n  vec3 pc = p;\n  pc.z -= 0.5*sstep;\n  float n = mod1(pc.z, sstep);\n  float dtorus = torus(pc.xzy, vec2(tradius*1.55, 0.025));\n  float nm = modPolar(pc.xy, rep);\n  float dspoke = cylinder(pc, vec3(tradius*1.55, 0.0, 0.025));\n  dtorus = min(dtorus, dspoke);\n  dtorus = max(dtorus, -p.z + sstep*0.5-0.025);\n  dtorus = max(dtorus, p.z-sstep*5.0 + sstep*0.5-0.025);\n  float dbattery = sphere(pc - vec3(tradius, 0.0, 0.0), sradius);\n  float dbox = softBox(pc - vec3(tradius, 0.0, 0.0), sradius*0.9);\n  dbox = roundDiff(dbox, dbattery, 0.125);\n  dbattery = min(dbattery, dbox);\n  dbattery = max(dbattery, -p.z + sstep*0.05);\n  dbattery = max(dbattery, p.z-sstep*5.0);\n  float dengine1 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+1.0)), 0.9);\n  float dengine2 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+2.0)), 0.9);\n  float dengine3 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+1.0)), 0.25);\n  float dengine = dengine1;\n  dengine = max(dengine, -dengine2);\n  dengine = min(dengine, dengine3);\n  vec3 pe = p;\n  pe -= vec3(0.0, 0.0, spaceship_outerLength+1.8);\n  mod1(pe.x, 0.5);\n  mod1(pe.y, 0.5);\n  float d = dcapsule;\n  d = min(d, dengine);\n  d = chamfer(d, dbattery, 0.035);\n  d = min(d, dtorus);\n\n\n  m = 1;\n\n  if (d == dglobe) m = 3;\n  if (d == dbattery) m = 4;\n  if (d == dtorus) m = 1;\n  if (d == dbox) m = 2;\n  if (d == dengine1) m = 2;\n  if (d == -dengine2) m = 5;\n  if (d == dengine3) m = 5;\n\n  nx = n;\n  ny = nm;\n\n  return d;\n}\n\nfloat spaceship_map(float ltime, vec3 p, out float nx, out float ny, out int m) {\n  return spaceship_theShip(ltime, p, nx, ny, m);\n}\n\n\nfloat spaceship_rayMarch(float ltime, vec3 ro, vec3 rd, out float nx, out float ny, out int mat, out int iter) {\n  float t = 0.0;\n  float d;\n  int i;\n  for (i = 0; i < SPACESHIP_MAX_RAY_MARCHES; i++)\n  {\n    d = spaceship_map(ltime, ro + rd*t, nx, ny, mat);\n    if (d < SPACESHIP_TOLERANCE || t > SPACESHIP_MAX_RAY_LENGTH) break;\n    t += d; // 0.9\n  }\n  iter = i;\n\n  if (abs(d) > 10.0*SPACESHIP_TOLERANCE) return SPACESHIP_MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 spaceship_normal(float ltime, vec3 pos) {\n  vec3  eps = vec3(SPACESHIP_NORM_OFF,0.0,0.0);\n  vec3 nor;\n  float nx;\n  float ny;\n  int mat;\n  nor.x = spaceship_map(ltime, pos+eps.xyy, nx, ny, mat) - spaceship_map(ltime, pos-eps.xyy, nx, ny, mat);\n  nor.y = spaceship_map(ltime, pos+eps.yxy, nx, ny, mat) - spaceship_map(ltime, pos-eps.yxy, nx, ny, mat);\n  nor.z = spaceship_map(ltime, pos+eps.yyx, nx, ny, mat) - spaceship_map(ltime, pos-eps.yyx, nx, ny, mat);\n  return normalize(nor);\n}\n\nvec3 spaceship_innerColor(float ltime, vec3 ro, vec3 rd, vec3 nor, float nx, float ny) {\n  vec2 f = hash2(137.0*vec2(nx, ny)+27.0);\n  vec3 refr = refract(rd, nor, 3.0);\n  float dim = smoothstep(0.6, 0.7, f.x);\n  dim *= mix(0.5, 1.0, psin(2.0*ltime+f.y*TAU));\n  float s1 = mix(0.3, 2.0, dim);\n  float s2 = mix(1.0, 1.25, dim);\n  float m = max(dot(nor, -refr), 0.0);\n  return 1.5*s1*pow(vec3(1.2, 1.1, s2)*m, 1.25*vec3(2.5, 2.5, 5.5));\n}\n\nvec3 engineColor(vec3 ro, vec3 rd, vec3 nor) {\n  float eradius = length(ro.xy);\n  float emradius = eradius;\n  float eangle = atan(ro.y, ro.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.2);\n  mod1(emangle, TAU/20.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n\n  float efadeout = 1.0 - smoothstep(0.0, 0.75, eradius);\n  float ifadeout = smoothstep(0.2, 0.225, eradius);\n\n  vec3 refr = refract(rd, nor, 1.25);\n  float m = max(dot(nor, -refr), 0.0);\n\n\n  vec3 scol = vec3(0.0);\n  scol += 4.0*spaceship_engineCol1*pow(m, 4.0);\n  scol += spaceship_engineCol2*2.0;\n  scol *= 1.0- ifadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += elinec*smoothstep(0.02, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.05, 0.0, abs(emangle))*efadeout;\n  ecol += spaceship_engineCol2*2.0*efadeout*efadeout;\n  ecol *= ifadeout;\n\n  return ecol + scol;\n}\n\nvec3 spaceship_render(float ltime, float input0, float input1, vec3 ro, vec3 rd) {\n  // background color\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float nx;\n  float ny;\n  float t = spaceship_rayMarch(ltime, ro, rd, nx, ny, mat, iter);\n\n//  vec3 icol = 1.0*vec3(1.0, 0.0, 0.9)*smoothstep(0.5, 1.0, float(iter)/MAX_RAY_MARCHES);\n  const  vec3 icol = vec3(0.0);\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = spaceship_normal(ltime, pos);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = spaceship_refColor(pos, ref, input0, input1);\n  vec3 refr = refract(rd, nor, spaceship_refractRatio);\n\n  if (t < SPACESHIP_MAX_RAY_LENGTH) {\n    // Ray intersected object\n\n    switch(mat) {\n    case 0:\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 1:\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 2:\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 3:\n      vec3 sicol = spaceship_shipInterior(pos, refr, input0, input1);\n      color = mix(sicol, rcol, vec3(refr == vec3(0.0)));\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 4:\n      color = spaceship_innerColor(ltime, pos, rd, nor, nx, ny);\n      ndif = 0.75;\n      nref = 0.9;\n      break;\n    case 5:\n      color = engineColor(pos, rd, nor);\n      ndif = 0.5;\n      nref = 0.75;\n      break;\n    default:\n      color = nor*nor;\n      break;\n    }\n\n  }\n  else {\n    // Ray intersected sky\n    return spaceship_skyColor(ro, rd, input0, input1) + icol;\n  }\n\n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = sunDirection;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = smallSunDirection;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float st  = spaceship_rayMarch(ltime, pos + ref*10.0*SPACESHIP_TOLERANCE, ref, nx ,ny, rmat, riter);\n  float sha2 = st < SPACESHIP_MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*spaceship_sunCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*spaceship_sunCol2, 0.8);\n\n  vec3 col = mix(rcol*sha2, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col + icol;\n}\n\nvec3 spaceship_fragment(float ltime, float input0, float input1, vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  return spaceship_render(ltime, input0, input1, ro, rd);\n}\n\n\nvec3 spaceship_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n\n  vec3 ro  =vec3(1.0, 0.0, -3.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  switch(minor) {\n  case MINOR_FROM_BEHIND:\n    ro = 3.0*vec3(0.5-ltime/10., 1.0+ltime/5.0, 15.0-ltime);\n    break;\n  case MINOR_CYLINDER_SEA:\n    ro = vec3(-7.5+ltime, 0.5, -1.5-ltime/10.0);\n    break;\n  case MINOR_FROM_FRONT:\n    ro = -3.0*vec3(-0.5+ltime/10., 1.0-ltime/5.0, 10.0-ltime);\n    break;\n  default:\n    break;\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n  col += spaceship_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o1);\n\n#ifdef AA\n  // Adaptive AA? Is that a good idea?\n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+1.0/256);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n  if (de > 0.1) {\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p-o1);\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p+o2);\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n#endif\n\n  return col;\n}\n\n#endif\n\n// -----------------------------==> SPACESHIP <==------------------------------\n\n// -------------------------------==> MAIN <==---------------------------------\n\nvec3 mainImage(vec2 p, vec2 q) {\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float effectNo = 0.0;\n  const float totalTime = float(effects.length())*DURATION + (DURATION1-DURATION);\n  float dtime = mod(max(TIME, 0.0), totalTime)-(DURATION1 - DURATION);\n\n  float timeInEffect = mod(dtime, DURATION);\n  int effectIndex = int(effectNo + mod(dtime/DURATION, float(effects.length())));\n\n  if (dtime < DURATION) {\n    // Special handling for first effect\n    timeInEffect = dtime+DURATION1 - DURATION;\n    effectIndex = 0;\n  }\n\n  Effect effect = effects[effectIndex];\n  Effect nextEffect = effects[int(((effectIndex + 1)%effects.length()))];\n  float ltime = timeInEffect + effect.seq*DURATION;\n\n  vec3 col = vec3(0.5);\n\n\n  switch(effect.major) {\n#ifdef ENABLE_NOEFFECT\n  case MAJOR_NOEFFECT:\n    col = noeffect_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_IMPULSE\n  case MAJOR_IMPULSE:\n    col = impulse_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_ORRERY\n  case MAJOR_ORRERY:\n    col = orrery_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_WATERWORLD\n  case MAJOR_WATERWORLD:\n    col = waterworld_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_BARRENMOON\n  case MAJOR_BARRENMOON:\n    col = barrenmoon_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_GALAXY\n  case MAJOR_GALAXY:\n    col = galaxy_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_SPACESHIP\n  case MAJOR_SPACESHIP:\n    col = spaceship_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n  default:\n    col = vec3(0.5, 0.0, 0.0);\n    break;\n  }\n\n  col = clamp(col, 0.0, 1.0);\n\n  float fadeIn  = smoothstep(0.0, FADEIN, timeInEffect);\n  float fadeOut = smoothstep(DURATION - FADEOUT, DURATION, timeInEffect);\n  float tfadeout = smoothstep(DURATIONT - 2.0*DURATION, DURATIONT, TIME);\n\n  if (effect.fade && effect.seq == 0.0) {\n    col = mix(vec3(0.0), col, fadeIn*fadeIn);\n  }\n\n  if (effect.fade && nextEffect.seq == 0.0){\n    col = mix(col, vec3(0.0), fadeOut*fadeOut);\n  }\n\n  col = mix(col, vec3(0.0), tfadeout*tfadeout);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  fragColor = vec4(mainImage(p, q), 1.0);\n}\n\n// -------------------------------==> MAIN <==---------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}