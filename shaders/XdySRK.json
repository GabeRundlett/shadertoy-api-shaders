{
    "Shader": {
        "info": {
            "date": "1466051536",
            "description": "This is a remix of: https://www.shadertoy.com/view/4dVGRW#\n\ncheers Hughsk!",
            "flags": 32,
            "hasliked": 0,
            "id": "XdySRK",
            "likes": 2,
            "name": "Negative Space Cell Shading",
            "published": 3,
            "tags": [
                "raymarch",
                "normals",
                "cellshading",
                "edgedetection"
            ],
            "usePreview": 0,
            "username": "vsnchips",
            "viewed": 795
        },
        "renderpass": [
            {
                "code": "mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec2 getDeltas(sampler2D buffer, vec2 uv) {\n  vec2 pixel = vec2(1. / iResolution.xy);\n  vec3 pole = vec3(+1, -1, -1);\n  float dpos = 0.0;\n  float dnor = 0.0;\n    \n  vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1\n  vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1\n  vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1\n  vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2\n  vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2\n  vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2\n  vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3\n  vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3\n  vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3\n\n  dpos = (\n    abs(s1.a - s7.a) +\n    abs(s5.a - s3.a) +\n    abs(s0.a - s8.a) +\n    abs(s2.a - s6.a)\n  ) * 0.5;\n  dpos += (\n    max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) +\n    max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) +\n    max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) +\n    max(0.0, 1.0 - dot(s2.rgb, s6.rgb))\n  );\n  \n  dpos = pow(max(dpos - 0.5, 0.0), 5.);\n    \n  return vec2(dpos, dnor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro = vec3(sin(iTime * 0.2), 1.5, cos(iTime * 0.2)) * 5.;\n  vec3 ta = vec3(1., 1., 1.0);\n  vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 0.1);\n  vec2 uv = fragCoord.xy / iResolution.xy;\n    \n  vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy);\n  float t = buf.a * 100.;\n  vec3 nor = buf.rgb;\n  vec3 pos = ro + rd * t;\n    \n  vec3 col = vec3(1., 1., 1);\n  vec2 deltas = getDeltas(iChannel0, uv);\n  if (t > -0.5) {\n    col = vec3(1.0);\n    col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0.1, -2, -10.))));\n    col *= vec3(1, 1, 1);\n  }\n  /* col.r = smoothstep(0.1, 1.0, col.r);\n  col.g = smoothstep(0.1, 1.0, col.g);\n  col.b = smoothstep(0.1, 1.0, col.b);\n  col = pow(col, vec3(1.1));\n  */\n   col -= 0.00000001*vec3(deltas.xx,deltas.x);\n  \n    \n  fragColor = vec4(col,1.)+0.9*buf;\n  //fragColor = vec4(buf.xyz,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y*1.,d.z)),0.) + length(max(d,0.0));\n}\n\nvec2 mirror(vec2 p, float v) {\n  float hv = v * 0.5;\n  vec2  fl = mod(ceil(p / v + 0.), sin(iTime)*.5+2.) * 2.0 - 1.5;\n  vec2  mp = mod((p + (hv * 4.)), v) - hv;\n    \n  return fl * mp;\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat map(vec3 p) {\n  float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9;\n  p.xz = mirror(p.xz, 10.);\n  p.xz = rotate2D(p.xz, r);\n  float d = sdBox(p, vec3(1));\n  d = min(d, sdBox(p, vec3(0.1, 0.1, 3)));\n  d = min(d, sdBox(p, vec3(2.5, 0.3, 0.1)));\n  return d;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nfloat calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  float res    = -1.0;\n\n  for (int i = 0; i < 300; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    float result = map(rayOrigin + rayDir * dist);\n\n    latest = result;\n    dist  += latest;\n  }\n {\n    res = dist;\n  }\n\n  return res;\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ) +\n                    v2 * map( pos + v2*eps ) +\n                    v3 * map( pos + v3*eps ) +\n                    v4 * map( pos + v4*eps ) );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = squareFrame(iResolution.xy, fragCoord.xy);\n  vec3 ro = vec3(sin(iTime*0.1), 2, cos(iTime * 0.1)) * 01.2;\n  vec3 ta = vec3(0.0, 0.0, 0.);\n  vec3 rd = getRay(ro, ta, uv, 0.4);\n    \n  float t = calcRayIntersection(ro, rd, 200.0, 0.0);\n  vec3 pos = ro + rd * t * 1.0 +sin(iTime*1.)*01.;\n  vec3 nor = calcNormal(pos)*0.9 + t * 0.00;\n    \n  fragColor = vec4(nor, t * 0.5);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}