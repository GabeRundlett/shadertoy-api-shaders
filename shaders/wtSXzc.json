{
    "Shader": {
        "info": {
            "date": "1566585014",
            "description": "Remixing Gallo's Rayman Raving Rabbid available at: https://www.shadertoy.com/view/tlBXzG.\nMusic may not sound automatically due to some kind of incompatibility with SoundCloud, in such case just go to Image/iChannel3, pause then resume audio playback.",
            "flags": 96,
            "hasliked": 0,
            "id": "wtSXzc",
            "likes": 14,
            "name": "Raving Rabbids actually raving!",
            "published": 3,
            "tags": [
                "raymarching",
                "remix",
                "character",
                "rayman",
                "rabbid",
                "gallo"
            ],
            "usePreview": 0,
            "username": "merry",
            "viewed": 1805
        },
        "renderpass": [
            {
                "code": "/**\n * @buffer\tImage\n * @brief   FXAA filter (author: Mudlord) + fade from black.\n */\n\n//\tLots of love to people whose code I'm using here: iq, XT95, Mudlord, the Mercury guys.\n//\tBy merry^Architect (2019).\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n    vec2  p         = fragCoord.xy/iResolution.xy;\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  color     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3  luma      = vec3(0.299, 0.587, 0.114);\n    float lumaNW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.,-1.)) * pp).xyz, luma);\n    float lumaNE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1.,-1.)) * pp).xyz, luma);\n    float lumaSW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1., 1.)) * pp).xyz, luma);\n    float lumaSE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1., 1.)) * pp).xyz, luma);\n    float lumaM     = dot(color.xyz, luma);\n    float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax   = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2  dir       = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0/8.0)), (1.0/128.0));\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1. / 3. -.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2. / 3. -.5)).xyz\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir *-.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * .5).xyz\n    );\n\n    float lumaB = dot(rgbB, luma);\n    fragColor = vec4((lumaB < lumaMin) || (lumaB > lumaMax) ? rgbA : rgbB, color.w);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 19415,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user1706906/02-paul-elstak-ft-beatstream"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float kNearPlaneDist   = 0.1;\nconst float kFarPlaneDist    = 256.;\nconst int   kMaxSteps        = 64 ;\nconst float kPi              = 3.14159265359;\nconst float kTau\t\t\t = 6.28318530718;\nconst float kEpsilon         = 0.001;\nconst vec3  kAmbientColor    = vec3(.166, .406, .664); \t// Ambient light color.  \nconst float kAmbientTerm     = 0.15; \t\t\t\t\t// Ambient light term.\nconst int   kNumLights       = 4;\nconst int   kNumCasterLights = 0;\nconst vec3 X_AXIS = vec3(1,0,0);\nconst vec3 Y_AXIS = vec3(0,1,0);\nconst vec3 Z_AXIS = vec3(0,0,1);\nconst float kSongBpm = 170.;\nfloat gSongTime = 0.;\n\n//\tGets light data.\nmat4 light(in int lightID, in vec3 pos, in vec3 ref)\n{\n\tmat4 lit = mat4(0);\n     float t = gSongTime;\n    float q = 1.- sin(mod(t*kTau, kTau*.25));\n    if (0 == lightID)\n    {\n    \tlit = mat4\n\t    (\n\t\t\t0.00, 15.00, 0.00,10.00, // Light position and attenuation.\n        \t1.00, 1.00, 1.00, 0.00, // Light color.\n        \t0.00, 0.00, 0.00, 0.00, // Reserved.\n        \t0.00, 0.00, 0.00, 0.00  // Reserved.\n\t    );\n\t\tlit[1].x*=1.;\n\t\tlit[1].y*=.25+.75*step(mod(t*4.,2.),1.);\n\t\tlit[1].z*=.25+.75*step(mod(t*4.,6.),3.);\n        lit[1].x-=lit[1].y*lit[1].z;\n        lit[1].xyz *= 1.-q;\n    }\n    else\n    if (1 == lightID)\n    {\n    \tlit = mat4\n\t    (\n\t\t\t-15.00, 15.00, 15.00,10.00, // Light position and attenuation.\n        \t1.00, 1.00, 1.00, 0.00, // Light color.\n        \t0.00, 0.00, 0.00, 0.00, // Reserved.\n        \t0.00, 0.00, 0.00, 0.00  // Reserved.\n\t    );\n        \n\t\tlit[0].x*=1.+step(mod(t*4.,2.),1.);\n\t\tlit[0].z*=1.+step(mod(t*4.,6.),3.);\n\t\tlit[1].y*=1.;\n\t\tlit[1].x*=.25+.75*step(mod(t*4.,2.),1.);\n\t\tlit[1].z*=.25+.75*step(mod(t*4.,6.),3.);\n        lit[1].y-=lit[1].x*lit[1].z;\n\n        lit[1].xyz *= q;\n    }\n    else\n    if (2 == lightID)\n    {\n    \tlit = mat4\n\t    (\n\t\t\t15.00, 15.00, -15.00,10.00, // Light position and attenuation.\n        \t1.00, 1.00, 1.00, 0.00, // Light color.\n        \t0.00, 0.00, 0.00, 0.00, // Reserved.\n        \t0.00, 0.00, 0.00, 0.00  // Reserved.\n\t    );\n\t\tlit[0].x*=1.+step(mod(t*2.,2.),1.);\n\t\tlit[0].z*=1.+step(mod(t*2.,6.),3.);\n\t\tlit[1].z*=1.;\n\t\tlit[1].x*=.25+.75*step(mod(t*4.,2.),1.);\n\t\tlit[1].y*=.25+.75*step(mod(t*4.,6.),3.);\n        lit[1].z-=lit[1].y*lit[1].x;\n\n        lit[1].xyz *= q;\n    }\n    else\n    if (3 == lightID)\n    {\n    \tlit = mat4\n\t    (\n\t\t\t-15.00, 15.00, -15.00,10.00, // Light position and attenuation.\n        \t1.00, 1.00, 1.00, 0.00, // Light color.\n        \t0.00, 0.00, 0.00, 0.00, // Reserved.\n        \t0.00, 0.00, 0.00, 0.00  // Reserved.\n\t    );\n\t\tlit[0].x*=1.+step(mod(t*4.,4.),2.);\n\t\tlit[0].z*=1.+step(mod(t*4.,6.),3.);\n\t\tlit[1].x*=1.;\n\t\tlit[1].y*=.25+.75*step(mod(t*4.,2.),1.);\n\t\tlit[1].z*=.25+.75*step(mod(t*4.,6.),3.);\n        lit[1].x-=lit[1].y*lit[1].z;\n\n        lit[1].xyz *= q;\n    }\n    lit[3].xyz = normalize(lit[0].xyz - pos); // Computes light vector.\n    return\tlit;\n}\n\nvec3 bgColor(in float t, in vec3 rd)\n{\n    float q = 1.- sin(mod(gSongTime*kTau, kTau*.25));\n    return texture(iChannel1, rd).xyz*q*light(0,vec3(0),vec3(0))[1].xyz;\n}\nmat3 rotation(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return inverse(mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n \t\t\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n \t\t\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 opMirrorX(in vec3 pos)\n{\n    vec3 lPos = pos;\n    lPos.x = abs(lPos.x);\n    return lPos;\n}\n\nvec3 opMirrorY(inout vec3 pos)\n{\n    pos.y = abs(pos.y);\n    return pos;\n}\n\nvec3 opMirrorZ(inout vec3 pos)\n{\n    pos.z = abs(pos.z);\n    return pos;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\nfloat sdPlane(vec3 p, vec4  n) { return dot(p,n.xyz) + n.w; }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2  mapScene(in vec3 pos)\n{\n\tvec2  a = vec2(kFarPlaneDist, 0), b = a;\nb   = vec2(sdPlane(pos+vec3(0,0.15,0), vec4(0,1,0,0)), 0.); MIN(a, b);\t// Floor.\n    \n    vec2 res = a;\n     float t = gSongTime;\n    \n    vec2 d0 = pMod2(pos.zx, vec2(1.));\n    \n    vec2 d = fract(d0 * .1);\n    float f0 = 1., f1 = 2.;\n    \n    pos.xy*=1.+mod(d0.xy,vec2(.4));\n\n    pos.y -= abs(sin(t*kTau*f1+d0.x+d0.y)*.1)*(d.x+d.y);\n\n//pos.x*=mod(d0.x,.5)+.5;\n    \n    pos = rotation(Y_AXIS, sin(d.x*30.+d.y*12.)*.1) * pos;\n    \n\tvec3 lHeadStart = rotation(X_AXIS, -0.1) * rotation(Z_AXIS, -0.1) * (pos - vec3(-0.03, 0.7, 0.0)); // rotation(X_AXIS, -0.1) * rotation(Z_AXIS, -0.1) *\n\tlHeadStart.z += f0*sin(t*kTau*4.+d.x+d.y)*0.07;\n    //Main Head\n    float   lHead = sdEllipsoid( lHeadStart, vec3(0.165, 0.15, 0.165));\n    lHead = opSmoothUnion(lHead, sdEllipsoid( lHeadStart - vec3(0.0, -0.15, 0.00), vec3(0.15, 0.2, 0.15)), 0.1);\n    float   lTorso = sdEllipsoid( pos - vec3(0.0, 0.26, 0.0), vec3(0.2, 0.22, 0.18));\n    //Ears\n    vec3 lEarsPos = rotation(Z_AXIS, 0.22) * opMirrorX(lHeadStart * vec3(1.0, 0.9, 1.0));\n    float lEars = sdRoundCone( lEarsPos - vec3(0.07, 0.14, 0.0), 0.04, 0.075, 0.15 );\n    \n\tfloat lEarsCutter =  sdBox(lEarsPos -  vec3(0.09, 0.26, -0.11), vec3(0.1, 0.15, 0.1));\n    \t  lEarsCutter =  min(lEarsCutter, sdBox(lEarsPos -  vec3(0.09, 0.26, 0.11), vec3(0.1, 0.15, 0.1)));\n    \t  lEars = max(lEars, -lEarsCutter);\n    lHead = opSmoothUnion(lHead, lEars, 0.02);\n    float lBody = opSmoothUnion(lHead, lTorso, 0.04);\n\n    //lLegs\n    vec3 pos2 = rotation(X_AXIS, -sin(t*kTau*f1)*.1) * pos;\n    if (f1 == 0.) pos2 = pos;\n    float lLegs = sdCylinder( opMirrorX(pos2) - vec3(0.09, 0.0, 0.0), vec2(0.07, 0.2) );\n    lBody = opSmoothUnion(lBody, lLegs, 0.07);\n    \n    //Arms\n    float lArms  = sdEllipsoid( rotation(Z_AXIS, -0.28) * (opMirrorX(pos) - vec3(0.18, 0.28, 0.0)), vec3(0.06, 0.12, 0.06));\n    lBody = fOpIntersectionRound(lBody, -lArms, 0.02);\n    //Arms Top\n    lArms  = opSmoothUnion(lArms, sdEllipsoid( rotation(Z_AXIS, -0.28) * (opMirrorX(pos) - vec3(0.125, 0.35, 0.0)), vec3(0.065, 0.08, 0.065)), 0.04);\n    //Hands\n    float lHands  = sdEllipsoid( rotation(Z_AXIS, -0.2) * (opMirrorX(pos) - vec3(0.235, 0.19, 0.0)), vec3(0.026, 0.065, 0.045));\n    \t  lHands  = min(lHands, sdEllipsoid( (opMirrorX(pos) - vec3(0.2, 0.17, -0.035)), vec3(0.012, 0.02, 0.012)));\n    lArms = opSmoothUnion(lArms, lHands, 0.02);\n    lBody = opSmoothUnion(lBody, lArms, 0.008);\n    \n    \n    \n    //Mouth Cavity\n    float lMouthCavity = sdEllipsoid( rotation(Z_AXIS, -0.2) * (lHeadStart - vec3(0.04, -0.1, -0.105)), vec3(0.065, 0.04, 0.07));\n    float lMouthCavity2 = sdEllipsoid( rotation(Z_AXIS, 0.2) * (lHeadStart - vec3(-0.04, -0.1, -0.105)), vec3(0.065, 0.04, 0.07));\n    float lMouthCavity3 = sdEllipsoid( lHeadStart - vec3(0.0, -0.11, -0.105), vec3(0.07, 0.03, 0.07));\n    lMouthCavity = opSmoothUnion(lMouthCavity, lMouthCavity2, 0.03);\n    lMouthCavity = opSmoothUnion(lMouthCavity, lMouthCavity3, 0.02);\n    lBody = fOpIntersectionRound(lBody, -lMouthCavity, 0.01);\n    lMouthCavity = max(lBody + 0.001, lMouthCavity) - 0.002;\n    res = opU( res, vec2( lBody, 3.0) );\n    res = opU( res, vec2( lMouthCavity, 6.0) );\n    \n    //Labios\n    float lLabios = sdEllipsoid( lHeadStart - vec3(0.0, -0.09, -0.1), vec3(0.13, 0.08, 0.25));\n    \t  lLabios = opSmoothUnion(lLabios, sdEllipsoid( lHeadStart - vec3(0.0, -0.12, -0.1), vec3(0.12, 0.08, 0.25)), 0.02);\n    lLabios = max(lLabios, lBody);\n    res = opU( res, vec2( lLabios, 2.0) );\n    \n    //Teeth\n    float lTeeth = sdRoundBox(rotation(Z_AXIS, -0.02) * (opMirrorX(lHeadStart) - vec3(0.044, -0.068, -0.14)), vec3(0.01, 0.015*(1.+d.x*.3+d.y*.3), 0.001), 0.012);\n    res = opU( res, vec2( lTeeth, 3.0 ) );\n    \n    //Tripa\n    float lTripa = sdEllipsoid( pos - vec3(0.0, 0.27, -0.1), vec3(0.12, 0.145, 0.12));\n    lTripa = max(lTripa, lBody);\n    res = opU( res, vec2( lTripa, 2.0) );\n    \n    //Inner Ears\n    float lInnerEars = sdRoundCone( lEarsPos - vec3(0.07, 0.18, 0.0), 0.03, 0.05, 0.11 );\n    float lInnerEarsCutter =  sdBox(lEarsPos -  vec3(0.09, 0.26, -0.12), vec3(0.1, 0.15, 0.1));\n    \t  lInnerEarsCutter =  min(lInnerEarsCutter, sdBox(lEarsPos -  vec3(0.09, 0.26, 0.1), vec3(0.1, 0.15, 0.1)));\n    \t  lInnerEars = max(lInnerEars, -lInnerEarsCutter);\n        //sdEllipsoid( lEarsPos - vec3(0.09, 0.26, -0.02), vec3(0.04, 0.08, 0.03));\n    lInnerEars = max(lInnerEars, lBody);\n    res = opU( res, vec2( lInnerEars, 2.0) );\n    //Eyes\n    vec3 lEyePos = opMirrorX(lHeadStart) - vec3(0.1, 0.0, -0.17);\n    lEyePos.y*=.5+.5*fract(d.x*.5+d.y*.5);\n    float lEyelids = sdSphere( lEyePos, 0.036 );\n    float \tlEyeCutter = sdBox( rotation(X_AXIS, 0.2) * lEyePos - vec3(0.0, 0.05, -0.055), vec3(0.05, 0.05, 0.05));\n    \t\tlEyeCutter = min(lEyeCutter, sdBox( rotation(X_AXIS, 0.5) * lEyePos - vec3(0.0, 0.05, -0.055), vec3(0.05, 0.05, 0.05)));\n    lEyelids = fOpIntersectionRound(lEyelids, -lEyeCutter, 0.004);\n    res = opU( res, vec2( lEyelids, 2.0) );\n    \n    float lEyeSpheres = sdSphere( lEyePos, 0.033 );\n    res = opU( res, vec2( lEyeSpheres, 5.0) );\n    //res = opU( res, vec2( lEyeCutter, 4.0) );\n    a=res;\n    \n    return\ta;\n}\n#define ZERO min(iFrame,0)\nvec3  computeNormal(const vec3 pos)\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapScene(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float texelRadius)\n{\n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {\n            if (err < prevErr    ) { res.x = t; prevErr = err; }\n            if (err < texelRadius) break;\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n\nfloat computeAO(vec3 pos, vec3 nor)\n{\n\tfloat  occ = 0.0;\n    float  sca = 1.0;\n    for( int i = 0; i < 5; ++i)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3  aopos = nor * hr + pos;\n        float dd = mapScene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    \n}\n\n//\tImproved soft shadows.\n//\tOriginal author: iq (using algorithm proposed by Sebastien Aaltonen).\n//\tSource: //https://www.shadertoy.com/view/lsKcDD\nfloat computeSoftShadow(const vec3 ro, const vec3 rd, const float tmin, const float tmax, float k)\n{\n\tfloat res  = 1.0;\n    float t    = tmin;\n    float ph   = 1e10; // Big, such that y = 0 on the first iteration.\n    \n    for (int i = 0; i < 32; ++i)\n    {\n\t\tfloat h = mapScene(ro + rd * t).x;\n        {\n            float y = h * h / (2.0 *  ph);\n            float d = sqrt(h * h - y * y);\n            res = min(res, 10. * d / max(0., t - y));\n            ph  = h;\n        }\n        t += h;\n        if ((res < kEpsilon) || (t > tmax)) \n            break;\n    }\n    return clamp(res, 0., 1.);\n}\nfloat sq(float a) { return (a * a); }\nfloat computeBRDF (vec3 pos, vec3 nor, vec3 ro, vec3 rd, mat4 mat, mat4 lit)\n{\n    float rgh  = mat[1].x;\n    vec3  h    = normalize(-rd + lit[3].xyz);\n    float rsq  = max(.001, sq(rgh));\n    vec3 terms = vec3\n    (\n        (rsq * rsq / (kPi * sq((sq(rsq) - 1.) * sq(clamp(dot(mat[3].xyz, h), 0., 1.)) + 1.))), // Distribution.\n        (mat[1].y + (1. - mat[1].y ) * (pow((1.  - clamp(dot(h, -rd), 0., 1.)), 5.))), // Fresnel.\n        (sq(1. / (dot(h , lit[3].xyz) * (1. - rsq *.5) + rsq * .5))) // Geometry.\n    );\n\treturn\t(terms.x * terms.y * terms.z / kPi);\n}\n\nvec4  computeColor(vec3 pos, vec3 nor, vec3 ro, vec3 rd, mat4 mat)\n{\n    vec3  col  = vec3(0), diffuse, ref = reflect(rd, nor);\n    vec4  amb  = vec4(0), res;\n    for (int i = 0; i < kNumLights; ++i)\n    {\n\t\tmat4  lit  = light(i, pos, ref);\n\t    float spe  = computeBRDF(pos, nor, ro, rd, mat, lit);\n\t    diffuse    = mix(mat[0].xyz  * clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.) * (1. - mat[1].z), mat[0].xyz, mat[0].w);\n\t    col += mix(lit[1].xyz , vec3(1), mat[0].w) * (diffuse \t\t// Diffuse lighting.\n\t        +  (((1. - mat[1].z) + mat[1].z *  mat[0].xyz)) * spe); // Specular light.\n\t    if (i < kNumCasterLights)\n      \t  col *= computeSoftShadow(pos, lit[3].xyz, kEpsilon, kFarPlaneDist, .5); // Soft shadowing.\n    }\n    col += mat[0].xyz * kAmbientColor * kAmbientTerm*computeAO(pos, nor); // Ambient lighting.\n    return  vec4(col, 0);\n}\n\nmat3  computeScreenSpaceIntersection(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec4 result;\n    vec3 pos, nor;\n\n    result  = castRay(ro, rd, length(1. / res));\n    pos     = ro + rd * result.x;// Intersection computation.\n    \n    float coneSize  = tan(kPi / 6.) / (res.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {//\tError correction.\n        pos    -= rd * (error - mapScene(pos).x);\n        error   = coneSize * length(ro - pos);\n    }\n    const float a = (kFarPlaneDist + kNearPlaneDist) / (kFarPlaneDist - kNearPlaneDist);\n\tconst float b = 2.0 * kFarPlaneDist * kNearPlaneDist / (kFarPlaneDist - kNearPlaneDist);\n\tfloat depth   = a + b /-length(ro - pos); // Depth computation.\n    \n    return mat3(pos, computeNormal(pos), result.x, depth, result.z);\n}\n\nmat3  computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid calcRayForPixel(in vec2 fragCoord, in vec2 res, in vec2 mouse, in float t, out vec3 ro, out vec3 rd)\n{\n    vec2  uv = fragCoord / res;\n\tvec2  p  = (-res + 2.0 * fragCoord) / res.y;\n    float h  = t * .5;\n    float r  = sin(t * .1) * .5 + .5;\n    \n    vec2 mo = mouse.xy/res.xy;\n    mo=vec2(0);\n\tfloat time = 15.0 + t*1.5-2.5;\n\n    // camera\t\n    vec3 ta = vec3( 0, .5, 0 );\n     ro = vec3(1.2*cos(0.1*time + 6.0*mo.x), .75 + 2.0*mo.y, -5.5);    \n\t/*    \n    vec3  ta = vec3(-ro.x, 0., -ro.z);\n    ro \t\t = ro * vec3(r, 1, r);\n    */\n    mat3  ca = computeCameraMatrix(ro, ta, 0.0);\n    rd       = ca * normalize(vec3(p.xy,  2.0));\n}\n\n//\tAA checkerboard texture.\n//\tOriginal author: iq.\n// \tSource: https://www.shadertoy.com/view/llffWs\nvec3  pri(in vec3 x)\n{\n    vec3    h = fract(x /  2.0)- 0.5;\n    return \tx * 0.5 + h * (1.0 - 2.0 * abs(h));\n}\n\nfloat checkersTextureGradTri(in vec3 p, in vec3 ddx, in vec3 ddy)\n{\n    vec3 \tw = max(abs(ddx), abs(ddy)) + 0.01;       \t\t\t\t// Filter kernel.\n    vec3 \ti = (pri(p + w) - 2.0 * pri(p) + pri(p - w)) / (w * w); // Analytical integral (box filter).\n    return \t0.5 -0.5 * i.x  * i.y * i.z;                  \t\t\t// XOR pattern.\n}\n\n//\tComputes the material to use on opaque rendering.\nmat4  material(in vec2 fragCoord, in vec2 res, in vec2 mouse, in float t, in int matID, in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor)\n{\n    mat4 mat;\n    \n    if (0 == matID)\n    {\n\t\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\t\tcalcRayForPixel(fragCoord, res, mouse, t, ro, rd);\n\t\tcalcRayForPixel(fragCoord + vec2(1.0,0.0), res, mouse, t, ddx_ro, ddx_rd);\n\t\tcalcRayForPixel(fragCoord + vec2(0.0,1.0), res, mouse, t, ddy_ro, ddy_rd);    \n\t\t           \n\t\tvec3 ddx_pos = ddx_ro - ddx_rd * dot(ddx_ro - pos, nor) / dot(ddx_rd, nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd * dot(ddy_ro - pos, nor) / dot(ddy_rd, nor);    \n\t\tvec3 uvw     = 0.5 * pos;\n\t\tvec3 ddx_uvw = 0.5 * ddx_pos-uvw;\n\t\tvec3 ddy_uvw = 0.5 * ddy_pos-uvw;\n        \n        mat[0] = vec4(0.1, 0.1, 0.2, 0.0) * step(checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw),.5) + .1 * texture(iChannel2, rd); // Albedo.\n        mat[1] = vec4(0.3, 0.5, 0.0, 0.0); // Roughness/Fresnel/Metalness.\n        mat[2] = vec4(0.0, 0.0, 0.0, 0.0); // Reserved.\n        mat[3] = vec4(nor, 0.0);           // Normal.\n    }\n    else\n\tif (2 == matID)\n    {//\tSkin.\nmat[0] = vec4(vec3(1.0, 0.807, 0.705) * 0.3, 0);\nmat[1] = vec4(.5, .9, .0, .0);\n        mat[3] = vec4(nor, 0.0);        \n    }\n    else\n    if (3 == matID)\n    {// White hair.\nmat[0] = vec4(vec3(0.980, 0.980, 0.980) * 0.9, 0);\nmat[1] = vec4(.8, .9, .0, .0);\n                mat[3] = vec4(nor, 0.0);\n    }\n    else\n    if (4 == matID)\n    {// Black.\nmat[0] = vec4(vec3(0.0, 0.0, 0.0), 0);\nmat[1] = vec4(.5, .5, .0, .0);\n                mat[3] = vec4(nor, 0.0);\n    }\n    else\n    if (5 == matID)\n    {// Eyeballs.\n        vec3 lFrontVector = -Z_AXIS;\n        vec3 lDiffVector =  nor;\n        \n        float lOuterCircle =  smoothstep(0.83, 0.9, dot(lDiffVector,  lFrontVector + vec3(0.0, -0.2, 0.0)));\n        float lBlueCircle =  smoothstep(0.82, 0.84, dot(lDiffVector,  lFrontVector + vec3(0.0, -0.2, 0.0)));\n        lOuterCircle = 1.0 - max(lOuterCircle, 1.0 - lBlueCircle);\n        float lBlackCircle = 1.0 - smoothstep(0.94, 0.98, dot(lDiffVector, lFrontVector + vec3(0.0, -0.2, 0.0)));\n        //float lBlackCircle = 1.0 - smoothstep(0.94, 0.98, dot(lDiffVector, lFrontVector + vec3(0.0, -0.2, 0.0)));\n        vec3 lInner = mix(vec3(4.0, 1.0, 1.0) * 0.6, vec3(0.01, 0.2, 1.0), lBlueCircle) * lBlackCircle;\n        mat[0] = vec4(mix(lInner, vec3(0.0, 0.0, 0.0), lOuterCircle), 0);\n        mat[1] = vec4(.2,.5,.0,.0);\n        mat[3] = vec4(nor, 0.0);        \n    }\n    else\n    if (6 == matID)\n    {// Mouth hole.\nmat[0] = vec4(vec3(0.745, 0.070, 0.062) * 0.2, 0);\n        mat[1] = vec4(.9,.5,.0,.0);\n                mat[3] = vec4(nor, 0.0);\n    }\n    else\n    if (7 == matID)\n    {// Teeth.\nmat[0] = vec4(vec3(0.980, 0.980, 0.980) * 0.7, 0);\n        mat[1] = vec4(.5,.5,.0,.0);\n                mat[3] = vec4(nor, 0.0);\n    }\n    if (100 == matID)\n    {// White hair.\nmat[0] = vec4(vec3(0.980, 0.980, 0.980) * 0.9, 0);\nmat[1] = vec4(.2, .9, .0, .0);\n                mat[3] = vec4(nor, 0.0);\n    }\n        \n    return \tmat;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    gSongTime = kSongBpm / 60. * iTime / 4.;\n    vec3  ro, rd;\n    calcRayForPixel(fragCoord, iResolution.xy, iMouse.xy, iTime, ro, rd);\n    mat3  res = computeScreenSpaceIntersection(iResolution.xy, ro, rd);\n    vec3  pos = res[0];\n    vec3  nor = res[1];\n    float dis = res[2].x;\n    float dep = res[2].y;\n    int   mid = int(res[2].z);\n    vec4  col = vec4(0);\n\tvec4  bkg = vec4(bgColor(iTime, rd), 0);\n    if (dis  >= kFarPlaneDist)\n    {//\tRenders the sky color.\n    \tcol   = bkg;\n    }\n    else\n    {//\tRenders the material.\n        mat4 mat = material(fragCoord, iResolution.xy, iMouse.xy, iTime, mid, ro , rd, pos, nor);\n        col   = computeColor (pos, nor, ro, rd , mat);\n        col+= mix(vec4(0.8,0.8,0.9,1.0), col, .5+.5*pow(clamp(dot(nor,-rd), 0., 1.), .5));\n\t\tcol   += col.w * vec4(bgColor(iTime, reflect(rd, nor)), 0); // Reflects the sky.\n        col = mix(col, bkg, pow(dis/kFarPlaneDist,.4));\n    }\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * @buffer\tBuffer B\n * @brief   Merge with filmic pass.\n */\n\nconst float kToneMapA =.15;\nconst float kToneMapB =.50;\nconst float kToneMapC =.10;\nconst float kToneMapD =.20;\nconst float kToneMapE =.02;\nconst float kToneMapF =.30;\nconst float kToneMapW =1.4;\nfloat hashf(float n) { int q = int(n); return float((0x3504f333 * q * q + q) * (0xf1bbcdcb * q * q + q)) * (2. /  8589934592.) + .5; }\nvec4 tonemap(vec4 x)\n{\n   return ( (x * (kToneMapA * x + kToneMapC * kToneMapB) + kToneMapD * kToneMapE)  /\n            (x * (kToneMapA * x + kToneMapB            ) + kToneMapD * kToneMapF)) -\n            kToneMapE / kToneMapF;\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\nvec2 gTexelSize = 1./iResolution.xy;\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    vec2 qv  = uv * 2. - 1.;\n\tvec4 col = texture(iChannel0, uv);\n    \n    col = tonemap(col) / tonemap(kToneMapW + .05 * textureLod(iChannel0, vec2(0.5), 9.0)); // Tonemapping.\n    col = col* (1./ pow(1. + pow(sqrt(dot(qv, qv)) * .3, 3.), 58.)); // Vignetting.\n    col = pow(col, vec4(1./2.2)); // Gamma correction.\n\tcol = .75*col + .25 * col * pow(hashf(fragCoord.x * fragCoord.y + iTime * 50.), 0.05); // Noise (to emulate film grain).    \n    \n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}