{
    "Shader": {
        "info": {
            "date": "1512494096",
            "description": "Methodology for drawing isolines + dots of constant thickness in screenspace for procedural transforms (here, Moebius Spirals).\nGrey version are lines in final space (distorted in screen space).",
            "flags": 0,
            "hasliked": 0,
            "id": "Xlffzj",
            "likes": 17,
            "name": "screenspace Moebius Spiral",
            "published": 3,
            "tags": [
                "spiral",
                "mobius",
                "complex",
                "screenspace",
                "tuto",
                "weave"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 894
        },
        "renderpass": [
            {
                "code": "// === Drawing transformed-space isolines using screen-space metrics ================\n// Inspired by \"Mobius Weave\" by Shane. https://shadertoy.com/view/XtsBRS\n// Cleaning and application here: https://www.shadertoy.com/view/llsfRj\n// Conformal version here: https://www.shadertoy.com/view/MllBzj\n\n#define UNIQ // if on, inverse gives one unique solution. Also, dist more robust !\n#define S(v) smoothstep(2./iResolution.y, 0., v )\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1,z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime/32.;\n\tfloat d = length(p);\n\treturn mat2(n,1, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- inverse transforms\nfloat k; // for tests\nvec4 iMobius(vec2 p, vec2 z1, vec2 z2, float s)      // s = -1 or 1, 2 solution for each\n{   float sb = 1.;\n#ifdef UNIQ                                          // ... or if activating signs,\n    s *= sign(p.x); sb = sign(p.y);                  // unique sol: s=1,x1,y1 otherwise 4\n#endif\n    float l = length(p), t = p.y/p.x,                // solve  u = v*l ; tan(u,v) = p.y/p.x\n          c = s / sqrt(1.+t*t),                      // c = cos(atan( ) )\n        v = length(z1-z2) / sqrt( 1.+ l*l -2.*l*c ), // c = (u²+v²-|z1z2|² ) / 2uv\n        u = v*l;                                   \n    vec2  a = 2.*(z1-z2);                            // solve |P-z1| = u ; |P-z2| = v\n    float b = u*u-v*v + dot(z2,z2)-dot(z1,z1);       // ||²-||²: a.P + b = 0\n    // y = -( b + a.x* x ) / a.y                     // normalize by a.y\n    b /= a.y; a /= a.y;                              // ( in Shane example a.y was = 0 ! )\n    float A = 1. +  a.x*a.x,                         //  |P-z1|² = u² , P = (x,y)\n          B =     2.* b*a.x -2.*dot(vec2(1,-a.x),z1),\n          C =           b*b +2.*b*z1.y + dot(z1,z1) - u*u,\n          D = max(0., B*B - 4.*A*C),\n         x1 = (-B+sb*sqrt(D))/(2.*A), y1 = -( b + a.x*x1 ),\n         x2 = (-B-sb*sqrt(D))/(2.*A), y2 = -( b + a.x*x2 );\n    k += 1./ (.1*abs(t)); // for tests\n // if (abs(A)<1e-5) { x1 = x2 = -C/B; y1 = y2 = -( b + a.x*x1 ) / a.y; } // degenerate case\n\treturn vec4(x1,y1, x2,y2);                       // 2 solutions per s\n}\n// horizontal red/blue glitches at t ~ 0 ( or D ~ 0 ) -> solved by #UNIQ\n// vertical red/blue glitches at t ~ inf ( or c ~ 0 )\n\nvec2 ispiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n    p = inverse(mat2(n,1, spiral,-zoom)) * (p-phase) ;\n    p.x = (p.x - iTime/32.) * 6.283;             // ( p.x, p.y )  = ( a, log(d) )\n    return exp(p.y) * vec2(cos(p.x),sin(p.x)) + offs;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),  // in Shane example Z1.y=Z2.y was causing a degenerescence\n     Z2 = vec2(.375, -.125);\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n}\nfloat DrawInvMobiusSpiral(vec2 q, vec2 uv0, float r) // total inverse transform + draw iso-X\n{\n    vec4 v; float s = 0.;\n    q = ispiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n    v = iMobius(q, Z1, Z2, 1.);  \n#ifdef UNIQ\n    return S(length(uv0-v.xy) - r );\n#else\n    s += S(length(uv0-v.xy) - r ); // note that only the quadrant of uv0 contributes\n    s += S(length(uv0-v.zw) - r ); // (but costly to 1st determine it: transfo + inverse + tests )\n    v = iMobius(q, Z1, Z2, -1.);   \n    s += S(length(uv0-v.xy) - r ); \n    s += S(length(uv0-v.zw) - r ); \n\treturn s;\n#endif\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n\tvec2 R = iResolution.xy,\n        uv0 = (U -.5*R) / R.y,\n    uv = MobiusSpiral(uv0);\n     \n    O -= O;\n    vec2 p = uv*4., q;\n  //O += .5*DrawInvMobiusSpiral(uv, uv0, .01 ); return; // check inverse ok ( = grey + white overlaps if !UNIQ )\n\n\n    if ( mod(iTime,2.) > 1. ) {\n        p = abs(fract(p+.5)-.5);                       // --- isolines in Moebius space\n        O += .5*float(min(p.x,p.y)<.1);\n        return;\n    }\n    \n    // --- to get iso-X in screenspace, \n    //     take it in final space ( floor(...) ),  inverse it, and draw distance to the result.\n    const int N = 2, dN = N/2-1;\n    for (int i=0; i<N; i++) {\n        //q = floor(p)/4.;\n        q = vec2( floor(p.x+float(i-dN)), p.y ) / 4.;  // --- H isolines in screen space\n        O.r += DrawInvMobiusSpiral(q, uv0, .005 );\n    \n        q = vec2( p.x, floor(p.y+float(i-dN)) ) / 4.;  // --- V isolines in screen space\n        O.b += DrawInvMobiusSpiral(q, uv0, .005 );\n    \n        for (int j=0; j<N; j++) {\n            q = floor(p+vec2(i-dN,j-dN) ) / 4.;        // --- dots in screen space\n            O.g += DrawInvMobiusSpiral(q, uv0, .02 );\n        }\n    }\n    //O += k/1e4; // for tests\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}