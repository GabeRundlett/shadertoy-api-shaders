{
    "Shader": {
        "info": {
            "date": "1679737319",
            "description": "A simple grass shader derived from the stunning \"Rolling Hills\": https://www.shadertoy.com/view/Xsf3zX . Check out the accompanying blog post here: https://blog.42yeah.is/rendering/2023/03/25/grass.html",
            "flags": 0,
            "hasliked": 0,
            "id": "mdtSD8",
            "likes": 5,
            "name": "Simple Grass",
            "published": 3,
            "tags": [
                "grass"
            ],
            "usePreview": 0,
            "username": "42yeah",
            "viewed": 444
        },
        "renderpass": [
            {
                "code": "vec2 hash22(vec2 uv)\n{\n    return fract(sin(vec2(dot(uv, vec2(13.1323, 57.81)), dot(uv, vec2(9.8173, 17.2552)))) * 10580.1);\n}\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(13.1323, 57.81))) * 10580.1);\n}\n\nfloat perlin(vec2 uv) {\n    vec2 u = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = smoothstep(0.0, 1.0, f);\n    \n    vec2 a = hash22(u);\n    vec2 b = hash22(u + vec2(1.0, 0.0));\n    vec2 c = hash22(u + vec2(0.0, 1.0));\n    vec2 d = hash22(u + vec2(1.0, 1.0));\n    \n    return mix(mix(dot(a, -f), dot(b, vec2(1.0, 0.0) - f), s.x),\n        mix(dot(c, vec2(0.0, 1.0) - f), dot(d, vec2(1.0, 1.0) - f), s.x), s.y);\n}\n\nvec2 voronoi(vec2 uv)\n{\n    vec2 f = fract(uv);\n    vec2 u = floor(uv);\n    \n    float closest = 100.0;\n    float id = 0.0;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 d = vec2(float(x), float(y));\n            vec2 nu = u + d;\n            vec2 p = hash22(nu);\n            float dist = distance(f, p + d);\n            if (dist < closest)\n            {\n                closest = dist;\n                id = hash(nu);\n            }\n        }\n    }\n    return vec2(1.0 - closest, id);\n}\n\n//\n// Voronoi adjusted for height.\n// The return value is a fake SDF - if the value is negative, that indicates \n// it is inside the grass. Otherwise, it is outside the grass.\n//\nvec3 voronoi_3d(vec3 p)\n{\n    float grassHeight = 1.0;\n    \n    vec2 uv = p.xz * 8.0;\n    float id = voronoi(uv).y;\n    float windyness = max(0.0, p.y * p.y * (0.5 + id * 0.5) * 5.0) * 0.5;\n    \n    // Wrap the space using time and y\n    uv = vec2(uv.x + windyness * sin(0.66 * iTime), uv.y + windyness * cos(0.5 * iTime));\n    vec2 vor = voronoi(uv);\n    //\n    // Warp the y so the grass becomes non-linear\n    //\n    float boundary = mix(0.0, 1.44, max(p.y / grassHeight, 0.0));\n    // When y is 0, boundary should be 0 as well\n    // when y is .5, boundary should be well over the grass\n    \n    return vec3(boundary - vor.x, vor.x - boundary, vor.y);\n}\n\nfloat ball(vec3 p, out vec3 mat)\n{\n    mat = vec3(1.0, 0.5, 0.0);\n    return length(p) - 1.0;\n}\n\nfloat perlin_height(vec2 uv)\n{\n    return perlin(uv * 0.1) * 5.0 + perlin(uv * 0.01) * 40.0;\n}\n\nfloat ground(vec3 p, out vec3 mat)\n{\n    mat = vec3(0.2, 0.4, 0.1); \n//    return p.y - perlin_height(p.xz);\n    return p.y - 1.0;\n}\n\nfloat map(vec3 p, out vec3 mat)\n{\n    vec3 minMat = vec3(1.0, 0.0, 1.0);\n    float minDist = ground(p, minMat), dist;\n\n    mat = minMat;\n    return minDist;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 trash;\n    vec2 eps = vec2(0.001, 0.0);\n    float t = map(p, trash);\n    return normalize(vec3(t - map(p - eps.xyy, trash), \n        t - map(p - eps.yxy, trash),\n        t - map(p - eps.yyx, trash)));\n}\n\nbool march(vec3 ro, vec3 rd, out float t, out vec3 mat)\n{\n    t = 0.0;\n    mat = vec3(0.0);\n    for (int i = 0; i < 200; i++)\n    {\n        vec3 p = ro + t * rd;\n        float dt = map(p, mat);\n        if (dt < 0.001)\n        {\n            return true;\n        }\n        t += dt;\n    }\n    return false;\n}\n\nvec4 grassBlades(vec3 ro, vec3 rd, float t)\n{\n    vec3 grassColor = vec3(0.0);\n    vec3 base = vec3(0.0, -0.4, 0.0);\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + t * rd + base;\n//        float ph = perlin_height(p.xz);\n//        p.y -= ph;\n        \n        vec3 grass = voronoi_3d(p);\n        t += max(0.001, t * 0.04);\n        //\n        // Mix with color\n        //\n        if (grass.x > 0.0)\n        {\n            continue;\n        }\n        float den = clamp(min(grass.y, 1.0 - color.a), 0.0, 1.0);\n        //\n        // The denser it is, the darker it is\n        //\n        float color_dense = 1.0 - den;\n        color_dense = clamp(color_dense + p.y - 0.64, 0.0, 1.0);\n        \n        vec3 bladeColor = mix(vec3(0.0, 0.0, 0.0), vec3(0.3, 0.9, 0.2), color_dense);\n        //\n        // Should be whiter at the top\n        //\n        bladeColor = mix(bladeColor, vec3(1.0, 1.0, 1.0), clamp(p.y - 0.45, 0.0, 1.0));\n        \n        color.rgb = color.rgb + bladeColor * den;\n        color.a += den;\n        if (color.a > 0.99)\n        {\n            break;\n        }\n    }\n    \n//    vec3 nor = calcNormal(ro);\n//    vec3 lig = max(dot(nor, vec3(1.0, 1.0, 0.0)), 0.0) * vec3(0.2, 1.0, 0.0);\n//    color = vec4(lig, 1.0);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= aspect;\n    vec2 camAngle = vec2(sin(iTime * 0.1) * 0.1, cos(iTime * 0.08) * 0.2);\n    vec3 ro = vec3(0.0, 1.8, iTime * 0.01);\n\n    vec3 front = normalize(vec3(cos(camAngle.x) * sin(-camAngle.y), sin(camAngle.x), cos(camAngle.x) * cos(-camAngle.y)));\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0))); \n    vec3 up = normalize(cross(right, front)); \n    \n    mat3 lookAt = mat3(right, up, front);\n    vec3 rd = lookAt * normalize(vec3(uv.x, uv.y, 2.0));\n    \n    // March ahead!\n    float t = 0.0;\n    vec3 mat = vec3(0.0);\n    bool intersect = march(ro, rd, t, mat);\n    vec3 color = vec3(0.0);\n    \n    vec3 skyColor = vec3(mix(vec3(0.5, 0.9, 0.9), vec3(0.1, 1.0, 1.0), rd.y));\n    if (intersect)\n    {\n        vec4 grassColor = grassBlades(ro + t * rd, rd, t * 0.01);\n        color = mix(mat, grassColor.rgb, grassColor.a);\n        color = pow(color, vec3(0.4545));\n        // Fog\n        color = mix(color, skyColor, min(1.0, max(t - 100.0, 0.0)));\n    }\n    else \n    {\n        color = skyColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}