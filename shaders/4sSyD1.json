{
    "Shader": {
        "info": {
            "date": "1493922090",
            "description": "Sphere in Yayoi Kusama's Style\nRemixed from Milo Yip's [url]https://www.shadertoy.com/view/4tKSDm[/url]\nOther references for Vasarely: [url]https://www.shadertoy.com/results?query=vasarely[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSyD1",
            "likes": 6,
            "name": "Yayoi Kusama Sphere",
            "published": 3,
            "tags": [
                "3d",
                "tutorial",
                "sphere",
                "halftone",
                "yayoi",
                "kusama"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "/** \n * Yayoi Kusama Sphere\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Demo: https://www.shadertoy.com/view/4sSyD1\n * \n * Halftone Sphere remixed from Milo Yip's https://www.shadertoy.com/view/4tKSDm\n **/\n\nconst float SPHERE_DIAMETER = 0.9; \nconst float PI = 3.1415926535897932;\nconst float PI_2 = PI / 2.0; \n\nmat3 rotationXY(in vec2 angle);\nvec3 render(in vec2 p, in mat3 rot);\n\nvec3 tutorial(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // step 0: define the screen coordinates p\n    vec2 p = (fragCoord.xy / iResolution.xy - 0.5) * 2.0 * vec2(iResolution.x / iResolution.y, 1.0); \n    \n    vec3 col = (length(p) <= 0.9) ? vec3(0.0) : vec3(1.0); \n   \t\n    // step 1: normal vector, assuming the n_z to outwards the screen, n_x = p_x, n_y = p_y, n_z = sqrt(1-p_x^2-p_y^2)\n    vec3 n = vec3( p, sqrt(1.0 - dot(p, p)) ); \n    // visualize the normal vector, [-1, 1]\n    // col = n; \n    col = vec3(n * 0.5 + 0.5); \n    \n    // step 2: define the spherical coordinates, [-1, 1]\n    vec2 s = vec2(acos(n.z), atan(n.y, n.x)) / PI; \n    col = vec3(s * 0.5 + 0.5, 0.0); \n    \n    // step 3: divide the sphere into many squares\n    uv = fract(s * vec2(30.0, 20.0));\n    col = vec3(uv, 0.0);\n    \n    // step 4: texture mapping with circles\n    float r = 0.4;\n    col = length(uv - 0.5) < r ? vec3(1.0) : vec3(0.0); \n    \n  \t// step 5: change the radius of the circles\n    r = ceil(s.x * 30.0) / 45.0;\n    col = length(uv - 0.5) < r ? vec3(1.0) : vec3(0.0); \n    \n    // step 6: define the rotation matrix based on the mouse\n    mat3 rot = rotationXY( vec2(iMouse.yx / iResolution.yx) * vec2(PI, -2.0 * PI) + vec2(-1.0, 1.0) * 0.5 * PI ); \n\n    const int KERNEL_RADIUS = 2;\n    const int KERNEL_SIZE = (KERNEL_RADIUS * 2) + 1; \n                          \n    // step 7: integrate all code into a function named render, and conduct super sampling\n    vec3 sum = vec3(0.0); \n    col = vec3(0.0); \n    for (int x = -KERNEL_RADIUS; x <= KERNEL_RADIUS; ++x) {\n        for (int y = -KERNEL_RADIUS; y <= KERNEL_RADIUS; ++y) {\n            sum += render( p + vec2(x, y) / (2.0 * iResolution.xx), rot); \n        }\n    }\n    col = sum / 25.0; \n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec3 col = tutorial(fragColor, fragCoord); \n    fragColor = vec4(col, 1.0); \n}\n\n// rotation matrix from step 6, forked from https://www.shadertoy.com/view/4tKSDm\nmat3 rotationXY(in vec2 angle) {\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\treturn mat3(\n\t\tc.y, 0.0, -s.y,\n\t\ts.y * s.x, c.x, c.y * s.x,\n\t\ts.y * c.x, -s.x, c.y * c.x\n\t);\n}\n\n// integration from step 7\nvec3 render(in vec2 p, in mat3 rot) {\n    if (length(p) > SPHERE_DIAMETER) return vec3(1.0); \n    vec3 n = rot * vec3(p, sqrt(1.0 - dot(p, p)));\n    vec2 s = vec2(acos(n.z), atan(n.y, n.x)) / PI;\n    vec2 uv = fract(s * vec2(30.0, 30.0));\n    float r = ceil( (1.0 - abs(s.x * 2.0 - 1.0)) * 15.0) / 45.0;\n    // r = ceil(s.x * 30.0) / 45.0;\n    vec3 col = length(uv - 0.5) < r ? vec3(0.0) : vec3(0.86, 0.68, 0.1);\n    \n    // step 8, add light\n    vec3 lightPos = vec3(2.0, 2.5, 4.0);\n    col += col * vec3(1.0) * max(dot(n, normalize(lightPos - n)), 0.0);\n    \n    return col; \n}\n\n// Dr. Neyret has a code-golf version as a step 8:\n/*\nvoid mainImage(out vec4 O,  vec2 U) {\n    vec2 R = iResolution.xy,\n         p = (U+U - R) / R.y,\n         m = iMouse.xy / R,\n         a = 3.14*vec2(m.y-.5, .5-2.*m.x),\n         c = cos(a), s = sin(a);\n    vec3 n = mat3( c.y,          0,      -s.y,\n\t\t           s.y * s.x,  c.x, c.y * s.x,\n\t\t           s.y * c.x, -s.x, c.y * c.x\n\t            )\n             * vec3( p, sqrt(1.-dot(p,p)) );\n    O -= O;\n    O += n==n ?  s = 9.55* vec2(acos(n.z), atan(n.y, n.x)), // 9.55 = 30/3.14\n                 ceil(s.x)/2. - 22.*length(fract(s)-.5)\n               : 1. ;   \n}\n*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}