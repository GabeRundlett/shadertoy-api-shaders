{
    "Shader": {
        "info": {
            "date": "1621740674",
            "description": "Working on ways to solve quintic equations. I'm hoping to implement the exact solution (not necessarily \"in radicals\"). Idea for testing based on mattz's analytic quartic solver shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nd23Dt",
            "likes": 9,
            "name": "Solving Quintic Equations Study",
            "published": 3,
            "tags": [
                "math",
                "equation",
                "quintic",
                "polynomial"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "//#define CONSTRUCT_FROM_ROOTS\n#define METHOD 3\n\n// Arrays seem buggy so I tried using structs\nstruct GeneralQuintic { float a; float b; float c; float d; float e; float f; };\nstruct ReducedQuintic { float p; float q; float r; float s; float offs; };\nstruct Float5 { float _0; float _1; float _2; float _3; float _4; };\nstruct Roots5 { int nroots; Float5 roots; };\n\n// Hack to prevent loop unrolling (linear search is heavy on it)\n#define ZERO min(iFrame, 0)\n\n// Getters and setters for every field! XD See https://www.youtube.com/watch?v=-AQfQFcXac8\n// I don't care too much for these so I've squashed them into single lines to keep them out of the way\nfloat get(in Float5 arr, in int idx) { switch(idx) { case 0: return arr._0; case 1: return arr._1; case 2: return arr._2; case 3: return arr._3; case 4: return arr._4; } }\nvoid set(inout Float5 arr, in int idx, in float val) { switch(idx) { case 0: arr._0 = val; case 1: arr._1 = val; case 2: arr._2 = val; case 3: arr._3 = val; case 4: arr._4 = val; } }\n\n// Evaluates the quintic equation\nfloat evalQuintic(in float x, in GeneralQuintic q) {\n    return ((((q.a * x + q.b) * x + q.c) * x + q.d) * x + q.e) * x + q.f;\n}\n\nfloat evalReducedQuintic(in float x, in ReducedQuintic q) {\n    return (((x * x + q.p) * x + q.q) * x + q.r) * x + q.s;\n}\n\n// Evaluates the derivative of the quintic equation\nfloat evalQuinticPrime(in float x, in GeneralQuintic q) {\n    return (((5.0 * q.a * x + 4.0 * q.b) * x + 3.0 * q.c) * x + 2.0 * q.d) * x + q.e;\n}\n\nfloat evalReducedQuinticPrime(in float x, in ReducedQuintic q) {\n    return ((5.0 * x * x + 3.0 * q.p) * x + 2.0 * q.q) * x + q.r;\n}\n\n// Generates coefficients for a quintic with five real roots\n// The idea is to construct five linear factors that share the roots and multiply them out\n// The choice is somewhat arbitrary but I chose:\n// (x - x1)(x - x2)(x - x3)(x - x4)(x - x5)\nvoid quinticFromRoots(in float x1, in float x2, in float x3, in float x4, in float x5, inout GeneralQuintic q) {\n    q.a = 1.0;\n    q.b = -x1 - x2 - x3 - x4 - x5;\n    q.c = x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4) + (x1 + x2 + x3 + x4) * x5;\n    q.d = -(x1 + x2) * x3 * x4 - x1 * x2 * (x3 + x4) - (x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4)) * x5;\n    q.e = x1 * x2 * x3 * x4 + ((x1 + x2) * x3 * x4 + x1 * x2 * (x3 + x4)) * x5;\n    q.f = -x1 * x2 * x3 * x4 * x5;\n}\n\n// Eliminates the x^4 term and divides by the leading coefficient\n// The resulting equation has roots offset from the original by -b/5a\n// and has the form: y^5 + py^3 + qy^2 + ry + s\n// TODO: simplify out lots of reused values\nReducedQuintic tschirnhausLinear(in GeneralQuintic eq) {\n    float a = eq.a, b = eq.b, c = eq.c, d = eq.d, e = eq.e, f = eq.f;\n    b /= a, c /= a, d /= a, e /= a, f /= a;\n    float p = c - 2.0 * b * b / 5.0;\n    float q = d - 3.0 * b * c / 5.0 + 4.0 * b * b * b / 25.0;\n    float r = e - 2.0 * b * d / 5.0 + 3.0 * b * b * c / 25.0 - 3.0 * b * b * b * b / 125.0;\n    float s = f -       e * b / 5.0 +       b * b * d / 25.0 -       b * b * b * c / 125.0 + 4.0 * b * b * b * b * b / 3125.0;\n    return ReducedQuintic(p, q, r, s, b / 5.0);\n}\n\n// Linear searching method for solving a quintic equation, pretty low quality\nRoots5 solveQuinticLinSearch(in GeneralQuintic eq, in float bmin, in float bmax, in float epsilon, in bool wrap, in int searches, in int iters) {\n    Roots5 roots = Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    float interval = 1.0 / float(searches);\n    float start = 0.0;\n\n    // Take equally spaced steps over the interval\n    for (int search=ZERO; search < searches; search++) {\n        // Apply newton-raphson\n        float root = mix(bmin, bmax, start);\n        for (int nrIter=0; nrIter < iters; nrIter++) {\n            float nrStep = root -= evalQuintic(root, eq) / evalQuinticPrime(root, eq);\n            if (wrap) root = bmin + mod(root - bmin, bmax - bmin); // Wrap to stay in the interval\n            if (abs(nrStep) < epsilon) break; // Potential early out\n        }\n\n        // Make sure this is a unique root (get rid of solutions that converge to the same spot)\n        bool unique = true;\n        for (int n=ZERO; n < roots.nroots; n++) {\n            if (abs(root - get(roots.roots, n)) < epsilon) {\n                unique = false;\n                break;\n            }\n        }\n\n        // Only use this solution if it is nearly a true root and is unique\n        if (abs(evalQuintic(root, eq)) < epsilon && unique) {\n            set(roots.roots, roots.nroots, root);\n            roots.nroots++;\n        }\n\n        // Step forward and take another chance at an early out\n        start += interval;\n        if (roots.nroots == 5) break;\n    }\n\n    return roots;\n}\n\n// Quartic solver from this paper: https://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/auckly29.pdf\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d -   0.5 * b * c + 0.125 * bb * b;\n    float r = e -  0.25 * b * d +         bb * c / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Preliminary root searching guaranteed to converge on the root if it is bracketed\nfloat bisection(in GeneralQuintic eq, in float bmin, in float bmax, in int bisections) {\n    for (int bisection=0; bisection < bisections; bisection++) {\n        float v1 = evalQuintic(bmin, eq), v2 = evalQuintic(bmax, eq);\n        if (abs(v1) > abs(v2)) bmin = 0.5 * (bmin + bmax);\n        else bmax = 0.5 * (bmin + bmax);\n    }\n\n    return 0.5 * (bmin + bmax);\n}\n\n// Converges faster than bisection but sensitive to the starting point, used in the final step\nfloat newton(in GeneralQuintic eq, in float x0, in float bmin, in float bmax, in int newtonSteps) {\n    float backup = x0;\n    for (int nrStep=0; nrStep < newtonSteps; nrStep++) {\n        x0 -= evalQuintic(x0, eq) / evalQuinticPrime(x0, eq);\n        if (x0 < bmin || x0 > bmax) return backup; // Early out if newton-raphson goes out of bounds (safe to assume nonconvergence)\n    }\n\n    // Prevent the root from getting messed up by newton-raphson because of big or small slope\n    float v1 = evalQuintic(backup, eq), v2 = evalQuintic(x0, eq);\n    if (abs(v1) < abs(v2)) return backup;\n    else return x0;\n}\n\n// Searches for roots between the critical points (local minima and maxima)\n// Fails when there are no critical points, ex. x^5 + x - 1\nRoots5 solveQuinticBracket(in GeneralQuintic eq, in int bisections, in int newtonSteps) {\n    // Solve for the roots of the derivative (a quartic) to get the critical points\n    vec4 brackets;\n    Roots5 roots = Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    int nBrackets = solveQuartic(5.0 * eq.a, 4.0 * eq.b, 3.0 * eq.c, 2.0 * eq.d, eq.e, brackets);\n\n    // No brackets, failed to find roots\n    // TODO: these cases are pretty simple quintics, look for another root finding solution\n    if (nBrackets == 0) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n\n    // Search for roots between critical points\n    for (int n=0; n < nBrackets - 1; n++) {\n        float brack1 = brackets[n], brack2 = brackets[n + 1];\n        float e1 = evalQuintic(brack1, eq), e2 = evalQuintic(brack2, eq);\n\n        // Bracketed section doesn't cross the x axis, no roots\n        if (!(min(e1, e2) < 0.0 && max(e1, e2) > 0.0)) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n\n        // Apply bisection, then newton-raphson\n        float bmin = min(brack1, brack2), bmax = max(brack1, brack2);\n        set(roots.roots, roots.nroots, newton(eq, bisection(eq, bmin, bmax, bisections), bmin, bmax, newtonSteps));\n        roots.nroots++;\n    }\n\n    // Flip inner bracket on one side to the outside to try capturing roots outside the critical points\n    // Not sure if this is foolproof but it appears to work and make sense\n    float brack1 = 2.0 * brackets[0] - brackets[1], brack2 = brackets[0];\n    float e1 = evalQuintic(brack1, eq), e2 = evalQuintic(brack2, eq);\n    if (!(min(e1, e2) < 0.0 && max(e1, e2) > 0.0)) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    float bmin = min(brack1, brack2), bmax = max(brack1, brack2);\n    set(roots.roots, roots.nroots, newton(eq, bisection(eq, bmin, bmax, bisections), bmin, bmax, newtonSteps));\n    roots.nroots++;\n\n    // Repeat on opposite side\n    brack1 = brackets[nBrackets - 1], brack2 = 2.0 * brackets[nBrackets - 1] - brackets[nBrackets - 2];\n    e1 = evalQuintic(brack1, eq), e2 = evalQuintic(brack2, eq);\n    if (!(min(e1, e2) < 0.0 && max(e1, e2) > 0.0)) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    bmin = min(brack1, brack2), bmax = max(brack1, brack2);\n    set(roots.roots, roots.nroots, newton(eq, bisection(eq, bmin, bmax, bisections), bmin, bmax, newtonSteps));\n    roots.nroots++;\n\n    return roots;\n}\n\nRoots5 solveQuinticPolyDiv(in GeneralQuintic eq, in int newtonSteps) {\n    Roots5 roots = Roots5(1, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    //ReducedQuintic rEq = tschirnhausLinear(eq);\n\n    // TODO: choose better starting point (or is this good enough???)\n    float x1 = -0.2 * eq.b / eq.a; // Inflection point\n    float y1 = abs(evalQuintic(x1, eq));\n\n    // SOSO (Same Opposite Same Opposite) approximation of roots\n    // Roots are approximately solutions to:\n    // ax^5 + bx^4 + cx^3 + dx^2 + ex + f = ax^5 - bx^4 + cx^3 - dx^2 + ex - f\n    // ---> bx^4 + dx^2 + f = 0 ---> b(x^2)^2 + d(x^2) + f = 0\n    // Which is a quadratic in x^2 that has four roots:\n    // x1, x2, x3, x4 = (+/-)sqrt((-d +/- sqrt(d^2 - 4bf))/2b)\n    float h = eq.d * eq.d - 4.0 * eq.b * eq.f;\n    if (h > 0.0) {\n        h = sqrt(h);\n        float da = 2.0 * eq.b;\n\n        float x2 = (-eq.d + h) / da;\n        if (x2 > 0.0) {\n            x2 = sqrt(x2);\n            float y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n\n            x2 = -x2;\n            y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n        }\n\n        x2 = (-eq.d - h) / da;\n        if (x2 > 0.0) {\n            x2 = sqrt(x2);\n            float y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n\n            x2 = -x2;\n            y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n        }\n    }\n\n    for (int n=0; n < newtonSteps; n++) {\n        float newtonStep = evalQuintic(x1, eq) / evalQuinticPrime(x1, eq);\n        x1 -= newtonStep;//min(abs(newtonStep), 1.0) * sign(newtonStep);\n    }\n\n    set(roots.roots, 0, x1);\n    vec4 factorRoots;\n    float qa = eq.a, qb = qa * x1 + eq.b, qc = qb * x1 + eq.c, qd = qc * x1 + eq.d, qe = qd * x1 + eq.e;\n    int nFactorRoots = solveQuartic(qa, qb, qc, qd, qe, factorRoots);\n    for (int n=0; n < nFactorRoots; n++) { set(roots.roots, n + 1, factorRoots[n]); }\n    roots.nroots += nFactorRoots;\n\n    return roots;\n}\n\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nRoots5 solveQuinticDurandKerner(in GeneralQuintic q) {\n    // TODO: refactor\n    // Reduction to x^5 + px^3 + qx^2 + rx + s\n    ReducedQuintic r = tschirnhausLinear(q);\n\n    float bound = 1.0 + max(1.0, max(abs(r.p), max(abs(r.q), max(abs(r.r), abs(r.s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5; // Keep safely within bounds\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0); // QuinticRootOfUnity^0\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound; // QuinticRootOfUnity^1\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound; // QuinticRootOfUnity^2\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound; // QuinticRootOfUnity^3\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound; // QuinticRootOfUnity^4\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(r.p, 0.0), z) + vec2(r.q, 0.0), z) + vec2(r.r, 0.0), z) + vec2(r.s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    // Undo substitution y = x + b/5a\n    // and weed out complex roots\n    Roots5 realRoots = Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            set(realRoots.roots, realRoots.nroots, z.x - r.offs);\n            realRoots.nroots++;\n        }\n    }\n\n    return realRoots;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n    float time = iTime;\n\n    #ifdef CONSTRUCT_FROM_ROOTS\n    time *= 0.25;\n    #endif\n\n    // Generate random animated roots\n    #ifdef CONSTRUCT_FROM_ROOTS\n    float state = 0.0;\n    Float5 x = Float5(0.0, 0.0, 0.0, 0.0, 0.0);\n    for (int n=0; n < 5; n++) {\n        set(x, n, mix(Hash11(floor(time) + state), Hash11(ceil(time) + state), smoothstep(0.0, 1.0, fract(time))) * 6.0 - 3.0);\n        state += 17.13;\n    }\n\n    GeneralQuintic q;\n    quinticFromRoots(x._0, x._1, x._2, x._3, x._4, q);\n\n    #else\n    GeneralQuintic q;\n    q.a = sin(time * 0.25) * 1.25;\n    q.b = sin(time) * 2.0;\n    q.c = sin(time) * 2.0;\n    q.d = cos(time * 0.75);\n    q.e = sin(time * 0.5);\n    q.f = cos(time);\n\n    #endif\n\n    // Draw root bounds\n    if (-max(0.0, 1.0 + max(q.b / q.a, max(-q.c / q.a, max(q.d / q.a, max(-q.e / q.a, q.f / q.a))))) < uv.x &&\n        uv.x < max(0.0, 1.0 + max(-q.b / q.a, max(-q.c / q.a, max(-q.d / q.a, max(-q.e / q.a, -q.f / q.a)))))) {\n        color.rb += 0.5;\n    }\n\n    // Draw the x axis and quintic equation\n    float fx = evalQuintic(uv.x, q);\n    float dx = evalQuinticPrime(uv.x, q); // Derivative for distance estimation\n    color.b += smoothstep(unit, 0.0, abs(uv.y));\n    color.rg += smoothstep(unit, 0.0, abs(uv.y - fx) / sqrt(1.0 + dx * dx));\n\n    // Draw the critical points\n    vec4 critical;\n    int nCritical = solveQuartic(5.0 * q.a, 4.0 * q.b, 3.0 * q.c, 2.0 * q.d, q.e, critical);\n    for (int n=0; n < nCritical; n++) {\n        color = mix(color, vec3(1.0, 0.25, 0.0), smoothstep(unit, 0.0, length(uv - vec2(critical[n], evalQuintic(critical[n], q))) - 0.05));\n    }\n\n    // Solve and draw expected versus found roots\n    #if METHOD == 0\n    Roots5 roots = solveQuinticLinSearch(q, -4.0, 4.0, 0.001, true, 20, 10);\n    #endif\n\n    #if METHOD == 1\n    Roots5 roots = solveQuinticBracket(q, 10, 3);\n    #endif\n\n    #if METHOD == 2\n    Roots5 roots = solveQuinticPolyDiv(q, 25);\n    #endif\n\n    #if METHOD == 3\n    Roots5 roots = solveQuinticDurandKerner(q);\n    #endif\n\n    for (int n=0; n < 5; n++) {\n        if (n < roots.nroots) color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - vec2(get(roots.roots, n), 0.0)) - 0.05));\n\n        #ifdef CONSTRUCT_FROM_ROOTS\n        color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(length(uv - vec2(get(x, n), 0.0)) - 0.1)));\n        #endif\n    }\n\n    // Debug bisection solver (I accidentally made it incorrect at first)\n    if (iMouse.z > 0.0) {\n        float test = bisection(q, min(mouse.x, mouse.z), max(mouse.x, mouse.z), 25);\n        if (uv.x > min(mouse.x, mouse.z) && max(mouse.x, mouse.z) > uv.x) color = mix(color, vec3(1.0, 0.0, 1.0), 0.5);\n        color = mix(color, vec3(0.0, 1.0, 0.8), smoothstep(unit, 0.0, length(uv - vec2(test, 0.0)) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}