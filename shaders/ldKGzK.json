{
    "Shader": {
        "info": {
            "date": "1455424416",
            "description": "Here I experiment perlin noise and value noise in 3d space",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKGzK",
            "likes": 22,
            "name": "Space Rock",
            "published": 3,
            "tags": [
                "raymarching",
                "perlinnoise3d"
            ],
            "usePreview": 1,
            "username": "yibojiang",
            "viewed": 1542
        },
        "renderpass": [
            {
                "code": "#define FBM_Iteration 7\n#define pi 3.14159\n\nvec3 hash3(vec3 p) {\n  p = vec3( dot( p, vec3(127.1, 311.7, 121.1) ),\n            dot( p, vec3(269.5, 183.3, 234.5) ),\n            dot( p, vec3(629.5, 43.3, 32.1) ) );\n\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123 );\n}\n\nvec2 hash2( vec2 p ) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return fract(sin(p) * 43758.5453); }\n\nfloat hash( float n ) { return fract(sin(n) * 753.5453123); }\n\n//background copy and paste from iq's Space Curvature https://www.shadertoy.com/view/llj3Rz\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n  vec3 colx = texture( sam, 0.5 + s * d.yz / d.x, b ).xyz;\n  vec3 coly = texture( sam, 0.5 + s * d.zx / d.y, b ).xyz;\n  vec3 colz = texture( sam, 0.5 + s * d.xy / d.z, b ).xyz;\n\n  vec3 n = d * d;\n\n  return (colx * n.x + coly * n.y + colz * n.z) / (n.x + n.y + n.z);\n}\n\nvec2 voronoi( in vec2 x )\n{\n  vec2 n = floor( x );\n  vec2 f = fract( x );\n\n  vec3 m = vec3( 8.0 );\n  for ( int j = -1; j <= 1; j++ )\n    for ( int i = -1; i <= 1; i++ )\n    {\n      vec2  g = vec2( float(i), float(j) );\n      vec2  o = hash2( n + g );\n      vec2  r = g - f + o;\n      float d = dot( r, r );\n      if ( d < m.x )\n        m = vec3( d, o );\n    }\n\n  return vec2( sqrt(m.x), m.y + m.z );\n}\n\n\nvec3 background( in vec3 d, in vec3 l )\n{\n  vec3 col = vec3(0.0);\n  col += 0.5 * pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n  col += 0.2 * pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n  col += 0.8 * vec3(0.80, 0.5, 0.6) * pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n  float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n\n  vec3 n = abs(d);\n  n = n * n * n;\n  vec2 vxy = voronoi( 50.0 * d.xy );\n  vec2 vyz = voronoi( 50.0 * d.yz );\n  vec2 vzx = voronoi( 50.0 * d.zx );\n  vec2 r = (vyz * n.x + vzx * n.y + vxy * n.z) / (n.x + n.y + n.z);\n  col += 0.9 * stars * clamp(1.0 - (3.0 + r.y * 5.0) * r.x, 0.0, 1.0);\n\n  col = 1.9 * col - 0.2;\n  col += vec3(-0.05, 0.1, 0.0);\n\n  float s = clamp( dot(d, l), 0.0, 1.0 );\n  col += 0.4 * pow(s, 5.0) * vec3(1.0, 0.7, 0.6) * 2.0;\n  col += 0.4 * pow(s, 64.0) * vec3(1.0, 0.9, 0.8) * 2.0;\n\n  return col;\n\n}\n\n\n//perlin noise\nfloat perlin_noise3(vec3 p) {\n  vec3 p0 = floor(p);\n  vec3 d = fract(p);\n\n  vec3 w = d * d * (3.0 - 2.0 * d);\n\n  float lerp1 = mix(\n                  mix( dot( hash3( p0 ) , d ) , dot( hash3( p0 + vec3(1, 0, 0)  ), d - vec3(1, 0, 0) ) , w.x ) ,\n                  mix( dot( hash3( p0 + vec3(0, 1, 0) ), d - vec3(0, 1, 0) ) , dot( hash3( p0 + vec3(1, 1, 0)  ), d - vec3(1, 1, 0) ) , w.x ),\n                  w.y);\n\n  float lerp2 = mix(\n                  mix( dot( hash3( p0 + vec3(0, 0, 1) ), d - vec3(0, 0, 1) ) , dot( hash3( p0 + vec3(1, 0, 1)  ), d - vec3(1, 0, 1) ) , w.x ) ,\n                  mix( dot( hash3( p0 + vec3(0, 1, 1) ), d - vec3(0, 1, 1) ) , dot( hash3( p0 + vec3(1, 1, 1)  ), d - vec3(1, 1, 1) ) , w.x ),\n                  w.y);\n\n  return mix(lerp1, lerp2, w.z);\n}\n\n\n//Value Noise\nfloat value_noise( in vec3 x )\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return mix(mix(mix( hash(n +  0.0), hash(n +  1.0), f.x),\n                 mix( hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n             mix(mix( hash(n + 113.0), hash(n + 114.0), f.x),\n                 mix( hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n\nfloat fbm3(vec3 p) {\n  float n = 0.0;\n  n = value_noise(p);\n\n  float a = 0.5;\n  for (int i = 0; i < FBM_Iteration; i++) {\n    n += a * value_noise(p);\n    p = p * 2.0;\n    a = a * 0.5;\n  }\n  return n;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - (r + 0.8 * ( 0.1 + ( 0.3 * fbm3( p * 3.0  )  ) ) ) ;\n}\n\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(0.0, 0.4);\n  float planeCol = 0.4;\n  float sphereCol = 11.3;\n\n  res = vec2( sphere(p - vec3(0.9, 0.5, 0.2), 0.8), sphereCol  ) ;\n  return res;\n}\n\nvec3 caclNormal(vec3 p) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  return normalize( vec3(\n                      map(p + eps.xyy).x - map(p - eps.xyy).x,\n                      map(p + eps.yxy).x - map(p - eps.yxy).x,\n                      map(p + eps.yyx).x - map(p - eps.yyx).x ) );\n}\n\nmat3 rotate(float an) {\n  return mat3(cos(an), 0, -sin(an),\n              0, 1, 0,\n              sin(an), 0, cos(an)\n             );\n}\n\nconst float precis = 0.002;\nvec2 raymarch(in vec3 ro, in vec3 rd) {\n  float tmin = 0.1;\n  float tmax = 20.0;\n\n  float t = tmin;\n  float m = -1.0;\n\n  for (int i = 0; i < 64; i++) {\n    vec2 res = map(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n\n    t += res.x * 0.5;\n    m = res.y;\n  }\n\n  if (t > tmax) m = -1.0;\n  return vec2(t, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec2 p = uv - vec2(0.5);\n\n  p.y = p.y * iResolution.y / iResolution.x;\n  float precis = 0.01;\n\n  float angle = 0.1 * iTime + 6.0 * iMouse.x / iResolution.x;;\n\n  float watchDist = 3.0;\n  vec3 pos = vec3(watchDist * sin(angle), 0.5 + cos(angle * 2.0) * 0.2, -watchDist * cos(angle));\n\n  vec3 ro = pos;\n  vec3 rd = normalize(vec3(p.x, p.y, 1.0) );\n\n\n  rd = rd * rotate(angle);\n\n\n  vec3 amb = vec3(0.0);\n  vec3 finalCol = vec3(1.0);\n  //finalCol=texture(iChannel0,uv).xyz;\n  vec2 res = raymarch(ro, rd);\n  float t = res.x;\n  float m = res.y;\n\n  vec3 bgCol = finalCol;\n  vec3 lig = normalize(vec3(-3.0, -0.9, 1.0));\n  if (m > -0.5) {\n    //directional light\n\n    vec3 hit = ro + rd * t;\n    vec3 nor = caclNormal(hit);\n\n    vec3 resCol = 0.3 * sin( vec3(0.06, 0.08, 0.1) * res.y );\n    //resCol=vec3(0.5);\n\n    float diffuse = 4.6 * max(0.0, dot(-lig, nor) );\n    vec3 ref = reflect(-rd, nor);\n    vec3 h = normalize(-lig - rd);\n    float specular = 1.0 * pow(max(0.0, dot(h, nor) ), 1.0 );\n\n    finalCol = resCol * (diffuse + specular) + amb;\n\n    //float edge = smoothstep(0., 0.2, dot(hit, nor));\n    //finalCol= mix(bgCol, finalCol, edge);\n\n    //finalCol=ref;\n  }\n  else {\n\n    vec3 bghit = ro - rd * 100.0;\n    //finalCol=texture (iChannel0,bghit).xyz;\n    finalCol = background( rd, -lig );\n  }\n  //finalCol *= smoothstep( 0.0, 6.0, iTime );\n\n  fragColor = vec4(finalCol.xyz, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}