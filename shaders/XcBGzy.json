{
    "Shader": {
        "info": {
            "date": "1704332991",
            "description": "Auto Edge\n Edges are colored based on the difference between the original SDF and a blured SDF ( www.shadertoy.com/view/mdc3RS )",
            "flags": 0,
            "hasliked": 0,
            "id": "XcBGzy",
            "likes": 65,
            "name": "Auto Edge",
            "published": 3,
            "tags": [
                "sdf",
                "edgedetect"
            ],
            "usePreview": 0,
            "username": "PauloFalcao",
            "viewed": 764
        },
        "renderpass": [
            {
                "code": "// Auto Edge\n//\n// By PauloFalcao\n//\n// Edges are colored based on the difference between the original SDF and a blured SDF\n//\n// It's also possible to deform the edges using a noise function\n// based on this difference but it's much lower.\n//\n// The blurred SDF method is explained here https://www.shadertoy.com/view/mdc3RS\n//\n\nstruct material {\n  vec3 baseColor;\n  float specular;\n  vec3 normal;\n};\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nvec3 opRepLim(vec3 p,vec3 c,vec3 l){\n    p+=(c*l)/2.0;\n    return p-c*clamp(floor(p/c+0.5),vec3(0.0),l);\n}\n\n\nvec2 twist_rot(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s),vec2(s, c));\n\treturn m * v;\n}\n\n//from Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n//from nikat https://www.shadertoy.com/view/XsX3zB\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\t  vec3 i1 = e * (1.0 - e.zxy);\n\t  vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n#define fbm_iterations 6\nfloat fbm(vec3 coord, float persistence) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < fbm_iterations; i++) {\n\t\tvalue += simplex_noise(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\nvec3 obj_trans(vec3 p){\n  p.xz=rot(p.xz,-iTime*0.5);\n  return p;\n}\n\n\nfloat obj_sdf_a(vec3 p){\n  vec3 t1=p;\n  t1.xz=twist_rot(t1.xz,t1.y*1.2);\n  float d1=sdRoundBox(t1,vec3(0.35,1.4,0.35),0.1);\n  vec3 t2=opRepLim(t1-vec3(0.0,0.6,0.0),vec3(2.0,0.5,2.0),vec3(0.0,3.0,0.0));\n  float d2=opSmoothUnion(length(t2.yz)-0.17,length(t2.xy)-0.17,0.14);\n  float d3=opSmoothSubtraction(d2,d1,0.1);\n  vec3 t3=p;\n  t3.y+=1.2;\n  float d4=sdRoundBox(t3,vec3(1.3,0.4,1.3),0.05);\n  return opSmoothUnion(d3,d4,0.6);\n  return d3;\n}\n\nfloat obj_sdf(vec3 p){\n  p=obj_trans(p);\n  return obj_sdf_a(p);\n}\n\n#define blur_iterations 55\n// blur obj is sdf_a\n// b is the blur amount\n// f is just the bounding object size\n//   so it only blurs when close to the object\nfloat blursdf3d(/*obj vec3->float*/in vec3 p,in float b,float f){\n    /*obj vec3->float = sdf_a*/\n\tfloat a=0.0;\n\tfloat d=obj_sdf(p);\n\tif (d<b*f){\n        /*iterations*/\n\t\tfor(int i=0;i<blur_iterations;i++){\n\t        float y=1.0-2.0*(float(i)/float(blur_iterations));\n\t        float r=sqrt(1.0-y*y);\n\t        float t=2.39996322973*float(i);\n\t\t\ta+=obj_sdf(p+vec3(cos(t)*r,y,sin(t)*r)*b);\n\t\t}\n\t} else{\n\t\treturn d;\n\t}\n\treturn a/float(blur_iterations);\n}\n\n\nconst float cgrad0_0_pos = 0.427273005;\nconst vec3 cgrad0_0_col = vec3(1.000000000, 0.685059309, 0.496093750);\nconst float cgrad0_1_pos = 0.709090978;\nconst vec3 cgrad0_1_col = vec3(0.472656250, 0.129241943, 0.129241943);\nvec3 color_grad0(float x) {\n  if (x <  cgrad0_0_pos) {\n    return cgrad0_0_col;\n  } else if (x < cgrad0_1_pos) {\n    return mix(cgrad0_0_col, cgrad0_1_col, ((x-cgrad0_0_pos)/(cgrad0_1_pos-cgrad0_0_pos)));\n  }\n  return cgrad0_1_col;\n}\n\nvec3 calcnormal(vec3 p){  \n  const vec2 e=vec2(0.001,-0.001);\n  float x=obj_sdf(p+e.xyy);\n  float y=obj_sdf(p+e.yxy);\n  float z=obj_sdf(p+e.yyx);\n  return normalize(vec3(x-y-z,-x+y-z,-x-y+z)+obj_sdf(p+e.xxx));\n}\n\nmaterial obj_mat3d(vec3 p){\n    material m;\n    float o0=obj_sdf(p);\n    float o1=blursdf3d(p,0.05,0.5);\n    float diff=clamp((o1-o0)*100.0,0.0,1.0);\n    vec3 mp=p;\n    mp=obj_trans(p);\n    float n0=fbm(mp*6.5,0.5)*0.5+0.5;\n    float n1=fbm((mp+vec3(10.0))*6.5,0.5)*0.5;\n    float n2=fbm((mp-vec3(7.0))*6.5,0.5)*0.5;\n    vec3 c0=color_grad0(n0);\n    m.baseColor=mix((vec3(1.0)-c0)*0.5,c0*2.0,diff);\n    m.specular=1.0-diff;\n    m.normal=normalize(calcnormal(p)+(vec3((n0-0.5),n1,n2)*(max(p.y*0.9+0.75,0.0))));\n    return m;\n}\n\nvoid march(inout float d,out vec3 p,out float dS,in vec3 ro,in vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = obj_sdf(p);\n        d += dS;\n        if (d > 20.0 || abs(dS) < 0.0001) break;\n    }\n}\n\nvec3 hdri(vec3 p,float v) {\n\treturn pow(texture(iChannel0, p).xyz, vec3(2.2))\n    + pow(texture(iChannel0, p).xxx, vec3(8.0)) * v;\n}\n\nvec3 raymarch(\n        vec2 uv,\n        vec3 camera,\n        float cameraZoom,\n        vec3 lookAt,\n        float cameraDistance,\n        vec3 sun,\n        float ambLightIntensity,\n        float lightPow,\n        float lightSpecular,\n        float reflection) {\n\tvec3 cam=camera*cameraZoom;\n\tvec3 ray=normalize(lookAt-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(ray,cX));\n\tvec3 rd = normalize(ray*cameraDistance+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0.);\n\tfloat dS=0.0;\n\tmarch(d,p,dS,ro,rd);\n\t\n  vec3 color=vec3(0.);\n\tmaterial objMat=obj_mat3d(p);\n\tvec3 light=normalize(sun);\n\tif (d<20.0) {\n\t  vec3 n=objMat.normal;\n\t\tfloat l=clamp(dot(-light,-n),0.,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.,1.0);\n    lightSpecular*=objMat.specular;\n\t\tcolor=max(ambLightIntensity,l)*objMat.baseColor+pow(r,lightPow)*lightSpecular;\n\t\t//reflection\n    d=0.01;\n\t\tmarch(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0.);\n\t\tif (d<20.0) {\n      material mref=obj_mat3d(p);\n\t\t\tobjColorRef=mref.baseColor;\n\t\t\tn=mref.normal;\n\t\t\tl=clamp(dot(-light,-n),0.,1.);\n\t\t\tobjColorRef=max(l,ambLightIntensity)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=hdri(ref.zyx,2.0);\n\t\t}\n    reflection*=objMat.specular;\n\t\tcolor=mix(color,objColorRef,reflection);\n\t} else {\n\t\tcolor=hdri(rd.zyx,0.0);\n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //setup uv\n    vec2 uv=fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    //rendering parameters\n    vec3 camera=vec3(sin(sin(iTime*0.3)*0.5+0.5)*4.0,2.0,cos(cos(iTime*0.2)*0.5+0.5)*4.0);\n    float cameraZoom=1.0;\n    vec3 lookAt=vec3(0.0,-0.1,0.0);\n    float cameraDistance=1.1;\n    vec3 sun=vec3(5.0,2.0,-0.2);\n    float ambLightIntensity=0.25;\n    float lightPow=128.0;\n    float lightSpecular=0.7;\n    float reflection=0.2;\n    vec3 col = raymarch(uv,camera,cameraZoom,lookAt,cameraDistance,sun,\n        ambLightIntensity,lightPow,lightSpecular,reflection);\n\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}