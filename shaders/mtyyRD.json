{
    "Shader": {
        "info": {
            "date": "1699982949",
            "description": "Spiral terrain",
            "flags": 0,
            "hasliked": 0,
            "id": "mtyyRD",
            "likes": 7,
            "name": "Spiral Terrain",
            "published": 3,
            "tags": [
                "terrain",
                "spiral"
            ],
            "usePreview": 0,
            "username": "Peace",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "const int MAX_STEPS = 128;\n#define SURFACE_DIST 0.1\nconst float PI = 3.14159265359;\n\nstruct Hit\n{\n    float dist;\n    float min_dist;\n    vec3 point;\n    vec3 normal;\n};\n\nfloat spiral(vec3 p) {\n    vec2 uv = p.xy;\n    float l = length(uv) * 8.0 - iTime;\n    vec2 p2 = vec2(sin(l), cos(l));\n    float d = 2.0 - pow(distance(uv, p2), 0.1);\n    d = pow(d, 2.0 - length(uv) * 0.5 + 1.0 / (0.2 + dot(uv, uv)));\n    return dot(p, normalize(vec3(0.2, 0.2, -1))) + d;\n}\n\nfloat SDF(vec3 point)\n{\n    return spiral(point);\n}\n\nvec3 getNormal(vec3 point, float dist)\n{\n    vec2 e = vec2(0.002, 0.0);\n    return normalize(dist - vec3(SDF(point - e.xyy), SDF(point - e.yxy), SDF(point - e.yyx)));\n}\n\nHit raymarch(vec3 ro, vec3 rd)\n{\n    Hit hit;\n    hit.min_dist = 99999.;\n    hit.point = ro;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float sdf = SDF(hit.point);\n        if (abs(sdf) < hit.min_dist) \n        {\n            hit.min_dist = sdf;\n            hit.normal = getNormal(hit.point, hit.min_dist);\n            if (sdf <= SURFACE_DIST)\n                break;\n        }\n        hit.point += rd * sdf * 0.1;\n        hit.dist += sdf;\n    }\n    \n    return hit;\n}\n\nvec3 gammaCorrect(vec3 color, float gamma)\n{\n    return pow(color, vec3(1.0 / gamma));\n}\n\nfloat diffuse(vec3 normal, vec3 light_dir)\n{\n    return max(0.0, dot(normal, light_dir));\n}\n    \nfloat specular(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    vec3 halfway = normalize(light_dir + ray_dir);\n    return max(0.0, dot(normal, halfway));\n}\n\nvec3 gradient(float z, float d) {\n    return mix(\n\t\tvec3(0.4, 0.8, 1.0),\n\t\tmix(\n\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\tvec3(1),\n\t\t\tz * 0.55\n\t\t),\n\t\t1.0 / (d * 0.033)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / mr;\n    vec3 ro = vec3(0, 0, -1);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    Hit hit = raymarch(ro, rd);\n    \n    vec3 lp = vec3(6, 8, -4);\n    vec3 ld = normalize(lp - hit.point);\n    \n    vec3 vd = normalize(ro - hit.point);\n    float s = specular(ld, vd, hit.normal);\n    float spec = pow(s, 32.);\n    spec += pow(s, 64.);\n    spec += pow(specular(normalize(vec3(5, -10, -2)), vd, hit.normal), 8.);\n    float diff = diffuse(hit.normal, ld);\n    float light = spec + diff;\n\n    vec3 color = gradient(hit.point.z, hit.dist + 32. * light);\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}