{
    "Shader": {
        "info": {
            "date": "1675116866",
            "description": "A raytracer.\nKnown issue involving the plane.",
            "flags": 32,
            "hasliked": 0,
            "id": "mllSzj",
            "likes": 1,
            "name": "Raytracer (Alpha)",
            "published": 3,
            "tags": [
                "raytracing",
                "raytracer",
                "pathtracing",
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "raymarchingenthusiast",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define sat(a) clamp(a,0.,1.)\nstruct Object {\n    vec3 a; //Position\n    vec3 b; //Size/Normal/x=Raidus\n    vec2 r; //Roatation\n    \n    int type;\n    //0 -> Sphere\n    //1 -> Box\n    //2 -> Plane\n};\n\nstruct Material {\n    float roughness;\n    float shininess;\n    vec3 color;\n};\n\nstruct Light {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define R iResolution.xy\n#define F float(iFrame)\n#define a vec3(23.,7.,11.)\n#define Inf 9999.\n#define G 1./2.2\n\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*a.x+a.y,a.z)/a.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*a.x+a.y,a.z)/a.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}\n\nvec3 getSky(vec3 rd) {\n    return .5+.5*rd;\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd) {\n    float d0 = sphInt(ro,rd,vec3(0.,0.,3.),1.).x;\n    if(d0 < 0.) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    \n    float d = min(d0,d1);\n    if(d==Inf) return vec2(-1.,0.);\n    \n    float m;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    \n    return vec2(d,m);\n}\n\nLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return Light(i,c,p+o);\n}\n\nvec3 getObjectNorm(vec3 p, float id) {\n    if(id==1.) return normalize(vec3(0.,0.,3.)-p);\n    if(id==2.) return normalize(vec3(0.,-1.,0.));\n    return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id) {\n    if(id==1.) return Material(1.,15.,vec3(.2,.2,.2));\n    if(id==2.) return Material(1.,60.,vec3(.025,.2,.075));\n}\n\nvoid getRay(out vec3 ro,inout vec3 rd,float r,vec3 p,vec3 n){\n    ro = p;\n    rd = reflect(rd,n);\n}\n\nbool inLight(vec3 ro,vec4 ld){\n    vec2 tres = worldInt(ro,-ld.xyz);\n    return tres.x>=ld.w||tres.y==0.;\n    return true;\n}\n\nvec3 getPixCol(vec2 I) {\n    irand(F,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    vec3 rd = normalize( vec3( p.xy, 1. ) );\n\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    vec3 gd = normalize( rd*1.3 - go );\n    vec3 ro = vec3(go.xy,0.);\n    rd.xy += gd.xy;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    for(int i = 0; i < 2; i++){\n        vec2 tres = worldInt(ro,rd);\n    \n        if(tres.y<=0.) {tcol+=fcol*getSky(rd);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n    \n        vec3 nor     = getObjectNorm(pos,tres.y);\n        //vec3 ofp     = pos + nor*.001;\n        Material dat = getObjectData(pos,tres.y);\n        \n        vec3 color = vec3(0.);\n        {\n            Light l = genLight(250.,vec3(1.),vec3(-5.,5.,-5.),.9);\n            vec4 ld = vec4(normalize(pos-l.pos),length(pos-l.pos));\n            if(inLight(pos,ld)){\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,ld.xyz),0.);\n                vec3 h = normalize(ld.xyz+rd);\n                color += fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }\n        }\n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,dat.roughness,pos,nor);\n    }\n    return tcol;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(sat(getPixCol(I)),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0) O += texelFetch(iChannel0,ivec2(I),0);\n    //O.xyz /= O.w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}