{
    "Shader": {
        "info": {
            "date": "1463048315",
            "description": "Gyroscope simulation; (unlike an earlier version) the differential\n  equations describing the dynamics are solved numerically.\nUsage described in source.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdGSRD",
            "likes": 12,
            "name": "Gyroscope",
            "published": 3,
            "tags": [
                "mechanics",
                "quaternion",
                "physics",
                "differentialequations"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "// \"Gyroscope\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Gyroscope simulation; (unlike an earlier version) the differential\n  equations describing the dynamics are solved numerically. The balls\n  trace the trajectory which includes both precession and nutation\n  (the total energy can be shown - it should remain constant).\n\n  The sliders control four of the five independent parameters of the\n  system (the fifth is the spin rate). From left to right:\n    Initial elevation\n    Initial precession rate\n    Ratio of moments of inertia\n    Gravity (owest value is zero)\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal);\nvec4 Loadv4 (int idVar);\n\nconst float pi = 3.14159;\nconst float txRow = 32.;\n\nmat3 rMat;\nvec3 vnBall, ltDir;\nfloat dstFar, axLen, bLen;\nint idObj;\nconst int ntPoint = 100;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, bRad, wlRad;\n  bRad = 0.06;\n  wlRad = 0.45;\n  dMin = dstFar;\n  q = p;\n  d = PrCapsDf (q.xzy, bRad * (1. - 0.4 * q.y / bLen), 0.9 * bLen);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q.y -= bLen;\n  d = PrSphDf (q, 0.07 * wlRad);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q.y -= -2.05 * bLen;\n  d = PrRCylDf (q.xzy, 10. * bRad, 0.03 * bLen, 0.08 * bLen);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.y -= bLen;\n  q.xz = Rot2D (q.xz, -0.5 * pi);\n  q = q.xzy * rMat;\n  q.z -= axLen;\n  d = PrTorusDf (q, 0.06 * wlRad, wlRad);\n  d = min (d, PrCylDf (q, 0.07 * wlRad, 0.05 * wlRad));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q.z += 0.5 * axLen;\n  d = min (d, PrCylDf (q, 0.03 * wlRad, 0.5 * axLen));\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q.z -= 0.5 * axLen;\n  q.xy = Rot2D (q.xy, 2. * pi *\n     (floor (3. * atan (q.y, - q.x) / (2. * pi)) + 0.5) / 3.);\n  q.x += 0.5 * wlRad;\n  d = PrCylDf (q.yzx, 0.04 * wlRad, 0.5 * wlRad);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TBallHit (vec3 ro, vec3 rd)\n{\n  vec3 p, v;\n  vec2 e;\n  float b, d, w, dMin, sz;\n  dMin = dstFar;\n  sz = 0.018;\n  for (int n = 0; n < ntPoint; n ++) {\n    e = Loadv4 (9 + n).xy;\n    p = 0.93 * axLen * vec3 (sin (e.y) * cos (e.x), cos (e.y),\n       sin (e.y) * sin (e.x));\n    p.y += bLen;\n    v = ro - p;\n    b = dot (rd, v);\n    w = b * b + sz * sz - dot (v, v);\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (v + d * rd) / sz;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.04;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.04 * d, h));\n    d += max (0.04, 0.05 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, dstBall, sh;\n  int idObjT;\n  dstBall = TBallHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstBall < min (dstObj, dstFar)) {\n    col = vec3 (0., 1., 0.2) * (0.4 + 0.6 * max (dot (vnBall, ltDir), 0.));\n  } else if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if      (idObj == 1) col = vec3 (0.5, 0.1, 0.1);\n    else if (idObj == 2) col = vec3 (0.2, 0.2, 0.7);\n    else if (idObj == 3) col = vec3 (0.8, 0.8, 0.1);\n    else if (idObj == 4) col = vec3 (0.6, 0.6, 0.7);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.) +\n       0.8 * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n  } else col = (1. - 2. * dot (rd.xy, rd.xy)) * vec3 (0.2, 0.25, 0.3);\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, slVal;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float asp, eTot;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  dstFar = 15.;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  eTot = stDat.y;\n  ori = stDat.zw;\n  rMat = QtToRMat (Loadv4 (1));\n  slVal = Loadv4 (7);\n  axLen = 0.8 + 0.3 * slVal.z;\n  bLen = 0.7;\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0.6, -5.);\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, slVal);\n  if (false) col = mix (col, vec3 (1., 1., 0.),\n     ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.45),\n     vec2 (0.06 * asp, 0.03), 4., floor (0.1 * eTot)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal)\n{\n  vec4 wgBx[4];\n  vec3 cc[4];\n  vec2 ut, ust;\n  float vW[4], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (-0.43 * asp, -0.05, 0.012 * asp, 0.2);\n  wgBx[1] = vec4 (-0.35 * asp, -0.05, 0.012 * asp, 0.2);\n  wgBx[2] = vec4 ( 0.35 * asp, -0.05, 0.012 * asp, 0.2);\n  wgBx[3] = vec4 ( 0.43 * asp, -0.05, 0.012 * asp, 0.2);\n  vW[0] = slVal.x;\n  vW[1] = slVal.y;\n  vW[2] = slVal.z;\n  vW[3] = slVal.w;\n  cc[0] = vec3 (1., 0., 0.);\n  cc[1] = vec3 (1., 0.4, 0.4);\n  cc[2] = vec3 (0., 0., 1.);\n  cc[3] = vec3 (0.4, 0.4, 1.);\n  for (int k = 0; k < 4; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (1., 1., 0.);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 2.);\n    if (length (ut) < 0.03 && max (ut.x, ut.y) > 0.01) col = cc[k];\n  }\n  return col;\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.7, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Gyroscope\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nmat3 QtToRMat (vec4 q);\nvec3 QtToEul (vec4 q);\nvec4 EulToQt (vec3 e);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.14159;\nconst float txRow = 32.;\n\nvec4 q, qv, qa, qa1, qa2, qa3, qo, qvo;\nvec3 mom;\nfloat nStep, grav, delT, paramE, paramS, paramP, paramH, paramG;\nconst int ntPoint = 100;\n\nvec3 AngVel ()\n{\n  vec4 qvt;\n  qvt = qv;\n  qvt.w *= -1.;\n  return 2. * QtMul (qvt, q).xyz;\n}\n\nvoid Accel ()\n{\n  vec4 qs;\n  vec3 torq, w, e;\n  float phi, theta;\n  e = QtToEul (q);\n  phi = e.x;\n  theta = e.y;\n  torq = grav * sin (theta) * vec3 (cos (phi), sin (phi), 0.) * QtToRMat (q);\n  w = AngVel ();\n  qs = vec4 (((mom.yzx - mom.zxy) * w.yzx * w.zxy + torq) / mom,\n     -2. * dot (qv, qv));\n  qa = 0.5 * QtMul (q, qs);\n}\n\nvoid PStep ()\n{\n  const vec4 cr = vec4 (323., -264., 159., -38.);\n  const vec4 cv = vec4 (502., -621., 396., -97.);\n  qo = q;\n  qvo = qv;\n  q = q + delT * qv + (delT * delT / 360.) * (cr.x * qa + cr.y * qa1 +\n     cr.z * qa2 + cr.w * qa3);\n  qv = (q - qo) / delT + (delT / 360.) * (cv.x * qa + cv.y * qa1 +\n     cv.z * qa2 + cv.w * qa3);\n  qa3 = qa2;\n  qa2 = qa1;\n  qa1 = qa;\n}\n\nvoid CStep ()\n{\n  const vec4 cr = vec4 (38., 171., -36., 7.);\n  const vec4 cv = vec4 (97., 114., -39., 8.);\n  q = qo + delT * qvo + (delT * delT / 360.) * (cr.x * qa + cr.y * qa1 +\n     cr.z * qa2 + cr.w * qa3);\n  qv = (q - qo) / delT + (delT / 360.) * (cv.x * qa + cv.y * qa1 +\n     cv.z * qa2 + cv.w * qa3);\n}\n\nvoid Step ()\n{\n  PStep ();\n  Accel (); \n  CStep (); \n  q = normalize (q);\n}\n\nvoid Init ()\n{\n  vec4 qt;\n  float phi, theta, psi, phiV, thetaV, psiV;\n  phi = pi / 6.;\n  theta = paramE * pi / 180.;\n  psi = 0.;\n  phiV = paramP;\n  thetaV = 0.;\n  psiV = paramS;\n  q = EulToQt (vec3 (phi, theta, psi));\n  qt = vec4 (sin (theta) * sin (psi) * phiV + cos (psi) * thetaV,\n             sin (theta) * cos (psi) * phiV - sin (psi) * thetaV,\n             cos (theta) * phiV + psiV, 0.);\n  qv = 0.5 * QtMul (q, qt);\n  Accel ();\n  qa1 = qa;\n  qa2 = qa;\n  qa3 = qa;\n}\n\nfloat Eng ()\n{\n  vec3 w;\n  float theta;\n  w = AngVel ();\n  theta = QtToEul (q).y;\n  return 0.5 * dot (mom, w * w) + grav * cos (theta);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[4], mPtr, mPtrP, stDat, slVal;\n  vec2 iFrag, canvas, ust, tPoint;\n  float asp, vW, eTot, el, az;\n  int pxId, wgSel, wgReg, kSel;\n  bool doInit;\n  const vec3\n     limE = vec3 (100., 20., 70.),\n     limP = vec3 (-10., 10., -5.),\n     limH = vec3 (0.8, 0.3, 0.4),\n     limG = vec3 (0., 100., 50.);\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 9 + ntPoint) discard;\n  delT = 0.0005;\n  doInit = false;\n  wgReg = -2;\n  paramS = 80.;\n  if (iFrame <= 5) {\n    paramE = limE.z;\n    paramP = limP.z;\n    paramH = limH.z;\n    paramG = limG.z;\n    slVal.x = (paramE - limE.x) / (limE.y - limE.x);\n    slVal.y = (paramP - limP.x) / (limP.y - limP.x);\n    slVal.z = (paramH - limH.x) / (limH.y - limH.x);\n    slVal.w = (paramG - limG.x) / (limG.y - limG.x);\n    mPtrP = mPtr;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (0).x;\n    q = Loadv4 (1);\n    qv = Loadv4 (2);\n    qa = Loadv4 (3);\n    qa1 = Loadv4 (4);\n    qa2 = Loadv4 (5);\n    qa3 = Loadv4 (6);\n    slVal = Loadv4 (7);\n    stDat = Loadv4 (8);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (-0.43 * asp, -0.05, 0.012 * asp, 0.2);\n    wgBx[1] = vec4 (-0.35 * asp, -0.05, 0.012 * asp, 0.2);\n    wgBx[2] = vec4 ( 0.35 * asp, -0.05, 0.012 * asp, 0.2);\n    wgBx[3] = vec4 ( 0.43 * asp, -0.05, 0.012 * asp, 0.2);\n    for (int k = 0; k < 4; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  el = 0.;\n  az = 0.;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el +=  pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n  } else {\n    for (int k = 0; k < 4; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) slVal.x = vW;\n    else if (kSel == 1) slVal.y = vW;\n    else if (kSel == 2) slVal.z = vW;\n    else if (kSel == 3) slVal.w = vW;\n    doInit = true;\n  }\n  paramE = limE.x + (limE.y - limE.x) * slVal.x;\n  paramP = limP.x + (limP.y - limP.x) * slVal.y;\n  paramH = limH.x + (limH.y - limH.x) * slVal.z;\n  paramG = limG.x + (limG.y - limG.x) * slVal.w;\n  mom = vec3 (1., 1., paramH);\n  grav = paramG;\n  if (doInit) {\n    Init ();\n    nStep = 0.;\n  }\n  if (! doInit && pxId <= 9) {\n    for (int k = 0; k < 4; k ++) Step ();\n    ++ nStep;\n  }\n  eTot = Eng ();\n  if (pxId == 9) tPoint = QtToEul (q).xy;\n  else if (pxId > 9) {\n    if (doInit) tPoint = vec2 (0., pi);\n    else tPoint = (mod (nStep, 8.) == 0.) ? Loadv4 (pxId - 1).xy :\n       Loadv4 (pxId).xy;\n  }\n  if      (pxId == 0) stDat = vec4 (nStep, eTot, el, az);\n  else if (pxId == 1) stDat = q;\n  else if (pxId == 2) stDat = qv;\n  else if (pxId == 3) stDat = qa;\n  else if (pxId == 4) stDat = qa1;\n  else if (pxId == 5) stDat = qa2;\n  else if (pxId == 6) stDat = qa3;\n  else if (pxId == 7) stDat = slVal;\n  else if (pxId == 8) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else                stDat = vec4 (tPoint, 0., 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec3 QtToEul (vec4 q)\n{\n  vec3 e;\n  float s, t;\n  t = dot (q.xy, q.xy);\n  s = 2. * sqrt (max (t * (1. - t), 0.));\n  e.y = atan (s, 1. - 2. * t);\n  if (s != 0.) e.xz = \n     vec2 (atan (q.x * q.z + q.y * q.w, q.x * q.w - q.y * q.z),\n           atan (q.x * q.z - q.y * q.w, q.x * q.w + q.y * q.z));\n  else e.xz = vec2 (2. * atan (q.z, q.w), 0.);\n  return e;\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  return vec4 (sin (a1) * vec2 (cos (a2), sin (a2)),\n               cos (a1) * vec2 (sin (a3), cos (a3)));\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}