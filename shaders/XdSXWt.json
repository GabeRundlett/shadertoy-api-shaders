{
    "Shader": {
        "info": {
            "date": "1416917739",
            "description": "Logistic map in complex numbers (real numbers superimposed in yellow). It's isomorphic to the Mandelbrot set. The smooth iteration count is sn = n + 1 - log2( log2|c| + log2|z| ). More info: [url]https://www.shadertoy.com/view/4dSXWt[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XdSXWt",
            "likes": 31,
            "name": "Logistic Map - Complex",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "logistic",
                "bifurcation",
                "feigenbaum"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 5051
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The Logistic Map in complex numbers. Since it's a quadratic funcion,\n// it's isomorphic to the Mandelbrot Set.\n//\n// The bifurcation diagram for the Logistic Map in real numbers is\n// superimposed to better see the overlap in the dynamics across the\n// x axis. More info here: https://www.shadertoy.com/view/4dSXWt\n//\n// Since f(z) = h路z路(1-z), as |Zn| approaches infinity we have that\n// Z = h^(2^n-1)路Zo^(2^n)\n//\n// Hence the normalization map phi = (Zn路h)^(1/2^n). \n//\n// The Green function is therefore G = log|phi| = (log|Zn|+log|h|)/(2^n)\n\n\n// supersampling factor (1 for slow machines, 5 for monsters!)\n#define AA 2\n\n// complex number operations\nvec2 cadd( float s, vec2 a ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (-iResolution.xy + 2.0*q)/iResolution.y;\n\n        // zoom\n        float zoo = 0.62 + 0.38*cos(.02*iTime);\n        float coa = cos( 0.1*(1.0-zoo)*iTime );\n        float sia = sin( 0.1*(1.0-zoo)*iTime );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 cc = vec2(1.0,0.0)+smoothstep(1.0,0.5,zoo)*vec2(0.24814,0.7369) + xy*zoo*2.0;\n\n        vec3 col = vec3( 0.0 );\n        \n        //---------------------------------\n        // logistic map in complex numbers\n        //---------------------------------\n        \n        vec2 sc = vec2( abs(cc.x-1.0)-1.0,cc.y);\n        if( dot(sc,sc)<1.0 )\n        {\n            // trick: in order to accelerate the rendering, we can detect if we\n            // are inside the convergent part of the set (any of the two bulbs of period 1).\n            //col = vec3(0.2);\n        }\n        else\n        {\n            float co = 0.0;\n            vec2 z  = vec2(0.5,0.0);\n            for( int i=0; i<256; i++ )\n            {\n                if( dot(z,z)>1024.0 ) break;\n                z = cmul(cc, cmul( z, cadd(1.0,-z) ) );\n                co += 1.0;\n            }\n\n            // smooth interation count = n + 1 - log2( log2|h| + log2|z| );\n            float sco = co + 1.0 - log2( 0.5*(log2(dot(cc,cc)) + log2(dot(z,z))) );\n\n            col = 0.5 + 0.5*cos( 3.0 + sco*0.1 + vec3(0.0,0.5,1.0));\n            if( co>255.5 ) col = vec3(0.0);\n        }\n\n        // Hubbard-Douady potential, |G|\n        //float d = (log(length(z)) + log(length(cc)))/pow(2.0,co);\n\n\n        //---------------------------------\n        // logic map in real numbers    \n        //---------------------------------\n        if( abs(cc.x-1.0)<3.0 )\n        {\n            float al = smoothstep( 17.0, 12.0, iTime );\n            col = clamp(col,0.0,1.0);\n            float x = 0.5;\n            for( int i=0; i<200; i++ )\n            x = cc.x*x*(1.0-x);\n            for( int i=0; i<200; i++ )\n            {\n                x = cc.x*x*(1.0-x);\n                col = mix( col, vec3(1.0,1.0,0.0), \n                           (0.15+0.85*pow(clamp(abs(sc.x+1.0)*0.4,0.0,1.0),4.0))*al*\n                           0.06*exp(-15000.0*(cc.y-x)*(cc.y-x)) );\n            }\n        }\n\n        tot += col;\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}