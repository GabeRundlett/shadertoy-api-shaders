{
    "Shader": {
        "info": {
            "date": "1693296521",
            "description": "Virtual rotation controller (Shoemake's Arcball) used to orient Mandelbulb and varying Juliabulb fractals",
            "flags": 32,
            "hasliked": 0,
            "id": "dlsBzX",
            "likes": 24,
            "name": "Arcball with Bulbs",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "mandelbulb",
                "navigation",
                "juliabulb",
                "trackball",
                "pentakis"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "// \"Arcball with Bulbs\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Implementation of Shoemake's Arcball (based on some old C code); extended to\n  control rotation speed in addition to angle.\n  Ball shows object orientation.\n  Click in green circle and drag yellow/red cursor to control rotation axis,\n  and angle (yellow) or speed (red); if cursor is on either green line then\n  rotation plane is one of the two marked great circles on the ball.\n  Yellow/red button sets controller function - either rotation angle or speed.\n  White button selects fractal type - Mandelbulb or varying Juliabulb.\n  Blue button resets controller and view.\n  Otherwise, mouse rotates and zooms overall view.\n  Behavior reverts to default if no user interaction detected.\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nmat3 objMat;\nvec3 qHit, ltDir;\nfloat dstFar, tCur;\nint nFrame, idObj, juMode;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec4 MJBulbDf (vec3 p)\n{ // (from \"Interactive Mandelbulb 2\")\n  vec4 aa, sa, ca;\n  vec3 c, q, qd, qm;\n  float d, qLen, qdLen, q2, q4, phi, theta, thetad, phid;\n  q = p.xzy;\n  c = (juMode > 0) ? normalize (vec3 (1., 1., 0.2 + 0.8 * SmoothBump (0.25, 0.75, 0.15,\n     fract (0.04 * tCur)))) : q;\n  qLen = length (q);\n  phi = atan (q.y, q.x);\n  theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n  thetad = 0.;\n  phid = 0.;\n  qdLen = 1.;\n  for (int n = VAR_ZERO; n < 5; n ++) {\n    qm = q;\n    q2 = qLen * qLen;\n    q4 = q2 * q2;\n    aa.xy = 8. * vec2 (theta, phi);\n    aa.zw = 7. * vec2 (theta, phi) + vec2 (thetad, phid);\n    sa = sin (aa);\n    ca = cos (aa);\n    q = q4 * q4 * vec3 (sa.x * vec2 (ca.y, sa.y), ca.x) + c;\n    qd = 8. * q4 * q2 * qLen * qdLen * vec3 (sa.z * vec2 (ca.w, sa.w), ca.z) + vec3 (1.);\n    qLen = length (q);\n    phi = atan (q.y, q.x);\n    theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n    qdLen = length (qd);\n    phid = atan (qd.y, qd.x);\n    thetad = (qdLen > 0.) ? asin (qd.z / qdLen) : 0.;\n    if (qLen > 3.1623) break;\n  }\n  d = (qLen > 0.) ? 0.5 * qLen * log (qLen) / qdLen : 0.;\n  return vec4 (d, qm);\n}\n\nvec3 DodecSymP (vec3 p)\n{   // (from \"Chinese Puzzle Balls 2\")\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    if (j < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat PentakEdgeDf (vec3 p)\n{  // (from \"Pentakis Dodecahedron\")\n  vec3 q;\n  float d, a;\n  q = DodecSymP (p);\n  a = 0.5 * acos (-1. / sqrt (5.));\n  d = max (abs (length (q) - 1.), min (dot (q.yz, sin (a - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.))))) - 0.007;\n  return d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 db4;\n  vec3 q;\n  float dMin, d, sz;\n  dMin = dstFar;\n  q = p;\n  d = PrSphDf (q, 2.5);\n  if (d < 0.1) {\n    sz = 2.;\n    db4 = MJBulbDf (objMat * q / sz);\n    d = sz * db4.x;\n    q = db4.yzw;\n    DMINQ (1);\n    sz = 2.3;\n    q = p;\n    d = sz * PentakEdgeDf (objMat * q / sz);\n    DMINQ (2);\n  } else dMin = min (dMin, d);\n  q = p;\n  q.x += 3.5;\n  q = objMat * q;\n  d = PrSphDf (q, 0.5);\n  DMINQ (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-5 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BallCol ()\n{\n  vec3 col;\n  vec2 a;\n  col = (qHit.y > 0.) ? vec3 (1., 0.7, 0.7) : vec3 (0.7, 1., 0.7);\n  col *= 0.5 + 0.5 * step (0.01, Minv3 (abs (qHit)));\n  col *= 0.7 + 0.3 * step (0.05, Minv3 (vec3 (length (qHit.xy), length (qHit.yz),\n     length (qHit.zx))));\n  a = 2. * pi * floor (24. * atan (vec2 (qHit.z), - qHit.yx) / (2. * pi) + 0.5) / 24.;\n  col *= mix (0.5 + 0.5 * step (0.01, abs (dot (qHit.yz, sin (a.x + vec2 (0., 0.5 * pi))))), 1.,\n     step (0.07, abs (qHit.x)));\n  col *= mix (0.5 + 0.5 * step (0.01, abs (dot (qHit.xz, sin (a.y + vec2 (0., 0.5 * pi))))), 1.,\n     step (0.07, abs (qHit.y)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (HsvToRgb (vec3 (0.05 + mod (0.2 * log (length (qHit)), 1.), 1., 1)), 0.2);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (BallCol (), 0.2);\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj > 1) nDotL *= nDotL;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col)\n{\n  vec4 stDat;\n  vec3 wgBx[4], cg;\n  vec2 cVec, w;\n  float mPtrz, s[2];\n  int wgSel, rtMode, noInt;\n  wgBx[0] = vec3 (1.4, -0.6, 0.25);\n  wgBx[1] = vec3 (1.65, -0.85, 0.04);\n  wgBx[2] = vec3 (1.65, -0.35, 0.04);\n  wgBx[3] = vec3 (1.7, 0.9, 0.05);\n  stDat = Loadv4 (0);\n  mPtrz = stDat.z;\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (2);\n  cVec = stDat.xy;\n  rtMode = int (stDat.z);\n  noInt = int (stDat.w);\n  s[0] = wgBx[0].x - wgBx[0].z;\n  s[1] = wgBx[1].x + wgBx[1].z;\n  w = uv - vec2 (0.5 * (s[0] + s[1]), wgBx[0].y);\n  col = mix (vec3 (0.35), col, 0.5 + 0.5 * smoothstep (4., 8., PrRoundBox2Df (w,\n     vec2 (0.5 * (s[1] - s[0]), wgBx[0].z + 0.03), 0.03) * canvas.y));\n  cg = (rtMode == 0) ? vec3 (1., 1., 0.) : vec3 (1., 0., 0.);\n  w = uv - wgBx[0].xy;\n  col = mix (vec3 (0., 1., 0.), col, smoothstep (3., 4., abs (length (w) - wgBx[0].z) * canvas.y));\n  if (length (w) < wgBx[0].z) col = mix (vec3 (0., 1., 0.), col,\n       smoothstep (3., 4., Minv2 (abs (w) * canvas.y)));\n  if ((mPtrz > 0. && wgSel == 0 || noInt > 0) && length (cVec) < 1.) col = mix (cg, col,\n     smoothstep (13., 15., length (w - cVec * wgBx[0].z)* canvas.y));\n  w = uv - wgBx[1].xy;\n  col = mix (vec3 (0., 0., 1.), col, smoothstep (3., 4., abs (length (w) - wgBx[1].z) * canvas.y));\n  w = uv - wgBx[2].xy;\n  col = mix (cg, col, smoothstep (3., 4., abs (length (w) - wgBx[2].z) * canvas.y));\n  w = uv - wgBx[3].xy;\n  col = mix (vec3 (0.9), col, smoothstep (3., 4., abs (length (w) - wgBx[3].z) * canvas.y));\n  if (juMode > 0) col = mix (vec3 (0.9), col, smoothstep (3., 4.,\n     abs (length (w) - 0.5 * wgBx[3].z) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, qtCur, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  stDat = Loadv4 (1);\n  qtCur = stDat;\n  objMat = QtToRMat (qtCur);\n  stDat = Loadv4 (3);\n  juMode = int (stDat.y);\n  el = stDat.z;\n  az = stDat.w;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  zmFac = 8. - 4. * cos (az);\n  dstFar = 40.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi);\n    rd = vuMat * normalize (vec3 (uvv, zmFac));\n    col += (1. / naa) * ShowWg (uvv, canvas, ShowScene (ro, rd));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Arcball with Bulbs\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float txRow = 32.;\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, mPtr, mPtrP, qtCur;\n  vec3 wgBx[4], mVec, mVecP;\n  vec2 iFrag, canvas, mt, cVec, w;\n  float tCur, el, az, asp,tCurM, aSpd;\n  int pxId, wgSel, wgReg, nFrame, rtMode, noInt, juMode;\n  bool reset;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4) discard;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec3 (1.4, -0.6, 0.25);\n  wgBx[1] = vec3 (1.65, -0.85, 0.04);\n  wgBx[2] = vec3 (1.65, -0.35, 0.04);\n  wgBx[3] = vec3 (1.7, 0.9, 0.05);\n  wgSel = -1;\n  wgReg = -2;\n  reset = false;\n  noInt = 1;\n  if (nFrame <= 1) {\n    rtMode = 0;\n    juMode = 1;\n    mPtrP = mPtr;\n    reset = true;\n    tCurM = tCur;\n    el = 0.;\n    az = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    qtCur = stDat;\n    stDat = Loadv4 (2);\n    cVec = stDat.xy;\n    rtMode = int (stDat.z);\n    noInt = int (stDat.w);\n    stDat = Loadv4 (3);\n    tCurM = stDat.x;\n    juMode = int (stDat.y);\n    el = stDat.z;\n    az = stDat.w;\n  }\n  mt = 2. * mPtr.xy * vec2 (asp, 1.);\n  if (noInt > 0) rtMode = 1;\n  if (rtMode == 0) {\n    if (mPtr.z > 0. && mPtrP.z <= 0.) cVec = (mt - wgBx[0].xy) / wgBx[0].z;\n    if (length (cVec) < 1.) mVecP = vec3 (cVec, sqrt (max (0., 1. - dot (cVec, cVec))));\n    aSpd = 1.;\n  } else {\n    cVec = vec2 (0.);\n    mVecP = vec3 (0., 0., 1.);\n    aSpd = 0.01;\n  }\n  if (mPtr.z > 0.) {\n    if (length (mt - wgBx[0].xy) < wgBx[0].z) {\n      cVec = (mt - wgBx[0].xy) / wgBx[0].z;\n      wgReg = 0;\n    }\n    if (length (mt - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) reset = true;\n      wgReg = 1;\n    }\n    if (length (mt - wgBx[2].xy) < wgBx[2].z) {\n      if (mPtrP.z <= 0.) rtMode = 1 - rtMode;\n      wgReg = 2;\n    }\n    if (length (mt - wgBx[3].xy) < wgBx[3].z) {\n      if (mPtrP.z <= 0.) juMode = 1 - juMode;\n      wgReg = 3;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (mPtr.z > 0. && mPtrP.z <= 0. && wgSel >= 0 && wgSel <= 2 && noInt > 0) {\n    reset = true;\n    rtMode = 0;\n    noInt = 0;\n  }\n  if (reset) {\n    cVec = vec2 (0.);\n    qtCur = vec4 (0., 0., 0., 1.);\n    el = 0.;\n    az = 0.;\n  }\n  if (mPtr.z > 0.) {\n    if (wgSel >= 0) {\n      if (wgSel <= 2) tCurM = tCur;\n    } else {\n      el = pi * mPtr.y;\n      az = 2. * pi * mPtr.x ;\n    }\n  } else {\n    if (tCur - tCurM > 3.) noInt = 1;\n    el *= 0.99;\n    az *= 0.99;\n  }\n  if (noInt > 0) {\n    cVec = Rot2D (vec2 (0.5, 0.), 0.1 * pi * tCur);\n    mVecP = vec3 (0., 0., 1.);\n    aSpd *= 0.25;\n  }\n  if (noInt > 0 || wgSel == 0) {\n    mVec = vec3 (aSpd * cVec, sqrt (max (0., 1. - aSpd * aSpd * dot (cVec, cVec))));\n    qtCur = normalize (QtMul (vec4 (cross (mVecP, mVec), dot (mVecP, mVec)), qtCur));\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = qtCur;\n  else if (pxId == 2) stDat = vec4 (cVec, float (rtMode), float (noInt));\n  else if (pxId == 3) stDat = vec4 (tCurM, float (juMode), el, az);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}