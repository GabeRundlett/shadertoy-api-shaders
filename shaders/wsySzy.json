{
    "Shader": {
        "info": {
            "date": "1594599436",
            "description": "mouse, arrow keys, shift and ctrl to move aound.\n\nfrom a comment on [url]https://www.shadertoy.com/view/wdjSzz[/url]\n\"Time to make some saturn rings\"\n     - Duke, 2019-03-18",
            "flags": 48,
            "hasliked": 0,
            "id": "wsySzy",
            "likes": 6,
            "name": "planet with asteroid belts",
            "published": 3,
            "tags": [
                "torus",
                "asteroids"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "#define sun vec3(800,100,1000)\n\n// noise by iq\n// https://www.shadertoy.com/view/4sfGzS\n//////////////////////////////////////////////////////////////\nfloat hash(vec3 p)  // replace this by something better     //\n{                                                           //\n    p  = fract( p*0.3183099+.1 );                           //\n\tp *= 17.0;                                              //\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );              //\n}                                                           //\n                                                            //\nfloat noise( in vec3 x )                                    //\n{                                                           //\n    vec3 i = floor(x);                                      //\n    vec3 f = fract(x);                                      //\n    f = f*f*(3.0-2.0*f);                                    //\n\t                                                        //\n    return mix(mix(mix( hash(i+vec3(0,0,0)),                //\n                        hash(i+vec3(1,0,0)),f.x),           //\n                   mix( hash(i+vec3(0,1,0)),                //\n                        hash(i+vec3(1,1,0)),f.x),f.y),      //\n               mix(mix( hash(i+vec3(0,0,1)),                //\n                        hash(i+vec3(1,0,1)),f.x),           //\n                   mix( hash(i+vec3(0,1,1)),                //\n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z); //\n}                                                           //\n//////////////////////////////////////////////////////////////\n\nvec2 ellipsoid(vec3 ro, vec3 rd, vec3 size) {\n    size = 1.0/max(size, 0.001);\n    \n    ro *= size;\n    rd *= size;\n    \n    float e = 1.0/dot(rd,rd);\n    float b = -dot(rd,ro)*e;\n    vec3 p = ro+rd*b;\n    float a = dot(p,p);\n    if (a > 1.0) return MISS;\n    float c = sqrt((1.0-a)*e);\n    \n    return b+vec2(-c,c);\n}\n\nvec4 cylinder(vec3 p, vec3 r, float s0, float s1) {\n    \n    p.y = 0.0;\n    r.y = 0.0;\n    \n    float l = 1.0/length(r);\n    r *= l;\n    \n    vec3 oc = p;\n    float b = dot( oc, r );\n    float c = dot( oc, oc );\n    float d = c-s0*s0;\n    float e = c-s1*s1;\n    float h = b*b - d;\n    \n    vec4 f = vec4(MISS,MISS);\n    if( h>0.0 ) {\n    \tfloat i = b*b - e;\n        if( i>0.0 ) {\n            i = sqrt(i);\n\n            f.zw = -b + vec2(-i,i);\n        }\n        \n        h = sqrt(h);\n\n        f.xy = -b + vec2(-h,h);\n    }\n    \n    return f*l;\n}\n\nvec2 plane(vec3 ro, vec3 rd, float s) {\n    float a = rd.y;\n    float b = ro.y;\n    \n    float c = abs(s/a);\n    float d = -b/a;\n    \n    return d+vec2(-c,c);\n}\n\nvec4 sqrring(vec3 ro, vec3 rd, float r, vec2 s) {\n    \n    vec2 pln = plane(ro,rd,s.y);\n    pln.x = max(pln.x,0.0);\n    \n    vec4 d = cylinder(ro,rd,r+s.x,r-s.x);\n    \n    d.x = max(d.x,pln.x);\n    \n    if (d.y > d.z && d.w > pln.x) {\n        \n        d = d.xzwy;\n        \n        if (d.x > d.y && d.x < d.z) {\n            d.xy = d.zw;\n            d.zw = MISS;\n        }\n        \n    } else {\n        d.zw = MISS;\n    }\n    \n    d.yw = min(d.yw,pln.y);\n    \n    return d;\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 n, float l) {\n    float a = dot(rd, n);\n    float b = dot(ro,n)-l;\n\n    if (b*a > 0.0) return sign(a)*10000.0;\n\n    return b/abs(a);\n\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nvec4 solid(vec3 p, vec3 rd, float s)\n{\n    float distn = 0.0;\n    float distf = FAR;\n    vec3 dir = vec3(0.,1.,0.);\n    float h = 3.;\n    float v = 6.;\n    mat2 hr = rot(PI * 2.0 / h);\n    mat2 vr = rot(PI * 2.0 / v);\n\tvec3 n;\n    for(float j = 0.; j < v; ++j)\n    {\n        for(float i = 0.; i < h; ++i)\n        {\n            float ran = hash(s + j * i)*0.2;\n\n            float len = plane(p, rd, dir,0.1+ran);\n\n            if (len >= 0.0) {\n                if (len > distn) {\n                    distn = len;\n                    n = dir;\n                }\n            } else {\n                distf = min(distf,-len);\n            }\n\n            dir.xz *= hr;\n        }\n\n        dir.yz *= vr;\n    }\n    if (distf < distn) distn = FAR;\n    return vec4(distn,n);\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 n) {\n    \n    float a = dot(rd,n);\n    float b = dot(ro,n);\n    \n    float d = -b/a;\n    \n    if (d < 0.0) return FAR;\n    \n    return d;\n\n}\n\nvec4 pvoxel(vec3 ro, vec3 rd, vec2 limit, float lines, float pivot, float radius, out float ring) {\n    \n    float orbit = iTime*0.1;\n    float spin = iTime*0.2;\n    \n    ro.xz *= rot(orbit);\n    rd.xz *= rot(orbit);\n    //ro += limit.x*rd;\n    float d = limit.x;\n    vec3 p = ro+rd*d;\n\n    float ang = (atan(p.x,p.z)/PI*0.5+0.5)*lines;\n    float dir = sign(dot(rd.xz,vec2(p.z,-p.x)));\n    float slice = floor(ang-dir);\n    \n    vec2 cell;\n    vec2 lens = vec2(FAR);\n    \n    vec3 rd2;\n    vec3 ird;\n    \n    float maxdist = limit.y-limit.x;\n    \n    float sliceratio = 1.0/lines*2.0*PI;\n    \n    mat2 slicerot = rot(sliceratio);\n    \n    float angle;\n    float angleedge;\n    \n    vec2 pln;\n    vec3 cent;\n\n    float hit = limit.x;\n    \n    for (int i = 0; i < 120; i++)\n    {\n        //if (sin(cell.x)*sin(cell.y) < -0.5) break;\n        if (d > limit.y) break;\n        float len = min(lens.x,lens.y);\n        \n        if (i > 0) {\n            //if (i == 2) break;\n            float l = min(len,hit);\n\n            mat2 rot1 = rot(-angle);\n            mat2 rot2 = rot(-angle*4.0-spin);\n            \n            vec3 c = vec3(0,cell.y,cell.x);\n            ring = dot(c.yz,c.yz);\n            if (ring < radius) {\n                c.zy *= rot2;\n                c.z -= pivot;\n                c.xz *= rot1;\n                \n                vec3 lp = ro-c;\n                vec3 rd2 = rd;\n                mat2 r = rot(iTime);\n                lp.xz *= r;\n                rd2.xz *= r;\n                r = rot(iTime * .5);\n                lp.xy *= r;\n                rd2.xy *= r;\n                r = rot(iTime * .25);\n                lp.yz *= r;\n                rd2.yz *= r;\n\n                vec4 sph = solid(lp,rd2,cell.x+cell.y*1.2432+slice*2.432);\n\n                if (sph.x < l)\n                {\n                    sph.zw *= rot(-iTime * .25);\n                    sph.yz *= rot(-iTime * .5);\n                    sph.yw *= rot(-iTime);\n    \t\t\t\tsph.yw *= rot(-orbit);\n                    \n                    return sph;\n                }\n            }\n        }\n        \n        if (hit < len)\n        {\n        \tslice += dir;\n            slice = mod(slice,lines);\n            d = hit;\n            \n            angle = (slice+0.5)*sliceratio;\n            angleedge = angle+dir*sliceratio*0.5;\n            \n            pln = vec2(cos(angleedge),-sin(angleedge));\n            cent = vec3(sin(angle),0.0,cos(angle));\n\n            float a = dot(rd.xz,pln);\n            hit = -dot(ro.xz,pln)/a;\n            if (a*dir > 0.0) hit = FAR;\n            \n            mat2 rot1 = rot(angle);\n            mat2 rot2 = rot(angle*4.0+spin);\n            \n            rd2 = rd;\n            rd2.xz *= rot1;\n            rd2.zy *= rot2;\n            \n            ird = 1.0/abs(rd2);\n            \n            vec3 p = ro+rd*d;\n            p.xz *= rot1;\n            \n            p.z += pivot;\n            \n            p.zy *= rot2;\n            p.zy += 0.5;\n            cell = floor(p.zy);\n    \t\tlens = d+abs(step(0.0,rd2.zy)-p.zy+cell.xy)*ird.zy;\n        } else {\n            d = len;\n            \n            if (lens.x < lens.y) {\n                lens.x += ird.z;\n                cell.x += sign(rd2.z);\n            } else {\n                lens.y += ird.y;\n                cell.y += sign(rd2.y);\n            }\n        }\n    }\n    return vec4(FAR,vec3(-1));\n}\n\nfloat asteroidring(vec3 ro, vec3 rd) {\n    return 0.0;\n}\n\nvec4 asteroids(vec3 ro, vec3 rd, float far, out float ring) {\n    vec4 l = sqrring(ro, rd, 12.0, vec2(2.5));\n    \n    float a;\n    \n    for (int i = 0; i < 2; i++) {\n        l.y = min(l.y, far);\n        if (l.x < l.y)\n        {\n            vec4 hit = pvoxel(ro,rd,l.xy, 50.0, 12.0, 5.1, ring);\n            if (hit.x < l.y)\n                return hit;\n\n            l.xy = l.zw;\n        } else {\n            break;\n        }\n    }\n    return vec4(FAR,vec3(-1));\n}\n\nvec4 ray(vec3 ro, vec3 rd, out float ring, out int planet) {\n    \n    //temp variables\n    float l = FAR;\n    vec3 n2;\n    float r = -1.0;\n    float r2;\n    \n    // ray variables\n    float d = FAR;\n    vec3 n = vec3(-1);\n    \n    vec3 p = ro;\n    vec2 sph = ellipsoid(p,rd,vec3(7));\n    \n    if (max(sph.x,0.0) < min(sph.y,l)) {\n        l = sph.x;\n        n2 = normalize(ro+rd*l);\n    }\n    \n    vec4 field = asteroids(p, rd, l, r2);\n    \n    if (field.x < l) {\n        r = r2;\n        l = field.x;\n        n2 = field.yzw;\n    }\n    \n    if (l < d) {\n        n = n2;\n        d = l;\n        planet = 1;\n        ring = r;\n    }\n    \n    mat2 rot1 = rot(-0.7);\n    p = ro;\n    vec3 rd2 = rd;\n    p -= vec3(sin(iTime*0.2),sin(iTime*0.2),cos(iTime*0.2))*20.0;\n    p.xy *= rot1;\n    rd2.xy *= rot1;\n    sph = ellipsoid(p,rd2,vec3(7));\n    l = d;\n    n2;\n    r = -1.0;\n    \n    if (max(sph.x,0.0) < min(sph.y,l)) {\n        l = sph.x;\n        r = -1.0;\n        n2 = normalize(p+rd2*l);\n    }\n    \n    field = asteroids(p, rd2, l, r2);\n    \n    if (field.x < l) {\n        r = r2;\n        l = field.x;\n        n2 = field.yzw;\n    }\n    \n    if (l < d) {\n    \tmat2 rot1 = rot(0.7);\n        n2.xy *= rot1;\n        n = n2;\n        d = l;\n        planet = 2;\n        if (p.y+rd2.y*d > 0.0) planet++;\n        ring = r;\n        \n    }\n    \n    //sun\n    p = ro-sun;\n    sph = ellipsoid(p,rd,vec3(70));\n    \n    if (max(sph.x,0.0) < min(sph.y,d)) {\n        d = sph.x;\n        n = normalize(p+rd*d);\n        planet = 4;\n    }\n    \n    \n    \n    return vec4(d,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = getdata(campos).xyz;\n    vec3 rd = normalize(vec3(uv,1));\n\n    vec4 rotcam = getdata(camrot);\n\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n    \n    float ring;\n    int planet;\n    vec4 r = ray(ro,rd, ring, planet);\n    //float ray = pvoxel(ro,rd,vec2(0,FAR),10.0);\n    \n    // Output to screen\n    vec3 col = vec3(0);\n    \n    if (r.x < FAR) {\n    \t\n        vec3 p = ro+rd*r.x;\n        \n        if (planet != 4) {\n            vec3 sundir = normalize(sun-p);\n\n            float a = clamp(dot(r.yzw,sundir),0.3,1.0);\n\t\t\tfloat one; int two;\n            if (ray(p+r.yzw*0.01,sundir,one,two).x < 100.0) a = 0.3;\n            \n            float gray = 0.0;\n\n            if (ring < 1.0)\n                gray = 0.01;\n            else if (ring < 3.0)\n                gray = 0.2;\n            else\n                gray = 1.0;\n\n            col = vec3(gray);\n\n            if (ring < 0.0) {\n                if (planet == 1) {\n                    col = vec3(0.4,0.0,1.0);\n                } else if (planet == 2) {\n                    col = vec3(0.4,0.8,0.4);\n                } else if (planet == 3) {\n                    col = vec3(0.0,0.6,0.0);\n                }\n            }\n\n            col *= a;\n        } else {\n           col = vec3(1,0.5,0); \n        }\n    } else {\n        col = sqr(rd.x*0.5+1.0)*vec3(0.1,0.0,0.9);\n        col += max((sqr(noise(rd*100.0))-0.8)*10.0,0.0);\n        \n    }\n\n    col = clamp(col,0.0,1.0);\n    fragColor = vec4(sqrt(col.xyz),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n\n#define sensitivity 3.0\n#define movespeed 3.0\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n\n//constants\n#define PI radians(180.0)\n#define FAR 10000.0\n#define MISS vec2(FAR,FAR-1.0)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(vec3(0,14,-30.0),1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(vec2(0,-0.5),0,1);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        \n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}