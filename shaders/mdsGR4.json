{
    "Shader": {
        "info": {
            "date": "1665775716",
            "description": "glassy topcoat idear",
            "flags": 0,
            "hasliked": 0,
            "id": "mdsGR4",
            "likes": 8,
            "name": "glossy globs",
            "published": 3,
            "tags": [
                "raymarch",
                "materials"
            ],
            "usePreview": 1,
            "username": "ufffd",
            "viewed": 377
        },
        "renderpass": [
            {
                "code": "// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\n#define PI 3.141592653589793\n#define MAX_STEP 100\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.2\n#define AMBIENT\t\t\t    0.7\n#define SPECULAR_POWER\t\t1.5\n#define SPECULAR_INTENSITY\t1.7\n#define FADE_POWER\t\t\t1.1\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    // sphere 1\n    vec3 sphere1p = p - vec3(0.) + JIGGLE*vec3(\n        noise(vec2(iTime*.7,1.)),\n        noise(vec2(iTime*.8,2.)),\n        noise(vec2(iTime*.9,3.))\n    );\n    float sphere1 = sphereDist(sphere1p + 0.04 - sin(p.y*10.)*0.03 - sin(p.x*p.y*70.+iTime*2.)*0.005 - sin(p.x*10.)*0.02, 0.8);\n    for (int i=0; i<10;i++) {\n        vec3 orboffset = vec3(.9,0.,0.)*(.7+float(i)*0.05);\n        orboffset.xy *= Rot(iTime*-1.-float(i)*0.1);\n        orboffset.xz *= Rot(iTime+float(i)*0.1);\n        vec3 orbp = sphere1p + orboffset;\n        float orb = sphereDist(orbp,0.1);\n        sphere1 = smin(sphere1, orb, 0.2);\n    }\n    for (int i=0; i<10;i++) {\n        vec3 orboffset = vec3(0.,.9,0.)*(.7+float(i)*0.05);\n        orboffset.xy *= Rot(iTime+float(i)*0.1);\n        orboffset.xz *= Rot(iTime+float(i)*0.1);\n        vec3 orbp = sphere1p + orboffset;\n        float orb = sphereDist(orbp,0.1);\n        sphere1 = smin(sphere1, orb, 0.2);\n    }\n    sphere1 = max(-sphereDist(sphere1p,0.65),sphere1);\n    // sphere 2\n    sphere1p.xz *= Rot(iTime*2.);\n    float sphere1in = sphereDist(sphere1p, 0.62);\n    sphere1 = max(-sphere1in, sphere1);\n    if (sphere1 < 0.001) mater = 2.;\n    d = min(d, sphere1);\n    if (sphere1in < 0.001) mater = 1.;\n    d = min(d, sphere1in);\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in float i) {\n    vec3 lightPos = vec3(0, 0, -1);\n    lightPos.xz += vec2(sin(iTime+i), cos(iTime+i))*2.;\n    return lightPos;\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    float dif = 0.;\n    float spec = 0.;\n    for (int i = 0; i<8; i++) {\n        for (int j=0; j<5; j++) {\n            vec3 lp = getLightPos(float(i)*0.5) + vec3(0.,float(j)-2.5 + sin(iTime*0.2)*2.,0.);\n            vec3 l = normalize(lp-p);\n\n            dif += clamp(dot(n, l), 0., 1.);\n            float d = map(p+n*SURF_DIST*2.).x;\n            if(d<length(lp-p)) dif *= .1;\n\n            spec += pow(max( dot( reflect(-l, n), -rd ), 0.), 60.);\n        }\n    }\n    \n    return dif*5. + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.g*10.+norm.r*4. + iTime*.2 + 2.*noise(20.*p.xy*p.yz)));\n        col *= norm;\n        col = col.brr*2.;\n        col.r = smoothstep(0.1,0.2,col.r) * 0.5 + 0.1;\n        col.b = smoothstep(0.1,0.2,col.b) * 0.5 + 0.1;\n        col.g *= .5 + 0.1;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.y += iTime * 0.1;\n        txuv.x *= .5;\n        vec3 text = texture(iChannel0, txuv*0.15).rrr;\n        col = mix(col,text*0.2,1.-col.r);\n        col.b += noise(p.xy * 3. + iTime)*0.1;\n        col.b += noise(p.xy * 2. + iTime)*0.1;\n        col.r += noise(p.xy * 2.5 + iTime*1.1)*0.1;\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84        \n        // repeated code...\n        vec2 txuv = norm.rg;\n        txuv.y += iTime * 0.1;\n        txuv.x *= .5;\n        txuv *= 0.15;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.5,0.3,-3.); \n    ro.xz *= Rot(iTime*0.3);\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uv.x-.15, uv.y-.2, 1.));\n    rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    vec3 backColor = vec3(24., 27., 23.)/255.;\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) { // light the inside only\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        if (rayIndex==2) { // light the inside only\n            col += 0.1*mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += 1.*materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                /*\n                vec3 lp = getLightPos(0.5);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n                */\n                \n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + light) * localColor;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n                \n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    \n    \n    // col += glow*glow*glow*0.000000000000001 * nsin(iTime*.5);\n\n    // Output to screen\n    // col = pow(col, vec3(1.45));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}