{
    "Shader": {
        "info": {
            "date": "1721205115",
            "description": "Une montre avec le theme Tsukuyomi",
            "flags": 0,
            "hasliked": 0,
            "id": "XfsczN",
            "likes": 6,
            "name": "Clock sharingan Tsukuyomi",
            "published": 3,
            "tags": [
                "v1"
            ],
            "usePreview": 0,
            "username": "Sank",
            "viewed": 134
        },
        "renderpass": [
            {
                "code": "#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(-0.2, -0.0)\n\nconst vec3 skycolor = vec3(0.55, 0.0, 0.0);\nconst vec3 bgcolor = vec3(0.1, 0.0, 0.0);\n\nconst float PI = 3.1415926;\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\nmat2 scale(vec2 scale){\n    return mat2(scale.x, 0.0,\n                0.0, scale.y);\n}\nfloat circle( vec2 p, float r ){\n    return 1.0 - smoothstep(0.9* r, r,length(p) - r);\n}\n\nfloat circle_perfect(vec2 p, float r) {\n    return step(length(p), r);\n}\n\nfloat ring( vec2 p, float r ){\n    return circle(p, r) - circle(p, r - 0.03);\n}\n\nfloat semicircle(vec2 p, float r) {\n    float pct = 1.0 - smoothstep(0.9 * r, r,length(p) - r); \n    pct *= step(0.0, p.y);\n    return pct;\n}\n\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec3 line(in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col)\n{\n    float f = sdLine(p, a, b);\n    float g = fwidth(f) * w.y;\n    return mix(buf, col.xyz, col.w * (1.0 - smoothstep(w.x - g, w.x + g, f)));\n}\n\n\nvec2 random2(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat segment(vec2 uv, bool On)\n{\n    if (!On) return 0.0;\n    float seg = (1.0 - smoothstep(0.08, 0.09 + float(On) * 0.02, abs(uv.x))) *\n                (1.0 - smoothstep(0.46, 0.47 + float(On) * 0.02, abs(uv.y) + abs(uv.x)));\n    if (On)\n        seg *= (1.0 - length(uv * vec2(3.8, 0.9)));\n    else\n        seg *= -(0.05 + length(uv * vec2(0.2, 0.1)));\n    return seg;\n}\n\nfloat perlin_noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(\n            dot(random2(i + vec2(0.0)), f - vec2(0.0)),\n            dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)),\n            u.x\n        ),\n        mix(            \n            dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n            dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)),\n            u.x\n        ),\n        u.y\n    );\n}\n\nfloat cloud_wind(vec3 x) {\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    p.z += WIND.x * 10.0 * iTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    return perlin_noise(uv);\n}\n\nfloat density(vec3 pos) {\n    float den = 3.0 * cloud_wind(pos * 0.3) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    return den;\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\n\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol) {\n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; ++i) {\n        if (sum.a > 0.99 ||\n        pos.y < (MIN_HEIGHT - 1.0) ||\n        pos.y > (MAX_HEIGHT + 1.0)) break;\n\n        float den = density(pos);\n        if (den > 0.01) {\n            float dif = clamp((den - density(pos)) / 0.6, 0.0, 1.0);\n            vec3 lin = vec3(0.0);\n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);\n            \n            col.rgb *= lin;\n            sum = sum + col*(1.0 - sum.a);    \n        }\n        t += max(0.05, 0.02 * t);\n        \n       pos = ro + rd * t;\n\n       \n    }\n    sum = clamp(sum, 0.0, 1.0);\n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    return mix(backCol, sum.xyz, sum.a);\n}\n\nvec3 Tsukuyomi(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.1, 1.0));\n\n    float dist = planeIntersect(ro, rd, 3.0);\n\n    \n    vec3 color = mix(bgcolor, skycolor, uv.y * 0.5 + 0.5);\n\n    if (dist > 0.0) {\n        color = raymarching(ro, rd, dist, color);\n       \n        \n    }\n    return color;\n}\nfloat sevenSegment(vec2 uv, int num)\n{\n    float seg = 0.0;\n    \n    // Segment 1 (haut)\n    seg += segment(uv.yx + vec2(-1.0, 0.0), num != -1 && num != 1 && num != 4);\n\n    // Segment 2 (haut gauche)\n    seg += segment(uv.xy + vec2(0.5, -0.5), num != -1 && num != 1 && num != 2 && num != 3 && num != 7);\n\n    // Segment 3 (haut droit)\n    seg += segment(uv.xy + vec2(-0.5, -0.5), num != -1 && num != 5 && num != 6);\n\n    // Segment 4 (milieu)\n    seg += segment(uv.yx + vec2(0.0, 0.0), num != -1 && num != 0 && num != 1 && num != 7);\n\n    // Segment 5 (bas gauche)\n    seg += segment(uv.xy + vec2(0.5, 0.5), num == 0 || num == 2 || num == 6 || num == 8);\n\n    // Segment 6 (bas droit)\n    seg += segment(uv.xy + vec2(-0.5, 0.5), num != -1 && num != 2);\n\n    // Segment 7 (bas)\n    seg += segment(uv.yx + vec2(1.0, 0.0), num != -1 && num != 1 && num != 4 && num != 7);\n\n    return seg;\n}\n\nvec3 drawNumber(vec3 col, vec2 uv, float r, float angle, int num)\n{\n    vec2 offset = r * vec2(cos(angle), sin(angle));\n    float seg = 0.0;\n    vec2 pos = (uv - offset) * 13.0;\n    \n    if (num == 10 || num == 11 || num == 12)\n    {\n        seg += sevenSegment(vec2(pos.x+0.7, pos.y), 1);\n        \n        if (num == 10)\n            seg += sevenSegment(vec2(pos.x - 0.8, pos.y), 0);\n        else if (num == 11)\n            seg += sevenSegment(vec2(pos.x - 0.6, pos.y), 1);\n        else if (num == 12)\n            seg += sevenSegment(vec2(pos.x - 0.8, pos.y), 2);\n    }\n    else\n    {\n        seg = sevenSegment((uv - offset) * 13.0, num);\n    }\n\n    if (seg < 0.0)\n        seg = -seg;\n\n    col = mix(col, vec3(1.0, 1.0, 1.0), seg);\n    return col;\n}\n\n\n\n\nfloat gouYu(vec2 p, float progress) {\n    float pct = circle(p, 0.2 - 0.1 * progress);\n    pct += semicircle(p + vec2(-0.2 - 0.2 * progress, 0.0), 0.3);\n    pct -= semicircle(p + vec2(-0.6, 0.0), 0.15 + 0.05 * progress);   \n    return step(1.0, pct);\n}\n\nfloat eye(vec2 p, float gouyuState) {\n    float pct = circle_perfect(p, 0.9);   \n    \n    float scale = 3.0 - 1.78 * gouyuState;\n    float offsetScale = 1.5 - 1.4 * gouyuState;\n    \n    vec2 uv = scale * p;\n\n    vec2 offset = - offsetScale * vec2(cos(PI / 3.0), sin(PI / 3.0));\n    vec2 pTemp = rotate2d(PI) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);\n    pTemp = rotate2d(5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n    pTemp = rotate2d(-5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n\n    pct -= (1.0 - 4.0 * gouyuState) * circle_perfect(p, 0.06);\n    pct -= ring(p, 0.28) * (1.0 - gouyuState);\n    pct -= ring(p, 0.48);\n    \n    float opacity = 1.0 - length(p) * length(p) * length(p);\n    return pct * opacity;\n}\n\nvec4 sharingan(vec2 st, float openProcess, float mangekyoSharinganProgress, float t) {\n    \n    vec4 color = vec4(0.0);\n    float height = 0.55 * abs(mod(0.5 * iTime, 1.1) - 0.55);\n    height = 0.55 * openProcess;\n\n    float t1 = (clamp(t, 2.0, 8.0) - 2.0) / 6.0;\n    float x = sin(t1 * PI * 0.5);\n    x = x * x * x;\n    mat2 eyeRotate = rotate2d(-x * x * 16.0) * 1.0;\n    \n    vec2 eyeoffset = vec2(0.0, 0.0);\n    float pct = 1.0;\n    //color += vec4(pct) - circle(3.6 * st  + eyeoffset, 0.5) * pct;  \n\n    pct *= eye((1.0 * st + eyeoffset) * eyeRotate, mangekyoSharinganProgress);\n  \n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0);\n    \n    \n\n    // ----  ---- //\n    float opacity = 0.2;\n    float t2 = clamp(t, 0.5, 1.5) - 0.5;\n    //t2 = 1.0;\n    float scale = clamp(.2 / t2, 0.3, 1.0);\n    opacity = (scale - 0.3) * 0.5  * step(1.0, openProcess);\n    pct = eye((3.0 * st + eyeoffset) * scale * eyeRotate, mangekyoSharinganProgress);\n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0) * opacity;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float mils = fract(iDate.w);\n    float secs = mod(floor(iDate.w), 60.0);\n    float mins = mod(floor(iDate.w / 60.0), 60.0);\n    float hors = mod(floor(iDate.w / 3600.0), 24.0);\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    float r = length(uv);\n    float a = atan(uv.y, uv.x) + 3.1415926;\n\n    vec3 nightColor = vec3(0.0, 0.0, 0.0) + 0.1 * uv.y;\n    vec3 dayColor = vec3(0.0, 0.0, 0.0) + 0.2 * uv.y;\n    vec3 col = mix(nightColor, dayColor, smoothstep(5.0, 7.0, hors) -\n                              smoothstep(19.0, 21.0, hors));\n    \n                              \n    \n\n    float f = abs(2.0 * fract(0.5 + a * 60.0 / 6.2831) - 1.0);\n    float g = 1.0 - smoothstep(0.0, 0.1, abs(2.0 * fract(0.5 + a * 12.0 / 6.2831) - 1.0));\n    float w = fwidth(f);\n    f = 1.0 - smoothstep(0.1 * g + 0.05 - w, 0.1 * g + 0.05 + w, f);\n    f *= smoothstep(0.85, 0.86, r + 0.05 * g) - smoothstep(0.94, 0.95, r);\n    col = mix(col, vec3(1.0, 0.0, 0.0), f);\n\n    vec2 dir;\n    dir = vec2(sin(6.2831 * secs / 60.0), cos(6.2831 * secs / 60.0));\n    col = line(col, vec2(0.0), dir * 0.9, uv, vec2(0.005, 1.0), vec4(1.0, 1.0, 1.0, 1.0));\n\n    dir = vec2(sin(6.2831 * mins / 60.0), cos(6.2831 * mins / 60.0));\n    col = line(col, vec2(0.0), dir * 0.7, uv, vec2(0.015, 1.0), vec4(1.0, 1.0, 1.0, 1.0));\n\n    dir = vec2(sin(6.2831 * hors / 12.0), cos(6.2831 * hors / 12.0));\n    col = line(col, vec2(0.0), dir * 0.4, uv, vec2(0.015, 1.0), vec4(1.0, 1.0, 1.0, 1.0));\n    \n    //col = mix( col, vec3(0.1), 1.0-smoothstep(0.050,0.055,r) );\n    \n\n    float angle6 = (9.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle6, 6);\n\n\n    float angle7 = (8.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle7, 7);\n\n\n    float angle8 = (7.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle8, 8);\n\n\n    float angle9 = (6.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle9, 9);\n\n\n    float angle10 = (5.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle10, 10);\n\n\n    float angle11 = (4.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle11, 11);\n\n\n    float angle12 = (3.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle12, 12);\n    \n\n    float angle1 = (2.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle1, 1);\n\n\n    float angle2 = (1.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle2, 2);\n\n\n    float angle3 = (0.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle3, 3);\n\n\n    float angle4 = (-1.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle4, 4);\n\n    float angle5 = (-2.0 - 12.0) / 12.0 * 6.2831;\n    col = drawNumber(col, uv, 0.8, angle5, 5);\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    st = st * 2.0 - 1.0;\n    st *= 1.5;\n    st.x -= 1.2;\n    st.x = -st.x;\n\n    st = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.xy;\n    col += Tsukuyomi(st) * ((clamp(2.0 * iTime, 1.0, 3.0) - 1.0) / 2.0);\n    \n    float time = mod(iTime, 15.0);\n    float openProcess = clamp(time, 0.0, 0.5) * (12.0 - clamp(time, 11.5, 12.0)) * 4.0;\n    float sharinganProgress = (clamp(time, 4.0, 6.0) - 4.0) * 0.5;\n     //float sharinganProgress =0.2;\n    vec4 color = sharingan(uv, openProcess, sharinganProgress, time);\n    col += color.xyz;\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}