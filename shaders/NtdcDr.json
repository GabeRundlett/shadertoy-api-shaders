{
    "Shader": {
        "info": {
            "date": "1659635124",
            "description": "potato  t",
            "flags": 32,
            "hasliked": 0,
            "id": "NtdcDr",
            "likes": 19,
            "name": "Day 959",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 956\" by jeyko. https://shadertoy.com/view/7l3yz4\n// 2022-08-04 09:07:01\n\n// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    C *= 0.;\n    \n    float sc = 1./(1.+0.*max(15.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.5)*0.;\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    float db = sdBox(nuv,vec2(0.4 + float(lightMode==0.)*float(fract(iTime*0.125)<0.5)*0.24,0.4));\n    \n    vec4 aa = Ta(uv);\n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    \n    \n    \n    //vec2 st = 0.4/R.xy + 0.1*sin(iTime)*float(hash11(floor(iTime)) < 1. && lightMode == 0.);\n    vec2 st = (0.1 + 0.*float((fract(iTime*0.2)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    int cmp = 3 - int(lightMode);\n    float l = \n        Tb(uv + vec2(st.x,0))[cmp]-(Tb(uv - vec2(st.x,0)))[cmp] +\n        Tb(uv + vec2(0,st.y))[cmp]-(Tb(uv - vec2(0,st.y)))[cmp] +\n        Tb(uv + vec2(st.xy))[cmp]-(Tb(uv - vec2(st.xy)))[cmp] +\n        Tb(uv + vec2(st.x,-st.y))[cmp]-(Tb(uv - vec2(st.x,-st.y)))[cmp]\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n    if(db > 0.){\n        //b = 1.-step(b,vec4(0.4,0.1,0.4,1));\n        b *= 0.1;\n        //b = 1.-b;\n    }\n\n\n    \n    C += vec4 (1)- b*1. - abs(a.y)*0. ;\n    \n    C = mix(C,vec4(0),l );\n    C = mix(C,vec4(0),aa.x );\n    // britney\n    C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.1;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if((id.x) > 28.){\n            if(r.y < 0.1){\n                if(r.x < 0.5)\n                    d = abs(d) - 0.0004;\n                \n                //C = mix(C,vec4(0),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.5){\n                C = mix(C,vec4(0),1.);\n                \n            }\n               \n        }\n         \n    }\n    \n    {\n        // ui crosses\n        vec2 p = uv;\n        \n        vec2 sid = vec2(float(p.x > 0.),float(p.y > 0.))*2. - 1.;\n        p = abs(p) - vec2(0.45,0.2);\n        float md = 0.0156;\n        \n        float trig = fcondmore(iTime, 0.1,0.3);\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        vec2 sz = vec2(0.004,0.004 + trig);\n        float d = sdBox(p.xy,sz);\n        d = length(p.xy);\n        if(lightMode == 1.)\n            d = min(d,sdBox(p.xy,sz.yx)) ;\n        if(trig == 1.)\n            d = max(d,-sdBox(p.xy,vec2(0.003))) ;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if(abs(id.x) < 1. + trig*1. && abs(id.y) < 1. + hash12(sid + floor(iTime*4.))*1.*(lightMode*2.-1.)*(1. + trig*1. )){\n        \n            if(d < 0.){\n                C = vec4(1);\n                if(r.y < 0.4){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n\n                }    \n            } else{\n                C = 1. - C;\n            }\n            \n               \n        }    \n    \n        // ui;\n        p = uv;\n        \n        md = 0.0156;\n        \n        id = floor(p/md);\n        p = pmod(p,md); \n        \n        d = length(p.xy) - 0.004;\n        \n        ra = hash12(id + 10.);\n        r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        if(abs(id.y) < 4. && (id.x) < -28.){\n        \n            if(  sin(iTime + sin(r.y*3.)*4.)> 0.){\n                if(r.y < 0.1){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n\n                }\n\n            } else{\n                C = vec4(0);\n            }\n        } \n         \n    }    \n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    //C = mix(C,n.xyzx,n.xyzz);\n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    C = mix(C,1.-C,float(fract(iTime*0.2) < 0.05)*lightMode);\n    \n    //C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    C = max(C,vec4(0.01));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.2) <0.5 )\n\n#define hardMode(t) float(fract(t*0.1) >0.8 )\n\n#define fcondless(t,c,l) float(fract(t*c) < l)\n#define fcondmore(t,c,l) float(fract(t*c) > l)\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n    \n    lookAt.z = 4.;\n    lookAt.y = 0. + 2. * hardMode(t);\n    lookAt.x = 0.0;\n    lookAt += 0.2*sin(t*vec3(1,0.8,0.9));\n    \n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,1.,-0.8);\n    ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    //ro.yz *= rot(sin(t)*0.4);\n    \n    //ro.xz *= rot((t + sin(t*1.4))*0.2);\n    ro.xz *= rot(m.x/r.x - 0.5);\n    ro.yz *= rot(m.y/r.x - 0.5);\n    return ro;\n}\n\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 5.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    \n    \n    \n    if(abs(id.y) < 1. && id.x < 16.  && id.x >= 0. && char < 200.){\n        if( id.x < 16. - n14(idx + 200.).x*15. ){\n            vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n            t = letter.w - opacity;\n            if(abs(p.x-1./16./2.)>1./16./2.)\n                t = 10e4;\n\n            t /= s*10.1;\n        } else {\n            return -10.;\n        }\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 1. + 0.*floor(hash11(floor(iTime + 200.))*8.)*float(hash11(floor(iTime)) < 0.2);\n    fragCoord = floor(fragCoord/sc)*sc;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    \n    \n   fragColor *= 0.;\n   if((lightMode==0.)){\n        vec2 p = (uv + vec2(-0.58,0.))*15.;\n        p.y += iTime;\n        float md = 0.4;\n        float id = floor(p.y/md);\n        p.y = mod(p.y,md);\n        if(mod(id*0.1 + sin(iTime*0.1+id),1.) < 0.5){\n            float td = text(p, float[4*4](\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,96.,96.,96.\n                ), -0.5 , 0.2 , false, 0., 0.5 , true, id);\n            fragColor = mix(fragColor,vec4(1),smoothstep(0.004,0.,td));\n        }\n        \n        \n    }  \n    \n    //col = 1.- col;\n    //fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// raymarch\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\nfloat gid;\n\nfloat map(vec3 p){\n    \n    \n    //float n = noise(p*10.)*0.01;\n    \n    float d = 10e5;\n    \n    \n    if(fract(iTime*0.125) < 0.5)\n        d = min(d,abs(abs(p.x )- 4.));\n    //p.y;\n    \n    p.x = abs(p.x);\n    \n    p.z += (iTime + sin(iTime)*0.7)*0.5;\n    \n    float md = 0.2 + 0.6 * (1.-lightMode)*mod(floor(iTime*0.2),2. );\n    \n    float id = gid = p.z/md;\n    p.z = pmod(p.z,md);\n   \n   \n    float sz = 0.003 + float(fract(iTime*0.15) > 0.9)*0.01;\n    p.x -= 0.4;\n    p.xy *= rot(4.5 + sin(id));\n    \n    \n    float noodlePer = 0.1;\n    float noodles = float(fract(iTime*0.1) < 0.4);\n    float noodlesId = floor(iTime*0.1);\n    \n    if(noodles == 1.)\n        p.x += sin(dot(p,p)*(1.) - iTime)*0.4;\n        \n    d = min(d,length(p.xz) - sz);\n    \n    \n    for(float i = 0.; i < 1.; i++){\n        p.xy = (abs(p.xy -1.*sin(id + iTime*0.4)*.3) ) * rot(1.5 + sin(id + iTime*0.1));\n\n        d = min(d,length(p.xz) - sz);\n\n    }\n    \n    \n    //d -= abs(noise(p*01.401))*0.01;\n    //p.xy *= rot(p.z + sin(iTime + p.z)*4.);\n    \n    //d -= noise(p*1.)*max(noise(p*4. + 14.),0.)*0.04;\n    //d = min(d, \n    //    length(p.xy) + sin(p.z + iTime)*0.3*noise(p*5.)*0.8 - 0.1  + smoothstep(1.,1.,abs(p.z))\n    //);\n    return d;\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001 + lightMode*0.01,0.);\n    \n    return normalize(vec3(\n        map(p + vec3(t.xyy)) - map(p - vec3(t.xyy)),\n        map(p + vec3(t.yxy)) - map(p - vec3(t.yxy)),\n        map(p + vec3(t.yyx)) - map(p - vec3(t.yyx))\n    ));\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    float sc = 1. + 3.*float(fract((iTime + 2.)*0.15) < 0.1) ;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n    //uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    //vec2 t = 1./R.xy;\n    //vec4 l = vec4(\n    //    luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n    //    luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    //);\n    //l = abs(l);\n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    C -= C;\n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    //rd = getRd(ro, lookAt,  uv );\n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    for(float i = 0.; i < 1840. - 500.*float(fract(iTime*0.25)>0.8); i++){\n        float d = map(p);\n        \n        if(d < 0.001){\n            hit = true;\n            break;\n        } else if(t > 24.5){\n            break;\n        }\n        d *= 0.06;\n        \n        p = ro + rd * (t += d);\n    }\n    if(hit == false){\n        t = 1000.;\n    } else{\n        \n        vec3 n = getNormal(p);\n        \n        \n        C.x += max(dot(n,normalize(vec3(4,1.,-2. + lightMode*14.* float(mod(gid + iTime*1.,2.))<1.))),0.);\n        \n        \n        //C.y = gid;\n    }\n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    \n    C.w = t;\n    \n    //C.y = l;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// dither\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),14.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 4. - hash11(idx)*4.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    int dithsc = (2 + 1*int(fract(iTime*0.1) < 0.2));\n    \n    vec2 dithu = U.xy/vec2(textureSize(iChannel1,0).xy*dithsc);\n       \n    \n    \n    if(enva(iTime) < 0.25)\n        dithu = vec2(\n            mod(U.y/float(dithsc),float(textureSize(iChannel1,0).x)),\n            mod(floor(U.y/float(dithsc))/float(textureSize(iChannel1,0).x),float(textureSize(iChannel1,0).y))\n        );\n   \n    float dith = texture(iChannel1,dithu).x;\n    \n    \n    float quant = 2. - hardMode(iTime)*1.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.x*vec3(1));\n    s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.1,0.*hardMode(iTime) )).xyzz;\n    //s = vec4(luma(s));\n    //s = vec4(s.x);\n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n    //C = sin(Ta(uv));\n    \n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        palCHsv.b += sin(iTime*(1. + float(fract(iTime*0.5) < 0.5)) + float(i))*1.;\n        float localSimilarity = dot(palCHsv.b, Chsv.b);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz *= hit;\n    \n    uv = (U - 0.5*R.xy)/R.y;\n    \n   \n          /*\n    \n    vec3 OC = C.xyz;\n    \n    C = vec4(1);\n    \n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    uv = (U - 0.5*R.xy)/R.y;\n    \n    float rep = 0.004;\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n      \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n\n    {\n        \n        vec2 lastDotPos = vec2(0);\n        float lastDD = 10e5;\n        for(float i = 0.; i < 140.; i++){\n            vec3 dotPos = max(hash31(i + 20.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            //lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            if(i < 20.){\n                d = max(\n                    min(abs(lp.x),abs(lp.y)),\n                    sdBox(lp,vec2(0.1,0.01))\n                    ) - 0.001 - 0.00*pow(abs(sin(i + iTime)),5.);\n            }else{\n                lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                 if(i<130.){\n                    float dd = length(lp) - 0.04*sin(i + iTime + sin(iTime + i));\n\n                    if(r.y > 0.5)\n                        d = abs(dd) - 0.001 ;\n                    else\n                        d = (dd) - 0.001 ;\n\n                    if(lightMode == 0.){\n\n                       float l = sdSegment(uv,projPos.xy,lastDotPos.xy)-0.004*(sin(i + iTime*2.));\n                       if(mod(idd,2.) == 0.)\n                           l = 10e5;\n                       d = min(d,max(max(l,-dd),-lastDD));\n                    }\n\n                    lastDD = dd;\n\n                } else {\n                    if(lightMode == 0.)\n                        continue;\n                    d = length(lp.y) - 0.004 ;\n                }\n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            C -= smoothstep( 1./R.x, 0. , d);\n        }\n        \n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n\n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            C = mix(C,vec4(0),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n        }\n\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n    */\n    C = clamp(C,0.,1.);\n    //C = mix(vec4(OC.xyz,1),vec4(1,1,1,0),dot(1.-C.x,1.-C.x));\n    //C = currC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    char -= 544. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 4. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    uv.x = abs(uv.x);\n    \n    uv.x -= 0.4;\n    vec2 t = 1./R.xy;\n    \n    \n    \n    vec2 prevP = vec2(0);\n    \n    float d = 10e4;\n    for(float i = 0.; i < 0.; i++){\n        vec2 k = vec2(sin(i*0.7 + sin(iTime + i)), cos(i*1.5 + iTime)*2.)*0.1;\n            \n            \n            \n        d = min(d,sdSegment(uv,k,prevP) - 0.004 - noise(vec3(i+iTime + sin(iTime + i),uv*5.))*0.01);\n        \n        \n        prevP = k;\n    }\n   \n   float od = d;\n   d = abs(d);\n   C *= 0.;\n   //C += 1.; // epic lol\n   \n   \n\n   C= mix(C,1.-C,smoothstep(0.,fwidth(d),d - 0.004));\n   \n   if(od < 0.)\n       return;\n   U = oU;\n    sc = 1. + 0.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(iTime) + 200.)*1.8;\n   u *= 0.4 - hash11(floor(iTime))*0.1;\n   u*=2. + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 1.;\n   \n\n    //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && fract(iTime) < 0.2 && sin(iTime) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       \n       vec2 dithu = oU.xy/vec2(textureSize(iChannel1,0).xy*(1 + 0*int(fract(iTime*0.1) < 0.2)));\n       \n       float dith = texture(iChannel2,dithu).x;\n        \n    \n        float quant = 1.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n\n       //britney = hsv2rgbSmooth(currColHsv*vec3(0.2,0.,1.) + vec3(1. + iTime,0.5,0.)).xyzz;\n\n       C -= 1.- britney;\n   }\n    \n    \n    sc = 2.;\n    U = floor(U/sc)*sc;   \n    uv = (U-R.xy*0.5)/R.y;\n    \n    float pxsz = 0.001;\n    float tt =10e5;\n\n \n             \n            \n    C = mix(C,(0.6-C) ,smoothstep(pxsz + 0.01,0., tt - 0.01));\n    \n    uv = (oU-R.xy*0.5)/R.y;\n    \n    if(fract(iTime*0.5)>0.75)\n    for(float i = 0.; i < 2. - 4.*hash11(floor(iTime) ); i++){\n        vec3 dotPos = max(hash31(i + 1200. + floor(iTime)),0.4)*2. - 1.;\n        vec2 lp = uv - dotPos.xy;\n        lp *= 17.4;\n\n        float md = 0.3;\n        float id = floor(lp.y/md);\n        if(id < 2. || id > 9. + sin(i)*20.)\n            continue;\n        lp.y = mod(lp.y,md);\n        float td = textb(lp, float[4*4](\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,96.,96.,96.\n            ), -0.5 , 0.2 , false, 0., 0.47 , true, id + i*20. + floor(iTime*10.));\n        C = mix(C,vec4(0),smoothstep(0.001,0.,td - 0.4));\n    }\n    \n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}