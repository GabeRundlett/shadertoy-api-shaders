{
    "Shader": {
        "info": {
            "date": "1567057577",
            "description": "Rusty metal. Works fine with different textures.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlXSzn",
            "likes": 13,
            "name": "PBR with Texture",
            "published": 3,
            "tags": [
                "pbr"
            ],
            "usePreview": 1,
            "username": "zxxuan1001",
            "viewed": 838
        },
        "renderpass": [
            {
                "code": "#define AA_SIZE 2\n#define PI 3.1415926\n#define EPSILON 0.0001\n#define IBL 1\nconst int MAX_STEPS = 120;\nconst float MAX_DISTANCE = 60.0;\nconst vec3 FOG_COLOR = vec3(0.9, 0.9, 0.7);\nconst float ROUGHNESS = 0.5;\nconst float METALLIC = 1.0;\nconst vec3 LIGHT_COLOR = vec3(300.0, 300.0, 250.0);\n\nfloat plane(vec3 p) \n{\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec2 unionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x < d2.x? d1 : d2;\n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec3 rotX(vec3 p, float d) \n{\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 rotY(vec3 p, float d) \n{\n    mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                    0.0, 1.0, 0.0, 0.0,\n                    -sin(d), 0.0, cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\n\nvec3 rotZ(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                    sin(d), cos(d), 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec2 sceneSDF(vec3 p) \n{\n    vec2 result = vec2(plane(p), -1.0);\n    \n    vec3 p1 = doTranslate(p,vec3(0.0, 3.5 , 0.0));\n    vec2 result1 = vec2(sdSphere( p1, 3.0));  \n    result1.x *= 0.4;\n    result = unionSDF(result, result1);\n    return result;\n}\n\nvec2 marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.01;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.y = -1.0;\n            result.x = tmax;\n            break;\n        }\n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).x;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).x;\n        occ += ( h - d ) * sca;\n        sca *= 0.85;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nconst vec2 OFFSET = vec2(EPSILON, 0.0);\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + OFFSET.xyy).x - sceneSDF(p - OFFSET.xyy).x,\n        sceneSDF(p + OFFSET.yxy).x - sceneSDF(p - OFFSET.yxy).x,\n        sceneSDF(p + OFFSET.yyx).x - sceneSDF(p - OFFSET.yyx).x\n    ));\n}\n\nvec3 ground(vec2 uv) \n{\n    vec3 col = vec3(0.5, 0.4, 0.3);\n    return  col; \n}\n\n//Distribution/concentration\nfloat D_GGX(float dotnh, float roughness) \n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotnh2 = dotnh * dotnh;\n    float denom =  max(dotnh2 * (a2 - 1.0) + 1.0, EPSILON);\n    return a2 /(PI * denom * denom);\n}\n\nfloat G_SGGX(float dotnv, float roughness)\n{\n    //for direct lighting\n    float r = roughness + 1.0;\n      \n#ifdef IBL\n    float k = roughness * roughness / 2.0;\n#else\n    float k = (r * r) / 8.0; \n#endif\n    \n    return dotnv / (dotnv * (1.0 - k) + k);\n}\n//Geometry/shadowing masking\nfloat G_Smith(float dotnv, float dotnl, float roughness)\n{\n    \n    float ggx1 = G_SGGX(dotnv, roughness);\n    float ggx2 = G_SGGX(dotnl, roughness);\n    return ggx1 * ggx2;\n}\n//Fresnel/reflectivity\nvec3 Fs(float dothv, vec3 f0)\n{\n    return max(f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0), 0.0);\n}\n\nvec3 PBL(vec3 ro, vec3 p, float objId) \n{\n    vec3 Lo = vec3(0.0);\n    vec3 lights[2];\n    vec3 lightColor = LIGHT_COLOR;\n    lights[0] = vec3(6.0, 8.0, -3.0);\n    lights[1] = vec3(-6.0, 8.0, -3.0);\n    \n    \n    vec3 viewDir = ro - p;\n    vec3 V = normalize(viewDir);\n    vec3 N = getNormal(p);\n    \n    vec3 albedo = vec3(0.6, 0.6, 0.3); //surface color\n    float metallic = METALLIC;\n    float roughness = ROUGHNESS;\n    float u = atan(N.x, N.z) / PI + 0.5;\n\tfloat v = N.y * 0.5 + 0.5;\n    vec3 tex = texture(iChannel0, vec2(u,v)).rgb;\n    float greyScale = dot(tex, vec3(0.299, 0.587, 0.114));\n    metallic = 1.0-tex.r; //(tex.r + tex.g + tex.b) / 3.0;\n    roughness = 1.0 - greyScale * 2.0;\n    \n    if (objId == -1.0) \n    {//floor     \n        albedo = ground(p.xz); \n    } else\n    {\n        albedo = pow(tex, vec3(2.2));\n    }\n    \n    for (int i = 0; i < 2; i++)\n    {\n        vec3 lightPos = lights[i];\n        \n        vec3 lightDir = lightPos - p;\n        float dist = length(lightDir);\n \n        vec3 L = normalize(lightDir);\n        vec3 H = normalize(V + L);\n        \n        float sd = calcShadow(p, normalize(lightPos));\n        float att = 1.0 / ( dist * dist );\n        vec3 radiance = lightColor * att * sd; \n\n        float dothv = max(dot(H, V), 0.0);\n        float dotnh = max(dot(N, H), 0.0);\n        float dotnv = max(dot(N, V), 0.0);\n        float dotnl = max(dot(N, L), 0.0);\n\t\t\n        //Cook-Torrance specular BRDF term\n        vec3 f0 = vec3(0.04);\n        f0 = mix(f0, albedo, metallic);  \n        vec3 F = Fs(dothv, f0);\n        \n        float D = D_GGX(dotnh, roughness);\n        float GS = G_Smith(dotnv, dotnl, roughness);\n        \n        vec3 nom = D * GS * F;\n        float denom = 4.0 * dotnv * dotnl;\n        vec3 Fct = nom / max(denom, EPSILON); //avoid zero denom\n\n        vec3 Ks = F; //specular\n        vec3 Kd = 1.0 - Ks; //diffuse \n        Kd *= 1.0 - metallic;\n        \n        //Lambert\n        vec3 Fl = albedo/PI; \n        \n        //final results\n        Lo += (Kd * Fl + Fct) * radiance * dotnl; \n    }\n    \n    float ao = calcAO(p, N);\n    vec3 ambient = vec3(0.05) * albedo * ao;\n    return ambient + Lo ;\n}\n\n \n\nmat3 getCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 fog(in vec3 pixColor, in float dist) \n{\n    return mix(pixColor, vec3(0.8), 1.0 - exp(-dist * 0.003));\n}\n\nvec3 background(vec2 uv) \n{\n    vec3 col = vec3(0.0);\n    return col;\n}\n\n\nvec3 render(in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x/iResolution.y; // restore aspect ratio\n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.1) + iMouse.xy / iResolution.xy ;\n    mouse -= 0.5;\n    float t = iTime * 0.1;\n    vec3 ro = vec3(8.0 * cos(mouse.x * 2.0 * PI + t),  4.0 + mouse.y * 3.0, 8.0 * sin(mouse.x * 2.0 * PI + t));\n    vec3 ta = vec3(0.0, 4.0, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.2));\n    \n    vec2 h = marching(ro, rd);\n    vec3 p = ro + rd * h.x;\n    if (h.x < MAX_DISTANCE) \n    {\n        if (h.y == 0.0) \n        {\n            col = vec3(0.0);\n        } \n        \n        col += PBL(ro, p, h.y);\n    } else \n    {\n        //background\n        col = background(uv); \n    }\n    \n    col = fog(col, h.x); \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float count = 0.0;  \n    vec3 col = vec3(0.0);\n#if AA_SIZE>1 \n   \n    for (float aay = 0.0; aay < float(AA_SIZE); aay++) \n    {\n        for (float aax = 0.0; aax < float(AA_SIZE); aax++) \n        {\n            col += render(fragCoord + vec2(aax, aay)/float(AA_SIZE));\n            count++;\n        }\n    }\n    col /= count;\n#else\n    col = render( fragCoord );\n#endif\n    \n \tcol = col / (col + vec3(1.0));\n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}