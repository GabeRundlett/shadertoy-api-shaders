{
    "Shader": {
        "info": {
            "date": "1590255494",
            "description": "\nSDF and coloring from https://www.shadertoy.com/view/WtV3Rw\nMDTMJVM = Middecembertomidjanuaryvember\nA month of coding stuff.\nCoding some of the days at http://twitch.tv/wwrighter",
            "flags": 32,
            "hasliked": 0,
            "id": "wdSBRG",
            "likes": 5,
            "name": "Sunakai",
            "published": 3,
            "tags": [
                "pathtracer",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 917
        },
        "renderpass": [
            {
                "code": "// 4k executable graphics for Outline 2020 demoparty\n\n// Code is pretty messy\n\n// noby's \"Devour\" artwork I used as a reference to learn DOF, so there are remnants of that in the code.\n\n// Thx to fizzer for the cosineDirection()\n// Dave Hoskins for hashes\n// Krzysztof Narkowicz for the ACESFilm()\n// slerpy, noby, and Luna, whose code I learned pathtracing tricks from\n\n#define S 0.5\n\n#define resolution iResolution.xy\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\n#define M 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec4 col = vec4(0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    col = texture(iChannel0,uv);    \n    col /= col.w;\n    \n    vec2 uvs = (fragCoord / iResolution.xy - 0.5) * (resolution.x/resolution.y) * 2.0;\n\n\t\n    col *= 0.16;\n    uvs *= 0.34;\n    col *= smoothstep(1.,0.,pow(dot(uvs,uvs),1.)/1.5);\n    col.xyz = mix(col.xyz,smoothstep(0., 1., col.xyz),0.5);\n    col.xyz = ACESFilm(col.xyz);\n\tcol = pow(col, vec4(0.45));;\n    \n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define zoom 0.\n\nint BOUNCES = 3;\n\n#define MARCH_ITERATIONS 230\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n\n#define fogCol vec3(0.12,0.15,0.2)*2.\n#define giAmt 0.4\n\n\nfloat seed;\nfloat side = 1.;\n\nvec3 fog = vec3(0.);\nvec3 prevP;\n\nvec3 attenuation = vec3(1.);\n\n\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec3 p){\n\n    float n = 0.;\n    p *= 2.;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*2.8);\n    \n\n    n += f*1. + q*0.5;\n    \n\treturn n;\n}\n\n\nvec2 fc;\nfloat sd;\nvec2 hash2(float n){\n    vec2 rand = texelFetch(iChannel1, ivec2(mod(fc,1024.)),0).rg;\n    rand += hash(sd+float(iFrame)+n);\n    return mod(rand, 1.0);\n}\n\n\n\nMaterial materials[6] = Material[](\n\tMaterial(vec3(1.,0.4,1)*1.1,499.,0.,1.), // unused\n\tMaterial(vec3(0.,0.5,0.6)*1.,14.,0.0,0.9), // ?\n\tMaterial(vec3(1.),0.,0.,0.), \t\t\t// diffuse\n\tMaterial(vec3(1.,0.2,0.1)*1.,165.,0.9,0.1),\t// light \n\tMaterial(vec3(0.8,0.4,1.4)*3.5,0.,0.9,2.0), // xtal refractive\n\tMaterial(vec3(0.8,0.4,1.4)*3.5,0.,0.9,2.0) \t// xtal reflective\n);  \n\n\n\nfloat pmodpol(inout vec2 uv, float rep){\n    uv.xy *= rot(pi/rep);\n    float id = floor(rep*atan(uv.x,uv.y)/tau + rep*0.5);\n    uv.xy *= rot(0.5*pi);\n    uv *= rot((id+1.)/(rep)*tau + tau/rep);\n    uv.xy *= rot(-pi/rep);\n    return id;\n}\n\n\nvec3 glow = vec3(0);\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdRhombicDodecahedron( vec3 p, float s)\n{\n    vec3 q = p;\n  \tq = abs(q)- s;\n \tfloat d = max(q.y,max(q.x,q.z));\n \t\n    float sSc = 1.42;\n    \n    //d = 10e6;\n    \n    float topUnsc = 1.3;\n    \n    q = p;\n    \n    p.xy *= rot(0.25*pi);\n    p.z = abs(p.z);\n        \n    p.z -= 1.*s;\n    p.z *= topUnsc; \n    \n    \n    d = min(d,sdOctahedron(p,s*sSc));   \n    \n    p=q;\n    p=abs(p);\n    p.x-=s*1.;\n    p.yz *= rot(0.25*pi); \n    p.x *= topUnsc;\n    \n    d = min(d,sdOctahedron(p,s*sSc));    \n    \n    p=q;\n    p=abs(p);\n    p.y-=s*1.;\n    p.xz *= rot(0.25*pi); \n    p.y *= topUnsc;    \n    d = min(d,sdOctahedron(p,s*sSc));\n    \n    \n    \n\treturn d;\n}\n    \n\nfloat coolCahedron(vec3 q, float s){\n    float rhomb= sdRhombicDodecahedron(q,s*0.45);\n    float d = rhomb;\n    d= 10e7;\n    rhomb = max( sdOctahedron(q,s),-rhomb);\n    d = min(d,rhomb);\n    return d;\n}\n\nObject mapG(vec3 p){\n    Object o = NewObject;\n\n\to.d = 10e6;\n\n    o.material = 2.;\n    float octa = 10e7;\n    float sc = 1.;\n    float sep = 1.3;\n    \n    vec3 q = p;\n    float rhomb= coolCahedron(q,S*sc);\n    \n    \n    float dBalls = 10e7;\n    \n    float dXtal = 10e7;\n    \n    float reps = 4.;\n    pmodpol(p.xy,reps);\n    pmodpol(p.yz,reps);\n    pmodpol(p.xz,reps);\n    p *= 0.65;\n    \n    for(float i = 0.; i < 4. + min(float(iFrame),0.); i++){\n        \n        sc = pow(0.54, i+1.);\n        if(mod(i+2.,2.) > 0.){\n            float db = length(p)-0.4*sc;\n            if(db< dBalls){\n            \tdBalls = db;\n                materials[3].albedo = 0.5 + sin(vec3(1.,0.5,0.1)+i+2.)/2.;\n                materials[3].albedo = max(materials[3].albedo,0.);\n                \n            }\n        }\n        \n        float sepi = sep*sc;\n        p=abs(p);\n        p.x -= sepi;\n        vec3 v = p;\n    \tocta= min(octa,coolCahedron(p,S*sc));\n        \n        if(mod(i+3.,2.) < 1.){\n            float db = sdOctahedron(p,S*sc*0.9);\n            if(db< dXtal){\n            \tdXtal = db;\n                materials[4].albedo = 0.5 + sin(vec3(1.,0.5,0.1)+i+2.)/2.;\n            }\n        }\n        \n        p.x += sepi;\n        p.y -= sepi;\n        \n        vec3 b = p;\n    \tocta= min(octa,coolCahedron(p,S*sc));\n        \n        if(mod(i+3.,2.) < 1.){\n            float db = sdOctahedron(p,S*sc*0.9);\n            if(db< dXtal){\n            \tdXtal = db;\n            }\n        }\n        \n        p.y += sepi;\n        p.z -= sepi;\n    \tocta= min(octa,coolCahedron(p,S*sc));\n\n        if(mod(i+3.,2.) < 1.){\n            float db = sdOctahedron(p,S*sc*0.9);\n            vec3 q = abs(p);\n            if(i<3.){\n                q.xz *= rot(0.25*pi);\n                q.xy *= rot(0.25*pi);\n                vec3 bSz = vec3(S*sc*0.9);\n                bSz.x *= 0.05;\n                bSz.y *= 100.;\n                bSz.z *= 0.05;\n                db = min(db,sdBox(q,bSz));\n            \n            }\n            if(db< dXtal){\n                dXtal = db;\n            }\n        }\t\n    }\n    \n\n    \n    o.d = min(o.d,octa);\n    \n    o = omin(o,dBalls, 3.);\n    \n    return o;\n}\n\n\n\n// ----------------- MAP ----------------- //\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n    vec3 q = p;\n    \n\tfloat off = 20.;\n    float sz = 40.;\n    \n    p.z += sz*0.25;\n    \n    p.x -= off;\n    \n    p.x += off*2.;\n    \n    p.z -= sz*.25;\n    p.x -= off;\n    \n    o = omin(o,mapG(p));\n    \n\n    vec3 y = p;    \n    p=abs(q);\n    q = y;\n    \n    \n    p.xz *= rot(0.125*pi);\n    p.xz -= 0.5;\n    \n    q.xz *= rot(-0.25*pi);\n    \n    q.x = pmod(q.x, 0.5);\n    q.z -= 1.2;\n    o = omin(o,sdBox(q,vec3(0.2,15.,0.2)), 4.);\n    \n    \n    o.didHit = true;\n    o.d *= 0.6;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.01;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS ; i++) {\n    \tObject obj = map(p);\n        \n        obj.d *= side;\n    \n        float dPds = length(p - prevP);\n        \n       \n        float noise = 0.1+fbm(3.6+1.5*p+0.*p*(1.5 + smoothstep(0.,1.,p.y)/1.));\n        \n        \n            \n        float fgPw = pow(max(-p.z-10.4*0.12+p.x,0.), 2.)*1000.01;\n\n        noise = pow(noise,6.);\n        \n        float fgDens = .005/(.014+fgPw)*dPds*noise;\n        \n        float fgDensSmoothstep = smoothstep(0.,1.,fgDens*1.);\n        \n        attenuation = mix(attenuation,attenuation*fogCol,smoothstep(0.,1.,fgDensSmoothstep*1.));\n        rd = mix( rd, cosineDirection(hash13(p), rd), fgDensSmoothstep);\n        rd=normalize(rd);\n        \n        obj.d = min(obj.d, 0.1);\n        obj.d *= max(1. - fgDensSmoothstep,0.1); // to do take other d into account\n        \n    \tfog += fgDens;\n        \n        prevP = p;\n        \n        if (obj.d < 0.001) {\n            obj.d = t;\n            obj.didHit=true;\n        \treturn obj;\n        }\n        \n        if (t>50.) {\n            obj.d = t;\n            obj.didHit=false;\n        \treturn obj;\n        }\n        \n        t += obj.d;\n        p += rd*obj.d;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.0005,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uvs = (fragCoord/iResolution.xy);\n    float aspect = iResolution.x/iResolution.y;\n\n    vec4 col = texture(iChannel0, uvs);\n \n    seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n    \n    vec3 accum = vec3(0);\n    \n    vec3 ro = 2.5*vec3(0.69,1.1,-0.7);\n    \n    vec3 lookAt = vec3(0,0.39,0.);\n    \n    uv = -1.0 + 2.0 * (uvs + (-1.0+2.0*hash2(3531.412))/iResolution.xy/1.5);\n    \n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    bool hitBg = false;\n    int i = 0;\n\n    vec2 rand = hash2(0.0);\n    \n    vec2 circle = vec2(cos(rand.x*tau),sin(rand.x*tau));\n    \n    float dPent = sdPentagon( circle, 1. );\n    circle -= normalize(circle)*dPent;\n    \n    float focusDistance = length(vec3(0)-ro);\n    float fov = 1.6;\n    float dof = 0.006*0.1;\n    \n    vec3 dd = dir*fov + (uv.x*right + uv.y*up);\n    vec3 focalPoint = ro + (dd)*focusDistance;\n    \n    ro += (circle.x*right+circle.y*up)*dof;\n    \n    vec3 rd = normalize(focalPoint-ro);\n    \n    \n    bool hitCrystalEarly = false;\n    \n    prevP = ro;\n    \n    for (; i < BOUNCES; i++){\n        \n        \tif (i > 7)\n                break;\n    \t\t\n        \tObject obj = trace(ro, rd);\n        \t\n        \taccum += fog*attenuation*fogCol;\n        \t\n        \n        \tif (!obj.didHit)\n                break;\n            \n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p)*side;\n            \n            float rgh = 0.4;\n        \n        \tMaterial material = materials[int(obj.material)];\n        \t\n        \n        \tif( (hitCrystalEarly &&  obj.material>=4.) || (obj.material>=4. && i < 2) ){\n            \thitCrystalEarly = true;\n                BOUNCES+=1; \n                \n                vec3 emission = material.albedo * material.emissiveness;\n\n                float dotnrd = max(dot(N,-rd),0.00);\n                float fres = pow(1.- dotnrd,5.);\n                \n                vec3 XtalCol = vec3(0.8,0.8,0.8)*1.1;\n                \n\t\t\t\tvec3 iridescenceCol = 0.5 + sin(vec3(0.2,0.8,1.8) + (dotnrd + length(sin(p*5.))*0.4)*25.)/2.;\n                \n                iridescenceCol = 0.5 * iridescenceCol * attenuation*fres;\n                \n                accum += iridescenceCol;\n                \n                attenuation *= 1.*XtalCol+iridescenceCol; // wtf this is over 1 attenuation oook\n                \n                if(obj.material == 4.){\n                    side *= -1.;\n                \trd = refract(rd,N,0.7);\n                }\n                else {\n                \trd = reflect(rd,N);\n                }\n                \n                \n                ro = p;\n                ro -= N*0.1;\n                \n            } else {\n                \n                vec3 emission = material.albedo * material.emissiveness + giAmt * fogCol;\n\n                accum += emission * attenuation;\n\n                attenuation *= material.albedo/PI;\n                ro = p;\n                rd = mix(cosineDirection(seed, N),N,material.metalness);\n            \n            }\n        \n\n            \n\n        \n    }\n    col.xyz += accum;\n    \n    if(iFrame==0) col.w = 0.;\n    \n    col.w ++;\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RAND 1\n\n    \n#define S 0.5\n\n#define PI pi\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash32(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n\nstruct Material {\n    vec3 albedo;\n    float emissiveness;\n\tfloat metalness; \n\tfloat roughness;\n};\n\n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tfloat material;\n};\nObject omin(Object a, float bdistance, float bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, float bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,0.)\n\n\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y,p.z));\n}\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}