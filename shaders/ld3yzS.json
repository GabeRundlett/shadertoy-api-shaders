{
    "Shader": {
        "info": {
            "date": "1519310607",
            "description": "Braids made of braids. Click to rotate the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3yzS",
            "likes": 33,
            "name": "Fractal Braids",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 939
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define FOV (PI*0.4)\n\n#define rot(a) mat2(cos(a+PI*vec4(0,1.5,0.5,0)))\n\n// hash function for dithering\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// parametric equation for the path of a single strand\n// https://en.wikipedia.org/wiki/Braiding_machine\nvec2 path( float x ) {\n    float v = step(fract(x), 0.5)*2.0-1.0;\n    float th = mod(x, 0.5)*-4.0*PI*v;\n    return vec2(cos(th)*0.5-0.5, sin(th)*0.5)*v;\n}\n\n// main distance function\nfloat de( vec3 p, out float id ) {\n    \n    float sky = 10.0-length(p.xy);\n    p.z *= 0.04;\n    \n    vec2 inS = vec2(0);\n    float scale = 1.0;\n    id = 0.0;\n    \n    for (int i = 0 ; i < 3 ; i++) {\n        \n        // figure out the path of the 3 strands\n        vec2 inA = p.xy - path(p.z)*scale;\n        vec2 inB = p.xy - path(p.z + (1.0/3.0))*scale;\n        vec2 inC = p.xy - path(p.z + (2.0/3.0))*scale;\n        \n        // pick the closest center\n        float dA = dot(inA, inA);\n        float dB = dot(inB, inB);\n        float dC = dot(inC, inC);\n        if (dA < dB && dA < dC) {\n            inS = inA;\n        } else if (dB < dC) {\n            inS = inB;\n            id += pow(3.0, float(i));\n        } else {\n            inS = inC;\n            id += 2.0*pow(3.0, float(i));\n        }\n        \n        p.z /= scale;\n        p.xy = inS;\n        scale *= 0.32;\n        \n    }\n    \n    // base primitive is a cylinder\n    float de = length(inS) - 1.5*scale;\n    \n    // compare the distance to the sky\n    if (sky < de) {\n        id = -1.0;\n        return sky;\n    }\n    \n    return de;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n\tvec3 from = vec3(0, -4.3, 0);\n\tvec3 dir = normalize(vec3(uv.x, 1.0 / tan(FOV*0.5), uv.y));\n    \n    \n\tvec2 mouse= (iMouse.xy - iResolution.xy * 0.5) / iResolution.x;\n\tif (iMouse.z < 1.0) mouse = vec2(0.0);\n\tmat2 rotx = rot(-mouse.x*4.0);\n\tmat2 roty = rot(mouse.y*3.0);\n    from.yz *= roty;\n\tfrom.xy *= rotx;\n\tdir.yz  *= roty;\n\tdir.xy  *= rotx;\n    from.z += iTime;\n    \n    // dithering\n    vec3 dither = hash33(vec3(fragCoord.xy, iFrame));\n    \n    // get the sine of the angular extent of a pixel\n    float sinPix = sin(FOV / iResolution.x)*1.0;\n    // accumulate color front to back\n    vec4 acc = vec4(0, 0, 0, 1);\n\n    float id = 0.0;\n    float totdist = 0.0;\n    totdist += dither.r*de(from, id)*0.4;\n    \n\tfor (int i = 0 ; i < 50 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p, id);\n        \n        // compute color\n        vec3 color = vec3(sin(id)*0.3+0.7);\n        if (id < -0.5) color = vec3(0.2);\n        else if (id < 0.5) color = vec3(0.6, 0.1, 0.1);\n        color *= pow(1.0 - float(i)/50.0, 1.5);\n        \n        // cone trace the surface\n        float prox = dist / (totdist*sinPix);\n        float alpha = clamp(prox * -0.5 + 0.5, 0.0, 1.0);\n        \n        if (alpha > 0.01) {\n            // accumulate color\n            acc.rgb += acc.a * (alpha*color.rgb);\n            acc.a *= (1.0 - alpha);\n        }\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) {\n            break;\n        }\n        \n        // continue forward\n        totdist += abs(dist*0.4);\n\t}\n    \n    fragColor.rgb = acc.rgb + (dither - 0.5)*0.01;\n\tfragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}