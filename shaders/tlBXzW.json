{
    "Shader": {
        "info": {
            "date": "1698360810",
            "description": "Minimalist image of a cube that can be rotated with the mouse.",
            "flags": 32,
            "hasliked": 0,
            "id": "tlBXzW",
            "likes": 1,
            "name": "Rotation Cube",
            "published": 3,
            "tags": [
                "cube",
                "rotation"
            ],
            "usePreview": 0,
            "username": "glk7",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "// Created by genis sole - 2023\n// License Creative Commons Attribution-NonCommercial 4.0 International.\n\nvec3 draw_cube(vec2 uv, float e, vec4 q)\n{\n    const vec4 p = vec4(1.0, -1.0, 0.0, 1.0);\n    \n\tvec3 b1 = quatRotate(q, p.yyy);\n    vec3 b2 = quatRotate(q, p.yyx);\n    vec3 b3 = quatRotate(q, p.xyx);\n    vec3 b4 = quatRotate(q, p.xyy);\n   \n   \tvec3 t1 = quatRotate(q, p.yxy);\n    vec3 t2 = quatRotate(q, p.yxx);\n    vec3 t3 = quatRotate(q, p.xxx);\n    vec3 t4 = quatRotate(q, p.xxy);\n    \n    const float zd = 10.0;\n    \n  \tb1.xy = b1.xy / (b1.z + zd);\n    b2.xy = b2.xy / (b2.z + zd);\n    b3.xy = b3.xy / (b3.z + zd);\n   \tb4.xy = b4.xy / (b4.z + zd);\n    \n    t1.xy = t1.xy / (t1.z + zd);\n    t2.xy = t2.xy / (t2.z + zd);\n    t3.xy = t3.xy / (t3.z + zd);\n    t4.xy = t4.xy / (t4.z + zd);\n    \n    float tp1 = dot(uv - t1.xy, normalize(t2.xy - t1.xy).yx * vec2(-1.0, 1.0));\n    float tp2 = dot(uv - t1.xy, normalize(t4.xy - t1.xy).yx * vec2(-1.0, 1.0));\n    float tp3 = dot(uv - t3.xy, normalize(t2.xy - t3.xy).yx * vec2(-1.0, 1.0));\n    float tp4 = dot(uv - t3.xy, normalize(t4.xy - t3.xy).yx * vec2(-1.0, 1.0));\n    \n    float bp1 = dot(uv - b1.xy, normalize(b2.xy - b1.xy).yx * vec2(-1.0, 1.0));\n    float bp2 = dot(uv - b1.xy, normalize(b4.xy - b1.xy).yx * vec2(-1.0, 1.0));\n    float bp3 = dot(uv - b3.xy, normalize(b2.xy - b3.xy).yx * vec2(-1.0, 1.0));\n    float bp4 = dot(uv - b3.xy, normalize(b4.xy - b3.xy).yx * vec2(-1.0, 1.0));\n    \n    float sp1 = dot(uv - b1.xy, normalize(t1.xy - b1.xy).yx * vec2(-1.0, 1.0));\n    float sp2 = dot(uv - b2.xy, normalize(t2.xy - b2.xy).yx * vec2(-1.0, 1.0));\n    float sp3 = dot(uv - b3.xy, normalize(t3.xy - b3.xy).yx * vec2(-1.0, 1.0));\n    float sp4 = dot(uv - b4.xy, normalize(t4.xy - b4.xy).yx * vec2(-1.0, 1.0));\n    \n    \n    float ty = min(min(-tp1, tp2), min(tp3, -tp4));\n    float by = min(min(bp1, -bp2), min(-bp3, bp4));\n    \n    float tx = min(min(tp1, -bp1), min(sp1, -sp2));\n    float bx = min(min(tp4, -bp4), min(sp3, -sp4));\n    \n    float tz = min(min(-tp2, bp2), min(-sp1, sp4));\n    float bz = min(min(-tp3, bp3), min(sp2, -sp3));\n    \n    return smoothstep(0.0, e*2.0, vec3(max(tx, bx), max(ty, by), max(tz, bz)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5)*e;\n\n    vec3 col = vec3(smoothstep(0.0, e*1.2, length(uv) - 0.2));\n    \n    float ff = min(1.0, step(3.0, iMouse.x) + step(3.0, iMouse.y));\n    vec4 q = mix(load(QUATROT), quatRandom(iTime * 0.3), 1.0 - ff);\n    \n    col += draw_cube(uv, e, q);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by genis sole - 2023\n// License Creative Commons Attribution-NonCommercial 4.0 International.\n\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n\nconst ivec2 PMOUSE = ivec2(1, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (any(greaterThan(fragCoord.xy, vec2(2.0, 1.0)))) return;\n   \t\n    fragColor = load(fragCoord);\n    \n    if (iTime == 0.0 || iFrame == 0) {\n        store(QUATROT, vec4(vec3(0.0), 1.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n    \n    vec2 m = (iMouse.xy - iResolution.xy*0.5)/iResolution.x;\n    \n    vec4 pm = load(PMOUSE).xyzw;\n    \n    vec4 q = load(QUATROT);\n\n    float e = 1.0/iResolution.x;\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n        if (pm.z == 0.0) pm.xy = m.xy;\n        \n        vec2 dm = (m.xy - pm.xy)*5.0 * step(length(m), vec2(0.2));\n        \n        vec4 invq = quatConjugate(q);\n        vec3 rx = quatRotate(invq, vec3(1.0, 0.0, 0.0));\n        vec3 ry = quatRotate(invq, vec3(0.0, 1.0, 0.0));\n        \n        vec4 qx = quat(rx, dm.y);\n        vec4 qy = quat(ry, -dm.x);\n        \n        q = quatMult(q, quatMult(qx, qy));\n        \n    \tstore(QUATROT, normalize(q));\n        store(PMOUSE, vec4(vec2(m.xy), 1.0, 1.0));\n    }\n    else if (pm.z != 0.0) {\n        store(PMOUSE, vec4(0.0));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by genis sole - 2023\n// License Creative Commons Attribution-NonCommercial 4.0 International.\n\n\nconst ivec2 QUATROT = ivec2(0, 0);\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nvec4 quat(vec3 axis, float rads) {\n    return vec4(sin(rads*0.5)*axis, cos(rads*0.5)); \n}\n\nvec4 quatMult(vec4 q1, vec4 q2) {\n    return vec4(q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w*q2.w - dot(q1.xyz, q2.xyz));\n}\n\nvec3 quatRotate(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatConjugate(vec4 q) {\n\treturn vec4(-q.xyz, q.w);    \n}\n\n//David Hoskins hash: https://www.shadertoy.com/view/4djSRW \nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z)*2.0 - 1.0;\n}\n\nfloat gnoise(float p) \n{\n    float i = floor(p);\n\tfloat f = fract(p);\n    \n    float a = dot(hash11(i), f);\n    float b = dot(hash11(i + 1.0), f - 1.0);\n    \n    float u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u);\n}\n\nvec4 quatRandom(float t)\n{\n    vec3 a = vec3(gnoise(t + 2.0) * 3.1, gnoise(t + 6.0) * 3.5, gnoise(t + 4.0) * 3.2);\n    float s = clamp((gnoise(t + 10.0) + 0.5), -1.0, 1.0);\n    return normalize(vec4(a * s, sqrt(1.0 - s*s))); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}