{
    "Shader": {
        "info": {
            "date": "1621347426",
            "description": "Rocket 2d y scroller",
            "flags": 0,
            "hasliked": 0,
            "id": "sdjSDd",
            "likes": 5,
            "name": "Rocket 2d y scroller",
            "published": 3,
            "tags": [
                "rocket2dyscroller"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "//Modificado por JorgeFloresP. ---jorge2017a1\n//Fork\n//2d sidescroller.....Created by onak in 2019-10-15\n//2D Rocket...........Created by antoineMoPa in 2017-06-28\n//https://www.shadertoy.com/view/lslBDX\n//https://www.shadertoy.com/view/tsKGDc\n\nfloat pixelsize = 2.0;\nfloat scrollSpeed = 0.3;\nfloat roughness = 0.55;\n\nfloat PI = 3.14159265359;\n\n/**\n * compares x to f and returns a value between 1.0 and 0.0\n * depending on the difference as long as its below threshold\n *\n * always returns 1.0 for differences above the threshold\n */\nfloat plot2d(in float x, in float f, in float threshold) {\n    float deviation = abs(x - f);\n    \n    if (deviation < threshold) {\n        return (deviation / threshold);\n    }\n    \n    return 1.0;\n} \n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat noise_fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n/**\n * two-dimensional fractal Brownian motion\n */\nfloat fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.x * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n\nfloat fBMYaX(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.y * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n// photoshop blend modes: https://www.shadertoy.com/view/XdS3RW\nvec4 blend_lighten(vec4 s, vec4 d) {\n    return max(s, d);\n}\nvec3 blend_lighten(vec3 s, vec3 d) {\n    return max(s, d);\n}\n\n\n\n\nvec4 rocket(vec2 pos)\n{\n    vec4 col = vec4(0.0);\n    \n    // Clip (because otherwise a sine is repeated)\n    if(pos.x < -0.5 || pos.x > 0.5){\n        return col;\n    }\n    \n    if(\n      // Base parabolic shape\n      pos.y + 0.02 * cos(12.0 * pos.y + 0.1) * pos.y < 0.5 - pow(3.88 * pos.x, 2.0) && pos.y > -0.1 \n      ||\n        // Lower rectangle\n       ( pos.y < 0.0 && pos.y > -0.2 \n            && \n                // Lower left arc\n                (pos.x > -0.1 || distance(pos, vec2(-0.1,-0.1)) < 0.10) \n                // Lower right arc\n            &&     (pos.x < 0.1  || distance(pos, vec2(0.1,-0.1)) < 0.10)\n       )\n      )\n    {\n        // Window\n        if (\n            distance(pos, vec2(0.0,0.2)) < 0.05\n        )\n        {\n            col.rgb += vec3(0.1,0.1,0.1);\n            col.a = 1.0;\n        }\n        // Rest\n        else\n        {\n            col.rgb += vec3(1.0,1.0,1.0);\n            col.a = 1.0;\n        }\n    }\n    \n    else if (\n        pos.y < -0.4 + 0.5 * cos(4.5 * pos.x)\n        &&\n        pos.y > -0.5 + 0.3 * cos(3.0 * pos.x)\n    )\n    {\n        col.rgb += vec3(1.0,0.1,0.2);\n        col.a = 1.0;\n    }\n    \n    // Propeller\n    else if (pos.x < 0.1 && pos.y < 0.0 && pos.x > -0.1 && pos.y > -0.3)\n    {\n        col.rgb += vec3(0.3,0.3,0.3) + 0.3 * cos(pos.x * 10.0 + 1.0);\n        col.a = 1.0;\n    }\n       \n    \n    return col;\n}\n\n\nvec3 paisajeRio(vec2 uv)\n{\nvec3 col;\n    float surfaceThickness = 0.015;\n    vec3 skyDark = vec3(0.17, 0.289, 0.51); // RGB 44, 74, 105\n    vec3 skyBright = vec3(0.714, 0.829, 0.984); // RGB 183, 238, 247\n    vec3 terrainBright = vec3(0.855, 0.640, 0.179); // RGB 219, 164, 46\n    vec3 terrainDark = vec3(0.585, 0.437, 0.117); // RGB 150, 112, 30 #96701e\n    vec3 surfaceDark = vec3(0.246, 0.398, 0.183); // RGB 63, 102, 47\n    vec3 surfaceBright = vec3(0.312, 0.648, 0.179); // RGB 80, 166, 46\n    float time = iTime * scrollSpeed;\n    \n    \n    // generate fractal noise\n    //float v = fBM(roughness, 7, 0.5, 2.31, uv + time);\n    float v = fBMYaX(roughness, 7, 0.5, 2.31, uv + time);\n     \n    // map to range\n    v = 0.125 + 0.135 * v;\n    \n    // colorize\n    if (abs(v - uv.x) < surfaceThickness  || abs( uv.x-v-0.7) < surfaceThickness )\n    {\n        // surface\n\t\tcol = mix(surfaceBright, surfaceDark, plot2d(uv.x, v + surfaceThickness * 0.5, surfaceThickness));\n    } \n   else if (v < uv.x && (v+0.7 > uv.x  ) ) {\n        // sky\n         vec3 sky = mix(skyBright, skyDark, uv.x);\n        float c = 2.5 * noise_fBM(2.0, 5, 0.5, 2.0, uv.yx + vec2(iTime * (0.7 * scrollSpeed), 0.0));\n        vec3 clouds = vec3(c);\n        col = clamp(sky + clouds, sky, vec3(1.0));\n        \n        //col = vec3(0.0,0.0,1.0);\n    }\n    else {\n        // terrain\n        col = terrainBright;\n        \n        // add some structure\n        float noise = noise_fBM(16.0, 5, 0.5, 2.0, uv + vec2(0.0, time));\n        noise = 0.5 + noise;\n\n        if (noise > 0.7   ) {\n            col = terrainDark;\n        }\n    }\n \n return col;\n}    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n        // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime * scrollSpeed;\n    \n    if (pixelsize > 1.0) {\n   \t\tuv = (pixelsize * floor(iResolution.xy * uv / pixelsize)) / iResolution.xy;\n        time = pixelsize * floor(iResolution.x / pixelsize * iTime * scrollSpeed) / iResolution.x;\n    }\n   \n    vec3 col;\n    col= paisajeRio(uv);\n    vec2 uv2=uv*(6.0+3.0*(sin(iTime)));\n    vec4 colcohete= rocket(uv2-vec2(3.0+2.0*sin(iTime*1.0),0.8));\n    col=mix(col,colcohete.xyz, colcohete.a );\n     \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}