{
    "Shader": {
        "info": {
            "date": "1622116031",
            "description": "Raymarching a random extruded quadtree in realtime.",
            "flags": 32,
            "hasliked": 0,
            "id": "slXGDN",
            "likes": 74,
            "name": "Realtime Extruded Quadtree",
            "published": 3,
            "tags": [
                "dof",
                "random",
                "block",
                "quadtree",
                "extrude"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2200
        },
        "renderpass": [
            {
                "code": "/*\n\n\n    Realtime Extruded Quadtree\n    --------------------------\n    \n    FMS_Cat posted a beautifully rendered, static extruded quadtree example the \n    other day that appealed to me on many levels. Since I already had a realtime  \n    quadtree example tucked away in my account, it inspired me to put on some\n    finishing touches and post it. Designwise, I \"borrowed\" two aspects from \n    FMS_Cat's scene. One was the camera angle, and the other was the hollowing \n    out of random blocks. I added some moving objects to the hollowed blocks to \n    provide a personal touch and to further illustrate the idea that this is a \n    realtime example. \n    \n    The quadtree code itself was based on a 2D quadtree demonstration I posted \n    on Shadertoy a few months ago, which ironically was much harder to produce \n    than this.\n\t\n\tCoding up an extruded quadtree in realtime is still a bit of an ask. \n    Thankfully, unlike my coding skills, machines have improved considerably \n    over the past few years, so it runs reasonably efficiently... Not fantastic, \n    but not too bad on decent machines. Apologies to anyone with a slower system,\n    but even with cost cutting, there's a fair bit of processing going on.\n\n    If you were to code an extruded tri-level quadtree using nested brute force \n    neighboring column repeat methods, you'd need a GPU-burning 64 taps, which \n    isn't satisfactory. However, using a mixture of simultaneous scaling and \n    repeat neighboring methods can get it right down to just 12, which \n    conceptually is about as good as you're going to get... Having said that, \n    there are some freakishly good coders on this site, so it wouldn't shock me \n    if someone got the number down. :)\n    \n    FMS_Cat's scene also included water, which would have been a great addition, \n    but I had to let it go, as it would have required extra passes -- Fake \n    environmental lighting was all I could afford this time around. However, I \n    have a regular extruded block example with water that I'll post later.\n\t\n    \n\n\tInspired by:\n    \n\t// I love static renderings like this.\n    \"Wooden Structure\" - FMS_Cat\n\thttps://www.shadertoy.com/view/sdjXWy\n    \n    // I based the code on this particular example.\n    Sorted Overlapping Quadtree - Shane\n    https://www.shadertoy.com/view/wtjfDy\n\n\n*/\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 3.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 3.5, coc = 1.;\n    // Linear distance from either side of the focal point.\n    float l = abs(focD - texture(iCh, uv).w);\n    // Using it to calculate the DOF.\n    vec2 dof = clamp((l - coc)/(1.*coc), 0., 1.)/vec2(800, 450); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)*dof).xyz;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// This would normally be a very quick routine that displays\n// the scene and gives it a distance of field effect, but I \n// wanted to put in a little loading bar graphic just to let\n// people know that some precalculation is happening in the \n// background... and to give impatient people like me a visual \n// representation of the time it's going to take. :D\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n     \n    \n    // Apply some depth of field, then present to the screen.\n    vec3 col = DpthFld(iChannel0, fragCoord/iResolution.xy);\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    The scene itself: It's just standard single pass raymarching code. The only \n    interesting function is the \"block\" function that renders the extruded \n    quadtree structure.\n    \n    \n*/\n\n// Block scale.\n#define GSCALE vec2(1./2.)\n\n// Pylon face shape: Each one has its own appeal.\n// Circles: 0, Square: 1, Rounded Square: 2.\n#define SHAPE 2\n\n// Give the pylon sides the same color as the trim.\n//#define LIGHT_SIDES\n\n// Grayscale, for that artsy look.\n//#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's texure hash -- I'm taking Flockaroo's word for it that the textureLod\n// function will help avoid artifacts.\nvec3 hash23T(vec2 p){  return textureLod(iChannel2, p, 0.).xyz; }\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D ch, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(ch, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\nfloat hm(in vec2 p){ \n    return dot(getTex(iChannel1, p/4.), vec3(.299, .587, .114));\n}\n\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \n    // Slight rounding. A little nicer, but slower.\n    //const float sf = .025;\n    //vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// Pylon or moving object ID.\nvec2 oID;\n\n// The extruded quadtree.\nvec4 blocks(vec3 q3){\n    \n    // Block dimension.\n    vec2 oDim = GSCALE;\n    vec2 dim = GSCALE; \n    \n    // Distance.\n    float d = 1e5;\n    \n    // Final entry needs to fill in the rest, so you give it a 100% chance of success.\n    // I'd rather not say how long it took me to figure that out. :D\n    //float rndTh[4] = float[4](.25, .333, .5, 1.01);\n    float rndTh[4] = float[4](.333, .5, 1.01, 1.01);    \n    \n    vec2 id = vec2(0);\n    float boxID = 0.;\n    oID = vec2(0);\n    \n     \n    // Three quadtree levels.\n    for(int k=0; k<3; k++){\n \n        // Four block neighbors.\n        for(int j = 0; j<=1; j++){\n            for(int i = 0; i<=1; i++){\n                \n                // For the 12 tap (4-tap IJ loop), we need the \"-.5\" figure to center things.\n        \t\t// For the 27 tap (9-tap IJ loop), take it off the expression.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j) - .5;\n\n               \n                float rndIJ[4];\n                rndIJ[0] = hash21(floor(ip0));\n                if(rndIJ[0]>=rndTh[k]) continue;\n\n                rndIJ[1] = hash21(floor(ip0/2.));\n                if(k==1 && rndIJ[1]<rndTh[0]) continue;\n\n                rndIJ[2] = hash21(floor(ip0/4.));\n                if(k==2 && (rndIJ[1]<rndTh[1] || rndIJ[2]<rndTh[0])) continue;\n\n                //rndIJ[3] = hash21(floor(ip0/8.)); \n                //if(k==3 && (rndIJ[1]<rndTh[2] || rndIJ[2]<rndTh[1] || rndIJ[3]<rndTh[0])) continue; \n\n\n                //if(rndIJ[0]<rndTh[k])\n                {\n\n                    //vec2 p = mod(oP, dim) - dim/2.; // Last term for 8 iterations.\n                    vec2 p = q3.xy;\n                    vec2 ip = floor(ip0) + .5;\n                    p -= ip*dim; // Last term for 8 iterations.\n\n                    vec2 idi = ip*dim;\n\n                    // The extruded block height. See the height map function, above.\n                    //float h = hm2(idi/256.);//15 + float(j)*.15;//\n                    float h = hm(idi);//15 + float(j)*.15;//\n\n                    //h = floor(h*15.999)/15.; // Or just, \"h *= .15,\" for nondiscreet heights.\n                    h *= .2;//.2;\n                   \n                    // Offset. Not used here, but it can be.\n                    vec2 off = vec2(0);//(hash22(idi + .37*dim) - .5)*dim*.35;\n\n                    // The 2D blocks.\n                    #if SHAPE == 0\n                    // Circle.\n                    float di2D = length(p - off) - dim.x/2.;\n                    #elif SHAPE == 1\n                    // Rounded squares.\n                    float di2D = sBoxS(p, dim/2. - .01*oDim.x, .0);\n                    #else\n                    // Rounded squares.\n                    float di2D = sBoxS(p, dim/2. - .01*oDim.x, .3*(dim.x));\n                    #endif\n                    \n                    // Some random number.\n                    vec3 r3 = hash23T(idi*7.27183 + .36);\n                    float rnd = r3.x;\n                    if(rnd<.5) {\n                        // Hollow out random pylons.\n                        di2D = abs(di2D + .04*oDim.x) - .04*oDim.x;\n                    \n                    }\n\n\n                    // The extruded distance function value.\n                    float di = opExtrusion(di2D, (q3.z + h - 32.125), h + 32.125);\n                    \n                    // Adding a bit of the face value to put a bit of variation on the top.\n                    di += di2D/8.;\n                    \n\n                    // The moving ball bearings. I made this up quickly, so there'd be\n                    // better ways to go about it.\n                    vec2 toID = vec2(0);\n                    // Only do it for hollowed out pylons for the first two levels.\n                    if(k<2 && rnd<.5) {\n                    \n\n                        float bh = sin(iTime*(r3.y + 5.)/4. + dot(idi, vec2(27.163, 113.457)) + r3.z*6.2831)*(dim.x + 1.);\n                        float qz = q3.z + h - 1. + bh;\n                        float ball = length(vec3(p, qz)) - .3*dim.x*(r3.y*.5 + .5);\n                        //float ball = max(oDi2D + oDim.x*.2, abs(qz) - dim.x*.2);\n                        //float ball2 = max(length(p) - .3*dim.x*(rnd2*.5 + .5), abs(qz) - .0*dim.x);\n                        //ball = max(ball, -(abs(ball2) - .02*dim.x));\n                        \n                        toID.x = di<ball? 0. : 1.;\n                        toID.y = bh;\n                        di = min(di, ball);\n                    \n                    }\n                    \n                    // Random sprinkles.\n                    //di += hash23T((q3.xy + q3.z)/8.).z*.003;\n                    \n\n\n                    // If applicable, update the overall minimum distance value,\n                    // ID, and box ID. \n                    if(di<d){\n                        \n                        d = di;\n                        id = idi;\n                        // Not used in this example, so we're saving the calulation.\n                        boxID = di2D;//float(k*4 + j*2 + (1 - i));\n                        oID = toID;\n                    }\n\n\n                }\n                \n\n\n            }\n        }\n\n        // Halve the dimension for the next iteration.\n        dim /= 2.; \n        \n    }  \n    \n    return vec4(d, id, boxID);\n    \n    \n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + 64.251;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.5 : d*.85; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t)*.7;\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c, c*c, c); // Blueish tinge.\n    \n    return mix(p.zxy, p, n3D2); // Mixing in a bit of red.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0., iTime/2., -1.8); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.5, 4, .9);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\trd.xy *= rot2(3.14159/5.); // + sin(iTime/6.)/8. + .125\n\trd.yz *= rot2(-3.14159/5.);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Global distance.\n    float gDist = t;\n    \n    // Save the block ID, object ID, etc.\n    vec3 svGID = gID;\n    vec2 svoID = oID;\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 12.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n \t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.  \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n        \n            // Coloring the pylons and moving objects.\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel3, svGID.xy/8. + .12);\n            \n            // Texture coordinates.\n            vec3 txP = sp;\n           \n            if(svoID.x==1.){\n            \n                // Moving bearing object texture coordinates.\n                txP += vec3(0, 0, svoID.y);\n\n                // Evening out the moving bearing object color. \n                tx = mix(tx, min(1./vec3(dot(tx, vec3(.299, .587, .114))), 1.), .2);\n            }\n            \n            tx = min(tx*1.5, 1.);\n            \n            // Multicolored.\n            //tx = .58 + .42*cos(6.2831*n3D(vec3(svGID.xy, 1))/2. + vec3(0, 1, 2));\n            \n            \n            // Tri-planar texturing.\n            vec3 tx2 = tex3D(iChannel3, txP/2. + svoID.x/2.*0., sn);\n            tx2 = smoothstep(0., .5, tx2);\n            \n            // Pylon color... I need to give the names more meaning, I think. :)\n            texCol = mix(tx, tx*tx2*4., 1.);\n            \n           \n             \n            //diff = pow(diff, 4.)*2.;\n            // Central dots.\n            //vec2 svP = sp.xy - svGID.xy;\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, length(svP) - .02));\n            \n            // Coloring the pylons only.\n            if(svoID.x==0.){\n            \n                // Face height and value.\n                float ht = hm(svGID.xy)*.2;\n                float face = svGID.z;\n\n                // Top pylon face coloring.\n                float face2 = face;\n                face = max(abs(face), abs(sp.z + ht*2.)) - .02; // Face border.\n                //face = min(face, abs(face2 + .01) - .00125); // Extra border.\n                \n                \n                // Line pattern.\n                float lSc = 30.;\n                float pat = (abs(fract((sp.x - sp.y)*lSc - .5) - .5)*2. - .5)/lSc;\n                //float pat = (abs(fract(hex2*lSc - .5) - .5)*2. - .25)/lSc;\n                \n                // Top color.\n                vec3 tCol = texCol/4.;\n               \n                // Top face color... I hacked this together in a hurry, but I'll tidy it later.\n                vec3 faceCol = mix(texCol, vec3(0), (1. - smoothstep(0., .01, pat))*.25);\n                float ew = .03;\n                tCol = mix(tCol, tx2*vec3(1.3, .9, .3)*4., (1. - smoothstep(0., .002, face2 + .01)));\n                tCol = mix(tCol, texCol/4., (1. - smoothstep(0., .002, face2 + ew)));\n                tCol = mix(tCol, faceCol, (1. - smoothstep(0., .002, face2 + ew + .01)));\n                \n                #ifdef LIGHT_SIDES\n                // Colored sides.\n                texCol = tx2*vec3(1.3, .9, .3)*3.;\n                #endif\n                \n                // Applying the top face color.\n                texCol = mix(texCol, tCol, (1. - smoothstep(0., .002, sp.z + ht*2.)));\n \n            \n                \n            }\n            //else texCol = (tx2*vec3(1.3, .9, .3)*4.);\n           \n            #ifdef GRAYSCALE\n            // Grayscale, for that artistic feel.\n            texCol = vec3(dot(texCol, vec3(.299, .587, .114)));    \n            #endif\n            \n            // Darkening the edges of the open silos, or whatever they are. :)\n            texCol = mix(texCol, vec3(0), smoothstep(0., 1., sp.z));\n            \n        \n \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + vec3(.04, .08, .12) + vec3(.2, .4, 1)*fre*sh*0. + vec3(1, .7, .4)*spec*freS*sh*8.);\n\n\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        col += col*cTex*15.; \n        \n        \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n    \n\n    // Mild temporal blur... Not really need here.\n    //vec4 oCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //col = mix(oCol.xyz, max(col, 0.), 1./2.);\n    \n    // Rought gamma correction.\n\tfragColor = vec4(max(col, 0.), gDist);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}