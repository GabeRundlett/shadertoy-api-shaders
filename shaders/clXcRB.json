{
    "Shader": {
        "info": {
            "date": "1690865940",
            "description": "sdf",
            "flags": 0,
            "hasliked": 0,
            "id": "clXcRB",
            "likes": 1,
            "name": "8 bit masked rounded box combine",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "Danielhu",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "float box(vec3 position, vec3 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0) - cornerRadius;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat sdf(vec3 position) { \n    float halfEdge = 0.25;\n    float cornerRadius = 0.06;\n    float separation = halfEdge - cornerRadius; // separation equal to the edge length minus the corner radius\n    float distance = 1e0; // Large initial distance\n    int mask = 1 | 2 | 4 | 16 ; // Change this to specify which cubes to draw\n    int cubeIndex = 0;\n    for(int x=-1; x<=1; x+=2) {\n        for(int y=-1; y<=1; y+=2) {\n            for(int z=-1; z<=1; z+=2) {\n                if ((mask & (1 << cubeIndex)) != 0) { // Only draw the cube if it matches the mask\n                    vec3 center = vec3(x, y, z) * separation; // Use the new separation\n                    vec3 p = position - center;\n                    distance = min(distance, box(p, vec3(halfEdge, halfEdge, halfEdge), cornerRadius));\n                }\n                cubeIndex++;\n            }\n        }\n    }\n    return distance;\n}\n\n\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128 * 2;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 10.0);\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}