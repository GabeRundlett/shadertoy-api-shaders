{
    "Shader": {
        "info": {
            "date": "1710520219",
            "description": "2D Fluid solver test.",
            "flags": 32,
            "hasliked": 0,
            "id": "lXlXD4",
            "likes": 8,
            "name": "2D Fluid Solver",
            "published": 3,
            "tags": [
                "2d",
                "math",
                "fluid",
                "solver"
            ],
            "usePreview": 0,
            "username": "Friend",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "vec2  domain(vec2 uv, float s);\nvec3  get_color_from_palette(float value);\nfloat pchar(vec2 p, int C);\nfloat pfnum(vec2 p, float x);\nfloat pinum(vec2 p, float x);\nfloat renderText(vec2 p, float num);\n\nvoid mainImage(out vec4 c, in vec2 p) {    \n    vec2 svp = vec2(-150., 30.);\n    vec4 sv = A(p*1.2 - svp);\n    float vm = length(vec2(sv.x, sv.y)); \n    float nvm = abs(vm) / lv;\n    \n    vec2 spp = vec2(310., 30.);\n    vec4 sp = A(p*1.2 - spp);\n    float np = (sp.z - 0.1) / (3. - 0.1);\n    \n    vec3 clv = get_color_from_palette(nvm);\n    vec3 clp = get_color_from_palette(np);\n    \n    if(p.x > 0. && p.x < 400.) {\n        c = vec4(clv, 1.);\n    }\n    if(p.x > 400.) {\n        c = vec4(clp, 1.);\n    }\n        \n    vec2 q = domain(p, 2.);\n    float Re = (lv * sz) / nu;\n    float td = renderText(q, Re);    \n    c = mix(c, vec4(1.), td);\n}\n\nfloat renderText(vec2 p, float num) {\n    float nm = 0.0;\n    float fontScale = 5.;\n    \n    p.y -= 1.6;\n    p.x += .5;\n    // Render \"R\"\n    nm = max(nm, pchar(fontScale * p, 82)); // ASCII for 'R'\n    p.x -= .1; \n    // Render \"e\"\n    nm = max(nm, pchar(fontScale * p, 101)); // ASCII for 'e'\n    p.x -= .1;\n    // Render \"=\"\n    nm = max(nm, pchar(fontScale * p, 61)); // ASCII for '='\n    p.x -= 0.34;\n    // Render the floating number\n    nm = max(nm, pfnum(fontScale * p, num));\n    \n    return nm;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - R.xy) / R.y * s;\n}\n\nvec3 get_color_from_palette(float value) {    \n    vec3 color_low = vec3(0.0, 0.0, 0.5);      // Dark blue\n    vec3 color_mid_low = vec3(0.0, 0.0, 1.0);  // Blue\n    vec3 color_mid = vec3(0.0, 1.0, 1.0);      // Cyan\n    vec3 color_mid_high = vec3(1.0, 1.0, 0.0); // Yellow\n    vec3 color_high = vec3(1.0, 0.0, 0.0);     // Red\n    \n    if (value < 0.25) {\n        return mix(color_low, color_mid_low, value / 0.25);\n    } else if (value < 0.5) {\n        return mix(color_mid_low, color_mid, (value - 0.25) / 0.25);\n    } else if (value < 0.75) {\n        return mix(color_mid, color_mid_high, (value - 0.5) / 0.25);\n    } else {\n        return mix(color_mid_high, color_high, (value - 0.75) / 0.25);\n    }\n}\n\nfloat pchar(vec2 p, int C) {\n  if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n   \n  return textureGrad(\n      iChannel2, p/16. + fract(vec2(C, 15-C/16) / 16.), \n      dFdx(p/16.),dFdy(p/16.)\n  ).r;\n}\n\nfloat pinum(vec2 p, float x) {\n    bool neg = false;\n    if(x < 0.) {\n    \tneg = true;\n        x *= -1.;\n    }\n    \n    int x_ = int(floor(x));\n    float nm = 0.;\n    if(neg)\n        nm = pchar(p+vec2(.3,0.), 45);\n    \n    for(int i = 0; i < 10; i++) {\n    \tint n = int(floor(mod(float(x_), 10.)));\n        nm = max(nm, pchar(p + float(i)*vec2(.4, 0.), 48+n));\n        x_ /= 10;\n        if(x_ == 0)\n            break;\n    }\n    \n    return nm;\n}\n\nfloat pfnum(vec2 p, float x) {\n   \t// +/-dn...d1d0d,d_0d_1...d_n\n    float xo = x;\n    bool neg = false;\n    if(x < 0.) { neg = true; x *= -1.; }\n    \n\tint d = int(abs(floor(x)));\n    int d0 = 0;\n    \n    int d_0 = int( floor(abs(fract(x)) * 10.) );\n\tint d_1 = int( floor(abs(fract(x)) * 100.) );\n    d_1 = int( d_1 - d_0*10);\n    \n    float nm = pinum(p, xo);\n    nm = max(nm, pchar(p - vec2(.3, 0.), 46));\n    nm = max(nm, pchar(p - vec2(.6, 0.), 48 + d_0));\n    nm = max(nm, pchar(p - vec2(1., 0.), 48 + d_1));\n\t\n    return nm;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R        iResolution\n#define t        iTime\n#define A(p)     texture(iChannel0,(p)/iResolution.xy)\n#define B(p)     texture(iChannel1,(p)/iResolution.xy)\n\n// Square space size\n#define sz min(R.y, R.x) - 50.\n \n#define dt     1./iFrameRate       // Discrete time step\n#define nu     1.                  // Kinematic viscosity\n#define K      1.                  // Modulation of divergance regulation\n#define lv     11.0                // Lid velocity of top edge\n\n// Substance params\n#define kappa  .1\n#define ds     0.0000005\n\n// Forces params\n#define fq     3.0\n#define fa     21.0\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void apply_circle_velocity(\n    inout vec4 c,\n    in vec2 p,\n    in vec2 center,\n    float radius,\n    vec2 velocity,\n    int duration,\n    float thickness\n);\nvoid apply_square_boundary_conditions(\n    inout vec4 c,\n    in vec2 p,\n    float squareSize,\n    vec3 velocity,\n    int edge,\n    bool fullScreen\n);\nvec4 calculate_laplacian(in vec2 p, float squareSize);\n\n\nvoid apply_disk_obstacle(\n    inout vec4 c,\n    in vec2 p,\n    in vec2 center,\n    float radius\n) {\n    float distanceFromCenter = length(p - center);\n    if (distanceFromCenter < radius) {\n        c.xyw = vec3(0., 0., 0.);\n        \n    }\n}\n\nvoid mainImage(out vec4 c, in vec2 p) {\n    if (iFrame == 1) {\n        c = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        c = A(p);\n    }\n    \n    // Laplacian\n    vec4 laplacian = calculate_laplacian(p, sz);\n    \n    // Divergence\n    vec4  n   = A(p + vec2(0, 1));\n    vec4  e   = A(p + vec2(1, 0));\n    vec4  s   = A(p - vec2(0, 1));\n    vec4  w   = A(p - vec2(1, 0));\n    vec4  dx  = (e - w) / 2.0;\n    vec4  dy  = (n - s) / 2.0;\n    float div = dx.x + dy.y;\n\n    // Fluid simulation - solver\n    c.z   -= dt * (dx.z * c.x + dy.z * c.y + div * c.z);    // Mass conservation, Euler method step\n    c.xyw  = A(p - dt * c.xy).xyw;                          // Semi-Langrangian advection\n    c.xyw += dt * vec3(nu, nu, kappa) * laplacian.xyw;      // Viscosity/diffusion\n    c.xy  -= K * vec2(dx.z, dy.z);                          // Nullify divergence with pressure field gradient\n    c.w   -= dt * ds;                                       // Substance dissipation\n    \n    // Circular velocity force\n    vec2  center = vec2(R.x / 2., R.y / 2.);\n    vec2  cv = vec2(fa, fa * cos(fq*t));\n    float cr = 50.;\n    int   duration = 60 * int(iFrameRate);\n    float thickness = 2.;\n    if(iFrame < 600)\n        apply_circle_velocity(c, p, center, cr, cv, duration, thickness);\n\n    // Obsticle \n    vec2 diskCenter = vec2(R.x / 2., R.y / 2.);\n    float diskRadius = 25.0;\n    apply_disk_obstacle(c, p, diskCenter, diskRadius);\n    \n    // Square boundry with edge velocity\n    vec3 vs = vec3(lv, 0.0, lv);\n    apply_square_boundary_conditions(c, p, sz, vs, 4, false);\n    \n    c.xyzw = clamp(\n        c.xyzw,\n        vec4(-500, -500, 0.1,  0.),\n        vec4( 500,  500, 3.0,  5.)\n    );\n}\n\nvoid apply_circle_velocity(\n    inout vec4 c,\n    in vec2 p,\n    in vec2 center,\n    float radius,\n    vec2 velocity,\n    int duration,\n    float thickness\n) {\n    if(iFrame >= duration)\n        return;\n        \n    float d = length(p - center); \n  \n    if (abs(d - radius)  < thickness) {\n        c.xy = velocity;\n    }\n}\n\nvoid apply_square_boundary_conditions(\n    inout vec4 c,\n    in vec2 p,\n    float squareSize,\n    vec3 velocity,\n    int edge,\n    bool fullScreen // Added parameter to toggle between full screen and square boundary\n) {\n    // Calculate edges based on fullScreen flag\n    float leftEdge = fullScreen ? 1.0 : (iResolution.x - squareSize) / 2.0;\n    float rightEdge = fullScreen ? iResolution.x : (iResolution.x + squareSize) / 2.0;\n    float bottomEdge = fullScreen ? 1.0 : (iResolution.y - squareSize) / 2.0;\n    float topEdge = fullScreen ? iResolution.y : (iResolution.y + squareSize) / 2.0;\n\n    // Apply boundary condition based on the edge parameter\n    if (p.x < leftEdge ||  p.y < bottomEdge || p.x > rightEdge || p.y > topEdge) {\n        c.xyw = vec3(0.0, 0.0, 0.0);\n        return; \n    }\n\n    if (edge == 1 && p.y >= topEdge - 1.0) {           // Top edge\n        if(iFrame <= 120 * int(iFrameRate)) { c.xyw = velocity; }\n    } else if (edge == 2 && p.x >= rightEdge - 1.0) {  // Right edge\n        if(iFrame <= 120 * int(iFrameRate)) { c.xyw = velocity; }\n    } else if (edge == 3 && p.y <= bottomEdge + 1.0) { // Bottom edge\n        if(iFrame <= 120 * int(iFrameRate)) { c.xyw = velocity; }\n    } else if (edge == 4 && p.x <= leftEdge + 1.0) {   // Left edge\n        if(iFrame <= 120 * int(iFrameRate)) { c.xyw = velocity; }\n    }\n}\n\nvec4 calculate_laplacian(in vec2 p, float squareSize) {\n    vec4 laplacian = vec4(0.0);\n    float count = 0.0;\n    \n    // Define the size of the centered square and calculate its edges\n    float leftEdge = (iResolution.x - squareSize) / 2.0;\n    float rightEdge = (iResolution.x + squareSize) / 2.0;\n    float bottomEdge = (iResolution.y - squareSize) / 2.0;\n    float topEdge = (iResolution.y + squareSize) / 2.0;\n    \n    if (p.x > leftEdge) {\n        laplacian += A(p - vec2(1, 0));\n        count += 1.0;\n    }\n    if (p.x < rightEdge) {\n        laplacian += A(p + vec2(1, 0));\n        count += 1.0;\n    }\n    if (p.y > bottomEdge) {\n        laplacian += A(p - vec2(0, 1));\n        count += 1.0;\n    }\n    \n    // Adjust the top edge check to prevent calculation at the boundary\n    if (p.y < topEdge - 1.0) {\n        laplacian += A(p + vec2(0, 1));\n        count += 1.0;\n    }\n\n    laplacian -= count * A(p);\n\n    return laplacian;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}