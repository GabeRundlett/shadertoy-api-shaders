{
    "Shader": {
        "info": {
            "date": "1718256347",
            "description": "-tmm changed the factors for xyz channels and then use that fract() to compute hsv\nMouse effects changes to saturation compensation and clamp v\n\nall credits to @SnoopethDuckDuck",
            "flags": 0,
            "hasliked": 0,
            "id": "lXy3WV",
            "likes": 2,
            "name": "Oily Shiny Tiles",
            "published": 3,
            "tags": [
                "fake",
                "25d",
                "golf"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 117
        },
        "renderpass": [
            {
                "code": "// Fork of \"Shiny Tiles [210 Chars]\" by SnoopethDuckDuck. https://shadertoy.com/view/l3y3DK\n// 2024-06-12 21:27:10\n\n\nvec2 mouseUV;\n\n// hsv funcs from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    \n    // -tmm add 0.5 * mouse to compensate saturation\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y + 0.5*(mouseUV.x/mouseUV.y)); //apply saturation\n    \n    // -tmm clamp value to brigher range to remove blacks\n    rgb = rgb * (clamp(hsv.z,0.2,1.0)); //apply value\n    return rgb;\n}\n\n\n#define pi 3.14159265359 \n            \n#define tTime  (iTime/5.0)\n#define wTime  (iTime/7.242)\n#define vTime  (iTime/10.2324)\n\n// simple mouse rotate and zoom for shader\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.1) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\n\n//ORIG#define FACTOR1   (9.0)    //NOW-> (f*30.)\n//ORIG#define FACTOR2   (0.3)    //NOW-> f\n\n#define F(a,f) for (float i; i++ < 7.; u /= .998)             \\\n        o.a += .7/i/length(exp(-((f*30.))*cos(i/(f+u*u) + iTime)) \\\n                         + tan(o.a*5.-iTime/i)              \\\n                         + tan(u/i)*i/2.);                 \n         \nvoid mainImage( out vec4 o, vec2 u )\n{\n    mouseUV = (iMouse.xy==vec2(0.0) )? vec2(1.0) : iMouse.xy / iResolution.xy;\n    o.xyz = iResolution;\n    u = (u+u-o.xy)/o.y;\n    \n    //u = mouseRotZoom(u);  // rotate and zoom w/mouse also\n    \n    o -= o;\n    F(x,.3+fract(sin(wTime))) F(y,.4+fract(cos(vTime))) F(z,.5+fract(sin(tTime))) \n    \n    // o = vec4( hsv2rgb(fract(sin(iTime)* 3.1415*o.rgb)).rgb, 1. );;\n    o = vec4( hsv2rgb( fract(pi*o.rgb)).rgb, 1. );;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}