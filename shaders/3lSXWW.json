{
    "Shader": {
        "info": {
            "date": "1565818196",
            "description": "In an attempt to deepen my understanding of the projection matrix and the values left in the depth buffer, I wrote a cute little 2D frustum tool to play around with various values of a frustum.",
            "flags": 32,
            "hasliked": 0,
            "id": "3lSXWW",
            "likes": 3,
            "name": "2D Frustum Playground",
            "published": 3,
            "tags": [
                "math",
                "ui",
                "frustum",
                "playground",
                "intuition"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 650
        },
        "renderpass": [
            {
                "code": "//\n// In an attempt to gain a deeper understanding about the projection matrix,\n// I wrote a cute 2D frustum shader.\n// However, I still don't fully understand why depth can be linearly interpolated as\n// 1/Z but not Z.\n//\n// If you have an intuitive way of understanding it, I'd be happy to hear it!\n//\n// A variety of sources for depth buffers can be found here:\n// https://github.com/AlexSabourinDev/software-development-resources#depth\n//\n\nconst vec2 cSliderStore = vec2(0);\n\nfloat DrawGrid(vec2 coord)\n{\n    vec2 gridDist = abs(coord - round(coord)) * 2.0;\n    vec2 gridActive = smoothstep(vec2(0.1), vec2(0.0), gridDist);\n    return min(gridActive.x + gridActive.y, 1.0);\n}\n\nvec4 LoadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = iResolution.x/iResolution.y;\n    vec4 sliders = LoadValue(cSliderStore);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float n = max(sliders.x,0.1)*2.0, f = max(sliders.y,0.2)*2.0, s = max(sliders.z,0.1);\n    mat3x3 frustum2D = mat3x3(\n        vec3(f / s, 0.0, 0.0),\n        vec3(0.0, -f/(n-f), f*n/(n-f)),\n        vec3(0.0, 1.0, 0.0));\n    \n    // Operations:\n    // (x * (f / y)) / s; (f / y)   = similar triangles, take the ratio of f to y (far plane to current y) and scale our x.\n    //                                this transforms our x from it's current value to s (the length of our far side)\n    //                    (...) / s = scale our new value of +/-s to +/-1\n    //\n    // (y*-f/(n-f)+f*n/(n-f))/y     = transformation of our y to 1/y remapped to the 0-1 range.\n    //\n    // See http://www.songho.ca/opengl/gl_projectionmatrix.html\n    // See https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n    \n    vec3 p=vec3(uv*2.0-1.0+vec2(0.0,1.0),1.0);\n    vec2 rp=clamp(uv*2.0-1.0,vec2(-(f-n)*0.5,n-1.0)/vec2(a,1.0),vec2((f-n)*0.5,f-1.0)/vec2(a,1.0))+vec2(0.0,1.0);\n    \n    vec3 np=p*frustum2D;\n    np=vec3(np.xy/np.z,np.z);\n    \n    // Clamp our position to the perimeter of the NDC box to find the closest outer point.\n    np=clamp(np,vec3(-1.0,0.0,n),vec3(1.0,1.0,f));\n    \n    // Perform the inverse of our perspective projection on our new point.\n    np.xy*=np.z;\n    np=np*inverse(frustum2D);\n    \n    // If we clamped to the NDC box, our distance will be greater than 0, allowing us to\n    // draw a nice edge!\n    float d=distance(p.xy,mix(np.xy,rp,clamp(pow(sliders.w,2.0),0.0,1.0)));\n    fragColor = vec4(1.0)*smoothstep(0.0, 0.01, 0.01-abs(0.01-d));\n    fragColor*=vec4(sin(iTime+uv.x*10.0),cos(iTime+uv.y*10.0),1.0,1.0);\n    \n    // UI\n    fragColor+=DrawGrid(uv*10.0*vec2(a,1.0))*0.15;\n    \n    vec4 debugOverlay = texture(iChannel0, uv);\n    fragColor = mix(fragColor, debugOverlay, debugOverlay.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// UI from https://www.shadertoy.com/view/4lBcD3\n\n// Store your save data positions as constants for easy retrieval and storage\nconst vec2 cSliderStore = vec2(0);\nconst vec2 cPreviousMouseClickStore = vec2(1.0, 0.0);\n\n// State storing taken from: https://www.shadertoy.com/view/MddGzf\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 LoadValue( in vec2 re )\n{\n    return textureLod( iChannel0, (0.5+re) / iChannelResolution[0].xy, 0.0 );\n}\n\nvoid StoreValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( IsInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec4 LoadData(in ivec2 pos)\n{\n    return texelFetch(iChannel0, pos, 0);\n}\n\nfloat Equal(in vec2 rhs, in vec2 lhs) \n{\n    vec2 signOf = sign(rhs - lhs);\n    return max(1.0 - abs(signOf.x + signOf.y), 0.0);\n}\n\nfloat Not(in float l)\n{\n    return 1.0 - l;\n}\n\n// Draw a slider, and update it's value based on the mouse position\nvec4 Slider(in vec2 uv, in vec2 pos, inout float currentSlider)\n{   \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n\t// Draw the slider bar\n    const vec2 cSquareHalfSize = vec2(0.01, 0.1);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    // Draw the actual slider\n    const vec2 cSliderHalfSize = vec2(0.02, 0.01);\n    vec2 sliderAbsPoint = abs(uv - (pos + vec2(0.0, currentSlider * 2.0 * cSquareHalfSize.y - cSquareHalfSize.y)));\n    vec2 inSliderV = step(sliderAbsPoint, cSliderHalfSize);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSlider = inSliderV.x * inSliderV.y;\n    \n    // Check collision against the slider\n    const vec2 cColliderBox = vec2(0.02, 0.1);\n    vec2 relativeMousePoint = (mouseUV - pos);\n    vec2 mouseInCollider = step(abs(relativeMousePoint), cColliderBox);\n    \n\t// Update the slider's position if we're in the collider\n    float sliderHeight = (relativeMousePoint.y + cColliderBox.y) / (2.0 * cColliderBox.y);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    currentSlider = mix(currentSlider, sliderHeight, mouseInCollider.x * mouseInCollider.y);\n    \n    // Draw out the slider\n    return vec4(0.5, 0.8, 0.4, 1.0) * inSquare + vec4(1.0) * inSlider;\n}\n\nvec4 Toggle(in vec2 uv, in vec2 pos, inout float currentToggle)\n{\n    vec2 previousMouseClick = LoadValue(cPreviousMouseClickStore).xy;\n    \n    vec2 clickUV = iMouse.zw / iResolution.xy;\n    \n    float hasClickStateChanged = Not(Equal(clickUV.xy, previousMouseClick.xy));\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 cSquareHalfSize = vec2(0.02 / aspect, 0.02);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    vec2 relativeAbsMousePoint = abs(previousMouseClick - pos);\n    vec2 mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    currentToggle = mix(currentToggle, 1.0 - currentToggle, mouseInCollider.x * mouseInCollider.y * hasClickStateChanged);\n    \n    vec2 cOutlineHalfSize = vec2(0.025 / aspect, 0.025);\n    vec2 inOutlineV = step(relativeAbsPoint, cOutlineHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inOutline = inOutlineV.x * inOutlineV.y;\n    \n    vec4 outlinecolor = vec4(1.0);\n    \n    relativeAbsMousePoint = abs(clickUV - pos);\n    mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    vec4 toggleColor = mix(vec4(0.5,0.5,0.5,1.0), vec4(0.5, 0.8, 0.4, 1.0), currentToggle);\n    toggleColor = mix(toggleColor, toggleColor * 0.95,  mouseInCollider.x * mouseInCollider.y);\n    return mix(outlinecolor * inOutline, toggleColor, inSquare);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t// Load the values that you stored a previous frame\n    vec4 sliderValues = LoadValue(cSliderStore);\n\n    // Draw the sliders and update the slider values based on the mouse input\n\tvec4 sliderColor = Slider(uv, vec2(0.05, 0.85), sliderValues.x);\n    sliderColor += Slider(uv, vec2(0.1, 0.85), sliderValues.y);\n    sliderColor += Slider(uv, vec2(0.15, 0.85), sliderValues.z);\n    sliderColor += Slider(uv, vec2(0.2, 0.85), sliderValues.w);\n    \n    // Draw out the sliders\n    fragColor = sliderColor;\n    \n    // Store the values into the buffer\n    StoreValue(cSliderStore, sliderValues, fragColor, fragCoord);\n    StoreValue(cPreviousMouseClickStore, vec4(iMouse.zw / iResolution.xy, 0, 0), fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}