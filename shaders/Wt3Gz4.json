{
    "Shader": {
        "info": {
            "date": "1579125093",
            "description": "My second raymarched scene. Thanks to iq and BigWIngs / The Art of Code for great tutorials.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt3Gz4",
            "likes": 2,
            "name": "My second raymarched scene",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592\n#define MAX_STEPS 150\n#define MAX_DIST 100.0\n#define SURF_DIST .01\n\n#define GROUND 0\n#define SKY 1\n#define SPHERE 2\n#define SHELL 3\n#define BOX 4\n\n#define SKY_COLOR vec3(0.1, 0.1, 0.15)\n\nstruct Obj {\n\tint type;\n    float d;\n    vec3 hitPos;\n};\n    \nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand2(float x){\n    return fract(sin(x)*43758.5453123);\n}\n\nmat2 rotation(float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p-s.xyz)-s.w;\n}\n\n// Value noise\n// from the book of shader\nfloat noise(in vec2 uv) {\n   \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves) {\n    \n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nObj getDist(vec3 p) {\t\n    \n    // distance to the ground\n    float height = fbm(vec2(p.x, p.z), 7); \n    float planeDist = p.y - height;\n    \n    // distance to the surface of sphere\n    vec4 s = vec4(4, 1., 4, 0.8);\n    float sphereDist =  sdSphere(p, s);\n    \n     // distance to the surface of shell\n    vec3 plane = vec3(2, 2, 1.5);\n    plane.xz *= rotation(2.45);\n    \n    float slice = dot(p, normalize(plane));   \n    vec4 s2 = vec4(0.8, 0.93, -2.6, 0.6);\n    \n    float shellDist = sdSphere(p, s2);\n    shellDist = max(abs(shellDist)-.03, slice);\n    \n    // distance to the surface of the twisted box\n    vec3 bp = p-vec3(-3,1,1);\n    bp.xz *= rotation(bp.y*2.6);\n    \n    float boxDist = sdBox(bp, vec3(0.2, 3.0, 0.2)) * 0.4;\n    \n    Obj obj = Obj(GROUND, planeDist, p);\n    \n    if (sphereDist < obj.d) {\n    \tobj = Obj(SPHERE, sphereDist, p);\n    }\n  \n    if (shellDist < obj.d) {\n    \tobj = Obj(SHELL, shellDist, p);\n    }\n     \n    if (boxDist < obj.d) {\n    \tobj = Obj(BOX, boxDist, p);\n    }\n    \n    return obj;\n}\n\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.0;\n    \n    Obj hitObj = Obj(SKY, t, ro + rd);\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        hitObj = getDist(p);      \n        t += hitObj.d;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(SKY, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.d) < SURF_DIST) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.d = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = getDist(p).d;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(0.01, 0);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).d,\n        getDist(p-e.yxy).d,\n        getDist(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    \n    // compute the light vector and its normal   \n    lightPos.xz += vec2(sin(iTime*0.5), cos(iTime*0.5))*1.4;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    // calculate diffuse lightning\n    // dot product gives values between -1 to 1 hence the range\n    // is clamped to 0 to 1\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    // Add shadow\n    // raymarch to the direction of light. If the ray hits something that's\n    // closer than the light there's an object between and shadow can be added\n    float d = rayMarch(p+n*SURF_DIST*2.0, l).d;\n    \n    if(d < length(lightPos-p)) {\n        dif *= 0.1;\n    }\n    \n    return dif;\n}\n\n// From the book Texturing & Modeling: A Procedural Approach\nvec3 star(vec2 pos, float npoints, float rmin, float rmax)\n{\n    // calculates how wide the angle between two points of the star is\n    float starAngle = 2.0*PI/npoints;\n\t\n    // polar coordinates of the given point\n    float angle = atan(pos.x, pos.y) + PI;\n\tfloat radius = length(pos);\n    \n    // transforms the coordinates into new feature space in which\n    // the range between two points is set to 0 to 1. If the point lies \n    // in the upper half of the \"V\" shape the point is reflected to the\n    // lower half through the center line. This is done to avoid checking \n    // both edges and is possible due to symmetry.\n    angle = mod(angle, starAngle) / starAngle;\n    if (angle >= 0.5) {\n\t\tangle = 1.0 - angle;\n    }\n    \n    // the tip of a point of the star\n    vec3 p0 = vec3(rmax, 0, 0);\n    // the point lying in the middle of the two points at radius rmin\n    // from the center\n\tvec3 p1 = rmin * vec3(cos(starAngle/2.0) - 0.45, sin(starAngle/2.0) - 0.45, 0.0);\n    \n    // vector from the tip of the star point to the point at rmin radius\n    // from the centre \n    vec3 d0 = p1 - p0; \n    // vector from the the tip to the current position\n    vec3 d1 = radius * vec3(cos(angle), sin(angle), 0) - p0;\n    \n    // cross product will point along the positive z-axis or along the negative\n    // z-axis. The direction is determined by whether the first vector is \n    // to the left or to the right of the second vector. Hence, the direction\n    // of the cross product tells which side of the edge d0 and if it's inside\n    // the star or not.\n    vec3 direction = cross(d0, d1);\n    \n\tfloat in_out = smoothstep(0.0, 0.03, direction.z);\n\tvec3 bgColor = vec3(0.0);    \n    \n    vec3 col = mix(bgColor, vec3(1.0), in_out / length(pos));\n    \n    return col;\n}\n\n// Analytically box-filtered checkerboard by iq\nfloat checkersTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {\n\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 texCoords(in vec3 pos, in vec4 sc0) {\n    vec3 q = normalize(pos - sc0.xyz);\n    vec2 matuv = vec2(atan(q.x,q.z), acos(q.y )) * sc0.w;\n\n    return 2.0*matuv;\n}\n\nvec3 fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering) {\n\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0., 0., 0.), vec3(1.0, 0.9, 0.7), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 col = SKY_COLOR;\n    \n    // camera\n    vec3 ro = vec3(.5, 2, -8);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    Obj hitObj = rayMarch(ro, rd);\n\n    vec3 LIGHT_DIR = vec3(-1, 4, -6);\n    \n    if (hitObj.type == SKY) {\n        \n        // add one pixel wide star\n        float twinkle = dot(length(sin(uv + iTime*0.05)), \n                            length(cos(uv*vec2(22.67)-iTime*0.05)));\n        twinkle = sin(twinkle*10.0)*0.5+0.5;\n        col += vec3(pow(rand(uv), 780.0)) * twinkle;\n        \n        // add the stars with points    \n        vec3 starColor = vec3(1.0000,0.5161, 0.0000);\n\t\tvec3 bgColor = vec3(0.0);\n    \n    \tfloat rmin = 15.36 / iResolution.x*1.4;\n    \tfloat rmax = 0.12;\n    \n\t\tcol += star(uv-vec2(0.4, 0.3), 4.0, rmin, rmax);\n        col += star(uv-vec2(0.7, 0.4), 4.0, rmin, rmax);\n        col += star(uv-vec2(0.6, 0.2), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.2, -0.25), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.15, -0.4), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.66, -0.11), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.06, -0.11), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.7, -0.35), 4.0, rmin, rmax);\n        \n        // add moon\n      \t\n        // first, change the background to solid color\n        float moon = step(0.01, length(uv-vec2(0.20,0.25))-0.09);\n        col *= moon;\n        col += (1.0-moon) * SKY_COLOR;\n        \n        \n        // add two circles almost on top of each other\n        moon = smoothstep(0.001, -0.009, length(uv-vec2(0.20,0.25))-0.09);\n        col += vec3(moon);      \n        \n        moon = smoothstep(-0.01, 0.06, length(uv-vec2(0.26, 0.26))-0.095);\n        col *= moon;\n        col += (1.0-moon) * SKY_COLOR;\n            \n      \n        // add mountains\n        uv *= 10.0;\n    \tfloat i = floor(uv.x);\n  \t    float f = fract(uv.x);\n    \n    \tfloat s = rand2(uv.x);\n    \n    \tfloat pct = smoothstep(-0.01, 0.01, s-uv.y);\n    \n    \tpct = mix(rand2(i), rand2(i +1.0), smoothstep(0., 1.0, f))*1.;\n   \n        float mountain = smoothstep(-0.01, 0.01, pct-uv.y);\n    \tcol *= (1.0-mountain);\n        \n        vec3 colb = vec3(0.02);\n        vec3 colt = vec3(0.07);\n        \n        vec3 mountain_col = mix(colb, colt, uv.y);\n        col += mountain*mountain_col;\n        \n    } else if (hitObj.type == SPHERE || \n               hitObj.type == BOX ||\n               hitObj.type == SHELL) {\n    \n    \tvec4 sc0 = vec4(5.5, 1.5, 10.5, 11.5);\n        \n        if (hitObj.type == SHELL) {\n        \tsc0 = vec4(.5, 1.5, 1.5, 11.5);\n        }\n           \n        // add checkerboard texture\n      \tvec2 uvw = texCoords(hitObj.hitPos, sc0) - uv;\n\n      \tvec2 ddx_uv = dFdx( uvw );\n      \tvec2 ddy_uv = dFdy( uvw );\n        \n      \tcol = vec3(checkersTextureGradBox(uvw, ddx_uv, ddy_uv));\n\n        // make it red\n        col = col + vec3(0.5, 0.0, 0.0);\n        \n        float dif = getLight(hitObj.hitPos, LIGHT_DIR);\n        col *= dif;\n        \n    } else if (hitObj.type == GROUND) {\n        float dif = getLight(hitObj.hitPos, LIGHT_DIR) * hitObj.hitPos.y;       \n        \n        // add fog to make the farther terrain darker\n        col = dif * vec3(0.4, 0.4, 0.4);\n        float fogExtintion = 0.07;\n        float fogInscattering = 4.5;\n        \n       col = fog(col, hitObj.d, rd, LIGHT_DIR, fogExtintion, fogInscattering); \n        col += 0.02;\n\n    } else {\n    \n  \t\tfloat dif = getLight(hitObj.hitPos, LIGHT_DIR);\n  \t\tcol = vec3(dif);\n    }\n\n \tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}