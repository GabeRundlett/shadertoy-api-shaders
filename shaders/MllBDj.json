{
    "Shader": {
        "info": {
            "date": "1513438145",
            "description": "A submarine Sonar for fun! After finishing this and looking at a real one, I realized that I have apprently never seen a real Sonar!",
            "flags": 0,
            "hasliked": 0,
            "id": "MllBDj",
            "likes": 2,
            "name": "Submarine Sonar",
            "published": 3,
            "tags": [
                "maths",
                "submarinesonar"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nfloat defineACircle(vec2 center, vec2 currentPixel, float radius){\n    float toReturn = 0.0;\n    \n    if((distance(center , currentPixel) - radius)/ radius< 1.0) toReturn = 1.0;\n    \n \treturn toReturn;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float PI = 3.14159;\n    \n    // Variables\n    \n    float tilingX = 10.0;\n    float tilingY = 10.0;\n    float smoothnesOfLines = 0.06;\n    float radarSmoothness = 1.4;\n    float RadarLineThickness = 0.01;\n    float noiseAmount = 0.18;\n    \n    float rotationSpeed = 0.2;\n    \n    vec4 colorBackground = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 linesBackground = vec4(0.8, 0.5 , 0.1, 1.0);\n    vec4 radarLineColor = vec4(1.0, 1.0, 0.1, 1.0);\n    \n    vec2 circleMiddle = vec2(0.5, 0.5);\n    \n    \n    \n    // Here you map your screen to a uv space between 1 nad 0 \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    // Horizontal\n    \n    float repeatingCoordinateSystemHorizontal = fract(uv.x * tilingX);\n    \n    float distanceToLineToBeDrawnHorizontal = abs( repeatingCoordinateSystemHorizontal - 0.5 ) ;\n    \n    float lerpFactorX = clamp( distanceToLineToBeDrawnHorizontal / smoothnesOfLines, 0.0, 1.0);\n    \n    vec4 endcolor =  mix(colorBackground, linesBackground, 1.0 - lerpFactorX);\n    \n   \n    // Vertical\n    \n    float repeatingCoordinateSystemVertical = fract(uv.y * tilingY);\n    float distanceToLineToBeDrawnVertical =  abs( repeatingCoordinateSystemVertical - 0.5 ) ;\n    \n    float lerpFactorY = clamp( distanceToLineToBeDrawnVertical / smoothnesOfLines, 0.0, 1.0);\n    \n    endcolor =  mix(endcolor, linesBackground, 1.0 - lerpFactorY);\n    \n    // Add the Dots \n    \n    // dot one button left\n    float directionX = rand (vec2(floor(iTime*0.01), floor(iTime*0.1)));\n    float directionY = rand (vec2( 10.0 + floor(iTime*0.01), 30.0 + floor(iTime*0.1)));\n    \n    float dotsLerpFactor =  defineACircle( vec2(fract(iTime*0.2) *directionX ,fract(iTime*0.2) * directionY), uv, 0.024);\n   \n    \n    // dot two up right\n    \n    directionX = rand (vec2(10.0 + floor(iTime*0.01), 15.0 +  floor(iTime*0.1)));\n    directionY = rand (vec2( 35.0 + floor(iTime*0.01), 9.0 + floor(iTime*0.1)));\n    \n    dotsLerpFactor += defineACircle( vec2(1.0 -fract(iTime*0.2) *directionX , 1.0 - fract(iTime*0.2) * directionY), uv, 0.02);\n    \n    \n    \n    \n    // dot three up left\n    \n    directionX = rand (vec2(-17.0 + floor(iTime*0.01), -4.0 +  floor(iTime*0.1)));\n    directionY = rand (vec2( 135.0 + floor(iTime*0.01), 33.0 + floor(iTime*0.1)));\n    \n    dotsLerpFactor += defineACircle( vec2(fract(iTime*0.2) *directionX , 1.0 - fract(iTime*0.2) * directionY), uv, 0.016);\n    \n    \n     // dot four down right\n    \n    directionX = rand (vec2(787.0 + floor(iTime*0.01), 240.0 +  floor(iTime*0.1)));\n    directionY = rand (vec2( 532.0 + floor(iTime*0.01), 241.0 + floor(iTime*0.1)));\n    \n    dotsLerpFactor += defineACircle( 1.0 - vec2(fract(iTime*0.2) *directionX , fract(iTime*0.2) * directionY), uv, 0.028);\n    \n    \n    vec4 dotsColor = mix(vec4(0.0, 0.0, 0.0, 0.0), linesBackground, dotsLerpFactor);\n    endcolor +=dotsColor;\n    \n    // Vector to Middle of the circle \n    \n    vec2 vectorToMiddle = uv - circleMiddle;\n    \n    float angleToPixel = atan(vectorToMiddle.y/vectorToMiddle.x);\n    \n    if((vectorToMiddle.x < 0.0) && (vectorToMiddle.y>0.0)) angleToPixel +=1.0* PI;\n    if((vectorToMiddle.x < 0.0) && (vectorToMiddle.y<0.0)) angleToPixel +=1.0* PI;\n    if((vectorToMiddle.x > 0.0) && (vectorToMiddle.y<0.0)) angleToPixel +=2.0* PI;\n    \n    float cacheForRadarLine = 0.0;\n    float distanceToLawToDraw =  angleToPixel - radians( fract( - iTime * rotationSpeed) * 360.0);\n    \n    float lerpFactorCircularLine = (1.0- distanceToLawToDraw) / radarSmoothness;\n    \n    if(lerpFactorCircularLine > 1.0 ) {\n        \n        if(lerpFactorCircularLine < 1.0 + RadarLineThickness)  cacheForRadarLine = 1.0;\n        lerpFactorCircularLine = 0.0;\n        \n    }\n    \n    \n        \n    // Blend Colors\n    \n    vec4 radarColor  =  mix(vec4(0.0, 0.0, 0.0, 1.0), linesBackground,  lerpFactorCircularLine);\n    \n     endcolor += radarColor;\n    \n    endcolor += (linesBackground * 0.5);\n    \n    if(distanceToLawToDraw + 0.3<0.0) endcolor *=lerpFactorCircularLine ;\n    \n    // Draw \n    \n    \n    endcolor = mix (endcolor, radarLineColor, cacheForRadarLine);\n    \n    \n    // Blend over the static noise on screen\n    vec4 noise = vec4 (rand(uv * iTime), rand(uv* iTime), rand(uv* iTime), 1.0);\n    \n    vec4 toBlend = mix(vec4(0.8, 0.8, 0.8, 1.0), noise, 0.2);\n    \n    endcolor *=toBlend;\n    \n    endcolor += mix(vec4(0.0, 0.0, 0.0, 1.0), noise, noiseAmount);\n    \n   \n    \n\tfragColor =endcolor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}