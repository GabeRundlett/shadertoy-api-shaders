{
    "Shader": {
        "info": {
            "date": "1611332443",
            "description": "Big bruh moment, Raymarching is far better.",
            "flags": 32,
            "hasliked": 0,
            "id": "WlKyzG",
            "likes": 6,
            "name": "My Horrific Ray-Tracer",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "sphere",
                "raytrace",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 10193
        },
        "renderpass": [
            {
                "code": "// ####### Ray-Tracing #######\n\n// p.s. i am currently fixing the cringe code, don't use it until I'm done, I beg you\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Preprocessor #####\n\n/*\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n/*\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// ##### Maths #####\n\n// Rotate a 2-Component Vector\nvec2 rotate(vec2 vector, float theta)\n{\n    float s = sin(theta), c = cos(theta);\n    return vec2(vector.x * c - vector.y * s, vector.x * s + vector.y * c);\n}\n\n// Dot Product\n// for optimizations involving comparing length, for example:\n// min(length(vector0), length(vector1))\n// This can be simplified and save using an extra sqrt() by changing it to:\n// sqrt(min(dotp(vector0), dotp(vector1)))\n\nfloat dot_p(vec2 vector) { return dot(vector, vector); }\nfloat dot_p(vec3 vector) { return dot(vector, vector); }\nfloat dot_p(vec4 vector) { return dot(vector, vector); }\n\n// ##### Random Number Generator #####\n\nuint pcg(uint x) {\n    uint state = x * 747796405u + 2891336453u;\n    uint word = ( ( state >> ( (state >> 28u) + 4u ) ) ^ state ) * 277803737u;\n    x = (word >> 22u) ^ word;\n    return x;\n}\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x) {\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\n// Random Number Generator Seed\nuint ns;\n\n// Initialize Random Number Generator\n#define INIT_RNG ns = uint(iFrame) * uint(iResolution.x * iResolution.y) + uint(fragCoord.x + fragCoord.y * iResolution.x) + 1u;\n\n// Uniform Random Value Between 0.0 and 1.0\nfloat rand() {\n    // Update RNG\n    ns = pcg(ns);\n    //ns = triple32(ns);\n\n    return float(ns) / float(0xFFFFFFFFu);\n}\n\n// 2-Component Uniform Random Vector\nvec2 rand2() {\n    vec2 vector;\n    vector.x = rand();\n    vector.y = rand();\n    return vector;\n}\n\n// 3-Component Uniform Random Vector\nvec3 rand3() {\n    vec3 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.y = rand();\n    return vector;\n}\n\n// 4-Component Uniform Random Vector\nvec4 rand4() {\n    vec4 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.z = rand();\n    vector.w = rand();\n    return vector;\n}\n\n// Uniformly distributied random point on a unit circle\nvec2 udir2() {\n    float z = rand();\n    float r = two_pi * z;\n    float s = sin(r), c = cos(r);\n    return vec2(s, c);\n}\n\n// Uniformly distributed random point on the surface of a unit sphere\nvec3 udir3() {\n    vec2 z = rand2();\n    vec2 r = vec2( two_pi * z.x, acos(2.0 * z.y - 1.0) );\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// 2D Gaussian Distribution\nvec2 nrand2(vec2 mean, float sigma) {\n    vec2 z = rand2();\n    return mean + sigma * sqrt( -2.0 * log(z.x   ) ) * vec2(cos(two_pi * z.y), sin(two_pi * z.y) );\n}\n\n// 3D Gaussian Distribution\nvec3 nrand3(vec3 mean, float sigma) {\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxy ) ) * vec3(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w) );\n}\n\n// 4D Gaussian Distribution\nvec4 nrand4(vec4 mean, float sigma) {\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxyy) ) * vec4(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w), sin(two_pi * z.w) );\n}\n\n// ##### Misc #####\n\n// Blackman-Harris Pixel Filter\nvec2 pixel_filter(vec2 pixel_coord)\n{\n    // Gaussian Pixel Filter\n    //return nrand2(pixel_coord, 0.5);\n\n    // https://en.wikipedia.org/wiki/Window_function#Blackmanâ€“Harris_window\n    // w[n] = a0-a1*cos(2*pi*n/N)+a2*cos(4*pi*n/N)-a3*cos(6*pi*n/N)\n    // a0 = 0.35875; a1 = 0.48829; a2 = 0.14128; a3 = 0.01168\n    float n = 0.5 * rand() + 0.5;\n    float w = 0.35875 - 0.48829 * cos(2.0 * pi * n) + 0.14128 * cos(4.0 * pi * n) - 0.01168 * cos(6.0 * pi * n);\n    return pixel_coord + (udir2() * 2.0 * w);\n}\n\n/*\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\nfloat ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define FOV 1.0\n\n/*\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect(in vec3 ro, in vec3 rd){\n    vec3 ce = sphereposition;\n    float ra = spheresize;\n    vec3 oc = ro-ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc)-ra*ra;\n    float h = b*b-c;\n    if(h < 0.0){return vec2(-1.0);}\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n*/\n\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra)\n{\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n\n    if(h < 0.0)\n    {\n        return vec2(-1);\n    }\n\n    h = sqrt(h);\n\n    return vec2(-b - h, -b + h);\n}\n\n/*\n// Suggested by Michael0884\nvec3 fresnel(vec3 rd, vec3 hvec){\n    vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-rd, hvec), 5.0);\n}\n*/\n\nvec3 fresnel(vec3 rd, vec3 h)\n{\n    const vec3 F0 = vec3(1);\n\n    //return F0 + (1.0 - F0) * pow(1.0 - dot(-rd, h), 5.0);\n\n    float p = 1.0 - dot(-rd, h);\n\n    return F0 + (1.0 - F0) * (p * p * p * p * p);\n}\n\nfloat mod289(float x) { return x - floor( x * (1.0 / 289.0) ) * 289.0; }\nvec4  mod289(vec4  x) { return x - floor( x * (1.0 / 289.0) ) * 289.0; }\nvec4  perm  (vec4  x) { return mod289( ( (x * 34.0) + 1.0 ) * x)     ; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p-a;\n    d = d*d*(3.0-2.0*d);\n    vec4 b = a.xxyy+vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2+a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c+1.0);\n    vec4 o1 = fract(k3*(1.0/41.0));\n    vec4 o2 = fract(k4*(1.0/41.0));\n    vec4 o3 = o2*d.z+o1*(1.0-d.z);\n    vec2 o4 = o3.yw*d.x+o3.xz*(1.0-d.x);\n    return o4.y*d.y+o4.x*(1.0-d.y);\n}\n\nfloat fbm(vec3 p, int octaves)\n{\n    octaves = max(octaves, 1);\n\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < octaves; i++)\n    {\n        value += atten * noise(scale * p);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value / accum;\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec2 intersection = sphIntersect(ro, rd, vec3(0), 1.0);\n\n    if(intersection.x < 0.0)\n    {\n        return texture(iChannel1, rd).rgb;\n    }\n\n    vec3 normal = normalize(ro + rd * intersection.x);\n\n    vec3 randomnormal = normalize( nrand3( normal, 0.1 * fbm(16.0 * normal, 8) ) );\n\n    vec3 reflected = reflect(rd, randomnormal);\n\n    vec3 color = fresnel(rd, normal)*texture(iChannel1, reflected).rgb;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iFrame != 0 ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0);\n\n    INIT_RNG;\n\n    vec2 uv = 2.0 * (nrand2(fragCoord, 0.5) - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize( vec3(FOV * uv, -1.0) );\n\n    vec3 color = radiance(ro, rd);\n\n    fragColor += vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor.rgb = texel.a != 0.0 ? texel.rgb / texel.a : texel.rgb;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}