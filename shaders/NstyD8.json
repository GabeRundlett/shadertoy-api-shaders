{
    "Shader": {
        "info": {
            "date": "1653397722",
            "description": "TL // Grid + Dancing Lights",
            "flags": 0,
            "hasliked": 0,
            "id": "NstyD8",
            "likes": 6,
            "name": "TL // Grid + Dancing Lights",
            "published": 3,
            "tags": [
                "tlgriddancinglights"
            ],
            "usePreview": 0,
            "username": "fpiaggio",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "#define FALLOFF_START 1.0\n#define DECAY_START 0.1\n#define DECAY 1.0\n\n#define GRIDW 0.02\n\n#define GRID_R 0.672443156957688\n#define GRID_G 0.0103298230296269\n#define GRID_B 0.246201326707835\n#define FALLOFF_GRID 0.75\n\n// Grid from  https://www.shadertoy.com/view/3tlXWS\n\nfloat sRGB(float x) {\n    if (x <= 0.00031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\n}\n\nfloat saw(float t) {\n \treturn t - floor(t);   \n}\n\nfloat tri(float t) {\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\nfloat grid(vec2 pix, float t) {\n    \n    float d = t + (pix.y / 30.0) + sin(pix.x * 500.0);\n    \n    float distortion = (sin(d * 400.0)*2. + (sin(d * 600.0) / 2.0) + (sin(d * 800.0) / 3.0)) / 4.0;\n    \n    float w = tri((pix.x + distortion) / 50.0);\n    float h = tri((pix.y + distortion) / 50.0);\n    \n    \n    float power = 1.0 + 0.25 * tri(pix.y / 50.0 + t / 6.0);\n    \n    float falloff = power * FALLOFF_GRID;\n    \n    float dist = min(w, h) * 25.0;\n    \n    return min(power, power * (falloff * falloff) / (dist * dist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 center = iResolution.xy / 2.0;\n    vec3 col = vec3(0);\n    float scale = 816.0 / iResolution.x;\n    // float scale = sin(iTime)*1512.0 / iResolution.x;\n    \n    vec2 uv = (fragCoord - center) * scale;\n    \n    vec2 uv_r = uv - vec2(sin(iTime / 3.0 + uv.y / 50.0) * 4.0, sin(uv.x / 75.0 + iTime / 8.0));\n    vec2 uv_g = uv;\n    vec2 uv_b = uv + vec2(cos(iTime / 2.0 + uv.y / 50.0) * 4.0, cos(uv.x / 50.0 + iTime / 4.0));\n\n    float grid_r = grid(uv_r, iTime) * GRID_R;\n    float grid_g = grid(uv_g, iTime - 0.1) * GRID_G;\n    float grid_b = grid(uv_b, iTime + 0.1) * GRID_B;\n    \n    vec3 grid_col = vec3(sRGB(grid_r), sRGB(grid_g), sRGB(grid_b));\n    \n    uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    float v = 0.0;\n    vec2 pos = uv * 2.;\n    float angle = 6. + sin(iTime*0.015);\n    float separation = 0.00195 + sin(iTime*0.2) * 0.02;\n    int maxIt = 150;\n    for (int i = 0; i < maxIt; i++) {\n        float s = (iTime*0.02) + float(i) * separation;\n        // vec2 mpos = 0.9 * vec2(sin(s * angle), - cos(s * (angle+1.) + iTime * 0.5));\n        vec2 mpos = (0.6 + sin(iTime * 0.5)) * vec2(sin(s * angle), - cos(s * (angle+1.) + iTime * 0.4));\n        float t = 1. / length(mpos - pos);\n        // float idx = float(i)/ float(maxIt);\n        v += t*t * float(i + 1) / 600000.0;\n    }\n\n    vec3 particles = vec3(vec3(v, v, v+0.5));\n    col = mix(grid_col, particles, particles);\n    //col = mix(col, particles, grid_col);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}