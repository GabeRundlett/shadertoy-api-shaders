{
    "Shader": {
        "info": {
            "date": "1674088438",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "ctB3Dt",
            "likes": 18,
            "name": "Year of Truchets #001",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #001\n    01/18/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\nfloat hash21(vec2 p) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat torus( vec3 p, vec2 a ){\n  return length(vec2(length(p.xy)-a.x,p.z))-a.y;\n}\n\nvec3 hp,hitpoint;\nvec2 gid, sid;\n\nconst float sz = 2.35;\nconst float hf = sz/2.;\nconst float zz = 4.25;\n\nfloat truchet(vec3 p, float id) {\n    float res =1e5;\n    \n    p.xy*=rot(T*.025);\n    p.y+=T*1.5;\n    \n    vec3 q=p;\n    vec2 gid = floor((p.xy+hf)/sz);\n    p.xy  = mod(p.xy+hf,sz)-hf;\n    \n    float rnd = hash21(gid+id);\n    if(rnd>.5) p.y *=-1.;\n    \n    float thk = .35;\n    \n    thk += .1*sin(q.y*1.3);\n    thk += .1*sin(q.x*1.3);\n    \n    vec2 d2 = vec2(length(p.xy-hf), length(p.xy+hf));\n    vec2 gx = d2.x<d2.y ? vec2(p.xy-hf) : vec2(p.xy+hf);\n    vec3 pv = vec3(gx.xy,p.z);\n    hp=pv;\n    float d = torus(pv,vec2(hf,thk));\n    \n    if(rnd>.9) { d=min(length(p.xz)-thk,length(p.yz)-thk); }\n    if(d<res) { res=d; hp=p; }\n\n    return res;\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n\n\n    float d = 1e5;\n    float m = 0.;\n    \n    for(float i=0.;i<3.;i++){\n        float e = truchet(p,i);\n        p.z+=zz;\n        d=min(e,d);\n        m+=.5;\n\n        if(d<res.x) res=vec2(d,m);\n\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, int steps) {\n    float d=0.,m=0.;\n    for(int i=0;i<steps;i++){\n        vec2 t = map(p);\n        d += i<32? t.x*.5:t.x;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(abs(t.x)<d*MIN_DIST||d>75.) break;\n    } \n    return vec2(d,m);\n}\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    t+=T*.06;\n    return .75+.75*cos(PI2*t*(vec3(1.,.99,.95)+vec3(.1,.34,.27))); \n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    vec2 ray = marcher(ro,rd,p,100);\n    \n    float d = ray.x;\n    float m = 23.+(ray.y*.7);\n    \n    gid = sid;\n    hitpoint = hp;\n    \n    if(d<MAX_DIST) {\n  \n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(5.5,-3,13.);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t=.01;t<24.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>24. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.35);\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),0.),24.);\n        \n        vec3 h = hue(m+hitpoint.x*.2);\n        vec3 h2 = hue(2.52+(m*2.));\n        float px = 8./R.x;\n  \n        float f = length(hitpoint.xy)-(hf*.75);\n        float ff = abs(abs(abs(f)-.2)-.1)-.05;\n        float fs=smoothstep(.1+px,-px,ff);\n        \n        f=smoothstep(px,-px,ff);\n        h=mix(h,h*.4,fs);\n        h=mix(h,h2,f);\n        C = h * diff+spec;\n    }\n\n    C = mix(C,vec3(.04), 1.-exp(-.00045*d*d*d));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}