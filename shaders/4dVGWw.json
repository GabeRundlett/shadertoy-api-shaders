{
    "Shader": {
        "info": {
            "date": "1454802780",
            "description": "Thanks Bergi! Write a number in the right box and the white dot shows the networks guess 0-9. Click the red dot to clear. Find the original by bergi here: [url]https://www.shadertoy.com/view/MdV3Wh[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "4dVGWw",
            "likes": 41,
            "name": "Handwritten DigiClass",
            "published": 3,
            "tags": [
                "neural",
                "network",
                "handwriting"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 1516
        },
        "renderpass": [
            {
                "code": "//This is just a refactoring of bergi's digit classifier to handle written numbers\n//Find the original here: https://www.shadertoy.com/view/MdV3Wh\n\n/*This is how the interface works...\nTop of the screen is the Neural Net weights laid out by digit (garbage)\nLeft side is the net being trained.\nRight side is for you to draw a digit in the grey square (hold left mouse)\nTop of the grey square shows the network's guess.\nRed dot in the middle erases your drawing.\nDigits in the lower left of the screen can be replaced with the current drawing by clicking them.\n*/\n\n/* Neural Net Digit classifier on Shadertoy \n\n   (c) 0x7e0, Stefan Berke\n\n   License: Creative Commons ...\n\n   Trained to output the correct class for each of 10 digits\n\n   No hidden layer, simply\n   16x16 input -> 10 output\n   2560 weights, no bias\n\n   Left image shows current training, \n\t with desired (top) and actual (bottom) net output\n   \n   Right image is a test,\n     with the network output (bottom) \n     and indicator of the cell with the highest output \n\n\n   It seems to learn most classes in ~15 seconds and\n   then degrades somehow...\n   Restart to learn from scratch\n*/\n\n\n\n\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(0.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat expectedOutputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat outputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[1].xy;\n    return texture(iChannel1, p).x;\n}\n\nfloat inputState2(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(16.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat outputState2(in int op)\n{\n    vec2 p = vec2(float(op)+.5, 1.5) / iChannelResolution[1].xy;\n    return texture(iChannel1, p).x;\n}\n\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[2].xy; \n    return (texture(iChannel2, p).x - .5) * 4.;\n}\n\n\nvec3 classifier(in vec2 uv)\n{\n    uv /= 10.;\n    \n    vec3 col = vec3(0.);\n    if (uv.x >= 0. && uv.y >= 0. && uv.x < 16. && uv.y < 18.)\n    {    \n        float v = 0.2 + 0.8 * inputState(ivec2(uv));\n\t\tcol = vec3(v);\n    \n    \tif (uv.y >= 16. && uv.x <= 10.)\n    \t{\n        \tfloat s = outputState(int(uv));\n        \tcol = vec3(max(0., s), 0., max(0.,-s));\n    \t}\n    \tif (uv.y >= 17. && uv.x <= 10.)\n    \t{\n        \tfloat s = expectedOutputState(int(uv));\n        \tcol = vec3(max(0., s), 0., max(0.,-s));\n    \t}\n    \n    }\n    return col;\n}\n//taken from digits/sliders/kbd widgets by FabriceNeyret2  https://www.shadertoy.com/view/MdKGRw\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n    uv.x=-uv.x;\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nvec3 testImage(in vec2 uv)\n{\n    uv /= 10.;\n    \n    vec3 col = vec3(0.);\n    \n    if (uv.x >= 0. && uv.y >= 0. && uv.x < 16. && uv.y < 18.)\n    {    \n    \tfloat v = 0.2 + 0.8 * inputState2(ivec2(uv));\n\t\tcol = vec3(v);\n    \n    \t// find output cell with highest output\n    \tfloat ma = 0.;\n    \tint outc = 0;\n    \tfor (int i=0; i<10; ++i)\n    \t{\n        \tfloat s = outputState2(i);\n        \tif (s > ma)\n        \t{\n            \tma = s;\n            \toutc = i;\n        \t}\n    \t}\n\n    \t// draw output state\n    \tif (uv.y >= 16. && uv.x <= 10.)\n    \t{\n        \tfloat s = outputState2(int(uv));\n        \tcol = vec3(max(0., s), 0., max(0.,-s));\n    \t}\n    \n    \t// draw highest state\n    \tif (uv.y >= 17. && uv.x <= 10.)\n        \tcol = vec3(outc == int(uv.x) ? 1. : 0.);\n        float d=digit(uv-vec2(12.0,16.5),outc);\n        if(d>0.5)col=vec3(1.0);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x<160. && fragCoord.y<16.){\n        fragColor=texture(iChannel0,(fragCoord+vec2(32.,0.0))/iResolution.xy);\n        return;\n    }\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 col = classifier(fragCoord.xy - 25.);\n\tcol = max(col, testImage(fragCoord.xy - vec2(300., 25.)));\n    \n    // render weight matrix\n    {\n        float x=floor(fragCoord.x/3.-5.),y=floor(fragCoord.y/3. - 75.);\n        float X=y*16.+mod(x,16.),Y=floor(x/16.);\n        int inCell = int(X);//fragCoord.x/2. - 10.);\n        int outCell = int(Y);//fragCoord.y/2. - 130.);\n        if (inCell >= 0 && inCell < 256 && outCell >= 0 && outCell < 10)\n        {\n            float w = 10.*weight(inCell, outCell);\n    \t\tcol = vec3(max(0., w), 0., max(0.,-w));\n        }\n    }\n    fragColor = vec4(col, 1.);\n    vec2 ms=fragCoord.xy/iResolution.xy-0.5;\n    if(length(ms)<0.035)fragColor=vec4(1.0,0.0,0.0,1.0);\n    \n    \n\t//fragColor = vec4(texture(iChannel2, uv/10.0).xyz, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//just added squiggly numbers -eiffie\n// \n// NETWORK INPUT\n//\n// renders a 16x16 random digit at 0,1\n// and a 10x1 expected network output at 0,0 (the class of the digit)\n// additionally renders a digit at 16,1 for testing the network\n\n\n\n// ------------- pseudo handwritten digits ----------------\n\nfloat Tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nfloat Arc(in vec2 p, float s, float e, float r1, float r2) {float t=clamp(atan(p.y*r1,p.x*r2),s,e);return length(p-vec2(r1*cos(t),r2*sin(t)));}\nfloat num(vec2 p, int n){\n\tvec2 a=abs(p),a4=a-0.4;\n\tfloat d;\n\tif(n==0)return abs(length(p)-0.4); \n\tif(n==1)return max(a.x,a4.y);\n\tif(n==2){\n\t\td=Arc(p-vec2(0.0,0.2),-1.57,2.4,0.4,0.2);\n\t\td=min(d,Arc(p+vec2(0.0,0.4),1.57,3.14,0.4,0.4));\n\t\td=min(d,max(a4.x,abs(p.y+0.4)));\n\t\treturn d;\n\t}\n\tif(n==3){\n\t\td=Arc(p-vec2(0.0,0.2),-1.57,2.4,0.4,0.2);\n\t\td=min(d,Arc(p+vec2(0.0,0.2),-2.4,1.57,0.4,0.2));\n\t\treturn d;\n\t}\n\tif(n==4){\n\t\td=max(a4.x,a.y);\n\t\td=min(d,max(abs(p.x-0.4),a4.y));\n\t\td=min(d,Tube(p-vec2(-0.4,0.0),vec2(0.6,0.4)));//split the difference in 4's\n\t\treturn d;\n\t}\n\tif(n==5){\n\t\td=max(a4.x,abs(p.y-0.4));\n\t\td=min(d,max(abs(p.x+0.4),abs(p.y-0.2)-0.2));\n\t\td=min(d,Arc(p-vec2(-0.05,-0.15),-2.45,2.45,0.45,0.3));\n\t\treturn d;\n\t}\n\tif(n==6){\n\t\td=Arc(p-vec2(0.0,-0.2),-3.1416,3.1416,0.4,0.2);\n\t\td=min(d,Arc(p-vec2(0.2,-0.2),1.57,3.1416,0.6,0.6));\n\t\treturn d;\n\t}\n\tif(n==7){\n\t\td=max(a4.x,abs(p.y-0.4));\n\t\td=min(d,Tube(p-vec2(-0.4,-0.4),vec2(0.8,0.8)));\n\t\treturn d;\n\t}\n\tif(n==8){\n\t\td=Arc(p-vec2(0.0,0.2),-3.1416,3.1416,0.4,0.2);\n\t\td=min(d,Arc(p-vec2(0.0,-0.2),-3.1416,3.1416,0.4,0.2));\n\t\treturn d;\n\t}\n\tif(n==9){\n\t\td=Arc(p-vec2(0.0,0.2),-3.1416,3.1416,0.4,0.2);\n\t\td=min(d,Arc(p-vec2(-0.2,0.2),-1.8,0.0,0.6,0.6));\n\t\treturn d;\n\t}\n    return 1.0;\n}\n\nvec3 printDigi(int di, vec2 uv)\n{\n    float d = num(uv,di);\n    return vec3(smoothstep(0.18,0.0,d));\n}\n\n// ----------------------------------------\n\n\n// hash by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat rnd=1.234;\nfloat rand(){return fract(sin(iTime+rnd++)*3424.4234);}\nvec2 smear(vec2 uv){\n    float a=rand()-0.5,b=rand()-0.5,c=(rand()-0.5)*(1.0-pow(abs(a)+abs(b),0.5));\n\tvec2 v=uv+vec2(a,b);\n\treturn sin(3.0*a*v.yx+2.4*sin(2.0*b*vec2(v.x+v.y,v.x-v.y)))*c;\n}\nvec3 digitRect(in vec2 uv, in int digit)\n{\n    uv = (uv / 8. - 1.02) * 0.6;\n\treturn printDigi(digit, uv);\n}\nvec3 savedRect(in vec2 uv, in int digit)\n{\n    uv+=smear(uv/8.-1.0)*8.;\n    uv.x+=float(digit+2)*16.;\n\treturn texture(iChannel0, uv/iResolution.xy).rgb;\n}\nvec2 ms2Dig(vec2 ms){\n    ms-=vec2(300.,25.);\n    return ms/10.+vec2(16.,1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= 192. || fragCoord.y >= 17.)discard;\n    fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n    if(iFrame<2){\n        int i=int(fragCoord.x/16.);\n        fragColor.rgb=digitRect((fragCoord - vec2(float(i)*16.,0.)), i-2);\n    }\n    if(fragCoord.x<16.){\n\t    // random training digit\n\t    int digit = int(hash(float(iFrame/1)*1.11)*9.+.5);\n    \tfragColor.rgb = savedRect(fragCoord- vec2(0., 1.) + hash(iTime), digit); \n    \t// expected network output\n    \tif (fragCoord.y < 1.)\n    \t{\n        \tfragColor.rgb = digit == int(fragCoord.x) ? vec3(.7) : vec3(0.);\n    \t}\n        return;\n    }\n    //ui\n    if(iMouse.z>0.0){//clicked\n        if(iMouse.y<16. && floor(fragCoord.x/16.)==floor(iMouse.x/16.)+2.){//replace training char with handwritten version\n            float x=floor(iMouse.x/16.)*16.;\n            fragColor=texture(iChannel0,vec2(mod(fragCoord.x,16.)+16.,fragCoord.y)/iResolution.xy);\n            return;\n        }\n        if(fragCoord.x>=32.)return;\n        vec2 ms=iMouse.xy/iResolution.xy-0.5;\n        if(length(ms)<0.035)fragColor.rgb=vec3(0.0); //clear handwriting\n        else{\n            ms=ms2Dig(iMouse.xy);//record handwriting\n        \tfloat d=length(ms-fragCoord.xy);\n        \td=smoothstep(1.5,0.0,d);\n            fragColor.rgb=max(fragColor.rgb,vec3(d));\n        }\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//I switched the order of forward and back prop - eiffie\n// FORWARD PROPAGATION\n//\n// takes a 16x16 input (chan0) and a 256x10 weight matrix (chan1)\n// and renders a 10x1 output\n//\n// uses the training y=0/test y=1 image as input\n\n// http://www.musicdsp.org/showone.php?id=238\nfloat Tanh(in float x) { return clamp(x * ( 27. + x * x ) / ( 27. + 9. * x * x ), -1., 1.); }\n\n// activation function\nfloat activation(in float x) { return Tanh(x); }\n\nvec2 offset=vec2(0.5, 1.5);\n\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + offset) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[1].xy; \n    return (texture(iChannel1, p).x - .5) * 4.;\n}\n\nfloat cellState(in int outCell)\n{\n    float sum = 0.;\n\tfor (int j=0; j<16; ++j)    \n    for (int i=0; i<16; ++i)    \n    {\n        sum += weight(j*16+i, outCell) * inputState(ivec2(i,j));\n    }\n    return activation(sum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > 10. || fragCoord.y > 2.)\n        discard;\n    if(fragCoord.y>=1.0)offset=vec2(16.5, 1.5);\n    int outCell = int(fragCoord.x);\n\t\n    float w = cellState(outCell);\n    fragColor = vec4(w, 0., 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// WEIGHT INITIALIZATION\n// AND GRADIENT DESCENT LEARNING\n//\n// renders a 256x10 weight matrix\n//\n// first two animation frames initialize randomly\n// after that, the expected and real network output are compared\n// and the error derivative is used to adjust the weights\n//\n\nconst float INIT_VARIANCE = 0.05;\nconst float LEARNRATE = 0.01;\n\n\n// http://www.musicdsp.org/showone.php?id=238\nfloat Tanh(in float x) { return clamp(x * ( 27. + x * x ) / ( 27. + 9. * x * x ), -1., 1.); }\n\n// activation function\nfloat activation(in float x) { return Tanh(x); }\n// derivative of the activation function\nfloat derivative(in float x) { return 1. - x * x; }\n\n// hashes by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n\n// 16x16 input to the net (the digit image)\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(0.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\n// the class of the input in 10 cells\nfloat expectedOutputState(in int op)\n{\n    vec2 p = vec2(float(op)+0.5, .5) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\n// the previous guess of the correct answer\nfloat outputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[1].xy;\n    return texture(iChannel1, p).x;\n}\n\n// the weight between each input and output cell\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[2].xy; \n    return (texture(iChannel2, p).x - .5) * 4.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= 256. || fragCoord.y >= 10.)\n        discard;\n    \n    // INIT WEIGHTS\n    if (iFrame < 2)\n    {\n        float w = (hash(fragCoord)-.5)*2. * INIT_VARIANCE;\n        \n        fragColor = vec4(vec3(w*.25+.5), 1.0);\n        return;\n    }\n    \n    // BACKPROP\n    \n    int inCell = int(fragCoord.x);\n    int outCell = int(fragCoord.y);\n    ivec2 ip = ivec2(int(mod(float(inCell), 16.)), inCell / 16);\n    \n    // previous output from forward pass\n    float outs = outputState(outCell);\n    // difference to expected output\n    float err = expectedOutputState(outCell) - outs;\n    // error derivative w.r.t. input state \n    float der = derivative(outs) * err * inputState(ip);\n    \n    float w = weight(inCell, outCell);\n    \n    // adjust weight\n    w += LEARNRATE * der; \n    \n    fragColor = vec4(vec3(w * .25 + .5), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}