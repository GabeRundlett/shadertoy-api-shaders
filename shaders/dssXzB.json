{
    "Shader": {
        "info": {
            "date": "1669160394",
            "description": "An \"escape time\" algorithm for drawing limit sets based on \"Grandma's Recipe\" from Indra's Pearls. See comments.",
            "flags": 0,
            "hasliked": 0,
            "id": "dssXzB",
            "likes": 26,
            "name": "Kleinian - \"Grandma's Recipe\"",
            "published": 3,
            "tags": [
                "fractal",
                "math",
                "mobius",
                "kleinian",
                "set",
                "limit",
                "pearls",
                "indras"
            ],
            "usePreview": 0,
            "username": "amoser",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "// An algorithm for drawing limit sets of Kleinian groups specified by \"Grandma's Recipe\" from the book \n// Indra's Pearls by David Mumford, Caroline Series, and David Wright. It's somewhat similar in spirit to\n// Jos Leys' algorithm https://www.shadertoy.com/view/MtKXRh , but it also supports groups where traces of \n// both generators are complex (i.e. groups that are not Maskit groups). It's also slower and less robust,\n// at least at the moment.\n\n// The ultimate goal is to use this to render 3D limit sets (which is also why this code features lots of\n// quaternions for seemingly no reason) since it should be applicable pretty directly, but I thought this\n// version looked pretty OK in its own right and might be useful to someone.\n\n// I hope it's relatively readable as well.\n\n// Uncomment to view the estimated Schottky curves used to determine which transformation to apply at\n// each iteration.\n//#define DEBUG_VIEW\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.0;\n    vec2 z = zoom*(2.0*(fragCoord.xy) - iResolution.xy) / iResolution.y;\n    \n    vec2[] ta = vec2[]\n    (\n        vec2(2,0),\n        vec2(2,0.2),\n        vec2(2,0.2),\n        vec2(2,-0.2),\n        vec2(2,-0.2),\n        vec2(1.8,-0.2),\n        vec2(1.8,-0.2),\n        vec2(2,0),\n        vec2(2,0),\n        vec2(1.8,-0.2),\n        vec2(2.2,0),\n        vec2(2.1,-0.4),\n        vec2(2,-0.9),\n        vec2(1.9,-1.4)\n    );\n    vec2[] tb = vec2[]\n    (\n        vec2(2,0),\n        vec2(2,0),\n        vec2(2,0.2),\n        vec2(2,0.2),\n        vec2(2,-0.2),\n        vec2(2,-0.2),\n        vec2(1.8,-0.2),\n        vec2(2,0),\n        vec2(1.8,0.2),\n        vec2(1.8,0.2),\n        vec2(2.2,0),\n        vec2(2.1,-0.4),\n        vec2(2,-0.9),\n        vec2(1.9,-1.4)\n    );\n    \n\n    float time = mod(iTime/2.0,float(ta.length()));\n    int index = int(floor(time));\n    float blend = fract(time);\n    vec2 tracea = mix(ta[index],ta[(index + 1)%ta.length()],smoothstep(0.0,1.0,smoothstep(0.0,1.0,blend)));\n    vec2 traceb = mix(tb[index],tb[(index + 1)%ta.length()],smoothstep(0.0,1.0,smoothstep(0.0,1.0,blend)));\n\n    // The actual generators to be calculated based on their traces.\n    transform a;\n    transform b;\n    transform A;\n    transform B;\n\n    // Construct the generating transformationa a, b, A, and B.\n    grandmaRecipe(vec4(tracea, 0, 0), vec4(traceb, 0, 0), a, b, A, B);\n    \n    // We're specifically interested in the properties of the fixed points of the commutators since they\n    // give useful information about the Schottky curves we need to make the algorithm work.\n    transform comAB = commutator(A,B);\n    transform comAb = commutator(A,b);\n\n    vec4 comabf1, comabf2, comABf1, comABf2, comaBf1, comaBf2, comAbf1, comAbf2;\n    fixedPoints(comAB,comABf1,comABf2);\n    fixedPoints(comAb,comAbf1,comAbf2);\n    // No need to calculate these two, since they're always the same for this family of groups.\n    comabf1 = vec4(1,0,0,0);\n    comaBf1 = vec4(-1,0,0,0);\n    \n    vec4 fa1, fb1, fA1, fB1, fa2, fb2, fA2, fB2;\n    fixedPoints(a,fa1,fa2);\n    fixedPoints(b,fb1,fb2);\n    fixedPoints(A,fA1,fA2);\n    fixedPoints(B,fB1,fB2);\n    \n    vec3 col = vec3(1);\n    \n    const int maxIter = 30;\n    float scale = 1.0;\n    float de = 1.0;\n    \n    // Stores the z value whenever we apply transformation b.\n    // If we're at the same position the next time we apply this transformation, we know that the orbit\n    // has become periodic and can break out of the main loop.\n    vec2 lastb = vec2(-10000);\n\n#ifdef DEBUG_VIEW\n    col *= 0.5;\n    \n    // Triangles used as a base for estimating the Schottky curves. Two vertices are placed\n    // at the fixed points of the commutators, which are always points where the Schottky\n    // curves touch. The third vertex is placed at a fixed point of the inverse transformation,\n    // which will be the \"tip\" of the limit set.\n    // There are some really obvious ways to make the estimate much more accurate that I'll get to\n    // eventually.\n    col.g += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy))));\n    col.rg += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy))));\n    col.b += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy))));\n    col.r += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy))));\n    col.r += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy))));\n    col.r += 0.5*(1.0-min(1.0, (0.5/zoom)*iResolution.y*abs(sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))));\n    \n    // Final (estimated) Schottky regions determined by choosing the closest triangle to a given point.\n    // You can observe (at least in cases where the Schottky regions are valid) that each colored region\n    // contains a distorted copy of all of the other colored regions, wich is the key to why this works.\n    if(sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n    {\n        col.g += 0.1;\n    }\n    else if((z.x >= comaBf1.x\n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n        || (z.x < comaBf1.x && z.y < comaBf1.y))\n    {\n        col.rg += 0.1;\n    }\n    else if((z.x <= comabf1.x\n        && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n        && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n        && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n        || (z.x > comabf1.x && z.y < comabf1.y))\n    {\n        col.b += 0.1;\n    }\n    else\n    {\n        col.r += 0.1;\n    }\n#endif\n\n    // The actual \"escape time\" algorithm based on the regions above.\n    for(int i = 0; i < maxIter; i++)\n    {\n        // Add the known limit set points to distance estimate. \n        // By definition, they'll remain in the limit set after each transformation is applied.\n        de = min(de, scale*min(min(distance(z, fB1.xy), distance(z, comABf1.xy)),distance(z, comaBf1.xy)));\n        de = min(de, scale*min(min(distance(z, fb1.xy), distance(z, comabf1.xy)),distance(z, comAbf1.xy)));\n        de = min(de, scale*min(distance(z, fA1.xy), distance(z, -fA1.xy)));\n        de = min(de, scale*min(distance(z, -fB1.xy), distance(z, -comABf1.xy)));\n        de = min(de, scale*min(distance(z, -fb1.xy), distance(z, -comAbf1.xy)));\n\n        // Apply relevant transformation based on which Schottky region we're in.\n        if(sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fA1.xy, comABf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n        {\n            scale /= clamp(jacobian(a, vec4(z,0,0)),-40.0,40.0);\n            z = applyTransform(a, vec4(z,0,0)).xy;\n        }\n        else if((z.x >= comaBf1.x\n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) \n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fB1.xy, comABf1.xy, comaBf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n            || (z.x < comaBf1.x && z.y < comaBf1.y))\n        {\n            if(distance(z, lastb) < 0.00001)\n            {\n                // Orbit has become periodic.\n                break;\n            }\n            lastb = z;\n            scale /= clamp(jacobian(b, vec4(z,0,0)),-40.0,40.0);\n            z = applyTransform(b, vec4(z,0,0)).xy;\n        }\n        else if((z.x <= comabf1.x\n            && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fA1.xy, comABf1.xy, comAbf1.xy) \n            && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fB1.xy, comABf1.xy, comaBf1.xy) \n            && sdTriangle(z, fb1.xy, comabf1.xy, comAbf1.xy) < sdTriangle(-z, fb1.xy, comabf1.xy, comAbf1.xy))\n            || (z.x > comabf1.x && z.y < comabf1.y))\n        {\n            scale /= clamp(jacobian(B, vec4(z,0,0)),-40.0,40.0);\n            z = applyTransform(B, vec4(z,0,0)).xy;\n        }\n        else\n        {\n            // Just exploiting that \"Grandma's\" groups are defined in such a way that they all have 180 degree\n            // rotational symmetry, so we don't need to do anything about the upper Schottky region directly.\n            // Applying the A transformation would also work, but it's slower to calculate and introduces more\n            // distortion into the distance estimate.\n            z = -z;\n        }\n    }\n    \n    col *= min(1.0, (0.5/zoom)*iResolution.y*de);\n\n    fragColor = vec4(col, 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Mobius transformation (az+b)/(cz+d) with quaternion a, b, c, d\n// Quaternions are used only to allow the transformations to be applied to 3D points for a future version of \n// this algorithm. As such, most of the operations aren't guaranteed to work in general but should be correct \n// for complex valued transformations.\n// Thanks to https://www.shadertoy.com/view/MddfD7 for making me realize that this actually does \"just work\"\n// to apply mobius transformations to points in 3D space.\nstruct transform\n{\n    vec4 a;\n\tvec4 b;\n\tvec4 c;\n\tvec4 d;\n};\n\nvec4 qconj(in vec4 q)\n{\n    return vec4(q.x, -q.yzw);\n}\n\nvec4 qinv(in vec4 q)\n{\n \treturn qconj(q) / dot(q,q);\n}\n\nvec4 qmul(in vec4 p, in vec4 q)\n{\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\n\nvec4 qdiv(in vec4 p, in vec4 q)\n{\n    return qmul(p, qinv(q));\n}\n\nvec4 qmobius(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 z)\n{ \n    return qdiv(qmul(a,z) + b, qmul(c,z) + d);\n}\n\nvec2 cmul(in vec2 za, in vec2 zb)\n{\n    return za*mat2(zb.x, -zb.y, zb.yx);\n}\n\nvec2 cinv(in vec2 z) \n{\n    return z*vec2(1, -1)/dot(z,z);\n}\n\nvec2 cdiv(in vec2 za, in vec2 zb)\n{\n    return cmul(za, cinv(zb));\n}\n\nvec2 cexp(in vec2 z) \n{\n    return exp(z.x)*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(in vec2 z) \n{\n    return vec2(log(length(z)), atan(z.y,z.x));\n}\n\nvec2 cpow(in vec2 z, in float n)\n{\n    return cexp(n*clog(z));\n}\n\nvec2 csqrt(in vec2 z)\n{\n    return cpow(z, 0.5);\n}\n\nvec4 applyTransform(in transform t, in vec4 z)\n{\n    vec4 res = qmobius(t.a, t.b, t.c, t.d, z);\n    return res;\n}\n\ntransform composeTransform(in transform a, in transform b)\n{\n    transform res;\n    \n    res.a = qmul(b.a, a.a) + qmul(b.b, a.c);\n    res.b = qmul(b.a, a.b) + qmul(b.b, a.d);\n    res.c = qmul(b.c, a.a) + qmul(b.d, a.c);\n    res.d = qmul(b.d, a.d) + qmul(b.c, a.b);\n        \n    return res;\n}\n\ntransform invertTransform(in transform t)\n{\n    transform res;\n    \n    res.a = t.d;\n    res.b = -t.b;\n    res.c = -t.c;\n    res.d = t.a;\n    \n    return res;\n}\n\ntransform commutator(in transform a, in transform b)\n{\n    transform A = invertTransform(a);\n    transform B = invertTransform(b);\n    transform res = composeTransform(A, composeTransform(B, composeTransform(a, b)));\n    \n    return res;\n}\n\nvec4 discriminant(in transform t)\n{\n    return qmul(t.a+t.d, t.a+t.d)-qmul(vec4(4,0,0,0),qmul(t.a,t.d)-qmul(t.b,t.c));\n}\n\nvoid fixedPoints(in transform t, out vec4 f1, out vec4 f2)\n{\n    f1 = qdiv((t.a-t.d)+vec4(csqrt(discriminant(t).xy),0,0), qmul(vec4(2,0,0,0), t.c));\n    f2 = qdiv((t.a-t.d)-vec4(csqrt(discriminant(t).xy),0,0), qmul(vec4(2,0,0,0), t.c));\n}\n\nfloat jacobian(in transform t, in vec4 z)\n{\n    vec4 denom = qmul(t.c, z) + t.d;\n    return length(qdiv(qmul(t.a,t.d)-qmul(t.b,t.c), qmul(denom, denom)));\n}\n\n// https://www.shadertoy.com/view/XsXSz4\n// ...with some added clamping as an ad hoc correction for some sloppiness I've introduced\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.00001, 0.9999 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.00001, 0.9999 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.00001, 0.9999 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// From Indra's Pearls by David Mumford, Caroline Series, and David Wright p. 229\nvoid grandmaRecipe(in vec4 ta, in vec4 tb, out transform a, out transform b, out transform A, out transform B)\n{\n    vec4 tmp = qmul(qmul(tb, ta), vec4(0.5,0,0,0));\n    vec4 tab = tmp-qmul(vec4(0,1,0,0),vec4(csqrt(-(qmul(tmp,tmp)-qmul(ta,ta)-qmul(tb,tb)).xy),0,0));\n\n    vec4 z0 = qdiv(qmul(tab - vec4(2,0,0,0),tb), qmul(tb,tab) - qmul(vec4(2,0,0,0),ta) + qmul(vec4(0,2,0,0), tab));\n    a.a = qmul(ta, vec4(0.5,0,0,0));\n    a.b = qdiv(qmul(ta, tab) - qmul(tb, vec4(2,0,0,0)) + vec4(0,4,0,0), qmul(qmul(tab, vec4(2,0,0,0)) + vec4(4,0,0,0), z0 ));\n    a.c = qdiv(qmul(qmul(ta, tab) - qmul(tb, vec4(2,0,0,0)) - vec4(0,4,0,0), z0), qmul(tab, vec4(2,0,0,0)) - vec4(4,0,0,0));\n    a.d = qmul(ta, vec4(0.5,0,0,0));\n\n    b.a = qmul(tb - vec4(0,2,0,0), vec4(0.5,0,0,0));\n    b.b = qmul(tb, vec4(0.5,0,0,0));\n    b.c = qmul(tb, vec4(0.5,0,0,0));\n    b.d = qmul(tb + vec4(0,2,0,0), vec4(0.5,0,0,0));\n    \n    B = invertTransform(b);\n    A = invertTransform(a);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}