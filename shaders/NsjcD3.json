{
    "Shader": {
        "info": {
            "date": "1644240175",
            "description": "Sin Seq",
            "flags": 8,
            "hasliked": 0,
            "id": "NsjcD3",
            "likes": 3,
            "name": "Sin Sequencer - Sound",
            "published": 3,
            "tags": [
                "sin",
                "audio",
                "sequencer",
                "sinewave"
            ],
            "usePreview": 0,
            "username": "gfy_9001",
            "viewed": 230
        },
        "renderpass": [
            {
                "code": "vec3 sinCol(int i, vec2 uv)\n{\n    return 0.5 + 0.5 * cos(float(i) + iTime + uv.xyx + vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepMax = bpm2ms(BPM);\n    float stepTime = mod(iTime, stepMax);\n        \n    stepCounter = int(mod(iTime / stepMax, float(SEQ_LENGTH)));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float xP = stepTime / (stepMax * float(SEQ_LENGTH));\n    float x = float(stepCounter) / float(SEQ_LENGTH);\n    \n    if (uv.x <= x + xP)\n        fragColor = vec4(sinCol(stepCounter, uv + vec2(stepTime)), 1.0);\n    else\n        fragColor = vec4(sinCol(stepCounter, -uv * vec2(stepTime)) * vec3(0.1),1.0);\n        \n    if (uv.x <= x)\n        fragColor *= vec4(vec3(0.5), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// https://en.wikipedia.org/wiki/Piano_key_frequencies\n// f(n) = 2^((n - 49) / 12) * 440.\nfloat KeyToHz(float key)\n{\n    float k = (key - 49.) / 12.;\n    return pow(2., k) * 440.;\n}\n\n#define KEY_0_A KeyToHz(49.)\n#define KEY_0_C KeyToHz(52.)\n#define KEY_0_D KeyToHz(54.)\n#define KEY_0_E KeyToHz(56.)\n\n// Toggle me between [0, 1]\n#define USE_FM 0\n#define USE_LFO 0\n\nfloat Amp(float a)\n{\n    return a * 0.1;\n}\n\nfloat SquareWave(float a, float f, float p, float t)\n{\n    return Amp(a) * sign(sin(T_PI * f * t + p));\n}\n\nfloat SinWave(float f, float a, float t)\n{\n    return Amp(a) * sin(T_PI * f * t);\n}\n\nfloat SawWave(float p, float a, float t)\n{\n    float period_t = t/p;\n    return Amp(a) * (2.0 * (period_t - floor(0.5 + period_t)));\n}\n\nfloat FMSin(float time)\n{\n    // modulating frequency\n    float mf = 1. / 40.;\n    return SinMod(time, mf, 0., 1.);\n}\n\nfloat LFO(float time)\n{\n    // modulating frequency\n    float mf = 1. / 8.2;\n    return SinMod(time, mf, 0., 1.);\n}\n\nfloat AmpEnvelope(float s, float curve_amount, float t)\n{\n    return s * exp(curve_amount * t);\n}\n\n//\n// 1x8 Sequencer\n//\n// The key of each tone is placed in 'seq'\n//\n// Each step lasts 1/4 bar for a given BPM before moving to the next step\n//\n// The tone is generated from 'SinWave' function. You can also generate a more interesting tone by changing USE_FM 0 to USE_FM 1\n//\n// The tone for a given step is put through the 'AmpEnvelope' which reduces the amplitude over a short duration (attuenuating the signal)\n//\n\nvec2 mainSound( int samp, float time )\n{\n    float seq[SEQ_LENGTH] = float[SEQ_LENGTH] (KEY_0_A, KEY_0_C, KEY_0_D, KEY_0_E, KEY_0_A, KEY_0_A, KEY_0_C, KEY_0_A);\n\n    float stepMax = bpm2ms(BPM);\n    float stepTime = mod(time, stepMax);    \n    \n    stepCounter = int(mod(time / stepMax, float(SEQ_LENGTH)));\n    \n    float f = seq[stepCounter];\n    float a = 1.5;\n    float envelope_curve = -8.;\n    \n    // set USE_FM to 0 or 1 above\n#if USE_FM\n    f *= 0.5; // lower octave\n    envelope_curve = -12.; // sharper curve\n    float m = FMSin(stepTime);\n    f = m*m - (f *.8); // some funky shit\n    a += 4.; // VERY VERY WAY MORE STRONGER... volume\n#if USE_LFO\n    f = (m*m)*0.5; // changing sound, more wub\n#endif    \n#endif\n    \n    float s = SinWave(f, a, stepTime);\n    \n    // set USE_LFO to 0 or 1 above\n#if USE_LFO\n    s *= LFO(stepTime);\n    envelope_curve = -3.;\n#endif\n    \n    float e = AmpEnvelope(s, envelope_curve, stepTime);\n    \n    return vec2(e);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define BPM 700.\n#define SEQ_LENGTH 8\n\n#define EPSILON 0.00001\n#define PI 3.1415926536\n#define T_PI 6.2831853072\n\nint stepCounter = 0;\n\nfloat bpm2ms(float bpm)\n{\n    float min_in_ms = 60000.0;\n    float beat_ms = (min_in_ms / bpm) / 1000.0;\n    return beat_ms;\n}\n\nfloat SinMod(float x, float b, float c, float d)\n{\n    float p = T_PI / b;\n    return sin(p * (x + c)) + d;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}