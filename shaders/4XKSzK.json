{
    "Shader": {
        "info": {
            "date": "1720191328",
            "description": "Population simulation",
            "flags": 48,
            "hasliked": 0,
            "id": "4XKSzK",
            "likes": 4,
            "name": "MinnowTunaShark",
            "published": 3,
            "tags": [
                "animalbehavior"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 133
        },
        "renderpass": [
            {
                "code": "/*\nBlue colored Minnows\nGreen colored Tuna eat Minnows\nRed colored Sharks eat Tuna\n\n(Q,W) #frames before Minnow spawns\n(A,S) Tuna spawns\n(Z,X) Shark spawns\n\n(D,F) #frames before Tuna starves\n(C,V) Shark starves\n\n<Space>  reset populations\n<Return> add additional populations\n*/\n\n// ----------------------------------------------------------\n// cell contents\n// x:  movement code.  EMPTY = unassigned, or 1..8 specifes neighboring cell desired to move to\n// y:  spawn count   0...spawnMax\n// z:  starve count  0...starveMax\n// w:  EMPTY, or animal code\n\nvoid drawGrid(inout vec4 fragColor,in vec2 fragCoord) {\n    // screen coord -> grid\n    fragCoord /= iResolution.xy;  // 0 ... 1\n    ivec2 addr = ivec2(int(float(GRIDX) * fragCoord.x),int(float(GRIDY) * fragCoord.y));\n         \n    fragColor = vec4(0.,0.,0.,1.);\n    \n    vec4 v = fetchData(iChannel0, addr); \n    if(v.w > 0.) {\n        fragColor.xyz = vec3(0.,0.,1.); // blue minnow\n        if(v.w == float(TUNA)) fragColor.xyz = vec3(0.,1.,0.);\n        if(v.w == float(SHARK)) fragColor.xyz = vec3(1.,0.,0.);\n\n    }\n}\n\n// ---------------------------------------------------\n\nvoid displaySettings(inout vec4 fragColor, in vec2 fragCoord,int offset) {\n    if(fragCoord.x > iResolution.x * 0.5) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.75) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(36,36);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.8,0.9) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n    \n    if(offset == 1) {\n     t.color.xyz = vec3(0.);\n     t.fragCoord += vec2(-2.,3.);\n    }\n    \n    String str;\n    setString(str,14,(cSp,cSp,cSp,cSp,cSp,cSp,cSp,cSp,cSp,cPlus,cSp,cSp,cSp,cMinus));\n    printString(str,t);\n    newlineCursor(t);\n    \n    setString(str,7,(cM,ci,cn,cn,co,cw,cSp));\n    printString(str,t);\n    printInt(int(minnowSpawn),t);\n    newlineCursor(t);\n\n    setString(str,7,(cT,cu,cn,ca,cSp,cSp,cSp));\n    printString(str,t);\n    printInt(int(tunaSpawn),t);\n    setString(str,1,(cSp));\n    printString(str,t);\n    printInt(int(tunaStarve),t);\n    newlineCursor(t);\n    \n    setString(str,7,(cS,ch,ca,cr,ck,cSp,cSp));\n    printString(str,t);\n    printInt(int(sharkSpawn),t);\n    setString(str,1,(cSp));\n    printString(str,t);\n    printInt(int(sharkStarve),t);\n     \n    drawText(t, iChannel2, fragColor);\n}\n\n// ---------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    getSettings(iChannel0);\n\n    drawGrid(fragColor,fragCoord);\n    displaySettings(fragColor,fragCoord,1);\n    displaySettings(fragColor,fragCoord,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid saveSettings(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor.xyz = settings[i];\n            return;\n        }\n}\n\nvoid bumpPopulations(inout vec4 fragColor,vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    if(coord.x < GRIDX && coord.y < GRIDY) {\n        if(rndStart(vec2(coord),float(iFrame) * 0.02) < 0.003) {\n            fragColor = NEWBORNCELL;\n            int x = int(fragCoord.x);\n            fragColor.w = float(MINNOW);\n            if((x & 3) == 0) fragColor.w = float(TUNA);\n            if((x & 5) == 0) fragColor.w = float(SHARK);\n        }\n    }\n}\n    \nvoid resetPopulations(inout vec4 fragColor,vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    if(coord.x < GRIDX && coord.y < GRIDY) \n        fragColor = EMPTYCELL;\n\n    bumpPopulations(fragColor, fragCoord);\n}\n\nvoid initializeSettings(inout vec4 fragColor,vec2 fragCoord) {\n    resetPopulations(fragColor,fragCoord);\n    \n    minnowSpawn = 6.;\n    tunaSpawn =  3.;\n    tunaStarve = 48.;\n    sharkSpawn = 89.;\n    sharkStarve = 31.;\n    \n    saveSettings(fragColor,fragCoord);\n}\n\n// ----------------------------------------------------------\n\nconst ivec2[] neighborOffsets = ivec2[](\n    ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),\n    ivec2(-1,0),ivec2(1,0),\n    ivec2(-1,1),ivec2(0,1),ivec2(1,1));   \n\n\nivec2 neighborCoord(ivec2 base, int offsetIndex) {\n    ivec2 ans = base + neighborOffsets[offsetIndex];\n    if(ans.x < 0) ans.x = GRIDX-1; else if(ans.x >= GRIDX) ans.x = 0;\n    if(ans.y < 0) ans.y = GRIDY-1; else if(ans.y >= GRIDY) ans.y = 0;\n   \n    return ans;\n}\n\n// ----------------------------------------------------------\n// Given the coordinate of an empty cell: \n// Does any living neighbor already lay claim to it?\n// * direction codes stored base 1 (1...8)\n// * if a neighbor uses direction code X to reach it, then it would use 8-X to reach him\n\nbool isCellClaimed(ivec2 coord) {\n    for(int i=0;i<8;++i) {\n        vec4 neighbor = fetchData(iChannel0,neighborCoord(coord,i));\n        if(isAlive(neighbor) && neighbor.x == float(8-i)) return true;\n    }\n\n    return false;\n}\n\n/* ----------------------------------------------------------\nscan neighbors for living neighbor whose direction code points at our position (they want to move here)\nA. copy cell contents to us\nB. set direction code to negative as a marker to the old position or erase himself next frame\nC. if spawn count is high enough: set spawnCount to 0. (a spawn was just performed in the old position)\n------------------------------------------------------------- */\n\nvoid updateEmptyCell(inout vec4 color,ivec2 coord) {\n    for(int i=0;i<8;++i) {\n        vec4 neighbor = fetchData(iChannel0,neighborCoord(coord,i));\n\n        if(isAlive(neighbor) && neighbor.x == float(8-i)) {\n            color = neighbor;  \n            color.x = -color.x;\n            \n            if(isMinnow(color) && color.y >= minnowSpawn) color.y = 0.;\n            if(isTuna(color)   && color.y >= tunaSpawn)   color.y = 0.;\n            if(isShark(color)  && color.y >= sharkSpawn)  color.y = 0.;\n            return;\n        }\n    }\n}\n\n/* ----------------------------------------------------------\nif x == EMPTY (have not selected an empty neighbor to move to)\n    look for empty neighboring cell.\n    once found:\n        ensure no neighbors of that cell have already laid claim to it\n        if no others set x = direction code to that cell (first claiment)\n        \nelse (x != EMPTY, have already specified desire to move to empty neighbor)\n    look again at selected neighbor\n    if they are not empty and their direction code is (ours * -1) (they have made the move for us)\n       if our spawn count is high enough: \n           leave old position alive (it becomes a newly spawned cell).\n       else set cell to empty (y = EMPTY)\n------------------------------------------------------------- */\n\nvoid updateLivingCell(inout vec4 color,ivec2 coord) {\n    // dir code was set to negative as a marker to the old position.\n    // that marker has served it's purpose.\n    // reset it to begin a new movement session.\n    if(color.x < 0.) color.x = float(EMPTY);\n\n    // ---------------------------------\n    incrementSpawnCount(color);\n\n    if(isTuna(color)) {\n        incrementStarveCount(color);\n        if(color.z >= tunaStarve) {\n            color = EMPTYCELL;\n            return;\n        }\n    }\n    \n    if(isShark(color)) {\n        incrementStarveCount(color);\n        if(color.z >= sharkStarve) {\n            color = EMPTYCELL;\n            return;\n        }\n    }\n    \n    // ---------------------------------\n    // minnow checking whether tuna wants to eat us\n    if(isMinnow(color)) {\n        for(int i=0;i<8;++i) {\n            vec4 neighbor = fetchData(iChannel0,neighborCoord(coord,i));\n\n            if(isTuna(neighbor) && neighbor.x == float(8-i)) {\n                color = neighbor;     // move that cell to here\n                color.x = -color.x;   // set marker: movement has been made\n                resetStarveCount(color);  \n                return;\n            }\n        }\n    }\n    \n    // ---------------------------------\n    // tuna checking whether shark wants to eat us\n    if(isTuna(color)) {\n        for(int i=0;i<8;++i) {\n            vec4 neighbor = fetchData(iChannel0,neighborCoord(coord,i));\n\n            if(isShark(neighbor) && neighbor.x == float(8-i)) {\n                color = neighbor; \n                color.x = -color.x;\n                resetStarveCount(color);  \n                return;\n            }\n        }\n    }\n\n    // ---------------------------------\n    // no destination assigned. scan neighbors for unclaimed destination.\n\n    if(!hasDirectionCode(color)) {\n        int index = int(rndStart(vec2(coord),iTime) * 15.0);\n        \n        for(int i=0;i<8;++i) {\n            index = (index+1) & 7;            \n            ivec2 neighborCoord = neighborCoord(coord,index);\n            vec4 neighbor = fetchData(iChannel0,neighborCoord);\n            if(isCellClaimed(neighborCoord)) continue;\n            \n            bool legalDestination = !isAlive(neighbor); // empty cells available to all\n            if(isTuna(color) && isMinnow(neighbor)) legalDestination = true;\n            if(isShark(color) && isTuna(neighbor)) legalDestination = true;\n            \n            if(legalDestination) {\n                color.x = float(index + 1); // save direction code (base 1)\n                return;\n            }\n        }\n        \n        return;\n    }\n    \n    // ---------------------------------\n    // during previous frame destination was assigned.\n    // now check whether movement was made.\n    \n    ivec2 neighborCoord = neighborCoord(coord,int(color.x)-1); // destination code (base 1)\n    vec4 neighbor = fetchData(iChannel0,neighborCoord);\n    \n    if(isAlive(neighbor) && neighbor.x == -color.x) { // marker set == move has been made\n        bool shouldSpawn = false;        \n        if(isMinnow(color) && color.y >= minnowSpawn) shouldSpawn = true;\n        if(isTuna(color)   && color.y >= tunaSpawn)   shouldSpawn = true;\n        if(isShark(color)  && color.y >= sharkSpawn)  shouldSpawn = true;\n\n        if(shouldSpawn)  // leave old dataset behind as a 'spawn'\n            resetSpawnCount(color);\n        else \n            color = EMPTYCELL;\n    }  \n    else\n      color.x = float(EMPTY); // movement was not made. reset search for a destination.\n}\n\n// ----------------------------------------------------------\n\nvoid updateGrid(inout vec4 fragColor,vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    if(coord.x >= GRIDX || coord.y >= GRIDY) return;\n    \n    fragColor = fetchData(iChannel0,coord);\n    \n    if(isAlive(fragColor))\n        updateLivingCell(fragColor,coord);\n    else\n        updateEmptyCell(fragColor,coord);\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(iFrame < 2) {\n        initializeSettings(fragColor, fragCoord);\n        return;\n    }\n\n    fragColor.xyz = fetchData(iChannel0, ivec2(fragCoord)).xyz;\n    getSettings(iChannel0);\n    updateGrid(fragColor,fragCoord);\n    \n    if((iFrame & 1) == 0) userInterface(iChannel3); // slow down auto repeat\n    if(getKeyClick(32,iChannel3)) resetPopulations(fragColor, fragCoord); // Spc\n    if(getKeyClick(13,iChannel3)) bumpPopulations(fragColor, fragCoord);  // Return\n\n    saveSettings(fragColor,fragCoord); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRIDX 150\n#define GRIDY 100\n// grid stored 0,0 ... GRIDX-1,GRIDY-1\n\nconst ivec2 P0_ADDR =  ivec2( 0,GRIDY+1);\nconst ivec2 P1_ADDR =  ivec2( 1,GRIDY+1);\nconst int ADDR_COUNT = 2;\nconst ivec2[ADDR_COUNT] addrList = ivec2[](P0_ADDR,P1_ADDR);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvec3[ADDR_COUNT] settings;\n\n#define minnowSpawn      settings[0].x\n#define tunaSpawn        settings[0].y\n#define sharkSpawn       settings[0].z\n#define tunaStarve       settings[1].x\n#define sharkStarve      settings[1].y\n\n// ------------------------------------------------\n\n#define EMPTY  0.\n#define MINNOW 1.\n#define TUNA   2.\n#define SHARK  3.\n\n#define isAlive(cell)  (cell.w > 0.)\n#define isMinnow(cell) (cell.w == MINNOW)\n#define isTuna(cell)   (cell.w == TUNA)\n#define isShark(cell)  (cell.w == SHARK)\n\n#define resetSpawnCount(cell) cell.y = 0.\n#define incrementSpawnCount(cell) cell.y += 1.\n#define resetStarveCount(cell) cell.z = 0.\n#define incrementStarveCount(cell) cell.z += 1.\n#define hasDirectionCode(cell) (cell.x != float(EMPTY))\n\n#define EMPTYCELL   vec4(EMPTY,EMPTY,0.,0.)\n#define NEWBORNCELL vec4(EMPTY,0.,0.,MINNOW)\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i)\n        settings[i] = fetchData(channel, addrList[i]).xyz;\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\treturn (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid userInterface(sampler2D channel) {    \n    if(getKeyState(81,channel)) minnowSpawn = clamp(minnowSpawn - 1.,1.,150.); // Q\n    if(getKeyState(87,channel)) minnowSpawn = clamp(minnowSpawn + 1.,1.,150.); // W\n    if(getKeyState(65,channel)) tunaSpawn = clamp(tunaSpawn - 1.,1.,150.);     // A\n    if(getKeyState(83,channel)) tunaSpawn = clamp(tunaSpawn + 1.,1.,150.);     // S\n    if(getKeyState(90,channel)) sharkSpawn = clamp(sharkSpawn - 1.,1.,150.);   // Z\n    if(getKeyState(88,channel)) sharkSpawn = clamp(sharkSpawn + 1.,1.,150.);   // X\n    if(getKeyState(68,channel)) tunaStarve = clamp(tunaStarve - 1.,1.,150.);   // D\n    if(getKeyState(70,channel)) tunaStarve = clamp(tunaStarve + 1.,1.,150.);   // F\n    if(getKeyState(67,channel)) sharkStarve = clamp(sharkStarve - 1.,1.,150.); // C\n    if(getKeyState(86,channel)) sharkStarve = clamp(sharkStarve + 1.,1.,150.); // V\n}\n\n// ========================================================================\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat previousRnd = 0.;\n\nfloat rnd(vec2 c) { return fract(sin(dot(vec2(1.317,19.753),c))*413.7972); } // 0...1\n\nfloat rndStart(vec2 coord, float t) {  // 0...1\n\tpreviousRnd += rnd(coord.xy + vec2(t * 217.0));\n    return previousRnd;\n}\n\n// ========================================================================\n// https://www.shadertoy.com/view/mdsSD7\n\nconst int maxStringLength = 16;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12),\n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12)\n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11),\n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11),\n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11),\n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10),\n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10)\n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9),\n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9),\n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9),\n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8),\n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8)\n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    int count;\n    ivec2[maxStringLength] chars;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    if(val < 100) printChar(cSp,t);\n    if(val < 10) printChar(cSp,t);\n    \n    for(;;)  {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    if(texture(fontTexture, t.outUV).r > 0.2)\n        fragColor = t.outColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}