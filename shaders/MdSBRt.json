{
    "Shader": {
        "info": {
            "date": "1501641616",
            "description": "Planar version of Planetary Noise (?) described by Paul Bourke: http://paulbourke.net/fractals/noise/\n\nLeft Side: Clamped noise values.\nRight Side: Colorized noise values.\n\nUse mouse to slide divider.",
            "flags": 32,
            "hasliked": 0,
            "id": "MdSBRt",
            "likes": 2,
            "name": "Planar Planetary Noise",
            "published": 3,
            "tags": [
                "2d",
                "noise"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 710
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Implementation of a noise algorithm discussed at:\n *\n *     Modelling Fake Planets\n *     http://paulbourke.net/fractals/noise/\n *\n * Buffer A: Generates the noise heightmap \n * Buffer B: Renders the noise heightmap.\n *\n * The noise is not practical, at least for ShaderToy usage, but wanted to see\n * it in motion. The algorithm is extremely simple and follows the steps below:\n *\n *     (1) Generate a random point A on the buffer\n *     (2) Generate a random point B on the buffer\n *     (3) These two points create a cut line across the buffer\n *     (4) Add a random offset to all points on one side of the line.\n *         Subtract an equal offset from all points on the other side of the line.\n *     (5) Repeat.\n *\n * It can be easily expanded to 3D objects (primarily spheres to simulate planet surfaces).\n * This implementation also applies a modifer which decreases the size of the offset\n * over time in order to stabilize the heightmap.\n */\n\n#define MIX(a, b, r) mix(r, color, step(a, b))\n\nvec3 Color(float h)\n{\n    // The noise isn't normalized so the values tend to clump up around 0.5\n    vec3 color = vec3(0.10980, 0.31764, 0.79215);\n    \n    color = MIX(h, 0.375, vec3(0.29803,  0.61568, 0.92156));\n    color = MIX(h, 0.45,  vec3(0.992157, 1.0,     0.541176));\n    color = MIX(h, 0.46,  vec3(0.37647,  0.90980, 0.34509));\n    color = MIX(h, 0.5,   vec3(0.37647,  0.78431, 0.34509));\n    color = MIX(h, 0.65,  vec3(1.0,      1.0,     1.0));\n    \n    return color;\n}\n\n// Source (3Dfx): https://www.shadertoy.com/view/4dGXW1\nvec4 SampleAA(in vec2 uv)\n{\n    vec2 s = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 o = vec2(0.11218413712, 0.33528304367) * s;\n    \n    return (texture(iChannel0, uv + vec2(-o.x,  o.y)) +\n            texture(iChannel0, uv + vec2( o.y,  o.x)) +\n            texture(iChannel0, uv + vec2( o.x, -o.y)) +\n            texture(iChannel0, uv + vec2(-o.y, -o.x))) * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 mouse = iMouse;\n    \n    if(ivec2(mouse.xy) == ivec2(0))\n    {\n        mouse.xy = iResolution.xy * 0.25;\n    }\n    \n    if(abs(fragCoord.x - mouse.x) < 1.0)\n    {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    if(fragCoord.x < mouse.x)\n    {\n        // Raw noise display\n        fragColor = vec4(vec3(texelFetch(iChannel0, ivec2(fragCoord), 0).r), 1.0);\n    }\n    else\n    {\n        // Colorized noise \n\t\tfragColor = vec4(Color(clamp(SampleAA(uv).r, 0.0, 1.0)), 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SeedA 203391.0\n#define SeedB 1558307.0\n#define SeedC 126047.0\n#define SeedD 1781041.0\n\n#define StablizeTime 30.0\n\n// Dave_Hoskin's hash (of course) https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Returns -1.0, 0.0, 1.0 depending on which side of the line AB that P lies.\nfloat Side(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    return sign((ba.x * pa.y) - (ba.y * pa.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Starts the process slowly so viewers can see what is happening, but\n    // then speeds up so we actually get somewhere in a reasonable timeframe.\n    \n    vec2  uv    = fragCoord.xy / iResolution.xy;\n    float ftime = floor(iTime * clamp(floor(iTime * 4.0), 1.0, 60.0));\n    vec4  tx    = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor = vec4(0.5, ftime, iResolution.xy);\n    \n    // Reset buffer if first frame or resolution switch\n    if(uint(tx.g) == uint(0) || (ivec2(iResolution.xy) != ivec2(tx.ba)))\n    {\n        return;\n    }\n    \n    fragColor.r = tx.r;\n    \n    // If it is time to update this texel\n    if(uint(ftime) != uint(tx.g))\n    {\n        // Generate random points A and B\n    \tvec2 a = vec2(hash12(vec2(SeedA, ftime)), hash12(vec2(ftime, SeedB))) * iResolution.xy;\n    \tvec2 b = vec2(hash12(vec2(SeedC, ftime)), hash12(vec2(ftime, SeedD))) * iResolution.xy;\n        \n        // Reduce the maximum offset value over time to stablize the heightmap\n        float stabilizer = clamp(1.0 - clamp(iTime / StablizeTime, 0.0, 1.0), 0.1, 1.0);\n        \n        // Generate the offset value/strength\n    \tfloat offset = mix(0.005, 0.01, hash12(vec2(iTime))) * stabilizer;\n        \n        // Apply the offset\n    \tfragColor.r += Side(fragCoord, a, b) * offset;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}