{
    "Shader": {
        "info": {
            "date": "1493573797",
            "description": "B-spline, with  n is 8  and degree is 2; by ciao",
            "flags": 0,
            "hasliked": 0,
            "id": "lsScDG",
            "likes": 2,
            "name": "B-spline-N8D2-OpenedAverage",
            "published": 3,
            "tags": [
                "bspline"
            ],
            "usePreview": 0,
            "username": "CiaoLee",
            "viewed": 618
        },
        "renderpass": [
            {
                "code": "#define N 7\n#define D 2\n#define DIVIDE 101\nvec2 points[N+1];\nfloat basis[(D+1)*(N+D+1)];\nfloat uarray[N+D+1+1];\nvoid initialPoints(){\n    points[0] = vec2(-0.5,-0.5);\n    points[1] = vec2(-0.5,0.0);\n    points[2] = vec2(-0.5,0.5);\n    points[3] = vec2(0.0,0.5);\n    points[4] = vec2(0.8,0.8);\n    points[5] = vec2(0.5,0.0);\n    points[6] = vec2(0.5,-0.5);\n    points[7] = vec2(0.0,-0.5);\n}\nbool isBlackPoint(vec2 point){\n    vec2 distance;\n    for(int i=0;i<8;i++){\n        distance = point - points[i];\n        if(length(distance)<0.01){\n        \treturn true;\n        }\n    }\n    return false;\n}\n//this is opened and average Bspline so...\nvoid initUarray(){\n\n    for(int i=0;i<=N+D+1;i++){\n        if( i<=D){\n        \tuarray[i] = 0.0;\n        }else if(i<=N){\n        \tuarray[i] = float(i-D)/float(1+N-D);\n        }else{\n        \tuarray[i] = 1.0;\n        }\n    }\n}\nvec2 calBsplinePoint(int index){\n    float u = float(index)*0.01;\n    vec2 result =vec2(0,0);\n    for(int i=0;i<=N+D;i++){\n        if(uarray[i]<=u&&u<uarray[i+1]){\n        \tbasis[i] = 1.0;\n        }else{\n        \tbasis[i] = 0.0;\n        }\n    }\n    float c0,c1;\n    for(int j = 1;j<=D;j++){        \n        for(int i=0;i<=N+D-j;i++){\n\t\t\tif (uarray[i + j] - uarray[i] == 0.0)\n\t\t\t\tc0 = 0.0;\n\t\t\telse\n\t\t\t\tc0 = (u - uarray[i]) / (uarray[i + j] - uarray[i]);\n\t\t\tif (uarray[i + j + 1] - uarray[i + 1] == 0.0)\n\t\t\t\tc1 = 0.0;\n\t\t\telse\n\t\t\t\tc1 = (uarray[i + j + 1] - u) / (uarray[i + j + 1] - uarray[i + 1]);\n            basis[j*(N+D+1)+i] = c0*basis[(j-1)*(N+D+1)+i]\n                +c1*basis[(j-1)*(N+D+1)+i+1];\n        }\n    }\n    for(int i=0;i<=N;i++){\n    \tresult += basis[D*(N+D+1)+i]*points[i];\n    }\n    return result;\n}\nbool isInLine(vec2 point,int currentMaxIndex){\n\tvec2 resultpoint;\n    vec2 distances;\n    for(int i=0;i<currentMaxIndex;i++){\n    \tresultpoint = calBsplinePoint(i);\n        distances = point - resultpoint;\n        if(length(distances)<0.01){\n        \treturn true;\n        }\n    }\n    return false;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int currentMaxIndex  = int(iTime/0.1)%100;\n    initialPoints();\n    initUarray();\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 realpoint = (uv-0.5)*vec2(2.0*iResolution.x/iResolution.y,2.0);\n    if(isBlackPoint(realpoint)){\n    \tfragColor = vec4(0.0,0.0,1.0,1.0);\n    }else{\n    \tfragColor = vec4(1.0,1.0,1.0,1.0);\n    }\n    if(isInLine(realpoint,currentMaxIndex)){\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n\t//agColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}