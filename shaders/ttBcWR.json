{
    "Shader": {
        "info": {
            "date": "1594080138",
            "description": "EPIC OH MY GOSH I DID IT\nand a fractal yeet",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBcWR",
            "likes": 12,
            "name": "My Very First Working Fractal",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "raymarch",
                "mandelbulb",
                "sphere",
                "marcher",
                "epic",
                "yeet"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You keep the links to source I used (I don't want to get in trouble)\n// You keep the link to this on ShaderToy\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n// If you are absolutely not able to follow these terms, that is OK and I allow you I guess.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking!\n#define MAX_MARCHES 32\n#define MAX_DISTANCE 8.0\n#define COLLISION_DISTANCE 0.01\n#define bailout 4.0\n#define iterations 6\n\n// Constants\n#define pi 3.14159265\n\n// Mandelbulb Distance Estimator\n// Adapted from:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelbulb(vec3 pos){\n\tfloat power = float(8.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iterations; i++){\n\t\tr = length(z);\n\t\tif (r>bailout) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir){\n\tfloat distorigin;\n    float distsurface;\n    vec3 raypos = camerapos;\n    for(int i=0; i<MAX_MARCHES; i++){\n        distsurface = mandelbulb(raypos);\n    \traypos += raydir*distsurface;\n        distorigin = distance(camerapos, raypos);\n        if(distsurface<COLLISION_DISTANCE){break;}\n    }\n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos){\n\tfloat dis = mandelbulb(raypos);\n    vec2 e = vec2(0.01, 0.0);\n    vec3 normal = dis-vec3(mandelbulb(raypos-e.xyy),\n                           mandelbulb(raypos-e.yxy),\n                           mandelbulb(raypos-e.yyx));\n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march){\n\t// Light Positions\n    vec3 lightpositiona = vec3(0.0, 8.0, 0.0);\n\tvec3 lightpositionb = vec3(0.0, 0.0, 0.0);\n    vec3 lightpositionc = vec3(0.0,-8.0, 0.0);\n\t// Animate Lights\n    lightpositiona.xz += vec2(sin(iTime*pi), cos(iTime*pi))*4.0;\n    lightpositionb.xz += vec2(sin(iTime*pi), cos(iTime*pi))*4.0;\n    lightpositionc.xz += vec2(sin(iTime*pi), cos(iTime*pi))*4.0;\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(sin(iTime*pi), 0.0, -4.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n\t// Compute and Shade\n\tfloat mandelbulbdistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos+raydir*mandelbulbdistance;\n    vec3 diffuse = shade(march);\n\n    // Output to Screen\n    fragColor = vec4(pow(diffuse, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}