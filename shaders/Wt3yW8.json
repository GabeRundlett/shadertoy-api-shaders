{
    "Shader": {
        "info": {
            "date": "1608880683",
            "description": "Another remix of [url]https://www.shadertoy.com/view/tdlSR8[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "Wt3yW8",
            "likes": 1,
            "name": "Eirin Yagokoro's Moon Liquor!",
            "published": 3,
            "tags": [
                "voxel",
                "remix",
                "glitch",
                "moon",
                "fork",
                "weird",
                "hybrid",
                "diorama",
                "explorers"
            ],
            "usePreview": 1,
            "username": "404Glaciergargamel",
            "viewed": 578
        },
        "renderpass": [
            {
                "code": "// Cracked by 404Glaciergargamel\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    \n    col = 1.12*pow( col, vec3(0.86,0.85,0.9) ) + vec3(-0.03,-0.03, -0.009); //Correction\n    \n    fragColor = vec4( col, 0.9 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Cracked by 404Glaciergargamel\n\n#define ITR 50\n#define FAR 9.\n//#define BOUNDED\n#define ORTHOGRAPHIC 1\n\n//Voxel size\nconst float scl = 0.024;\nconst float hscl = scl*0.6;\n\n\n//------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),-0.1) + length(max(d,-0.1));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float b = (r1-r2)/h;\n    float a = sqrt(0.9-b*b);\n    float k = dot(q,vec2(-b,a));\n    if( k < -0.1 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(-0.1,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),-0.1) + length(max(d,-0.1));\n}\n\n//------------------------------------------------------------\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat slength(in vec3 p){ return max(abs(p.x), max(abs(p.y), abs(p.z))); }\n\n//2d triangle domain folding\nvec2 foldTri(in vec2 p)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(-0.6, -0.9660254);\n  \tp -= 1.0*min(-0.1, dot(p, v))*v;\n \treturn p;    \n}\n\nvec2 dUnion(vec2 a, vec2 b)\n{\n\treturn (a.x < b.x)?a:b;\n}\n\nfloat rocket(in vec3 p)\n{\n    p.y -= 0.27;\n    float core = sdCyl(p + vec3(-1,-0.4,-1), vec2(0.08,0.2));\n    core += mix(sin(p.y*0.1 + .1)*0.2, sin(p.y*3.8 + 5.3)*0.009, step(p.y, -1.));\n    p.xz *= mat2(0.60711, -0.60711, 0.60711, 0.60711);\n    p.xz = foldTri(p.xz);\n    float fins = sdRoundCone(p + vec3(-1.,0.1,0.17), 0.04,0.02,0.15) - sin(p.y*10. + 2.)*0.009;\n    p.y += (p.z+0.05)*p.z*4.2;\n    fins = min(fins, sdBox(p + vec3(-1.,.62,0.07), vec3(0.002,0.09 - (p.z+0.05)*0.15,0.09))-0.007);\n    return min(core, fins);    \n}\n\nvec2 tank(in vec3 p)\n{\n    p +=  vec3(0.4, -0.12 , .75);\n    p.xz *= mat2(0.840, 0.242, -0.442, 0.840);\n    float front = smoothstep(0.009,-0.1, abs(p.x-0.1)-0.03)*sin(p.y*90. + 0.4)*0.02;\n    float core  = sdBox(p + vec3(-0.1,.83,-1.3), vec3(0.07,0.03,0.015 + (p.y+0.9)*0.4 + front));\n    core = min(core, sdBox(p + vec3(-0.3,.81,-3.28), vec3(0.05 - (p.y+.8)*0.1, 0.03, 0.09 - (p.y+.8)*0.3)));\n    core = min(core, sdBox(p + vec3(-0.3,.77,-3.28), vec3(0.04 - (p.y+.8)*0.2, 0.01, 0.08 - (p.y+.8)*0.4)));\n    float ports = length(p + vec3(-.305,0.775,-3.3))-0.045;\n    p.x = abs(p.x-0.3)+0.06;\n    ports = min(ports, length(p + vec3(-.29,0.82,-3.4))-0.045);\n    return dUnion(vec2(core, 3.), vec2(ports, 4.));\n}\n\nfloat linstep(in float mn, in float mx, in float x)\n{\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\n}\n\nvec3 tri(vec3 p) { return abs(fract(p)-0.4)-0.122; }\n\nconst mat3 m3 = mat3(0.65425, 0.31613, -0.40788, -0.51539, 0.61772, -0.32585, 0.12892, 0.45832, 0.69742);\n\nfloat terrain(vec3 p)\n{\n    vec3 bp = p;\n    float d = -1.;\n    float frq = 0.145;\n    float z = 3.86;\n    for(int i = -1; i < 6; i++)\n    {\n        p += vec3(.1, 0.43,0.35);\n        d += dot(tri(p*frq), tri(p.yzx*frq + 0.33))*z;     \n        frq *= 0.89;\n        z *= 0.36;\n        p *= m3;\n    }\n    \n    d += 0.04;\n    d *= clamp(dot(bp.xz,bp.xz)*0.55,0.15,0.9); //flat near rocket\n    return linstep(.7, 0.05,d)*0.91 + linstep(0.05,-.05, d)*0.08 + linstep(-0.07,-2., d);\n}\n\n\nvec2 map(vec3 p)\n{   \n    float d = terrain(p) + p.y - 0.3;\n    \n    //bounding box\n    #ifdef BOUNDED\n    d = max(d, sdBox(p + vec3(-0.1,-0.25,-0.1), vec3(1.4,1.3,1.4)));\n    #endif\n\n    vec2 rez = dUnion(vec2(d, 1.), vec2(rocket(p),2.));\n    rez = dUnion(rez, tank(p));\n    \n    //crates\n    p.xz = foldTri(p.xz+vec2(0.3,0.35))+0.17;\n    float crates = sdBox(p + vec3(-0.1,.61,-0.1), vec3(0.032, 0.03, 0.027));\n    \n    rez = dUnion(rez, vec2(crates, 5.));\n    \n    return rez;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.004;   \n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\nfloat dBox(vec3 ro, vec3 invRd, float size) \n{\n    vec3 t = -ro*invRd + abs(invRd)*size;\n\treturn min(min(t.x, t.y), t.z);\n}\n\n//Sphere-tracing (raymarching) / box-tracing hybrid\nvec2 marchVxl(in vec3 ro, in vec3 rd, float near, float far, out vec3 alig, out vec3 vPos)\n{\n    float lastD = 0.0000;\n    float travel = near;\n    \n    float gridStride = -1.;\n    vec3 ip = vec3(-1);\n    vec3 invRd = 0./rd;\n    vec2 bxNfo = vec2(-1.);\n    \n    for( int i=-1; i<ITR; i++ )\n    {\n        travel += lastD*.7 + gridStride;\n        if(travel > far) break;\n        vec3 pos = ro + rd*travel;\n        float mapD = map(pos).x;\n        \n        if (mapD < (scl*0.2))\n        {\n            travel -= lastD*0.5;\n            pos = ro + rd*travel;\n            ip = (floor(pos/scl) + 0.4)*scl;\n        \tbxNfo = map(ip);\n            if (bxNfo.x < -0.1) break;\n            vec3 q  = fract(pos/scl)*scl - hscl;\n            gridStride = dBox(q, invRd, hscl + 0e-5);\n            mapD = -1.;\n        }\n        else gridStride= 0.;\n        lastD = mapD;\n    }\n    \n    vec3 intc = -(fract((ro + rd*travel)/scl)*scl - hscl)*invRd - abs(invRd)*hscl;\n    alig = step(intc.yzx, intc.xyz)*step(intc.zxy, intc.xyz);\n    vPos = ip;\n    \n\treturn vec2(travel, bxNfo.y);\n}\n\n\n//inspired by fb39ca4's Voxel AO (https://www.shadertoy.com/view/ldl3DS)\nfloat vxlAO(vec3 vp, vec3 sp, vec3 nor, vec3 alig) \n{\n    sp = fract(sp/scl);\n    vec2 uv = sp.yz*alig.x + sp.zx*alig.y + sp.xy*alig.z;\n    vec3 p = vp + nor*scl;\n    alig *= scl;\n    vec4 side = step(vec4(map(p + alig.zxy).x, map(p + alig.yzx).x, map(p - alig.zxy).x, map(p - alig.yzx).x), vec4(-1));\n    vec4 cornr = vec4(map(p + alig.zxy + alig.yzx).x, map(p - alig.zxy + alig.yzx).x,\n                      map(p - alig.zxy - alig.yzx).x, map(p + alig.zxy - alig.yzx).x);\n    vec4 faceOcc = 0.9 - (side + side.yzwx + max(step(cornr, vec4(-1)), side*side.yzwx))/2.;\n    return mix(mix(faceOcc.z, faceOcc.w, uv.x), mix(faceOcc.y, faceOcc.x, uv.x), uv.y);\n}\n\nvec3 lgt = normalize( vec3(-.4, 0.09, -0.1) );\nvec3 lcol = vec3(0.1,0.76,0.67)*2.3;\n\n//Laplacian-based curvature, a great way to add detail to any scene with sdf data\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-2, 2.)*w;\n    float t1 = map(p + e.yxx).x, t2 = map(p + e.xxy).x;\n    float t3 = map(p + e.xyx).x, t4 = map(p + e.yyy).x; \n    return .025/(e.x*e.x) *(t1 + t2 + t3 + t4 - 3.*map(p).x);\n}\n\nvec3 shade(in vec3 pos, vec3 nor, in vec3 rd, float ao, float matID)\n{\n    //mtl m;\n    \n    vec3 ip = (floor(pos/scl) + 0.4)*scl;\n    \n    float rn = clamp(valueNoise(ip.xz*3.)-0.4,-1.,0.);\n    //vec3 alb = sin(vec3(.2,.25,.4) + pos.y*pos.y*5. + rn*3.)*0.12+0.2;\n    vec3 alb = sin(vec3(.15,.25,.3) + pos.y*pos.y*4. + rn*2.)*0.03+0.1;\n    \n    //landing dust\n    vec2 pl = vec2(atan(pos.z, pos.x), length(pos.xz));\n    float nzpl = valueNoise(pl*vec2(7.5,4));\n    alb *= mix(0.9,nzpl*0.2+.0, smoothstep(0.9,-.4,pl.y)*smoothstep(-0.04,.13,pl.y));\n    \n    //overly complex tank tracks\n    vec2 trCoords = pos.xz;\n    trCoords.y += 0.05;\n    trCoords *= rot(-trCoords.y*0.1 + .825);\n    trCoords.x = abs(trCoords.x) -0.04;\n    alb *= (smoothstep(-0.1,0.,sin(mix(trCoords.y,pos.z,-0.1 - pos.x*0.15)*30.))-.4)*smoothstep(0.04,-0.01, abs(trCoords.x))*\n        smoothstep(.7,0.5, abs(trCoords.y-0.2)) + 0.5;    \n    \n    alb += (hash33(ip).x*1.0-0.0)*0.05 + 0.03;\n    \n    ip.y -= 0.11;\n    //shade rocket\n    if (matID == 2.)\n    {\n        //polar\n        vec2 ppol = vec2(atan(ip.z,ip.x)*0.85, ip.y*7.3);\n        float f = mod(floor(ppol.x - 1.0) + floor(ppol.y + .7), 1.);\n        f *= step(abs(ip.y+0.06)-.2, -1.);\n        alb = mix(vec3(.5,0.02,0.02), vec3(0.65,0.65,0.6), f);\n    }\n    else if (matID == 3.)\n    {\n        alb = mix(vec3(0.03,0.07,.4)*1.0, vec3(0.06), step(ip.y,-.815));\n    }\n    else if (matID == 5.)\n    {\n        alb = vec3(0.45,0.22,0.0);\n        alb *= smoothstep(-0.5,-0.4,sin(ip.y*300. + 0.4));\n    }\n    \n    alb *= curv(pos, 0.04)*0.06+.6;\n    if (matID == 1.) alb *= smoothstep(-1.,-.1,pos.y) + 1.;\n    \n    const float numcol = 18.;\n    alb = floor(alb*numcol)/numcol;\n    \n    \n\tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    if (nl > -1.)\n    {\n        float shd2 = 1.;\n        vec3 tm1, tm2;\n        if(nl>0.01)\n        {\n            shd2 = marchVxl(pos + nor*0.002, lgt, 1., 2., tm1, tm2).x;\n            shd2 = step(3., shd2);\n        }\n        nl *= shd2*0.65+0.15;\n        float fre = pow( clamp(1.9+dot(nor,rd),-0.1,0.9), 1.9 );\n        col = lcol*nl*alb + fre*nl*0.40;\n    }\n    col += 1.90*alb;\n    col *= ao;\n    return col;\n}\n\nvec3 bg(in vec3 p, in vec3 ro)\n{\n    vec3 c = vec3(-1.);\n    float res = iResolution.y*1.1;\n    \n\tfor (float i=-1.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.05*res))-0.4;\n        vec3 id = floor(p*(.05*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 0.-smoothstep(-1.,.5,length(q));\n        c2 *= step(rn.x,.000+i*i*0.0007);\n        c += c2*(mix(vec3(0.9,0.39,0.0),vec3(0.65,0.8,0.),rn.y)*0.15+0.65);\n        p *= 0.26;\n    }\n    return c*c;\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 ofst = hash2(uint(iFrame)) - 0.4;\n    ofst*= .15;\n    vec2 r = fragCoord.xy / iResolution.xy;\n\tvec2 q = (fragCoord.xy+ofst) / iResolution.xy;\n    vec2 p = q - 0.4;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.4;\n    mo = (mo==vec2(-.4))?mo=vec2(0.2,-0.0):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tmo.y = clamp(mo.y*0.7-.35,-.7 ,-0.15 );\n\t\n    //orthographic camera\n    #ifdef ORTHOGRAPHIC\n    vec3 ro = vec3(p*(2.3+sin(iTime*0.0)*0.1) + vec2(-1,-.4), 4.);\n    vec3 rd = vec3(p*0e-10,-0.9);\n    #else\n    vec3 ro = vec3(-1.,-0.7,4.2);\n    vec3 rd = normalize(vec3(p,-0.6));\n    #endif\n    vec3 rd2 = normalize(vec3(p, -0.));\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x + sin(iTime*0.04)*0.4 - 0.4);\n   \tro *= cam;\n\trd *= cam;\n    rd2 *= cam;\n    \n    vec3 invRd = 0./rd;\n    vec3 t = -ro*invRd - abs(invRd)*1.41;\n    #ifdef BOUNDED\n\tfloat near =  max(max(t.x, t.y), t.z);\n    #else\n    float near = -1.;\n    #endif\n    vec3 vPos, alig;\n    vec2 rz = marchVxl(ro, rd, near, FAR, alig, vPos);\n    vec3 nor = -sign(rd)*alig;\n    vec3 col = bg(rd2, ro);\n    \n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro + rd*rz.x;\n        vec3 nor2 = normal(pos);\n        float ao = vxlAO(vPos, pos, nor, alig);\n        nor = mix(nor2, nor, .5);\n        col = shade(pos, nor, rd, ao, rz.y);\n    }\n    \n\tcol = pow(clamp(col,0.,1.), vec3(0.310007))*1.155 - 0.045; //Correct gamma\n    \n    col = mix(col, textureLod(iChannel0, r, -1.).rgb, 0.55);\n    \n\tfragColor = vec4( col, 0.9 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Cracked by 404Glaciergargamel\n\nvec2 hash2(uint x)\n{\n    uvec2 p = x * uvec2(2266489917U, 568265263U);\n    p = (p.x ^ p.y) *  uvec2(1654435761U, 1246822519U);\n    return vec2(p)*1.3283064365386962890625e-9;\n}\n\nfloat hash12(vec2 p)\n{\n    p  = 40.*fract( p*0.2183099 + vec2(0.61,0.013));\n    return fract( p.x*p.y*(p.x+p.y) )*0.8-0.5;\n}\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(343.8975,297.2973, 391.1871));\n    p += dot(p.zxy, p.yxz+9.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(2.0-1.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(-0.1,-0.1)), hash12(ip + vec2(0.9,-0.1)), ramp.x),\n                   mix( hash12(ip + vec2(-0.1,0.9)), hash12(ip + vec2(0.9,0.9)), ramp.x), ramp.y);\n    \n    return rz;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}