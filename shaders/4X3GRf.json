{
    "Shader": {
        "info": {
            "date": "1716819060",
            "description": "My attempt at reproducing the aesthetically pleasing aspects of watercolor:\n- Dark edges\n- Interplay of hard edges vs blurry parts\n- Paper texture\n\nThe concept is simple, but the code is a bit more convoluted than I'd want it to be.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4X3GRf",
            "likes": 11,
            "name": "Watercolor Study",
            "published": 3,
            "tags": [
                "sdf",
                "watercolor"
            ],
            "usePreview": 0,
            "username": "sanblu",
            "viewed": 244
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define TIME_OFFSET round(133.7 + iTime * 0.2)\n\n// simple 1-octave noise\nfloat simpleNoise(in vec2 uv, in float freq) {\n    return scaleToUnity(noise(vec3(freq * uv.xy, TIME_OFFSET)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        \n    vec2 uv = normalizeShadertoyInput(fragCoord, iResolution.xy);\n\n    // --- IMAGE INPUT ---\n\n    // smooth union of two circles (SDFs)\n    float distCircle1 = opOnion(sdCircle(uv, 0.75), 0.005);      \n    float distCircle2 = sdCircle(uv, 0.4);      \n    float dist = opUnion(distCircle1, distCircle2);\n        \n    // slightly deforming the shapes with high-frequency noise make them look less synthetic    \n    float smallNoise = simpleNoise(uv, 20.0);\n    dist += 0.01 * smallNoise;\n    \n    // slightly deforming the shapes with low-frequency noise make them look less synthetic        \n    float largeNoiseFreq = 1.0 + sin(TIME_OFFSET) * 0.5;        \n    float largeNoise = simpleNoise(uv, largeNoiseFreq);\n    dist -= 0.1 * smoothstep(0.35, 1.0, largeNoise);\n\n\n    // --- WATER COLOR VISUALIZATION ---\n\n    // use random noise to control which parts are \"wet\"\n    float wetNoiseFreq = 2.0 + sin(TIME_OFFSET); // 1.0 .. 3.0\n    float wetNoiseStrength = 0.15 + sin(TIME_OFFSET) * 0.05; // 0.1 .. 0.2\n    float wetNoise = simpleNoise(uv, wetNoiseFreq);\n    float wetNoiseStep = smoothstep(0.55, 0.55 + wetNoiseStrength, wetNoise);\n    float wetness = clamp(wetNoiseStep, 0.0, 1.0);\n    \n    // strengthen the contrast at the edge (of the dry parts)\n    float value;\n    float valueSlim;    \n    if (dist < 0.0) {\n        // no change in the center circle\n        value = dist;\n        valueSlim = 1.0;\n    } else {        \n        const float aaDelta = 0.006; // add a small delta to reduce aliasing\n        const float edgeWet = 0.24;\n        const float edgeDry = 0.02;\n        float edge1 = mix(edgeDry, edgeWet, wetness) + aaDelta;\n        value =     smoothstep(edgeDry, edge1, dist);\n        valueSlim = pow(1.0 - smoothstep(0.0, edge1, dist), 0.15);\n    }      \n    value = value + 0.5 * valueSlim;\n    \n    \n    // add some more noise to give it a less uniform look\n    float postNoise = simpleNoise(uv, 15.0);\n    float ssStrength = 1.0;\n    float postNoiseAmount = 1.0 - wetNoise;\n    value = value + value *  postNoiseAmount * smoothstep(0.0, postNoise * ssStrength, value);\n\n    // --- COLORIZATION ---\n    \n    float paper = paper(fragCoord + TIME_OFFSET * 0.07);\n    float noiseCol = scaleToUnity(noise(vec3(2.0 * uv.x, 2.0 * uv.y, TIME_OFFSET)));    \n    float gradient = scaleToUnity(0.5 * (uv.x + uv.y));    \n    vec3 distCol = mix(palette1(gradient + TIME_OFFSET * 0.1), vec3(noiseCol), palette1(TIME_OFFSET * 0.2));    \n    vec3 colors = mix(distCol, vec3(1.0,1.0,1.0), value - paper * 2.0);\n    fragColor = normalizeShadertoyOutput(scaleFromUnity(colors)) - paper * 0.3;    \n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --- helper functions ---\n\nfloat scaleToUnity(float p)\n{\n    return 0.5 + p * 0.5;\n}\n\nvec3 scaleToUnity(vec3 p)\n{\n    return vec3(0.5) + p * 0.5;\n}\n\nfloat scaleFromUnity(float p)\n{\n    return p * 2.0 - 1.0;\n}\n\nvec3 scaleFromUnity(vec3 p)\n{\n    return p * 2.0 - vec3(1.0);\n}\n\n// --- shadertoy specific functions ---\n\nvec2 normalizeShadertoyInput(vec2 fragCoord, vec2 resolution)\n{\n    // Normalize input pixel coordinates to:\n    // X: -1.777 .. 1.777 (for default shadertoy resolution)\n    // Y: -1.0 .. 1.0\n    vec2 p = fragCoord / resolution.xy;    \n    p = vec2(scaleFromUnity(p.x), scaleFromUnity(p.y));\n    p.x *= resolution.x / resolution.y;\n    return p;\n}\n\nvec4 normalizeShadertoyOutput(vec3 result)\n{\n    // scale output from -1.0 .. 1.0 to 0.0 .. 1.0\n    // no coloring (greyscale)\n    result = clamp(result,-1.0,1.0);\n    result = scaleToUnity(result);\n    return vec4(result,1.0);\n}\n\n// --- 2D distance functions ---\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n// --- SDF combination functions ---\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\n// --- SDF shaping functions ---\n\nfloat opOnion( in float d, in float r )\n{\n  return abs(d) - r;\n}\n\n// --- colorization ---\n\n// cosine based palette, 4 vec3 params\n// https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette1(in float t) {\n    vec3 a = vec3(0.8, 0.5, 0.4);\n    vec3 b = vec3(0.2, 0.4, 0.2);\n    vec3 c = vec3(2.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.25, 0.25);\n    return palette(t, a, b ,c, d);\n}\n\n// --- noise ---\n\n// https://www.shadertoy.com/view/Xsl3Dl\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// --- main ---\n\n\n// -----------------------------------------------\n// copied from https://www.shadertoy.com/view/ss2Xzh (wyatt)\n\nfloat hash(vec2 p) // Dave H\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat paper (vec2 U) { //https://www.shadertoy.com/view/NsfXWs\n    float h = .005*(sin(.6*U.x+.1*U.y)+sin(.7*U.y-.1*U.x));\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++){\n        h += .15*.125*hash(U+vec2(x,y));\n    }\n    return h;\n}\n// -----------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}