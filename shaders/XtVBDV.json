{
    "Shader": {
        "info": {
            "date": "1544118337",
            "description": "smoothstep() on the left, smootherstep() on the right.\ngamma(2.2) top, 1.0 bottom.\n\nfork of \"Simple Smooth Line\" by dilip019. https://www.shadertoy.com/view/XlVfWV\ncomparing smoothstep() to smootherstep() from v_coda: https://www.shadertoy.com/view/MlyBWK",
            "flags": 0,
            "hasliked": 0,
            "id": "XtVBDV",
            "likes": 4,
            "name": "Are smoother() lines better() ?",
            "published": 3,
            "tags": [
                "smoothstep",
                "smootherstep"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 760
        },
        "renderpass": [
            {
                "code": "// smoothstep() on the left, smootherstep() on the right.\n// fork of \"Simple Smooth Line\" by dilip019. https://www.shadertoy.com/view/XlVfWV\n// comparing smoothstep() to smootherstep() from v_coda: https://www.shadertoy.com/view/MlyBWK\n\n#define Pi 3.14159\n#define smooth true\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// Ken Perlin suggests an improved version of the smoothstep() function, \n// which has zero 1st- and 2nd-order derivatives at x = 0 and x = 1.\nfloat smootherstep(float edge0, float edge1, float x) \n{\n  x = clamp((x - edge0)/(edge1 - edge0), 0., 1.);\n  return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat smoothit(float a, float b, float c, bool useSmoother) {\n    if (useSmoother) {\n        return smootherstep(a, b, c);\n    }\n    else {\n        return smoothstep(a, b, c);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.yy;\n\tvec2 uv2= fragCoord.xy / iResolution.xy;\n    uv2.x *= iResolution.x/iResolution.y; \n  //  vec2 center = \n    vec2 q = p;\n\t\n \tfloat var = 0.9 +0.45* cos(0.5*iTime);\n \tfloat var2 = 0.5+ 0.45*sin(0.5*iTime);\n    // background\t\n\tvec3 col = vec3(0.5,0.85,0.9);\n\t\n    \n\tvec2 pA = vec2(0.9,0.50); \t\n    vec2 pB = vec2( var, var2 );\t\n    \n    for (int n = 0; n < 2; ++n) {\n        // compute distance to a set of lines\n        float d   = 0.3;\t \n        \n        vec2 uv = uv2;\n        uv.x += (n == 0 ? 0.3 : -0.3);\n      \n        float h = line( pA, pB, uv );\n        d = min( d, h );\n\n        if( smooth )\n        {\n            const float minW = 0.001;\n            const float maxW = 0.05;\n            float w = mix(minW, maxW, sin(iTime * 0.2) * 0.5 + 0.5);\n            col = mix( vec3(0.0,0.0,0.0), col, smoothit(-w,w,d-0.04,n == 1) ); // black\n            col = mix( vec3(1.0,0.6,0.0), col, smoothit(-w,w,d-0.02,n == 1) ); // orange\n\n        }\n        else\n        {\n            if( d<0.04) col = vec3(0.0,0.0,0.0); // black \n            if( d<0.02 ) col = vec3(1.0,0.6,0.0); // orange\n        }\n    }\n    \n    if (p.y > sin(iTime * 0.8) * 0.2) {\n        col = pow(col, vec3(1.0/2.2));\n    }\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}