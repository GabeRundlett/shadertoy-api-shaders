{
    "Shader": {
        "info": {
            "date": "1595423473",
            "description": "Precalculating 2D distance field values and height field values then storing them in the faces of the cube map in order to produce an extruded Cairo based pentagonal tiling arrangement in realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t2cDK",
            "likes": 54,
            "name": "Extruded Pentagon Tiling",
            "published": 3,
            "tags": [
                "grid",
                "tiling",
                "pentagon",
                "extrude",
                "cairo"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1277
        },
        "renderpass": [
            {
                "code": "/*\n\n\n    Extruded Pentagon Tiling\n    ------------------------\n\n\n\tMost people know that a regular pentagon alone can't tile the Euclidean\n    plane, but there are plenty of irregular ones that can. This is part of\n\ta Cairo tiling setup, which is pretty simple to put together in 2D form.\n\tThe extruded version is doable also, as you can see here, but with eight \n\tpentagon renderings, it can get slow... You might be able to get away \n\twith fewer taps, but it's still a slow process. Either way, it can be\n\tovercome by encoding some of the heavier calculations into buffers, like\n    the pentagon distance fields and height map values. This can reduce the\n\traymarching function down to a bit of setup and some texture reads, which\n\tmost GPUs can do pretty efficiently these days.\n\n\tAnyway, this is more of a proof of concept than anything else. There are \n    probably better ways to get the job done, like encoding heights into all \n    four channels to reduce the number of texture reads but this seems to be\n    working well enough... providing your computer is happy reading from the \n    cube map faces, which mine is. In fact, my laptop can run this in \n    fullscreen, but it's probably better when run in window form.\n\n    There's a couple of defines to play with. There's a SHIM_VALUE define in\n\tthe common tab that will display different arrangements and a\n    QUANTIZE_HEIGHT option that forces the height to display 16 discreet\n    values, which can look neater. However, since things are precalculated,\n    it's necessary to reset each time. There are also PENTAGON_MAP_2D and \n    WIREFRAME defines in the \"Common\" tab to try as well. In fact, I almost\n\twent with the wireframe look with quantized heights by default, but \n    untimately decided less is more, and all that. :)\n\n    \n\n\tCairo and pentagonal tiling:\n    \n    \n    // Nimitz was doing this stuff way before it was cool. :D\n    // Quite an old shader, this one, and nicely done, as always. \n    Cairo tiling - nimitz\n\thttps://www.shadertoy.com/view/4ssSWf\n\n\t// 2D Cairo tiling. Very nice.\n    Pentagonal Tessellations - MLA\n\thttps://www.shadertoy.com/view/XlBBWG\n\n    // Fabrice's version.\n    pentagonal tiling - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltBBzK\n\n    // I love this both aesthetically, and for the mathematical\n    // story behind it.\n\t15th Pentagonal Tiling - tomkh\n\thttps://www.shadertoy.com/view/4lBXRV\n\n    // Not the easiest of tilings to pull off, and Rory's done it in\n    // two tweets. I'd like to see the expanded version.\n\t[SH17A] Pentagons - rory618\n\thttps://www.shadertoy.com/view/4sjfRm\n\n\n*/\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Hacky global to stored the height of the closest pylon.\nfloat gh;\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n    // Pulling in the 8 precalculated pentagon values from their respective\n    // cube map faces. Four from the first face, and four from the last.\n    // Those two faces were chosen because calculations are a little quicker.\n    //\n    // By the way, calculating the minimum 2D face distance, then using it to\n    // render the extruded block doesn't work... It'd be nice, but you have to\n    // compare all 8 extruded blocks... It's obvious, yet if I haven't done this\n    // for a while, it's the first thing I try. :D\n    vec2 uv = (floor(q3.xy*1024.) + .5)/1024.;\n    vec4 p41 = tx0(iChannel0, uv);    \n    vec4 p42 = tx5(iChannel0, uv);   \n    \n    \n    // Scale.\n\tconst vec2 scale = GSCALE;\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, vec2(l.x, -l.y), -l);\n     \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    \n    // By the way, I'm making 8 height map calls. They're in the form of\n    // precalculated textures reads, which most GPUs can handle quite\n    // easily, even within a raymarching loop. However, with a bit of \n    // effort, it'd be possible to store four loop values in each channel,\n    // then get away with just two texture reads instead of eight.\n    // Unfortunately, I couldn't make that happen in the short time I had\n    // to put this together. Anyway, just know that it'd be possible if \n    // someone less slow was writing this. :D\n    // \n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n\n\n        // Local coordinates and local tile ID.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; \n    \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip*s + cntr;\n \n        // The pentagonal block central face offse, base on block dimension,\n        // and block orientation.\n        vec2 offs = vec2(l.x/4., 0.);\n        if((i&1) == 1){ //if(i == 1 || i == 3){\n             // Reorient for blocks one and three.\n             offs = offs.yx*vec2(-1, 1);\n        }\n \n        \n        // Height scale. Heigher is more dramatic, but can be prone to arifacts,\n        // which has to do with a bunch of things.\n        const float hs = .5;\n     \n        \n        // Here's a brief summary of one Cairo tiling method: Put a square grid together.\n        // Cut grid blocks in half horizontally on one checker portions and vertically\n        // across the other. Set \"shim\" to zero (an reset) for a visual reference.\n        // Add mid points to all the edges, then move the right ones in or out depending\n        // on the pentagonal tile configuration you wish to produce. The following effects\n        // that.\n\n        // Shimming variable to move the midpoints in or out. This is by a constant amount,\n        // but I guess you could go to a lot of trouble to make irregular tiles, which \n        // would be pretty cool... I might do that later.\n        float shim = SHIM_VALUE; // Range: [-1, 1].\n        \n        // Moving the central offset position by 1.5 times the shimming amount. I honestly\n        // can't remember why I chose this value, but it seems to work. :)\n        offs *= 1. + shim/2.;\n       \n       \n        // Using the precalcuted pentagon values to consrtuct the extuded pentagon blocks.\n\n        // Central block position (doubling as an ID), which is used to read into the \n        // height map.\n        vec2 idi1 = idi + offs;\n        // Pentagonal top face.\n        float pent1 =  p41[i];\n        // Extruded block height.\n        float h1 = tx1B(iChannel0, (idi1)/64.).x;\n        //h1 = floor(h1*15.999)/15.; // Or just, \"h1 *= .15,\" for nondiscreet heights.\n        h1 *= hs;\n        // One of two extruded block distances for this pass.\n        float pent1Ext = opExtrusion(pent1 + .0*scale.x, (q3.z + h1), h1);\n\n        // The same as above, but for the second extruded block.\n        vec2 idi2 = idi - offs;\n        float pent2 = p42[i]; \n        float h2 = tx1B(iChannel0, (idi2)/64.).x;\n        //h2 = floor(h2*15.999)/15.;\n        h2 *= hs;\n        // The extruded distance function value.\n        float pent2Ext = opExtrusion(pent2 + .0*scale.x, (q3.z + h2), h2);\n        \n        // Adding a touch of the 2D values for extra height. This points the pointy\n        // cone-like tips on the faces.\n        pent1Ext += pent1*.25;\n        pent2Ext += pent2*.25;\n       \n        // Choose the closest block, then return it's central position ID and a number\n        // telling us whether it's on the top or bottom.\n        vec4 di = pent1Ext<pent2Ext? vec4(pent1Ext, idi1, 0) : vec4(pent2Ext, idi2, 4);\n  \n\n\n        // If applicable, update the overall minimum distance value, ID, and box ID. \n        if(di.x<d){\n            \n            d = di.x;\n            id = di.yz;\n            // There are 8 possible blocks, so give each an ID. \n            // Not used in this example, but it's there.\n            boxID = float(i) + di.w;\n            \n            // This is a last minute global hack to return the block\n            // heights, which are used to render the black block rims.\n            // I wouldn't recommend trying this at home. :D\n            gh = pent1Ext<pent2Ext? h1 : h2;\n            \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor. Not really used here, but if you changed the block dimensions,\n    // the you'd want this.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.25) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // So, what's this mess then? Glad you asked. :) Apparently, if there's a break, things\n    // won't get unrolled, so the idea is that this will cut down on the number of unrolled\n    // map calls which can add to compile time... As to whether it works or not, I can't say,\n    // but it seems to cut compile time down on my machine. If you know of something better,\n    // feel free to let me know. In case it needs to be said, from a code perspective, I \n    // do not like this. :)\n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the \n    // lowest number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        // Subtle difference. Thanks to IQ for this tidbit.\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); \n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\n// Just the 2D Cairo pentagon value. Pull in all 8 stored values\n// and send back the minimum. Technically, we should be using a \n// 2D interpolated technique which involves more texture calls,\n// but we're just using this to draw outlines.\n//\n// Also, for normal 2D, we wouldn't need 8 pentagon calls. You could\n// get away with four or even two.\nfloat pent2D(vec2 p){\n    \n    vec2 uv = (floor(p*1024.) + .5)/1024.;\n    \n    vec4 p1 = tx0(iChannel0,uv);\n    float d1 = min(min(p1.x, p1.y), min(p1.z, p1.w));\n    \n    vec4 p2 = tx5(iChannel0,uv);\n    float d2 = min(min(p2.x, p2.y), min(p2.z, p2.w));\n    \n    return min(d1, d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, iTime, -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .2, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, .5, .25);// Put it a bit in front of the camera.\n    #ifdef GREYSCALE\n    lp.y += 1.; // Move the light to show the colored specular component more.\n    #endif\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2(sin(iTime/12. - cos(iTime/16.))/2.);\n\n\n    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec3 svGID = gID;\n    \n    float svObjID = objID;\n    \n    float svGH = gh;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Setting the object color to zer. \n\t    vec3 objCol = vec3(0);  \n        \n        // Specular color.\n        vec3 sCol = vec3(1, .5, .2);\n        \n        // 2D pentagon variables for dark lines, decoration, etc.\n        float pentLn = 1e5, pentRng = 1e5, pent = 1e5;\n        \n        // Some color variables.\n        vec3 tCol1 = vec3(0), tCol2 = vec3(0);\n\n        // The extruded pentagonal grid. The coloring is made up on the spot. All of it\n        // is based off of simple 2D techniques.\n        if(svObjID<.5){\n            \n       \n            // See the scaling factor in distance the function.\n            float rnd = tx1B(iChannel0, svGID.xy/64.).x*1.5;\n            vec2 pl = sp.xy - svGID.xy;\n            // Using the tile ID to rotate the angle to align correctly with the pentagonal\n            // sides. I did this in a hurry, so it's not my best work. :) There'd have to be \n            // a nicer way to do this.\n            float[8] rt = float[8](1., 0., 1., 0., 3., 2., 3., 2.);\n            pl *= rot2(rt[int(svGID.z)]*3.14159/10.);\n            \n            // Tangential palette colors and colors based on the height map. The cos palette\n            // function comes from IQ. It's really clever and very versatile.\n            float ia = (floor(atan(pl.x, pl.y)/6.28318*5.) + .5)/5.;\n            tCol1 = .55 + .45*cos(-6.2831*rnd + vec3(0, 1, 2));\n            tCol2 = .55 + .45*cos(6.2831*ia + vec3(0, 1, 2));\n            \n            // Setting the specular color to the tangential colors. There's no science behind \n            // it. Giving the facets a pearlescent appearance seemed like a fun thing to do.\n            sCol = tCol2;\n            \n            // Setting the object color to the height map color.\n            objCol = tCol1;\n            #ifdef GREYSCALE\n            // Greyscale.\n            objCol = vec3(1)*dot(objCol, vec3(.299, .587, .114));\n            #endif\n            \n            // Mixing things up.\n            //objCol = objCol/2. + objCol*tCol2*2.;\n           \n            \n            // Putting in some dark lines to give it a slight cartoon look. It's more hassle\n            // that using a distance map-based edge formula, but it's way cheaper, easier on\n            // the compiler and gives you more control.\n            \n            // Pentagonal lines.\n            pentLn = abs(fract(atan(pl.x, pl.y)/6.2831853*5. + .5) - .5)*2. - min(.007/length(pl), 1.);\n        \n            // 2D pentagon.\n            pent = pent2D(sp.xy);\n            // Pentagon lines, not including the pentagon face itself. Commenting this out will produce\n            // a wireframe looking exterior.\n            #ifndef WIREFRAME\n            pentLn = max(pentLn, -pent);\n            #endif\n            // The pentagonal ring that surrounds the face edges.\n            pentRng = max(abs(pent) - .001, (sp.z + svGH*2.));\n            \n            // Brightening up the inner face edges a bit. It's a 2D photoshop inner stroke trick.\n            // Comment it out to see what it does.\n            objCol = mix(objCol, mix(objCol*2., vec3(1), .1), \n                         (1. - smoothstep(0., .01, -(sp.z + svGH*2.)))*.5);\n   \n\n   \n        }\n        /*\n        else {\n            \n            // The dark floor in the background. Not really used here, as it's hidden\n            // behind the pylons, but if you changed the block dimensions, you'd want this.\n            objCol = vec3(0);\n        }\n        */\n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 4.);\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n         \n        // Combining the above terms to procude the final color.\n        \n       \n        #ifdef GREYSCALE\n        // In greyscale mode, focus more on the specular.\n        col = objCol*(diff*.7 + ao*.1 + sCol*spec*8.) + sCol*sqrt(spec); \n        #else\n        col = objCol*(diff + ao*.3 + sCol*spec*8.);\n        #endif\n        \n        \n        // Apply the dark pentagonal ring and lines to the extruded pentagon edges.\n        // I've found through trial and error that applying dark edges after performing\n        // the lighting calculations is more artifact free. Codewise, it doesn't look \n        // as neat and tidy, unfortunately.\n        float alpha = 1.;\n        #ifdef WIREFRAME\n        alpha = .8;\n        #endif\n        col = mix(col, vec3(0), (1. - smoothstep(0., .007, min(pentLn, pentRng)))*alpha);\n\n\n        #ifdef RANDOM_TOPS\n        // Extra decoration: Interesting, but a little too much, I think, so it's not on by default.\n        if(hash21(svGID.xy)<.35){\n            col = mix(col, vec3(0), 1. - smoothstep(0., .01, pent + .035));\n            col = mix(col, mix(tCol1, tCol2, .5), 1. - smoothstep(0., .01, pent + .035 + .01));\n        }\n        #endif        \n        \n        \n        \n        \n        // Just the texture color.\n        //col = objCol;// + sCol*spec; \n        \n        // Shading.\n        col *= ao*sh*atten;\n        \n        \n\t\n\t}\n    \n    // Usually, you'd put fog here, but the camera is up close, and the horizon is not in\n    // view, so we're saving the calculations.\n\n    \n    #ifdef PENTAGON_MAP_2D\n    // Just the 2D pentagons.\n    float pent1 = pent2D(uv + iTime/6.) + .007;\n    float pent2 = pent2D(uv + iTime/6. + vec2(.004)) + .007;\n    float b = max(pent2 - pent1, 0.)/.004*.7;\n    b *= max(-pent1/.2, 0.) + .5;\n    col = mix(vec3(1), vec3(1, .9, .85)*b, 1. - smoothstep(0., 4./iResolution.y, pent1));\n    #endif\n    \n    \n    // Showing the preculated height field in the second cube face.\n    //col = tx1(iChannel0, uv/2. + iTime/4.).xyz;\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n} \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The Cairo tile midpoint shimming value: Range: [-1, 1].\n// Different values produce different tile configurations. A value of zero\n// will produce the basic double brick arrangement. By the way, a reset is\n// necessary each time. Ie. Hit the back button.\n#define SHIM_VALUE .57735\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n#define GSCALE vec2(1./4.)\n\n// Give the height field discreet heights. It's not necessary, but it can look\n// a little neater, especially with wireframe mode turned on. If you choose \n// this option, a reset will be necessary. Ie. Hit the back button.\n//#define QUANTIZE_HEIGHT\n\n// Display the 2D pentagonal Cairo tiles that are encoded in two of the\n// cube map faces.\n//#define PENTAGON_MAP_2D\n\n// Gives things a polygonized wireframe look. It only works with the default\n// SHIM_VALUE and looks better with the QUANTIZE_HEIGHT define turned on. I'll\n// reformulate the logic later to work with all values.\n//#define WIREFRAME\n\n// Greyscale. Its main purpose is to show the colored angular specular lighting.\n//#define GREYSCALE\n\n// Random indeed, and probably a little too random for my liking. :D\n//#define RANDOM_TOPS\n\n\n\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly. Basically, the pattern is wrapped on a 64 by 64 unit basis.\nfloat repSc = 64.;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n/*\nvec2 hash22(vec2 p) {\n    //return vec2(0);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n// IQ's vec2 to float hash, but with a repeat factor. If you repeat random\n// textures to wrap, then you need to wrap the random functions.\nfloat hash21Rep(vec2 p){ \n    p = mod(p, repSc); \n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\nvec2 hash22Rep(vec2 p) {\n    //return vec2(0);\n    p = mod(p, repSc);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n*/\n\n\n// Reading from various cube map faces.\nvec4 tx0(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(-.5, fract(p.yx) - .5), 0.);\n    //return texture(tx, vec3(-.5, fract(p.yx) - .5));\n}\n\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\nvec4 tx5(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(fract(p) - .5, .5), 0.);\n    //return texture(tx, vec3(fract(p) - .5, .5));\n}\n\nvec4 tx1B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(p.x, -.5, p.y), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\n/*\n\n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    //vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n*/\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22B(i), p);\n    v.y = dot(hash22B(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22B(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22B(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n/*\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D txCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(txCh, (p/8.)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, based on a texture's greyscale value.\nfloat hm(sampler2D txCh, in vec2 p){ \n   \n    return dot(getTex(txCh, p), vec3(.299, .587, .114));\n    \n}\n*/\n\n\n// Height map. Just a couple of gradient noise layers. \n// By the way, because this is precalculated, you could\n// make this as extravagent as you wished.\nfloat hm(in vec2 p){ \n    \n    // We're going for simplicity, so just a couple of\n    // noise layers. The bottom layer is hollowd out a\n    // bit to give a basin like feel.\n    float h = smoothstep(.08, 1., n2D3G(p)*.5 + .5);\n    h = mix(h, n2D3G(p*2.)*.5 + .5, .33);\n    #ifdef QUANTIZE_HEIGHT\n    h = floor(h*15.999)/15.; // Discreet heights.\n    #endif\n    \n    return h;\n    \n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n/*\n// Based on IQ's signed distance to a 2D triangle.\nfloat pent(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4){\n\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n\tvec2 e3 = p4 - p3;\n\tvec2 e4 = p0 - p4;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 v3 = p - p3;\n\tvec2 v4 = p - p4;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\tvec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n\tvec2 pq4 = v4 - e4*clamp( dot(v4,e4)/dot(e4,e4), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e4.y - e0.y*e4.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n    \n    d = min(d, vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x)));\n    d = min(d, vec2( dot( pq4, pq4 ), s*(v4.x*e4.y-v4.y*e4.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n*/\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define N 5\n//\nfloat sdPoly(in vec2 p, in vec2[N] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed objects.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\n// For a 2D extruded block tiling four objects are needed. For the Cairo tiling,\n// each block needs to be subdivided into two seperate pentagonal pieces, so \n// that's eight pentagon distances all up. Since there are no vec8 containers in \n// WebGL, we need to make one. By the way, for regular 2D Cairo tiles, you only \n// need four or even two, depending what you're trying to do.\n//\nstruct Cairo{ vec4 distA; vec4 distB; };\n\n\nCairo df(vec2 q3){\n    \n    // Scale.\n\tconst vec2 scale = GSCALE;\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n     \n    // For block corner postions.\n    vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, vec2(l.x, -l.y), -l);\n    \n    // Cairo tile container.\n    Cairo tile;\n   \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        vec2 cntr = ps4[i]/2. -  ps4[0]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= ip*s; // New local position.\n\n       \n        // Here's a brief summary of one Cairo tiling method: Put a square grid together.\n        // Cut grid blocks in half horizontally on one checker portions and vertically\n        // across the other. Set \"shim\" to zero (an reset) for a visual reference.\n        // Add mid points to all the edges, then move the right ones in or out depending\n        // on the pentagonal tile configuration you wish to produce. The following effects\n        // that.\n\n        // Shimming variable to move the midpoints in or out. This is by a constant amount,\n        // but I guess you could go to a lot of trouble to make irregular tiles, which \n        // would be pretty cool... I might do that later.\n        float shim = SHIM_VALUE; // Range: [-1, 1].\n        \n        // Is the block configuration cut across the horizontal or vertical?\n        int horiz = 1;\n    \n        // Left and right, or top and bottom block dimension.\n        vec2 dim = vec2(l.x/1., l.y);\n        if((i&1) == 1){  //if(i == 1 || i == 3)\n            // Reorient, flag, etc, on blocks one an three.\n            dim = dim.yx;\n            horiz = 0;\n            shim = -shim;\n        }\n\n        // Square vertices and mid points. Standard stuff.\n        vec2[4] vert = vec2[4](vec2(-.5, .5)*dim, vec2(.5)*dim, vec2(.5, -.5)*dim, vec2(-.5)*dim);  \n        vec2[4] mid = vec2[4](mix(vert[0], vert[1], .5), mix(vert[1], vert[2], .5),\n                              mix(vert[2], vert[3], .5), mix(vert[3], vert[0], .5));  \n        \n        \n        // Move the mid point vertices in or out, depending on the above.\n        mid[0] -= mid[0]*shim;\n        mid[2] -= mid[2]*shim;\n\n        mid[1] += mid[1]*shim;\n        mid[3] += mid[3]*shim; \n        \n          \n        // Construct block one: Its orientation depends on the above.\n        vec2[5] v = vec2[5](mid[3], vert[0], mid[0], vert[1], mid[1]); \n        if(horiz == 1) v = vec2[5](mid[0], vert[1], mid[1], vert[2], mid[2]); \n       \n       \n        // Even though the pentagons are identical and concave, this will work \n        // with non concave polygons, so we're making use of IQ's all round \n        // polygon formula. It's slower that the specialized version, but these \n        // values are being precalculated, so it doesn't matter.\n        // \n        float pent1 =  sdPoly(p, v); \n        //float pent1 =  pent(p, v[0], v[1], v[2], v[3], v[4]); \n        \n        \n        // Construct block two: Its orientation depends on the above.\n        v = vec2[5](mid[3], mid[1], vert[2], mid[2], vert[3]); \n        if(horiz == 1) v = vec2[5](mid[0], mid[2], vert[3], mid[3], vert[0]); \n      \n        // Pentagon two.\n        float pent2 = sdPoly(p, v);\n        //float pent2 =  pent(p, v[0], v[1], v[2], v[3], v[4]); \n\n        // Set the eight pentagon distances. These will be used the main \n        // raymarching function in the \"Image\" tab in the form of texture calls. \n        // Trust me, a texture call is much faster than contstucting a 2D \n        // Cairo style pentagon.\n        tile.distA[i] = pent1;\n        tile.distB[i] = pent2;\n \n       \n    }\n    \n    // Return the eight pentagon distances.\n    return tile;\n\n}\n\n\n// Cube mapping for face identification - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in some of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIALIZING.\n        \n        // Construct a distance field, then store it.\n    \tCairo d = df(uv);\n        \n        if(faceID == 0) col = d.distA; //d// Distance field in X, and object IDs in YZ.\n    \n        if(faceID == 5) col = d.distB;//vec4(ln);\n    \n        \n        repSc = 64.;\n        if(faceID == 1) {\n            col = vec4(1)*hm(uv*repSc);//hm(iChannel1, uv*repSc)\n        }\n     \n    }\n    else {\n        if(faceID == 0) col = tx0(iChannel0, uv);\n        if(faceID == 5) col = tx5(iChannel0, uv);\n        if(faceID == 1) col = tx1(iChannel0, uv);\n    }\n\n\n    // Store in the cube map.\n    fragColor = col;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}