{
    "Shader": {
        "info": {
            "date": "1522683866",
            "description": "Generator of bricks/tiles patterns, with plenty of tuning parameters\n (autodemo doesn't touch brick size, ratio and grad direction)\n\nvariant of [url]https://shadertoy.com/view/4dVyDw[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVyRK",
            "likes": 4,
            "name": "Brick & Tiles",
            "published": 3,
            "tags": [
                "2d",
                "pattern",
                "brick",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/4dVyDw\n// variant with separate shape func here: https://www.shadertoy.com/view/ldVczc\n// variant with shape groups and more shapes: https://www.shadertoy.com/view/ldGyzd\n// variant with basketweave: https://www.shadertoy.com/view/XdtBzn\n\n#define MM 0\nfloat CELL = 20.,                  // grid size vertically -> cell size\n      RATIO = 3.,                  // brick length / brick width\n      ROT0 = 0.,                   // brick fix rotation ( degrees )\n      ROT1 = 0.,                   // brick random rotation amplitude (degrees)\n      ROUND = 1./4.;               // radius of round corners\nvec2  BEVEL = vec2(1)/4.,          // bevel width ( cell %  )\n      GAP  = vec2(.5)/8.,          // inter brick gap ( cell % )\n      SUPERCELL = vec2(2,3),       // super tiles ( nb of tiles H, V ) \n      SUPERGAP  = vec2(.2,.1);     // gap around supertile ( cell % )\n      \nbool  BRICK = false;               // tiling or bricks\nint   RAND = 0,                    // 0: white bricks. 1: random B&W. 2: random col\n      TEXT = 2,                    // 0: plein 1: one texture 2: two textures\n      GRAD = 0;                    // gradient through bricks\nvec2  grad = vec2(1,0);            // grad direction & strength\nfloat grad_randA = 2.,             // spread in amplitude ( amp * [1/A,A] )\n      grad_randD = 360.;           // spread in direction ( degrees )\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) +1e-30; // <- eps to fix a windows/angle bug\n}\n#define rot(a) mat2(sin(radians(a) + vec4(1,0,2,1)*1.5707))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U /= R.y;          // normalized coordinates \n    demo( floor(U.x-iTime-.2*sin(4.*U.y-3.*iTime)) ); // demo mode\n    O -= O;\n    vec2 W = vec2(RATIO,1);                     // normalize in cells units\n    U *= CELL/W;\n    \n    if (BRICK) \n        U.x += .5* mod(floor(U.y),2.);\n    else {\n        vec2 iU = floor(U / SUPERCELL) * SUPERCELL, // pos in supercell\n             fU = mod(U,SUPERCELL);\n        fU = (fU-SUPERGAP) / (SUPERCELL-2.*SUPERGAP);\n        U =  iU + clamp(fU,0.,1.)*SUPERCELL;        // renormalize inside superbrick\n    }\n    ivec2 H = ivec2(U);                         // vec2 tile id\n    vec2 S = W* (fract(U) - 1./2.);             // centered coords in a brick\n\n    float dir = ROT0 + ROT1 * (-1.+2.*hash3(uvec3(H,1)).x); // brick rotation\n    S *= rot(dir);\n\n    vec2 A = W/2.-GAP - abs(S),                 // coords from borders \n         B  = A * 2. / BEVEL;                   // coords in bevel\n        float m = min(B.x,B.y);                 // in bevel if [0,1]\n    if (A.x<ROUND && A.y<ROUND)                 // round edges\n        m = (ROUND-length(ROUND-A)) *2./dot(BEVEL,normalize(ROUND-A));\n    \n    O += clamp( m ,0.,1.);                      // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3(uvec3(H,3));      // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,S);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3(uvec3(H,2));             // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, S);\n        O *= T;\n    }\n#else\n // O-=O;\n    O.r = hash3(uvec3(H,2)).r;                 // tile id\n // O.g = O.g;                                 // image(height)\n    O.b = dir;                                 // direction (degrees)\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// autodemo touches all parameters but brick size, ratio and grad direction\n\n#define demo(t) {                                    \\\n    vec3 h1 = hash3(uvec3(t*vec3( 1  , 7.2,-3.1))),  \\\n         h2 = hash3(uvec3(t*vec3( 7.2,-3.1, 9.7  ))),\\\n         h3 = hash3(uvec3(t*vec3(-3.1,-9.9, 7.2))),  \\\n         h4 = hash3(uvec3(t*vec3(11.1, 1.3,-7.5))),  \\\n         h5 = hash3(uvec3(t*vec3(-9.3, 5.1,-2.5)));  \\\n   BEVEL = vec2(h1.xy)/4.;                           \\\n    GAP  = vec2(h2.xy)/4.;                           \\\n   ROUND = h1.z/2.;                                  \\\n   BRICK = bool(h2.z>.5);                            \\\n   if (BRICK==false) SUPERCELL = ceil(4.*h2.xy), SUPERGAP = vec2(h2.z)/2.; \\\n    RAND = int(h3.x*3.);                             \\\n    TEXT = int(h3.y*3.);                             \\\n    GRAD = int(h3.z*2.);                             \\\n    ROT0 = h4.x*h4.x*10.;                            \\\n    ROT1 = h4.y*h4.y*10.;                            \\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}