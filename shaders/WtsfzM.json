{
    "Shader": {
        "info": {
            "date": "1596551774",
            "description": "An extruded grid of packed rounded irregular triangles.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtsfzM",
            "likes": 35,
            "name": "Extruded Offset Triangle Grid",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "triangle",
                "skew",
                "extrude",
                "incircle"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 786
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Offset Triangle Grid\n    -----------------------------\n\n    This is an extruded grid of packed rounded irregular triangles. The triangles\n\tare rendered using some common and not so common triangle geometry.\n\n\tI've been meaning to post an extruded triangle grid for some time, but I keep\n    getting side tracked with other things -- Better late than never, I guess.\n\tThe lack of examples pretty much everywhere tells me that people enjoy coding \n    up extruded triangles about as much as I do. :D In fact, I couldn't even track \n\tdown an irregular packed extruded triangle still image anywhere, let alone code, \n    but I'm sure it's out there. Either way, there's now a reference on Shadertoy, \n    and I've tried to make the process as painless as possible.\n\n\tIn theory, rendering an extruded triangle grid is pretty simple: Render a\n\tregular square block grid, then chop each square block along the diagonal to\n\tproduce triangles. However, in order to avoid artifacts, neighbors need to be \n    considered, which means four block renders per pass, or eight extruded triangles.\n    On top of that, the aforementioned will only produce right angled isosceles \n    triangles, whereas most people will want nice regular equilateral ones. In order \n    to produce those, the rectangles need to be skewed (leant over to the right, in \n    this case) prior to subdivsion.\n\t\n\tLike most regular people, I don't enjoy implementing the skewing and unskewing\n\tprocess. I mean, I can do it, but I don't enjoy it. :) With that in mind, I \n    went to the trouble to clearly outline the process, so hopefully, it'll be easier \n    for anyone else who needs to do it.\n    \n    Anyway, the code's below. A lot of it is window dressing, so for anyone who\n\twould like to construct one of these, just look at the \"map\" function. For \n\tanyone who was wondering, an offset rounded quadrilateral grid is possible using \n    a subset of this setup, and I have one ready to go.\n\n    By the way, the comments are rushed, but I'll tidy them up in due course, and\n\tin case it isn't obvious, the example is a little GPU intensive, so I'll attempt\n\tto mitigate that as well. The most obvious thing I could do is bake the 2D\n\tface information into a buffer texture, then read from that, but for the purpose \n    of readability, I wanted to avoid that.\n\n\n*/\n\n\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n// Skew the grid: In this case, we're just leaning the rectangles over to the \n// right a bit prior to the diagonal subdivision. I'm not sure who first noticed\n// that it was a better way to create triangle grids, but I'm glad they did.\n// Without skewing, you'll have subdivided right angled squares, which is fine,\n// if that's the look you're going for.\n#define SKEW_GRID\n\n// Just the flat plane.\n//#define FLAT_GRID\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// IQ's vec2 to float hash.\nvec2 hash22B(vec2 p){ \n    \n    // Faster.\n    return texture(iChannel1, p/1.13).xy*2. - 1.;\n    \n    /*\n    // Looks nicer, and more distributed, but slower, unfortunately.\n    p = vec2(dot(p, vec2(27.609, 113.583)), dot(p, vec2(57.527, 85.491)));\n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    // Animated.\n    return sin(p*6.2831853 + iTime);//mix(p, sin(p*6.2831853 + iTime), .35);\n    */\n}\n\n/*\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n    \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n*/\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(in vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    //p = p/2. + .5;\n    //p = (floor(p*1024.) + .5)/1024.;\n    vec3 tx = texture(iChannel0, p/2.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n \n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n/*\n// IQ's distance to a regular polygon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define N 3\n//\nfloat sdPoly(in vec2 p, in vec2[N] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n*/\n\n// Rounded triangle routine.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2, vec3 inC){\n    float ndg = .016/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .012;      \n        \n}  \n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n/*\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n*/\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n// Global vertices and local coordinates of the triangle cell.\n// It's lazy putting them here, but I'll tidy them up later.\nvec2[3] gV;\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale.\n    #ifdef SKEW_GRID\n\tconst vec2 scale = vec2(1./.8660254, 1)*vec2(1./6.);\n    #else\n    // Roughly the same area as the above cell, but it can be anything\n    // you want, and it doesn't have to be square either.\n    const vec2 scale = vec2(.18); \n    #endif\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(.5/.8660254, 0);//;\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates, center and overall cell ID.\n    vec2 p, ip, cntr, id = vec2(0);\n\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n    \n \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.;\n    #else\n    const float hs = .25;\n    #endif\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    gV = vec2[3](vec2(0), vec2(0), vec2(0));\n    gP = p;\n    \n    for(int i = 0; i<4; i++){\n\n        // Here's how you apply skewing to four neighboring blocks. There's a specific\n        // order, which would become apparent if you were to code this from scratch. \n        // You could check, if you wanted, or just take my word for it... On a side note,\n        // I make way too many mistakes, so you should never take my word for it. :D\n        \n        // Block center.\n        cntr = ps4[i]/2. - ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);\n        \n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        vert[0] += hash22B((idi + vert[0]/2.))*.25;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.25;\n        vert[2] += hash22B((idi + vert[2]/2.))*.25; \n        vert[3] += hash22B((idi + vert[3]/2.))*.25;\n        #endif\n       \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n      \n          \n        // Mid edge points. Not used here.   \n        //vec2[4] mid = vec2[4](mix(vert[0], vert[1], .5), mix(vert[1], vert[2], .5),\n                              //mix(vert[2], vert[3], .5), mix(vert[3], vert[0], .5));  \n \n        \n        \n        // Some triangle flipping to ensure a Delaunay triangulation... Further non-Delaunay\n        // subdivisions will occur, so it's probably redundant, but it's here for completeness.\n        //float f = flipDistance(vert[0] - vert[2], vert[1] - vert[2], vert[3] - vert[2])<0.? 1. : -1.;\n \n        \n        // Partioning the rectangle into two triangles.\n        \n        // Triangle one.\n        vec2[3] v1 = vec2[3](vert[0], vert[1], vert[2]); \n        //if(f>.5) v1 = vec2[3](vert[0], vert[1], vert[3]); // Delaunay flipping.\n        \n        // Incircle position and radius.\n        vec3 inC = inCentRad(v1[0], v1[1], v1[2]);\n        \n        //float face1 = sdPoly(p, v1); \n        float face1 = sdTriR(p, v1[0], v1[1], v1[2], inC);\n        //float face1 = length(p - inC.xy) - inC.z;\n        //vec2 offs = (v1[0] + v1[1] + v1[2])/3.;\n        vec2 offs = inC.xy;\n        vec2 idi1 = idi + offs;\n        float h1 = hm(idi1);\n        //h1 = floor(h1*15.999)/15.; // Or just, \"h1 *= .15,\" for nondiscreet heights.\n        h1 *= hs;\n        float face1Ext = opExtrusion(face1 + .0*scale.x, (q.z + h1), h1); \n        //float cyl1 = opExtrusion(length(p - inC.xy) - .015, (q.z + h1 + .015), h1 + .015);\n         \n        // Triangle two.\n        vec2[3] v2 = vec2[3](vert[0], vert[2], vert[3]);\n        //if(f>.5) v2 = vec2[3](vert[1], vert[2], vert[3]);  // Delaunay flipping.\n       \n\n        inC = inCentRad(v2[0], v2[1], v2[2]);\n        //float face2 = sdPoly(p, v2);\n        float face2 = sdTriR(p, v2[0], v2[1], v2[2], inC);\n        //float face2 = length(p - inC.xy) - inC.z;\n        //offs = (v2[0] + v2[1] + v2[2])/3.;\n        offs = inC.xy;\n        vec2 idi2 = idi + offs;\n        float h2 = hm(idi2);\n        //h2 = floor(h2*15.999)/15.; // Or just, \"h1 *= .15,\" for nondiscreet heights.\n        h2 *= hs;\n        float face2Ext = opExtrusion(face2 + .0*scale.x, (q.z + h2), h2); \n        //float cyl2 = opExtrusion(length(p - inC.xy) - .015, (q.z + h2 + .015), h2 + .015);\n        \n        //face1Ext += max(face1, -.02);\n        //face2Ext += max(face2, -.02);\n        face1Ext += face1*.2;\n        face2Ext += face2*.2;\n        \n        //face1Ext = min(face1Ext, cyl1);\n        //face2Ext = min(face2Ext, cyl2);\n        \n        // Obtain the smallest triangle information.\n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            \n            d = di.x; // Minimum distance.\n            id = di.yz; // Position-based triangle ID.\n            triID = di.w; // Triangle ID. Not used here, but useful.\n       \n            // Setting the vertices and local coordinates.\n            // Hacked in at the last minute.\n            gV = v2; if(face1Ext<face2Ext) gV = v1;\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, triID);\n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded blocks.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .0;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    \n    //d4.x = -p.z + d4.x*.5;\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.125) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        // Hacky, but not all distance fields play nice. :)\n        t += i<40? d*.5 : d*.75; \n        //t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by forcing a break...\n    // Not sure if it works or not.\n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 6.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c*c, c*c, c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665).yxz; // Mixing in a bit of purple.\n\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, iTime*1.*.5, -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .1, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1.5, 3, -1.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime/8. - cos(iTime/12.))/2. );\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec3 svGID = gID;\n    \n    // Object ID.\n    float svObjID = objID;\n    \n    // Saved local triangle face coordinates and vertices.\n    vec2 svP = gP;\n    vec2[3] svV = gV;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            \n            // Tri-planar texture coloring.\n            vec3 tx = tex3D(iChannel0, sp/1., sn);\n            // Solid coloring for each block.\n            vec3 tx2 = getTex(svGID.xy);\n            \n            // Triangle color.\n            texCol = mix(tx, tx2, 1.5);\n            \n              \n            //texCol = .55 + .45*cos(6.2831*hash21(svGID.xy)/2. + vec3(0, 1, 2));\n       \n            // Black dots at the incircle position on the triangle face.\n            //texCol = mix(texCol, vec3(0), \n            //\t\t\t\t1. - smoothstep(0., .005, length(sp.xy - svGID.xy) - .0086));\n \n            \n            // Rendering a dark ring around the face edges.\n            vec3 inC = inCentRad(svV[0], svV[1], svV[2]);\n            float tri = sdTriR(svP, svV[0], svV[1], svV[2], inC);\n            float tri2 = tri;\n            tri = max(abs(tri) - .001, abs(sp.z + svGID.z*2.));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, tri));\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, tri + .005));\n            \n            // Light lines from the incircle center to the vertices for emphasis.\n            const float ew = .001;\n            float ln = 1e5;\n            ln = min(ln, lBox(svP, inC.xy, svV[0], ew));\n            ln = min(ln, lBox(svP, inC.xy, svV[1], ew));\n            ln = min(ln, lBox(svP, inC.xy, svV[2], ew));\n            texCol = mix(texCol, min(texCol*1.66, 1.), (1. - smoothstep(0., .005, ln)));\n             \n            // Other markings.\n            //float pat = abs(fract(tri2*50.) - .5)*2. - .25;\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, max(tri2, pat)))*.7);\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, tri2 + inC.z - .01));\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, abs(tri2 + .015) - .001));\n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.25/(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 2.)*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.35 + vec3(.2, .4, 1)*fre + vec3(1, .4, .2)*spec*4.);\n        \n        vec3 cTex = envMap(reflect(rd, sn));//texture(iChannel2, reflect(rd, sn)).xyz; cTex *= cTex;\n        \n        col += col*cTex*5.;\n\n        // Shading.\n        col *= ao*sh*atten;\n        \n          \n\t\n\t}\n    \n/*    \n    // Just the 2D rendering.\n    uv = fragCoord/iResolution.y;\n    vec4 d = blocks(vec3(uv + iTime/32., 0.));\n    vec3 inC = inCentRad(gV[0],  gV[1],  gV[2]); \n    vec3 oCol = smoothstep(0., .5, getTex(d.yz));\n    float triD = sdTriR(gP, gV[0],  gV[1],  gV[2], inC); \n    float sf = 1./iResolution.y;\n    col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, triD));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, triD + .005));\n*/        \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}