{
    "Shader": {
        "info": {
            "date": "1642032722",
            "description": "Raymarched a modulo'd cube and added an offset depending on the time on the ray origin",
            "flags": 0,
            "hasliked": 0,
            "id": "fslcDH",
            "likes": 2,
            "name": "Flying through infinite cubes",
            "published": 3,
            "tags": [
                "raymarching",
                "simple",
                "cube",
                "inifinity"
            ],
            "usePreview": 0,
            "username": "ninofiliu",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "float STEP = 0.99;\nfloat MAX_DIST = 100.;\nfloat SURFACE_DIST = 0.0001;\nfloat NORMAL_DIST = 0.00001;\nvec3 MOD_CENTER = vec3(0., 0., -5.);\nfloat MOD_SIZE = 7.;\n\nstruct Marched {\n    vec3 w; // marched position, modulo'd\n    vec3 n; // surface normal\n    float d; // distance from scene\n    float md; // marched distance\n};\n\n/** \n * Signed distance from a point `w` to a plane defined by a point `p` and a normal `n`\n */\nfloat distPlane(vec3 w, vec3 p, vec3 n) {\n    return dot(n, w-p);\n}\n\n/** \n * The scene is a cube centered at `center`\n * The `radius` is the distance from `center` to any face\n * Faces are contained in infinite planes defined by `normals`\n * A point on each face is derived from existing variables\n * Like any concave polygon, the distance from it to a point\n * is the max of signed distance to infinite face planes\n */\nfloat distScene(vec3 w) {\n    vec3 center = vec3(0., 0., -5.);\n    float radius = .8;\n    vec3 normals[6];\n    normals[0] = vec3(0., sin(iTime), cos(iTime));\n    normals[1] = vec3(1., 0., 0.);\n    normals[2] = cross(normals[0], normals[1]);\n    for (int i = 0; i < 3; i++) {\n        normals[3+i] = -normals[i];\n    }\n    \n    float d = 0.;\n    for (int i = 0; i < 6; i++) {\n        d = max(d, distPlane(w, center + normals[i] * radius, normals[i]));\n    }\n    \n    return d;\n}\n\nMarched march(vec3 ray) {\n    vec3 w = vec3(\n        mod(iTime, MOD_SIZE),\n        mod(2.*iTime, MOD_SIZE),\n        mod(-5.*iTime, MOD_SIZE)\n    );\n    float md = 0.;\n    float d = distScene(w);\n    int i = 0;\n    while (i < 1000 && d > SURFACE_DIST && d < MAX_DIST) {\n        w += ray * d * STEP;\n        md += d * STEP;\n        for (int j = 0; j < 3; j++) {\n            float offset = -MOD_CENTER[j] + MOD_SIZE / 2.;\n            w[j] = mod(w[j] + offset, MOD_SIZE) - offset;\n        }\n        d = distScene(w);\n        i++;\n    }\n    // Computes the normal based on distance from nearby points\n    // https://computergraphics.stackexchange.com/a/8097/17336\n    float dwx = distScene(w + vec3(NORMAL_DIST, 0., 0.));\n    float dwy = distScene(w + vec3(0., NORMAL_DIST, 0.));\n    float dwz = distScene(w + vec3(0., 0., NORMAL_DIST));\n    vec3 n = (vec3(dwx, dwy, dwz) - d) / NORMAL_DIST;\n    \n    return Marched(w, n, d, md);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    // Camera is at (0,0,0) and looks towards (0,0,-1)\n    vec3 ray = normalize(vec3(\n        (coord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y),\n        -1.\n    ));\n    Marched m = march(ray);\n    float light =\n        // light from a vertical source\n        // objects do not cast shadows\n        (0.5 + 0.5 * dot(m.n, vec3(0., 1., 0.)))\n        // darken far away objects\n        / (1. + .05 * m.md)\n        // adjusts brightness\n        * 2.;\n    color = vec4(vec3(light), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}