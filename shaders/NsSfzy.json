{
    "Shader": {
        "info": {
            "date": "1646588339",
            "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n",
            "flags": 48,
            "hasliked": 0,
            "id": "NsSfzy",
            "likes": 7,
            "name": "[CrzClm] Plants",
            "published": 3,
            "tags": [
                "maptoy",
                "crazyclimbers"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE .4\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n#define MIN_DIST .001\n#define MAX_DIST 20.\n#define MAT_VOID vec3(-1)\n#define MAT_GREEN_COL vec3(0.240886584,0.422814429,0.322595179)\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = fOpUnionSmooth( res, d, s );\n    }\n    return res;\n}\n\nvec3 bokoboko = vec3(0);\nvec3 unyounyo = vec3(0);\nvec3 bokomini = vec3(0);\nvec3 paripari = vec3(0);\nvoid setTriTextures(vec3 p) {\n  p.y += .14 * 1500.;\n  const float sclpari = 5.;\n  const float smoothness = .1;\n  paripari.x = voronoiSmooth(p.yz * sclpari, smoothness);\n  paripari.y = voronoiSmooth(p.xz * sclpari, smoothness);\n  paripari.z = voronoiSmooth(p.xy * sclpari, smoothness);\n  paripari = smoothstep(.01, .95, paripari);\n\n  const float sclboko = 10.;\n  bokoboko.x = gfbm(p.yz * sclboko, 1, .5);\n  bokoboko.y = gfbm(p.xz * sclboko, 1, .5);\n  bokoboko.z = gfbm(p.xy * sclboko, 1, .5);\n  bokoboko = smoothstep(.01, 1., bokoboko);\n\n  const vec3 sclunyo = vec3(8., 16., 8.);\n  vec3 q = p;\n  q *= sclunyo;\n  q.x += u2s(gfbm(q.yz * .85, 1, .5)) * .5;\n  R(q.xy, sin(q.x * 2.) * PI * .015);\n  unyounyo.x = gfbm(q.yz, 1, .5);\n  unyounyo.y = gfbm(q.xz, 1, .5);\n  unyounyo.z = gfbm(q.xy, 1, .5);\n  unyounyo = smoothstep(.0, 1., unyounyo);\n\n  const float sclbokomini = 30.;\n  p.y *= 2.;\n  bokomini.x = gfbm(p.yz * sclbokomini, 1, .5);\n  bokomini.y = gfbm(p.xz * sclbokomini, 1, .5);\n  bokomini.z = gfbm(p.xy * sclbokomini, 1, .5);\n  bokomini = smoothstep(.01, 1., bokomini);\n}\n\nfloat getTriDisp(vec3 v3, vec3 n) {\n  const float k = 3.;\n  n = normalize(n);\n  vec3 w = pow(abs(n), vec3(k));\n  return (v3.x * w.x + v3.y * w.y + v3.z * w.z) / (w.x + w.y + w.z);\n}\n\nvec3 getTriTrans(vec3 v3, vec3 n) {\n  const float k = 3.;\n  n = normalize(n);\n  vec3 w = pow(abs(n), vec3(k));\n  w /= w.x + w.y + w.z;\n  return v3 * sign(n) * w;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ){\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn ((min(max(d.x,d.y),0.) + length(max(d,0.))));\n}\n\nfloat pMirror(float x, float k){\n\treturn sqrt(x*x+k);\n}\n\nvec2 pBend(vec2 q, float k){\n    //Based on \"bend\" by las:\n    //https://www.pouet.net/topic.php?which=7931&page=5\n\tfloat r = 1./k;\n\tif(abs(k)<1e-1)return q;\n\tfloat sgn = sign(k);\n\tvec2 d = vec2(-q.x, (r-q.y))*sgn;\n\tfloat a = -atan(d.x, d.y);\n\tvec2 b = vec2(sin(a), cos(a));\n\treturn sgn*vec2(-b.y*d.x-b.x*d.y, b.x*d.x-b.y*d.y)+vec2(a*r,r);\n}\n\nvoid pElongate(inout float q, in float h ){\n\tq = q-clamp(q,-h,h);\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat sdPlanterLeaves(vec3 p, vec2 gp, vec2 gID, float maxBend, float strBendRnd) {\n  vec4 res = vec4(MAX_DIST, MAT_VOID);\n  float bsd = length(p + vec3(0., -.3, 0.)), bsr = 0.25;\n  if(bsd > 2. * bsr) return bsd - bsr;\n\n  vec3 cpLeafBase = p;\n  cpLeafBase += vec3(-.00125, -0.216, 0.135);\n  cpLeafBase.xz = pBend(cpLeafBase.xz, 7.36);\n  const float rep = .106;\n  float leafID = floor(cpLeafBase.x / rep);\n  leafID = mod(leafID, 8.);\n  cpLeafBase.x = mod(cpLeafBase.x, rep) - rep * .5;\n\n  float bendStrength = maxBend - hash12(gID.yx + leafID) * maxBend * strBendRnd;\n  float bendf = smoothstep(maxBend, maxBend*(1.-strBendRnd), bendStrength);\n  \n  vec3 cpLeafInner = cpLeafBase;\n  {  // winkles\n    vec3 q = cpLeafInner;\n    q.z += 0.24 * 2.;\n    vec3 sq = (q + vec3(0, -.1, 0)) * vec3(1, 1, .5);\n    q -= getTriTrans(bokoboko, sq) * .05;\n    float a = atan2(q.x, q.z);\n    float l = length(q.xz);\n    float off = gfbm(vec2(l, a * 3.), 5, .5) + gfbm(vec2(l, a * 1.5), 2, .5);\n    cpLeafInner.y += off * .2;\n    float globalOff = gfbm(gp * 7., 3, .5);\n    cpLeafInner.y += u2s(globalOff) * .025;\n    R(cpLeafInner.yz, sin(l * .5));\n  }\n  cpLeafInner.yz = pBend(cpLeafInner.yz, -2.5);\n  cpLeafInner += vec3(0, -0.2, -.115);\n  cpLeafInner = rot(cpLeafInner, vec3(0., -1.57, 0.48));\n  cpLeafInner.y-=.025*bendf;\n  pElongate(cpLeafInner.y, .02);\n  cpLeafInner.z = abs(cpLeafInner.z);\n  cpLeafInner.x -= .02;\n\n  vec3 cpLeafOuter = cpLeafBase;\n  {  // winkles\n    vec3 q = cpLeafOuter;\n    q.z += 0.24 * 2.;\n    vec3 sq = (q + vec3(0, -.1, 0)) * vec3(1, 1, .5);\n    q -= getTriTrans(bokoboko, sq) * .05;\n    float a = atan2(q.x, q.z);\n    float l = length(q.xz);\n    float off = gfbm(vec2(l, a * 3.), 5, .5) + gfbm(vec2(l, a * 1.5), 2, .5);\n    cpLeafOuter.y += off * .2;\n    float globalOff = gfbm(gp * 7., 3, .5);\n    cpLeafOuter.y += u2s(globalOff) * .025;\n    R(cpLeafOuter.yz, sin(l * .5));\n  }\n  \n  cpLeafOuter.yz = pBend(cpLeafOuter.yz, -bendStrength);\n  cpLeafOuter += vec3(0., -0.15, -0.175);\n  cpLeafOuter.y+=u2s(smoothstep(0.,.15,length(p.xz))*hash11(leafID+2.))*.0125*bendf;\n  cpLeafOuter = rot(cpLeafOuter, vec3(0., -1.57, .5));\n  cpLeafOuter.y-=.05*bendf;\n  pElongate(cpLeafOuter.y, .035+bendf*.03);\n\n  cpLeafOuter.z = pMirror(cpLeafOuter.z, .0001);\n  cpLeafOuter += vec3(-.03, .01, -.005);\n  cpLeafOuter.x = abs(cpLeafOuter.x);\n  cpLeafOuter.x += .004;\n  \n  float lw = .038;\n  float lh = .05+bendf*.01;\n  float d = sdEllipsoid(cpLeafOuter, vec3(.01, lh, lw));\n  d = min(sdEllipsoid(rot(cpLeafInner, vec3(.07, .76, -.116)), vec3(.001, .007, .01)), d);\n  d = max(-p.y + .0536, d);\n\n  return d;\n}\n\nfloat map(vec3 p){\n    vec3 cp = p;\n    //p.xz+=iTime*.25;\n    vec3 q = p;\n    //q.xz = mod(q.xz, .5)-.25;\n    \n    q.y+=.25;\n    float d = sdPlanterLeaves(q, p.xz, floor(p.xz/.5)+floor(fract(iTime*.1)*10.), 6.5, .5);\n    q.y-=.125;\n    d = min(sdCylinder(q, vec2(.153,.149)), d);\n    return d;\n}\n\nrender();\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}