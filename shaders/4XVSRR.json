{
    "Shader": {
        "info": {
            "date": "1719836479",
            "description": "a simple terraria like world generations using perlin noise.\nlittle 2d world",
            "flags": 0,
            "hasliked": 0,
            "id": "4XVSRR",
            "likes": 5,
            "name": "Simple terrain, terraria like",
            "published": 3,
            "tags": [
                "noise",
                "simple",
                "terrain",
                "perlin",
                "terraria"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "float cellSize = 4.0;\nfloat speed = 5.; //blocks per secound\n\nfloat typesCount = 6.;\nvec3[] types = vec3[](\n    vec3(19,109,21)/255.,\n    vec3(173,165,135)/255.,\n    vec3(134,152,166)/255.,\n    vec3(68,73,82)/255.,\n    vec3(203,206,211)/255.,\n    vec3(161,180,190)/255.\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float skyLimit = (iResolution.y / cellSize);\n    fragCoord.x += float(iTime * cellSize * speed);\n    vec2 cord = floor(fragCoord / cellSize);\n\n    vec2 uv = mod(fragCoord, cellSize) / cellSize;\n    \n    float noise = hash21(cord);\n    \n    float height = perlin(vec3(cord.x / skyLimit, 0, 0), 8, .2) * skyLimit;\n    \n    int block = -1;//int(noise * typesCount);\n    float ground = height - cord.y;\n    \n    float cave = abs(perlin(vec3(cord / 100., 0) + vec3(10, 57, 99), 5, .2) - .5) * 2.;\n    if(ground < 0. && cord.y < skyLimit * .48) block = -3;\n    else if(ground > 0. && cave < .02) block = -2;\n    else if(ground > 5.) block = int(round(perlin(vec3(cord / 10., 0) / 5., 8, .2) * (typesCount - 1.)) + 1.);\n    else if(ground > 0.) block = 0;\n\n    float bgNoise = (1. - perlin(vec3(fragCoord / cellSize, noise) * 1., 4, .5) * 0.5);\n\n    vec3 col = vec3(160,217,239) / 255.;\n    if(block == -3)\n        col = vec3(28,163,236) / 255. * (perlin(vec3(cord + iTime, sin(iTime / 5.)), 4 , 0.3) * .6 + .4);\n    else if(block == -2)\n        col = vec3(118,85,43) / 255. * bgNoise;\n    else if(block != -1)\n        col = bgNoise * types[block];\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define numOfPoints 100\n#define seed (653165)\n#define PointDist 0.3\n#define Thickness 0.003\n#define RandomPoints 1000\n\nvec2 posCache[numOfPoints];\nvec2 points[numOfPoints];\nvec3 colors[numOfPoints];\n\nfloat ConvertToFloat(uint n)\n{\n    uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    uint ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32\n\n    n &= ieeeMantissa;\n    n |= ieeeOne;\n\n    float f = uintBitsToFloat(n);\n    return f - 1.0;\n}\n//pcg_hash https://stackoverflow.com/questions/70985360/how-to-create-a-3d-random-gradient-out-of-3-passed-values-in-a-fragment-shader\n//minor change to add a seed value\nfloat rand(uint i) {\n    uint state = i + (i * 747796405u + 2891336453u) ^ uint(seed);\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return ConvertToFloat((word >> 22u) ^ word);\n}\n\nfloat rand(float i) { return rand(floatBitsToUint(i)); }\n\nint randInt(uint i) {\n    uint state = i + (i * 747796405u + 2891336453u) ^ uint(seed);\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return int((word >> 22u) ^ word);\n}\n\n\nint randInt(float i)\n{\n    return randInt(uint(i));\n}\nint randInt(int i)\n{\n    return randInt(uint(i));\n}\nint randInt(vec3 i)\n{\n    return randInt(\n        uint(randInt(\n            uint(randInt(\n                uint(i.x)\n            )) + uint(i.y)\n        )) + uint(i.z)\n    );\n}\n\n\nvec3 hash23(vec2 src) {\n    vec3 randV = vec3(rand(src.x), rand(src.y), rand(src.x * src.y + src.x + src.y + 8912.2793));\n    randV += dot(randV, randV+vec3(3799.6274,9567.3518,8575.2724));\n    \n    return fract(randV);\n}\n\nfloat hash21(vec2 src) {\n    vec3 randV = vec3(rand(src.x), rand(src.y), rand(src.x * src.y + src.x + src.y + 8912.2793));\n    \n    return rand(dot(randV, randV+vec3(3799.6274,9567.3518,8575.2724)));\n}\n\nvec2 hash32(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y));\n    randV *= dot(randV, vec2(8183.0119, src.z));\n    \n    return fract(randV);\n}\n\nfloat hash31(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y));\n    randV *= dot(randV, vec2(8183.0119, src.z));\n    \n    return hash21(fract(randV));\n}\n\nvec2 hash12(float i) {\n    vec2 randV = vec2(rand(i), rand(i + 6939.9375));\n    randV *= dot(randV, vec2(8183.0119,4912.9833));\n    \n    return fract(randV);\n}\n\n\nvec3 hash13(float i) {\n    vec2 randV = vec2(rand(i), rand(i + 6939.9375));\n    randV *= dot(randV, vec2(8183.0119,4912.9833));\n    \n    return hash23(fract(randV));\n}\nvec2 hash12(int i) {return hash12(intBitsToFloat(i));}\n\n\n\nint inc(int num)\n{\n    num++;\n    return num;\n}\n\nint inc(float num)\n{\n    return inc(int(num));\n}\n\nfloat grad(int hash, vec3 pos)\n{\n    int h = hash & 15;\n    float u = (h < 8) ? pos.x : pos.y;\n    \n    float v;\n    \n    if(h < 4)\n    {\n        v = pos.y;\n    }else if( h == 12 || h == 14 )\n    {\n        v = pos.x;\n    }else\n    {\n        v = pos.z;\n    }\n    \n    return (((h&1) == 0) ? u : -u)+((h&2) == 0 ? v : -v);\n}\n\nfloat fade(float t)\n{\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(vec3 t)\n{\n    return vec3(fade(t.x), fade(t.y), fade(t.z));\n}\n\n\n\nfloat lerp(float a, float b, float x)\n{\n    return a + x * (b - a);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 posI = floor(pos);\n    vec3 posF = pos - posI;\n    \n    posI.x = float(int(posI.x) & 255);\n    posI.y = float(int(posI.y) & 255);\n    posI.z = float(int(posI.z) & 255);\n    \n    vec3 uvw = fade(posF);\n    \n    int aaa = randInt(vec3(     posI.x ,     posI.y ,     posI.z  ));\n    int aba = randInt(vec3(     posI.x , inc(posI.y),     posI.z  ));\n    int aab = randInt(vec3(     posI.x ,     posI.y , inc(posI.z) ));\n    int abb = randInt(vec3(     posI.x , inc(posI.y), inc(posI.z) ));\n    int baa = randInt(vec3( inc(posI.x),     posI.y ,     posI.z  ));\n    int bba = randInt(vec3( inc(posI.x), inc(posI.y),     posI.z  ));\n    int bab = randInt(vec3( inc(posI.x),     posI.y , inc(posI.z) ));\n    int bbb = randInt(vec3( inc(posI.x), inc(posI.y), inc(posI.z) ));\n    \n    float x1, x2, y1, y2;\n    \n    x1 = lerp(\n        grad(aaa, posF), \n        grad(baa, vec3(posF.x - 1., posF.y     , posF.z     )),\n        uvw.x\n    );\n    x2 = lerp(\n        grad(aba, vec3(posF.x     , posF.y - 1., posF.z     )), \n        grad(bba, vec3(posF.x - 1., posF.y - 1., posF.z     )),\n        uvw.x\n    );\n    y1 = lerp(x1,x2, uvw.y);\n    \n    x1 = lerp(\n        grad(aab, vec3(posF.x     , posF.y     , posF.z - 1.)), \n        grad(bab, vec3(posF.x - 1., posF.y     , posF.z - 1.)),\n        uvw.x\n    );\n    x2 = lerp(\n        grad(abb, vec3(posF.x     , posF.y - 1., posF.z - 1.)), \n        grad(bbb, vec3(posF.x - 1., posF.y - 1., posF.z - 1.)),\n        uvw.x\n    );\n    y2 = lerp(x1,x2, uvw.y);\n    \n    return (lerp (y1, y2, uvw.z) + 1.) / 2.;\n}\n\nfloat perlin(vec3 pos, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;\n    \n    for(int i=0;i<octaves;i++) {\n        total += noise(pos * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    \n    return total/maxValue;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}