{
    "Shader": {
        "info": {
            "date": "1482508737",
            "description": "Gyroid, Schwarz P, Schwarz D",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVSzR",
            "likes": 15,
            "name": "Gyroid",
            "published": 3,
            "tags": [
                "raymarching",
                "geometry",
                "gyroid",
                "schwarzminimalsurface"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 922
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ROT (iTime*0.5)\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    p.xz*=rot(ROT);\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat matid=0.;\n\nfloat map(vec3 p)\n{\n    matid=0.;\n    vec3 q=p;\n    p.xz*=rot(ROT);\n    float time=mod(iTime, 15.0)+2.;\n    // Gyroid\n    float d0=dot(sin(p),cos(p));\n    \n    // Schwarz Primitive\n    //float d0=dot(vec3(1.0), cos(p));\n    \n    // Schwarz Diamond\n    //float d0=sin(p.x)*sin(p.y)*sin(p.z)+sin(p.x)*cos(p.y)*cos(p.z)+cos(p.x)*sin(p.y)*cos(p.z)+cos(p.x)*cos(p.y)*sin(p.z);\n    \n    // Try Shane's variation\n    //float d0=dot(sin(p),cos(p.yzx));\n    \n    float d1=abs(p.y+6.3);\n    float d2=length(p)-min(9.,time);\n    float d=smax(-d0,d2,3.);\n    if(d1<d){matid=1.;d=d1;}\n    return d*0.5;\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.15*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01,d=0.0;\n    for(int i=0;i<96;++i)\n    {\n        vec3 p=ro+t*rd; \n        d=map(p);\n        if(d<0.001*t||t>100.)\n           \tbreak;\n        t+=d;\n    }\n    if(t>100.)t=-1.0;\n   \n    return t;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 lookat = vec3(0.0, 0., 0.);\n\tvec3 ro = lookat + vec3(0., 7., -20.5);\n\n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.0);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-1.0, 1.0, -.7));\n        \n        vec3 material=vec3(0.4,1.1,0.3);\n        if(matid>0.5)material=vec3(1.0,1.,0.9);\n\t    n=bump_mapping(pos, n, 0.9/(1.+t*0.5));\n        \n        float ao=get_ao(pos,n);\n        \n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 16.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.0005, 28.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.3)*amb*ao;\n        lin+=vec3(7.,4.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(spec*7.2)*sha;\n        \n        col=lin*0.2*material;\n        col *= min(2000.0*exp(-0.34*t),1.0);\n     }\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor.xyz=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}