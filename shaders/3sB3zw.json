{
    "Shader": {
        "info": {
            "date": "1548382799",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "3sB3zw",
            "likes": 6,
            "name": "MandelbulbISF",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "TheHybridProject",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "\n\nfloat stime, ctime;\nvec3 pos = vec3(0.0, 0.0, 0.0);\n//\nvec3 sundir = normalize(vec3(0.1, 0.8, 0.6));vec3 sun = vec3(1.64, 1.27, 0.99); \nvec3 skycolor = vec3(0.6, 1.5, 1.0);\nfloat pixel_size = 1.0;\n\n\nfloat Multiply = 1.0;\nfloat Multiply1 = 1.0;\nfloat Multiply2 = 1.0;\nfloat Multiply3 = 1.0;\nfloat Multiply4 = 1.0;\nfloat Multiply5 = 1.0;\n\nvoid ry(inout vec3 p, float a)\n{  \n \tfloat c,s;\n    vec3 q = p;  \n  \tc = cos(a);\n    s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\n\n/* \n** z = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n** zn+1 = zn^8 +c\n** z^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n** zn+1' = 8 * zn^7 * zn' + 1\n*/\n\nvec3 mb(vec3 p)\n{\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tfloat power = 8.0*Multiply;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\tfloat t0 = 1.0;\n\t\n\tfor(int i = 0; i < 7; ++i)\n    {\n\t\tr = length(z);\n\t\tif(r > 2.0)\n            continue;\n\t\ttheta = atan(z.y / z.x);\n\t\tphi = asin(z.z / r);\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\tz = r * vec3(cos(theta) * cos(phi*Multiply1), sin(theta*Multiply2) * cos(phi*Multiply3), sin(phi*Multiply4)) + p*Multiply5;\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\nvec3 f(vec3 p)\n{ \n\t//ry(p, 1.15);\n    ry(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k)\n{ \n\tfloat akuma = 1.0;\n    float h= 0.0; \n\tfloat t = 0.01;\n    for(int i = 0; i < 50; ++i)\n    { \n        h = f(ro + rd * t).x; \n        if(h < 0.001)\n            return 0.02; \n        akuma = min(akuma, k * h / t); \n \t\tt += clamp(h, 0.01, 2.0); \n    } \n    return akuma; \n} \n\nvec3 nor(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize(vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ));\n}\n\nvec3 intersect(in vec3 ro, in vec3 rd)\n{\n    ro = ro - pos;\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for(int i = 0; i < 54; i++)\n    {\n        if(error >= pixel_size * 0.5 && t <= 20.0 )\n        {\n            c = f(ro + rd * t);\n            d = c.x;\n            if(d > os)\n            {\n                os = 0.4 * d * d / pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step = -os;\n                os = 0.0;\n                pd = 100.0;\n                d = 1.0;\n            }\n            error = d / t;\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n            t += step;\n        }\n\n    }\n\tif(t > 20.0)\n        res_t = -1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n    vec2 q = fragCoord.xy / iResolution.xy; \n \tvec2 uv = -1.0 + 2.0 * q; \n \tuv.x *= iResolution.x / iResolution.y; \n\n\t\n \tstime = sin(iTime * 0.1); \n \tctime = cos(iTime * 0.1); \n     \n    vec3 ro = vec3(0.0, -2.0, 3.0);\n \t//vec3 ro= vec3(3.0 * stime, stime * 2.0 + 1.0, 3.0 * ctime); \n\t//vec3 ro = vec3(0.0, 2.0*stime*ctime, 2.2);\n\t//vec3 ro = vec3(0.0, 0.0, 2.0);\n\n \tvec3 cf = normalize(-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0, 1.0, 0.0))); \n    vec3 cu = normalize(cross(cs, cf)); \n \tvec3 rd = normalize(uv.x * cs + uv.y * cu + 3.0 * cf);\n    \n    //vec3 rd = normalize(vec3(uv, -1.0));\n\tpixel_size = 1.0 / (iResolution.x * 2.0 * length(ro - pos));    \n\tvec3 bg = exp(uv.y - 2.0) * vec3(0, 0, 0);\n    float halo = clamp(dot(normalize(-ro), rd), 0.0, 1.0); \n    vec3 col = bg + vec3(0.6, 0.8, 0.4) * pow(halo * 0.1, 42.0); \n\n    vec3 p = ro; \n\tvec3 res = intersect(ro, rd);\n\tif(res.x > 0.001)\n    {\n\t\t  p = ro + res.x * rd;\n          vec3 n = nor(p); \n          float shadow = softshadow(p, sundir, 10.0 );\n          float dif = max(0.0, dot(n, sundir)); \n          float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t  float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n          float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n          vec3 lin = 8.5 * sun * dif * shadow; \n          lin += 0.8 * bac * sun; \n          lin += 0.6 * sky * skycolor; \n          lin += 3.0 * spe; \n\n\t\t  res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\t  vec3 tc0 = 0.5 + 0.5 * sin(3.2 + 3.2 * res.y + vec3(0.5, 0.5, 0.0));\n          col = lin *vec3(0.9, 0.5, 0.6) *  0.6 * tc0;\n \t\t  col = mix(col,bg, 1.0 - exp(-0.001 * res.y * res.y));\n    }\n    col = pow(clamp(col, 0.0, 1.0),vec3(0.45));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.5);\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);\n \tfragColor = vec4(col.xyz, 1.0); \n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}