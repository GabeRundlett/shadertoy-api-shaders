{
    "Shader": {
        "info": {
            "date": "1481638659",
            "description": "Simple adaptation of iq's 3d noise shader (https://www.shadertoy.com/view/4sfGzS) to do 4d noise in a single texture fetch. Due to shadertoy limitations the precomputed texture is currently emulated with 4 1d-noise fetches.",
            "flags": 0,
            "hasliked": 0,
            "id": "XltSWj",
            "likes": 38,
            "name": "Single fetch 4d noise",
            "published": 3,
            "tags": [
                "noise",
                "4d"
            ],
            "usePreview": 1,
            "username": "stubbe",
            "viewed": 2735
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2013\n// Adapted for 4d by stubbe in 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fast 3D (value) noise by using two cubic-smooth bilinear interpolations in a LUT, \n// which is much faster than its hash based (purely procedural) counterpart.\n//\n// Note that instead of fetching from a grey scale texture twice at an offset of (37,17)\n// pixels, the green channel of the texture is a copy of the red channel offset that amount\n// (thx Dave Hoskins for the suggestion to try this)\n\n// Adaped by stubbe for 4d: By applying the same trick again we can copy red and green into \n// blue and alpha with an offset for w and effectively sample a 4d noise by sampling and\n// blending two 3d noises.\n\n\nconst vec2 zOffset = vec2(37.0,17.0);\nconst vec2 wOffset = vec2(59.0,83.0);\n\nvec4 tex(vec2 uv)\t// Emulate a single texture fetch into the precalculated texture\n{\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\n    float r = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).r;\n    float g = textureLod( iChannel0, (uv+0.5 + zOffset)/256.0, 0.0 ).r;\n    float b = textureLod( iChannel0, (uv+0.5 + wOffset)/256.0, 0.0 ).r;\n    float a = textureLod( iChannel0, (uv+0.5 + zOffset + wOffset)/256.0, 0.0 ).r;\n    \n    return vec4(r, g, b, a);\n}\n\n\nfloat noise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\n    \n   \tvec4 s = tex(uv);\n\treturn mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\n}\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n\nconst mat4 m = mat4( 0.00,  0.80,  0.60, -0.4,\n                    -0.80,  0.36, -0.48, -0.5,\n                    -0.60, -0.48,  0.64,  0.2,\n                     0.40,  0.30,  0.20,  0.4);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime*0.0;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        vec4 samplePos = vec4(pos,0.5+iTime*0.8);\n        samplePos *= m;\n\t    float f = 0.0;\n\t\t\n\t\tvec4 q = 4.0*samplePos;\n        f  = 0.5000*noise( q ); q = m*q*2.01;\n        f += 0.2500*noise( q ); q = m*q*2.02;\n        f += 0.1250*noise( q ); q = m*q*2.03;\n        f += 0.0625*noise( q ); q = m*q*2.01;\n\t\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\t//col *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}