{
    "Shader": {
        "info": {
            "date": "1493308497",
            "description": "collection of math stuff.\n\nvisual demonstrations are disabled, but some demo examples exist.",
            "flags": 48,
            "hasliked": 0,
            "id": "lsSyRd",
            "likes": 23,
            "name": "020 look at all the maths",
            "published": 3,
            "tags": [
                "tutorial",
                "rotation",
                "hgsdf",
                "collection",
                "adjugate",
                "inversequare"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1413
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o,in vec2 u){\n o=texture(iChannel0,u/iResolution.xy);}\n//all the stuff is in the BufA tab\n\n//...because \"Image\" can not be read from\n//...and reading from self is kind of important.",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nhttps://www.shadertoy.com/view/lsSyRd   =self\nhttps://www.shadertoy.com/view/XsBczV   =parent\nhttps://www.shadertoy.com/view/ldByDw   =granddad\n\ntutorializing webgl fragment shader collection for shadertoy\nthis dives DEEP into irrational complex rotation matrix math.\n\n//this is the main renderer on BufA\n//because it may function without any other input.\n//and it needs to be able to load from self.\n//\n//it also has ability to display glyphs, floats\n//(though i might have roken that ones spacing)\n\nend__.header\nstart.const   ----do not change this \"const\" section---\n\nWorld famous irrational numbers, sorted by NATURAL fame:\nDifferent definitions can change performance and precision.\nAll irrationals are infinite recursive fractions like a=1/n+(a), \n... with a sequence for every n being set by a defined series.\nThey can be approximated by iterating trough the infinite series.\nThose with larger divisors are approximated faster->\"less irrational\"\nphi=1/(1+(phi)) has the smallest divisor [1], approximates slowest->\"most irrational\"\n\nhttps://www.youtube.com/watch?v=CaasbfdJdJg\n/////iou, function that gives dividend and divisor of irrationals after n-ierations\n\neul=limes of f(x)=pow(1+1/x,x)\npow(e,n)=firstDerivativeOf(pow(e,n));\neul=base for [log()] as the inverse of [pow(e,x)] so that\n... log(pow(eul,x))==x==pow(eul,log(x)); for [x>0]\n*/\n#define eul 2.61803398875\n//eul is not as awesome here, wait till I include advanced \"derivative arithmetic\"\n//\n////integerSquareroot/integer -> RootUnity:  https://en.wikipedia.org/wiki/Root_of_unity\n////With more n-gons this section boils down to more constants of \n////  https://en.wikipedia.org/wiki/Exact_trigonometric_constants\n//\n//generally: most simple fractions are not good enough approximations:\n//eg: 22/7 is not a precise enough approximation for a rotation by pi\n//... when you use polar coordinates.\n//\n//sqrt(2.)=1.4142135623730950488016887242097=\n//...pow(2.,1./2.)= ; https://en.wikipedia.org/wiki/Square_root_of_2#Properties_of_the_square_root_of_two\n//#define p22 sqrt(2.)\n//eightRotation.y=eightRotation.x=cos(pi4)=sin(pi4)=\n//...pow(2.,1./2.)/2=sqrt(2.)/2.=p22/2.=1./p22 =sqrt(0.5)==0.70710678118654752440084436210485\n#define p222 sqrt(0.5) \n//(pow(2.,1./2.)*.5*.5)).5/p22\n#define p224 (p222*.5)\n//incircleHexagonTotalHeight=\n//pow(3.,1./2.)= 97./56. =1.73205080756887729352744634150587236694280525381038062805580=\n#define p32 sqrt(3.)\n//\"inCircleHexagonTotalHeight\"=\"equilateralTriangle.y\"=\"hexagon.y\"=sixth.y\"=.5=\"trivial\" || \"hexagon.x\"=\"sixth.x\"=\"tricky\"=\n//pow(3.,1./2.)/2.= 97./112. =\"sixth.x\"=\"hexagon.x\"=sin(asin(1.)*2./3.)=sin(acos(-1.)/3.)=.866=\n#define p322 (p32/2.)\n//pow(3.,1./2.)/3.= 97./168. =.57735026919=\"useful for hexagonal scaling?\"\n#define p323 (p32/3.)\n//\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1 && 1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(), good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n//\"silverRatio\"=  https://en.wikipedia.org/wiki/Silver_ratio\n#define Phis (sqrt(2.)+1)\n//\n//pi8=pi/4  pi2=pi/2 : pi=3.14 _: tau=pi*2 \n#define pi4 acos( 0.)*.5/*eight  rotation in radians : cos(pi4)==sin(pi)*/\n#define pi2 acos( 0.)   /*quater rotation in radians =asin(1.) */\n#define pi  acos(-1.)   /*half   rotation in radians*/\n//#define tau pi*2.    /*full   rotation in radians =6.28*/\n#define tau 6.283185307179586476925286766559\n//substituring [pi] by [tau/2] can make things simpler (and more precise with floats)\n/*\nend__.const\nstart.const.struct\n*/\n//structs are more a namespace issue and less of a mathematic fundament as the above\n//enforcing sctructs makes it harder to confuse things for other things.\nstruct plane  {vec3 n;float d;}Mplane;//plane normal && DISTANCE <- NormalForm (is not the HNF !)\nstruct quat   {vec3 i;float r;}Mquat;//quaternion; axis.ijk && Angle\nstruct rotaAA {vec3 a;float r;}MrotaAA;//AxisAngleRotation; axis.xyz && Angle.w\nstruct sphere {vec3 c;float r;}Msphere;//sphere; center.xyz && radius.w\nstruct ray    {vec3 o;vec3  d;}Mray;//ray; origin && direction\n//todo, rotate plane and points by things.\n/*\nend__.const.struct\nstart.const.comm\n*/\n#define chank iChannel2\n#define tex(a,b) texture(a,b))\n#define pushing .2\n#define once .5\n#define toggle .7\n#define key(a,b) (tex(chank,vec2((.5+a)/256.),b).x >0.)\n//bool keyAtoggle=key(128,toggle);\n//Note that you NEVER need to write in other shaders\n//and you ONLY need good use of memory and timeouts to simulate \"patience\".\n\n\n\n\n/*\nend__.const.comm\n//\n//ALL parts of the above text (that are used by the functions below)\n//...should be equal for all shaders (that load data from each other)\n//...to avoid namespace cconflicts and unneccessary name changes.\n//To avoid version conflicts, the above gets a ConstantVersionID of:\n//cvid 15\n//                        and the below gets a MutableVersionID of\n//svid 20\n//\nstart.mutable\n*/\n\n\n\n\n\n#define Demo1d 0\n#define Demo2d 1\n#define DemoTiny 2\n#define DemoHgSdf 3\n#define DemoRaymarch 4\n#define DemoRaymarchUber 5\n//#define DemoAll 7 //i can dream of a mode that unifies all modes\n//todo IOU: the feature of switching modes by changing DemoNum is VERY incomplete.\n#define DemoNum 6\n//#define DemoNum Demo1d           -> show linear graph y=f(a)=f(a.x)=[*] || eg y=x*x;\n//#define DemoNum Demo2d           -> show 2d distance gradients.\n//all larger DemoNum are 3d        || commonly d=f(a.xy)=fract(length(a.xy)) ||=fract(min(a.x,a.y))\n//#define DemoNum DemoTiny         -> shows a tiny distance field with nice outlining\n//#define DemoNum DemoHgSdf        -> show ARRAY of a [*] DistanceField\n//                                    ...to test distance field collections\n//#define DemoNum DemoRaymarch     -> show a SINGLE [*] distance field that does not fur in the array\n//#define DemoNum DemoRaymarchUber -> show a SINGLE [fUberprim(*)] parametric distance field\n//#define DemoNum DemoRaymarchUber -> demonstrate rayTracing DFunctions\n\n//define what time is, how (fast) it changes or it if is paused at any value.\n#define time iTime\n//#define time .5\n//the specialty of time dimensions is that they hav a constant sign.\n//[time not having a constant sign] -> [no meaningful derivatives over time]\n//                                  -> [time dimension becomes spatial]\n#if DemoNum > Demo2d      /*at least 3d space*/\n //maximum raymarching iterations\n #define rmIterations 256\n //the lame solution for overstepping: scale steps by *lipschitsScale\n #define lipschitsScale .5\n //because scaling a first derivative is fun and totally awesome, not!\n //increasing epsilon with distance can speed up convergence, distorts space.\n //#define dynamicEps\n#endif /*DemoNum > Demo2d, is at least 3d */\n//\n#define eps 2e-2\n//.02*(sin(tt)*.5+.6)\n//1e-2\n//#if DemoNum > 0  /*at least 2d space*/\n vec2 eA=normalize(vec2(eul, 1.));\n vec2 eB=normalize(vec2(1.,Phi));\n//#endif /*DemoNum > Demo1d, is at least 2d */\n/*\nend__.mutable\nstart.text\n*/\n\n#define S(a) c+=char(p,a);p.x-=1.;\n#define _ p.x-=1.;\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);        \n#define _exc   S(33);   // !\n#define _add   S(43);   // + \n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign \n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\nfloat char(vec2 p,int c){return any(lessThan(vec4(p,1,1),vec4(0,0,p)))? \n 0.:texture(iChannel0,.0625*(p+vec2(c-c/16*16,15-c/16))).x;}\n//draw line segment from A to B\n//float drawSegment(vec2 A, vec2 B, float r){vec2 g=B-A,h=uv-A;\n// float d=length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));\n// return smoothstep(r, 0.5*r, d);}\n//display [f]fraction with [d]leadingZeros \nvoid SetTextPosition(out vec2 p,float x,float y){  //x=line, y=column\n //p=10.0*uv;\n p.x=p.x+17.-x;\n p.y=p.y-9.4+y;}\nfloat drawFract(inout vec2 p,int d, float f){float c=0.; \n f=fract(f)*10.;for(int i=1;i<60;i++){\n  c+=char(p,48+int(f));p.x+1.;d--;f=fract(f)*10.;if(d<=0||f==0.)break;\n }p.x+float(d);return c;}\nfloat drawFract(vec2 p,int d){return drawFract(p,d,0.);}\n//draw [v]int with a minimum # of [m]glyphs\nfloat drawInt(inout vec2 p,int v,int m){float c=0.;if(v<0){v=-v; \n  if(m<1)m=1;else m--;_sub}\n int f=v,d=1;for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;}// get number of digits\n d=max(m,d);p.x-=float(d);\n for(int n=1;n<11;n++){p.x+=1.;c += char(p,48+(v-((v/=10)*10)));if(n>=d)break;} \n p.x-=float(d);return c;}\nfloat drawInt(vec2 p,int v){return drawInt(p,v,1);}\n\n//display [v]float with [p]decimalPrecision and [m]maxDigits\nfloat drawFloat(inout vec2 p,float v,int q,int m){float c=0.;\n p.x-=float(m);\n if (v<0.){c=char(p,45);v=-v;}p.x-=1.; //write \"-\"\n c+=drawInt(p,int(v),1);    //write floor()                                           \n c+=char(p,46);p.x-=1.;      //write \".\"\n c+=drawFract(p,0,fract(v));//write fract() \n return c;}//shorter defaults:\nfloat drawFloat(inout vec2 p,float v)      {return drawFloat(p,v,2,5);} \nfloat drawFloat(inout vec2 p,float v,int q){return drawFloat(p,v,q,2);} \n//display stuffs:\nfloat WriteInteger(inout vec2 p,const in int v){float c=0.;\n c=drawInt(p,v);p.x-=1.;return c;}\nfloat WriteDate(inout vec2 p){float c=0.;\n c+=drawInt(p,int(iDate.x));    _sub;\n c+=drawInt(p,int(iDate.y +1.));_sub;\n c+=drawInt(p,int(iDate.z));return c;}\nfloat WriteTime(inout vec2 p){float c=0.;\n c+=drawInt(p,int(mod(iDate.w/3600.,24.)));  _ddot;\n c+=drawInt(p,int(mod(iDate.w/60.  ,60.)),2);_ddot;\n c+=drawInt(p,int(mod(iDate.w      ,60.)),2);return c;}\nfloat WriteFPS(inout vec2 p){float c=0.;//float fps=(1./iTimeDelta+.5);\n c+=drawFloat(p,iFrameRate);_f _p _s \n return c;}//https://www.shadertoy.com/view/lsKGWV\nvec3 WriteMousePos(inout vec2 p,float t,vec2 m){vec3 c=vec3(0);\n int digits=3;\n float r=iResolution.x/200.;\n //if(iMouse.z>0.)dotColor=mpColor;// print dot at mPos.xy \n float s=length(m-p)-r;\n //vColor+=mix(vec3(0),dotColor,(1.-clamp(s,0.,1.)));\n SetTextPosition(p,1.,t);// print first mouse value\n //drawColor = mxColor;// print mouse position\n if(t==7.){\n  c+=drawFloat(p,m.x,6,3);p.x-=1.;\n  c+=drawFloat(p,m.y,6,3);\n }else{\n  c+=drawInt(p,int(m.x));p.x-=1.;\n  c+=drawInt(p,int(m.y));\n  return c;}}\n\n//\"show\"= [value to display]:\nconst float show=pi;//tsn(1.);//-.6e-4;//-0.00006;//-0.00000000000000006;//\n//const float small=0.;\nconst float small=0.;//exp2(-63.);//a small offset to show more decimals on smaller values.\n//display a value with up to 60 decimal points\nconst float show60=  show-small;\n//display a value with 4 decimals, rounded AFTER the 4th\nconst float show4 =  show-small;// -200.09906;\n//reasonable float precision\n//these values take float16 precision errors into account:\n//exp2(-126.0)== smallest positive 16 bit float exp2(-127.0)->0\nconst float showSmall=exp2(-126.);//planck length 16 bit float, scales exponentially.\n\nfloat DemoWriteTestValues(in vec2 p){float c=0.;\n SetTextPosition(p,1.,12.);\n c+=drawInt(p,123, 8);   \n c+=drawInt(p,-1234567890);// right now !!!\n _ c+=drawInt(p,0);                \n _ c+=drawInt(p,-1);                \n _ c+=drawFloat(p,-123.456);     // right now !!!\n SetTextPosition(p,1.,13.);\n _ c+=drawInt(p,-123, 8);   \n _ c+=drawInt(p,1234567890,11);\n _ c+=drawFloat(p,0.0,0,0);\n _ c+=drawFloat(p,1.0,0,0);\n _ c+=drawFloat(p,654.321);      // nearly right\n _ c+=drawFloat(p,999.9, 1);\n _ c+=drawFloat(p,pow(10., 3.),1);   \n _ c+=drawFloat(p,pow(10., 6.),1);   \n SetTextPosition(p,1.,14.);c+=drawFloat(p,showSmall,60);\n SetTextPosition(p,1.,15.);c+=drawFloat(p,show60,60);\n SetTextPosition(p,1.,16.);c+=drawFloat(p,show4+sign(show4)*.5*pow(10.,-4.),4);\n return c;}\n \t\n//iq curves: https://iquilezles.org/articles/functions\n//cubic curve that skips y=0. f(0)=n; for range n>y>m the cuve is cubic.\nfloat almostIdentity(float x,float m,float n){\n if(x>m )return x;//above m, f(x) is linear.\n x/=m;return((2.*n-m)*x+2.*m-3.*n)*x*x+n;}\n//slowly decaying \"ping\". maximum is f(1/k)=1;\nfloat impulse(float x,float k){float h=k*x;return h*exp(1.-h);}\n//interval [-w,w] local maximum at f(0);\n//bellShaped Gaussian-like =smoothstep(c-w,c,x)-smoothstep(c,c+w,x)\nfloat cubicPulse(float x,float c,float w){x=abs(x-c);\n if(x>w)return 0.;x/=w;return 1.0f - x*x*(3.0f-2.0f*x);}\n//e=exponent, k=scaling.y, for large [k,e] approaches step(x,1)\nfloat expStep(float x, float k, float e ){\n return exp(-k*pow(x,e));}\n//parabolic projection for x[0..1]\n//parabola(0)=parabola(1)=0,and parabola(.5)=1\nfloat parabola(float x,float k){\n return pow(4.*x*(1.-x),k);}\n//f(k)=maximum, gives shapes of wigs, eyes, leafs.\nfloat pcurve(float x,float a,float b,float k){\n return pow(x,a)*pow(1.-x,b)*k;}\nfloat pcurve(float x,float a,float b){\n return pcurve(x,a,b,(pow(a+b,a+b)/(pow(a,a)*pow(b,b))));}\n\n/*\nend__.text\nstart.solver\n*/\n//return ifb(a,b,c); is identical to if(a<0.){return b;}else{return c;} but branchless:\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//branchless code -> longer pipelines on newer hardware -> likely better performance.\n//branchless code -> +1add +1mult, even slower on older hardware.\n//branchless code -> b & c are both calculated and substracted.\n//... this can cause extra calculations and more rounding errors. as only one difference of b and c matters.\n\n//a lot of things solve efficiently with inverse(m) of matrix [m].\n//m*inverse(m)=mat3(1)=mat2(1,0,0,0,1,0,0,0,1);\n//if(determinant(m)==0)matrix is its own inverse (matrix changes nothing);\n//calculaitng an inverse is tricky in higher dimensions.\n//due to division of: inverse(m)==adjugate(m)/determinant(m)\n//... we seperate adjugate(m) and determinant(m) for higher precision.\n\n//in mat2 this is simple:\n//[mat2 determinant() in 2 other types]=det()=determinant()\nfloat det(mat2 a){return determinant(a);}\nfloat det(mat3 a){return determinant(a);}//shorthand avoids reserved namespace\nfloat det(vec2 a,vec2 b){return det(mat2(a,b));}//return a.x*b.y-b.x*a.y;)\nfloat det(float a[2],float b[2]){return det(mat2(a[0],a[1],b[0],b[1]));}//return a[0]*b[1]-b[0]*a[1];)\nfloat det(float a[3],float b[3],float c[3]){return det(mat3(a[0],a[1],a[2],b[0],b[1],b[2],c[0],c[1],c[2]));}\n\n//return inverse of m, multiplied by its determinant(m)\nmat2 adjugate(mat2 m){vec4 n=vec4(m);return mat2(n.w,-n.yz,n.a);}\n //return mat2(m[1][1],-m[1][0],-m[0][1],m[0][0]);\n//https://www.mathsisfun.com/algebra/matrix-inverse.html\n\n#define skipli for(int i=0;i<e;i++){r[i+int(step(s-float(i),0.))]=a[i];}return r;}\n#define skipl2 a[3],float s){int e=a.length()-1\n#define skipl3 a[4],float s){int e=a.length()-1\n//mat3 adjugate gets trickier:\n//return sublist of a, without entry number#[skip]\nint  [2] lSkipI2(int   skipl2,      r[2];skipli\nfloat[2] lSkipF2(float skipl2;float r[2];skipli\nint  [3] lSkipI3(int   skipl3,      r[3];skipli\nfloat[3] lSkipF3(float skipl3;float r[3];skipli\nmat3 adjugate(mat3 m){mat3 r=mat3(0);\n for(int i=0;i<4;i++){for (int j=0;j<4;i++){//[s=] is similar to my sgn() function\n   float s=-2.*fract((float(i+j)*.5));//s=sign of checkerboardMatrix at m[i][j]\n// https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html\n   int co[3]=int[3](0,1,2),c2[2]=lSkipI2(co,float(i)),nullth=c2[0],first =c2[1];\n   //above calculates that .y parameter are NOT skipped.\n   //a is the LEFTMOST sub-column //b is the RIGHTMOST sub-column\n   float a[2]=lSkipF2(float[3](m[0][nullth],m[1][nullth],m[2][nullth]),float(j));\n   float b[2]=lSkipF2(float[3](m[0][first],m[1][first],m[2][first]),float(j));\n   r[i][j]=s*det(a,b);//det(aa,bb)==entry[i][j] of \"matrix of minors\"\n }}return transpose(r);}\n//adjugate functions are more likely full of typos than not.\nmat4 adjugate(mat4 m){mat4 r=mat4(0);\n for(int i=0;i<5;i++){for (int j=0;j<5;i++){\n   float s=-2.*fract((float(i+j)*.5));\n   int co[4]=int[4](0,1,2,3),c2[3]=lSkipI3(co,float(i)),nullth=c2[0],first =c2[1],second=c2[2];\n   //above calculates that .y parameter are NOT skipped.\n   float a[3]=lSkipF3(float[4](m[0][nullth],m[1][nullth],m[2][nullth],m[3][nullth]),float(j));\n   float b[3]=lSkipF3(float[4](m[0][first ],m[1][first ],m[2][first ],m[3][first ]),float(j));\n   float c[3]=lSkipF3(float[4](m[0][second],m[1][second],m[2][second],m[3][second]),float(j));\n   r[i][j]=s*det(a,b,c);}}return transpose(r);}\n                  \n//return vec3(a,b,c) that makes all input equations true.\n//p contains \"solutions\", one side of the equation\n//x,y,z store factors on the other side of the equations:\n//1=2*a+3*b+4*c -> p.x=1; a=vec3(2,3,4)\n//5=6*a+7*b+8*c -> p.y=5; b=vec3(6,7,8)\n#define sr if(determinant(m)==0.)return p;return inverse(m)*p;}\nvec2 solve(vec2 p,vec2 x,vec2 y){mat2 m=transpose(mat2(x,y));sr\nvec3 solve(vec3 p,vec3 x,vec3 y,vec3 z){mat3 m=transpose(mat3(x,y,z));sr\nvec4 solve(vec4 p,vec4 x,vec4 y,vec4 z,vec4 w){mat4 m=transpose(mat4(x,y,z,w));sr\n//opengl goes ColumnsBeforeLines: check (determinant(m)!=0) before solvem() \n#define solvem(p,m) (inverse(m)*p)\n//https://www.mathsisfun.com/algebra/systems-linear-equations-matrices.html\n\n    \n//IOU gaussian Elimination\nmat2 GaussianElimination(mat2 m){return mat2(0);}\nmat3 GaussianElimination(mat3 m){return mat3(0);}\nmat4 GaussianElimination(mat4 m){return mat4(0);}\n\n/*\nend__.solver\nstart.hash\n*/\n\n//---------------- \"h[*]\"\n\n//IOU - pseudoRandom stuffs.\n//hashes are better when they are pseudoRandom, with an unpredictable seed-stream.\n\n//hashes take the namespace \"h[*]\"\n//hashes project one set (of numbers) to another (smaller) set (of numbers).\n//a more constant input part of a hash is called \"seed\". \n//seeds can be constant or streamed video or audio, to include change over time.\n//\n//hashes include sin() or fract() as final operation and approximate irrational \n//...numbers within that to more evenly distribute the result of any non-seed-input.\n//Simplest most evenly distributing most predictable hash, plants love it:\n#define hPhi(seed,a) (a*fract(seed*Phi))\n//above is used by plants, below is better for type int due to smaller intDivisions\n#define hphi(seed,a) (a*fract(seed*phi))\n//But you want the results of consecutive hashes to be good pseudo-randoms-values.\n//\n//A hash reduces information, if only by rounding.\n//A hashes result can be spread over more output dimensions than its input dimensions.\n//this does not create information out of thin air, but can give the illusion of that.\n\n//return float range [0..1] from uint[n] : by Hugo Elias:\nfloat hash(uint n){n=(n<<13U)^n;n=n*(n*n*15731U+789221U)+1376312589U;\n //return 1.-float(n&0x7fffffffU)/float(0x7fffffff);}//older approach from https://iquilezles.org/articles/sfrand\n return uintBitsToFloat((n>>9U)|0x3f800000U)-1.0;}\n\n/*\nend__.hash\nstart.noise\n*/\n\n//\"noise\" comes down to being a smoothenedHash==HashesNthDerivative\n\n//simple fast smooth noise, uses texture2D() as seed.\n/*float nC(in vec3 x){vec3 p=floor(x),f=fract(x);f=f*f*(3.-2.*f);\t\n vec2 rg=texture2D(iChannel0,((p.xy+vec2(37.,17.)*p.z)+f.xy+.5)/256.,-100.).yx;\n return mix(rg.x,rg.y,f.z);}/**/\n\nvec2 M;\nvec4 noise(vec2 u){u=mod(u,M.x)+M.y; // mod() avoids grid glitch\n u-=.5;return vec4(hash(uint(u.x+iResolution.x*u.y)));}\n\n#define V(i,j)  noise(u+vec2(i,j))\nvec4 bluenoise(vec2 u){//U=floor(U/8.); \n vec4 n=8./9.*noise(u)-1./9.*(V(-1,-1)+V(0,-1)+V(1,-1)+V(-1,0)+V(1,0)+V(-1,1)+V(0,1)+V(1,1));  \n return n*2.+.5;}   // or *1 to avoid saturation at the price of low contrast\n//https://www.shadertoy.com/view/XdScRt\n/*\nend__.noise\nstart.gradient\n*/\n\n#define saturate(x) (clamp(x,0.,1.))\n//IOU hsl2rgb\n//IUO all the nice 3d gradients.\n\n// return color from temperature in kelvin\n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp){\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) return col*Temp/1000.;\n   \treturn col;}\n//to be replaced by\nvec3 blackbody2(float k){float p=pow(k,-3./2.),\n g=0.;//green is approximated in 2 ways, depending on k.\n if(k>6500.)g=138e3*p+.721;else g=.39*log(k)-2.45;\n vec3 c=saturate(vec3(22e4*p+.58,g,.76*log(k)-5.68));\n //if(k<1e3)return c*k*.001;//extra black.\n return c;}\n/*\nend__.gradient\nstart.transform\n*/\n//transform.2d:\n//2d rotation r=3.14 -> half rotation roundrclockwise\n#define r2d(r) mat2(cos(r),-sin(r),sin(r),cos(r))\n//return matrix of complex multiplication of [a] by [b]\n#define cmul(a,b) mat2(a,-a.y,a.x)*b\n//return matrix of complex division       of [a] by [b]\n#define cdiv(a,b) a*mat2(b,-b.y,b.x)/dot(b,b)\n\n//transform.3d\n//return vector [p] rotated by angle [r] around axis [a]\n#define raa(p,a,r) (cos(r)*v+sin(r)*cross(a,v)+(1.-cos(r))*dot(a*p)*a)\n/*\nend__.transform\nstart.trace\n*/\n//raytracing returns intersection points||distances\n//which comes down to solving a 2nd to 6th degree spline\n//for all the points where f(x)=0, with 0 to 6 solutions for 6th gegree splines.\n//Raytacing is useful to calculate bounding shapes for raymarching\n\n//raytracing an elypsoid\n\n//[h.xyz],[h.w]=paneNormal,paneDistanceToVec3(0)\n//[o],[d]=TayOrigin,RayDirection\n//return distance along ray to intersection of plane along ray \nfloat gPRxZ(plane p,ray r){return -((dot(p.n,r.o)+p.d)/(dot(p.n,r.d)));}\n#define PlaneRayDistance(p,r) gPRxZ(p,r)\n//return intersection of ray[r] anf plane[p]\nvec3 gPRdV(plane p,ray r){return r.d*gPRxZ(p,r);}\n#define PlaneRayIntersection(p,r) gPRdV(p,r)\n\nvec3 RayTraceDemo(plane p,ray r){\n float d=PlaneRayDistance(p,r);//ditance=distanceOnRayToPlane\n vec3 c=r.d*fract(d)*pow(d,-.3);//color=fades to black with distance\n vec3 Out=c;\n return Out;}\n\n//#if DemoNum == DemoRaymarch\n//[o]=rayOrgin [d]RayDirection, sets up a planeto collide ray with.\nvec3 RayTraceDemoScene(vec3 o,vec3 d){\n plane p=plane(vec3(0,1,0),1.);\n ray r=ray(o,d);\n vec3 Out=RayTraceDemo(p,r);\n return Out;\n}\n//#endif\n\n//return vector that points from point[p] to nearest place on plane[h]\nvec3 gPXdV(plane h,vec3 p){\n return -(dot(h.n,p)+h.d)*h.n;}\n/*\nend__.trace\nstart.march.sub\n*/\n//raymarching subroutines are distanceField and distanceBound functions.\n//both functions return a distance to the surface of a defined shape.\n//distanceField should return exact euclidean distance.\n//distanceBound can returns a larger distance than that\n//both never return a shorter distance than euclidean distance.\n//but if you bend space, overestimating distances happens easily.\n//...and you \"hit the ground\" sooner than expected,\n//...leading to \"vanishing surfaces\"\n// the compound of all distance estimations is a \"distance field\":\n                                               \n//primarily sorted by number of highest input dimension.\n//secondarily sorted by types; [distance],[transform],[compound]_\n//[distance] =d*  =return float distance of input parameters, 0th parameter is a point.\n//[transform]=p*  =return transformed [p], like; p=matrix*p;\n//            pM* =return #'s of the modulo tile, while inout transforming p;\n//[compound] =fOp*=return distance to booleanIsh-Volume of 2 distances.\n\n#define dd(p) dot(p,p)\n#define am(a,b) (abs(a)-b)\n//1to4d\nfloat vmax(vec2 p){return max(p.x,p.y);}\nfloat vmax(vec3 p){return max(vmax(p.xy),p.z);}\nfloat vmax(vec4 p){return max(vmax(p.xy),vmax(p.zw));}\nfloat vmin(vec2 p){return min(p.x,p.y);}\nfloat vmin(vec3 p){return min(vmin(p.xy),p.z);}\nfloat vmin(vec4 p){return min(vmin(p.xy),vmin(p.zw));}\nfloat vsum(vec2 p){return p.x+p.y;}\nfloat vsum(vec3 p){return vsum(p.xy)+p.z;}\nfloat vsum(vec4 p){return vsum(p.xy)+vsum(p.zw);}\nvec2  vpow(vec2 a,float n){return pow(a,vec2(n));}\nvec3  vpow(vec3 a,float n){return pow(a,vec3(n));}\nvec4  vpow(vec4 a,float n){return pow(a,vec4(n));}\n#define vmm(a) vmax(am(a,0.));\n//distance to sphere with radius (is subroutine)\n#define fSphere(p,r) (length(p)-r)\n#define ml(a,l) max(a,length(l))\n#define fBoxCheap(p,b) return vmax(am(p,b);\n//fBoxCheap() extrudes to box : fBox() extrudes to ROUNDED box\n\n//https://iquilezles.org/articles/distfunctions\n#define lengthN(a,e) pow(vsum(vpow(a,e)),1./e)\n//#define length8(a) pow((pow(a,vec2(8.)),vec2(1./8.)))\n//1d.p*         == simple linear algebra: y=f(x);\nfloat pSgn(float x){return step(x,0.)*2.-1.;}//return (x<0)?-1:1;\n//hull-curves with descriptive names: p[-1..1] r[0..1] -> .y[0..1]\n//https://www.shadertoy.com/view/lsscR2\n//#define powm(a) (1.-pow(a))\n#define fpr float p,float r){return\nfloat pTongueButt     (fpr 1.-pow(       abs(p)       ,r);}\nfloat pTongueIncube   (fpr 1.-pow(max(0.,abs(p)*2.-1.),r);}\nfloat pTongueSinButt  (fpr 1.-pow(abs(sin(pi2*p)),r);}\nfloat pSinSphereOncube(fpr pow(    cos(pi2*p)           ,r);}\nfloat pTentDomeOncube (fpr pow(min(cos(pi2*p),1.-abs(p)),r);}\n//below function is parametric composition of abive.\nfloat pUber(float p,float r,float one,float m){\n float c=cos(pi2*p);\n float inf=1.;//not sure if this should be 1,2,10 or LargestFloat\n inf=mix(inf,1.-abs(p),m);\n float a=pow(min(c,inf),r);\n return mix(a,1.-a,one);}\n/*\n//tent-shaped hull curves\n    vec2 u = fragCoord.xy / iResolution.xy;\n\t//u.x = (u.x - 0.5) * 2.0;\n    u.x*=iResolution.x/ iResolution.y;\n    u.x-=1.;\n    float a = (0.5 + 0.5 * sin(iTime)) * 5.5;\n    //a=.5;\n    float r=pTongueButt(u.x,a);\n    float g=pTongueIncube(u.x,a);\n    float b=pTongueSinButt(u.x,a);\n    float y=pSinSphereOncube(u.x,a);\n    float p=pTentDomeOncube(u.x,a);\n    //col.r +=fract(r -uv.y);\n    //col.g +=fract(g -uv.y);\n    //col.b +=fract(b -uv.y);\n    //col.rg+=fract(y-uv.y);\n    //col.rb+=fract(p-uv.y);\n    col+=vec3(fract(mix(p,g,.5)-uv.y));\n*/\n// convert distance to alpha for nice \"logarytmhic glow\"\nfloat pToa(float d,float a){a=1./a;\n return clamp(a/(clamp(d,a,1.)),0.,1.);}\n//usage as in https://www.shadertoy.com/view/XtjGzt\n//c=mix(c,vec4(1,.5,0),.7 *pToa(distance,60.));\n\n//1d pM*\n#define pmm p*=mod(c,2.)*2.-1.;return c;}\n#define pm c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMod1(inout float p,float s){\n float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);pmm\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);\n if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=tau/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;//s=step(p,0.)*2.-1.;\n p=am(p,d);return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\n//bend around point that is offset -20. on the p.y axis.\nvec3 pCheapBend(vec3 p){return vec3(r2d(20.*p.y)*p.xy,p.z);}\n//ztwist p around p,y axis.\nvec3 pTwist( vec3 p ){return vec3(r2d(20.*p.y)*p.xz,p.y);}\nvoid pR(inout vec2 p,float r){p=cos(r)*p+sin(r)*vec2(p.y,-p.x);} \n//eight-rotation (45°/360°)\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*p222;}\n//2d.f\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=am(p,b);//fBox2()=ROUNDED box,different in 3d and 2d.\n return length(max(d,0.))+vmm(p)} \n//egg= weighted ellipse -> \"Cartesian Oval\" //.z=weightFactor\nfloat fEllipseW(vec2 p,vec3 a,vec3 b,float r){\n return length(p-a.xy)*a.z+length(p-b.xy)*b.z-r;}\n//https://www.shadertoy.com/view/lld3DS\nfloat fNgon(in vec2 p,float N){p=p*2.-1.;//centring\n float a=atan(p.x,p.y);//a=atan(p.x/p.y);//fast mirrored\n return cos(floor(.5+a*N/tau)*tau/N-a)*length(p);  \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p); \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p)*length(p);\n}//https://www.shadertoy.com/view/4ldXDn\n//squircle  http://en.wikipedia.org/wiki/Squircle\nfloat sdSquircle(vec2 p, float r, float w){p=abs(p);\n return vsum(pow(p,vec2(w)))-pow(r,w);}\n#define vas vec2(0.,asin(1.))\n//return signed distance of [p] to a line that goes trough [a] and is orthogonal to a line trough [a] and [b].\nfloat sdline(vec2 p,vec2 a,vec2 b){vec2 c=b-a;\n vec2 m=vec2(sin(atan(c.x,c.y)+vas));return dot(p,m)-dot(a,m);}\n//...rotate p around (h.z,0,0) by -quaterRotation-atan(b.x,b.y) and only return .y\nfloat q(vec2 p,vec3 h,vec2 b){return dot(p+vec2(-h.z,0),sin(atan(-b.y/b.x)+vas))-h.y;}\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//return distace of p to 2 circles and their tangents.\n//h.xy=circle radii; h.z distance.x between sphere centers  \n//h.x>=h.y>0.0 ! h.z>=h.x-h.y, else there is no tangent\nfloat TangentCapsule(vec2 p,vec3 h){h.x=max(h.x,h.y);//cheap constrain\n #define ib ifb(-sdline(p,a\n p.y=abs(p.y);float s=h.x-h.y,i=cci(vec3(s,vec2(h.z*.5)));//h.x>h.y!\n vec2 a=vec2(i,sqrt(s*s-i*i)),b=vec2(h.z,0)-a;\n float e=length(p-vec2(h.z,0))-h.y,f=length(p)-h.x,g=ib+b,a-b),e,q(p,h,b));\n return ib,a+b),f,g);}//https://www.shadertoy.com/view/4sBcWh\n\n#define lvmm(a,b) return length(max(a,0.))+vmm(b)}\nfloat fCorner(vec2 p){lvmm(p,p)\nfloat fDisc(vec3 p,float r){\n float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\n//2d.pM*\nvec2 pMod2(inout vec2 p,vec2 s){vec2 pm\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);pmm\nvec2 pModGrid2(inout vec2 p,vec2 size){\n vec2 c=floor((p+size*.5)/size);\n p=mod(p+size*.5,size)-size*.5;\n p*=mod(c,2.)*2.-vec2(1);p-=size*.5;\n if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){\n vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);\n pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}                    \n//3d.f\n\n//[n]planeNormal [d]=planeDistanceToVecN(0) (aka. hessian normal form)\n#define fPlane(p,n,d) (dot(p,n)+d)\n#define pa in vec3 p,in vec3 a\n#define pab pa,in vec3 b                                     \n#define pr in vec3 p,in float r\nfloat fBox(pa){vec3 q,d=am(p,a);//fBox()=ROUNDED box,different in 3d and 2d.\n return length(max(d,0.))+vmax(min(d,0.));}\nfloat fBlob(vec3 p){p=abs(p);//no clue\n if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;\n float l=length(p),b=max(max(max(dot(p,vec3(p323)),dot(p.xz,eA)),dot(p.yx,eB)),dot(p.xz,eB));\n return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*pi,pi));}\nfloat fCylinder(pr,float h){//extrudes to cylinder\n return max(fSphere(p.xz,-r),am(p.y,h));}\nfloat fLineSegment(pab){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\n//lineSegment() has other input values than fCapsule()\nfloat fCapsule(pab,float r){return fLineSegment(p,a,b)-r;}\n//above is smarter reuse of code\nfloat fCapsule(pr,float c){\n return mix(length(p.xz)-r,fSphere(vec3(p.x,am(p.y,c),p.z),r),step(c,abs(p.y)));}\nfloat fTorus(pr,float c){//r and i input positions swapped!\n return fSphere(vec2(fSphere(p.xz,r),p.y),c);}\n//fCircle() is a torus were r sets both radii.1sub less\n#define fCircle(p,r) length(vec2(p.y,fSphere(p.xz,r)))\n//https://iquilezles.org/articles/distfunctions\n#define hm1 vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*p322\nfloat fTriPrism           (hm1+p.z*.5,-p.z)-h.x*.5);}\nfloat fHexagonCircumcircle(hm1+q.z*.5, q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*p322,h.y));}\nfloat fCone(pr,float h){\n vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));\n float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);\n if(q.y>h&&j<0.)d=ml(d,t);\n if(q.x>r&&j>length(vec2(h,r)))d=ml(d,q-vec2(r,0.));return d;}\nfloat fEllipsoid(in vec3 p,in vec3 r){\n return fSphere(p/r,1.)*vmin(r);}\n//euclidean distance(a,b)=length(a-b) has exponent[n]=[2]; here [n] can be other EVEN number exponents.\nfloat fTorusN2( vec3 p,vec2 t,float n){\n return lengthN(vec2(length(p.xz)-t.x,p.y),n)-t.y;}\nfloat fTorus82(vec3 p,vec2 t){return fTorusN2(p,t,8.);}\nfloat fTorusNN(vec3 p,vec2 t,float n1,float n2){\n vec2 q=vec2(lengthN(p.xz,n1)-t.x,p.y);return lengthN(q,n2)-t.y;}\nfloat fUnterprim(vec3 p,vec4 s,vec3 r,vec2 ba,float sz2){\n vec3 d=abs(p)-s.xyz;float q=length(max(d.xy,0.))+min(0.,max(d.x,d.y))-r.x;\n #ifndef CONVEX    \n q=abs(q)-s.w;\n #endif    \n vec2 px=vec2(q,p.z-s.z),\n diag=px-vec2(r.z,sz2)*clamp(dot(px,ba),0.,1.),\n h0=vec2(max(q - r.z,0.0),p.z + s.z),\n h1=vec2(max(q,0.0),p.z-s.z);\n return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n  *sign(max(dot(px,vec2(-ba.y,ba.x)),d.z))-r.y;}\n//https://www.shadertoy.com/view/MsVGWG\n//[s]=width,height,depth,thickness\n//[r]=xy corner radius,zCornerRadius,bottomRadiusOffset\nfloat fUberprim(vec3 p, vec4 s, vec3 r){//these operations can be precomputed\n s.xy-=r.x;\n #ifdef CONVEX  \n r.x-=r.y;\n #else\n r.x-=s.w;s.w-=r.y;\n #endif\n s.z-=r.y;vec2 ba=vec2(r.z,-2.*s.z);return fUnterprim(p,s,r,ba/dd(ba),ba.y);}\nfloat fUcube    (vec3 p){return fUberprim(p,vec4(1),vec3(0));}\nfloat fUcylinder(vec3 p){return fUberprim(p,vec4(1)          ,vec3(1,0,0));}\nfloat fUcone    (vec3 p){return fUberprim(p,vec4(0,0,1  ,1  ),vec3(0,0  ,1));}\nfloat fUpill    (vec3 p){return fUberprim(p,vec4(1,1,2  ,1  ),vec3(1,1  ,0));}\nfloat fUsphere  (vec3 p){return fUberprim(p,vec4(1          ),vec3(1,1  ,0));}\nfloat fUpellet  (vec3 p){return fUberprim(p,vec4(1,1,.25,1  ),vec3(1,.25,0));}\nfloat fUtorus   (vec3 p){return fUberprim(p,vec4(1,1,.25,.25),vec3(1,.25,0));}\nfloat fUpipe    (vec3 p){return fUberprim(p,vec4(1          ),vec3(1,.1 ,0));}\nfloat fUcorridor(vec3 p){return fUberprim(p,vec4(1,1,1  ,.25),vec3(1,.1 ,0));}\n\n//3d.pM*\n                      \n//quaternions q()<->creation r()<->rotaition\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nvec4 q(vec4 q){return q/dot(q,q);}\n//above is faster alternative to [normalize(q)] that only works for SOME situatinons;\n//return quaternin of [axis]&{angle] rotation\nvec4 q(vec3 axis, float angle){angle*=.5;return q(vec4(axis*sin(angle),cos(angle)));}\n//return [r]rotation, rotated by [b] //use like matrix multiplication\nvec4 r(vec4 b,vec4 r){return q(vec4(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz)));}\n//return [r]vector, rotated by [b] //use like matrix multiplication\nvec3 r(vec4 b,vec3 r){vec3 t=2.*cross(b.xyz, r);return r+b.w*t+cross(b.xyz,t);}\n//from  https://www.shadertoy.com/view/lstSRM\n                      \n//return s3d sinusoidial \"blob_displacement\" of [p].\n#define pBlob(p) (sin(p.x)*sin(p.y)*sin(p.z))\nvec3 pMod3(inout vec3 p,vec3 s){vec3 pm\n                      \n//1d.fOp* take 2 distances (a,b) + parameters ([r][ra][rb]=radii,[n]=NumberOfThings)\n//*union*     ==a || b, volumetric union        == both volumes together\n//*intersect* ==a && b, volumetric intersection == only the shared volume\n//*difference*==a &&!b, volumetric difference   == volumeA-VolumeB\n//\n//*Chamfer ==diagonal cut\n//*Round   ==negative cylinder cut          \n//*Columns ==positive cylinder cut\n//*Stairs  ==stair cut\n//*Soft    ==cubic \"melt\"\n\n#define ac4(b) (a-b)*p222)\n#define mac4(a,b) max(a,ac4(b)\nfloat fOpUnionChamfer       (float a,float b,float r){\n return min(min(a,b),ac4(r+b);}\nfloat fOpIntersectionChamfer(float a,float b,float r){\n return mac4(max(a,b),-b);}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat fOpUnionRound(float a,float b,float r){\n vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){\n vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n#define eM(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat fOpUnionColumns eM(1.)p.x+=p222*(-r)+p222*(c*2.);\n if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);\n return min(min(min(length(p)-c,p.x),a),b);}\nfloat fOpDifferenceColumns eM(-1.)p.y+=c;p.x-=p222*(r+c);\n if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);\n return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat fOpUnionStairs(float a,float b,float r,float n){\n float s=r/n;float u=b-r;\n return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n//a smoother fOpUnionRound(), by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}\n//cylindical pipe that runs along the intersection.\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\n//// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\n// first object gets a U-shaped capenter-style groove cut out\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\n// first object gets a capenter-style tongue attached (negative groove)\nfloat fOpTongue(float a,float b,float ra,float rb){return min(a,max(a-ra,abs(b)-rb));}\n//metabally union of 7: //https://www.shadertoy.com/view/Xls3R7\nfloat fOpBlob7(float d1,float d2,float d3,float d4,float d5,float d6,float d7){float k=-2.;\n return -log(exp(k*d1)+exp(k*d2)+exp(k*d3)+exp(k*d4)+exp(k*d5)+exp(k*d6)+exp(k*d7))/-k;}\n//use cases for hg_sdf distancefunctions\nfloat hg_sdf_demo(vec3 p){\n float t=sin(time)*.01+.02;\n mat2 m=r2d(time*.1);//rotation.2d\n //rotate world==rotate camera\n //p.yz*=m;p.xy*=m;//uses same 2d rotation 2x on different axes\n \n #ifndef hgSdfShowUber\n  //pMirrorOctant(p.xy,vec2(1.,1.));\n  pModMirror1(p.x,.5);  \n  pModMirror1(p.y,.5);\n  pModMirror1(p.z,.5);\n  m=r2d(time*.5);//rotation.2d\n  //rotate within tile-grid\n  //p.yz*=m;p.xy*=m;//uses same 2d rotation 2x on different axes\n #else\n  p-=vec3(0,0,4);\n  p*=2.;\n  p=p.zxy; \n  m=r2d(time*.2);\n  p.yz*=m;p.xz*=m;//uses same 2d rotation 2x on different axes\n  return fUberprim(p,vec4(0,4,2,0)*.2,vec3(-2,1.5,1.5));\n  return fUcorridor(p)-t*20.;\n  return fUcylinder(p)-t*20.;\n  return fUpipe(p)-t*20.;//rounded cylinder\n  return fUtorus(p)-t*20.;\n  return fUpellet(p)-t*20.;\n  return fUsphere(p)-t*20.;\n  return fUpill(p)-t*20.;\n  return fUcone(p)-t*20.;\n  return fUcylinder(p)-t*20.;\n  return fUcube(p)-t*20.;\n  #endif\n  \n  //return fdEllipsoid(p,vec3(1,2,3)*.05);\n  //return fPlane(p,vec3(2,2,0),1.);\n  float roundedSquareFrame=fTorusNN(p,vec2(.1,.0),4.,2.)-t;\n  float wheel             =fTorusN2(p,vec2(.1,.01),4.)-t;\n  //return wheel;\n  //return roundedSquareFrame;\n  float sphere  =fSphere(p,.08);\n  float cone    =fCone  (p,.02,.06)-t;\n//float circle  =fCircle(p,.05    )-t;//torus with less params\n  float torus   =fTorus (p.yxz,.03,.08)-t;\n//float disc    =fDisc  (p,.01    )-t;\n  float hex     =fHexagonCircumcircle(p,vec2(0.06,0.05))-t;\n  float triprism=fTriPrism(p,vec2(.1,.02))-t;\n  //  return triprism;\n  //return fHexagonIncircle(p,vec2(0.05,0.01))-t;\n//float capsule =fCapsule(p,.02,.04)-t;\n//float cylinder=fCylinder(p,.05,.02)-t;\n//float blob    =fBlob(p*.1); //???\n\n  //return sphere;\n  \n  float box     =fBox(p,vec3(.05))-t;\n//float bxcheap =fBoxCheap(p,vec3(.05))-.01;\n//float sphere  =fSphere(p,.1);\n  //return fOpIntersectionChamfer(box-.02,torus-.02,1.07);\n  //return fOpUnionSoft(torus,hex,.02);\n  //return fOpUnionColumns(torus,hex,.03,6.);\n  //return fOpUnionStairs(torus,hex,.03,6.);\n  //return fOpEngrave(hex,torus,.03);\n  //return fOpGroove(hex,torus,.03,0.04)-.01;\n  return fOpPipe(hex,torus,.03)+.01;\n  return hex;\n}\n\n//return distance of [p] to closest surface, defined by function.\nfloat df(vec3 p){\n  #ifdef hgSdf\n  vec3 h=p; h.z-=.1;h.x-=.1;return hg_sdf_demo(h);\n  #endif\n  p=fract(p);\n  float t=time*.1;\n  float k=20.*(sin(t*5.)*.5+.9);//blobbyness\n  return length(p*1.-0.5)-.2+.1*pBlob(k*p);}\n\nvec3 Gradient(vec3 p,float d){vec2 e=vec2(.001,0);p*=99.;\n return (vec3(df(p+e.xyy),df(p+e.yxy),df(p+e.yyx))*99.-d)/e.x;}\nvec3 Normal(vec3 p){vec2 e=vec2(.01,0);return normalize(vec3(\n df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}\nvec3 Normal2(vec3 p){if(df(p)<.03)return Normal(p);return vec3(0);}\n/*\nend__.march.sub\nstart.march.main\n*/\n//rm3 does 2*df() per rmIterations, but the loop unrolls to less code.\nvoid rm3(vec3 o,vec3 r,inout float t,inout float t2){for(int i=0;i<rmIterations;++i){\n  float d2=df(o+r*t2);\n  if(d2>eps)t2+=d2*.5;\n  float d=df(o+r*t);\n  t+=d*.5;\n  #ifdef dynamicEps\n  d=pow(d,pow(t,.5));\n  #endif\n  if(d<eps*.05)break;\n }}//calculating 2 distances at once is useful to:\n//- better visualite a distance field. -> analyze errors in the df easier.\n//- - it basically visualizes ONE first derivative!!!\n//- - as a transparent cartoon outline\n            \n//////raymarch.end\n//\n//////main.start\n            \nvoid mainImage(out vec4 Out,in vec2 In){\n vec2 u=In.xy/iResolution.xy-.5;\n u.x*=iResolution.x/iResolution.y;\n vec3 o=vec3(0,0,-.2);//ray.Origin\n vec3 r=normalize(vec3(u,1));//ray.Direction\n mat2 m=r2d(time*.2);//rotation.2d\n r.yz*=m;r.xy*=m;//uses same 2d rotation 2x on different axes\n \n // Out=vec4( RayTraceDemoScene(o,r),1);return;\n  vec3 p;//point were a surface was hit\n  float t=0.,t2=0.;\n  rm3(o,r,t,t2);\n  #if DemoNum == DemoHgSdf\n   //p=mix((o+r*t2),Normal2(o+r*t)*.5+.5,1.0);\n   //p=Gradient((o+r*t2),.01)*.5+.5;\n    p=Normal2(o+r*t)*.5+.5;\n  #else\n   p=o+r*t2;\n   p=fract(p)*mod(p,3.)*t2*t2/(t*t*t);\n  #endif\n  //p=vec3(fract(t),fract(t2),0.);\n\n/*\n //STATIC-Image Zenos-Paradox of Achilles-Tortoise multipass :\n vec3 pp=texture(iChannel0,In/iResolution.xy).rgb*float(iFrame);\n //Out=vec4((pp+p*.5)/float(iFrame+1),1);\n //every extra frame has a diminishing impact, approaching null.\n/**/\n    \n //gamma correction\n p=pow(p,vec3(1.075));\n Out=vec4((p)*.5,1);\n //#endif\n\n //dependant multipass\n //from https://www.shadertoy.com/view/XdjyDw\n float convergeSpeed=0.2;//set blur amount\n convergeSpeed=length(u)*.25;//blurry peripheral vision.\n //example for dependant convergeSpeed.\n //float DeltaV=-iMouse.z;\n //convergeSpeed-=DeltaV>0.||iFrame< 20?.4:.996;\n //haing the above -=y makes it visualize delta of movvement.\n if(iFrame<=1)convergeSpeed=0.;\n Out.rgb = mix(Out.rgb, texture(iChannel0, In/iResolution.xy).rgb, convergeSpeed);\n if(iFrame>1)convergeSpeed=0.;\n Out.rgb = mix(Out.rgb, texture(iChannel0, In/iResolution.xy).rgb, convergeSpeed);\n\n /**/\n}\n\n//the i am tired dump:\n            \n//todo, i actually need a linear equation solver up to 6th gedree curves?\n//for many things, but mostly just to raytrace.\n//for that i need my decent 2d canvvas\n\n//pow(x,y) is internally doing exp(log(x)*y)\n//pow(2,y) is faster as pow2(y);\n\n// continuous angle from atan\nfloat cAtan(vec2 p){\n if (p.x< 0.) return acos(-1.)-atan(p.x,-p.y);\n return atan(p.x,p.y);}\n\n/*memos\n\n\n\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\nhttps://en.wikipedia.org/wiki/Contour_line\nhttps://en.wikipedia.org/wiki/Isosurface\nlink surface nets to distance fields.\n\n//what i still havenver done:\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n//optimizing\nhttps://en.wikipedia.org/wiki/Volume_rendering#Optimization_techniques\n\n\nsyntax:\nhttps://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Arrays\nconst float array[3] = float[3](2.5, 7.0, 1.5);\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//reserved for keyboard Input\n//sure would be nice to have glyphs show up in here\n//but glyphs are more useful to shapes than to keyboard input\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n //   fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}