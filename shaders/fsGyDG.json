{
    "Shader": {
        "info": {
            "date": "1655483313",
            "description": "an improvement with two less texture lookups of Catlike Coding's Direction Flow [url]https://catlikecoding.com/unity/tutorials/flow/directional-flow/ [/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "fsGyDG",
            "likes": 17,
            "name": "Directional Flow Hexagon",
            "published": 3,
            "tags": [
                "wave",
                "water",
                "hexagon",
                "barycentric",
                "flow",
                "hex",
                "directional",
                "vectorfield",
                "direction"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 583
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nUpdate: I created an even faster version Square Directional Flow \n(https://www.shadertoy.com/view/7dtBWl).\n\nThis is an improved version of the Directional Flow algroithm. It only uses\n6 texture lookups instead of 8. It does this by switching the square grid \npattern to a hexagonal grid pattern.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe previous 8 sample Directional Flow is implemented in shadertoys here:\nhttps://www.shadertoy.com/view/fsKczd\n\nHere is my Rhombic Dodecahedron Tiling to have Hex Directional Flow in 3D:\nhttps://www.shadertoy.com/view/fddfRn\n\nHere is a diffeent use case with cyclone windwaves:\nhttps://www.shadertoy.com/view/7dycDV\n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n//#define ShowGrid\n\n#define SQRT3 \t\t\t1.7320508076 //sqrt(3)\n#define HALF_SQRT3\t\t0.8660254038 //sqrt(3)/2\n#define INV_SQRT3\t\t0.5773502693 // 1/sqrt(3)\n#define INV_TWO_SQRT3 0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\n#define R vec2(1, SQRT3) // 1, sqrt(3)\n#define H vec2(0.5,HALF_SQRT3) // 1/2, sqrt(3) /2\n\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, H), p.x);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\ntilingVal hexTile(vec2 uv) {   \n    vec2 a = mod(uv, R)-H;\n    vec2 b = mod(uv-H, R)-H;\n    \n    vec2 grid = dot(a, a) < dot(b,b) ? a : b;    \n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(grid))*2.; //  Edge distance with range 0-1    \n    // float cdist = dot(gv, gv); // squared distance from the center.\n    vec2 id = uv-grid; // simple ID calculation\n    \n    return tilingVal(grid, id, edist);  // make tilingVal struct\n}\n\n// makes a hexagon pixelized pattern without offset\ntilingVal hexPixelizor(vec2 uv, float gridRes, vec2 offset) {\n    // generate hex grid tiling\n    tilingVal tiling = hexTile(uv * gridRes + offset); \n    // generate square grid tiling    \n    tiling.id = (tiling.id - offset)/gridRes; //pixaltion    \n    return tiling;\n}\n\n// 3 hex pixaled flowing textures thier edges get hidden by each other\nvec3 hexDirectionalFlow(sampler2D tex, sampler2D flow, vec2 uv, \n                           float gridRes, float time, float contrast) { \n    // generate grid values each is at the corners of the others\n    tilingVal A = hexPixelizor(uv, gridRes, vec2(0.));\n    tilingVal B = hexPixelizor(uv, gridRes, vec2(0,INV_SQRT3));\n    tilingVal C = hexPixelizor(uv, gridRes, vec2(0.5,INV_TWO_SQRT3));\n\n    // sample flow map in each grid\n    vec2 flowA = flowMap(flow, A.id);\n    vec2 flowB = flowMap(flow, B.id);\n    vec2 flowC = flowMap(flow, C.id);\n    \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so constant\n    A.grid *= 2.0;\n    B.grid *= 2.0;\n    C.grid *= 2.0;\n    \n    // rotate and offset then sample texture\n    vec3 gridA = PanDirectionalTex(tex, A.grid, flowA, time);\n    vec3 gridB = PanDirectionalTex(tex, B.grid, flowB, time);\n    vec3 gridC = PanDirectionalTex(tex, C.grid, flowC, time);\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // interpolate result\n    vec3 col = gridA * alpha.x + gridB * alpha.y + gridC * alpha.z;\n    \n#ifdef ShowGrid\n    // overlaying the edges of the alpha mask\n    float lineThickness = 0.03; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return max(mask, col);\n#else\n    return col;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {    \n    float time = iTime* .4; // flow speed multiplier\n    float gridRes = 8.; // the number of subdivisions for the sampling of the flowmap\n    float contrast = 2.;  // 1-inf, increased the contrast between the tiles\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n\n    vec3 hdf = hexDirectionalFlow(iChannel0, iChannel1, uv, gridRes, time, contrast);\n    \n    #ifndef  ShowGrid   \n    hdf += vec3(0.0,0.2,0.5); //adding arbitrary watery color\n    #endif\n    \n    fragColor = vec4(hdf, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal {\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction)\n{\n    // Normalize the direction vector\n    direction = normalize(direction);\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        direction.x, -direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// rotates and animates texture in flowmap direction \nvec3 PanDirectionalTex (sampler2D sam, vec2 uv, vec2 flowMap, float time) {  \n    uv += flowMap*time; // add offset with time\n\n    uv = rotateUV(uv, flowMap); // rotate UVs\n    \n    return texture(sam, uv).xyz; // sample texture\n}\n\n// generates a -1-1 smooth flowmap\nvec2 flowMap(sampler2D sam, vec2 uv) {\n    //a random spot in the noise map, normally you use an actual flowmap\n    vec2 flowMap = texture(sam, uv*0.05).xy;\n    return flowMap * 2. -1.; // constant bias scale for -1 to 1 range\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}