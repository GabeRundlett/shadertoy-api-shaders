{
    "Shader": {
        "info": {
            "date": "1618834721",
            "description": "The Spheres-Torus quartic surface, raytraced with reflections.\nbased on\nmla@[url]https://www.shadertoy.com/view/3tVcWV[/url]\nFabriceNeyret2@[url]https://www.shadertoy.com/view/4ljyWc[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "NsXSRj",
            "likes": 7,
            "name": "Mirrored Spheres-Torus Surface",
            "published": 3,
            "tags": [
                "reflection",
                "torus",
                "sphere",
                "raytrace",
                "cubic",
                "quartic",
                "lanczos"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 405
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Mirror Spheres-Torus Quartic Surface\"\n//\n// based on original code \n// - mla --- Goursat Quartic Surface --- https://www.shadertoy.com/view/wsXGWS\n// - FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\n// - cyperus --- ispheres2torus Quartic Solver --- https://www.shadertoy.com/view/tddcRB\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting parameters\n// 'c': clip at x = 0\n// 'g': show grid\n// 'r': do rotation\n// 'm': mirror surface\n// 's': no reflections\n// 'p': plain colouring\n//\n// Quartic surfaces with rotational symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos with\n// cubic solver from Numerical Recipes, plus some Newton-Raphson polishing.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n// Animation\nfloat animvelocity = 0.25;    \n//#define NEAREST\n//#define LINEAR\n#define CUBICLINEAR\n//#define CATMULL    \n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Sort into descending order\n  if (nroots > 1 && roots.x < roots.y) roots.xy = roots.yx;\n  if (nroots > 2) {\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    if (roots.x < roots.y) roots.xy = roots.yx;\n  }\n  // And select the largest\n  float psi = roots[0];\n  // There _should_ be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  if (psi < 0.0) assert(evalcubic(psi,1.0,B,C,D) < 0.0);\n  // If so, nudge in the right direction\n  psi = max(1e-6,psi);\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to give the least wild behaviour.\n  if (abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n};\n\nint spheres2torussurface(Surface surface, in vec3 o, in vec3 d, out vec4 roots) {\n    \n\t/*\n\tray is defined by p(t) = o + t*d\n\tin vec3 p : intersection point (x,y,z)\n\tin vec3 o : ray-origin\n\tin vec3 d : ray-direction\n\tout vec4 roots: values roots\n\tout int number solutions from{0,1,2,3,4}\n    \n    surface is defined by (x^2+y^2-z^2-co)^2+4.0*(x^2+y^2)*z^2-cr^2=0\n    float cr : circle radius\n\tfloat co : circle origine\n\tafter some calculations you get the quartic equation\n\tA * t^4 + B * t^3 + C * t^2 + D * t^1 + E = 0\n\t*/\n    \n\t// not used = surface.params[0];\n\t// not used = surface.params[1];    \n\tfloat co = surface.params[2];    \n\tfloat cr = surface.params[3];\n    \n\n    if (co == 0.) {\n        //Sphere => quadratic equation\n        vec2 res;\n        int resn = quadratic(1.0, 2.0*dot(o,d), dot(o,o)-cr*cr, res);\n        roots = vec4(res, 0.,0.);\n        return resn;\n    }\n    else{\n    \t// commun factors\n        float oo2 = o.x*o.x+o.y*o.y, oo3 = oo2-o.z*o.z; // squares\n        float dd2 = d.x*d.x+d.y*d.y, dd3 = dd2-d.z*d.z;\n        float od2 = o.x*d.x+o.y*d.y, od3 = od2-o.z*d.z; // mixed products\n        float k = co*co-cr*cr; // const\n        // quartic equation coefficients\n        float A = \t dd3*dd3\n                    +4.0*dd2*d.z*d.z;\n        float B =  4.0*(\n                    +od3*dd3\n                    +2.0*d.z*(od2*d.z+dd2*o.z)\n                        );\n        float C =  2.0*(\n                    +(2.0*od3*od3+dd3*oo3) \n                    -co*dd3\n                    +2.0*(oo2*d.z*d.z+4.0*od2*o.z*d.z+dd2*o.z*o.z)\n                        );\n        float D =  4.0*(\n                    +oo3*od3\n                    -co*od3\n                    +2.0*o.z*(oo2*d.z+od2*o.z)\n\t\t\t\t\t);\n        float E = \t oo3*oo3\n                    -2.0*co*oo3\n                    +4.0*oo2*o.z*o.z\n                    +k;\n  \n      return quartic(A,B,C,D,E,roots);\n      }\n}\n\nvec3 spheres2torusnormal(Surface surface, vec3 p) {\n\t// not used = surface.params[0];\n\t// not used = surface.params[1];    \n\tfloat co = surface.params[2];    \n\tfloat cr = surface.params[3];\n    \n    // surface gradient\n    if (cr == 0.) \n        return 2.*p;\n    else\n        return 4.0*((p.x*p.x+p.y*p.y-p.z*p.z-co)*vec3(p.x,p.y,-p.z)\n                    + 2.0*p.z*vec3(p.x*p.z,p.y*p.z,p.x*p.x+p.y*p.y));\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  return spheres2torussurface(surface,p0,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  return spheres2torusnormal(surface,p);\n}\n  \nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!key(CHAR_C) || p.x > 0.0) { // clip at x == 0\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  basecolor *= gridline(p);\n  if (key(CHAR_P)) basecolor = vec3(0.8);\n  result.p = p; result.n = n; result.color = applylighting(basecolor,p,n,r);\n  return true;\n}\n\nSurface surface;\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float att = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // If we've hit the surface some distance from origin,\n    // stop reflecting.\n    if (dot(p,p) > 1000.0) break;\n    // Solve from closest point to origin.\n    // This makes p.r = 0.\n    float tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(surface,p,r,-tmin,res)) break;\n    if (key(CHAR_P) || key(CHAR_S)) return res.color;\n    color += att*res.color;\n    att *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (key(CHAR_P)) return vec3(0.5);\n  if (key(CHAR_M)) return texture(iChannel1,r).xyz;  \n  return color + att*pow(abs(r),vec3(2));\n}\n\n// animation spheres2torus surface\nint nanimparams = 10;\nvec4 animparams(int i) {\n  if (i == 0) return vec4(0,0,0,1);\n  if (i == 1) return vec4(0,0,-1,1);\n  if (i == 2) return vec4(0,0,-1,1);\n  if (i == 3) return vec4(0,0,3,1);\n  if (i == 4) return vec4(0,0,3,1);  \n  if (i == 5) return vec4(0,0,-3,1);\n  if (i == 6) return vec4(0,0,-3,1);\n  if (i == 7) return vec4(0,0,1,1);\n  if (i == 8) return vec4(0,0,1,1);\n  else        return vec4(0,0,0,1);\n\n}\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\n// by FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\nvec4 nearest(vec4 v1) {\n    return v1;\n    }\n\nvec4 linear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,t);\n    }\n\nvec4 cubiclinear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,smoothstep(0.,1.,t));\n    }\n\nvec4 catmull(vec4 v0, vec4 v1, vec4 v2, vec4 v3, float t) {\n\tvec4 A0 = mix( v0, v1, t+1.),\n\t     A1 = mix( v1, v2, t),\n\t     A2 = mix( v2, v3, t-1.),\n         B0 = mix( A0, A1, .5*t + .5),\n\t     B1 = mix( A1, A2, .5*t);\n\treturn mix( B0, B1, t);\n    }\n\nvoid init() {\n  float ttime = animvelocity*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  \n  vec4 params;\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nanimparams;+1;\n  if (isurface == 0) {\n    // get parameter id for interpolation\n    ivec4 param_id = ivec4(\n        int(rtime-1.0)%nanimparams,\n        int(rtime)%nanimparams,\n        int(rtime+1.0)%nanimparams,\n        int(rtime+2.0)%nanimparams);\n    // get parameter values with selected interpolation\n    #ifdef NEAREST\n    params = nearest(animparams(param_id[2]));\n    #endif\n    #ifdef LINEAR    \n    params = linear(animparams(param_id[1]),\n                    animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CUBICLINEAR \n    params = cubiclinear(animparams(param_id[1]),\n                         animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CATMULL \n    params = catmull(animparams(param_id[0]),\n                     animparams(param_id[1]),\n                     animparams(param_id[2]),\n                     animparams(param_id[3]), ttime);\n    #endif\n  } else {\n    params = animparams(isurface-1);\n  }\n  surface = Surface(params,vec3(0));\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  init();\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = normalize(vec3(uv, 2.0));\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#define assert(x)\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}