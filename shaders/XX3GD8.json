{
    "Shader": {
        "info": {
            "date": "1716527538",
            "description": "This was supposed to be a simple experiment, but it got away from me. I think this ended up looking quite nice. More details in the shader itself.",
            "flags": 0,
            "hasliked": 0,
            "id": "XX3GD8",
            "likes": 6,
            "name": "Brick Building",
            "published": 3,
            "tags": [
                "3d",
                "brick",
                "bulding"
            ],
            "usePreview": 0,
            "username": "triggthediscovery",
            "viewed": 113
        },
        "renderpass": [
            {
                "code": "// This is a long one, I know. there's probably a lot\n// which could be paired down, but I think this is a\n// good place to leave it for now. The const variables up \n// here control a lot of the parameters, you can \n// add windows, make them bigger, ect.\n// \n// The way this works from a high level is you break the\n// surface of the building into subsections, which it\n// will then trace into to draw the windows. This\n// means the performace is independent on the number \n// of windows, but it also means the 3D effect disappears \n// at sharp angles. \n//\n// provided under CC0.\n\nconst float brick_scale = 0.05;\nconst float brick_outline = brick_scale/5.0;\n\nconst float window_scale = 0.23;\nconst float window_outline = window_scale/4.5;\n\nconst vec3 windowframe_color = vec3(0.6,0.4,0.1)*0.8;\nconst vec3 window_color = vec3(0.5,0.6,0.9)*0.8;\nconst vec3 brick_mortar_color = vec3(.7);\n\n// This only really works with numbers in the form x.5\n// e.g. 1.5, 2.5, 3.5, ect.\nconst float num_windows = 3.5;\n\nvec3 light_dir;\n\nstruct NormAndUV {\n    vec3 uv;\n    mat3 norm;\n};\n\nstruct NormAndCol {\n    vec3 col;\n    vec3 norm;\n    float dist;\n};\n\nNormAndCol nac_helper(vec3 col, vec3 norm, float dist) {\n    NormAndCol ret;\n    ret.col = col;\n    ret.norm = norm;\n    ret.dist = dist;\n    return ret;\n}\n\n// This is a 2D fuction which defines the brick texture.\n// Returns a NormAndCol containing the normal and color.\nNormAndCol draw_side_base(vec2 uv_in) {\n    uv_in += vec2(10.0);\n    \n    NormAndCol ret;\n    ret.norm = vec3(0,0,1);\n    \n    if (mod(uv_in.y, brick_scale) < brick_outline) {\n        ret.col = brick_mortar_color;\n        \n        float dist = (mod(uv_in.y, brick_scale) - (brick_outline/2.0))/brick_outline;\n            dist *= 1.2;\n        \n        ret.norm = normalize(vec3(0, -pow(dist, 3.0), 0.1));\n    \n        return ret;\n    }\n    \n    float pos_x = (uv_in.x - mod(uv_in.x, brick_scale)) / brick_scale;\n    float pos_y = (uv_in.y - mod(uv_in.y, brick_scale)) / brick_scale;\n\n    float test = 1.999999;\n\n    if (mod(pos_y, test) < 1.0 && mod(pos_x, test) < 1.0) {\n        if (mod(uv_in.x, brick_scale) < brick_outline) {\n            ret.col = brick_mortar_color;\n        \n            float dist = (mod(uv_in.x, brick_scale) - (brick_outline/2.0))/brick_outline;\n            dist *= 1.2;\n\n            ret.norm = normalize(vec3(-pow(dist, 3.0), 0, 0.1));\n\n            return ret;\n        }\n        \n        pos_x += 1.0;\n    }\n\n    if (mod(pos_y, test) >= 1.0 && mod(pos_x, test) >= 1.0) {\n        if (mod(uv_in.x, brick_scale) < brick_outline) {\n            ret.col = brick_mortar_color;\n        \n            float dist = (mod(uv_in.x, brick_scale) - (brick_outline/2.0))/brick_outline;\n            dist *= 1.2;\n\n            ret.norm = normalize(vec3(-pow(dist, 3.0), 0, 0.1));\n\n            return ret;\n        }\n        \n        pos_x += 1.0;\n    }\n    \n    ret.col = vec3(0.6 + ((mod(pos_y, 0.1321) + mod(pos_x, 0.12114))*1.4),0.4,0.4)*0.9;\n    \n    return ret;\n}\n\n// This function is for checking an intersection with a plane on a major axis.\n// returns a vec3 with the intersection point on the plane in the xy, and distnace \n// in the z.\nvec3 plane_intersect(vec3 vector_pos, vec3 vector_dir, int maxis, int xaxis, int yaxis, vec3 pos) {\n    float dist = pos.z-vector_pos[maxis];\n \n    if (dist * vector_dir[maxis] <= 0.0) {\n        return vec3(1000.0);\n    }\n    \n    float total_dist = (dist/vector_dir[maxis]);\n    \n    if (total_dist < 0.0) {\n        return vec3(1000.0);\n    }\n    \n    vec3 col_point = vector_pos + (vector_dir * total_dist);\n    \n    return vec3(col_point[xaxis]+pos.x, col_point[yaxis]+pos.y, total_dist);\n}\n\nconst mat3 iden = mat3(vec3(1,0,0), vec3(0,1,0), vec3(0,0,1));\nconst mat3 tran = mat3(vec3(0,0,1), vec3(0,1,0), vec3(1,0,0));\nconst mat3 rota = mat3(vec3(1,0,0), vec3(0,0,1), vec3(0,1,0));\n\n// This functions utilizes plane_intersect to find the closest intersection\n// of a rectangular prism with size \"scale\", and location \"slide\".\n// Returns the normal matrix and UV (with disance packed into the z of the uv).\nNormAndUV get_uv(vec3 vector_pos, vec3 vector_dir, vec3 scale, vec3 slide, bool backsides) {\n    vec3 buv = vec3(10000); \n    mat3 norm = iden;\n    \n    NormAndUV ret;\n    \n    // Z positive\n    vec3 nuv = plane_intersect(vector_pos, vector_dir, 2, 0, 1, vec3(0,0,scale.z)+(slide.xyz*vec3(1,-1,1)));\n    if (nuv.z < buv.z && abs(nuv.x) <= scale.x && abs(nuv.y) <= scale.y) {\n        mat3 nnorm = iden;\n        if (!backsides || dot(nnorm[2], vector_dir) > 0.0) {\n            norm = nnorm;\n            buv = nuv;\n        }\n    }\n    // Z negative\n    nuv = plane_intersect(vector_pos, vector_dir, 2, 0, 1, -vec3(0,0,scale.z)+(slide.xyz*vec3(1,-1,1)));\n    if (nuv.z < buv.z && abs(nuv.x) <= scale.x && abs(nuv.y) <= scale.y) {\n        mat3 nnorm = -iden;\n        if (!backsides || dot(nnorm[2], vector_dir) > 0.0) {\n            norm = nnorm;\n            buv = nuv;\n            buv.x *= -1.0;\n        }\n    }\n    // X positive\n    nuv = plane_intersect(vector_pos, vector_dir, 0, 2, 1, vec3(0,0,scale.x)-slide.zyx);\n    if (nuv.z < buv.z && abs(nuv.x) <= scale.z && abs(nuv.y) <= scale.y) {\n        mat3 nnorm = tran;\n        if (!backsides || dot(nnorm[2], vector_dir) > 0.0) {\n            norm = nnorm;\n            buv = nuv;\n        }\n    }\n    // X negative\n    nuv = plane_intersect(vector_pos, vector_dir, 0, 2, 1, -vec3(0,0,scale.x)-slide.zyx);\n    if (nuv.z < buv.z && abs(nuv.x) <= scale.z && abs(nuv.y) <= scale.y) {\n        mat3 nnorm = -tran;\n        if (!backsides || dot(nnorm[2], vector_dir) > 0.0) {\n            norm = nnorm;\n            buv = nuv;\n            buv.x *= -1.0;\n        }\n    }\n    // Y positive\n    nuv = plane_intersect(vector_pos, vector_dir, 1, 0, 2, vec3(0,0,scale.y)+slide.xzy*vec3(1,-1,1));\n    if (nuv.z < buv.z && abs(nuv.x) <= scale.x && abs(nuv.y) <= scale.z) {\n        mat3 nnorm = rota;\n        if (!backsides || dot(nnorm[2], vector_dir) > 0.0) {\n            norm = nnorm;\n            buv = nuv;\n        }\n    }\n    // Y negative\n    nuv = plane_intersect(vector_pos, vector_dir, 1, 0, 2, -vec3(0,0,scale.y)+slide.xzy*vec3(1,-1,1));\n    if (nuv.z < buv.z && abs(nuv.x) <= scale.x && abs(nuv.y) <= scale.z) {\n        mat3 nnorm = -rota;\n        if (!backsides || dot(nnorm[2], vector_dir) > 0.0) {\n            norm = nnorm;\n            buv = nuv;\n            buv.x *= -1.0;\n        }\n    }\n    \n    ret.uv = buv;\n    ret.norm = norm;\n    \n    return ret;\n}\n\n// This is a function which will scan an array against a series of rectangular \n// prisms to make a window. Returns normal, color, and distance.\nNormAndCol draw_windows(vec3 in_vec_p, vec3 in_vec_d, vec3 slide, NormAndUV buv, bool x_alligned) {\n    NormAndCol ret;\n    \n    ret.dist = buv.uv.z;\n    \n    const float win_depth = window_outline/2.0;\n    \n    vec3 outer_window = vec3(0.3*window_scale,0.5*window_scale,0.99+win_depth);\n    vec3 inner_window = vec3((0.3-window_outline)*window_scale,(0.5-window_outline)*window_scale,0.99+win_depth);\n    vec3 window_bar = vec3(0.3*window_scale,0.05*window_scale,0.985+win_depth);\n    vec3 window_box = vec3(0.38*window_scale,0.07*window_scale,1.02+win_depth);\n    \n    if (x_alligned) {\n        outer_window = outer_window.zyx;\n        inner_window = inner_window.zyx;\n        window_bar = window_bar.zyx;\n        window_box = window_box.zyx;\n    }\n    \n    NormAndUV frame_uv = get_uv(in_vec_p, in_vec_d, outer_window, slide, false);\n    NormAndUV window_uv = get_uv(in_vec_p, in_vec_d, inner_window, slide, true);\n    NormAndUV frame_cen_uv = get_uv(in_vec_p, in_vec_d, window_bar, slide, false);\n\n    // The components of a window. Essentially, render frame_uv with a hole cut out. \n    // Then render window_uv, with is only the backfacing sides. Then render the \n    // center bar. If that all fails, draw the window itself, as it's the only thing\n    // remaining in the scope of frame_uv.\n    if (frame_uv.uv.z < ret.dist && frame_uv.uv.z < window_uv.uv.z) {\n        if (frame_uv.uv.x < (-0.3+window_outline)*window_scale || frame_uv.uv.x > (0.3-window_outline)*window_scale ||\n            frame_uv.uv.y < (-0.5+window_outline)*window_scale || frame_uv.uv.y > (0.5-window_outline)*window_scale) {\n            ret = nac_helper(windowframe_color, normalize(frame_uv.norm*vec3(0,0,1)), frame_uv.uv.z);\n        } else if (frame_cen_uv.uv.z < ret.dist && frame_cen_uv.uv.z < window_uv.uv.z) {\n            ret = nac_helper(windowframe_color, normalize(frame_cen_uv.norm*vec3(0,0,1)), frame_cen_uv.uv.z);\n        } else if (window_uv.uv.z < ret.dist) {\n            ret = nac_helper(windowframe_color, normalize(-window_uv.norm*vec3(0,0,1)), window_uv.uv.z);\n        } else {\n            ret = nac_helper(window_color, normalize(buv.norm*vec3(0,0,1)), buv.uv.z-0.01);\n        }\n    }\n    \n    // Finally, render a little planter.\n    slide.y -= 0.45 * window_scale;\n    NormAndUV window_box_uv = get_uv(in_vec_p, in_vec_d, window_box, slide, false);\n    \n    if (window_box_uv.uv.z < ret.dist) {\n        ret = nac_helper(windowframe_color, normalize(window_box_uv.norm*vec3(0,0,1)), window_box_uv.uv.z);\n    }\n        \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n\n    float ang = iTime/2.0;\n    float dist = 3.0;\n\n    vec3 in_vec_p = vec3(sin(ang)*dist, 0.0, -(cos(ang)*dist));\n    vec3 in_vec_d = normalize(-in_vec_p);\n    light_dir = normalize(vec3(sin(ang+0.6), 0, -(cos(ang+0.3))));\n    \n    float fov = 2.8;\n    vec3 in_vec_d_hold = in_vec_d;\n\n    in_vec_d.x += (in_vec_d_hold.z*(uv.x*fov));\n    in_vec_d.z -= (in_vec_d_hold.x*(uv.x*fov));\n    in_vec_d.y += uv.y*fov/1.8;\n    \n    // Sky gradient.\n    vec3 col = mix(vec3(0.6,0.8,1), vec3(0.3,0.5,1), uv.y);\n    vec3 norm = vec3(0,0,1);\n    float closest = 900.0;\n\n    // This section draws the brick base.\n    NormAndUV buv = get_uv(in_vec_p, in_vec_d, vec3(1,1.32,1), vec3(0), false);\n\n    if (buv.uv.z < closest) {\n        NormAndCol brick_col = draw_side_base(buv.uv.xy);\n    \n        col = brick_col.col;\n        norm = normalize(buv.norm*brick_col.norm);\n        closest = buv.uv.z;\n    }\n    \n    \n    \n    // This code determines where to draw a window.\n    vec3 slide = vec3(0);\n \n    buv.uv.xy *= num_windows;\n    buv.uv.xy += 0.5;\n    \n    slide.y = (buv.uv.y - mod(buv.uv.y, 1.0))/num_windows;\n\n    if (in_vec_d.z > 0.0) {\n        slide.x = (buv.uv.x - mod(buv.uv.x, 1.0))/num_windows;\n    } else {\n        slide.x = -(buv.uv.x - mod(buv.uv.x, 1.0))/num_windows;\n    }\n\n    NormAndCol win_ret = draw_windows(in_vec_p, in_vec_d, slide, buv, false);\n\n    slide.x = 0.0;\n\n    if (in_vec_d.x > 0.0) {\n        slide.z = -(buv.uv.x - mod(buv.uv.x, 1.0))/num_windows;\n    } else {\n        slide.z = (buv.uv.x - mod(buv.uv.x, 1.0))/num_windows;\n    }\n    \n    // Draw the x alligned windows, and if that misses try the z alligned ones.\n    if (win_ret.dist < closest) {\n        col = win_ret.col;\n        norm = win_ret.norm;\n        closest = win_ret.dist;\n    } else {\n        win_ret = draw_windows(in_vec_p, in_vec_d, slide, buv, true);\n\n        if (win_ret.dist < closest) {\n            col = win_ret.col;\n            norm = win_ret.norm;\n            closest = win_ret.dist;\n        }\n    }\n    \n    // Finally, draw a ground slab.\n    NormAndUV ground_uv = get_uv(in_vec_p, in_vec_d, vec3(1.05,0.05,1.05), vec3(0,-1.34,0), false);\n\n    if (ground_uv.uv.z < closest) {\n        col = brick_mortar_color;\n        norm = normalize(ground_uv.norm*vec3(0,0,1));\n        closest = ground_uv.uv.z;\n    }\n\n    if (closest < 800.0) { \n        // Add lighting.\n        col = col*(0.6+clamp(dot(norm, light_dir), 0.0, 1.0)/3.0);\n        \n        // Add fog.\n        col /= (0.2+(closest/2.3));\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}