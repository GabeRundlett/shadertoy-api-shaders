{
    "Shader": {
        "info": {
            "date": "1708658611",
            "description": "Simple implementation of RTiOW. Took reference from serveral shaders available online.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3BGR3",
            "likes": 0,
            "name": "Ray Tracing in One Weekend.",
            "published": 3,
            "tags": [
                "rtiow"
            ],
            "usePreview": 0,
            "username": "dhawals",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "#define SAMPLES 1\n\n// Used Shadertoy examples of fhecht as reference\n\n\n// CAMERA\nstruct ray\n{\n    vec3 origin;    // this is the origin of the ray\n    vec3 direction; // this is the direction the ray is pointing in\n    float tmin;\n    float tmax;\n};\n\nvec2 pixel_sample_square()\n{\n    // Returns a random point in the square surrounding a pixel at the origin.\n    float px = -0.5 + rand1(g_seed);\n    float py = -0.5 + rand1(g_seed);\n    return vec2(px,py);\n}\n\n\nray generate_camera_ray(vec2 uv, \n                        int image_width, \n                        int image_height, \n                        inout float viewport_height,\n                        inout float viewport_width,\n                        vec3 lookfrom,\n                        vec3 lookat,\n                        vec3 up,\n                        float fov,\n                        float defocus_angle,\n                        float focus_distance) {\n\n    // Fragment coordinates\n    float i = uv.x;\n    float j = uv.y;\n      // Image aspect ratio\n    float aspect_ratio = float(image_width) / float(image_height);\n    \n    vec3 camera_center = lookfrom;\n\n    // float focal_length = length(lookat - lookfrom);\n    float theta = radians(fov);\n    float h = tan(theta/2.);\n    \n    viewport_height = focus_distance * 2.  * h; \n    viewport_width = viewport_height * aspect_ratio;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n\n    // Calculate the vectors across the horizontal and down the vertical viewport edges.\n    // vec3 viewport_u = vec3(viewport_width, 0, 0);\n    // vec3 viewport_v = vec3(0, -viewport_height, 0);\n\n    vec3 viewport_u = viewport_width * u;\n    vec3 viewport_v = viewport_height * -v;;\n    // Calculate the horizontal and vertical delta vectors from pixel to pixel.\n   \n    vec3 pixel_delta_u = viewport_u / float(image_width);\n    vec3 pixel_delta_v = viewport_v / float(image_height);\n    // Calculate the location of the upper left pixel.\n    // vec3 viewport_upper_left = camera_center\n    //                          - vec3(0, 0, focal_length) - viewport_u/2. - viewport_v/2.;\n    \n    vec3 viewport_upper_left = camera_center - (focus_distance * w) - viewport_u/2. - viewport_v/2.;\n    vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n\n    vec3 pixel_center = pixel00_loc + (i * pixel_delta_u) + (j * pixel_delta_v);\n    \n    // Sample generation\n    vec2 pxpy = pixel_sample_square();\n    vec3 pixel_sample = pixel_center +  (pxpy.x * pixel_delta_u) + (pxpy.y * pixel_delta_v);\n    \n    float defocus_radius = focus_distance * tan(radians(defocus_angle) / 2.);\n    vec3 defocus_disk_u = u * defocus_radius;\n    vec3 defocus_disk_v = v * defocus_radius;\n    \n    // defocus disk sampling\n    vec2 p = random_in_unit_disk(g_seed);\n    vec3 ray_origin = (defocus_angle <= 0.) ? camera_center \n                                            : camera_center + (p.x * defocus_disk_u) + (p.y * defocus_disk_v);\n    // Generate camera ray\n    vec3 ray_direction = pixel_sample - ray_origin; // Assuming camera at origin\n    ray camera_ray = ray(ray_origin, ray_direction, 1e-5, 1e20);\n    \n    return camera_ray;\n}\n\n//\n\nstruct hit_record\n{\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool front_face;\n    int material_type;\n    vec3 albedo;\n    float fuzz_or_refractive_index;\n};\n\n// Sphere\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int material_type;\n    vec3 albedo;\n    float fuzz_or_refractive_index;\n};\n\n// Borrowed scene from 1vx_437312114 shadertoy example \nconst int NUM_SPHERES = 8;\nSphere scene_spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(vec3( 0.000000, -1000.000000, 0.000000), 1000.000000, 0, vec3( 0.300000, 0.200000, 0.700000), .0),\n    \n    Sphere(vec3( -2.000000, 1.000000, 0.000000), 1.000000, 0, vec3( 0.800000, 0.200000, 0.00000), .0),\n    Sphere(vec3( 0.000000, 1.000000, 2.000000), 1.000000, 1, vec3( 0.2000000, 0.5000000, 0.2000000), 0.),\n    Sphere(vec3( 0.000000, 1.500000, 0.000000), 1.000000, 2, vec3( 0.1000000, 0.2000000, 0.3000000), 2.45),\n    Sphere(vec3( 0.000000, 1.000000, -2.000000), 1.000000, 0, vec3( 0.2000000, 0.5000000, 0.2000000), 1.5),\n    Sphere(vec3( 2.000000, 1.000000, 0.000000), 1.000000, 1, vec3( 0.800000, 0.200000, 0.00000), 0.000000),\n    \n    Sphere(vec3( 0.000000, 1.000000, 0.000000), 4.000000, 2, vec3( 0.000000, 0.000000, 0.000000), 1.5),\n    Sphere(vec3( 0.000000, 1.000000, 0.000000), -3.5, 2, vec3( 0.000000, 0.000000, 0.000000), 1.5)\n);\n\n\nfloat rand1_limit(float min, float max) {\n    // Returns a random real in [min,max).\n    return min + (max-min) * rand1(g_seed);\n}\n\nvec3 random(float min, float max) {\n        return vec3(rand1_limit(min,max), rand1_limit(min,max), rand1_limit(min,max));\n}\n\nbool hit_sphere(ray r, Sphere s, out hit_record hit, int sphere_id)\n{\n\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n    \n    // First possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.tmin <= t && t < r.tmax) { \n        hit.t = t;\n        hit.p = r.origin + t * r.direction;\n\n        vec3 outward_normal = (hit.p - s.center) / s.radius;\n        hit.front_face = dot(r.direction, outward_normal) < 0.;\n        vec3 normal = hit.front_face ? outward_normal : -outward_normal;\n        hit.normal = normal;\n        \n        hit.material_type = s.material_type;\n        hit.albedo = s.albedo;\n        hit.fuzz_or_refractive_index = s.fuzz_or_refractive_index;\n        return true;\n    }\n\n    // Second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.tmin <= t && t < r.tmax) { \n        hit.t = t;\n        hit.p = r.origin + t * r.direction;\n        \n        vec3 outward_normal = (hit.p - s.center) / s.radius;\n        hit.front_face = dot(r.direction, outward_normal) < 0.;\n        vec3 normal = hit.front_face ? outward_normal : -outward_normal;\n        hit.normal = normal;\n\n        hit.material_type = s.material_type;\n        hit.albedo = s.albedo;\n        hit.fuzz_or_refractive_index = s.fuzz_or_refractive_index;\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hit_spheres(ray r, Sphere spheres[NUM_SPHERES], out hit_record hit)\n{\n    bool is_hit = false;\n    for (int i = 0; i < NUM_SPHERES; ++i) {\n        if (hit_sphere(r, spheres[i], hit, i)) {\n            is_hit = true;\n            r.tmax = hit.t;\n        }\n    }\n    return is_hit;\n}\n\nfloat reflectance(float cosine, float ref_idx) \n{\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.-ref_idx) / (1.+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1. - cosine),5.);\n}\n\nbool get_scatterd_ray(inout ray in_ray, hit_record hit_rec, inout vec3 attenuation_color)\n{\n\n    // Diffuse\n    if(hit_rec.material_type == 0)\n    {\n        vec3 rd = normalize(hit_rec.normal + random_in_unit_sphere(g_seed));\n        attenuation_color = hit_rec.albedo;\n        in_ray.origin = hit_rec.p;\n        in_ray.direction = rd;\n        return true;\n    }\n    // Metal\n    if(hit_rec.material_type == 1)\n    {\n        vec3 direction = normalize(reflect(in_ray.direction, hit_rec.normal) + \n        hit_rec.fuzz_or_refractive_index * random_in_unit_sphere(g_seed));\n        in_ray.origin = hit_rec.p, \n        in_ray.direction = direction;\n\n        attenuation_color = hit_rec.albedo;\n        return dot(in_ray.direction, hit_rec.normal) > 0.0;\n    }\n\n    \n    // DIELECTRIC\n    if(hit_rec.material_type == 2)\n    {\n\n        attenuation_color = vec3(1.0, 1.0, 1.0);\n        float refraction_ratio = hit_rec.front_face ? (1.0 / hit_rec.fuzz_or_refractive_index) : hit_rec.fuzz_or_refractive_index;\n\n        vec3 unit_direction = normalize(in_ray.direction);\n        float cos_theta = min(dot(-unit_direction, hit_rec.normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > rand1(g_seed))\n            direction = reflect(unit_direction, hit_rec.normal);\n        else\n            direction = refract(unit_direction, hit_rec.normal, refraction_ratio);\n\n        in_ray.origin = hit_rec.p;\n        in_ray.direction =  direction;\n        return true;\n    }\n    return false;\n\n}\n\nvec3 ray_color(ray r)\n{\n    hit_record hit_rec;\n    vec3 col = vec3(1);    \n    for (int i=0; i<MAX_RECURSION; i++) \n    {\n        if (hit_spheres(r, scene_spheres, hit_rec)) \n        {\n            vec3 attenuation_color = vec3(0);\n            get_scatterd_ray(r, hit_rec, attenuation_color);\n            r.origin = r.origin + 1e-4*normalize(r.direction);\n            col *= attenuation_color;\n        }\n        else\n        {\n            float a = 0.5*r.direction.y + 0.5;\n            col *= (1.-a)*vec3(1.0, 1.0, 1.0) + a*vec3(0.5, 0.7, 1.0);\n            return col;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    init_rand(FragCoord.xy, iTime);\n\n    int image_height = int(iResolution.y), image_width = int(iResolution.x);\n\n    // Focal length\n    float focal_length = 1.0;\n    float viewport_height = 2.0, viewport_width = 0.;\n    vec3 camera_center = vec3(0.);\n\n    int i = int(FragCoord.x);\n    int j = int(iResolution.y - FragCoord.y);\n    vec2 uv = vec2(i,j);\n    vec3 lookfrom = vec3(-20.*sin(float(iTime)/5.),20,15.);\n    vec3 lookat = vec3(0,0,0);\n    vec3 up = vec3(0, 1, 0);\n    float fov = 20.;\n    float defocus_angle = 10.;\n    float focus_distance = length(lookfrom) + 1.*sin(float(iTime)/20.);\n    // Generate camera ray for current fragment\n    vec4 aggregate_color = vec4(0.);\n    for(int s = 0; s<SAMPLES; s++)\n    {\n\n        ray camera_ray = generate_camera_ray(uv, \n                                            image_width, \n                                            image_height, \n                                            viewport_height, \n                                            viewport_width,\n                                            lookfrom,\n                                            lookat,\n                                            up,\n                                            fov,\n                                            defocus_angle,\n                                            focus_distance);\n\n        aggregate_color += vec4(ray_color(camera_ray), 1.);\n    }\n    FragColor = vec4(pow(aggregate_color.xyz, vec3(1./2.2)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ray tracing in one weekend basecode for Dartmouth CS 77/177\n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3\n#define MAX_FLOAT 3.402823466e+38\n#define MAX_RECURSION 50\n#define PI 3.1415926535897932384626433832795\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time)\n{\n    g_seed = float(base_hash(floatBitsToUint(frag_coord))) / float(0xffffffffU) + time;\n}\n\nfloat rand1(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed += .1, seed += .1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec2 random_in_unit_disk(inout float seed)\n{\n    vec2 h = rand2(seed) * vec2(1., 6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n    return r * vec2(sin(phi), cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed)\n{\n    vec3 h = rand3(seed) * vec3(2., 6.28318530718, 1.) - vec3(1, 0, 0);\n    float phi = h.y;\n    float r = pow(h.z, 1. / 3.);\n    return r * vec3(sqrt(1. - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}