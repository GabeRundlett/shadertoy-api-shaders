{
    "Shader": {
        "info": {
            "date": "1652216004",
            "description": "Worked out on paper the derivative of the superellipse.\n\nMost parameters are controlled by time, two are controlled by mouse position.\n\nSeems to have a bug in some cases when m=0, I'm not sure why yet.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtjBWW",
            "likes": 3,
            "name": "Superellipse Derivative",
            "published": 3,
            "tags": [
                "2d",
                "derivative",
                "superellipse"
            ],
            "usePreview": 0,
            "username": "cra_manning_w",
            "viewed": 484
        },
        "renderpass": [
            {
                "code": "\n//Provides more information.\n//Set to 'false' for a simpler, nicer display.\n#define VISUALIZE_NORMALS true\n\n\n//Utilities:\n#define INV_LERP(a, b, x) ((x - a) / (b - a))\n#define OSCILLATE_T(x) (0.5 + (0.5 * -cos(x * 3.14159265 * 2.0)))\n#define SATURATE(x) (clamp(x, 0.0, 1.0))\n#define SHARPEN(x) smoothstep(0.0, 1.0, x)\n#define SIGN1(x) (((x) >= 0.0) ? 1.0 : -1.0)\nvec2 getPerpendicularRight(vec2 dir)\n{\n    //OpenGL's screen is left-handed.\n    return vec2(dir.y, -dir.x);\n}\n\n\n//Reference: https://mathworld.wolfram.com/Superellipse.html\n\n//Provide a custom function on the angle (which is between -Pi and Pi)\n//    before it's plugged into the \"cos\" and \"sin\" terms,\n//    to get more interesting shapes.\nvoid ellipseAngleModification(float theta, out vec2 newTheta, out vec2 derivative)\n{\n    newTheta = vec2(theta);\n    derivative = vec2(1.0);\n}\n\nstruct SuperEllipse\n{\n    float radiusScale;\n    \n    //My attempt to give intuitive names to the parameters:\n    \n    ivec2 nPeaks; // Half of 'm', different values per axis.\n                  //   (multiples of 2 are the only 'm' values with continuous results)\n    float peakSharpness; // 'n1'\n    \n    vec2 subPeakSizes; // 'a' and 'b'\n    vec2 subPeakSharpness; // 'n2' and 'n3'\n};\nstruct SE_Surface\n{\n    float radius, derivative;\n    vec2 tangent, normal;\n};\n\n//Finds the radius, derivative, and tangent/normal of a superellipse,\n//    given the position/angle around it.\n//Tangent/normal calculation assumes left-handed coordinates\n//    (like the ShaderToy screen), and the Theta angle increasing counter-clockwise.\nSE_Surface getEllipseSurface(SuperEllipse ellipse, vec2 surfaceDir, float theta)\n{\n    //Extract the parameter names used in the original math.\n    vec2 m = vec2(ellipse.nPeaks * 2),\n         ab = ellipse.subPeakSizes,\n         n23 = ellipse.subPeakSharpness;\n    float n1 = ellipse.peakSharpness;\n\n          \n    vec2 theta1, theta1Derivative;\n    ellipseAngleModification(theta, theta1, theta1Derivative);\n\n    //First calculate the layers of values from the original function.\n    vec2 multiplier = (m / 4.0),\n         r1 = multiplier * theta1,\n         trigR1 = vec2(cos(r1.x), sin(r1.y)),\n         trigSign = vec2(SIGN1(trigR1.x), SIGN1(trigR1.y)), //Replaces abs()\n         r2 = trigR1 * trigSign / ab,\n         r3 = pow(r2, n23);\n    float r = ellipse.radiusScale * pow(r3.x + r3.y, -1.0 / n1);\n    \n    //Next, calculate the derivatives of those layers\n    //    by applying the chain rule multiple times.\n    vec2 rDeriv1 = multiplier * theta1Derivative,\n         rDeriv2 = vec2(-sin(r1.x), cos(r1.y))\n                     * rDeriv1 * trigSign / ab,\n         rDeriv3 = n23 * rDeriv2\n                     * pow(r2, n23- 1.0);\n    float rDeriv = ellipse.radiusScale * (-1.0 / n1)\n                   * (rDeriv3.x + rDeriv3.y)\n                   * pow(r3.x + r3.y, -(1.0 + (1.0 / n1)));\n         \n\n    //Use the derivative to find the tangent line on this part of the surface.\n    //Remember that derivative is \"rise / run\", a.k.a. \"y\"/\"x\".\n    //On the surface, \"rise\" is the outward surface direction,\n    //    and \"run\" is the positive angle direction.\n    vec2 leftward = -getPerpendicularRight(surfaceDir);\n    vec2 tangentRise = surfaceDir * rDeriv / ellipse.radiusScale,\n         tangentRun = leftward * 1.0,\n         tangent = normalize(tangentRise + tangentRun);\n         \n    vec2 normal = getPerpendicularRight(tangent);\n    \n    return SE_Surface(r, rDeriv, tangent, normal);\n}\n\n\nfloat distToLine(vec2 lineStart, vec2 lineDir, vec2 point, bool isRay)\n{\n    float t = dot(point - lineStart, lineDir);\n    if (isRay)\n        t = max(0.0, t);\n    vec2 closestLinePoint = lineStart + (lineDir * t);\n    \n    return distance(point, closestLinePoint);\n}\n\n//Give a pixel and a specific point on an ellipse's surface,\n//    returns a color value used to visualize that suface's derivative.\nvec3 vizSurfaceDerivative(vec2 pixelPos, float vizTheta, SuperEllipse ellipse)\n{\n    vec2 towardsSurface = vec2(cos(vizTheta), sin(vizTheta));\n    \n    SE_Surface surface =  getEllipseSurface(ellipse, towardsSurface, vizTheta);\n    vec2 surfacePos = towardsSurface * surface.radius;\n             \n    //Draw a red tangent line, blue normal line,\n    //    dotted yellow \"surface dir\" line,\n    //    and a green dot at the surface point.\n    float lineTangent = distToLine(surfacePos, surface.tangent, pixelPos, true),\n          lineNormal = distToLine(surfacePos, surface.normal, pixelPos, true),\n          lineSurface = distToLine(surfacePos, towardsSurface, pixelPos, false);\n    #define LINE_NARROWNESS 180.0\n    vec3 tangentColor = vec3(1, 0, 0) *\n                        pow(1.0 - SATURATE(lineTangent),\n                            LINE_NARROWNESS),\n         normalColor = vec3(0, 0, 1) *\n                       pow(1.0 - SATURATE(lineNormal),\n                           LINE_NARROWNESS),\n         surfaceDirColor = vec3(1, 1, 0) *\n                           SHARPEN(mix(0.0, 1.0,\n                               OSCILLATE_T(dot(towardsSurface,\n                                               pixelPos - surfacePos)\n                                             * 20.0))) *\n                           pow(1.0 - SATURATE(lineSurface),\n                               LINE_NARROWNESS),\n         surfaceColor = vec3(0, 1, 0) *\n                        step(SATURATE(distance(pixelPos, surfacePos)),\n                             0.01);\n    vec3 drawColor = tangentColor + normalColor + surfaceDirColor + surfaceColor;\n    \n    //Display the derivative value as text.\n    vec2 TEXT_SIZE = vec2(0.2, 0.1);\n    vec3 textColor = vec3(0.2, 1, 0.1) *\n                     PrintValue(-0.5 * TEXT_SIZE, pixelPos,\n                                TEXT_SIZE,\n                                surface.derivative,\n                                2.0, 3.0);\n    \n    return SATURATE(drawColor + textColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Correct for aspect ratio, but leave the center of the screen at {0.5, 0.5}.\n    float aspect = iResolution.x / iResolution.y,\n          aspectOffset = (aspect - 1.0) / 2.0;\n    uv.x = (uv.x * aspect) - aspectOffset;\n    \n    //Compute the polar coordinates.\n    vec2 shapeCenter = vec2(0.5);\n    vec2 pos = uv - shapeCenter,\n         towardsSurface = normalize(pos);\n    float theta = atan(pos.y, pos.x),\n          radius = length(pos);\n          \n    //DEBUG: visualize angle.\n    fragColor.rgb = vec3((theta + 3.1415927) / (2.0 * 3.1415927));\n    //return;\n          \n    //Compute the superellipse parameters.\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float time = iTime;\n    //TODO: Modify these parameters to make the thumbnail preview more interesting.\n    //  [this didn't do anything, I'm not sure how to fix this]\n    if (false && iMouse.xy == vec2(0))\n    {\n        mouseUV = vec2(0.5);\n        time = 34.3421;\n    }\n    SuperEllipse ellipse = SuperEllipse(0.25,\n                                        ivec2(mix(vec2(1.0), vec2(8.999), mouseUV)),\n                                        mix(2.0, 8.0, OSCILLATE_T(time / 2.65)),\n                                        vec2(mix(0.75, 3.0, OSCILLATE_T(time / 3.5)),\n                                             mix(0.75, 3.0, OSCILLATE_T(time / 7.0))),\n                                        vec2(mix(0.4, 4.5, OSCILLATE_T(time / 4.25)),\n                                             mix(0.4, 4.5, OSCILLATE_T(time / 8.5))));\n                                             \n    //Compute the superellipse data at this point.\n    SE_Surface elSurface = getEllipseSurface(ellipse, towardsSurface, theta);\n    vec2 surfacePos = shapeCenter + (towardsSurface * elSurface.radius);\n          \n    //Pick a color.\n    float displayDerivative = SATURATE(INV_LERP(0.0, 0.82, abs(elSurface.derivative))),\n          radiusT = radius / elSurface.radius;\n    vec3 backgroundColor = vec3(0),\n         shapeColor = VISUALIZE_NORMALS ?\n                          mix(vec3(0.7),\n                              vec3(0.2, 0.2, 0.8),\n                              displayDerivative * pow(SATURATE(radiusT), 2.0)) :\n                          mix(vec3(1),\n                              vec3(0.7, 0.7, 1),\n                              displayDerivative * pow(SATURATE(radiusT), 5.0)),\n         edgeColor = vec3(\n             //Red-Green visualizes the signed normal.\n             SATURATE(elSurface.normal),\n             //Blue visualizes the derivative.\n             //Only show it in places where the normal is black,\n             //    otherwise the normal is difficult to interpret.\n             pow(displayDerivative, 0.375)\n              * step(elSurface.normal.x, 0.0)\n              * step(elSurface.normal.y, 0.0)\n         );\n    float edgeThickness = 0.01;\n    if (abs(radius - elSurface.radius) < edgeThickness)\n        fragColor.rgb = edgeColor;\n    else if (radius < elSurface.radius)\n        fragColor.rgb = shapeColor;\n    else\n        fragColor.rgb = backgroundColor;\n        \n    //Visualize a specific surface normal.\n    if (VISUALIZE_NORMALS)\n    {\n        float thetaToExamine = fract(iTime * 0.1)\n                                 * 3.14159265 * 2.0;\n        fragColor.rgb += vizSurfaceDerivative(pos, thetaToExamine, ellipse);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 textPos, vec2 pixelPos, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (textPos - pixelPos) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n    charCoord.x = 1.0 - charCoord.x;\n    charCoord.y = 1.0 - charCoord.y;\n    charCoord = vec2(charCoord.x, charCoord.y);\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ---- 8< -------- 8< -------- 8< -------- 8< ----",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}