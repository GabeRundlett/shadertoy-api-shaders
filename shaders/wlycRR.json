{
    "Shader": {
        "info": {
            "date": "1610315802",
            "description": "The human body generates more bio electricity than a 120 volt battery and over 25000 BTUs of body heat.\nCombined with a form of fusion the machines had found all the energy they would ever need.\n  - The Matrix (1999)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlycRR",
            "likes": 43,
            "name": "Human Batteries",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "matrix",
                "movie",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 14431
        },
        "renderpass": [
            {
                "code": "// 'Human Batteries' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/wlycRR\n//\n// \"The human body generates more bio electricity than a\n//  120 volt battery and over 25000 BTUs of body heat.\n//  Combined with a form of fusion the machines had found\n//  all the energy they would ever need.\"\n//   - The Matrix (1999)\n//\n// Tricks to get the performance:\n//   - There's only one 'pod'.\n//\t The others are all cloned by folding space and\n//\t mirroring the axis.\n//   - There's only one column.\n//\t Again, mirroring the axis x/z axis creates more.\n//   - Only two lighting bolts.\n//\t Axis mirroring again...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 80.0\n#define MAX_STEPS\t\t 100.0\n#define SHADOW_STEPS\t 20.0\n#define MAX_SHADOW_DIST  10.0\n#define BODY_STEPS\t     30.0\n#define MAX_BODY_DIST    1.7\n\nfloat T; // Global time.\nvec2 g = vec2(0); // Glow for lightning and pods.\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id;  // Material ID.\n\tvec3 uv; // Ray position.\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\n#define HASH  p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec2 hash22(vec2 p) { HASH }\nvec4 hash44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n)\n{\n\tfloat angle = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x), 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdPod(vec3 p) {\n\t// Pod.\n\tfloat d = exp(-p.x * .6) * .3 - .07 * p.x * sin(4.7 * p.x) + .06, d2;\n\tHit h = Hit(sdCapsule(p, 1.5, d), 3, p);\n\n\t// The end bit.\n\td2 = sdBox(p - vec3(1.6, 0, 0), vec3(.05)) - .03;\n\n\t// Feeding pipes.\n\td2 = min(min(d2, sdTorus(p + vec3(.6, 0, 0), vec2(.8, .05))),\n\t\t\t sdTorus(p.xzy + vec3(1.75, 0, 0), vec2(2, .1)));\n\n\t// Pod 'cage'.\n\tp.yz = abs(p.yz);\n\tp.y -= d * .5;\n\tp.z -= d;\n\td = sdCapsule(p, 1.65, .03 + abs(sin(p.x * 30.)) * .005);\n\tminH(h, Hit(min(d2, d) * .9, 2, p));\n\n\tg.y += .0001 / (.2 + d * d);\n\n\treturn h;\n}\n\nfloat sdBody(vec3 p) {\n\t// Map world to pod point.\n\tp.xz = opModPolar(abs(p.xz) - 20., 60.);\n\tp.y = mod(p.y, 3.) - 1.5;\n\tp.x -= 12.1;\n\n\t// Head\n\tfloat d = length(p) - .07;\n\n\t// Torso\n\tp.z = abs(p.z);\n\tp.x -= .1;\n\tp.xy *= rot(-.2);\n\td = smin(d, sdCapsule(p, .3, p.x * .09 + .02), .1);\n\n\t// Legs\n\tp.x -= .35;\n\tp.z -= .06;\n\tp.xy *= rot(.3);\n\tp.xz *= rot(.15);\n\treturn smin(d, sdCapsule(p, .5, .01), .2);\n}\n\nfloat sdBolts(vec3 p, float i) {\n\tp = mix(p, p.zyx, step(12., p.x));\n\n\tfloat d, t = T + sign(p.z) + i,\n\t\t  r = n21(vec2(t, i * .2)) - .5;\n\n\tp.x += 10.;\n\tp.y += mod(70. - t * 10. * i, 70.) - 18.\n\t\t   + n21(vec2(p.x, t * 15.2 + i)) * 2.;\n\n\tp.z = abs(p.z) - 24. - r * 5.;\n\n\tp.xy *= rot(r);\n\tp.xz *= rot((i - 1.) * .5);\n\n\td = sdCapsule(p, 20., .01);\n\tg.x += .01 / (.01 + d * d);\n\n\treturn d * .6;\n}\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Lightning.\n\t// We only render two bolts - The others\n\t// are added using axis reflection.\n\tHit h = Hit(min(sdBolts(p, 1.), sdBolts(p, .4)), 6, p);\n\n\t// Main cylinders.\n\t// Only one created - We use axis reflection again.\n\tp.xz = abs(p.xz) - 20.;\n\tminH(h, Hit(length(p.xz) - 12. + sin(p.y * 2.09 + 4.7) * .2, 1, p));\n\n\t// Pods.\n\t// Again, only one is ever rendered!\n\tp.xz = opModPolar(p.xz, 60.);\n\tp.x -= 11.8;\n\tp.y = mod(p.y, 3.) - 1.5;\n\tminH(h, sdPod(p));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .5;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = 0.; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .01 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// March through the pod - Basically the same as a shadow.\nfloat bodyTint(vec3 p, vec3 rd) {\n\tfloat s = 1.;\n\tconst float stp = MAX_BODY_DIST / BODY_STEPS;\n\tfor (float t = 0.; t < MAX_BODY_DIST; t += stp)\n\t{\n\t\tfloat h = sdBody(p + rd * t);\n\t\ts = min(s, 20. * h / t);\n\t\tif (s < .01) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld, float h) { return smoothstep(0.0, 1.0, map(p + ld * h).d / h); }\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 3, -10) - p),\n\t\t n = calcN(p, d), c;\n\tfloat ss = 0., // Sub-surface scatter\n\t\t  sp = 10.; // Specular multiplier.\n\n\tif (h.id == 1) {\n\t\t// Column.\n\t\t// Small ridges added using a quick bump map.\n\t\tc = vec3(.01);\n\t\tn.y += (abs(sin(h.uv.y * 31.)) - .5) * .4;\n\t\tn = normalize(n);\n\t} else if (h.id == 2) {\n\t\t// Feeder Pipes.\n\t\tc = vec3(.02);\n\t\tsp = 50.; // Slightly increased specular to add 'shine'.\n\t} else if (h.id == 3) {\n\t\t// Pod pink.\n\t\tc = vec3(1, .32, .27) * smoothstep(1.55, 1.3, h.uv.x);\n\t\tc *= .2 + .8 * smoothstep(0., .2, h.uv.x);\n\n\t\t// Sub-surface scattering.\n\t\tss = sss(p, ld, .45);\n\t} else c = vec3(1);\n\n\t// Ambient occlusion.\n\tfloat ao = dot(vec2(ao(p, n, .2), ao(p, n, .5)), vec2(.1, .2)),\n\n\t// Primary light.\n\tl1 = max(0., .1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * calcShadow(p, ld)) // ...with shadow.\n\t\t * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * sp;\n\n\t// Combine into final color.\n\treturn mix((l1 + (l2 + spe) * ao + ss) * c * vec3(2, 1.6, 1.4),\n\t\t\t   vec3(.01),\n\t\t\t   fre);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c = vec3(0);\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST || d > MAX_DIST)\n\t\t\tbreak;\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\t// Stash the glow before calculating normals/etc alters it.\n\tvec2 gg = g;\n\n\tif (d < MAX_DIST) {\n\t\tc = lights(p, rd, d, h);\n\n\t\t// If we hit a pod, do a mini-march through it\n\t\t// to build a tint of the 'bodies'.\n\t\tif (h.id == 3)\n\t\t\tc *= .4 + .6 * bodyTint(p - rd, rd);\n\t}\n\n\tc *= exp(d * d * -.001);\n\n\t// Raymarch to get fog depth.\n#define FOG_STEPS      8.0\n\tfloat maxD = min(d, MAX_DIST),\n\t\t  d2 = 0.01;\n\tfor (float i = 0.; i < FOG_STEPS; i++) {\n\t\tp = ro + rd * d2;\n\t\tfloat fd = 0.7 * abs(p.y + 15.0 + 10.0 * n31(vec3(p.xz * 0.1, T * 0.1)));\n\t\tif (abs(fd) < MIN_DIST || d2 > maxD)\n\t\t\tbreak;\n\t\td2 += fd;\n\t}\n\n\t// Mix in the fog color.\n\td = smoothstep(0., 1., (min(d, MAX_DIST) - d2) / 30.);\n\tc = mix(c,\n\t\t\tvec3(.25, .3, .4),\n\t\t\td * d // Base fog.\n\t\t\t* n21(p.xz * .06) // Low frequency patches.\n\t\t\t* (.2 + .8 * n31(vec3(p.xz + T, T) * .2)) // Finer details.\n\t\t\t);\n\n\treturn c // Base color.\n\t\t   + gg.x * vec3(.4, .6, 1) // Lighting bolt glow.\n\t\t   + gg.y * vec3(1, .32, .27); // Faint pod glow.\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = mod(iTime, 40.) + 1.3;\n\n\tfloat dim = 1. - abs(cos(clamp(T, -1., 1.) * 1.57)),\n\t\t  t = .5 + .5 * cos(.157 * T);\n\tt = mix(smoothstep(0., 1., t), t, t);\n\tvec3 ro = vec3(-6.5, 25. - t * 20., 21);\n\tro.xz += t * 25.;\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, getRayDir(ro, vec3(0, -t * 10., 0), uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}