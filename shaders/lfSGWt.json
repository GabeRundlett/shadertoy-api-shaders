{
    "Shader": {
        "info": {
            "date": "1704778168",
            "description": "I made this with ray marching because i like it.",
            "flags": 48,
            "hasliked": 0,
            "id": "lfSGWt",
            "likes": 6,
            "name": "Path tracing with ray marching",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "Vulpes",
            "viewed": 353
        },
        "renderpass": [
            {
                "code": "const float exposure = .5; \n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1. : 0.,\n        (f.y < value) ? 1. : 0.,\n        (f.z < value) ? 1. : 0.);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0., 1.);\n    \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, 0.0031308)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    color *= exposure;\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 50\n#define MAX_DIST 20.\n#define SURFACE_DIST .001\n\n#define OFFSET_X 1\n#define OFFSET_Y 1\n#define DEPTH\t 3.5\n\nconst float KEY_SPACE = 32.5/256.0;\n\n#define TWO_PI 6.283185307179586476925286766559\n#define PI 3.1415926535897932384626433832795\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rndFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 rndUnitVector(inout uint state)\n{\n    float z = rndFloat01(state) * 2.0f - 1.0f;\n    float a = rndFloat01(state) * TWO_PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct SMaterialInfo\n{\n    vec3 albedo;\n    vec3 emissive;\n    float percentSpecular;\n    float roughness;\n    vec3 specularColor;\n};\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nvec3 rotate3d(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nstruct spot {\n    float dist;\n    int ID;\n};\n\nstruct ray {\n    int ID;\n    vec3 place;\n    float dist;\n};\n\nspot sdUnion(spot a, spot b)\n{\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\nspot sdMirror(vec3 p)\n{\n    vec3 sphere1 = vec3(0, 1, 0);\n    float dist1 = length(p - sphere1) - sphere1.y;\n    \n    vec3 sphere2 = vec3(1, .5, -1);\n    float dist2 = length(p - sphere2) - sphere2.y;\n    \n    return spot(min(dist1, dist2), 1);\n}\n\nspot sdFloor(vec3 p)\n{\n    float dist = p.y;\n    \n    return spot(dist, 2);\n}\n\nspot sdLight(vec3 p)\n{\n    vec3 q = abs(p - vec3(-1, 2.25, -1)) - vec3(.3);\n    float dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .005;\n    \n    return spot(dist, 3);\n}\n\nspot sdWalls(vec3 p)\n{\n    float north = p.z+4.5;\n    float south = 6.-p.z;\n    float east = p.x+4.;\n    float west = 6.-p.x;\n    \n    return spot(min(min(north, south), min(east, west)), 4);\n}\n\nspot sdCeil(vec3 p)\n{\n    float up = 5.-p.y;\n    \n    return spot(up, 5);\n}\n\nspot sdSpheres(vec3 p)\n{\n    vec3 sphere1 = vec3(4, 1, 4);\n    float dist1 = length(p - sphere1) - sphere1.y;\n    \n    vec3 sphere2 = vec3(4.2, .5, 1);\n    float dist2 = length(p - sphere2) - sphere2.y;\n    \n    return spot(min(dist1, dist2), 6);\n}\n\nspot sdLent(vec3 p)\n{\n    p = p - vec3(-2.5, 1., 1);\n    vec2 t = vec2(.5, .25);\n    \n    vec2 q = vec2(length(p.zy)-t.x,p.x);\n    float dist = length(q)-t.y;\n    \n    return spot(dist, 7);\n}\n\nspot sdLentNeq(vec3 p)\n{\n    spot s = sdLent(p);\n    \n    return spot(-s.dist, s.ID);\n}\n\nspot getDist2(vec3 p)\n{\n    return sdUnion(sdUnion(sdUnion(sdMirror(p), sdLent(p)), sdSpheres(p)), sdUnion(sdUnion(sdWalls(p), sdCeil(p)), sdFloor(p)));\n}\n\nspot getDist(vec3 p)\n{\n    return sdUnion(getDist2(p), sdLight(p));\n}\n\nvec3 getNormal(vec3 p)\n{\n    float dist = getDist(p).dist;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dist - vec3(\n        getDist(p-e.xyy).dist,\n        getDist(p-e.yxy).dist,\n        getDist(p-e.yyx).dist\n    );\n    \n    return normalize(normal);\n}\n\nray rayMarchNeq(vec3 begin, vec3 direction)\n{\n    float dist0 = 0.005;\n    float minDist = MAX_DIST;\n    int j = 0;\n    spot res;\n    vec3 p;\n    \n    for (int i = 0; i < MAX_STEPS; i++, j++)\n    {\n        p = begin + dist0 * direction;\n        \n        res = sdLentNeq(p);\n        float distS = res.dist;\n        \n        minDist = min(minDist, distS);\n        dist0 += distS;\n        \n        if (distS < SURFACE_DIST) return ray(res.ID, p, dist0);\n        if (dist0 > MAX_DIST) return ray(0, p, dist0);\n    }\n    \n    return ray(res.ID, p, dist0);\n}\n\nray rayMarch(vec3 begin, vec3 direction)\n{\n    float dist0 = 0.005;\n    float minDist = MAX_DIST;\n    int j = 0;\n    spot res;\n    vec3 p;\n    \n    for (int i = 0; i < MAX_STEPS; i++, j++)\n    {\n        p = begin + dist0 * direction;\n        \n        res = getDist(p);\n        float distS = res.dist;\n        \n        minDist = min(minDist, distS);\n        dist0 += distS;\n        \n        if (distS < SURFACE_DIST) return ray(res.ID, p, dist0);\n        if (dist0 > MAX_DIST) return ray(0, p, dist0);\n    }\n    \n    return ray(res.ID, p, dist0);\n}\n\nSRayHitInfo getMaterial(int ID, SRayHitInfo hitInfo)\n{\n    if (ID == 2) \n    {\n        hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = 0.0f;\n        hitInfo.material.roughness = 0.0f;\n        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n            \n        return hitInfo;\n    }\n    if (ID == 3)\n    {\n        hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n        hitInfo.material.percentSpecular = 0.0f;\n        hitInfo.material.roughness = 0.0f;\n        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n            \n        return hitInfo;\n    }\n    if (ID == 4) \n    {\n        hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.1f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = 0.0f;\n        hitInfo.material.roughness = 0.0f;\n        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n            \n        return hitInfo;\n    }\n    if (ID == 5) \n    {\n        hitInfo.material.albedo = vec3(0.1f, 0.1f, 0.7f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = 0.0f;\n        hitInfo.material.roughness = 0.0f;\n        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n            \n        return hitInfo;\n    }\n    if (ID == 6) \n    {\n        hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n        hitInfo.material.percentSpecular = 1.0f;\n        hitInfo.material.roughness = 0.75f;\n        hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);   \n            \n        return hitInfo;\n    }\n}\n\nvec3 path(vec3 begin, vec3 direction, vec2 uv, inout uint rngState)\n{\n    vec3 ret = vec3(0);\n    vec3 throughput = vec3(1);\n    float dist = MAX_DIST;\n    \n    for (int bounceIndex = 0; bounceIndex < 8; bounceIndex++)\n    {\n        ray res = rayMarch(begin, direction);\n        dist += res.dist;\n        \n        vec3 normal = getNormal(res.place);\n        begin = res.place;\n    \n        SRayHitInfo hitInfo;\n        hitInfo.dist = dist;\n        \n        if (res.ID == 1) \n        {\n            direction = reflect(direction, normal);\n                \n            continue;\n        }\n        else if (res.ID == 7)\n        {\n            vec3 right;\n            float angle;\n            float rAngle;\n            \n            angle = acos(dot(-direction, normal));\n            rAngle = asin(sin(angle) / 1.5);\n            \n            right = normalize(cross(-direction, normal));\n            direction = normalize(rotate3d(direction, right, rAngle));\n                \n            ray res = rayMarchNeq(begin, direction);\n            \n            begin = res.place;\n            normal = getNormal(begin);\n            \n            angle = acos(dot(-direction, normal));\n            rAngle = asin(sin(angle) / 1.5);\n            \n            right = normalize(cross(direction, normal));\n            direction = normalize(rotate3d(direction, right, rAngle));\n                \n            continue;\n        }\n        else\n        {\n            hitInfo = getMaterial(res.ID, hitInfo);\n        }\n        \n        float doSpecular = (rndFloat01(rngState) < hitInfo.material.percentSpecular) ? 1. : 0.;\n        \n        vec3 diffuseRayDir = normalize(normal + rndUnitVector(rngState));\n        vec3 specularRayDir = reflect(direction, normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.roughness * hitInfo.material.roughness));\n        direction = mix(diffuseRayDir, specularRayDir, doSpecular);\n        \n        ret += hitInfo.material.emissive * throughput;\n        \n        throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);      \n    }\n    \n    return ret;\n}\n\n#define RAYS 2\n\nvec3 render(vec2 uv, inout uint rngState)\n{\n    vec3 begin = vec3(0, 1.5, -4);\n           \n    vec3 direct = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 col = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < RAYS; ++index)\n    \tcol += path(begin, direct, uv, rngState) / float(RAYS);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec2 jitter = vec2(rndFloat01(rngState), rndFloat01(rngState)) - .5;\n    \n    vec2 uv = ((fragCoord+jitter)-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = render(uv, rngState);\n    \n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1. : 1. / (1. + (1. / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n    \n    fragColor = vec4(col,blend);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}