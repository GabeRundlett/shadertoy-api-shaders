{
    "Shader": {
        "info": {
            "date": "1622005199",
            "description": "played around with stephaneginier's editSDF, very pleased with what came out",
            "flags": 0,
            "hasliked": 0,
            "id": "Nll3WH",
            "likes": 3,
            "name": "swarm pillars",
            "published": 3,
            "tags": [
                "editsdf"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_117 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_118 = vec4(sdBox(pMod((mat4(1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,-0.673682451248169,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,1.71,5.0)), vec4(0.1,0.78,0.1,0.09)) * 0.6877309083938599, vec3(0.30639375,0.35338712499999997,0.52));\nvec4 tmpComb_267 = opUnionColumns(tmpPrim_117, tmpPrim_118, vec2(0.3,5.96));\nvec4 tmpPrim_119 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(1.6400000000000001,2.09,6.7700000000000005)), 0.28) * 1.0, vec3(0.5215065625,0.49989843749999996,0.77));\nvec4 tmpComb_268 = tmpComb_267;\nvec4 tmpComb_269 = opUnionColumns(tmpComb_268, tmpPrim_119, vec2(0.3,10.0));\nvec4 tmpPrim_120 = vec4(sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,3.44)), vec4(0.33,0.01,0.53,0.0)) * 1.0, vec3(0.5215065625,0.49989843749999996,0.77));\nvec4 tmpComb_270 = tmpComb_269;\nvec4 tmpComb_271 = opSubColumns(tmpComb_270, tmpPrim_120, vec2(0.17,10.0));\nvec4 tmpPrim_121 = vec4(sdSphere(pMod((mat4(3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,5.372418403625488,-0.0015462442534044385,0.008526071906089783,1.0) * vec4(point, 1.0)).xyz, vec3(0.1,0.1,0.1)), 0.01) * 0.30537912249565125, vec3(0.11024278124999998,0.04005781250000002,0.31000000000000005));\nvec4 tmpComb_272 = tmpComb_271;\nvec4 tmpComb_273 = opInterColumns(tmpComb_272, tmpPrim_121, vec2(0.01,7.0));\nreturn tmpComb_273;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_274 = opUnionColumns(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdBox(pMod((mat4(1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,-0.673682451248169,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,1.71,5.0)), vec4(0.1,0.78,0.1,0.09)) * 0.6877309083938599, vec2(0.3,5.96));\nfloat tmpComb_275 = tmpComb_274;\nfloat tmpComb_276 = opUnionColumns(tmpComb_275, sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(1.6400000000000001,2.09,6.7700000000000005)), 0.28) * 1.0, vec2(0.3,10.0));\nfloat tmpComb_277 = tmpComb_276;\nfloat tmpComb_278 = opSubColumns(tmpComb_277, sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,3.44)), vec4(0.33,0.01,0.53,0.0)) * 1.0, vec2(0.17,10.0));\nfloat tmpComb_279 = tmpComb_278;\nfloat tmpComb_280 = opInterColumns(tmpComb_279, sdSphere(pMod((mat4(3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,5.372418403625488,-0.0015462442534044385,0.008526071906089783,1.0) * vec4(point, 1.0)).xyz, vec3(0.1,0.1,0.1)), 0.01) * 0.30537912249565125, vec2(0.01,7.0));\nreturn tmpComb_280;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 16; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}