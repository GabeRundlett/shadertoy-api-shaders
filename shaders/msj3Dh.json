{
    "Shader": {
        "info": {
            "date": "1680890509",
            "description": "Fast traversal of a heightmap by pre-calculating the minmax mimaps of the texture. Also known as Quadtree Displacement Mapping (QDM)\n\nClick and drag to look around",
            "flags": 32,
            "hasliked": 0,
            "id": "msj3Dh",
            "likes": 21,
            "name": "Fast Minmax Terrain Traversal",
            "published": 3,
            "tags": [
                "terrain",
                "displacement",
                "lod",
                "heightmap",
                "quadtree",
                "minmax"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "\n// Minmax Terrain Traversal - gelami\n// https://www.shadertoy.com/view/msj3Dh\n\n/*\n * Fast traversal of a heightmap by pre-calculating the minmax mimaps of the texture.\n *   Also known as Quadtree Displacement Mapping (QDM)\n *\n * The mipmap is computed in a buffer in 8 passes,\n *   though it should've probably done in the cubemap instead.\n * There's still some artifacts on the traversal, as I've pretty much just hacked it.\n * Ideally you'd traverse using a step mask to increment the IDs,\n *   but I've just relied on using only on the position instead.\n * \n * Instructions:\n * - Click and drag to look around\n * - Defines in Common\n * - To change textures, change both iChannel0 in Image and Buffer A\n *     or change getHeightmap() in Common for procedural functions\n * \n * Buffer A computes the mipmaps in 8 passes\n * Buffer B stores the sky-view LUT\n * Image does the traversal\n *\n * This shader was inspired by:\n * Tesselation-Free Displacement Mapping\n * https://research.adobe.com/publication/tessellation-free-displacement-mapping-for-ray-tracing/\n *\n * Sky atmosphere taken from (thank u Jodie):\n * Cheap sky simulation - Jodie\n * https://www.shadertoy.com/view/ttSGzh\n *\n * I've just found out after finishing this that Fabrice already did this before, and\n * without pre-calculating the minmax mipmaps (using some magic)\n * fast heightfield rendering - FabriceNeyret2\n * https://www.shadertoy.com/view/wtdXDj\n *\n * TODO for next time:\n * - Random scale and height per tile\n * - Calculate mipmap in cubemap\n *\n */\n\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat intersectSlab( in vec3 ro, in vec3 ird, vec2 span ) \n{\n    if (ro.y > span.x && ro.y < span.y )\n        return MAX_DIST;\n\n    vec3 m = ird;\n    float n = ro.y * ird.y;\n    vec2 k = span * ird.y;\n    vec2 tN = -n + k;\n    float t = min(tN.x, tN.y);\n    if (t < 0.) t = MAX_DIST;\n    return t;\n}\n\nfloat intersectColumn( vec3 ro, vec3 ird, vec3 center, float size, out vec3 normal ) \n{\n    ro -= center;\n    vec3 n = ird * ro;\n    vec3 k = abs(ird) * vec3(size, 1, size);\n    vec3 t1 = -n + k;\n    float t = min( min( t1.x, t1.y ), t1.z );\n    normal = -sign(ird) * step(t1, t1.yzx) * step(t1, t1.zxy);\n    return t;\n}\n\nfloat intersectBox( vec3 ro, vec3 ird, vec3 center, vec3 size, out vec3 normal ) \n{\n    ro -= center;\n    vec3 n = ird * ro;\n    vec3 k = abs(ird) * size;\n    vec3 t1 = -n + k;\n    float t = min( min( t1.x, t1.y ), t1.z );\n    normal = -sign(ird) * step(t1, t1.yzx) * step(t1, t1.zxy);\n    return t;\n}\n\nfloat intersectObject( vec3 ro, vec3 rd, vec3 center, float size, out vec3 n )\n{\n    vec2 uv = center.xz;\n    vec2 res = iChannelResolution[1].xy;\n    \n    float s = 1.;\n    vec2 p00 = uv + vec2(-.5, -.5) * size * s;\n    vec2 p10 = uv + vec2( .5, -.5) * size * s;\n    vec2 p01 = uv + vec2(-.5,  .5) * size * s;\n    vec2 p11 = uv + vec2( .5,  .5) * size * s;\n    \n    float lod = float(MIN_LOD);\n    float t00 = getHeightmap(iChannel0, p00, lod) * SCALE;\n    float t10 = getHeightmap(iChannel0, p10, lod) * SCALE;\n    float t01 = getHeightmap(iChannel0, p01, lod) * SCALE;\n    float t11 = getHeightmap(iChannel0, p11, lod) * SCALE;\n            \n    vec3 v0 = vec3(p00, t00).xzy;\n    vec3 v1 = vec3(p10, t10).xzy;\n    vec3 v2 = vec3(p01, t01).xzy;\n    vec3 v3 = vec3(p11, t11).xzy;\n\n    vec3 n0, n1;\n    vec3 tri0 = triIntersect(ro, rd, v0, v2, v1, n0);\n    vec3 tri1 = triIntersect(ro, rd, v1, v2, v3, n1);\n\n    float t = MAX_DIST;\n    \n    if (tri0.x < t)\n    {\n        t = tri0.x;\n        n = n0;\n    }\n    if (tri1.x < t)\n    {\n        t = tri1.x;\n        n = n1;\n    }\n    \n    return t;\n}\n\nstruct HitInfo {\n    vec3 p;\n    vec3 n;\n    float t;\n    float size;\n    bool hit;\n    int lod;\n    int i;\n};\n\nHitInfo trace(vec3 ro, vec3 rd, int startLod)\n{\n    HitInfo h;\n\n    vec3 srd = sign(rd);\n    \n    if (abs(rd.x) < EPS) rd.x = srd.x * EPS;\n    if (abs(rd.y) < EPS) rd.y = srd.y * EPS;\n    if (abs(rd.z) < EPS) rd.z = srd.z * EPS;\n    \n    vec3 ird = 1. / rd;\n    \n    vec3 p = ro;\n    float scale = SCALE;\n    \n    vec3 n;\n    vec3 bn;\n    bool hit = false;\n    int lod = startLod;\n    float size = 1. / getLodSize(lod);\n    \n    int minLod = MIN_LOD;\n    float t = 0.;\n    //float mh = getTextureLodNearest(iChannel1, iChannelResolution[0].xy, vec2(.5), LOD_LEVELS-1).y * scale;\n    float mh = scale;\n    \n    vec2 id = floor(p.xz/size);\n    int i = 0;\n    \n    if (iFrame < LOD_LEVELS)\n    {\n        h.t = -ro.y * ird.y;\n        h.t = h.t < 0.0 ? MAX_DIST : h.t;\n        h.p = ro + rd * t;\n        h.n = vec3(0, 1, 0);\n        h.size = 1. / getLodSize(MIN_LOD);\n        h.hit = ird.y > 0.0 ? false : true;\n        h.lod = MIN_LOD;\n        h.i = i;\n        \n        return h;\n    }\n    for (; i < MAX_STEPS; i++)\n    {\n        vec2 h = getTextureLodNearest(iChannel1, iChannelResolution[1].xy, (id + .5) * size, lod).xy * scale;\n        vec3 center = vec3((id + .5) * size, .5).xzy;\n        \n        if (p.y >= h.x && p.y <= h.y)\n        {\n            if (lod <= minLod)\n            {\n            #ifdef INTERSECT_OBJECT\n                vec3 nn;\n                float nt = intersectObject(p, rd, center, size, nn);\n                \n                if (nt < MAX_DIST)\n                {\n                    t += nt;\n                    p += rd * nt;\n                    n = nn;\n                    hit = true;\n                    break;\n                }\n            #else\n                vec3 center = vec3((id + .5) * size, (h.x + h.y) * 0.5).xzy;\n                //float nt = intersectBox(p, rd, center, vec3(size * 0.5, h.y - h.x, size * 0.5), bn);\n\n                n = bn;\n                hit = true;\n                break;\n            #endif\n            } else {\n                lod--;\n                size *= .5;\n                id = floor(p.xz/size);\n                continue;\n            }\n        }\n        \n        float sd = intersectSlab(p, ird, h);\n\n        float cd = intersectColumn(p, ird, center, size * .5, bn);\n\n        if (sd <= cd)\n        {\n            if (lod <= minLod)\n            {\n            #ifdef INTERSECT_OBJECT\n                vec3 nn;\n                float nt = intersectObject(p, rd, center, size, nn);\n                \n                if (nt < MAX_DIST)\n                {\n                    t += nt;\n                    p += rd * nt;\n                    n = nn;\n                    hit = true;\n                    break;\n                }\n            #else\n                t += sd;\n                p += rd * sd;\n                n = -vec3(0, 1, 0) * srd.y;\n                hit = true;\n                break;\n            #endif\n            } else {\n                t += sd - EPS;\n                p += rd * (sd - EPS);\n                lod--;\n                size *= .5;\n                id = floor(p.xz/size);\n                continue;\n            }\n        }\n        \n        t += cd;\n        #ifdef INTERSECT_OBJECT\n        p += rd * (cd + EPS);\n        #else\n        p += rd * cd - bn * EPS;\n        #endif\n        \n        //p.xz = fract(p.xz);\n        vec2 pid = id;\n        id = floor(p.xz/size);\n        n = bn;\n        \n        #ifdef DYNAMIC_LOD\n        minLod = clamp(int(ceil(log(t))), 0, LOD_LEVELS);\n        #endif\n        \n        #if 1\n        if (floor(pid/2.) != floor(id/2.) && lod < LOD_LEVELS-1)\n        {\n            lod++;\n            size *= 2.;\n            id = floor(p.xz/size);\n        }\n        #endif\n        \n        //if (any(lessThan(p, vec3(0))) || any(greaterThanEqual(p, vec3(1)))) break;\n        \n        if (p.y > mh && rd.y > 0. || p.y < 0. && rd.y < 0.) break;\n    }\n    \n    h.p = p;\n    h.n = n;\n    h.t = t;\n    h.size = size;\n    h.hit = hit;\n    h.lod = lod;\n    h.i = i;\n    \n    return h;\n}\n\nvec3 getSkyTexture(vec3 rd)\n{\n    float x = atan(rd.z, rd.x) / TAU;\n    float y = -asin(rd.y);\n    y = 0.5 + 0.5 * sign(y) * sqrt(abs(y) / (PI * 0.5));\n    //y = asin(rd.y) / TAU;\n    vec3 col = texture(iChannel2, vec2(x, y) * (iResolution.xy - 1.) / iResolution.xy + 0.5 / iResolution.xy).rgb;\n    \n    vec3 nightCol = vec3(0.004,0.012,0.03) * 0.3;\n    \n    return max(col, nightCol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    float px = 1. / iResolution.y;\n    \n    vec3 ro = vec3(0, -.3, 0);\n    vec3 lo = vec3(0, 0, 1);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax, ay;\n    \n    if (any(lessThan(iMouse.xy, vec2(2))))\n    {\n        ax = PI * 0.05;\n        ay = PI * 0.05;\n    } else {\n        ax = -m.x * TAU;\n        ay = PI * 0.5 + m.y * PI * 0.75;\n    }\n    \n    lo.yz *= rot2D(-ay);\n    lo.xz *= rot2D(ax);\n    lo += ro;\n    \n    vec3 of = vec3(0.2, 0, 0.6) * iTime;\n    \n    ro += of;\n    lo += of;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    vec3 ird = 1. / rd;\n    vec3 srd = sign(rd);\n    \n    vec3 p = ro + .5;\n    p.xz = fract(p.xz);\n    \n    vec3 n = vec3(0);\n    HitInfo tr = trace(p, rd, LOD_LEVELS-1);\n    \n    //fragColor = vec4(tr.n, 1);\n    //return;\n    \n    int lod = tr.lod;\n    float size = tr.size;\n    bool hit = tr.hit;\n    float t = tr.hit ? tr.t : MAX_DIST;\n    \n    p = ro + 0.5 + rd * t;\n    n = tr.n;\n\n    p.xz = fract(p.xz);\n    vec2 id = floor(p.xz/size);\n    \n    vec3 col = vec3(0);\n    \n#ifdef INTERSECT_OBJECT\n\n#ifdef SMOOTH_NORMALS\n    vec2 tuv = p.xz + 0.5 * size;\n    float e = 1.0 / getLodSize(lod);\n    \n    #if 0\n    float hx0 = getHeightmap(iChannel0, tuv - vec2(e, 0), float(lod)) * SCALE;\n    float hy0 = getHeightmap(iChannel0, tuv - vec2(0, e), float(lod)) * SCALE;\n    float hx1 = getHeightmap(iChannel0, tuv + vec2(e, 0), float(lod)) * SCALE;\n    float hy1 = getHeightmap(iChannel0, tuv + vec2(0, e), float(lod)) * SCALE;\n    #else\n    \n    float hx0 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv - vec2(e, 0), lod).y * SCALE;\n    float hy0 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv - vec2(0, e), lod).y * SCALE;\n    float hx1 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv + vec2(e, 0), lod).y * SCALE;\n    float hy1 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv + vec2(0, e), lod).y * SCALE;\n    \n    #endif\n    n = normalize(vec3(hx0 - hx1, e, hy0 - hy1));\n#endif\n    \n    vec3 alb = textureLod(iChannel0, p.xz, float(lod)).rgb;\n#else\n    vec3 alb = textureLod(iChannel0, (id + .5) * size, float(lod)).rgb;\n    \n#endif\n    \n    vec3 amb = getSkyTexture(vec3(0, 1, 0));\n    \n    vec3 ldir = normalize(texelFetch(iChannel1, ivec2(iResolution.xy-1.), 0).rgb);\n    vec3 lldir = normalize(vec3(ldir.xz, max(ldir.y, 0.0)).yzx);\n    vec3 lcol = getSkyTexture(lldir);\n    float la = 1.-pow(1.-ldir.y, 8.);\n    \n    HitInfo sh;\n    if (ldir.y > 0.0)\n    {\n        sh = trace(p + ldir * EPS, ldir, MIN_LOD);\n        \n        float dif = max(dot(n, ldir), 0.0);\n        float sha = float(!sh.hit) * la;\n        dif = dif * sha;\n        \n        col += alb * max(dif * 0.5, 0.02);\n\n        col += alb * sha * lcol * 0.8;\n\n        col += alb * amb * max(dot(reflect(ldir, n), n), 0.0) * 0.5;\n        col += alb * sha * pow(max(dot(normalize(-rd + ldir), n), 0.0), 200.0) * 0.5;\n    }\n    \n    col += alb * dot(abs(n), vec3(0.2, 0.6, 0.2)) * 0.08;\n    col += amb * 0.3;\n    \n#ifndef INTERSECT_OBJECT\n    col *= dot(abs(n), vec3(.85, 1, .7));\n#endif\n    \n    vec3 ard = vec3(rd.xz, abs(rd.y)).xzy;\n    vec3 sky = getSkyTexture(normalize(ard * vec3(1, 0.1, 1)));\n\n#ifdef FOG\n    \n    vec3 fogCol = sky;\n    \n    float a = .02;\n    float b = 4.;\n    \n    float fog = (a/b) * exp(-ro.y*b) * (1.0-exp( -t*rd.y*b ))/rd.y;\n    \n    col = mix(fogCol, col, saturate(1.-fog));\n#endif\n\n    //col = vec3(p.xz, 0);\n    \n    vec3 bg = vec3(0.678,0.859,0.922);\n    \n    if (!hit)\n    {\n        col = getSkyTexture(ard);\n\n        if (ldir.y < 0.0)\n        {\n            vec3 stars;\n\n            vec2 spc = vec2(atan(rd.z, rd.x) / PI, -asin(rd.y) / PI) * 200.;\n            vec2 sid = floor(spc);\n            vec4 h = hash42(sid);\n            vec2 suv = fract(spc) - hash22(sid) - (hash22(sid+iTime) - 0.5) * 0.03;\n            float str = pow(h.x, 3.);\n\n            stars += smoothstep(0.2, 1.0, str * 0.02 / length(suv));\n            stars *= pow(-ldir.y, .33);\n            stars *= mix(palette(h.y), vec3(1), 0.3);\n            \n            col += stars;\n        }\n    }\n    \n    float cosT = dot(rd, ldir);\n    float sunT = acos(cosT);\n    float sunR = 0.526 * TAU / 180.;\n    float sunMask = smoothstep(0.0, px * 2.0, sunR - sunT);\n    sunMask *= pow(1.-(sunT / sunR), 1.0);\n    sunMask *= la;\n\n    col += vec3(1, .8, .4) * 200. * lcol * saturate(sunMask);\n    //col = mix(col, vec3(1, .8, .4) * 200. * lcol, saturate(sunMask));\n    \n    #ifdef SHOW_STEPS\n    #ifdef SHOW_SHADOW_STEPS\n    float s = float(sh.i) / float(MAX_STEPS-1);\n    #else\n    float s = float(tr.i) / float(MAX_STEPS-1);\n    #endif\n    \n    col = pow(turbo(s), vec3(2.2));\n    \n    if (fragCoord.y < 11.)\n        col = pow(turbo(fragCoord.x / iResolution.x), vec3(2.2));\n    #endif\n    \n    #ifdef VIEW_LODS\n    \n    vec2 st = fragCoord.xy / iResolution.y;\n    int i = int(iTime)%(LOD_LEVELS+1);\n    if (i == 0)\n    {\n        col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    } else {\n        col = getTextureLodNearest(iChannel1, iChannelResolution[0].xy, st, i).rgb;\n        \n        if (st.x > 1. || st.y > 1.)\n            col = vec3(0);\n    }\n    #endif\n\n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    //col = 1.0-exp(-col*2.0);\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nconst vec2 off[9] = vec2[9](\n    vec2(-1, -1), vec2(-1,  1), \n\tvec2( 1, -1), vec2( 1,  1), \n\tvec2( 1,  0), vec2( 0, -1), \n\tvec2( 0,  1), vec2(-1,  0), vec2(0, 0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (all(equal(ivec2(fragCoord-.5), ivec2(iResolution.xy-1.))))\n    {\n        vec3 ldir = normalize(vec3(-0.6, 1, 0.3));\n    \n        ldir.yz *= rot2D(-iTime * PI * 0.05 + PI * 0.25);\n        //ldir.yz *= rot2D(-42.8 * PI * 0.05 + PI * 0.25);\n        \n        \n        ldir = normalize(ldir);\n        fragColor = vec4(ldir, 1);\n        return;\n    }\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    int lod = 0;\n    for(; lod <= LOD_LEVELS; lod++)\n    {\n        if (fragCoord.x < float(LOD_TEX_END[lod]))\n            break;\n    }\n    \n    float offset = float(LOD_TEX_END[lod]);\n    float size = getLodSize(lod);\n    if (fragCoord.y < size && lod <= LOD_LEVELS)\n    {\n        uv = fract((fragCoord - vec2(LOD_TEX_START[lod], 0)) / size);\n        \n        if (lod > 0)\n        {\n            float size2 = getLodSize(lod-1);\n            vec2 px = uv * size2 + .5;\n            \n            float sizen1 = getLodSize(lod-1);\n            vec2 res = iChannelResolution[1].xy;\n            \n            vec4 t00 = getTextureLodNearest(iChannel1, res, (px - vec2(0, 0)) / size2, lod-1);\n            vec4 t10 = getTextureLodNearest(iChannel1, res, (px - vec2(1, 0)) / size2, lod-1);\n            vec4 t01 = getTextureLodNearest(iChannel1, res, (px - vec2(0, 1)) / size2, lod-1);\n            vec4 t11 = getTextureLodNearest(iChannel1, res, (px - vec2(1, 1)) / size2, lod-1);\n            \n            float minH = min(min(t00.r, t10.r), min(t01.r, t11.r));\n            float maxH = max(max(t00.g, t10.g), max(t01.g, t11.g));\n            \n            //fragColor = max(max(t00, t10), max(t01, t11));\n            //fragColor.a = 1.;\n            \n            fragColor = vec4(minH, maxH, 0, 1);\n            \n            //fragColor = vec4(px / size2,0,1);\n            //fragColor = texture(iChannel0, uv).rrrr;\n        } else {\n            \n            vec2 res = iChannelResolution[0].xy;\n            \n            uv = fract((floor(fragCoord) - vec2(LOD_TEX_START[lod], 0)) / size) + .5 / res;\n        \n            float minH = 1e3;\n            float maxH = -1e3;\n            \n            int d = 4;\n            \n            for (int x = -d; x <= d; x++)\n            {\n                for (int y = -d; y <= d; y++)\n                {\n                    float t = getHeightmap(iChannel0, uv + vec2(x, y) / res);\n                    \n                    minH = min(minH, t);\n                    maxH = max(maxH, t);\n                }\n            }\n            \n            fragColor = vec4(minH, maxH, 0, 1);\n            //fragColor = texture(iChannel0, uv).rrrr;\n        }\n    } else {\n        fragColor = vec4(vec3(0), 1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Distance fog\n#define FOG\n\n// Intersect object (currently only triangles)\n// Comment to enable columns only\n#define INTERSECT_OBJECT\n\n// Enable lod distance (doesn't do much for perf anyways)\n//#define DYNAMIC_LOD\n\n// Show the number of steps taken to traverse\n//#define SHOW_STEPS\n//#define SHOW_SHADOW_STEPS\n\n//#define SMOOTH_NORMALS\n\n// \n//#define VIEW_LODS\n\n#define MAX_STEPS 256\n#define SCALE 0.15\n\n#define MIN_LOD 0\n//#define MIN_LOD (int(iTime / 2.) % LOD_LEVELS)\n#define LOD_LEVELS 8\n\n\n#define EPS 2e-5\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n#define MAX_DIST 1e3\n\nconst int LOD_TEX_START[LOD_LEVELS+1] = int[](0, 256, 384, 448, 480, 496, 504, 508, 510);\nconst int LOD_TEX_END[LOD_LEVELS+1] = int[](256, 384, 448, 480, 496, 504, 508, 510, 511);\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat luminance(vec3 c)\n{\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat getLodSize(int lod)\n{\n    return float(1<<(LOD_LEVELS-lod));\n}\n\n// Heightmap\nfloat getHeightmap(sampler2D tex, vec2 uv, float lod)\n{\n    // Using textures\n    return pow(luminance(textureLod(tex, uv, lod+2.0).rgb), 1.);\n    //return textureLod(tex, uv, lod).r;\n    \n    // Procedural\n    //return saturate((sin(uv.x*TAU) * cos(uv.y*TAU)) * 0.5 + 0.5);\n}\n\nfloat getHeightmap(sampler2D tex, vec2 uv)\n{\n    return getHeightmap(tex, uv, 0.);\n}\n\nvec4 getTextureLod0(sampler2D tex, vec2 size, vec2 uv, int lod)\n{\n    vec2 tex_size = vec2(getLodSize(0));\n    vec2 new_uv = fract(uv) * tex_size - 0.5;\n    \n    return textureLod(tex, new_uv / size, 0.0);\n}\n\nvec4 getTextureLod(sampler2D tex, vec2 size, vec2 uv, int lod)\n{\n    vec2 tex_size = vec2(getLodSize(lod));\n    vec2 new_uv = fract(uv) * tex_size + vec2(LOD_TEX_START[lod], 0);\n\n    return texture(tex, new_uv / size);\n}\n\nvec4 getTextureLodNearest(sampler2D tex, vec2 size, vec2 uv, int lod)\n{\n    vec2 tex_size = vec2(getLodSize(lod));\n    vec2 new_uv = fract(uv) * tex_size + vec2(LOD_TEX_START[lod], 0);\n\n    return texelFetch(tex, ivec2(new_uv), 0);\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, .95, .9) * t + vec3(0, .3, .5)));\n}\n\nvec3 paletteR(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1) * t + vec3(0, .3, .5)));\n}\n\n// Turbo Colormap\n// https://www.shadertoy.com/view/3lBXR3\nvec3 turbo(float t) {\n\n    const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n    const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n    const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n    const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n    const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n    const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n    const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n// https://iquilezles.org/articles/intersectors/\n\n// Ray-Sphere Intersection\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Ray-Box Intersection\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(MAX_DIST); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n// Ray-Tri Intersection\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, out vec3 normal )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3 n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    \n    if (d > 0.0) return vec3(MAX_DIST, 0, 0);\n    \n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    \n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) return vec3(MAX_DIST, 0, 0);\n    \n    normal = normalize(n);\n    return vec3( t, u, v );\n}\n\n// cheap sky simulation - Jodie\n// https://www.shadertoy.com/view/ttSGzh\n\n#define atmosphereHeight 8228.\n#define earthRadius 6371000.\n#define mieHeight 1200\n//http://www.vendian.org/mncharity/dir3/starcolor/\n#define sunColor pow(vec3(0xff,0xf5,0xf2)/255.,vec3(2.2))\n#define ozoneHeight 30000.\n// http://skyrenderer.blogspot.com/2012/10/ozone-absorption.html\n// https://www.spectroscopyeurope.com/article/new-broadband-high-resolution-ozone-absorption-cross-sections\n#define ozoneCoefficient (vec3(3.426, 8.298, .356) * 6e-5 / 100.)\n#define mieCoefficient 3e-6 // adjust for foggier look\n#define earthAlbedo pow(vec3(0x99,0x92,0x80)/255.,vec3(2.2))\n\n// ( Riley, Ebert, Kraus )\n//#define rayleighCoefficient vec3(5.8e-6  , 1.35e-5 , 3.31e-5 )\n// ( Bucholtz )\n//#define rayleighCoefficient vec3(4.847e-6, 1.149e-5, 2.87e-5 ) \n// ( Thalman, Zarzana, Tolbert, Volkamer )\n//#define rayleighCoefficient vec3(5.358e-6, 1.253e-5, 3.062e-5)\n// ( Penndorf )\n#define rayleighCoefficient vec3(5.178e-6, 1.226e-5, 3.06e-5 )\n\n#define up vec3(0,1,0)\n\n//b = dotup\nvec3 getSkyThicknesses(float b){\n    const vec4 sr = earthRadius + vec4(\n        atmosphereHeight,\n        mieHeight,\n        ozoneHeight,\n        ozoneHeight + atmosphereHeight\n    );\n    b*=earthRadius;\n    const float r2 = earthRadius * earthRadius;\n    vec4 z = sqrt( sr * sr + (b * b - r2) );\n    return vec3(b+z.xy, z.w-z.z);\n}\n\n// Improved Rayleigh phase for single scattering\n// https://old.cescg.org/CESCG-2009/papers/PragueCUNI-Elek-Oskar09.pdf\n// note: integral from -1 to 1 of function in the paper is 2.24\n#define phaseRayleigh(a) (( .4 * (a) + 1.12 )/2.24)\n//#define phaseRayleigh(a) ((3./8.)*(1.+(a)*(a)))\n\n// (Henyey Greenstein)\n// https://www.astro.umd.edu/~jph/HG_note.pdf\nfloat phaseg(float x,float g){\n    const float  b = 1./2.;\n    float a = inversesqrt(1.+g*g-2.*g*x);\n\treturn b*(1.-g*g)*a*a*a;\n}\nfloat phaseMie(const float VdotL, const float depth){\n    //curve fit with turingbot\n    float g = atan(sin(pow(0.7,depth*mieCoefficient)));\n    return phaseg(VdotL, g);\n}\n\n// https://iquilezles.org/articles/sphereshadow\nfloat sphSoftShadow(vec3 position,vec3 L){\n    const float k = 5.;\n    //vec4 sph = vec4(-up*earthRadius,earthRadius);\n    vec3 oc = position + up * earthRadius;\n    float b = dot( oc, L );\n    float c = dot( oc, oc ) - earthRadius*earthRadius;\n    float h = b*b - c;\n    \n    float d = -earthRadius + sqrt( max(0.0,earthRadius*earthRadius-h));\n    float t = -b - sqrt( max(0.0,h) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );\n}\n\nvec3 getSky(const vec3 V, const vec3 L) {\n\n    const mat3 coeffs = mat3(\n        rayleighCoefficient      ,\n        vec3(mieCoefficient*1.11), // mie absorbs (Bruneton)\n        ozoneCoefficient\n    );\n    \n    float VdotUp = -V.y;\n    float LdotUp = -L.y;\n    \n    vec3 thicknesses = getSkyThicknesses(VdotUp);\n    float VdotL = dot(V, L);\n\n    vec3 rayleighScatter =(thicknesses.x * phaseRayleigh(VdotL))          * rayleighCoefficient;\n    float     mieScatter = thicknesses.y * phaseMie(VdotL, thicknesses.y) *      mieCoefficient;\n\n\tvec3 scattering = rayleighScatter + mieScatter;\n    \n    vec3 sunCoeff = coeffs * getSkyThicknesses(LdotUp);\n    vec3 viewCoeff = coeffs * thicknesses;\n    vec3 absorption = (exp(-viewCoeff)-exp(-sunCoeff)) / (sunCoeff - viewCoeff);\n    \n    //  integral of x from 0 to 1\n    //  exp( -a*x - b*(1-x) )\n    //\n    //  e⁻ᵃ - e⁻ᵇ\n    // ---------\n    //  (a - b) \n    \n    float earthShadow = sphSoftShadow(thicknesses.x*V,L);\n    \n    if(dot(V,up)<0.)return earthAlbedo * sunColor * exp(-sunCoeff);\n\n    return sunColor * scattering * absorption * earthShadow;\n}\n\nvec3 sphere(vec3 rpos, vec3 rd){\n\n    vec3 oc = -rpos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - 1.; \n\t\n\tfloat h = b*b - c; \n\n    float t = b - sqrt(h);\n\tvec3 n = oc-rd*t;\n    if(n.z<0.||h<0.)return rd.xzy;\n    return n;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ldir = texelFetch(iChannel0, ivec2(iResolution.xy-1.), 0).rgb;\n    \n    float y = uv.y;\n    if (y < 0.5) {\n\t\ty = 1.0 - 2.0 * y;\n\t\ty = -y * y;\n\t} else {\n\t\ty = y * 2.0 - 1.0;\n\t\ty = y * y;\n\t}\n    \n    float theta = uv.x * TAU;\n    float phi = -y * 0.5 * PI;\n    \n    vec3 rd = vec3(cos(theta) * cos(phi), sin(phi), sin(theta) * cos(phi));\n\n    fragColor = vec4(getSky(rd, ldir), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}