{
    "Shader": {
        "info": {
            "date": "1704828721",
            "description": "An 8x8 gaussian blur using 16 carefully places samples. ",
            "flags": 0,
            "hasliked": 0,
            "id": "McBGWd",
            "likes": 3,
            "name": "Gaussian 8x8 (16 taps)",
            "published": 3,
            "tags": [
                "blurgaussian"
            ],
            "usePreview": 0,
            "username": "WizardOfOzzz",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "vec4 saturate(vec4 v) {\n  return clamp(v, 0.0, 1.0);\n}\n\nfloat gaussian(float v, float twoSigmaSq) {\n  return exp(-(v * v) / twoSigmaSq);  \n}\n\nvec4 gaussian(vec4 v, float twoSigmaSq) {\n  return exp(-(v * v) / twoSigmaSq);\n}\n\nvec4 truncatedGaussian(vec4 v, float twoSigmaSq, float trunc) {\n  return saturate(gaussian(v, twoSigmaSq) - trunc); \n}\n\n// A 8x8 gaussian blur using 16 carefully placed bilinear samples.\nvec4 blur8x8(in vec2 texCoord, float twoSigmaSq, float trunc) {\n  vec2 size = iChannelResolution[0].xy;\n  vec2 texel = 1.0 / size.xy;\n\n  // Fraction of a pixel\n  vec2 a = fract(texCoord * size.xy - vec2(0.5));\n\n  // Compute 6 x/y distances to neighboring texels in x/y. The offsets alternate between\n  // two variables so we can compute a ratio later (that determines final sample location).\n  vec4 xDist0 = -a.xxxx + vec4(-3.0, -1.0, 1.0, 3.0);\n  vec4 xDist1 = xDist0 + 1.0;\n  vec4 yDist0 = -a.yyyy + vec4(-3.0, -1.0, 1.0, 3.0);\n  vec4 yDist1 = yDist0 + 1.0;\n\n  // Corresponding gaussian weights in x/y.\n  vec4 gx0 = truncatedGaussian(xDist0, twoSigmaSq, trunc);\n  vec4 gx1 = truncatedGaussian(xDist1, twoSigmaSq, trunc);\n  vec4 gy0 = truncatedGaussian(yDist0, twoSigmaSq, trunc);\n  vec4 gy1 = truncatedGaussian(yDist1, twoSigmaSq, trunc);\n\n  // Final sample offsets in x/y.\n  vec4 gx01 = gx0 + gx1;\n  vec4 gy01 = gy0 + gy1;\n  vec4 xOffsets = (xDist0 + (gx1 / gx01)) * texel.x;\n  vec4 yOffsets = (yDist0 + (gy1 / gy01)) * texel.y;\n\n  // 4 rows of 4 weights (for the 16 bilinear samples).\n  vec4 w0 = gx01 * gy01.x;\n  vec4 w1 = gx01 * gy01.y;\n  vec4 w2 = gx01 * gy01.z;\n  vec4 w3 = gx01 * gy01.w;\n\n  vec4 result = vec4(0.0);\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.x)) * w0.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.x)) * w0.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.x)) * w0.z;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.w, yOffsets.x)) * w0.w;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.y)) * w1.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.y)) * w1.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.y)) * w1.z;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.w, yOffsets.y)) * w1.w;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.z)) * w2.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.z)) * w2.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.z)) * w2.z;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.w, yOffsets.z)) * w2.w;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.w)) * w3.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.w)) * w3.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.w)) * w3.z;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.w, yOffsets.w)) * w3.w;\n\n  float weight = dot(vec4(1.0), w0) + dot(vec4(1.0), w1) + dot(vec4(1.0), w2) + dot(vec4(1.0), w3);\n  return result / weight;\n}\n\n\nvoid mainImage( out vec4 outColor, in vec2 coord )\n{\n  float blurMinSigma = 0.4;\n  float blurMaxSigma = 3.0;\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = coord / iResolution.xy;\n  \n  // Use a sine wave for animation.\n  float sine = sin(iTime * 3.0) * 0.5 + 0.5;\n  float sigma = sine * (blurMaxSigma - blurMinSigma) + blurMinSigma;\n  float twoSigmaSq = sigma * sigma * 2.0; \n  float trunc = gaussian(4.0, twoSigmaSq);  \n  outColor.rgb = blur8x8(uv, twoSigmaSq, trunc).rgb;\n  outColor.a = 1.0;\n  \n  // Comparison with bilinear\n  //outColor.rgb = texture( iChannel0, uv).rgb;;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}