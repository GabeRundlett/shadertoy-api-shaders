{
    "Shader": {
        "info": {
            "date": "1638317533",
            "description": "I don't like this + artifact at 0 angle",
            "flags": 0,
            "hasliked": 0,
            "id": "NtG3DV",
            "likes": 14,
            "name": "Grid Segments fork",
            "published": 3,
            "tags": [
                "e"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\n// idk what to call this\nvec2 func(float t) {\n    return vec2(.5 + .5 * cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy)/ iResolution.y;\n    //uv += 2. + 0.04 * iTime;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    uv = vec2(4. * a/pi, log(r) - 0.1 * iTime);\n    \n    float c = 100.;\n    // cant scale dynamically because sc used in h21 (bad)\n    float sc = 5.;// + 1./length(ouv-ms);\n    vec2 fpos = fract(sc * uv) - 0.;\n    vec2 ipos = floor(sc * uv) + 0.5;    \n    \n    // Generate values for each corner of uv (sloppy)\n    float l  = h21(ipos.x + 1., ipos.y,      c * sc);\n    float t  = h21(ipos.x,      ipos.y + 1., c * sc);\n    float tl = h21(ipos.x + 1., ipos.y + 1., c * sc);\n    float id = h21(ipos.x,      ipos.y,      c * sc);\n\n    // Smooth fpos completely, so v noise looks better\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Smooth the grid uvs so different uvs meet continuously on the edges\n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n    \n    // shift fpos correctly\n    fpos -= 0.5;\n    \n    // moving points for each cell\n    vec2 p = pnt(ipos, sc);\n\n    vec2 pl = -vec2(1.,0.) + pnt(ipos - vec2(1.,0.), sc);\n    vec2 pr =  vec2(1.,0.) + pnt(ipos + vec2(1.,0.), sc);\n    vec2 pt = -vec2(0.,1.) + pnt(ipos - vec2(0.,1.), sc);\n    vec2 pb =  vec2(0.,1.) + pnt(ipos + vec2(0.,1.), sc);\n    \n    // used to change intensity of each segment\n    float rl = h21(vec2((ipos.x - 1.) * ipos.x, ipos.y));\n    float rr = h21(vec2((ipos.x + 1.) * ipos.x, ipos.y));\n    float rt = h21(vec2(ipos.x, (ipos.y - 1.) * ipos.y));\n    float rb = h21(vec2(ipos.x, (ipos.y + 1.) * ipos.y));   \n    \n    // draw half of each segment for each cell\n    float dl = sdSegment(fpos, p, pl);\n    float dr = sdSegment(fpos, p, pr);\n    float dt = sdSegment(fpos, p, pt);\n    float db = sdSegment(fpos, p, pb);\n        \n    // Outline line segments, scale with v\n    // (m = thickness of line, n = thickness of outline)  \n    float m = 0.05 + 0.07 * v;\n    float ml = m + 0.1 * cos(length(p - pl));\n    float mr = m + 0.1 * cos(length(pr - p));\n    float mt = m + 0.1 * cos(length(p - pt));\n    float mb = m + 0.1 * cos(length(pb - p));\n    float mm = 0.1;\n    ml = min(ml, mm);mr = min(mr, mm);mt = min(mt, mm);mb = min(mb, mm);\n      \n    float n = 0.18;\n    float sl = rl * (step(0.,ml - dl)-step(0., n * ml - dl));\n    float sr = rr * (step(0.,mr - dr)-step(0., n * mr - dr));\n    float st = rt * (step(0.,mt - dt)-step(0., n * mt - dt));\n    float sb = rb * (step(0.,mb - db)-step(0., n * mb - db));\n    \n    /*\n    float n2 = 0.08 * h21(uv);  \n    float sl = rl * (smoothstep(-n2,n2,ml - dl)-smoothstep(-n2,n2, n * ml - dl));\n    float sr = rr * (smoothstep(-n2,n2,mr - dr)-smoothstep(-n2,n2, n * mr - dr));\n    float st = rt * (smoothstep(-n2,n2,mt - dt)-smoothstep(-n2,n2, n * mt - dt));\n    float sb = rb * (smoothstep(-n2,n2,mb - db)-smoothstep(-n2,n2, n * mb - db));\n    //*/\n    float s = max(max(sl, sr), max(st, sb));\n    \n    // Segment colors\n    vec3 col = 1. * s + s * pal(0.5 * v + r * 0.5 - 0.3 * iTime, vec3(0.), vec3(1.), vec3(1.),  \n                  2. * r * cos(s + 0.15 * iTime) * vec3(0.,0.33,0.66));\n\n    col = clamp(8. * pow(length(ouv), 2.) * col, vec3(0.), col);\n    \n    fragColor = vec4(col, 1.); //vec4(v);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}