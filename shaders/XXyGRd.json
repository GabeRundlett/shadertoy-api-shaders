{
    "Shader": {
        "info": {
            "date": "1718040951",
            "description": "Im just playing arround",
            "flags": 0,
            "hasliked": 0,
            "id": "XXyGRd",
            "likes": 1,
            "name": "I'm not sure",
            "published": 3,
            "tags": [
                "random",
                "something",
                "playing"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 88
        },
        "renderpass": [
            {
                "code": "const float res = 20.;\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa - ba*h);\n\n    return 1. - smoothstep(0.0, thickness, idk);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord - 0.5 * iResolution.xy) / iResolution.y) * res;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec2 p1 = vec2(floor(uv));\n    vec2 p4 = vec2(ceil(uv));\n   \n    vec2 p2 = vec2(p4.x, p1.y);\n    vec2 p3 = vec2(p1.x, p4.y);\n    \n    float time = iTime / 2.;\n    \n    vec2 r1 = normalize(hash32(p1, iTime) - .5) * 0.5;\n    vec2 r2 = normalize(hash32(p2, iTime) - .5) * 0.5;\n    vec2 r3 = normalize(hash32(p3, iTime) - .5) * 0.5;\n    vec2 r4 = normalize(hash32(p4, iTime) - .5) * 0.5;\n    \n    col += vec3(.8) * lineSegment(uv, p1, p1 + r1);\n    col += vec3(.8) * lineSegment(uv, p2, p2 + r2);\n    col += vec3(.8) * lineSegment(uv, p3, p3 + r3);\n    col += vec3(.8) * lineSegment(uv, p4, p4 + r4);\n    \n    float r = 0.;\n    float g = 0.;\n    float _dot = dot(fract(uv), r1);\n    if(_dot < 0.) r += abs(_dot);\n    else g += abs(_dot);\n    \n    _dot = dot(fract(uv), r2);\n    if(_dot < 0.) r += abs(_dot);\n    else g += abs(_dot);\n    \n    _dot = dot(fract(uv), r3);\n    if(_dot < 0.) r += abs(_dot);\n    else g += abs(_dot);\n    \n    _dot = dot(fract(uv), r4);\n    if(_dot < 0.) r += abs(_dot);\n    else g += abs(_dot);\n    \n    col += vec3(r,g,0) / 4.0;\n\n    if(fract(uv.x) < 0.01 || fract(uv.y) < 0.01) col = vec3(1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uint uSeed = 65319165u;\nfloat ConvertToFloat(uint n)\n{\n    uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    uint ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32\n\n    n &= ieeeMantissa;\n    n |= ieeeOne;\n\n    float f = uintBitsToFloat(n);\n    return f - 1.0;\n}\n//pcg_hash https://stackoverflow.com/questions/70985360/how-to-create-a-3d-random-gradient-out-of-3-passed-values-in-a-fragment-shader\n//minor change to add a seed value\nfloat rand(uint i) {\n    uint state = i + (i * 747796405u + 2891336453u) ^ uSeed;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return ConvertToFloat((word >> 22u) ^ word);\n}\n\nfloat rand(float i) { return rand(floatBitsToUint(i)); }\n\nvec2 hash32(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y));\n    randV *= dot(randV, vec2(8183.0119, src.z));\n    \n    return fract(randV);\n}\nvec2 hash32(vec2 src, float z) {\n    return hash32(vec3(src, z));\n}\nvec2 hash32(vec2 src, int z) {\n    return hash32(vec3(src, z));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}