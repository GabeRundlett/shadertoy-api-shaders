{
    "Shader": {
        "info": {
            "date": "1648972464",
            "description": "based on https://gam0022.net/blog/2017/03/02/raymarching-fold/",
            "flags": 0,
            "hasliked": 0,
            "id": "7tlyDs",
            "likes": 3,
            "name": "snow crystal",
            "published": 3,
            "tags": [
                "fold"
            ],
            "usePreview": 0,
            "username": "takahiroando",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI 3.14151692\n#define PI2 (PI * 2.0)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\nvec3 foldX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat dTree(vec3 p) {\n    // <draw stem>\n    \n    // To see complete shape, just set 0.6 to scale\n    float scale = 0.6;// * saturate(1.5 * sin(0.05 * iTime));\n    float width = mix(0.3 * scale, 0.0, saturate(p.y)); // which means width gradually thin from the origin, from 0.3 * scale to 0.0\n    vec3 size = vec3(width, 1.0, width);\n    // To see how the box looks like, uncomment this line\n    //p.xz *= rot(iTime * 0.1);\n    float d = sdBox(p, size);\n    \n    // </draw stem>\n    \n    // <draw branches>\n    // same idea with tree fold\n    for (int i = 0; i < 10; i++) {\n        vec3 q = p;\n        q = foldX(q);\n        q.y -= 0.5 * size.y;\n        q.xy *= rot(-1.2);\n        d = min(d, sdBox(p, size));\n        p = q;\n        size *= scale;\n    }\n    // </draw branches>\n\n    return d;\n}\n\nfloat dSnowCrystal(inout vec3 p) {\n    // To see the effect of foldRotate, comment this line out. You would see a shape like a tree.\n    p.xy = foldRotate(p.xy, 6.0);\n    return dTree(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-3);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=dSnowCrystal(p));\n    if(d<.001)fragColor+=3./i;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}