{
    "Shader": {
        "info": {
            "date": "1522321474",
            "description": "An adaptation of Shane's [url]https://www.shadertoy.com/view/XsGyDh[/url] to show the Kummer surface, [url]http://mathworld.wolfram.com/KummerSurface.html[/url]\n\nRemoved background & added mouse rotation, also recalculated some coefficients.",
            "flags": 32,
            "hasliked": 0,
            "id": "MdGyDm",
            "likes": 15,
            "name": "Quartic Solver: Kummer Surface",
            "published": 3,
            "tags": [
                "solver",
                "surface",
                "quartic",
                "kummer"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 1181
        },
        "renderpass": [
            {
                "code": "// Original shader created by Shane, 2018:\n// https://www.shadertoy.com/view/XsGyDh\n// Adapted by Matthew Arcus to show the Kummer surface:\n// http://mathworld.wolfram.com/KummerSurface.html\n\n/* NB: comments etc. by Shane */\n/*\n\n\tRaytraced Quartic Surface\n\t-------------------------\n\n\tMattz's quartic solvers inspired me to put this together, and Ninjakoala's refined\n\tquartic solver enabled me to port it to Shadertoy. :) I coded up a generalized quartic \n\tsurface intersection many years ago, and didn't particularly enjoy the experience, \n\tso haven't been in a hurry to port it to the pixel shader environmnet. :)\n\t\n\tFor the most part, I did this for academic purposes. I like raytracing, but I find \n\tit a bit limiting. It appears that everyone else does too, because raytraced triangulated \n\tscenes aside, I seldom see anything more than basic primitives rendered. This is \n\tunderstandable, since surfaces described by higher order equations require far more \n\tcalculation.\n\n\tFor that reason, there's not a lot of raytraced quartic code out there, but now there's\n\ta reference on Shadertoy... I don't have a great deal of interest in it myself, but I \n\tfigured the raytracing crowd might find it novel having something to render other than \n\tspheres and cylinders. :)\n\n\tAnother reason I avoid realtime raytraced scenes is the hard shadows. With this example,\n\tI partly got around the problem by employing a cheap jittering trick, which I wouldn't \n\trecommend, but I think I got away with it here... kind of. :)\n\n\tI applied some geometric tiling and a simple radial blur, in a half hearted attempt to \n\tmake up for the fact that this is a pretty uninspiring lacklustre scene. :)\t\n\n\tBy the way, I hurriedly hacked together the reflection\\refraction loop as an \n\tafterthought. It's not entirely physically accurate, since it lacks proper stack logic, \n\tbut other than that, it seems to be about right. However, if anyone spots any errors \n\t(incorrect normal direction, calculation, etc), feel free to let me know.\n\n\n \tQuartic examples:\n\n\tEllipse / quartic - mattz\n\thttps://www.shadertoy.com/view/4dVcR1\n\n\tCubic bezier - Signed Distance - NinjaKoala\n\thttps://www.shadertoy.com/view/4sKyzW\n\n    \n\tRaytracing examples for grown ups. :D\n\tActually, they might be raymarched, but either way. :)\n\n\tstochastic path tracer v1 - otaviogood\n\thttps://www.shadertoy.com/view/4ddcRn\n\n\n\tSpectral Path Tracer Test - P_Malin\n\thttps://www.shadertoy.com/view/4s3cRr\n\n\t\n\n\n\n\tFull Scene Radial Blur\n\t----------------------\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 32.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    //vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    //mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(.5, 3., 2.5));\n    //l.xz = a * l.xz;\n    //l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.925; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.7; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.05; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer and brighter.\n    vec4 col = texture(iChannel0, uv.xy)*0.5;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    //col = mix(col, col.xzyw, uv.y);\n    col = mix(col, vec4(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)));\n\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    //col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit more.\n    //col = smoothstep(0., .5, col);\n    \n    // Bypassing the radial blur to show the scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n    \n    fragColor = sqrt(mix(max(col, 0.), texture(iChannel0, fragCoord.xy / iResolution.xy), .5));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Original shader created by Shane, 2018:\n// https://www.shadertoy.com/view/XsGyDh\n// Adapted by Matthew Arcus to show the Kummer surface:\n// http://mathworld.wolfram.com/KummerSurface.html\n\n/*\n\n\tRaytraced Quartic Surface\n\t-------------------------\n\n\tMattz's quartic solvers inspired me to put this together, and Ninjakoala's refined\n\tquartic solver enabled me to port it to Shadertoy. :) I coded up a generalized quartic \n\tsurface intersection many years ago, and didn't particularly enjoy the experience, \n\tso haven't been in a hurry to port it to the pixel shader environmnet. :)\n\t\n\tFor the most part, I did this for academic purposes. I like raytracing, but I find \n\tit a bit limiting. It appears that everyone else does too, because raytraced triangulated \n\tscenes aside, I seldom see anything more than basic primitives rendered. This is \n\tunderstandable, since surfaces described by higher order equations require far more \n\tcalculation.\n\n\tFor that reason, there's not a lot of raytraced quartic code out there, but now there's\n\ta reference on Shadertoy... I don't have a great deal of interest in it myself, but I \n\tfigured the raytracing crowd might find it novel having something to render other than \n\tspheres and cylinders. :)\n\n\tAnother reason I avoid realtime raytraced scenes is the hard shadows. With this example,\n\tI partly got around the problem by employing a cheap jittering trick, which I wouldn't \n\trecommend, but I think I got away with it here... kind of. :)\n\n\tI applied some geometric tiling and a simple radial blur, in a half hearted attempt to \n\tmake up for the fact that this is a pretty uninspiring lacklustre scene. :)\t\n\n\tBy the way, I hurriedly hacked together the reflection\\refraction loop as an \n\tafterthought. It's not entirely physically accurate, since it lacks proper stack logic, \n\tbut other than that, it seems to be about right. However, if anyone spots any errors \n\t(incorrect normal direction, calculation, etc), feel free to let me know.\n\n\n \tQuartic examples:\n\n\tEllipse / quartic - mattz\n\thttps://www.shadertoy.com/view/4dVcR1\n\n\tCubic bezier - Signed Distance - NinjaKoala\n\thttps://www.shadertoy.com/view/4sKyzW\n\n    \n\tRaytracing examples for grown ups. :D\n\tActually, they might be raymarched, but either way. :)\n\n\tstochastic path tracer v1 - otaviogood\n\thttps://www.shadertoy.com/view/4ddcRn\n\n\n\tSpectral Path Tracer Test - P_Malin\n\thttps://www.shadertoy.com/view/4s3cRr\n\n\n*/\n\n\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n////////////////////\n#define eps .000005\n\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs.y / 2.;\n\n    float D = p*p - coeffs.x;   \n    \n    if (D <= 0.){\n\t\treturn 0;\n    }\n    else {\n\t\troots = vec2(-1, 1)*sqrt(D) - p;\n\t\treturn 2;\n    }\n}\n\n\n// The following is a variation on the standard cubic solver that I see all over the \n// place. I can thank NinjaKoala for his Newton iteration fix. Basically, he's \n// performing an extra numerical analysis step to accommodate for the loss of accuracy\n// this function suffers from when -- and this is just a guess -- switching from \n// \"double\" accuracy to \"float\" accuracy. Either way, it worked for me, and I'm \n// thankful. :)\n//\n// By the way, I trimmed the function down just slightly to repurpose it to my needs,\n// but it's still needs a bit of trimming, and so forth, which I'll get to later.\n// In fact, I might rewrite it from scratch when I'm feeling bored enough.\n\n// From Trisomie21. But instead of his cancellation fix I'm using a Newton iteration.\n//\n// Cubic bezier - Signed Distance - NinjaKoala\n// https://www.shadertoy.com/view/4sKyzW\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a/3.;\n\tfloat q = a * (2.*a*a - 9.*b)/27. + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.*p3/27.;\n\tfloat offset = -a/3.;\n    \n\tif(d >= 0.0) { // Single solution.\n\t\t\n        /*\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z)/2.;\n\t\tfloat v = (-q - z)/2.;\n\t\tu = sign(u)*pow(abs(u), 1./3.);\n\t\tv = sign(v)*pow(abs(v), 1./3.);\n\t\tr[0] = offset + u + v;\t\n\t\t*/\n        \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n\n\t\t// CHANGE\n\t\t// Single newton iteration to account for cancellation.\n\t\tfloat f = ((r[0] + a)*r[0] + b)*r[0] + c;\n\t\tfloat f1 = (3.*r[0] + 2. * a)*r[0] + b;\n\n\t\tr[0] -= f/f1;\n\n\t\treturn 1;\n\t}\n    \n\tfloat u = sqrt(-p/3.);\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t// Single newton iteration to account for cancellation\n\t// (once for every root).\n\n\tfloat f,f1;\n\tr[0] = offset + u * (m + m);\n\n\tf = ((r[0] + a)*r[0] + b)*r[0] + c;\n\tf1 = (3.*r[0] + 2. * a)*r[0] + b;\n\n\tr[0] -= f / f1;\n\n\tr[1] = offset - u * (n + m);\n\n\tf = ((r[1] + a)*r[1] + b) * r[1] + c;\n\tf1=(3.*r[1] + 2. * a)*r[1] + b;\n\n\tr[1] -= f / f1;\n\n\tr[2] = offset + u * (n - m);\n\n\tf = ((r[2] + a)*r[2] + b)*r[2] + c;\n\tf1 = (3.*r[2] + 2. * a)*r[2] + b;\n\n\tr[2] -= f / f1;\n\n\treturn 3;\n}\n\n\n/*\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n*/\n\n// Cubic bezier - Signed Distance - NinjaKoala\n// https://www.shadertoy.com/view/4sKyzW\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there.\n\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    //  Substitute x = y - A/4 to eliminate cubic term: x^4 + px^2 + qx + r = 0\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t// Doesn't seem to happen for me.\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0] = z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp = vec2(1e8);\n\t\tint old_num = num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                //s[0] = tmp[0];\n                //s[1] = tmp[1];\n                s.xy = tmp.xy;\n            }\n            else{//old_num == 2\n                //s[2] = tmp[0];\n                //s[3] = tmp[1];\n                s.zw = tmp.xy;\n            }\n        }\n    }\n\n    // Resubstitute.\n    s -= a/4.;\n\n    // I seemed to be getting away without doing this, so left it out.\n    /*\n\t//float sub = 1./4.*a;\n\n\t// Single halley iteration to fix cancellation.\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n    */\n\n    return num;\n}\n///////////////\n\n/*//////////////////////////////////////////////\n////////////////////////////////////////////////\n\n    Quartic surface function, with coefficients.\n\n    A400*x^4 + A040*y^4 + A004*z^4 +\n    A310*x^3*y + A301*x^3*z + \n    A031*y^3*z + A130*x*y^3 +\n    A103*x*z^3 + A013*y*z^3 +\n    A220*x^2*y^2 + A022*y^2*z^2 + A202*x^2*y^2 +\n    A211*x^2*y*z + A121*x*y^2*z + A112*x*y*z^2 +\n    A300*x^3 + A030*y^3 + A003*z^3 +\n    A210*x^2*y + A021*y^2*z + A102*x*z^2 +\n    A120*x*y^2 + A012*y*z^2 + A201*x^2*z +\n    A111*x*y*z +\n    A200*x^2 + A020*y^2 + A002*z^2 +\n    A110*x*y + A011*y*z + A101*x*z +\n    A100*x + A010*y + A001*z +\n    A000 = 0\n\n////////////////////////////////////////////////\n//////////////////////////////////////////////*/ \n\n\n#define OUTER\t 1.\t\t// Ray hit primitive\n#define MISS\t 0.\t\t// Ray missed primitive\n#define INNER\t-1.\t\t// Ray started inside primitive\n\nfloat A400, A040, A004;\nfloat A310, A301, A031, A130, A103, A013;\nfloat A220, A022, A202, A211, A121, A112;\nfloat A300, A030, A003;\nfloat A210, A021, A102, A120, A012, A201;\nfloat A111;\nfloat A200, A020, A002;\nfloat A110, A011, A101;\nfloat A100, A010, A001;\nfloat A000;\n\n// Quartic center.\nvec3 qCenter = vec3(0, 0, 0);\n\n// Transform the quartic.\nvec3 transQuartic(in vec3 v){\n    \n    v.xz *= rot2(iTime/4.);\n    v.xy *= rot2(iTime/2.0);\n    return v;\n}\n\n// Makeshift inverse trasformation.\nvec3 invTransQuartic(in vec3 v){\n    \n    v.xy = rot2(iTime/2.0)*v.xy;\n    v.xz = rot2(iTime/4.0)*v.xz;\n    return v;\n}\n\n\nvec3 quarticNorm(vec3 p){\n    \n    // Object translation and rotation.\n    p = transQuartic(p - qCenter);\n    \n\n    vec3 p2 = p*p, p3 = p2*p;\n    \n    // Differentiating the quartic function (see above) describing the surface then plugging\n    // in the surface point position to produce the normal. Partial derivatives, and so forth.\n    // It's pretty standard stuff for anyone with a math background, but if it's not, trust\n    // me, it doesn't take long to learn.\n    \n    vec3 n;\n\n\tn.x = A100 + 2.*A200*p.x + 3.*A300*p2.x + 4.*A400*p3.x + A110*p.y + 2.*A210*p.x*p.y + \n\t\t  3.*A310*p2.x*p.y + A120*p2.y + 2.*A202*p.x*p2.y + \n\t\t  2.*A220*p.x*p2.y + A130*p3.y + A101*p.z + 2.*A201*p.x*p.z + \n\t\t  3.*A301*p2.x*p.z + A111*p.y*p.z + 2.*A211*p.x*p.y*p.z + A121*p2.y*p.z + \n\t\t  A102*p2.z + A112*p.y*p2.z + A103*p3.z;\n    \n\tn.y = A010 + A110*p.x + A210*p2.x + A310*p3.x + 2.*A020*p.y + 2.*A120*p.x*p.y + \n\t\t  2.*A202*p2.x*p.y + 2.*A220*p2.x*p.y + 3.*A030*p2.y + \n\t\t  3.*A130*p.x*p2.y + 4.*A040*p3.y + A011*p.z + A111*p.x*p.z + \n\t\t  A211*p2.x*p.z + 2.*A021*p.y*p.z + 2.*A121*p.x*p.y*p.z + 3.*A031*p2.y*p.z + \n\t\t  A012*p2.z + A112*p.x*p2.z + 2.*A022*p.y*p2.z + A013*p3.z;\n    \n\tn.z = A001 + A101*p.x + A201*p2.x + A301*p3.x + A011*p.y + A111*p.x*p.y + \n\t\t  A211*p2.x*p.y + A021*p2.y + A121*p.x*p2.y + A031*p3.y + \n\t\t  2.*A002*p.z + 2.*A102*p.x*p.z + 2.*A012*p.y*p.z + 2.*A112*p.x*p.y*p.z + 2.*A022*p2.y*p.z + \n\t\t  3.*A003*p2.z + 3.*A103*p.x*p2.z + 3.*A013*p.y*p2.z + \n\t\t  4.*A004*p3.z; \n    \n    n = normalize(n); // Normalizing.\n    \n\n    // Transform back by the inverse normal, which means getting the order right. I know \n    // this, but it'd been a while... and to cut a long story short, there's about an hour\n    // that I'll never get back again. :D\n    n = invTransQuartic(n);\n    \n    return n;\n\n}\n\nvec2 quarticIntersect(vec3 ro, vec3 rd){\n    \n   \n\t\n    // There's a lot of variables here. Most of the time, each of the lines\n    // would be set to equal amounts, which means opportunites for trimming \n    // it right back. It's also possible to streamline for particular objects\n    // which would cut the code back even more. For instance, a rounded cube-\n    // looking object would have most variables set to zero, which would\n    // result in a number of zero entries, thus cutting the code -- and \n    // consequently, processing time -- down considerably.\n    \n    A400 = A040 = A004 = 0.;\n    A310 = A301 = A031 = A130 = A103 = A013 = 0.;\n    A220 = A022 = A202 = A211 = A121 = A112 = 0.;\n    A300 = A030 = A003 = 0.;\n\tA210 = A021 = A102 = A120 = A012 = A201 = 0.;\n\tA111 = 0.;\n\tA200 = A020 = A002 = 0.;\n\tA110 = A011 = A101 = 0.;\n\tA100 = A010 = A001 = 0.;\n\tA000 = 0.;\n    \n////   \n    // Here are just two of an infinitely many possible surfaces. Feel free to\n    // look some up and plug in the figures.\n     \n#if 0\n    // Goursat wiffle cube-like surface.\n    #if 1 \n    float r = .2;\n\tA400 = 1.; A040 = 1.; A004 = 1.;\n\tA200 = A020 = A002 = -.3;\n\tA000 = .035;\n    #else  \n    // Goursat tooth surface.\n    float r = .15;  \n\tA400 = 1.; A040 = 1.; A004 = 1.;\n\tA200 = A020 = A002 = -.2;\n\tA000 = -.03;\n    #endif\n#else\n    // Kummer Surface\n\tfloat a2 = 0.334 + 3.0*(1.0-cos(0.2*iTime));\n\tfloat b = (3.0*a2-1.0)/(3.0-a2);\n\tA000 = a2*a2 - b;\n\tA400 = 1.0;\n\tA040 = 1.0;\n\tA004 = 1.0-b;\n\tA200 = -2.0*a2 + 2.0*b;\n\tA020 = -2.0*a2 + 2.0*b;\n\tA002 = -2.0*a2 + 2.0*b;\n\n\tA220 = -4.0*b + 2.0;\n\tA202 =  2.0*b + 2.0;\n\tA022 =  2.0*b + 2.0;\n\n\tA201 =  4.0*b;\n\tA021 = -4.0*b;\n#endif    \n    \n \n/////   \n    \n    // Object position and rotation. Standard stuff.\n    ro = transQuartic(ro - qCenter);\n    rd = transQuartic(rd);\n    \n\n    // Some vectors to saving a few calculations later.\n    vec3 ro2 = ro*ro, ro3 = ro2*ro, ro4 = ro3*ro;\n    vec3 rd2 = rd*rd, rd3 = rd2*rd, rd4 = rd3*rd;\n    \n    // Look at this mess! I feel sorry for the poor soul who had to crunch this out... It was me, but it was many\n    // years ago, when I had more energy. I'll assume it's correct. :D Book keeping aside, it's just a lengthy, \n    // but simple, bit of processing -- involving expanding a forth degree polynomial, grouping terms, and so forth.   \n    \n    // Basically, we're solving the general quartic surface function written above by substituting the ray distance,\n    // \"ro + rd*t\" into it, then solving for \"t.\" In other words, we're solving the following:\n    \n    // A400*(ro.x + rd.x*t)^4 + A040*(ro.y + rd.y*t)^4 + A004*(ro.z + rd.z*t)^4 + ... + A000 = 0.;\n    \n    // After a lot of frustrating expanding and grouping terms, you'll arrive at a function in the form:\n    \n    // C4*t^4 + C3*t^3 + C2*t^2 + C1*t + C0 = 0;\n    \n    // From there, you can solve for t by plugging the coefficients into a function that's built for that kind of \n    // thing, namely, a quartic solver, which is just an application of computing science and math. The one I'm \n    // using is based off a function that has been around for a long time, but has been refined slightly by \n    // Shadertoy user, NinjaKoala.\n    \n    float coeff[5];  // Coefficients storage.\n\n    float x0 = ro.x, y0 = ro.y, z0 = ro.z;\n    float x1 = rd.x, y1 = rd.y, z1 = rd.z;\n    float x02 = x0*x0, y02 = y0*y0, z02 = z0*z0;\n    float x03 = x0*x02, y03 = y0*y02, z03 = z0*z02;\n    float x04 = x02*x02, y04 = y02*y02, z04 = z02*z02;\n    float x12 = x1*x1, y12 = y1*y1, z12 = z1*z1;\n    float x13 = x1*x12, y13 = y1*y12, z13 = z1*z12;\n    float x14 = x12*x12, y14 = y12*y12, z14 = z12*z12;\n\n#if 0\n    // Just the coeffs we need for the Kummer surface\n    coeff[4] = A400*x14 + A220*x12*y12 + A040*y14 + A202*x12*z12 + A022*y12*z12 + A004*z14;\n\n    coeff[3] =\n      4.0*A400*x0*x13 + 2.0*A220*x12*y0*y1 + 2.0*A220*x0*x1*y12 +\n      4.0*A040*y0*y13 + 2.0*A202*x12*z0*z1 + 2.0*A022*y12*z0*z1 +\n      2.0*A202*x0*x1*z12 + 2.0*A022*y0*y1*z12 + 4.0*A004*z0*z13 +\n      A201*x12*z1 + A021*y12*z1;\n\n    coeff[2] = 6.0*A400*x02*x12 + A220*x12*y02 + 4.0*A220*x0*x1*y0*y1 +\n      A220*x02*y12 + 6.0*A040*y02*y12 + A202*x12*z02 + A022*y12*z02 +\n      4.0*A202*x0*x1*z0*z1 + 4.0*A022*y0*y1*z0*z1 + A202*x02*z12 +\n      A022*y02*z12 + 6.0*A004*z02*z12 + A201*x12*z0 + A021*y12*z0 +\n      2.0*A201*x0*x1*z1 + 2.0*A021*y0*y1*z1 + A200*x12 + A020*y12 + A002*z12;\n\n    coeff[1] = 4.0*A400*x03*x1 + 2.0*A220*x0*x1*y02 + 2.0*A220*x02*y0*y1 +\n      4.0*A040*y03*y1 + 2.0*A202*x0*x1*z02 + 2.0*A022*y0*y1*z02 + 2.0*A202*x02*z0*z1 +\n      2.0*A022*y02*z0*z1 + 4.0*A004*z03*z1 + 2.0*A201*x0*x1*z0 + 2.0*A021*y0*y1*z0 +\n      A201*x02*z1 + A021*y02*z1 + 2.0*A200*x0*x1 + 2.0*A020*y0*y1 + 2.0*A002*z0*z1;\n\n    coeff[0] = A400*x04 + A220*x02*y02 + A040*y04 + A202*x02*z02 + A022*y02*z02 +\n      A004*z04 + A201*x02*z0 + A021*y02*z0 + A200*x02 + A020*y02 + A002*z02 + A000;\n#elif 0\n    // The full set (from Sage, I wouldn't want to do this by hand)\n    coeff[4] = A400*x14 + A310*x13*y1 + A220*x12*y12 + A130*x1*y13 +\n    A040*y14 + A301*x13*z1 + A211*x12*y1*z1 + A121*x1*y12*z1 +\n    A031*y13*z1 + A202*x12*z12 + A112*x1*y1*z12 + A022*y12*z12 +\n    A103*x1*z13 + A013*y1*z13 + A004*z14; \n\n    coeff[3] = 4.0*A400*x0*x13 + A310*x13*y0 + 3.0*A310*x0*x12*y1 +\n    2.0*A220*x12*y0*y1 + 2.0*A220*x0*x1*y12 + 3.0*A130*x1*y0*y12 +\n    A130*x0*y13 + 4.0*A040*y0*y13 + A301*x13*z0 + A211*x12*y1*z0 +\n    A121*x1*y12*z0 + A031*y13*z0 + 3.0*A301*x0*x12*z1 + A211*x12*y0*z1\n    + 2.0*A211*x0*x1*y1*z1 + 2.0*A121*x1*y0*y1*z1 + A121*x0*y12*z1 +\n    3.0*A031*y0*y12*z1 + 2.0*A202*x12*z0*z1 + 2.0*A112*x1*y1*z0*z1 +\n    2.0*A022*y12*z0*z1 + 2.0*A202*x0*x1*z12 + A112*x1*y0*z12 +\n    A112*x0*y1*z12 + 2.0*A022*y0*y1*z12 + 3.0*A103*x1*z0*z12 +\n    3.0*A013*y1*z0*z12 + A103*x0*z13 + A013*y0*z13 + 4.0*A004*z0*z13 +\n    A300*x13 + A210*x12*y1 + A120*x1*y12 + A030*y13 + A201*x12*z1 +\n    A111*x1*y1*z1 + A021*y12*z1 + A102*x1*z12 + A012*y1*z12 +\n    A003*z13; \n\n    coeff[2] = 6.0*A400*x02*x12 + 3.0*A310*x0*x12*y0 + A220*x12*y02 +\n    3.0*A310*x02*x1*y1 + 4.0*A220*x0*x1*y0*y1 + 3.0*A130*x1*y02*y1 +\n    A220*x02*y12 + 3.0*A130*x0*y0*y12 + 6.0*A040*y02*y12 +\n    3.0*A301*x0*x12*z0 + A211*x12*y0*z0 + 2.0*A211*x0*x1*y1*z0 +\n    2.0*A121*x1*y0*y1*z0 + A121*x0*y12*z0 + 3.0*A031*y0*y12*z0 +\n    A202*x12*z02 + A112*x1*y1*z02 + A022*y12*z02 + 3.0*A301*x02*x1*z1\n    + 2.0*A211*x0*x1*y0*z1 + A121*x1*y02*z1 + A211*x02*y1*z1 +\n    2.0*A121*x0*y0*y1*z1 + 3.0*A031*y02*y1*z1 + 4.0*A202*x0*x1*z0*z1 +\n    2.0*A112*x1*y0*z0*z1 + 2.0*A112*x0*y1*z0*z1 + 4.0*A022*y0*y1*z0*z1\n    + 3.0*A103*x1*z02*z1 + 3.0*A013*y1*z02*z1 + A202*x02*z12 +\n    A112*x0*y0*z12 + A022*y02*z12 + 3.0*A103*x0*z0*z12 +\n    3.0*A013*y0*z0*z12 + 6.0*A004*z02*z12 + 3.0*A300*x0*x12 +\n    A210*x12*y0 + 2.0*A210*x0*x1*y1 + 2.0*A120*x1*y0*y1 + A120*x0*y12\n    + 3.0*A030*y0*y12 + A201*x12*z0 + A111*x1*y1*z0 + A021*y12*z0 +\n    2.0*A201*x0*x1*z1 + A111*x1*y0*z1 + A111*x0*y1*z1 +\n    2.0*A021*y0*y1*z1 + 2.0*A102*x1*z0*z1 + 2.0*A012*y1*z0*z1 +\n    A102*x0*z12 + A012*y0*z12 + 3.0*A003*z0*z12 + A200*x12 +\n    A110*x1*y1 + A020*y12 + A101*x1*z1 + A011*y1*z1 + A002*z12; \n\n    coeff[1] = 4.0*A400*x03*x1 + 3.0*A310*x02*x1*y0 +\n    2.0*A220*x0*x1*y02 + A130*x1*y03 + A310*x03*y1 +\n    2.0*A220*x02*y0*y1 + 3.0*A130*x0*y02*y1 + 4.0*A040*y03*y1 +\n    3.0*A301*x02*x1*z0 + 2.0*A211*x0*x1*y0*z0 + A121*x1*y02*z0 +\n    A211*x02*y1*z0 + 2.0*A121*x0*y0*y1*z0 + 3.0*A031*y02*y1*z0 +\n    2.0*A202*x0*x1*z02 + A112*x1*y0*z02 + A112*x0*y1*z02 +\n    2.0*A022*y0*y1*z02 + A103*x1*z03 + A013*y1*z03 + A301*x03*z1 +\n    A211*x02*y0*z1 + A121*x0*y02*z1 + A031*y03*z1 + 2.0*A202*x02*z0*z1\n    + 2.0*A112*x0*y0*z0*z1 + 2.0*A022*y02*z0*z1 + 3.0*A103*x0*z02*z1 +\n    3.0*A013*y0*z02*z1 + 4.0*A004*z03*z1 + 3.0*A300*x02*x1 +\n    2.0*A210*x0*x1*y0 + A120*x1*y02 + A210*x02*y1 + 2.0*A120*x0*y0*y1\n    + 3.0*A030*y02*y1 + 2.0*A201*x0*x1*z0 + A111*x1*y0*z0 +\n    A111*x0*y1*z0 + 2.0*A021*y0*y1*z0 + A102*x1*z02 + A012*y1*z02 +\n    A201*x02*z1 + A111*x0*y0*z1 + A021*y02*z1 + 2.0*A102*x0*z0*z1 +\n    2.0*A012*y0*z0*z1 + 3.0*A003*z02*z1 + 2.0*A200*x0*x1 + A110*x1*y0\n    + A110*x0*y1 + 2.0*A020*y0*y1 + A101*x1*z0 + A011*y1*z0 +\n    A101*x0*z1 + A011*y0*z1 + 2.0*A002*z0*z1 + A100*x1 + A010*y1 +\n    A001*z1; \n\n    coeff[0] = A400*x04 + A310*x03*y0 + A220*x02*y02 + A130*x0*y03 +\n    A040*y04 + A301*x03*z0 + A211*x02*y0*z0 + A121*x0*y02*z0 +\n    A031*y03*z0 + A202*x02*z02 + A112*x0*y0*z02 + A022*y02*z02 +\n    A103*x0*z03 + A013*y0*z03 + A004*z04 + A300*x03 + A210*x02*y0 +\n    A120*x0*y02 + A030*y03 + A201*x02*z0 + A111*x0*y0*z0 + A021*y02*z0\n    + A102*x0*z02 + A012*y0*z02 + A003*z03 + A200*x02 + A110*x0*y0 +\n    A020*y02 + A101*x0*z0 + A011*y0*z0 + A002*z02 + A100*x0 + A010*y0\n    + A001*z0 + A000; \n#else\n    // Original calculation with use of z instead of y for A202 terms.\n    // Coefficients for the t^4 term.\n \tcoeff[4] = A400*rd4.x + A310*rd3.x*rd.y + A202*rd2.x*rd2.z + rd2.y*(A220*rd2.x + A130*rd.x*rd.y + A040*rd2.y) + \n\t\t   (A301*rd3.x + A211*rd2.x*rd.y + A121*rd.x*rd2.y + A031*rd3.y)*rd.z + \n\t\t   rd.y*(A112*rd.x + A022*rd.y)*rd2.z + (A103*rd.x + A013*rd.y)*rd3.z + A004*rd4.z;\n\t\n    // Coefficients for the t^3 term.\n\tcoeff[3] = A300*rd3.x + 4.*A400*ro.x*rd3.x + A310*ro.y*rd3.x + A301*ro.z*rd3.x + A210*rd2.x*rd.y + \n\t\t   3.*A310*ro.x*rd2.x*rd.y + 2.*A202*ro.z*rd2.x*rd.z + 2.*A220*ro.y*rd2.x*rd.y + A211*ro.z*rd2.x*rd.y + \n\t\t   A120*rd.x*rd2.y + 2.*A202*ro.x*rd.x*rd2.z + 2.*A220*ro.x*rd.x*rd2.y + 3.*A130*ro.y*rd.x*rd2.y + \n\t\t   A121*ro.z*rd.x*rd2.y + A030*rd3.y + A130*ro.x*rd3.y + 4.*A040*ro.y*rd3.y + \n\t\t   A031*ro.z*rd3.y + ((A201 + 3.*A301*ro.x + A211*ro.y)*rd2.x + \n\t\t   (A111 + 2.*A211*ro.x + 2.*A121*ro.y + 2.*A112*ro.z)*rd.x*rd.y + (A021 + A121*ro.x + 3.*A031*ro.y + 2.*A022*ro.z)*rd2.y)*\n\t\t   rd.z + ((A102 + A112*ro.y + 3.*A103*ro.z)*rd.x + (A012 + A112*ro.x + 2.*A022*ro.y + 3.*A013*ro.z)*rd.y)*rd2.z + \n\t\t   (A003 + A103*ro.x + A013*ro.y + 4.*A004*ro.z)*rd3.z;\n\n    // Coefficients for the t^2 term.\n\tcoeff[2] = A200*rd2.x + 3.*A300*ro.x*rd2.x + 6.*A400*ro2.x*rd2.x + A210*ro.y*rd2.x + \n\t\t   3.*A310*ro.x*ro.y*rd2.x + A202*ro2.z*rd2.x + A220*ro2.y*rd2.x + \n\t\t   A201*ro.z*rd2.x + 3.*A301*ro.x*ro.z*rd2.x + A211*ro.y*ro.z*rd2.x + A110*rd.x*rd.y + 2.*A210*ro.x*rd.x*rd.y + \n\t\t   3.*A310*ro2.x*rd.x*rd.y + 2.*A120*ro.y*rd.x*rd.y + 4.*A202*ro.x*ro.z*rd.x*rd.z + 4.*A220*ro.x*ro.y*rd.x*rd.y + \n\t\t   3.*A130*ro2.y*rd.x*rd.y + A111*ro.z*rd.x*rd.y + 2.*A211*ro.x*ro.z*rd.x*rd.y + 2.*A121*ro.y*ro.z*rd.x*rd.y + \n\t\t   A112*ro2.z*rd.x*rd.y + A020*rd2.y + A120*ro.x*rd2.y + A202*ro2.x*rd2.z + \n\t\t   A220*ro2.x*rd2.y + 3.*A030*ro.y*rd2.y + 3.*A130*ro.x*ro.y*rd2.y + \n\t\t   6.*A040*ro2.y*rd2.y + A021*ro.z*rd2.y + A121*ro.x*ro.z*rd2.y + 3.*A031*ro.y*ro.z*rd2.y + \n\t\t   A022*ro2.z*rd2.y + ((A101 + 2.*A201*ro.x + 3.*A301*ro2.x + ro.y*(A111 + 2.*A211*ro.x + A121*ro.y)+ \n\t\t   2.*(A102 + A112*ro.y)*ro.z + 3.*A103*ro2.z)*rd.x + \n\t\t   (A011 + A111*ro.x + A211*ro2.x + ro.y*(2.*A021 + 2.*A121*ro.x + 3.*A031*ro.y)+ \n\t\t   2.*(A012 + A112*ro.x + 2.*A022*ro.y)*ro.z + 3.*A013*ro2.z)*rd.y)*rd.z + \n\t\t   (A002 + A102*ro.x + ro.y*(A012 + A112*ro.x + A022*ro.y)+ 3.*(A003 + A103*ro.x + A013*ro.y)*ro.z + \n\t\t   6.*A004*ro2.z)*rd2.z;\n\n    // Coefficients for the t (t^1) term.\n\tcoeff[1] = A100*rd.x + 2.*A200*ro.x*rd.x + 3.*A300*ro2.x*rd.x + 4.*A400*ro3.x*rd.x + A110*ro.y*rd.x + 2.*A210*ro.x*ro.y*rd.x + \n\t\t   3.*A310*ro2.x*ro.y*rd.x + A120*ro2.y*rd.x + 2.*A202*ro.x*ro2.z*rd.x + 2.*A220*ro.x*ro2.y*rd.x + \n\t\t   A130*ro3.y*rd.x + A101*ro.z*rd.x + 2.*A201*ro.x*ro.z*rd.x + 3.*A301*ro2.x*ro.z*rd.x + A111*ro.y*ro.z*rd.x + \n\t\t   2.*A211*ro.x*ro.y*ro.z*rd.x + A121*ro2.y*ro.z*rd.x + A102*ro2.z*rd.x + A112*ro.y*ro2.z*rd.x + \n\t\t   A103*ro3.z*rd.x + A010*rd.y + A110*ro.x*rd.y + A210*ro2.x*rd.y + A310*ro3.x*rd.y + 2.*A020*ro.y*rd.y + \n\t\t   2.*A120*ro.x*ro.y*rd.y + 2.*A202*ro2.x*ro.z*rd.z + 2.*A220*ro2.x*ro.y*rd.y + 3.*A030*ro2.y*rd.y + \n\t\t   3.*A130*ro.x*ro2.y*rd.y + 4.*A040*ro3.y*rd.y + A011*ro.z*rd.y + A111*ro.x*ro.z*rd.y + A211*ro2.x*ro.z*rd.y + \n\t\t   2.*A021*ro.y*ro.z*rd.y + 2.*A121*ro.x*ro.y*ro.z*rd.y + 3.*A031*ro2.y*ro.z*rd.y + A012*ro2.z*rd.y + \n\t\t   A112*ro.x*ro2.z*rd.y + 2.*A022*ro.y*ro2.z*rd.y + A013*ro3.z*rd.y + \n\t\t   (A001 + A101*ro.x + A201*ro2.x + A301*ro3.x + A011*ro.y + A111*ro.x*ro.y + A211*ro2.x*ro.y + \n\t\t   A021*ro2.y + A121*ro.x*ro2.y + A031*ro3.y + \n\t\t   2.*(A002 + A102*ro.x + ro.y*(A012 + A112*ro.x + A022*ro.y))*ro.z + 3.*(A003 + A103*ro.x + A013*ro.y)*ro2.z + \n\t\t   4.*A004*ro3.z)*rd.z;\n\n    // Coefficients for the constant term (t^0).\n\tcoeff[0] = A000 + A100*ro.x + A200*ro2.x + A300*ro3.x + A400*ro4.x + A010*ro.y + A110*ro.x*ro.y + \n\t\t       A210*ro2.x*ro.y + A310*ro3.x*ro.y + A020*ro2.y + A120*ro.x*ro2.y + \n\t\t       A202*ro2.x*ro2.z + A220*ro2.x*ro2.y + A030*ro3.y + A130*ro.x*ro3.y + \n\t\t       A040*ro4.y + (A001 + ro.x*(A101 + ro.x*(A201 + A301*ro.x)) + (A011 + ro.x*(A111 + A211*ro.x))*ro.y + \n\t\t       (A021 + A121*ro.x)*ro2.y + A031*ro3.y)*ro.z + \n\t\t       (A002 + A102*ro.x + ro.y*(A012 + A112*ro.x + A022*ro.y))*ro2.z + (A003 + A103*ro.x + A013*ro.y)*ro3.z + \n\t\t       A004*ro4.z;   \n#endif        \n    \n    // Plug the coefficents into Ninja Koala's refined quartic formula, which itself was based on a formula written\n    // many years ago.\n    //\n    // By the way, it'd be more efficient to use a vec4 for the coefficients above, then divide the results by the last\n    // term, but probably less readable. \n    //\n    vec4 roots;// = vec4(1e8);\n    vec4 coeff4 = vec4(coeff[0], coeff[1], coeff[2], coeff[3])/coeff[4];\n    //\n    // The function returns the number of roots (intersections) and stores the solutions (distances to intersections) to \n    // the equation in \"roots.\" Depending on the surface, up to four solutions (intersections) are possible. Obviously, \n    // we want the closest one to the jump-off point.\n\tint nroots = solve_quartic(coeff4, roots);\n    \n    \n    // If you were only interested in an outer hit point (no refraction), you'd only need to return the minimum\n    // distance, so the following wouldn't be necessary.\n\n    // Super lazy distance ordering. Since there are only 4 roots stored in a vec4, I should probably perform \n    // some swizzling, or something.\n\tfor(int i=0; i<nroots; i++){\n        for(int j = i + 1; j<nroots; j++){\n            if(roots[i]>roots[j]){\n                float temp = roots[i];\n                roots[i] = roots[j];\n                roots[j] = temp;\n            }\n        }\n\t}\n\n\t// Obtaining the closest hit point (if applicable), and determining whether the ray has hit the outer \n    // surface or inner surface.\n    float t = 1e8, retval=0., t0;\n\n\tfor(int k = 0; k<nroots; k++){\n        t0 = roots[k]; \n        if (t0>0. && t0<t){\n            t = t0;\n            retval = ((k&1)==0)? OUTER : INNER;\n            break;\n        }\t  \n\t}   \n    \n    // Return the nearest surface distance, and it's classification (outer, inner, no hit).\n    return vec2(t, retval);\n    \n    \n    \n}\n\n// Plane normals.\nvec3 planeNorm(vec3 p, float id){\n   \n    if(id<1.5) return normalize(vec3(0, 0, -1));\n    else return normalize(vec3(0, 1, 0));\n    \n}\n\n// Plane intersection. Old formula, and could do with some tidying up.\nvec2 planeIntersect(vec3 ro, vec3 rd, vec3 n, float d){\n\n    float t = 1e8, retval = 0.;\n\n\tfloat ndotdir = dot(n*rd, vec3(1));\n    \n\tif (ndotdir < 0.){\n\t\n\t\tfloat dist = (d - dot(n, ro))/ndotdir;\t\n \t\t\t\n\t\tif (dist>0. && dist<t){\n\t\t//if ((dist < t)){\n\t\t\tt = dist;\n\t\t\tretval = 1.;\n\t\t}\n\t}\n    \n    return vec2(t, retval);\n\n}\n\n// Scene normal logic.\nvec3 getNorm(vec3 p, float id){\n    \n    vec3 n;\n    \n    if(id<.5) n = quarticNorm(p);\n    else n = planeNorm(p, id);\n    \n    return n;\n    \n    \n}\n\n// Intersection logic for all objects.\nvec3 intersect(vec3 ro, vec3 rd){\n    \n    vec2 qI = quarticIntersect(ro, rd);\n    return vec3(qI,0);\n#if 0\n    vec2 pI = planeIntersect(ro, rd, normalize(vec3(0, 0, -1)), -4.5);\n    vec2 pI2 = planeIntersect(ro, rd, normalize(vec3(0, 1, 0)), -1.5);\n    //pI.x += 1e8;\n    //qI.x += 1e8;\n    \n    return qI.x<pI.x && qI.x<pI2.x? vec3(qI, 0.): pI.x<pI2.x? vec3(pI, 1.) : vec3(pI2, 2.);\n#endif    \n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// 2D distance formula.\nfloat dist(vec2 p, vec2 b){\n    \n    //return sdBox(p, b);\n    \n    p = abs(p);\n    p -= b;\n    return smax(p.x, p.y, .125);\n    \n}\n\n// vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(41, 289)))*43758.5453); }\n\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(1, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n*/\n\n\n// Custom box divide formula. I wrote this from scratch and based it on various \n// techniques, but changed a lot of it to cut down on operations. I also went to\n// some trouble to keep the morter widths constant. The routines I've come across\n// don't do that. Anyway, take it with a grain of salt. I know of a far more\n// robust way to go about it, but it's harder, so I'm not in a hurry. :)\nfloat boxDivide(in vec2 p, in float sc) {\n    \n    \n    //p += vec2(n3D(vec3(p*64., 1.)), n3D(vec3(p*64. + .5, 1.)))*.004 - .002;\n    \n    p *= .25;    \n    p += .5;\n    \n    \n    vec2 oP = p;\n    \n    vec2 ip = floor(p); p -= ip;\n    \n    \n    vec2 l = vec2(1), lastL;    \n    \n    float r = hash21(ip);\n    \n    \n    //if(r>.5) p = p.yx;\n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum... That's a fancy mathematicians\n    // way to say, repeat the process.\n    \n    for(int i=0; i<5; i++) {\n \n        //r = hash21(l + ip)*.4 + (1.-.4)/2.;\n        r = fract(dot(l, vec2(123.71, 439.43)) + r)*.4 + (1. - .4)/2.;\n        \n        lastL = l;\n        if(l.x>l.y) { p = p.yx; l = l.yx;  }\n         \n        if(p.x<r) { l.x /= r; p.x /= r; }\n        else { l.x /= (1. - r); p.x = (p.x - r)/(1. - r);  }\n        \n        if(lastL.x>lastL.y){ p = p.yx; l = l.yx;  }\n         \n        \n    }\n    \n    // With the subdivided boxed space, you're free to do what you want.\n    // I made slightly raised rounded square blocks.\n     \n    \n    // Gap, or morter, width. Keeping it constant.\n    float th = .0 + sc*.005;\n    \n    // Take subdivided space and turn them into rounded pavers.\n    p = abs(p - .5);\n    float c = dist(p, .5 - th*l);\n    \n    // Rounded shading.\n    float sh = smoothstep(0., .05, (max(-c, 0.)));\n    \n    //float det = 1. - clamp(-cos(c*6.283*2. + .5)*2. + 1.75, 0., 1.); // Edging.\n    //c = max(c, -(c + .03)); // Alternated edging.\n    \n    c = 1. - smoothstep(0., .1, c); // Rouded pavers.\n    \n    c *= sh*.9 + .1; // Smoothing them over.\n    \n    //c *= det*.1 + .95; // Raised edges.\n\n    /*\n    // Experiments with rivits. Doesnt' really work here.\n    vec2 p2 = abs((p + vec2(-.25, -.25))/l);\n    float riv = max(p2.x*.8550254 + p2.y*.5, p2.y) - .005;\n    //float riv = length((p + vec2(-.3, -.3))/l) - .02;\n    //float riv = length((p + vec2(-.35, -.35))) - .05;\n    riv = 2. - smoothstep(0., .01, riv);\n    \n    //float sh1 = smoothstep(0., .15, (max(-c, 0.)));\n    //c = max(c, 2.5 - smoothstep(0., .01, riv))*c;\n    //c = mix(riv, c, .5);\n    c *= riv;\n    */\n     \n    // Additional surface texturing.\n    //float tx = n3D(vec3(oP*64., sh));\n    //tx = 1. - mix(tx, abs(abs(tx - .5)*4. - 1.) , .1);\n    //c *= (.95 + tx*.1);\n\n    \n    return c;\n    \n}\n\n\n// Bump function logic. Rushed, as you can see. \nfloat bumpFunc(vec3 p, vec3 n, float id){\n    \n    float c;\n    \n    if(id<.5){\n        \n        c = 0.;\n        \n        /*\n        p = transQuartic(p - qCenter);\n        c = n3D(p*4.);\n        c = sin(c*6.283*8.)*.5 + .5;\n\t\t*/\n       \n    }\n    else {\n\n        // 2D vector setup. Use XY for the back plane, or XZ for the ground plane.\n        // There's some lining up as well.\n        vec2 q;\n        if(id<1.5) q = p.xy - vec2(10.5, .5 + .75-.125);\n        else q = p.xz - vec2(10.5, 1);\n        \n        c = boxDivide(q, 1.);\n        \n        \n        // Hacky brick-like skirting. There'd be better ways to go about it, that's for sure.\n        float lns = clamp(-cos((p.x - 1.5)*6.283*.5)*48. + 47.9, 0., 1.);\n        if(id<1.5 && p.y<-.75-.125) c = (p.y>-.8-.125) ? 0.: p.y<-1.4? 0.: lns;\n\n    }\n\n\n    \n    return c;//smoothstep(0.05, .4, c);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor, float id){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p, n, id);                 \n    vec3 grad = (vec3(bumpFunc(p - e.xyy, n, id),\n                      bumpFunc(p - e.yxy, n, id),\n                      bumpFunc(p - e.yyx, n, id) )-ref)/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n, float id){\n    \n    if(id<.5){\n        p = transQuartic(p - qCenter);\n        n = transQuartic(n);\n    }\n    else p += .2;\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 bumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf, float id){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n, id), tex3D(tx, p - e.yxy, n, id), tex3D(tx, p - e.yyx, n, id));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n, id), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n*/\n\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  const float PI = 3.14159;\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Unit ray setup -- with a bit of rotation.\n    vec3 rd = normalize(vec3(uv, .9));\n    rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));\n    rd = normalize(transform(rd));\n\n    // Moving the ray around a bit. A proper camera setup would be better,\n    // but this will do.\n    //float swiv = sin(iTime/3.);\n    //float swiv2 = cos(iTime/3.);\n    //rd.xz *= rot2(-.35 + swiv*.1);\n    //rd.yz *= rot2(-.05 + swiv2*.025);\n    \n    \n    // Ray origin, or camera position, if you prefer.\n    vec3 ro = vec3(1., 0, -5.);\n    \n    // Moving the camera and the object back and forth for something to do. :)\n    //ro.x -= swiv*.35;\n    //qCenter.xz -= vec2(swiv, -.5 + swiv2*.5)*.25;\n\n    ro = transform(ro);\n    \n    // Some randomness -- Used to jitter the light. Mostly for the shadows, but I get it'll\n    // give a jittery lighting effect too. If that wasn't desirable, you could set up a\n    // non jittering light, and an extra jittery light.\n    float hash = fract(sin(dot(rd + fract(iTime)*vec3(.9, .7, .8), vec3(1, 157, 113)))*43758.5453);\n    \n    // Jittery lights for a poor man's path tracing effect. :D\n    vec3 lp = ro + vec3(0, 1.5, 1.65)*1.*(1.05 - hash*.1);\n    vec3 lp2 = ro + vec3(0, 1.5, 1.65)*.95*(.95 + hash*.1);\n    \n    lp = transform(lp);\n    lp2 = transform(lp2);\n    \n    // Ray bounces, passes, etc. Probably the minimum necessary. Change the number to\n    // something like 2 or 3 to see the difference.    \n    const int sNum = 5;\n    \n    // Some multiple bounce varibles.\n    float total = 0., totAtten = 1.;\n    \n    // Accumulative color.\n    vec3 aCol = vec3(0);\n    \n    // Refraction ration. solid glass, or near enough. If you don't like the glassy ray bending,\n    // you could bring the figure down closer to one for that air effect.\n    float refRatio = 1./1.5;\n    \n    // More loop utils First distance.\n    //float fDist = 0.;\n    //float grad = rd.y*.5 + .5;\n    \n    // Was going to be used for makeshift stencil buffer shadow blurring, but I went with another method.\n    //float gSh = 0.; \n    \n    //#define MAX_DIST 20. // Necessary, if there's a horizon involved.\n    \n    \n    // The mulitple ray-bounce loop. Hacked together on the fly, so it needs some restructuring, etc.\n    for (int i=0; i<sNum; i++){\n        \n        \n        // The ridiculously bloated intersection formula. Thankfully, it's only called once.\n        // That's the payoff... although it's diminishing returns, if you ask me. :)\n        // vec3 t = vec3(distance, hitInnerOuter, objectID);\n        vec3 t = intersect(ro, rd);\n        //t.x = min(t.x, MAX_DIST);\n        \n        \n        /*\n        if(i==0) {\n            fDist = t.x;\n            gSh = 1.;\n        }\n\t\t*/\n        \n        // Initialize the bounce-pass color to zero.\n        vec3 col = vec3(0);\n    \n        if(t.y!=0.){\n\n            // Hit point for this pass.\n            vec3 sp = ro + t.x*rd;\n\n            // Unit light direction vector, surface to light distance and attenuation.\n            vec3 ld = lp - sp;\n            float lDist = max(length(ld), .0001);\n            float atten = 1./(1. + lDist*lDist*.25);\n           \tld /= lDist;\n\n            // Hit point normal -- oriented depending on whether you've hit and inner or outer surface.\n            vec3 sn = sign(t.y)*getNorm(sp, t.z);\n            //sn *= sign(dot(sn, -rd));; // If you didn't have inner outer access. \n            \n  \n            // Bump mapping. Only on the first pass to save cycles.\n            float bf = .002;\n            if(t.z>.5) bf = .25;\n            if(i==0) sn = bumpMap(sp, sn, bf, t.z);///(1.+ t.x*t.x*.1));\n            \n\n            // Texture-based bump mapping. Not used here.\n            float txSc = .25;\n            if(t.z<.5) txSc = 1.;\n        \t//if(i==0 && t.z>.5) sn = bumpMap(iChannel0, sp*txSc, sn, .005, t.z);\n\n            \n            // Shadows. It's faster to just render it on the first pass, but I thought I'd live\n            // dangerously and render them on subsequent passes also. :D\n            float sh = 1.;\n            vec3 t2 = intersect(sp + ld*.002, ld);\n            if(t2.y != 0. && t2.x<lDist) sh = t2.z<.5? .4 : .5;\n            \n            \n            // Blending in another jittered shadow sample on the first pass for\n            // a slightly softer look... Yeah, I know. Lamest soft shadows ever. :D\n            if(i==0){\n                float sh2 = 1.;\n                vec3 ld2 = lp2 - sp;\n                float lDist2 = max(length(ld), .0001);\n            \tvec3 t3 = intersect(sp + ld2*.002, ld2);\n            \n                 if(t3.y != 0. && t3.x<lDist2){\n                   sh2 = t3.z<.5? .4 : .5;\n                 }\n            \n            \tsh = mix(sh, sh2, .5);\n            }\n            \n            //if(i==0) gSh = sh;\n            \n            // Texture value at the surface. Manipulate it depending on which surface has been hit.         \n            vec3 tx = tex3D(iChannel0, sp*txSc, sn, t.z);\n            if(t.z<.5) tx = smoothstep(.05, .5, tx)*2.; // Quartic texel.\n            else {\n              tx = vec3(0);\n#if 0\n              tx = vec3(1.1, .8, .6)*smoothstep(-.05, .7, tx)*1.75; // Wall texels.\n              \n                if(t.z > 1.5) tx *= vec3(1.2, 1, .8);  // Back wall.                  \n                else if(sp.y<-.775-.125 && sp.y>-1.45) tx *= vec3(1.1, 1, .9)*1.5; // Back wall skirting strip.\n#endif \n            }\n            \n            \n            vec3 refl = reflect(rd, sn);\n\n            float diff = max(dot(ld, sn), 0.);\n            // Specular lighting.\n            float spec = pow(max( dot( reflect(-ld, sn), -rd), 0.), 32.);\n            \n            // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        \tfloat fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 2.);\n             \n\n\t\t\t// Combining the terms above and applying them to the quartic object first, then the walls.\t\n            if(t.z<.5) col = 4.*tx*vec3(1, .9, .8)*(diff*diff*.3 + .1 + vec3(1, .35, .2)*spec*32. + vec3(.25, .5, 1)*fre*4.);\n            else col = tx*(diff*diff*vec3(.7, 1, 1.4) + .1 + vec3(1, .7, .5)*spec*2.5 + vec3(.25, .5, 1)*fre*fre*3.);\n\n            \n            // Applying the bump shade to the walls to darken the crevices more.\n            if(t.z>.5) col *= bumpFunc(sp, sn, t.z)*.6 + .4;\n            \n            \n            // Attenuation and shadowing for this pass.\n            col *= atten*sh; // Normal-based coloring: (sn.yzx*.2 + .9);\n\n            \n            \n\t\t\t// Once the color has been determined for this pass, decide where the next ray is going by\n            // changing the unit direction vector at the surface. First determine whether refraction is\n            // possible. By the way, some reflection is usually observed with every surface hit, but we \n            // need a stack for that, and I was too lazy to set one up. I will next time though.\n            vec3 refr = refract(rd, sn, refRatio);\n            if (dot (refr, refr) < .001 || t.z>.5) { // Is refraction a viable option.\n                \n                // Refraction not possible, so reflect. \n\t\t\t\trd = refl;\n           \t\t// break;\n            }        \n            else {\n                // Refract, then invert the refractive index for the next refractive pass, which will be \n                // from the inner part of the object to an object outside. As you know, the refractive\n                // index of medium A to medium B is the inverse of medium B to medium A.\n                rd = refr;\n                refRatio = 1./refRatio;\n            }\n            //rd = refl; // Debug, for relective passes only.\n            \n            // The old surface hit point becomes the new jump off point (ray origin) for the next pass.\n            // It's also necessary to bump the ray off the surface just a fraction to avoid intersecting\n            // with the new hit point itself. I used to make that mistake all the time. :)\n            ro = sp + rd*.001;\n\n        }\n        //else break;\n        \n        \n        // If you didn't have the back wall, you'd want something like this to fog\n        // out the horizon.\n        //col = mix(col, vec3(1, .9, .8)*grad/32., smoothstep(0., .95, t.x/MAX_DIST));\n        \n       \n        \n        // There are different ways to blend successive passes. This is one of them.\n        aCol = mix(aCol, col, totAtten);\n        \n        // Additive blending is another.\n        //aCol += col*totAtten;\n        \n        \n        \n        // Sometimes useful when using additive blending.\n        //total += totAtten;\n        // Toning down the contribution of the next pass -- Analogous to applying layers.\n        totAtten *= .866025; // Using sqrt(3)/2. to give the impression that something clever is going on. :D\n        \n         \n        // If there's no hit, or we hit a wall, break from the loop.\n        if(t.y==0. || t.z>.5) break;\n        \n    }\n    \n    // If using additive blending, which we're not for this example.\n    //aCol /= float(sNum);//total;    \n    \n    // A colder looking scene. Sometimes global coloring can add a little more scene consistency.\n    //aCol *= vec3(.7, 1, 1.4);\n    \n    \n    \n\n    //aCol = mix(aCol, vec3(.7, 1, .9)*grad, smoothstep(0., .95, fDist/10.));//smoothstep(0., .95, fDist/10.)//1.-1./(1. + fDist*fDist*.05)\n\n    // A bit of temperal blurring. Not absolutely necessary, but figured why not? :)\n    //uv = fragCoord/iResolution.xy;\n    //aCol = mix(aCol, texture(iChannel1, uv).xyz, .333);\n\n    // Output to screen\n    fragColor = vec4((max(aCol, 0.)), 1); // gSh\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}