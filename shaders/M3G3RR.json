{
    "Shader": {
        "info": {
            "date": "1717185616",
            "description": "From left to right:\n- Original\n- RGB10A2 Octadronal Normal + Diamond Tangent + Bitangent Sign\n- 32-Bit encoded QTangent (10bit 10bit 9bit 1bit 2bit)\n- RGBA8 QTangent\n\n From top to bottom: Tangent, Bitangent, Normal",
            "flags": 0,
            "hasliked": 0,
            "id": "M3G3RR",
            "likes": 4,
            "name": "Tangent Space Compression",
            "published": 3,
            "tags": [
                "3d",
                "compression",
                "normal",
                "tangent",
                "mat3",
                "tangentspace",
                "bitangent"
            ],
            "usePreview": 0,
            "username": "BeRo",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "// Encoding&Decoding functions - Copyright 2024, Benjamin 'BeRo' Rosseaux - zlib licensed\n\n// From left to right:\n// - Original\n// - RGB10A2 Octadronal Normal + Diamond Tangent + Bitangent Sign\n// - 32-Bit encoded QTangent (10bit 10bit 9bit 1bit 2bit)\n// - RGBA8 QTangent\n\n// From top to bottom: Tangent, Bitangent, Normal\n\n// Every 5 seconds the display switches back and forth between error \n// distance display and normal shading.\n\n// The 32bit QTangent encoding scheme is:\n// 10bit 10bit 9bit for the 3 smaller components of the quaternion and 1bit \n// for the sign of the bitangent and 2bit for the largest component index for \n// the reconstruction of the largest component of the quaternion\n\n// Comparison shader based on: https://www.shadertoy.com/view/Mtfyzl\n// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//=================================================================================================\n// all iq code below\n//=================================================================================================\n\nfloat map( vec3 p )\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid getTangentSpaceBasisFromNormal(in vec3 n, out vec3 t, out vec3 b){\n  if(abs(n.z) >= 1e-6){\n    float a = n.y / (1.0 + n.z),\n          d = n.y * a,\n          c = -n.x * a;\n    t = normalize(vec3(n.z + d, c, -n.x));\n    b = normalize(vec3(c, 1.0 - d, -n.y));\n  }else{\n    b = normalize(cross(n, t = normalize((n.yzx - n.zxy) - dot(n.yzx - n.zxy, n))));\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\t\n    //-----------------------------------------------------\n\n    float ti = mod( 0.25*iTime, 8.0 );\n    float am = clamp( ti/3.0, 0.0, 1.0 ) - clamp( (ti-4.0)/3.0, 0.0, 1.0 );\n    uint precis = 1u + uint(floor(15.0*am));\n    \n    ///////\n    \n    float fpx = q.x * 4.0;\n    int ipx = int(floor(fpx));\n    float tpx = (fpx < 0.5) ? 1.0 : ((fpx < 3.5) ? abs(fract((fpx - float(ipx)) + 0.5) - 0.5) * 2.0 : 1.0);\n    \n    /////\n         \n    float fpy = q.y * 3.0;\n    int ipy = int(floor(fpy));\n    float tpy = (fpy < 0.5) ? 1.0 : ((fpy < 2.5) ? abs(fract((fpy - float(ipy)) + 0.5) - 0.5) * 2.0 : 1.0);\n    \n    //-----------------------------------------------------\n\t\n\tfloat an = 4.0 + 0.1*iTime*2.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        \n        vec3 nor = calcNormal(pos);\n        vec3 t,b;\n        getTangentSpaceBasisFromNormal(nor,t,b);\n   \n        vec3 ref = reflect( rd, nor );\n        mat3 tbn0 = mat3(t,b,nor);\n\n        mat3 tbn1 = decodeTangentSpaceFromRGB10A2SNorm(encodeTangentSpaceAsRGB10A2SNorm(tbn0)); \n           \n        mat3 tbn2 = decodeQTangentUI32(encodeQTangentUI32(tbn0));\n        \n        mat3 tbn3 = decodeQTangentRGBA8(encodeQTangentRGBA8(tbn0));\n        \n        int w = 2 - ipy;\n        nor = vec3[4]( tbn0[w], tbn1[w], tbn2[w], tbn3[w])[ipx];\n        \n        vec3 error = abs(tbn0[w] - nor);\n\n        // material\n\t\tcol = vec3(0.2);\n        col *= 1.0 + 0.5*nor;\n        \n\t\t// lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),32.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky;\n        \t lin += 8.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.1+0.9*pow(fre,5.0))*sky;\n             lin += 1.0*fre*vec3(1.0,0.90,0.80);\n        col = col * lin;\n        col += 0.50*spe;\n        col += 0.15*spe*spe*spe;\n        \n        if(fract(iTime * 0.1) >= 0.5)\n        {\n          col = error;\n        }           \n        \n\t}\n\n\tcol = sqrt(col);\n    \n\n    col *= smoothstep( 0.003, 0.006, tpx * 0.2);\n    col *= smoothstep( 0.003, 0.006, tpy * 0.2);\n   \n\n    fragColor = vec4( col, 1.0 );\n//  fragColor = vec4( vec3(tpx), 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copyright 2024, Benjamin 'BeRo' Rosseaux - zlib licensed\n\n/*\n** Encoding and decoding functions from tangent space vectors to a single 32-bit unsigned integer (four bytes) in\n** RGB10A2_SNORM format and back.\n** \n** These functions are used to encode and decode tangent space vectors into a single 32-bit unsigned integer.\n** The encoding is done using the RGB10A2 snorm format, which allows to store the tangent space in a single integer.\n** The encoding is lossy, but the loss is very small and the precision is enough for most use cases.\n** \n** The encoding is done as follows:\n** 1. The normal is projected onto the octahedron, which is a 2D shape that represents the normal in a more efficient way.\n** 2. The tangent is projected onto the canonical diamond space, which is a 2D space that is aligned with the normal.\n** 3. The tangent is projected onto the tangent diamond, which is a 1D space that represents the tangent in a more efficient way.\n** 4. The bitangent sign is stored in signed 2 bits as -1.0 or 1.0.\n** 5. The values are packed into a single 32-bit unsigned integer using the RGB10A2 snorm format.\n** \n** The decoding is done as follows:\n** 1. The values are unpacked from the RGB10A2 snorm format.\n** 2. The normal is decoded from the octahedron.\n** 3. The canonical directions are found.\n** 4. The tangent diamond is decoded.\n** 5. The tangent is found using the canonical directions and the tangent diamond.\n** 6. The bitangent is found using the normal, the tangent and the bitangent sign. \n** \n** Idea based on https://www.jeremyong.com/graphics/2023/01/09/tangent-spaces-and-diamond-encoding/ but with improvements for\n** packing into RGB10A2 snorm to a 32-bit unsigned integer.\n**\n** And the 32bit QTangent encoding scheme is:\n**\n** 10bit 10bit 9bit for the 3 smaller components of the quaternion and 1bit for the sign of the bitangent and 2bit for the \n** largest component index for the reconstruction of the largest component of the quaternion\n**\n**/\n\n#define fma(a,b,c) (((a)*(b))+(c))\n\nuint packSnorm4x8(vec4 v){\n  uvec4 e = (uvec4(ivec4(round(clamp(v, -1.0, 1.0) * 127.0))) & uvec4(0xffu)) << uvec4(0u, 8u, 16u, 24u);\n  return e.x | e.y | e.z | e.w;\n}\n\nvec4 unpackSnorm4x8(uint v){\n  ivec4 e = ivec4(\n    int(uint(v << 24u)) >> 24,\n    int(uint(v << 16u)) >> 24,\n    int(uint(v << 8u)) >> 24,\n    int(uint(v)) >> 24\n  );\n  return vec4(e) / 127.0;\n}\n\nmat2x3 getCanonicalSpaceFromNormal(in vec3 n){\n  vec3 t = n.yzx - n.zxy, b = normalize(cross(n, t = normalize(t - dot(t, n))));\n  return mat2x3(t, b);\n}\n\nmat3 decodeTangentSpaceFromRGB10A2SNorm(const in uint encodedTangentSpace){\n\n  // Unpack the values from RGB10A2 snorm\n  ivec4 encodedTangentSpaceUnpacked = ivec4(\n    int(uint(encodedTangentSpace << 22u)) >> 22,\n    int(uint(encodedTangentSpace << 12u)) >> 22,\n    int(uint(encodedTangentSpace << 2u)) >> 22,\n    int(uint(encodedTangentSpace << 0u)) >> 30\n  );\n\n  // Decode the tangent space\n  vec2 octahedronalNormal = vec2(encodedTangentSpaceUnpacked.xy) / 511.0;\n  vec3 normal = vec3(octahedronalNormal, 1.0 - (abs(octahedronalNormal.x) + abs(octahedronalNormal.y)));\n  normal = normalize((normal.z < 0.0) ? vec3((1.0 - abs(normal.yx)) * fma(step(vec2(0.0), normal.xy), vec2(2.0), vec2(-1.0)), normal.z) : normal);\n\n  // Find the canonical space\n  mat2x3 canonicalSpace = getCanonicalSpaceFromNormal(normal);\n  \n  // Decode the tangent diamond direction\n  float tangentDiamond = float(encodedTangentSpaceUnpacked.z) / 511.0;\n  float tangentDiamondSign = (tangentDiamond < 0.0) ? -1.0 : 1.0; // No sign() because for 0.0 in => 1.0 out\n  vec2 tangentInCanonicalSpace;\n  tangentInCanonicalSpace.x = 1.0 - (tangentDiamond * tangentDiamondSign * 2.0);\n  tangentInCanonicalSpace.y = tangentDiamondSign * (1.0 - abs(tangentInCanonicalSpace.x));\n  tangentInCanonicalSpace = normalize(tangentInCanonicalSpace);\n  \n  // Decode the tangent\n  vec3 tangent = normalize(canonicalSpace * tangentInCanonicalSpace);\n\n  // Decode the bitangent\n  vec3 bitangent = normalize(cross(normal, tangent) * float(encodedTangentSpaceUnpacked.w));\n\n  return mat3(tangent, bitangent, normal);\n\n}\n\nuint encodeTangentSpaceAsRGB10A2SNorm(mat3 tbn){\n\n  // Normalize tangent space vectors, just for the sake of clarity and for to be sure\n  tbn[0] = normalize(tbn[0]);\n  tbn[1] = normalize(tbn[1]);\n  tbn[2] = normalize(tbn[2]);\n\n  // Get the octahedron normal\n  vec3 normal = tbn[2];\n  vec2 octahedronalNormal = normal.xy / (abs(normal.x) + abs(normal.y) + abs(normal.z)); \n  octahedronalNormal = (normal.z < 0.0) ? ((1.0 - abs(octahedronalNormal.yx)) * fma(step(vec2(0.0), octahedronalNormal.xy), vec2(2.0), vec2(-1.0))) : octahedronalNormal;\n  \n  // Find the canonical space\n  mat2x3 canonicalSpace = getCanonicalSpaceFromNormal(normal);\n\n  // Project the tangent into the canonical space \n  vec2 tangentInCanonicalSpace = vec2(dot(tbn[0], canonicalSpace[0]), dot(tbn[0], canonicalSpace[1]));\n  \n  // Find the tangent diamond direction (a diamond is more or less the 2D equivalent of the 3D octahedron here in this case)\n  float tangentDiamond = (1.0 - (tangentInCanonicalSpace.x / (abs(tangentInCanonicalSpace.x) + abs(tangentInCanonicalSpace.y)))) * ((tangentInCanonicalSpace.y < 0.0) ? -1.0 : 1.0) * 0.5;\n\n  // Find the bitangent sign\n  float bittangentSign = (dot(cross(tbn[0], tbn[1]), tbn[2]) < 0.0) ? -1.0 : 1.0; \n\n  // Encode the tangent space as signed values\n  ivec4 encodedTangentSpace = ivec4(\n    ivec2(clamp(octahedronalNormal, vec2(-1.0), vec2(1.0)) * 511.0), // 10 bits including sign\n    int(clamp(tangentDiamond, -1.0, 1.0) * 511.0), // 10 bits including sign\n    int(clamp(bittangentSign, -1.0, 1.0)) // 2 bits\n  );\n  \n  // Pack the values into RGB10A2 snorm\n  uint t = ((uint(encodedTangentSpace.x) & 0x3ffu) << 0u) | \n           ((uint(encodedTangentSpace.y) & 0x3ffu) << 10u) | \n           ((uint(encodedTangentSpace.z) & 0x3ffu) << 20u) | \n           ((uint(encodedTangentSpace.w) & 0x3u) << 30u);\n     \n#if 1\n  // Optional step for ensure that the bitangent sign is correct \n  if(dot(decodeTangentSpaceFromRGB10A2SNorm(t)[1], tbn[1]) < 0.0){\n     t = (t & 0x3fffffffu) | ((uint(int(-encodedTangentSpace.w)) & 0x3u) << 30u);\n  }\n#endif\n  \n  return t;\n\n}\n\n// 10bit 10bit 9bit for the 3 smaller components of the quaternion and 1bit for the sign of the bitangent and 2bit for the \n// largest component index for the reconstruction of the largest component of the quaternion.\n// Since the three smallest components of a quaternion are between -1/sqrt(2) and 1/sqrt(2), we can rescale them to -1 .. 1\n// while encoding, and then rescale them back to -1/sqrt(2) .. 1/sqrt(2) while decoding, for a better precision.\nuint encodeQTangentUI32(mat3 m){\n  float r = (determinant(m) < 0.0) ? -1.0 : 1.0; // Reflection matrix handling \n  m[2] *= r;\n#if 0\n  // When the input matrix is always a valid orthogonal tangent space matrix, we can simplify the quaternion calculation to just this:  \n  vec4 q = vec4(m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0], 1.0 + m[0][0] + m[1][1] + m[2][2]);\n#else  \n  // Otherwise we have to handle all other possible cases as well.\n  float t = m[0][0] + (m[1][1] + m[2][2]);\n  vec4 q;\n  if(t > 2.9999999){\n    q = vec4(0.0, 0.0, 0.0, 1.0);\n  }else if(t > 0.0000001){\n    float s = sqrt(1.0 + t) * 2.0;\n    q = vec4(vec3(m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / s, s * 0.25);\n  }else if((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])){\n    float s = sqrt(1.0 + (m[0][0] - (m[1][1] + m[2][2]))) * 2.0;\n    q = vec4(s * 0.25, vec3(m[1][0] + m[0][1], m[2][0] + m[0][2], m[1][2] - m[2][1]) / s);    \n  }else if(m[1][1] > m[2][2]){\n    float s = sqrt(1.0 + (m[1][1] - (m[0][0] + m[2][2]))) * 2.0;\n    q = vec4(vec3(m[1][0] + m[0][1], m[2][1] + m[1][2], m[2][0] - m[0][2]) / s, s * 0.25).xwyz;\n  }else{\n    float s = sqrt(1.0 + (m[2][2] - (m[0][0] + m[1][1]))) * 2.0;\n    q = vec4(vec3(m[2][0] + m[0][2], m[2][1] + m[1][2], m[0][1] - m[1][0]) / s, s * 0.25).xywz; \n  }\n#endif  \n  vec4 qAbs = abs(q = normalize(q));\n  int maxComponentIndex = (qAbs.x > qAbs.y) ? ((qAbs.x > qAbs.z) ? ((qAbs.x > qAbs.w) ? 0 : 3) : ((qAbs.z > qAbs.w) ? 2 : 3)) : ((qAbs.y > qAbs.z) ? ((qAbs.y > qAbs.w) ? 1 : 3) : ((qAbs.z > qAbs.w) ? 2 : 3)); \n  q.xyz = vec3[4](q.yzw, q.xzw, q.xyw, q.xyz)[maxComponentIndex] * ((q[maxComponentIndex] < 0.0) ? -1.0 : 1.0) * 1.4142135623730951;\n  return ((uint(round(clamp(q.x * 511.0, -511.0, 511.0) + 512.0)) & 0x3ffu) << 0u) | \n         ((uint(round(clamp(q.y * 511.0, -511.0, 511.0) + 512.0)) & 0x3ffu) << 10u) | \n         ((uint(round(clamp(q.z * 255.0, -255.0, 255.0) + 256.0)) & 0x1ffu) << 20u) |\n         ((uint(((dot(cross(m[0], m[2]), m[1]) * r) < 0.0) ? 1u : 0u) & 0x1u) << 29u) | \n         ((uint(maxComponentIndex) & 0x3u) << 30u);\n}\n\nmat3 decodeQTangentUI32(uint v){\n  vec4 q = vec4(((vec3(ivec3(uvec3((uvec3(v) >> uvec3(0u, 10u, 20u)) & uvec2(0x3ffu, 0x1ffu).xxy)) - ivec2(512, 256).xxy)) / vec2(511.0, 255.0).xxy) * 0.7071067811865475, 0.0);\n  q.w = sqrt(1.0 - clamp(dot(q.xyz, q.xyz), 0.0, 1.0)); \n  q = normalize(vec4[4](q.wxyz, q.xwyz, q.xywz, q.xyzw)[uint((v >> 30u) & 0x3u)]);\n  vec3 t2 = q.xyz * 2.0, tx = q.xxx * t2.xyz, ty = q.yyy * t2.xyz, tz = q.www * t2.xyz;\n  vec3 tangent = vec3(1.0 - (ty.y + (q.z * t2.z)), tx.y + tz.z, tx.z - tz.y);\n  vec3 normal = vec3(tx.z + tz.y, ty.z - tz.x, 1.0 - (tx.x + ty.y));\n  return mat3(tangent, cross(tangent, normal) * (((v & (1u << 29u)) != 0u) ? -1.0 : 1.0), normal);\n}\n\n// Decodes the UI32 encoded qtangent into a unpacked qtangent for further processing like vertex interpolation and so on\nvec4 decodeQTangentUI32Raw(uint v){\n  vec4 q = vec4(((vec3(ivec3(uvec3((uvec3(v) >> uvec3(0u, 10u, 20u)) & uvec2(0x3ffu, 0x1ffu).xxy)) - ivec2(512, 256).xxy)) / vec2(511.0, 255.0).xxy) * 0.7071067811865475, 0.0);\n  q.w = sqrt(1.0 - clamp(dot(q.xyz, q.xyz), 0.0, 1.0)); \n  return normalize(vec4[4](q.wxyz, q.xwyz, q.xywz, q.xyzw)[uint((v >> 30u) & 0x3u)]) * (((v & (1u << 29u)) != 0u) ? -1.0 : 1.0);\n}\n\n// Constructs a TBN matrix from a unpacked qtangent for example for after vertex interpolation in the fragment shader\nmat3 constructTBNFromQTangent(vec4 q){\n  q = normalize(q); // Ensure that the quaternion is normalized in case it is not, for example after interpolation and so on \n  vec3 t2 = q.xyz * 2.0, tx = q.xxx * t2.xyz, ty = q.yyy * t2.xyz, tz = q.www * t2.xyz;\n  vec3 tangent = vec3(1.0 - (ty.y + (q.z * t2.z)), tx.y + tz.z, tx.z - tz.y);\n  vec3 normal = vec3(tx.z + tz.y, ty.z - tz.x, 1.0 - (tx.x + ty.y));\n  return mat3(tangent, cross(tangent, normal) * ((q.w < 0.0) ? -1.0 : 1.0), normal);\n}\n\n// Just 8bit per component of the quaternion and sign of the bitangent is stored in the sign of the quaternion in the w component\nuint encodeQTangentRGBA8(mat3 m){\n  const float threshold = 1.0 / 127.0; \n  const float renormalization = sqrt(1.0 - (threshold * threshold));\n  float r = (determinant(m) < 0.0) ? -1.0 : 1.0; // Reflection matrix handling \n  m[2] *= r;\n  float t = m[0][0] + (m[1][1] + m[2][2]);\n  vec4 q;\n  if(t > 2.9999999){\n    q = vec4(0.0, 0.0, 0.0, 1.0);\n  }else if(t > 0.0000001){\n    float s = sqrt(1.0 + t) * 2.0;\n    q = vec4(vec3(m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / s, s * 0.25);\n  }else if((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])){\n    float s = sqrt(1.0 + (m[0][0] - (m[1][1] + m[2][2]))) * 2.0;\n    q = vec4(s * 0.25, vec3(m[1][0] + m[0][1], m[2][0] + m[0][2], m[1][2] - m[2][1]) / s);    \n  }else if(m[1][1] > m[2][2]){\n    float s = sqrt(1.0 + (m[1][1] - (m[0][0] + m[2][2]))) * 2.0;\n    q = vec4(vec3(m[1][0] + m[0][1], m[2][1] + m[1][2], m[2][0] - m[0][2]) / s, s * 0.25).xwyz;\n  }else{\n    float s = sqrt(1.0 + (m[2][2] - (m[0][0] + m[1][1]))) * 2.0;\n    q = vec4(vec3(m[2][0] + m[0][2], m[2][1] + m[1][2], m[0][1] - m[1][0]) / s, s * 0.25).xywz; \n  }\n  q = normalize(q); \n  q = mix(q, -q, float(q.w < 0.0));\n  q = mix(q, vec4(q.xyz * renormalization, threshold), float(q.w < threshold));\n  return packSnorm4x8(mix(q, -q, float((dot(cross(m[0], m[2]), m[1]) * r) <= 0.0)));\n}\n\nmat3 decodeQTangentRGBA8(uint v){\n  vec4 q = normalize(unpackSnorm4x8(v)); \n  vec3 t2 = q.xyz * 2.0, tx = q.xxx * t2.xyz, ty = q.yyy * t2.xyz, tz = q.www * t2.xyz;\n  vec3 tangent = vec3(1.0 - (ty.y + (q.z * t2.z)), tx.y + tz.z, tx.z - tz.y);\n  vec3 normal = vec3(tx.z + tz.y, ty.z - tz.x, 1.0 - (tx.x + ty.y));\n  return mat3(tangent, cross(tangent, normal) * sign(q.w), normal);\n} \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}