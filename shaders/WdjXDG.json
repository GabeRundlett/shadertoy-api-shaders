{
    "Shader": {
        "info": {
            "date": "1554849945",
            "description": "Impulse 2019 Invite\n\nA \"retro\" invitation created for my old Atari ST buddies for a  summer get-together. I wanted the Atari ST demo feeling with\n  chiptune music and everything.",
            "flags": 64,
            "hasliked": 0,
            "id": "WdjXDG",
            "likes": 11,
            "name": "Impulse 2019 Invite",
            "published": 3,
            "tags": [
                "impulse"
            ],
            "usePreview": 1,
            "username": "mrange",
            "viewed": 681
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A \"retro\" invitation created for my old Atari ST buddies for a\n//  summer get-together. I wanted the Atari ST demo feeling with\n//  chiptune music (soundcloud is sometimes struggling to load)\n//  and unpolished and a bit too colorful screens.\n//  Of course, it all needs to end with an impossible to read\n//  scrolltext. It's just how it was supposed to work on the\n//  old Atari ST :)\n\n// Inspiration and code shamelessly borrowed from the many\n//  talented shader authors at shadertoy:\n//  iq, shane, evilryu, otaviogood, purton and others.\n\n// Shaders harvested for inspiration and code for specific effects:\n//  Scrolltext - Code based on: https://www.shadertoy.com/view/wsSXzz\n//  Mandelbrot zoom - Code is basically orbit traps added to: https://www.shadertoy.com/view/4df3Rn\n//  Cloud marching - Code heavily inspired by: https://www.shadertoy.com/view/XslGRr\n\n// Resources that helped with write raymarchers:\n//  http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//  https://iquilezles.org/articles/distfunctions\n//  http://mercury.sexy/hg_sdf/\n\n// Cool stuff on how to use distance fields to zoom \"decals\" and apply \n//  effects like outer glow. Is used for scrolltext\n//  https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n\n// -----------------------------------------------------------------------------\n// Common code and definitions - BEGIN\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define AA 2\n\n// Font rendering macros (ASCII codes)\n#define _SPACE 32\n#define _EXCLAMATION 33\n#define _COMMA 44\n#define _DASH 45\n#define _PERIOD 46\n#define _SLASH 47\n#define _COLON 58\n#define _AT 64\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\nconst int numLetters = 253;\nconst int letterArray[numLetters] = int[numLetters](\n  _I,_M,_P,_U,_L,_S,_E,_EXCLAMATION,_SPACE,_DASH,_SPACE,\n  _I,_t,_SPACE,_i,_s,_SPACE,_t,_i,_m,_e,_SPACE,_f,_o,_r,_SPACE,_t,_h,_e,_SPACE,_I,_M,_P,_U,_L,_S,_E,_SPACE,\n  _DASH,_SPACE,_i,_n,_v,_i,_t,_i,_o,_n,_a,_t,_i,_o,_n,_a,_l,_SPACE,_o,_n,_l,_y,_SPACE,_DASH,_SPACE,_2,_0,_1,_9,_PERIOD,_SPACE,\n  _2,_0,_1,_8,_SPACE,_w,_a,_s,_SPACE,_a,_SPACE,_g,_r,_e,_a,_t,_SPACE,_s,_u,_c,_c,_e,_s,_s,_SPACE,\n  _a,_n,_d,_SPACE,_2,_0,_1,_9,_SPACE,_d,_e,_s,_e,_r,_v,_e,_s,_SPACE,_a,_SPACE,_w,_o,_r,_t,_h,_y,_SPACE,\n  _r,_e,_p,_e,_a,_t,_PERIOD,_SPACE,\n  _S,_o,_SPACE,_f,_e,_l,_l,_o,_w,_SPACE,_h,_a,_c,_k,_e,_r,_s,_COMMA,_SPACE,_p,_i,_c,_k,_SPACE,_u,_p,_SPACE,\n  _y,_o,_u,_r,_SPACE,_c,_o,_m,_p,_u,_t,_e,_r,_s,_COMMA,_SPACE,_k,_e,_y,_b,_o,_a,_r,_d,_s,_SPACE,_a,_n,_d,_SPACE,\n  _j,_o,_y,_s,_t,_i,_c,_k,_s,_SPACE,_a,_n,_d,_SPACE,_t,_r,_a,_v,_e,_l,_SPACE,_t,_o,_SPACE,\n  _G,_o,_t,_h,_e,_n,_b,_u,_r,_g,_SPACE,_i,_n,_SPACE,_M,_a,_y,_PERIOD,_SPACE,\n  _B,_e,_SPACE,_t,_h,_e,_r,_e,_SPACE,_o,_r,_SPACE,_b,_e,_SPACE,_s,_q,_u,_a,_r,_e,_EXCLAMATION,_EXCLAMATION,_EXCLAMATION\n);\n\n\nvec4 sampleText(in vec2 uv, int start, int count, bool repeat)\n{\n  float fl = floor(uv + 0.5).x;\n  float cursorPos = fl;\n  int arrayPos = int(cursorPos);\n  if (arrayPos < 0)\n  {\n    return vec4(0.0, 0.0, 0.0, 1.0);\n  }\n  if (!repeat && arrayPos >= count)\n  {\n    return vec4(0.0, 0.0, 0.0, 1.0);\n  }\n\n  arrayPos %= count;\n  arrayPos += start;\n\n  int letter = letterArray[arrayPos];\n  vec2 lp = vec2(letter % 16, 15 - letter/16);\n  vec2 uvl = lp + fract(uv+0.5)-0.5;\n\n  // Sample the font texture. Make sure to not use mipmaps.\n  // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n  vec2 tp = (uvl+0.5)*(1.0/16.0);\n  return texture(iChannel2, tp, -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\nvec3 scrollText(vec2 uv, float time, vec3 fontColor, vec3 glowColor, vec3 background)\n{\n  vec3 col = background;\n\n  const float appearTime = 6.0;\n\n  vec2 p = uv + vec2(time, 0.0);\n\n  if (abs(p.y) > 0.5)\n  {\n    return col;\n  }\n\n  vec4 samp = sampleText(p, 0, numLetters, true);\n  float dist = samp.w;\n\n  col += glowColor*(1.0 - smoothstep(0.55, 0.66, dist));\n\n  if (step(0.55, dist) == 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  if (step(0.5, dist) == 0.0)\n  {\n    col = fontColor;\n  }\n\n\n  return col;\n}\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat mod1(inout float p, in float size)\n{\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, in vec2 size)\n{\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat rand(vec3 r)\n{\n  return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453);\n}\n\nvec2 toHyperSpace(in vec2 p)\n{\n  float r2 = dot(p, p);\n  float t = 1.0 + 1.0/sqrt(1.0 - r2);\n  return (t + 1.0)*p;\n}\n\nvec2 toPolar(in vec2 p)\n{\n  return vec2(length(p), atan(p.y,p.x));\n}\n\nvec2 toRectangular(in vec2 p)\n{\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec3 toSpherical(vec3 p)\n{\n  float l = length(p);\n  return vec3(length(p), acos(p.z/l), atan(p.y, p.x));\n}\n\nvec3 toRectangular(vec3 p)\n{\n  float l = length(p);\n  return vec3(p.x*sin(p.y)*cos(p.z), p.x*sin(p.y)*sin(p.z), p.x*cos(p.y));\n}\n\nvec3 mod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat maxComp(in vec2 p)\n{\n  return max(p.x, p.y);\n}\n\nvoid rot(inout vec2 p, in float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 toSmith(vec2 p)\n{\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)\n{\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec3 fadeIn(in vec3 col, in vec3 fadeTo, in float start, in float done, in float time)\n{\n  float fadeIn = smoothstep(start, done, time);\n  return mix(fadeTo, col, fadeIn);\n}\n\nvec3 fadeOut(in vec3 col, in vec3 fadeTo, in float start, in float done, in float time)\n{\n  float fadeOut = 1.0 - smoothstep(start, done, time);\n  return mix(fadeTo, col, fadeOut);\n}\n\nfloat unionRound(float a, float b, float r)\n{\n  vec2 u = max(vec2(r - a,r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\n\nfloat softMin(in float a, in float b, in float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat sdSphere(in vec3 p, in float r)\n{\n  return length(p) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdSoftBox(in vec3 p, in float r)\n{\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nfloat sdCross(in vec3 p)\n{\n  float da = maxComp(abs(p.xy));\n  float db = maxComp(abs(p.yz));\n  float dc = maxComp(abs(p.zx));\n  return min(da,min(db,dc))-1.0;\n}\n\nfloat sdPlane(in vec3 p, in vec3 n, in float m)\n{\n  return dot(p, n) + m;\n}\n\nmat4 mscale(vec3 s)\n{\n  return mat4(\n    s.x, 0.0, 0.0, 0.0,\n    0.0, s.y, 0.0, 0.0,\n    0.0, 0.0, s.z, 0.0,\n    0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 mrotX(in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat4(\n    c,-s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 0);\n}\n\nmat4 mrotY(in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat4(\n    c, 0,-s, 0,\n    0, 1, 0, 0,\n    s, 0, c, 0,\n    0, 0, 0, 1);\n}\n\nmat4 mrotZ(in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat4(\n    1, 0, 0, 0,\n    0, c,-s, 0,\n    0, s, c, 0,\n    0, 0, 0, 1);\n}\n\nmat4 mtrans(in vec3 t)\n{\n  return mat4(\n    1, 0, 0, t.x,\n    0, 1, 0, t.y,\n    0, 0, 1, t.z,\n    0, 0, 0, 1);\n}\n\n// -----------------------------------------------------------------------------\n// Common code and definitions - END\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// Retro Impulse Intro - BEGIN\n// -----------------------------------------------------------------------------\n\n#define RII_START       0.0\n#define RII_DONE        (RII_START + 69.0)\n\n#define RII_FADEINTIME 0.25\n#define RII_FLASHDOWNTIME 0.75\n\nvec3 rii_scrollText(in float gtime, in vec2 uv, in vec3 background)\n{\n  vec3 col = background;\n\n  const float appearTime = 6.0;\n\n//  uv.y += 0.05*sin(8.0*uv.x + TIME);\n\n  vec2 p = uv*3.0 + vec2(4.0*(gtime - appearTime) - 6.0, -2.5);\n\n  if(abs(p.y) > 0.5)\n  {\n    return col;\n  }\n\n  vec4 samp = sampleText(p, 0, numLetters, true);\n  float dist = samp.w;\n\n  if (step(0.55, dist) == 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  if (step(0.5, dist) == 0.0)\n  {\n    col = vec3(1.0);\n  }\n\n  return col;\n}\n\nconst int rii_numBars = 6;\nconst vec3 rii_bars[rii_numBars] = vec3[rii_numBars](\n    1.0*vec3(135.0, 160.0, 255.0)/255.0,\n    1.0*vec3(140.0, 141.0, 255.0)/255.0,\n    1.0*vec3(155.0, 099.0, 255.0)/255.0,\n    1.0*vec3(167.0, 060.0, 255.0)/255.0,\n    1.0*vec3(175.0, 034.0, 255.0)/255.0,\n    1.0*vec3(187.0, 000.0, 255.0)/255.0\n);\n\nfloat rii_flash(in float gtime, in float time)\n{\n  return step(time, gtime)*(1.0 - smoothstep(time, time + RII_FLASHDOWNTIME, gtime));\n}\n\nvec3 rii_logo(in float gtime, in vec2 uv, in vec3 background)\n{\n  vec3 col = background;\n\n  const float electrifyTime = 25.0;\n\n  float period = 1.0;\n  float time = mod(gtime, period);\n\n  vec2 p = uv*vec2(3.0, 4.0) - vec2(-3.0, -3.5 + time - time*time);\n\n  if(abs(p.y) > 0.5)\n  {\n    return col;\n  }\n\n  vec4 samp = sampleText(p - vec2(-0.5, 0.0), 0, 8, false);\n  float dist = samp.w;\n\n  col = rii_bars[0]*smoothstep(0.5, 0.66, dist);\n\n  if (step(0.5, dist) == 0.0)\n  {\n    col = vec3(samp.y + 0.3);\n  }\n\n  if (gtime > electrifyTime)\n  {\n    float tx = mod((p.x + 2.5)*48.0, 511.0);\n    float wave = texelFetch(iChannel0, ivec2(tx,1), 0).x;\n\n  //wave = 0.5;\n\n    for(int i = 0; i < rii_numBars; ++i)\n    {\n      float r = (float(i + rii_numBars)/float(2*rii_numBars));\n      float shade = pow(r, 4.0);\n      float disty = r*r*0.4*sin(p.x + (5.0 + float(i))*gtime);\n\n      col += shade*rii_bars[i]*(1.0 - smoothstep(0.0, 0.5, abs(wave - p.y - 0.5 + disty)));\n      col += shade*(1.0 - smoothstep(0.0, 0.15, abs(wave - p.y - 0.5 + disty)));\n    }\n    float fo = abs(cos(PI*p.y));\n    col *= sqrt(fo);\n\n    col += rii_flash(gtime, electrifyTime);\n  }\n\n\n  return col;\n}\n\n\nvec3 rii_rasterBars(in float gtime, in vec2 uv, in vec3 background)\n{\n  vec3 col = background;\n\n  const float unflatTime = 31.5;\n\n  vec2 pol = toSmith(uv);\n  rot(pol, smoothstep(unflatTime, unflatTime + 120.0, gtime)*3.14*sin(gtime));\n  //pol.x += 0.75*sin(TIME*1.5);\n  pol.y += smoothstep(unflatTime, unflatTime + 60.0, gtime)*0.5*cos(gtime);\n  //pol.y += sin(TIME + uv.y + uv.x)*0.5;\n  //pol.x *= 0.6 + 0.4*cos(TIME + uv.y - 0.5);\n  uv = fromSmith(pol);\n\n  for(int i = 0; i < rii_numBars; ++i)\n  {\n      float shade = (float(i + rii_numBars)/float(2*rii_numBars));\n      vec3 barCol = rii_bars[rii_numBars - i - 1]*shade;\n      float a = 0.5*float(i) + 2.0*gtime;\n      float y = 0.5*sin(a);\n      float f = step(-0.1,uv.y + y)*(1.0 - step(0.1,uv.y + y));\n      float h =\n          rii_flash(gtime, unflatTime) +\n          step(unflatTime, gtime)*shade*0.5*cos(30.0*(uv.y + y))*f;\n      col = mix(col, barCol + h, 0.9*f);\n  }\n\n  return col;\n}\n\nfloat rii_length8(in vec2 uv)\n{\n  uv = uv*uv;\n  uv = uv*uv;\n  uv = uv*uv;\n  return pow(uv.x + uv.y, 1.0/8.0);\n}\n\nvec3 rii_synth(in float gtime, in vec2 uv, in vec3 background)\n{\n  vec3 col = background;\n\n  const float appearInTime = 19.0;\n  const float waveTime = 40.0;\n  const float waveDevelopTime = 20.0;\n\n  vec2 pol = toPolar(uv);\n  //pol.y += sin(TIME + uv.y + uv.x)*0.5;\n  pol.x *= 1.0 + smoothstep(waveTime, waveTime + waveDevelopTime, gtime)*0.6*cos(gtime + uv.y - 0.5);\n  uv = toRectangular(pol);\n\n  vec2 cp = uv;\n\n  vec2 ci = mod2(cp, vec2(0.2));\n\n  rot(ci, 1.0 - step(waveTime, gtime)*0.25*(gtime - waveTime));\n\n  float ffi = abs(mod(10.0*abs(ci.x + ci.y), 511.0));\n\n  float d = rii_length8(cp);\n\n  float fft  = texelFetch(iChannel0, ivec2(ffi,0), 0).x;\n\n  if (d < 0.075)\n  {\n    col += smoothstep(appearInTime, appearInTime + RII_FADEINTIME,gtime)*0.75*(vec3(fft*fft, 0.0, fft) + fft*fft*fft);\n  }\n\n  return col;\n}\n\nconst int rii_numBalls = 12;\nconst vec3 rii_balls[rii_numBalls] = vec3[rii_numBalls](\n    vec3(1.0, 0.0, 0.0),\n    vec3(1.0, 0.5, 0.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.5, 1.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 1.0, 0.5),\n    vec3(0.0, 1.0, 1.0),\n    vec3(0.0, 0.5, 1.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.5, 0.0, 1.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 0.0, 0.5)\n);\n\nvec3 rii_nerdBalls(in float gtime, vec2 uv, vec3 background)\n{\n  vec3 col = background;\n\n  const float appearTime = 12.5;\n\n  const float softBallTime = 37.5;\n  const float softBallDuration = 10.0;\n\n  const int ballCount = rii_numBalls*2;\n  const float ballRadius = 0.1;\n\n  if (gtime < appearTime)\n  {\n    return col;\n  }\n  float ga = gtime;\n  vec2 gr = 0.3*vec2(cos(2.0*ga/3.0), cos(2.0*ga/5.0)) + vec2(0.7);\n\n  float f = smoothstep(softBallTime, softBallTime + softBallDuration, gtime);\n  float minf = mix(300.0, 30.0 + 25.0*sin(ga), f);\n  float powf = mix(0.01, 1.5, f);\n\n  float d = 10000.0;\n  vec3 c = vec3(1.0);\n\n  for (int i = 0; i < ballCount; ++i)\n  {\n    float a = ga + float(i)/10.0;\n    float r = float(i + ballCount) / float(2*ballCount);\n\n    vec2 p = uv + r*gr*vec2(cos(4.0*a), sin(3.0*a));\n    float dd = length(p) - ballRadius;\n    d = softMin(dd, d, minf);\n    c = mix(rii_balls[i%rii_numBalls], c, dd <= 0.0 ? 0.0 : pow(dd, powf));\n  }\n\n  if (d < -0.02)\n  {\n    float dif = cos((d + ballRadius)/ballRadius);\n    float spe = 0.75*pow(dif, 10.0);\n    col = c*dif;// + spe;\n  }\n  else if (d < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid rii_main(in vec2 fragCoord, inout vec3 col)\n{\n  if (!(RII_START < iTime && iTime <= RII_DONE)) return;\n  float gtime = iTime;\n\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = 2.0*q - 1.0;\n\n  vec2 uv = p*vec2(iResolution.x/iResolution.y, 1.0);\n\n  vec3 c = vec3(0.0);\n\n  c = rii_synth(gtime, uv, c);\n  c = rii_rasterBars(gtime, uv, c);\n  c = rii_nerdBalls(gtime, uv, c);\n  c = rii_logo(gtime, uv, c);\n  c = rii_scrollText(gtime, uv, c);\n\n  col = fadeOut(c, vec3(1.0), RII_DONE - 0.25, RII_DONE, iTime);\n}\n\n\n\n// -----------------------------------------------------------------------------\n// Retro Impulse Intro - END\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// Introducing Impulse Box - BEGIN\n// -----------------------------------------------------------------------------\n\n#define III_START       RII_DONE\n#define III_DONE        (III_START + 75.0)\n\n#define III_TOLERANCE           0.001\n#define III_NORM_OFF            0.001\n#define III_MAX_RAY_LENGTH      6.0\n\n#define III_MAX_RAY_MARCHES     70\n\n#define III_BOXSIZE             0.2\n\n#define III_PERIOD              15.0\n#define III_CURRENT_PERIOD      int(gtime/III_PERIOD)\n#define III_TIME_IN_PERIOD      mod(gtime,III_PERIOD)\n\n\nfloat iii_sdHoleyBox(in vec3 p)\n{\n  vec3 bp = p;\n  float bd = sdSoftBox(bp, III_BOXSIZE);\n  mod3(bp, vec3(0.62*III_BOXSIZE));\n  float msd = sdSphere(bp, 0.38*III_BOXSIZE);\n  float hbd = max(bd, -msd);\n\n  return hbd;\n}\n\nvoid iii_nerdRotate(inout vec3 p)\n{\n  float a2 = 2.0*iTime/sqrt(2.0);\n  float a3 = 1.0*iTime/sqrt(3.0);\n  float a5 = 0.5*iTime/sqrt(5.0);\n  rot(p.yz, a5);\n  rot(p.xy, -a3);\n  rot(p.xz, -a2);\n}\n\nfloat iii_theCube(in vec3 p, out int m)\n{\n  vec3 bp = p;\n  float bd = sdSoftBox(bp, III_BOXSIZE);\n\n  float d = bd;\n\n  m = 1;\n\n  return d;\n}\n\nfloat iii_nerdBalls(in vec3 p, out int m)\n{\n  float a2 = TAU*iTime/sqrt(2.0);\n  float a3 = TAU*iTime/sqrt(3.0);\n\n  float d = III_MAX_RAY_LENGTH;\n\n  for (int i = 0; i < 7; ++i)\n  {\n    vec3 sp = p;\n    rot(sp.yz, float(i));\n    sp += 0.75*III_BOXSIZE*sin(a2/3.0 + float(i)*a3/20.0);\n    float d1 = sdSphere(sp, III_BOXSIZE*0.25);\n    d = softMin(d, d1, 20.0);\n  }\n\n  m = 1;\n\n  return d;\n}\n\nfloat iii_nerdCube(in vec3 p, out int m)\n{\n  vec3 bp = p;\n\n  float hbd = iii_sdHoleyBox(bp);\n\n  float d = hbd;\n\n  m = 1;\n\n  return d;\n}\n\nfloat iii_impulseCube(in float gtime, in vec3 p, in float celld, in float celll, out int m)\n{\n  vec3 bp = p;\n\n  float cs = III_BOXSIZE*0.8;\n\n  float cd = max(length(p.xy) - cs*0.3, sdSphere(bp, 1.2*III_BOXSIZE));\n  float hbd = min(max(sdSoftBox(bp, III_BOXSIZE), -sdCross(bp/cs)*cs), cd);\n  float bbd = sdBox(bp, vec3(cs));\n\n  vec3 rbp = toSpherical(bp);\n  rbp.y += III_TIME_IN_PERIOD*0.5;\n  bp = toRectangular(rbp);\n\n  vec3 cell = mod3(bp, vec3(cs*celld));\n\n  float id = sdSoftBox(bp, cs*celll);\n\n  float mbd = max(bbd, id);\n\n  float d = unionRound(hbd, mbd, III_BOXSIZE*0.15);\n\n  if (abs(hbd - d) < 0.01)\n  {\n    m = 2;\n  }\n  else\n  {\n    m = 1;\n  }\n\n\n  return d;\n}\n\n\nfloat iii_map(in float gtime, in vec3 p, out int m)\n{\n  const float scale = III_BOXSIZE;\n  p *= scale;\n\n  float d = III_MAX_RAY_LENGTH;\n  int period = III_CURRENT_PERIOD%5;\n\n//  period = 3;\n\n  iii_nerdRotate(p);\n\n  switch(period)\n  {\n  case 0:\n    d = iii_theCube(p, m);\n    break;\n  case 1:\n    d = iii_nerdCube(p, m);\n    break;\n  case 2:\n    d = iii_nerdBalls(p, m);\n    break;\n  case 3:\n    d = iii_impulseCube(gtime, p, 0.1, 0.048, m);\n    break;\n  case 4:\n    d = iii_impulseCube(gtime, p, 0.1, 0.01, m);\n    break;\n  }\n\n  return d/scale;\n}\n\n\nfloat iii_rayMarch(in float gtime, in vec3 ro, in vec3 rd, out int mat, out int iter)\n{\n  float t = 0.0;\n  float distance;\n  int i;\n  for (i = 0; i < III_MAX_RAY_MARCHES; ++i)\n  {\n    distance = iii_map(gtime, ro + rd*t, mat);\n    if (distance < III_TOLERANCE || t > III_MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n\n  if (abs(distance) > 100.0*III_TOLERANCE) return III_MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 iii_normal(in float gtime, in vec3 pos)\n{\n  vec3  eps = vec3(III_NORM_OFF,0.0,0.0);\n  vec3 nor;\n  int mat;\n  nor.x = iii_map(gtime, pos+eps.xyy, mat) - iii_map(gtime, pos-eps.xyy, mat);\n  nor.y = iii_map(gtime, pos+eps.yxy, mat) - iii_map(gtime, pos-eps.yxy, mat);\n  nor.z = iii_map(gtime, pos+eps.yyx, mat) - iii_map(gtime, pos-eps.yyx, mat);\n  return normalize(nor);\n}\n\nconst vec3 iii_lightPos1 = 100.0*vec3(-0.3, 0.15, 1.0);\nconst vec3 iii_lightPos2 = 100.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 iii_lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 iii_lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 iii_skyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(iii_lightPos1);\n  vec3 lightDir2 = normalize(iii_lightPos2);\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  final += 1.0*pow(iii_lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 1.0*iii_lightCol1 * pow(ld1, 200.0);\n  final += 1.0*pow(iii_lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += 1.0*iii_lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\n\nvec3 iii_render(in float gtime, in vec3 ro, in vec3 rd)\n{\n  // background color\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float t = iii_rayMarch(gtime, ro,rd, mat, iter);\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = vec3(0.0, 1.0, 0.0);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n\n  if (t < III_MAX_RAY_LENGTH)\n  {\n    // Ray intersected object\n    nor = iii_normal(gtime, pos);\n    float d2 = abs(dot(-rd, nor));\n\n    switch(mat)\n    {\n    case 0:\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 1:\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 2:\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    default:\n      color = nor*nor;\n      break;\n    }\n\n  }\n  else\n  {\n    // Ray intersected sky\n    return iii_skyColor(rd);\n  }\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = iii_skyColor(ref);\n\n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = iii_lightPos1 - pos;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = iii_lightPos2 - pos;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float st  = iii_rayMarch(gtime, pos + ref*10.0*III_TOLERANCE, ref, rmat, riter);\n  float sha1 = pow(st/III_MAX_RAY_LENGTH, 0.2);\n  float sha2 = st < III_MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n  float occ  = float(III_MAX_RAY_MARCHES + III_MAX_RAY_MARCHES - iter) / 2.0*float(III_MAX_RAY_MARCHES);\n\n  float bac  = 0.2;\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*iii_lightCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*iii_lightCol2, 0.8);\n\n//  nref = 1.0;\n\n  vec3 col = mix(rcol*sha2, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col;\n}\n\nvoid iii_main(in vec2 fragCoord, inout vec3 col)\n{\n  if (!(III_START < iTime && iTime <= III_DONE)) return;\n  float gtime = (iTime - III_START);\n\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = 1.5*vec3(2.0, 1.0, 0.2);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  rot(ro.xz, TAU*iTime/30.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 c = iii_render(gtime, ro, rd);\n\n  float fadeIn = 1.0 - smoothstep(0.0, 0.75, III_TIME_IN_PERIOD);\n  float fadeOut = smoothstep(III_PERIOD - 0.25, III_PERIOD, III_TIME_IN_PERIOD);\n\n  col = mix(c, vec3(1.0), fadeOut + fadeIn);\n}\n\n\n// -----------------------------------------------------------------------------\n// Introducing Impulse Box - END\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// Mandelbrot Dream - BEGIN\n// -----------------------------------------------------------------------------\n\n#define MBD_START       III_DONE\n#define MBD_DONE        (MBD_START + 62.0)\n\n#define MBD_START_ZOOM  7.0\n\nvec3 mbd_mandelbrot(in float gtime, in vec2 p)\n{\n  vec3 col = vec3(0.0);\n\n  if(-p.y + 1.5 > gtime*0.5)\n  {\n    return col;\n  }\n\n  float ztime = (gtime - MBD_START_ZOOM)*step(MBD_START_ZOOM, gtime);\n\n  float zoo = 0.64 + 0.36*cos(.07*ztime);\n  float coa = cos(0.15*(1.0-zoo)*ztime);\n  float sia = sin(0.15*(1.0-zoo)*ztime);\n  zoo = pow(zoo,8.0);\n  vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n  vec2 c = vec2(-.745,.186) + xy*zoo;\n\n  const float B = 10.0;\n  float l = 0.0;\n  vec2 z  = vec2(0.0);\n\n  vec2 zn = vec2(2.1, 0.0);\n  float zo = 2.99;\n  vec2 zc = vec2(1.0);\n\n  rot(zc, ztime);\n\n  float dcc = 1e20;\n  float dll = 1e20;\n\n  for(int i = 0; i < 256; ++i)\n  {\n    float re2 = z.x*z.x;\n    float im2 = z.y*z.y;\n    float reim= z.x*z.y;\n\n    if(re2 + im2 > (B*B)) break;\n\n    z = vec2(re2 - im2, 2.0*reim) + c;\n\n    vec2 zm = z;\n    mod2(zm, vec2(5));\n\n    float l2c = dot(zm - zc, zm - zc);\n    float l2l = dot(zm, zn) + zo;\n\n    dcc = min(dcc, l2c);\n    dll = min(dll, abs(l2l));\n\n    l += 1.0;\n  }\n\n  if (l == 256.0) return vec3(0.0);\n\n  float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n  vec3 dc = vec3(pow(abs(1.0 - dcc), 20.0));\n  vec3 dl = 0.5*vec3(pow(abs(1.0 - dll), 10.0));\n  vec3 gc = 0.5 + 0.5*cos(3.0 + sl*0.15 + vec3(0.1,0.5,0.9));\n  return saturate(gc + dl*smoothstep(35.4, 35.6, ztime) + dc*smoothstep(28.8, 29.0, ztime));\n}\n\nvoid mbd_main(in vec2 fragCoord, inout vec3 col)\n{\n  if (!(MBD_START < iTime && iTime <= MBD_DONE)) return;\n  float gtime = (iTime - MBD_START);\n\n  vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n  col = fadeOut(fadeIn(0.5*(mbd_mandelbrot(gtime, p) + mbd_mandelbrot(gtime - 1.0/120.0, p)),vec3(1.0), MBD_START, MBD_START + 0.75, iTime),vec3(0.0), MBD_DONE - 2.0 , MBD_DONE, iTime);\n}\n\n\n// -----------------------------------------------------------------------------\n// Mandelbrot Dream - END\n// -----------------------------------------------------------------------------\n\n\n// -----------------------------------------------------------------------------\n// A New Dawn - BEGIN\n// -----------------------------------------------------------------------------\n\n#define AND_START       MBD_DONE\n#define AND_DONE        (AND_START + 13.0)\n\n#define AND_TOLERANCE       0.001\n#define AND_MAX_RAY_MARCHES 150\n\nconst float and_fadeInTime  = 2.0;\nconst float and_fadeOutTime = 28.0;\nconst float and_apexTime    = 30.0;\n\nfloat and_noise(in vec3 x)\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n  vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  vec2 rg = textureLod(iChannel1, (uv+ 0.5)/256.0, 0.0).yx;\n  return mix(rg.x, rg.y, f.z);\n}\n\nvec3 and_heightShade(in float gtime)\n{\n  float time = gtime/and_apexTime;\n  return mix(vec3(1.0, 0.5, 0.5), vec3(1.0), min(1.0, time));\n}\n\nvec3 and_getSkyColor(in float gtime, vec3 rayDir)\n{\n  vec3 lightPos1 = 100.0*vec3(0.0, -0.15, 1.0);\n  vec3 lightPos2 = 100.0*vec3(0.4, -0.25, 1.0);\n\n  float time = gtime/and_apexTime;\n  float a    = 0.5*time;\n  float sky  = atan(rayDir.y/rayDir.z)*2.0/PI;\n\n  rot(lightPos1.yz, a);\n  rot(lightPos2.yz, a);\n\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n\n  vec3 heightmod = and_heightShade(gtime);\n  vec3 lightCol1 = heightmod*vec3(8.0,7.0,6.0)/8.0;\n  vec3 lightCol2 = heightmod*vec3(8.0,6.0,7.0)/8.0;\n\n  float lf1 = max(dot(rayDir, lightDir1), 0.0);\n  float lf2 = max(dot(rayDir, lightDir2), 0.0);\n\n  vec3 final = vec3(0.0);\n\n  final += mix(0.5*heightmod, heightmod*vec3(0.0, 0.4, 1.5), pow(min(1.0, abs(1.5*sky)), 1.0));\n\n  final += lightCol1*pow(lf1, mix(4.0, 75.0, time));\n  final += lightCol2*pow(lf2, 75.0)/4.0;\n\n  final += 4.0*lightCol1 * pow(lf1, 100.0);\n  final += 4.0*lightCol2 * pow(lf2, 3200.0);\n\n  return final;\n}\n\n\nfloat and_noise2(in vec3 p)\n{\n  p /=3.0;\n  vec3 q = p;\n  float f;\n  f  = 0.50000*and_noise(q);\n  q = q*2.02;\n  f += 0.25000*and_noise(q);\n  q = q*2.03;\n  f += 0.12500*and_noise(q);\n  return clamp(1.0 - p.y - 2.1 + 2.0*f, 0.0, 1.0);\n}\n\n\nvec4 and_cloudMarch(in float gtime, in vec3 ro, in vec3 rd)\n{\n  float t = 1.0;\n  vec4 sum = vec4(0.0);\n  vec3 heightmod = sqrt(and_heightShade(gtime));\n  for (int i = 0; i < AND_MAX_RAY_MARCHES; ++i)\n  {\n    vec3 p = ro + rd*t;\n    float den = and_noise2(p);\n    vec4 col  = vec4(heightmod*mix(vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), den) + 0.05*sin(p), den);\n    col.a *= 0.6;\n    col.rgb *= col.a;\n\n    sum = sum + col*(1.0 - sum.a);\n\n    t += 0.3;\n  }\n\n  return sum;\n}\n\n\nvec3 and_render(in float gtime, in vec3 ro, in vec3 rd)\n{\n  vec3 skyCol = saturate(and_getSkyColor(gtime, rd));\n  vec4 col = and_cloudMarch(gtime, ro, rd);\n  return skyCol*(pow(1.0 - col.a, 0.2)) + col.xyz;\n}\n\nvoid and_main(in vec2 fragCoord, inout vec3 col)\n{\n  if (!(AND_START < iTime && iTime <= AND_DONE)) return;\n  float gtime = (iTime - AND_START)*1.5;\n\n  vec2 q =fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float ctime = gtime*11.0;\n\n  vec3 ro = vec3(0.0, 0.0, ctime);\n  vec3 ww = normalize(ro + vec3(0.0, 0.0, 1.0));\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 c = and_render(gtime, ro, rd);\n  c = clamp(c, 0., 1.);\n  c = pow(c, vec3(0.416667))*1.055 - 0.055; //sRGB\n\n  col = fadeOut(fadeIn(c, vec3(0.0), AND_START, AND_START + 2.0, iTime), vec3(1.0), AND_DONE - 2.0, AND_DONE, iTime);\n}\n\n// -----------------------------------------------------------------------------\n// A New Dawn - END\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// Mobius scroll text - BEGIN\n// -----------------------------------------------------------------------------\n\n#define MST_START       AND_DONE\n#define MST_DONE        (MST_START + 52.0)\n\n#define MST_BOUNCESTART 0.0\n#define MST_BOUNCEDONE  30.0\n\n#define MST_DISTSTART   5.0\n#define MST_DISTDONE    20.0\n\n#define MST_LAYERSTART  12.0\n#define MST_LAYERDONE   40.0\n#define MST_LAYERCOUNT  6\n\n#define MST_ROTSTART    9.0\n#define MST_ROTDONE     20.0\n\n#define MST_TRANSSTART  0.0\n#define MST_TRANSDONE   30.0\n\nfloat mst_linex(in vec2 p, in float b)\n{\n  float d = abs(p.y) - b;\n  return min(d,0.0) + max(d,0.0);\n}\n\nfloat mst_liney(in vec2 p, in float b)\n{\n  float d = abs(p.x) - b;\n  return min(d,0.0) + max(d,0.0);\n}\n\nfloat mst_circle(in vec2 p, in float r)\n{\n  return length(p) - r;\n}\n\n\nconst vec3 mst_color = vec3(1.125, 1.25, 1.5);\nconst vec3 mst_fontColor = vec3(1.15, 1.1, 1.1);\nconst vec3 mst_glowColor = vec3(1.5, 1.25, 1.125);\n\nvec3 mst_layer(in vec2 p, in int layer, in float time)\n{\n  layer += 3;\n  float s = 0.2/float(layer + 1);\n  const float timeFactor = 0.3;\n  float tm = time*timeFactor;\n  rot(p, mix(0.0, tm + 100.0*s*float(layer) - timeFactor*MST_ROTSTART, smoothstep(MST_ROTSTART, MST_ROTDONE, time)));\n  p += mix(vec2(0.0), -s*200.0*vec2(cos(sqrt(2.0)*tm), sin(tm)) + s*vec2(1.0), smoothstep(MST_TRANSSTART, MST_TRANSDONE, time));\n\n  vec2 sp = toSmith(p);\n  sp += mix(vec2(0.0), -0.5*(2.0+ sin(tm))*mix(p, vec2(1.0), sin(tm*0.1)*sin(tm*0.1)), smoothstep(MST_DISTSTART, MST_DISTDONE, time));\n  p = fromSmith(sp);\n\n  vec2 scp = p;\n  float row = mod1(scp.y, 4.0*s);\n  scp *= 1.0/s;\n  scp += vec2(-row*4.0, -0.5);\n\n  mod2(p, vec2(4.0*s));\n\n  float d = 1E20;\n\n  d = min(d, mst_liney(p, s*0.1));\n  d = min(d, mst_linex(p, s*0.1));\n\n  d = min(d, mst_circle(p, s*0.6));\n  d = max(d, -mst_circle(p, s*0.4));\n\n  vec3 col = vec3(0.0);\n\n  if (d < 0.0)\n  {\n    col = pow(mst_color, vec3(-layer));\n  }\n\n  col = scrollText(scp, time, pow(mst_fontColor, vec3(-layer)), pow(mst_glowColor, vec3(-layer)), col);\n\n  return col;\n}\n\nvec3 mst_mobiusScrollText(in vec2 p, float time)\n{\n\n  p *= mix(0.1, 5.0*(2.0 + sin(time*0.1)), smoothstep(MST_BOUNCESTART, MST_BOUNCEDONE, time));\n\n  float lp = float(MST_LAYERDONE - MST_LAYERSTART) / float(MST_LAYERCOUNT);\n\n  vec3 col = mst_layer(p, 0, time);\n\n  for (int i = 1; i < MST_LAYERCOUNT; ++i)\n  {\n    float lf = smoothstep(float(MST_LAYERSTART) + lp*float(i - 1), float(MST_LAYERSTART) + lp*(float(i - 1) + 0.5), time);\n    col += lf*mst_layer(p, i, time);\n  }\n\n\n  return col;\n}\n\nvec3 mst_fadeOut(vec3 col, vec2 p, float time)\n{\n  p *= 0.5;\n  time *= 2.0;\n  float f = smoothstep(0.25, 1.0, time);\n  float s = (2.5 - 2.35*f);\n  float d = pow(abs(p.x)*abs(p.y), s);\n  float c = 1.0 - smoothstep(0.1, 0.2, abs(d));\n  vec3 sf = (1.0 - pow(f, 16.0))*vec3(c, c, sqrt(c));\n  return mix(col, sf, smoothstep(0.0, 0.25, time));\n}\n\nvoid mst_main(in vec2 fragCoord, inout vec3 col)\n{\n  if (!(MST_START <= iTime && iTime < MST_DONE)) return;\n  float gtime = iTime - 3.0 - MST_START;\n\n  vec3 c = vec3(0.0);\n\n  for(int m=0; m<AA; ++m)\n  for(int n=0; n<AA; ++n)\n  {\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n    c += mst_mobiusScrollText(p, gtime);\n  }\n\n  vec2 q =fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  col = mst_fadeOut(fadeIn(c/float(AA*AA), vec3(1.0), MST_START, MST_START + 4.0, iTime), p, iTime - (MST_DONE - 1.0));\n}\n\n// -----------------------------------------------------------------------------\n// Mobius scroll text - END\n// -----------------------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col = vec3(0.0);\n\n  rii_main(fragCoord, col);\n  iii_main(fragCoord, col);\n  mbd_main(fragCoord, col);\n  and_main(fragCoord, col);\n  mst_main(fragCoord, col);\n\n  fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18318,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/adhesivewombat/adhesivewombat-8-bit-adventure"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}