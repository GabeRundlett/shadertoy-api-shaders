{
    "Shader": {
        "info": {
            "date": "1700252683",
            "description": "I refactored someone else's shader to help me understand it better.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtVcDD",
            "likes": 3,
            "name": "Fork Structures nov2023",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "amaxwell",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "// refactored from https://www.shadertoy.com/view/Ms2SDc\n\nconst float PI = 3.14159;\nconst float ep = 0.02;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\nconst vec3 lightColor = vec3(0.08, 0.02, -0.01);\nconst float atmosphere = 0.0625;\nconst int maxIterations = 96;\nconst float holeWidth = 0.05;\n\n// takes a 2d vector and rotates it by some angle\nvec2 rotate(vec2 vector, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return vec2(\n        cosAngle * vector.x - sinAngle * vector.y,\n        sinAngle * vector.x + cosAngle * vector.y    \n    );\n}\n\n// takes a point in space and returns how far it is from the scene\n// this is a very compact way to represent a scene mathematically\nfloat sceneSDF(vec3 pos) {\n\tfloat ground = dot(pos, up) + 0.75;\n\tfloat structure = length(abs(mod(pos, 2.0) - 1.0)) - 1.35 \n        + 0.05 * cos(PI * pos.x * 4.0) \n        + 0.05 * sin(PI * pos.z * 4.0);\n\tfloat slice1 = length(max(abs(mod(pos, 2.0) - 1.0).xz - 1.0, 0.5)) - 0.075 \n        + 0.1 * cos(pos.y * 36.0);\n\tfloat slice2 = length(abs(mod(pos, 0.5)) - 0.25) - 0.975;\n\n\tfloat bubble_w = 0.8 + 0.2 * cos(PI * pos.z) + 0.2 * cos(PI * pos.x);\n\tfloat bubble = length(mod(pos, 0.125) - 0.0625) - bubble_w;\n\n\tfloat hole = length(abs(mod(pos.xz, 1.0) - 0.5)) - holeWidth;\n\n\treturn max(\n        slice1 + slice2,\n        min(\n            -structure, \n            max(\n                -hole - slice2 * 0.375,\n                ground + bubble\n            )\n        )\n    );\n}\n\n// starts from the camera location and moves in the rayDirection until it touches the scene\n// uses the point where the ray hits the scene and its distance from the camera to calculate a color\nvec3 calculateRayColor(vec3 cameraLocation, vec3 rayDirection) {\n    float rayLength = 0.0;\n    for (int i = 0; i < maxIterations; i++) {\n        float distance = sceneSDF(cameraLocation + rayDirection * rayLength);\n        if (abs(distance) < 0.005) break;\n        rayLength += distance * 0.5;\n    }\n\n    vec3 hitPoint = cameraLocation + rayDirection * rayLength;\n\n    float lightIntensity = dot(\n        normalize(vec3(\n            sceneSDF(hitPoint + vec3(-ep, ep, ep)), \n            sceneSDF(hitPoint + vec3(ep, -ep, -ep)), \n            sceneSDF(hitPoint + vec3(ep, ep, -ep))\n        )), \n        vec3(0.1)\n    );\n\n    vec3 baseColor = vec3(lightIntensity) - rayLength * atmosphere;\n    return baseColor * baseColor + vec3(lightIntensity) + rayLength * lightColor;\n}\n\n// returns the direction of the ray for a screen coordinate\nvec3 getRayDirection(vec2 fragCoord) {\n    vec3 rayDirection = normalize(\n        vec3((2.0 * fragCoord / iResolution.xy - 1.0) * vec2(1.625, 1.0), 0.75)\n    );\n    rayDirection.yz = rotate(rayDirection.yz, PI * 0.25 * sin(PI * iTime * 0.125));\n    rayDirection.zx = rotate(rayDirection.zx, PI * cos(-PI * iTime * 0.05));\n    rayDirection.xy = rotate(rayDirection.xy, PI * 0.125 * cos(PI * iTime * 0.125));\n    return rayDirection;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 cameraLocation = vec3(\n        1.5 * cos(PI * iTime * 0.125), \n        4.0 - 3.0 * sin(PI * iTime * 0.125), \n        -1.0 - iTime\n    );\n\n    fragColor = vec4(\n        calculateRayColor(cameraLocation, getRayDirection(fragCoord)), \n        1.0\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}