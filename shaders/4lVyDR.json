{
    "Shader": {
        "info": {
            "date": "1535840738",
            "description": "Multi Julia Testing 123...",
            "flags": 0,
            "hasliked": 0,
            "id": "4lVyDR",
            "likes": 1,
            "name": "Julia Set Multi Test",
            "published": 3,
            "tags": [
                "fractal",
                "hybrid"
            ],
            "usePreview": 0,
            "username": "Chris_M_Thomasson",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "/*\nMulti Mandelbrot:(0.0.0)\n\nby: Chris M. Thomasson\n___________________________________*/\n\n\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float sdis = 99999.0;\n    \n    float time = 0.0;//iTime / 10.0;\n    float escape_scale = .4 + abs(cos(iTime / 5.0)) * .1;\n    \n    /*\n    z = ct_cmul(z, z);\n    z = z + c;\n    \n    z = ct_cmul(z, z);\n    z = z + c;\n    \n    z = ct_cmul(z, z);\n    z = z + c;\n    \n    z = ct_cmul(z, z);\n    z = z + c;\n    \n    z = ct_cmul(z, z);\n    z = z + c;\n*/\n    \n    vec2 jp[3];\n    \n    jp[0] = vec2(0.355534, -0.337292) ;//vec2(-0.745, 0.113);\n    jp[1] = vec2(-0.66, 0.048);\n    \n    float jptime = 0.4;\n    jp[2] = vec2(cos(jptime), sin(jptime));\n    \n    float zscale = .9 + abs(cos(iTime * .5)) * .1;\n    \n    float escape = 2.0;\n    int i = 0;\n    for (i = 0; i < n; ++i)\n    {\n        \n        vec2 jps = jp[0];\n        \n        if ((i % 2) == 1)\n        {\n            jps = jp[0];\n        }\n        \n        else\n        {\n            jps = jp[1];\n        }\n\n        \n        z = ct_cmul(z, z);\n        z = z + jps;\n        \n        z = z * zscale;\n        \n    \tfloat dis = length(z);\n        \n        sdis = min(sdis, dis);\n        \n        if (dis > 100.0)\n        {\n            //z = z * .5;\n           break;\n        }\n    }\n    \n    float ctime = 0.0;\n    float scale = 2.0;\n    color.r = mod((1.0 - sdis) * 3.0, 1.0);\n    color.g = mod(ct_normal_pi(z, iTime * 5.0) * 1.0, 1.0) * .4;\n    color.b = mod(float(i) / float(n) * .5, 1.0);\n    \n    return color;\n}\n\n\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    float time = iTime / 10.0;\n    vec2 rc = vec2(-.75, 0.06);\n    \n    vec2 rcx = vec2(\n        -1.0 + abs(cos(time)) * 1.3, \n        -1.0 + abs(sin(time)) * 1.3\n    );\n    \n    return ct_vpixel(c, c, 600, 2.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0.0, \n        0.0, \n        1.0 - abs(cos(iTime * .1)) * .7\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}