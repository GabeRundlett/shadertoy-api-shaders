{
    "Shader": {
        "info": {
            "date": "1665391736",
            "description": "Approximately the same as https://www.shadertoy.com/view/styBW3 but with 3D-Sdf and raymarching algorithm",
            "flags": 0,
            "hasliked": 0,
            "id": "slKfW3",
            "likes": 3,
            "name": "Line 2D with lightning 3Dversion",
            "published": 3,
            "tags": [
                "3d",
                "line",
                "lightning"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\nfloat lines(in vec2 pos){\n    float scale = 16.;\n    pos *= scale;\n    float v = sin(pos.x);\n    return smoothstep(-2., 2., v/fwidth(v));\n}\n\nfloat SceneSdf(vec3 p){\n    float h = 1.+cos(iTime*.5);\n    float l = length(p.xy);\n    return h*cos(l*2.*3.1415)-p.z;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 diff = vec2(0.01, 0.);\n    float dist = SceneSdf(p);\n    \n    vec3 normal = dist - vec3(SceneSdf(p - diff.xyy),\n                              SceneSdf(p - diff.yxy),\n                              SceneSdf(p - diff.yyx) );\n    normal = normalize(normal);\n    normal.z *= -1.; // in order to have Upward normal\n    return (normal);\n}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = SceneSdf(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n  return depth;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 col;\n    vec3 normal;\n   \n    \n    \n    vec3 ro = vec3(0., 0., 5.+1.+cos(iTime*.5)); // ray origin that represents camera position\n   \n    vec3 rd = normalize(vec3(uv, -1));\n\n    float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n    if (d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n    } else {\n    vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n    normal = GetNormal(p);\n    vec3 lightPosition = vec3(0, 0, 12);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    vec2 xy = p.xy;\n    float angle = cos(length(xy*2.*3.1415));\n    angle *= cos(iTime)*.5 ;\n    mat2 rot = rotate2d(angle);  \n    xy = rot*xy;\n\n    vec2 st = vec2(length(xy), atan(xy.x, xy.y));\n\n    st.x *= smoothstep(.2, .21, length(xy));\n    st.y *= step(.02, length(xy));\n    float l = lines(st.yx);\n    col = vec3(l)+vec3(1.-l)*.2;\n\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * col;\n  }\n    vec3 res = vec3(0.);\n    if (uv.x>0.){\n        res = col;\n    }\n    else{\n        res = normal.xyz;\n    }\n  // Output to screen\n  fragColor = vec4(res, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}