{
    "Shader": {
        "info": {
            "date": "1513170829",
            "description": "This goes under the category \"Happy accidents\". Initially I wanted to do a sin-wave-scroller. But it went in a totally different direction. Then I thought I should try out the soundcloud-support. Although I do not think I'm pulling the right values.",
            "flags": 96,
            "hasliked": 0,
            "id": "XtsfWS",
            "likes": 2,
            "name": "distorted wavy fbm somethings",
            "published": 3,
            "tags": [
                "2d",
                "fbm",
                "music",
                "multipass"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 722
        },
        "renderpass": [
            {
                "code": "// pulling it all together and adding the radial blur on top\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// distorted wavy fbm somethings (aka happy accident) \n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int SAMPLES = 32;\nconst float STRENGTH = -.125;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // coord. normalizing and aspect-correction\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // do the radial blur\n    float scale = .0;\n    vec3 col = vec3 (.0);\n    vec3 sum = vec3 (.0);\n    for (int i = 0; i < SAMPLES; ++i) {\n        scale = (float (i) / float (SAMPLES)) * STRENGTH;\n        vec2 offset = uv * scale;        \n    \tcol = texture (iChannel0, fragCoord.xy / iChannelResolution[0].xy + offset).rgb;\n        sum += (col * col);\n    }\n    col = sum / float (SAMPLES);\n\n    // tonemap, gamma-correction, vignette\n    col = col / (1. + col);\n    col = sqrt (col);\n    col.rgb *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// creating the weird mask/scene with 2d-raymarching\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// distorted wavy fbm somethings (aka happy accident) \n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (in float angle)\n{\n    float c = cos (angle);\n    float s = sin (angle);\n\treturn mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\n// create some wavy mess with sin/cos and pull some noise-values to distort it\nfloat scene (in vec2 p)\n{\n    vec2 uv = (p + 1.) * .5;\n    uv *= .5;\n    p += texture (iChannel0, uv).xy;\n    float t = iTime;\n\n    float x = p.x + sin (t + p.y * cos (t));\n    float y = p.y + t;\n\n    float a = .5;\n    float b = 4.;\n    float c = .5;\n\n    return length (vec2 (x + a*sin (b*y), .0)) - c*cos (p.y * sin (10.*t));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    float pSize = 1. / iResolution.y;\n\n    float a = .01 + sin (uv.y*uv.x) *.5 + .5;\n    float b = .25*a;\n    float d = smoothstep (a, b, scene (uv));\n\n    // making the noise-textures rotate around the center\n    vec2 uv2 = fragCoord / iChannelResolution[0].xy;\n    uv2 -= .5;\n    uv2.x *= iChannelResolution[0].x / iChannelResolution[0].y;\n    uv2 *= .6;\n    vec2 uv3 = uv2;\n    uv2 *= r2d (iTime);\n    uv3 *= r2d (-iTime);\n    uv2 += .5;\n    uv3 += .5;\n\n    vec3 col1 = texture (iChannel0, uv2).rgb * vec3 (.0, .4, .9);\n    vec3 col2 = texture (iChannel0, uv3).rgb * vec3 (1., .45, .2);\n    vec3 col = mix (col1, col2, d);\n\n    // trying to let the border between the red and blue thing flash based on the music\n    float f = texelFetch (iChannel1, ivec2 (abs(uv.x), .0), 0).r;\n    col *= 2.2 * cos (pow(d, f*f*15.));\n\n\tfragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 12773,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/demoscenedelights/wayfinder-platinum"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// just the noise-texture generation is in this buffer\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// distorted wavy fbm somethings (aka happy accident) \n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (in float a){float c=cos(a);float s=sin(a);return mat2(vec2(c,s),vec2(-s,c));}\n\nfloat hash (in float v)\n{\n    return fract (sin (v) * 55734.5453);\n}\n\n// iq's 3D-noise adapted to 2D\nfloat noise(in vec2 p)\n{\n    vec2 fl = floor (p);\n    vec2 fr = fract (p);\n\n\t// these six lines I don't get...\n    // and I don't know how iq came up with those values \n    fr = fr * fr * (3. - 2. * fr);\n    float x = fl.x + 57. * fl.y;\n    float a = hash (x);\n    float b = hash (x + 1.);\n    float c = hash (x + 57.);\n    float d = hash (x + 58.);\n\n    return mix (mix (a, b, fr.x),\n                mix (c, d, fr.x),\n                fr.y);\n}\n\nfloat fbm (in vec2 p)\n{\n\tfloat v = .0;\n    v += .5 * noise (p*r2d(iTime) + vec2 (cos (p.x*p.y), sin(p.x+p.y)));\n    p *= r2d (23.4) * 2.02 * (1. + .3 * sin (iTime));\n    v += .25 * noise (p);\n    p *= r2d (45.6) * 2.03 * (1. + .35 * cos (iTime)*sin (iTime));\n    v += .125 * noise (p);\n    p *= r2d (78.9) * 2.04 * (1. + .4 * cos (iTime));\n    v += .0625 * noise (p);\n    v /= .9375;\n\n    return v;\n}\n\nvoid mainImage (out vec4 col, in vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = 4.2 + iTime;\n    uv += vec2 (cos(t), sin(t));\n\n    col = vec4 (vec3(fbm (2.75*uv)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}