{
    "Shader": {
        "info": {
            "date": "1619414690",
            "description": "It's the Mandelbrot set, but with cats.  Click to zoom, cursor keys to pan.",
            "flags": 48,
            "hasliked": 0,
            "id": "NdfXDl",
            "likes": 7,
            "name": "interactive nyanbrot zoomer",
            "published": 3,
            "tags": [
                "mandelbrot",
                "nyancat",
                "stateful",
                "df64"
            ],
            "usePreview": 0,
            "username": "sh1boot",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "FLOAT getParam(int i) {\n   return unpack(texelFetch(iChannel0, ivec2(i, 0), 0));\n}\n\n\nvec4 img(vec2 c, float off) {\n    c = clamp(c * 1.0 + vec2(0.5, 0.6), vec2(0.0), vec2(1.0));\n    float t = floor(fract(iTime * 4.0 + off) * 6.0);\n    c.x = (fract(c.x) + t) * 40.0 / 256.0;\n    return texture(iChannel1, c);\n}\n\n\nvec4 brot(FLOAT cx, FLOAT cy, float junk) {\n    float iter = 0.0;\n    FLOAT zx = cx;\n    FLOAT zy = cy;\n    vec4 colour = vec4(0.0);\n    for (int i = 0; i < 512; ++i) {\n        FLOAT tx = add(mul(zx, zx, junk), -mul(zy, zy, junk), junk);\n        FLOAT ty = mul(mul(zx, zy, junk), 2.0, junk);\n        zx = add(tx, cx, junk);\n        zy = add(ty, cy, junk);\n        if (i >= 30 && (i & 1) == 0) {\n          vec2 p = vec2(zx.x, zy.x);\n          if ((i & 2) == 0) p = p.yx;\n          if ((i & 4) == 0) p.y = -p.y;\n          if ((i & 8) == 0) p.x = -p.x;\n          vec4 tex = img(p, float(i) / 7.0);\n          if ((i % 3) == 1) tex = tex.rbga;\n          colour = mix(tex, colour, colour.a);\n          if (colour.a > 0.95) return colour;\n       }\n       if (lensquare(zx, zy, junk) > 4.0) break;\n       iter = iter + 1.0;\n    }\n    if (iter >= 511.0) return vec4(0.0, 0.0, 0.0, 0.0);\n\n//    return colour;\n\n    return vec4(0.5 + 0.5 * cos(3.0 + iter * 0.15 + vec3(0.0, 0.6, 1.0)), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float junk = make_junk(iTime);\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    FLOAT cx = getParam(0);\n    FLOAT cy = getParam(1);\n    FLOAT zoom = getParam(2);\n    \n    cx = add(cx, mul(zoom, uv.x, junk), junk);\n    cy = add(cy, mul(zoom, uv.y, junk), junk);\n\n    fragColor = brot(cx, cy, junk);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#if 0\n#define FLOAT float\nvec4 pack(FLOAT f) {\n    return vec4(f, 0.0, 0.0, 0.0);\n}\nFLOAT unpack(vec4 v) {\n    return v.x;\n}\nFLOAT toFLOAT(float x) {\n    return x;\n}\nFLOAT mul(FLOAT a, FLOAT b, float junk) {\n    return a * b;\n}\n\nFLOAT add(FLOAT a, FLOAT b, float junk) {\n    return a + b;\n}\nfloat lensquare(FLOAT a, FLOAT b, float junk) {\n    return mul(a, a, junk) + mul(b, b, junk);\n}\n// make a value of junk that works for the functions above.\nfloat make_junk(float a_positive_variable) {\n   return 0.0;\n}\n#else\n#define FLOAT vec4\nvec4 pack(FLOAT f) {\n    return f;\n}\nFLOAT unpack(vec4 v) {\n    return v;\n}\nFLOAT toFLOAT(float x) {\n    return vec4(x, 0.0, 0.0, 0.0);\n}\n\n// force the computation of x without optimisation, by making it depend on junk.\nfloat final(float x, float junk) {\n    return x + junk;\n}\n\nvec2 final(vec2 x, float junk) {\n    return x + junk;\n}\n\n// make a value of junk that works for the functions above.\nfloat make_junk(float a_positive_variable) {\n   return 1.0 - step(0.0, a_positive_variable);\n}\n\n// from: http://andrewthall.org/papers/df64_qf128.pdf\nvec2 quickTwoSum(float a, float b, float junk) {\n    float s = final(a + b, junk);\n    float e = b - (s - a);\n    return vec2(s, e);\n}\nvec2 twoSum(float a, float b, float junk) {\n    float s = final(a + b, junk);\n    float v = s - a;\n    float e = (a - (s - v)) + (b - v);\n    return vec2(s, e);\n}\nvec4 twoSumComp(vec2 a, vec2 b, float junk) {\n    vec2 s = final(a + b, junk);\n    vec2 v = s - a;\n    vec2 e = (a - (s - v)) + (b - v);\n    return vec4(s.x, e.x, s.y, e.y);\n}\nvec2 df64_add(vec2 a, vec2 b, float junk) {\n    vec4 sum = twoSumComp(a, b, junk);\n    vec2 s = sum.xy;\n    vec2 t = sum.wz;\n    s.y += t.x;\n    s = quickTwoSum(s.x, s.y, junk);\n    s.y += t.y;\n    s = quickTwoSum(s.x, s.y, junk);\n    return s;\n}\nvec2 split(float a, float junk) {\n    const float split = 4097.0;\n    float t = a * split;\n    float a_hi = t - final(t - a, junk);\n    float a_lo = a - a_hi;\n    return vec2(a_hi, a_lo);\n}\nvec4 splitComp(vec2 c, float junk) {\n    const float split = 4097.0;\n    vec2 t = c * split;\n    vec2 c_hi = t - final(t - c, junk);\n    vec2 c_lo = c - c_hi;\n    return vec4(c_hi.x, c_lo.x, c_hi.y, c_lo.y);\n}\n\nvec2 twoProd(float a, float b, float junk) {\n#if 1  // yes fma\n    float p = a * b;\n    float err = a * b - p;\n#else  // no fma\n    float p = a * b;\n    vec4 split = splitComp(vec2(a, b), junk);\n    vec2 aS = split.xy;\n    vec2 bS = split.wz;\n    float err = ((aS.x * bS.x - p)\n                 + aS.x * bS.y + aS.y * bS.x)\n                + aS.y * bS.y;\n#endif\n     return vec2(p, err);\n}\nvec2 df64_mult(vec2 a, vec2 b, float junk) {\n    vec2 p;\n\n    p = twoProd(a.x, b.x, junk);\n    p.y += a.x * b.y;\n    p.y += a.y * b.x;\n    p = quickTwoSum(p.x, p.y, junk);\n    return p;\n}\nvec2 df64_mult(vec2 a, float b, float junk) {\n    vec2 p;\n\n    p = twoProd(a.x, b, junk);\n    p.y += a.y * b;\n    p = quickTwoSum(p.x, p.y, junk);\n    return p;\n}\n\nFLOAT mul(FLOAT a, FLOAT b, float junk) {\n    return vec4(df64_mult(a.xy, b.xy, junk), 0.0, 0.0);\n}\nFLOAT mul(FLOAT a, float b, float junk) {\n    return vec4(df64_mult(a.xy, b, junk), 0.0, 0.0);\n}\nFLOAT add(FLOAT a, FLOAT b, float junk) {\n    return vec4(df64_add(a.xy, b.xy, junk), 0.0, 0.0);\n}\nfloat lensquare(FLOAT a, FLOAT b, float junk) {\n    return mul(a, a, junk).x + mul(b, b, junk).x;\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "FLOAT getParam(int i) {\n   return unpack(texelFetch(iChannel0, ivec2(i, 0), 0));\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\nconst int KEY_HOME  = 36;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float junk = make_junk(iTime);\n    vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    int p = int(fragCoord.x);\n    FLOAT f = getParam(p);\n    FLOAT zoom = getParam(2);\n\n    int pluskey = 0;\n    int minuskey = 0;\n    FLOAT reset = toFLOAT(0.0);\n    FLOAT incr = mul(zoom, 0.025, junk);\n    float m = 0.0;\n\n    switch (p) {\n    case 0:\n        reset = toFLOAT(-0.75);\n        pluskey = KEY_RIGHT;\n        minuskey = KEY_LEFT;\n        m = mouse.x;\n        break;\n\n    case 1:\n        reset = toFLOAT(0.0);\n        pluskey = KEY_UP;\n        minuskey = KEY_DOWN;\n        m = mouse.y;\n        break;\n\n    case 2:\n        reset = toFLOAT(1.25);\n        pluskey = KEY_PGDN;\n        minuskey = KEY_PGUP;\n        break;\n    }\n\n    if (texelFetch(iChannel1, ivec2(KEY_HOME, 0), 0).x > .5 || iFrame < 1)\n        f = reset;\n    if (texelFetch(iChannel1, ivec2(pluskey, 0), 0).x > .5)\n        f = add(f, incr, junk);\n    if (texelFetch(iChannel1, ivec2(minuskey, 0), 0).x > .5)\n        f = add(f, -incr, junk);\n\n    if (iMouse.z > 0.0) {\n        f = add(f, mul(zoom, m, junk), junk);\n        zoom = mul(zoom, 0.975, junk);\n        f = add(f, -mul(zoom, m, junk), junk);\n        if (p == 2) f = zoom;\n    }\n\n    fragColor = pack(f);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}