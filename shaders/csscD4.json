{
    "Shader": {
        "info": {
            "date": "1687898592",
            "description": "Rendering voxel terrain using minmax mipmaps/quadtree displacement mapping\n\nMouse drag to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "csscD4",
            "likes": 108,
            "name": "Voxel Terrain Minmax Traversal",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "terrain",
                "voxel",
                "quadtree",
                "traversal",
                "minmax"
            ],
            "usePreview": 1,
            "username": "gelami",
            "viewed": 3213
        },
        "renderpass": [
            {
                "code": "\n// Voxel Terrain Minmax Traversal - gelami\n// https://www.shadertoy.com/view/csscD4\n\n/* \n * Rendering voxel terrain using minmax mipmaps/quadtree displacement mapping\n * \n * Mouse drag to look around\n * \n * The heightmap and its mipmaps is each stored in a cubemap face,\n * which has a constant resolution of 1024x1024, unlike in my previous minmax shader\n * \n * Grass is rendered as a special intersection on the top block \n * \n * Clouds are only 2D, with a fake shadow to give it some shape and depth\n * \n * There is still more room to add to this, for example you could store\n * up to 4 heightmaps in 4 faces, and store its mipmaps in the remaining 2,\n * allowing you to make a 2048x2048 sized terrain, or use it to add more layers\n * \n * Like in this shader from kastorp:\n * Heightmap with Layers - kastorp\n * https://www.shadertoy.com/view/7l23Rc\n * \n * My previous minmax traversal shader:\n * Fast Minmax Terrain Traversal - gelami\n * https://www.shadertoy.com/view/msj3Dh\n * \n * I changed my fake AO to use voxel AO instead, from:\n * Voxel Ambient Occlusion - fb39ca4\n * https://www.shadertoy.com/view/ldl3DS\n * \n * Catmull-rom spline camera path based on: \n * Fractal Flythrough - Shane\n * https://www.shadertoy.com/view/4s3SRN\n * \n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-06-15 09:26:29\n\nfloat map(vec3 p)\n{\n    const float sc = SCALE;\n    float s = 1.0 / (float(getLodSize(MIN_LOD)) * sc);\n    \n    #if 1\n    float h = luminance(sRGBToLinear(textureLod(iChannel2, p.xz * sc, 1.0).rgb)) * MAX_HEIGHT;\n    \n    return p.y - h;\n    #else\n    vec4 data = SampleCubemapLod(iChannel0, fract(p.xz * sc), vec2(1024), 0);\n    \n    float h = (data.r - (data.a + data.g) * s) * MAX_HEIGHT;\n    \n    return p.y - h;\n    #endif\n}\n\nvec3 grad(vec3 p)\n{\n    vec2 e = vec2(0, 1.0 / 1024.0);\n    \n    return vec3(map(p - e.yxx) - map(p + e.yxx),\n                e.y,\n                map(p - e.xxy) - map(p + e.xxy)\n            ) / (e.y * 2.0);\n}\n\nfloat getVoxel(vec3 id) {\n    const float sc = SCALE;\n    \n    float s = 1.0 / (float(getLodSize(MIN_LOD)) * sc);\n    \n    vec3 p = (floor(id) + 0.5) * s;\n\tvec4 data = SampleCubemapLodNearest(iChannel0, fract(p.xz * sc), vec2(1024), 0);\n    \n    float h = data.r * MAX_HEIGHT;\n    \n    return float(p.y < h - (data.a == 1.0 ? s : 0.0));\n}\n\n// Voxel AO from:\n// Voxel Ambient Occlusion - fb39ca4\n// https://www.shadertoy.com/view/ldl3DS\nfloat vertexAo(vec2 side, float corner) {\n\t//if (side.x == 1.0 && side.y == 1.0) return 1.0;\n\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\n}\n\nvec4 voxelAo(vec3 pos, vec3 d1, vec3 d2) {\n\tvec4 side = vec4(getVoxel(pos + d1), getVoxel(pos + d2), getVoxel(pos - d1), getVoxel(pos - d2));\n\tvec4 corner = vec4(getVoxel(pos + d1 + d2), getVoxel(pos - d1 + d2), getVoxel(pos - d1 - d2), getVoxel(pos + d1 - d2));\n\tvec4 ao;\n\tao.x = vertexAo(side.xy, corner.x);\n\tao.y = vertexAo(side.yz, corner.y);\n\tao.z = vertexAo(side.zw, corner.z);\n\tao.w = vertexAo(side.wx, corner.w);\n\treturn 1.0 - ao;\n}\n\nvec2 asign(vec2 p)\n{\n    return vec2(\n        p.x >= 0.0 ? 1.0 : -1.0,\n        p.y >= 0.0 ? 1.0 : -1.0);\n}\n\nvec3 asign(vec3 p)\n{\n    return vec3(\n        p.x >= 0.0 ? 1.0 : -1.0,\n        p.y >= 0.0 ? 1.0 : -1.0,\n        p.z >= 0.0 ? 1.0 : -1.0);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 id;\n    int i;\n    int type;\n};\n\nbool intersectObject(vec3 ro, vec3 rd, vec2 id, float t, float h, float s, out HitInfo hit)\n{\n    vec3 sp = vec3(id.x, h - s * 0.5, id.y);\n    \n    float tP2 = -(ro.y - (h - s)) / rd.y;\n\n    #if 0\n    vec2 sph = sphereIntersection(ro - sp, rd, s * 0.5);\n\n    if (sph.x < MAX_DIST)\n    {\n        hit.t = sph.x;\n        hit.n = normalize(ro + rd * sph.x - sp);\n        hit.id = id;\n        hit.i = i;\n        hit.type = 1;\n        return true;\n    }\n    #else\n\n    float ang = hash12(id*12.0) * TAU;\n\n    vec3 gn0 = vec3(cos(ang), 0, sin(ang));\n    vec3 gn1 = vec3(-gn0.z, 0, gn0.x);\n    //const vec3 gn0 = vec3(sqrt(0.5), 0, sqrt(0.5));\n    //const vec3 gn1 = vec3(-sqrt(0.5), 0, sqrt(0.5));\n    \n    float pa = dot(rd, gn0);\n    float pb = -dot(ro - sp, gn0) / pa;\n\n    vec3 pp = ro + rd * pb;\n\n    vec2 puv = vec2(dot(pp - sp, gn1), pp.y - sp.y);\n\n    pb = pb > 0.0 && abs(puv.x) < s * 0.5 && abs(puv.y) < s * 0.5 ? pb : MAX_DIST;\n\n    float pa2 = dot(rd, gn1);\n    float pb2 = -dot(ro - sp, gn1) / pa2;\n\n    vec3 pp2 = ro + rd * pb2;\n\n    vec2 puv2 = vec2(dot(pp2 - sp, gn0), pp2.y - sp.y);\n\n    pb2 = pb2 > 0.0 && abs(puv2.x) < s * 0.5 && abs(puv2.y) < s * 0.5 ? pb2 : MAX_DIST;\n\n    vec3 pn = gn0;\n    if (pb2 < pb)\n    {\n        pb = pb2;\n        puv = puv2;\n        pn = gn1;\n        pa = pa2;\n    }\n\n    if (pb < MAX_DIST)\n    {\n        hit.t = pb;\n        hit.n = -pn * sign(pa);\n        hit.id = id;\n        //hit.i = i;\n        hit.type = 1;\n        return true;\n    }\n\n    #endif\n    else if (rd.y < 0.0 && tP2 > 0.0 && tP2 < t)\n    {\n        hit.t = tP2;\n        hit.n = vec3(0, 1, 0);\n        hit.id = id;\n        //hit.i = i;\n        return true;\n    }\n\n    return false;\n}\n\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, float tmin, float tmax)\n{\n    if ((rd.y > 0.0 && ro.y > MAX_HEIGHT) ||\n        (rd.y < 0.0 && ro.y < 0.0) || iFrame < MAX_LOD)\n        return false;\n    \n    hit.t = MAX_DIST;\n    hit.type = 0;\n    \n    ro = ro + rd * tmin;\n    vec3 pos = ro;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = asign(ird);\n    vec3 ard = abs(ird);\n    vec3 iro = pos * ird;\n    \n    const int minlod = MIN_LOD;\n    const float sc = SCALE;\n    \n    int lod = MAX_LOD;\n    float s = 1.0 / (float(getLodSize(lod)) * sc);\n    vec2 id = (floor(pos.xz / s) + 0.5) * s;\n    vec2 pid = id;\n    \n    float t = 0.0;\n    vec2 nrd = vec2(0);\n    int i = min(0, iFrame);\n    for (; i < STEPS; i++)\n    {\n        vec4 data = SampleCubemapLodNearest(iChannel0, fract(id * sc), vec2(1024), lod);\n        \n        float h = data.r * MAX_HEIGHT;\n        \n        vec2 p = id;\n        vec2 n = iro.xz - p * ird.xz;\n        vec2 k = ard.xz * s * 0.5;\n        \n        vec2 t0 = -n - k;\n        vec2 t1 = -n + k;\n        \n        float tF = min(t1.x, t1.y);\n        \n        if (pos.y < h)\n        {\n            if (lod == minlod)\n            {\n                if (lod == 0 && data.a == 1.0 && h - pos.y < s * MAX_HEIGHT)\n                {\n                    if (intersectObject(ro, rd, id, tF, h, s, hit))\n                    {\n                        hit.i = i;\n                        return true;\n                    }\n                    \n                } else\n                {\n                    hit.t = t;\n                    hit.n = vec3(-nrd, 0).xzy;\n                    hit.id = id;\n                    hit.i = i;\n                    return true;\n                }\n            } else\n            {\n                s *= 0.5;\n                lod--;\n                id += asign(pos.xz - id) * s * 0.5;\n                continue;\n            }\n        }\n        \n        float tP = -(ro.y - h) * ird.y;\n        \n        pos = ro + rd * tF;\n        \n        if (pos.y < h)\n        {\n            if (lod == minlod)\n            {\n                if (lod == 0 && data.a == 1.0)\n                {\n                    if (intersectObject(ro, rd, id, tF, h, s, hit))\n                    {\n                        hit.i = i;\n                        return true;\n                    }\n                } else\n                {\n                    hit.t = tP;\n                    hit.n = vec3(0, 1, 0);\n                    hit.id = id;\n                    hit.i = i;\n                    return true;\n                }\n            } else\n            {\n                pos = ro + rd * (-(ro.y - h) * ird.y - EPS);\n                s *= 0.5;\n                lod--;\n                id += asign(pos.xz - id) * s * 0.5;\n                continue;\n            }\n        }\n        \n        if (tF + tmin > tmax ||\n           (rd.y > 0.0 && pos.y > MAX_HEIGHT) ||\n           (rd.y < 0.0 && pos.y < 0.0))\n            return false;\n        \n        t = tF;\n        nrd = t1.x <= t1.y ? vec2(srd.x, 0) : vec2(0, srd.z);\n        pid = id;\n        id += nrd * s;\n        \n        vec2 iid = id / s;\n        vec2 ipid = pid / s;\n        if (floor(iid*0.5) != floor(ipid*0.5) && lod < MAX_LOD)\n        {\n            s *= 2.0;\n            id = (floor(iid*0.5) + 0.5) * s;\n            pid = id;\n            lod++;\n        }\n    }\n    \n    return false;\n}\n\nvec3 shade()\n{\n    vec3 col = vec3(0);\n\n    return col;\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel3,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nconst mat2 rot = mat2(0.866, 0.5, -0.5, 0.866) * 2.0;\n\nfloat getClouds(vec2 p, const float a, const float b)\n{\n    #if 0\n    float d = texture(iChannel3, p).r*0.5; p *= rot;\n    d += texture(iChannel3, p).r*0.25*0.9; p *= rot;\n    d += texture(iChannel3, p).r*0.125*0.7; p *= rot;\n    d += texture(iChannel3, p).r*0.0625*0.5; p *= rot;\n    #else\n    vec3 q = vec3(p * 256.0, iTime*0.05);\n    float d = noise(q)*0.5; q.xy *= rot;\n    d += noise(q)*0.25*0.9; q.xy *= rot;\n    d += noise(q)*0.125*0.7; q.xy *= rot;\n    d += noise(q)*0.0625*0.5; q.xy *= rot;\n    #endif\n    d = smoothstep(a, b, d);\n    \n    return d;\n}\n\n\n#define CAM_PATH_LENGTH 30\n\nconst vec3[CAM_PATH_LENGTH] CAM_PATH = vec3[](\n    vec3(0.08/SCALE, 0.28, 0.52/SCALE),\n    vec3(0.105/SCALE, 0.15, 0.58/SCALE),\n    vec3(0.1/SCALE, 0.2, 0.64/SCALE),\n    vec3(0.1/SCALE, 0.25, 0.7/SCALE),\n    vec3(0.16/SCALE, 0.15, 0.73/SCALE),\n    vec3(0.21/SCALE, 0.1, 0.71/SCALE),\n    vec3(0.25/SCALE, 0.15, 0.67/SCALE),\n    vec3(0.31/SCALE, 0.2, 0.64/SCALE),\n    vec3(0.35/SCALE, 0.28, 0.61/SCALE),\n    vec3(0.39/SCALE, 0.3, 0.58/SCALE),\n    vec3(0.40/SCALE, 0.25, 0.54/SCALE),\n    vec3(0.42/SCALE, 0.28, 0.5/SCALE),\n    vec3(0.46/SCALE, 0.26, 0.47/SCALE),\n    vec3(0.5/SCALE, 0.2, 0.45/SCALE),\n    vec3(0.54/SCALE, 0.15, 0.43/SCALE),\n    vec3(0.59/SCALE, 0.25, 0.39/SCALE),\n    vec3(0.605/SCALE, 0.32, 0.34/SCALE),\n    vec3(0.58/SCALE, 0.30, 0.31/SCALE),\n    vec3(0.53/SCALE, 0.38, 0.29/SCALE),\n    vec3(0.49/SCALE, 0.42, 0.3/SCALE),\n    vec3(0.44/SCALE, 0.45, 0.31/SCALE),\n    vec3(0.39/SCALE, 0.48, 0.28/SCALE),\n    vec3(0.35/SCALE, 0.52, 0.25/SCALE),\n    vec3(0.29/SCALE, 0.58, 0.23/SCALE),\n    vec3(0.21/SCALE, 0.5, 0.28/SCALE),\n    vec3(0.18/SCALE, 0.3, 0.30/SCALE),\n    vec3(0.14/SCALE, 0.2, 0.32/SCALE),\n    vec3(0.11/SCALE, 0.12, 0.36/SCALE),\n    vec3(0.08/SCALE, 0.22, 0.4/SCALE),\n    vec3(0.07/SCALE, 0.28, 0.46/SCALE)\n);\n\nvec3 CatmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n    return p1 + 0.5 * t * (-p0 + p2 + t * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3 + t * (-p0 + 3.0 * p1- 3.0 * p2 + p3)));\n}\n\nvec3 getCamPath(float t)\n{\n    t = mod(t, float(CAM_PATH_LENGTH));\n    \n    int i = int(floor(t));\n    float f = fract(t);\n        \n    int i0 = (i - 1 + CAM_PATH_LENGTH) % CAM_PATH_LENGTH;\n    int i2 = (i + 1) % CAM_PATH_LENGTH;\n    int i3 = (i + 2) % CAM_PATH_LENGTH;\n    \n    return CatmullRomSpline(CAM_PATH[i0], CAM_PATH[i], CAM_PATH[i2], CAM_PATH[i3], f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    \n    #if SSAA > 0\n    for (int x = 0; x <= SSAA; x++)\n    {\n        for (int y = 0; y <= SSAA; y++)\n        {\n    vec2 o = (vec2(x, y) + 0.5) / float(SSAA+1);\n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    #else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    #endif\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax, ay;\n    \n    #ifdef TURNTABLE_CAM\n    vec3 ro = vec3(0, 0, 0.6);\n    vec3 lo = vec3(1.6, 0.1, 2.3);\n    \n    #ifdef STATIC_CAM\n    ax = -0.15 * TAU + PI;\n    ay = -0.46 * TAU + PI;\n    #else\n    if (iMouse.z > 0.0)\n    {\n        ax = -m.x * TAU + PI;\n        ay = -m.y * PI + PI * 0.5;\n    } else\n    {\n        ax = -PI * .7 + iTime * .15;\n        ay = PI * 0.15;\n    }\n    #endif\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    #else\n    float ct = iTime * 0.4;\n    vec3 ro = getCamPath(ct);\n    vec3 lo = getCamPath(ct + 0.2);\n    if (iMouse.z > 0.0)\n    {\n        lo = vec3(0, 0, 1);\n        ax = -m.x * TAU + PI;\n        ay = -m.y * PI + PI * 0.5;\n        \n        lo.yz *= rot2D(-ay);\n        lo.xz *= rot2D(ax);\n        lo += ro; \n    }\n    #endif\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    const float invTanFov = 1.25;\n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n    \n    vec3 col = vec3(0);\n    \n    float pt = 0.0;\n    if (rd.y < 0.0 && ro.y > MAX_HEIGHT)\n    {\n        pt = -(ro.y - MAX_HEIGHT) / rd.y - EPS;\n    }\n    \n    HitInfo hit;\n    bool isHit = trace(ro, rd, hit, pt, MAX_DIST);\n    \n    float t = hit.t + pt;\n    \n    vec3 pos = ro + rd * t;\n    \n    const float sc = SCALE;\n    float s = 1.0 / (float(getLodSize(MIN_LOD)) * sc);\n    \n    vec3 p = (pos - hit.n * EPS) / s;\n    vec3 vid = floor(p);\n    \n    vec3 id = vec3(hit.id, 0).xzy;\n    id.y = floor((pos.y + rd.y * EPS) / MAX_HEIGHT * 1024.0 * SCALE) / (1024.0 * SCALE);\n    \n    vec3 alb = vec3(texture(iChannel0, cubeUVToPos(fract(hit.id * SCALE), 0)).rgb);\n    \n    float k = texture(iChannel1, id.xz * 0.02).r;\n    k = smoothstep(0.05, 0.2, k * k);\n    \n    alb = mix(vec3(0.95,0.4,0.25)*0.4, vec3(0.95, 0.4, 0.3), 1.0 - k);\n    //alb *= hash12(hit.id*3232.0)*0.2+0.8;\n    \n    vec3 gn = normalize(grad(id));\n    \n    float ky = id.y + (textureLod(iChannel3, id.xz * 0.0006, 0.0).r - 0.5) * 0.002;\n    float k1 = smoothstep(0.0,0.5,hash11(ky * 4.3+1.0));\n    float k2 = smoothstep(0.2,0.15,hash11(ky * 8.0+1.0));\n    alb *= k1 * vec3(0.7, 0.6, 0.5) + 0.35;\n    \n    alb = mix(alb, vec3(1, 0.7, 0.6), k2 * 0.8);\n    \n    vec3 tcol = (0.4+0.6*texture(iChannel1, id.xz * 0.4).rgb) * vec3(0.9, 0.55, 0.2);\n    float tk = smoothstep(0.6, 0.9, gn.y);\n    alb = mix(alb, alb * vec3(1, 0.6, 0.3), tk);\n    tk *= smoothstep(0.2, 0.0, id.y);\n    tk *= smoothstep(0.1, 0.2, texture(iChannel1, -id.xz * 0.02).r);\n    alb = mix(alb, tcol, tk);\n    \n    alb *= 1.0-texture(iChannel1, -id.xz * 0.3).rgb * 0.8;\n    \n    col = alb;\n    \n    vec4 data = SampleCubemapLodNearest(iChannel0, fract(hit.id * sc), vec2(1024), 0);\n    \n    if (data.a > 1.0 && (vid.y + 1.0) * s > (data.r - data.a * s) * MAX_HEIGHT)\n    {\n        col = (col*0.6+0.4)*vec3(0.4, 0.5, 0.15) + col * 0.1;\n        col *= hash13(vid) * 0.3 + 0.7;\n    }\n    \n    vec3 ldir = normalize(vec3(1, 1.2, 0.8));\n    vec3 lcol = vec3(1, 0.8, 0.6) * 2.5;\n    vec3 skyCol = vec3(0.6, 0.85, 1) + smoothstep(0.2, 0.0, abs(rd.y)) * vec3(0.35,0.4,0.5);\n    vec3 skyCol2 = vec3(0.35,0.62,0.9);\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + hit.n * 1e-6, ldir, hitL, 0.0, MAX_DIST);\n    \n    float sha = float(!isHitL);\n    \n    if (hitL.type == 1)\n        sha = sha * 0.8 + 0.2;\n    \n    float dif = max(dot(hit.n, ldir), 0.0) * sha;\n    float hao = smoothstep(0.0, MAX_HEIGHT * 0.3, pos.y);\n    \n    if (hit.type == 1)\n    {\n        col = mix(col, (col*0.6+0.4)*vec3(0.8, 0.9, 0.2), 0.3);\n        //dif += 0.2 * max(-dot(hit.n, ldir), 0.0) * sha;\n        dif = (max(dot(hit.n, ldir), 0.0) + 0.6*max(-dot(hit.n, ldir), 0.0)) * (sha * 0.4+0.6);\n    }\n    \n    col *= lcol * (dif * 0.7 + 0.3);\n    \n    float ao = 1.0;\n    if (hit.type == 0)\n    {\n        vec3 mask = abs(hit.n);\n        vec2 vuv = mod(vec2(dot(mask * p.yzx, vec3(1.0)), dot(mask * p.zxy, vec3(1.0))), vec2(1.0));\n\n        vec4 vao = voxelAo(vid + hit.n, mask.zxy, mask.yzx);\n        ao = mix(mix(vao.z, vao.w, vuv.x), mix(vao.y, vao.x, vuv.x), vuv.y);\n\n        col *= dot(abs(hit.n), vec3(0.9, 1, 0.95));\n    \n        col *= ao * 0.6 + 0.4;\n    }\n    \n    col += skyCol * 0.1;\n    \n    if (hit.type == 1)\n    {\n        //col += alb * lcol * (dot(hit.n, ldir)*0.5+0.5) * 0.2;\n    }\n    \n    col *= hao * 0.4 + 0.6;\n    \n    float cost = dot(rd, ldir);\n    //float fog = 1.0 - exp(-t*t * 0.001);\n    float fog = 1.0 - exp(-t * 0.04);\n    float hg = mix(henyeyGreenstein(cost, 0.65), henyeyGreenstein(cost, -0.3), 0.45);\n    \n    vec3 fogCol = skyCol * hg;\n    col = mix(col, fogCol, fog);\n    \n    vec3 ref = reflect(rd, hit.n);\n    \n    HitInfo hitR;\n    bool isHitR = trace(pos + hit.n * EPS, ref, hitR, 0.0, MAX_DIST);\n    \n    #ifdef SHOW_NORMALS\n    col = hit.n;\n    #endif\n    \n    if (!isHit)\n    {\n        col = mix(skyCol, skyCol2, smoothstep(0.0, 0.4, rd.y));\n        \n        #define SUN_ANGLE_DEGREES 0.52\n        const float sunAngle = SUN_ANGLE_DEGREES * PI / 180.0;\n        const float sunCost = cos(sunAngle);\n\n        float cost = max(dot(rd, ldir), 0.0);\n        float dist = cost - sunCost;\n\n        float bloom = max(1.0 / (0.02 - min(dist, 0.0)*400.0), 0.0) * 0.08;\n\n        vec3 sun = 20.0 * lcol * (smoothstep(0.0, 0.0001, dist) + bloom);\n        \n        col += sun;\n        \n        vec2 clsph = sphereIntersection(vec3(0, 0.46, 0), rd, 0.5);\n        \n        vec3 clpos = rd * clsph.y;\n        vec2 cluv = (clpos.xz + iTime * 0.0015) * 0.3;\n        cluv += (texture(iChannel3, cluv * 10.0 + iTime * 0.003).rg - 0.5) * 0.0004;\n        float cld = getClouds(cluv, 0.35, 0.6);\n        float clsh = getClouds(cluv + (ldir.xz - rd.xz) * 0.0008, 0.35, 0.65);\n        \n        vec3 ccol = (max(cld - clsh, 0.0) * lcol * 0.6 + skyCol * 0.5 + 0.35) * hg ;\n        \n        col = mix(col, ccol, (1.0 - exp(-cld)) * smoothstep(0.0, 0.02, rd.y));\n        \n        vec3 fp = (rd - ldir) * cmat;\n        vec3 cldir = ldir * cmat;\n        vec2 cuv = cldir.xy / cldir.z * invTanFov;\n        vec2 fuv = pv - cuv;\n        float fd = length(fuv * vec2(30, 1));\n        fd = min(fd, length(rot2D(PI/3.0) * fuv * vec2(30, 1)));\n        fd = min(fd, length(rot2D(-PI/3.0) * fuv * vec2(30, 1)));\n        \n        vec3 flare = 0.2 * lcol * smoothstep(1.0, 0.0, fd);//max(1.0 / max(fd, 0.00), 0.0) * 0.05;\n        \n        col += flare;\n    }\n    \n    #ifdef SHOW_STEPS\n    col = turbo(float(hit.i) / float(STEPS));\n    \n    if (fragCoord.y < 10.0)\n        col = turbo(uv.x);\n    #endif\n    \n    //vec2 luv = fragCoord / iResolution.y;\n    //int lod = (iFrame/20)%(1+MAX_LOD);\n    //col = luv.x > 1.0 ? vec3(0) : vec3(SampleCubemapLodNearest(iChannel0, luv, vec2(1024), lod).r);\n    \n    //col = texture(iChannel0, cubeUVToPos(fragCoord / iResolution.y, 1)).rgb;\n    \n    col = max(col, vec3(0));\n    \n    #if SSAA > 0\n        tot += col;\n        }\n    }\n    tot /= float((SSAA+1)*(SSAA+1));\n    #else\n    tot = col;\n    #endif\n    \n    //tot = tot / (1.0 + tot);\n    //tot = ReinhardExtLuma(tot, 5.0);\n    tot = ACESFilm(tot * 0.35);\n    \n    fragColor = vec4(linearTosRGB(tot), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define SSAA 0\n\n//#define TURNTABLE_CAM\n//#define STATIC_CAM\n//#define SHOW_STEPS\n//#define SHOW_NORMALS\n\n//#define SCALE 0.125\n#define SCALE 0.1\n//#define SCALE 0.0625\n\n#define MIN_LOD 0\n#define MAX_LOD 8\n\n#define MAX_HEIGHT 1.0\n\n#define STEPS 256\n#define MAX_DIST 200.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n\nfloat henyeyGreenstein(float cosTheta, float g)\n{\n    //const float k = 1.0 / (4.0 * PI);\n    float g2 = g * g;\n    \n    return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * cosTheta, 3.0 / 2.0);\n}\n\n// Ray-sphere intersesction\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereIntersection(vec3 ro, vec3 rd, float ra )\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    if (b > 0.0 && c > 0.0)\n        return vec2(MAX_DIST);\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Cubemap helper functions\n// https://en.wikipedia.org/wiki/Cube_mapping#Memory_addressing\n\n// Cubemap ID as per OpenGL indices\nint cubeID(vec3 normal)\n{\n    return int(dot(max(-normal, vec3(0)), vec3(1)) + dot(abs(normal), vec3(0, 2, 4)));\n}\n\nvec2 cubeNearest(vec2 uv, float res)\n{\n    return (floor(uv * res) + 0.5) / res;\n}\n\n// OpenGL face orientation from\n// https://www.khronos.org/opengl/wiki/Cubemap_Texture\nvec2 cubePosToUV(vec3 pos, vec3 normal)\n{\n    pos = pos + 0.5;\n\n    vec3 mask = abs(normal);\n    vec2 uv = mask.x > 0. ? vec2(-pos.z * normal.x, -pos.y) :\n              mask.y > 0. ? vec2( pos.x,  pos.z * normal.y) :\n                            vec2( pos.x * normal.z, -pos.y);\n    \n    uv = fract(uv);\n   \n    return uv;\n}\n\nvec2 cubePosToUV(vec3 pos, int id)\n{   \n    pos = pos + 0.5;\n\n    vec2 uv;\n    switch(id)\n    {\n        case 0:\n            uv = vec2(-pos.z, -pos.y); break;\n        case 1:\n            uv = vec2( pos.z, -pos.y); break;\n        case 2:\n            uv = vec2( pos.x,  pos.z); break;\n        case 3:\n            uv = vec2( pos.x, -pos.z); break;\n        case 4:\n            uv = vec2( pos.x, -pos.y); break;\n        case 5:\n            uv = vec2(-pos.x, -pos.y); break;\n    }\n    \n    uv = fract(uv);\n\n    return uv;\n}\n\n// Based on Shane's cubemap texture function\n// Geometric Cellular Surfaces - Shane\n// https://www.shadertoy.com/view/Wt33zH\n\n// Modified to match OpenGL face orientation\n// https://www.khronos.org/opengl/wiki/Cubemap_Texture\nvec3 cubeUVToPos(vec2 uv, int id)\n{\n    uv = fract(uv) - .5;\n    \n    \n    switch(id)\n    {\n        case 0:\n            return vec3(0.5, -uv.yx);\n        case 1:\n            return vec3(-0.5, -uv.y, uv.x);\n        case 2:\n            return vec3(uv.x, 0.5, uv.y);\n        case 3:\n            return vec3(uv.x, -0.5, -uv.y);\n        case 4:\n            return vec3(uv.x, -uv.y, 0.5);\n        case 5:\n            return vec3(-uv, -0.5);\n    }\n    \n    return vec3(0);\n}\n\nvec3 cubeIntersect(vec3 rayDir, out vec3 normal)\n{\n    vec3 sideDist = abs(0.5 / rayDir);\n    \n    float t = min(sideDist.x, min(sideDist.y, sideDist.z));\n    vec3 mask = step(sideDist, sideDist.yzx) * step(sideDist, sideDist.zxy);\n    \n    normal = mask * sign(rayDir);\n    \n    return rayDir * t;\n}\n\nconst int[] LOD_TEX_START = int[](0, 512, 768, 896, 960, 992, 1008, 1016, 1020, 1022);\nconst int[] LOD_TEX_END = int[](512, 768, 896, 960, 992, 1008, 1016, 1020, 1022, 1023);\n\nint getLodSize(int lod)\n{\n    return 1024>>lod;\n}\n\nvec4 SampleCubemapLod(samplerCube tex, vec2 uv, vec2 res, int lod)\n{\n    if (lod <= 0)\n    {\n        return texture(tex, cubeUVToPos(uv, 0));\n    }\n    \n    vec2 size = vec2(getLodSize(lod));\n    vec2 offset = vec2(LOD_TEX_START[lod-1], 0);\n    \n    return texture(tex, cubeUVToPos((uv * size + offset) / res, 1));\n}\n\nvec4 SampleCubemapLodNearest(samplerCube tex, vec2 uv, vec2 res, int lod)\n{\n    if (lod <= 0)\n    {\n        uv = (floor(uv * res) + 0.5) / res;\n        return texture(tex, cubeUVToPos(uv, 0));\n    }\n    \n    vec2 size = vec2(getLodSize(lod));\n    vec2 offset = vec2(LOD_TEX_START[lod-1], 0);\n    \n    uv = floor(uv * size) + 0.5;\n    return texture(tex, cubeUVToPos((uv + offset) / res, 1));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// matplotlib colormaps + turbo - mattz\n// https://www.shadertoy.com/view/3lBXR3\nvec3 turbo(float t) {\n\n    const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n    const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n    const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n    const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n    const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n    const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n    const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    // Doesn't do anything on my maching T_T\n    #if 0\n    if (iFrame > MAX_LOD)\n    {\n        fragColor = texture(iChannel0, rayDir);\n        return;\n    }\n    #endif\n    \n    vec3 n;\n    vec3 pos = cubeIntersect(rayDir, n);\n    int id = cubeID(n);\n    \n    if (id == 0)\n    {\n        fragColor = vec4(0);\n        \n        vec2 fl = floor(fragCoord / 4.0);\n        \n        vec3 tex = sRGBToLinear(texture(iChannel1, uv).rgb);\n        \n        float h = luminance(tex);\n        float ha = h;\n        h = floor(h * 1024.0 * SCALE);\n        \n        if (hash12(fragCoord) < 0.08 * smoothstep(0.25, 0.0, ha))\n        {\n            fragColor.a = 1.0;\n            h++;\n        } else if (hash12(-fragCoord.yx) < 0.0035 * smoothstep(0.1, 0.0, ha))\n        {\n            fragColor.a = floor(hash12(fragCoord.yx) * 4.0) + 2.0;\n            h += fragColor.a;\n        }\n        \n        h /= (1024.0 * SCALE);\n        \n        fragColor.r = saturate(h);\n        \n    } else if (id == 1)\n    {\n        fragColor = vec4(0);\n        \n        vec4 prev = textureLod(iChannel0, cubeUVToPos(uv, 0), 1.0);\n        vec2 hres = floor(iResolution.xy / 2.0);\n        \n        int lod = 0;\n        for(; lod <= MAX_LOD; lod++)\n        {\n            if (fragCoord.x < float(LOD_TEX_END[lod]))\n                break;\n        }\n        lod += 1;\n        \n        vec2 res = vec2(getLodSize(lod));\n        float xpos = float(LOD_TEX_START[lod-1]);\n        \n        if (lod > MAX_LOD || fragCoord.y >= res.y)\n        {\n            fragColor = vec4(0);\n            return;\n        }\n\n        vec2 p = (fragCoord - vec2(xpos, 0)) / iResolution.xy;\n        vec2 uv = (fragCoord - vec2(xpos, 0)) / vec2(res);\n        \n        vec2 res2 = vec2(getLodSize(lod-1));\n        vec2 px2 = 1.0 / res2;\n        vec2 uv2 = ((uv * res2) + 0.5) / res2;\n        \n        vec4 tex00 = SampleCubemapLodNearest(iChannel0, uv2, iResolution.xy, lod-1);\n        vec4 tex10 = SampleCubemapLodNearest(iChannel0, uv2 - vec2(px2.x, 0), iResolution.xy, lod-1);\n        vec4 tex01 = SampleCubemapLodNearest(iChannel0, uv2 - vec2(0, px2.y), iResolution.xy, lod-1);\n        vec4 tex11 = SampleCubemapLodNearest(iChannel0, uv2 - px2, iResolution.xy, lod-1);\n        \n        fragColor.r = max(max(tex00.x, tex10.x), max(tex01.x, tex11.x));\n        \n    } else\n    {\n        fragColor = vec4(0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}