{
    "Shader": {
        "info": {
            "date": "1466518469",
            "description": "Applying a Mobius-Spiral-Zoom combination to a raytraced sphere.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldVXDG",
            "likes": 19,
            "name": "Mobius Eggs",
            "published": 3,
            "tags": [
                "zoom",
                "spiral",
                "sphere",
                "raytrace",
                "mobius",
                "transform"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1730
        },
        "renderpass": [
            {
                "code": "/*\n\n    Mobius Eggs\n\t-----------\n\n\tPretty standard Mobius transform, followed by a spiral zoom. I've always liked \n\tthis particular combination, and so do plenty of others, since it's used to\n\tproduce a lot of the interesting geometric pictures you see all over the net.\n\n\tThis particular example is based off of a couple of snippets I came across in \n\tFlexi and Dila's code... I think. I can't quite remember where it came from.\n\tThe rest is just some raytraced, lit spheres. Pretty boring on their own, but \n\tmade to look more interesting when transformed.\n\n\tAnyway, the purpose of this was just to show the process. It's possible to make \n\tfar more interesting things.\t\n\n\t// Much simpler, easy to decipher example:\n\tLogarithmic Mobius Transform - Shane\n\thttps://www.shadertoy.com/view/4dcSWs\n\n\tOther examples:\n\n\tbipolar complex - Flexi\n\thttps://www.shadertoy.com/view/4ss3DB\n\n\tMobius - dila\n\thttps://www.shadertoy.com/view/MsSSRV\n\n\tMoebius Strip - dr2\n\thttps://www.shadertoy.com/view/lddSW2\n\n*/\n\n// 2x2 hash algorithm. Used to add some light sprinkles to the background.\nvec2 hash22(vec2 p) { \n\n    // More concise, but wouldn't disperse things as nicely as other versions.\n    float n = sin(dot(p, vec2(41, 289))); \n    return fract(vec2(8, 1)*262144.*n);\n\n}\n\n// Intersection of a sphere of radius one.\nfloat trace( in vec3 ro, in vec3 rd ){\n\t\n\tfloat b = dot(ro, rd);\n\tfloat h = b*b - dot(ro, ro) + 1.;\n\tif (h<0.) return -1.;\n\treturn -b - sqrt(h);\n\t\n}\n\n// For all intents and purposes, this is just a grid full of raytraced spheres.\n// They look like eggs due to the transform warping. All of it is standard, and\n// most is just window dressing, like patterns, lighting, etc.\nvec3 scene(vec2 uv){\n\n    // Grid cell ID. Used to color the spheres. In this case, white or red.\n    vec2 id = mod(floor(uv), 5./2.);\n    \n    // Partition space (the 2D canvas) into squares.\n    uv = fract(uv) - .5;\n\n\t\n    // Draw a lit, raytraced sphere in each grid cell. From here it's just boring\n    // intersection and lighting stuff.\n    \n    \n\t// Ray origin, unit ray and light.\n\tvec3 ro = vec3(0, 0, -2.4);\n\tvec3 rd = normalize( vec3(uv, 1.));\n    vec3 lp = ro + vec3(cos(iTime), sin(iTime), 0)*4.;\n\t\n\t// Sphere intersection.\n\tfloat t = trace( ro, rd );\n    \n\t\n\t// Dark background.\n\tvec3 col = vec3(1, .04, .1)*0.003 + length(hash22(uv + 7.31))*.005;\n    \n\tif (t>0.){\n\t\n        \n        // Surface point.\n    \tvec3 p = ro + rd*t;\n    \t\n        // Normal.\n    \tvec3 n = normalize(p);\n        \n        // Point light.\n        vec3 ld = lp - p;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist;\n        \n        float diff = max(dot(ld, n), 0.); // Diffuse.\n        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.); // Specular.\n        \n        // Adding a sinusoidal pattern.\n        float c = dot(sin(p*8. - cos(p.zxy*8. + 3.14159 + iTime)), vec3(.166)) + .5;\n        float f = c*6.;\n        c = clamp(sin(c*3.14159*6.)*2., 0., 1.);\n        c = sqrt(c*.75+.25);\n        vec3 oCol = vec3(c); // Coloring the object white.\n        \n        // Coloring the object red, based on ID.\n        if(id.x>1.25) oCol *= vec3(1, .04, .1);\n        \n\t\n        // Adding some fake environment mapping. Not that great, but it gives\n        // a slight reflective sheen.\n        p = reflect(rd, n)*.35;\n        c = dot(sin(p*8. - cos(p.zxy*8. + 3.14159)), vec3(.166)) + .5;\n        f = c*6.;\n        c = clamp(sin(c*3.14159*6.)*2., 0., 1.);\n        c = sqrt(c*.75+.25);\n        vec3 rCol = vec3(min(c*1.5, 1.), pow(c, 3.), pow(c, 16.)); // Reflective color.\n        \n        // Producing the final lit color.\n        vec3 sCol = oCol*(diff*diff + .5) + vec3(.5, .7, 1)*spec*2. + rCol*.05;\n       \n        // Applying attenuation.\n        sCol *= 1.5/(1. + lDist*.25 + lDist*lDist*.05);\n\n        // Simple trick to antialias the edges of a raytraced sphere.\n        float edge = max(dot(-rd, n), 0.);\n    \tedge = smoothstep(0., .35, edge); // Hardcoding. A bit lazy.\n        // Taper between the sphere edge and the background.\n        col = mix(col, min(sCol, 1.), edge); \n        \n\t}\n    \n\n\t\n    // Clamp and perform some rough gamma correction.\n\treturn sqrt(clamp(col, 0., 1.));\n}\n\n\n// Standard Mobius transform: f(z) = (az + b)/(cz + d). Slightly obfuscated.\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2){\n\n\tz1 = p - z1; p -= z2;\n\treturn vec2(dot(z1, p), z1.y*p.x - z1.x*p.y)/dot(p, p);\n}\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 + iTime*.125*.25;\n\tfloat d = length(p);\n\treturn vec2(a*n + log(d)*spiral, -log(d)*zoom + a) + phase;\n}\n\n/*\n// Antialiased circle. The coordinates are mutated, so \"fwidth\" is used for\n// concise, gradient-related, edge smoothing.\nfloat circle(vec2 p) {\n    \n    p = fract(p) - .5;\n    float d = length( p ); return smoothstep(0., fwidth(.4-d)*1.25, .4-d);\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n\n    // Transform the screen coordinates.\n    uv = Mobius(uv, vec2(-.75, 0), vec2(.5, 0));\n    uv = spiralZoom(uv, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.125);\n    \n    // Pass the transformed coordinates into the scene equation. Uncomment either, or both,\n    // or the lines above to see a less transformed version.\n    \n    // Draw some repeat lit spheres with the transformed coordinates. Just the one sphere \n    // is rendered, but it's repeated across a 2D grid using the \"fract(uv)\" trick.\n    vec3 col = scene(uv*5.);\n    \n    // Much, much simpler version with plane circles. One could argue that it \n    // looks better too. :)\n    //vec3 col = vec3(circle(uv*4.));\n    \n    // An interesting alternative. Worth looking at. Requires a wrappable texture\n    // to be loaded into channel zero.\n    //vec3 col = texture(iChannel0, uv).xyz; // Texture, if desired.\n    \n    // Apply a vignette and increase the brightness for that fake spotlight effect.\n    uv = fragCoord/iResolution.xy;\n    col *= pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*1.15;\n\n    \n    fragColor = vec4(min(col, 1.), 1);\n    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}