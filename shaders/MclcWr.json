{
    "Shader": {
        "info": {
            "date": "1721036224",
            "description": "im not God=)  originals https://www.shadertoy.com/view/lclyWr https://www.shadertoy.com/view/tsVBWK",
            "flags": 0,
            "hasliked": 0,
            "id": "MclcWr",
            "likes": 2,
            "name": "particles color",
            "published": 3,
            "tags": [
                "particlesrotate"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "#define particles 500.\nvec3 c1 = vec3(0.,0.3,1.);\nvec3 c2 = vec3(1.,0.5,.3);\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nvec3 noise(float n) {\n\tvec3 t = texture(iChannel0,vec2(floor(n)/particles)).xyz;\n    vec3 u = texture(iChannel0,vec2(ceil(n)/particles)).xyz;\n    return mix(t,u,fract(n));\n}\nvec3 palette(float t) \n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    \n    return a + b*cos( 6.28318*(c*t*d) );\n}\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec4 fire(vec2 p)\n\t{\n    p-=vec2(.5);     \n\tp.x /= 1.75;\n\t\n\tfloat color = 3.0 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 2; i++)\n\t\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-time*.05, time*.01), power*16.);\n\t\t}\n\treturn vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n\t}\n\n\nconst vec2 ch_size  = vec2(0.9, 2.0);              \t// character size\nconst vec2 ch_space = ch_size + vec2(0.7, 1.0);    \t// character distance  \nconst vec2 ch_start = vec2 (-8.8, 3.0); \t\t\t// start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             \t// character position\nfloat d = 1e6;\n\n/* 16 segment display...\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n\n#define A_ ch_pos.x-=0.5;ddigit(0x4381,uv);ch_pos.x+=0.1;\n#define B_ ch_pos.x-=0.5;ddigit(0xC442,uv);\n#define V_ ch_pos.x-=0.5;ddigit(0xC642,uv);\n#define G_ ch_pos.x-=0.5;ddigit(0x4402,uv);\n#define D_ ch_pos.x-=0.5;ddigit(0x42C1,uv);ch_pos.x+=0.1;\n//#define E_ ch_pos.x-=0.5;ddigit(0x4542,uv);\n#define E_ ch_pos.x-=0.5;ddigit(0x8300,uv);\n#define EY_ ch_pos.x-=0.5;ddigit(0x8300,uv);ch_pos+=vec2(.5-ch_space.x,2.5);ddigit(0x0,uv); ch_pos.x+=.5-ch_space.x; ddigit(0x0,uv); ch_pos-=vec2(1.,2.5);\n//ch_pos+=vec2(1.-ch_space.x,0.);ddigit(0,uv);ch_pos-=vec2(1.,1.);\n\n#define J_ ddigit(0xEE00,uv);\n#define Z_ ch_pos.x-=0.5;ddigit(0x8242,uv);\n#define I_ ddigit(0x6418,uv);ch_pos.x-=0.4;ch_pos.x+=0.1;\n#define IY_ ddigit(0x6418,uv);ch_pos+=vec2(-ch_space.x,.5);ddigit(0x4,uv);ch_pos-=vec2(.5,.5);ch_pos.x+=0.1;\n#define K_ ch_pos.x-=0.5;ddigit(0xc600,uv);\n#define L_ ch_pos.x-=0.5;ddigit(0x4281,uv);ch_pos.x+=0.1;\n#define M_ ddigit(0x0A99,uv);ch_pos.x+=0.1;\n#define N_ ch_pos.x-=0.5;ddigit(0x4581,uv);ch_pos.x+=0.1;\n#define O_ ch_pos.x-=0.5;ddigit(0x44c3,uv);ch_pos.x+=0.1;\n#define P_ ch_pos.x-=0.5;ddigit(0x4483,uv);ch_pos.x+=0.1;\n#define R_ ch_pos.x-=0.5;ddigit(0x4602,uv);\n//#define S_ ch_pos.x-=0.5;ddigit(0x4442,uv);\n#define S_ ch_pos.x-=0.5;ddigit(0x8200,uv);\n\n#define T_ ddigit(0x4406, uv /* * vec2(1.2, 1.)-vec2(.5,0.)*/ );//ch_pos.x-=0.3;\n\n#define U_ ddigit(0x3408,uv);ch_pos.x-=0.4;\n#define F_ ddigit(0x550F,uv);\n#define H_ ddigit(0xAA00,uv);\n//#define C_ ddigit(0x4478,uv);\n#define C_ ddigit(0x4478,uv);ch_pos+=vec2(.5-ch_space.x,-1.);ddigit(0x2000,uv);ch_pos-=vec2(.5,-1.);\n#define CH_ ddigit(0x5408,uv);ch_pos.x-=0.4;\n#define SH_ ddigit(0x44F9,uv);ch_pos.x+=0.1;\n//#define SHCH_ ddigit(0x1589,uv);\n#define SHCH_ ddigit(0x44F9,uv);ch_pos+=vec2(1.-ch_space.x,-1.);ddigit(0x3000,uv);ch_pos-=vec2(.5,-1.);\n\n#define mz_ ch_pos.x-=0.5;ddigit(0xC440,uv);\n#define YI_ ddigit(0x50B9,uv);ch_pos.x+=0.1;\n#define tz_ ddigit(0xC44C,uv);\n//#define YE_ ddigit(0x5424,uv);\n#define YE_ ddigit(0x3800,uv);ch_pos.x-=0.4;\n\n#define YU_ ddigit(0x54DB,uv);ch_pos.x+=0.1;\n#define YA_ ddigit(0x740C,uv);ch_pos.x-=0.4;\n\n\n#define n0 ddigit(0x22FF,uv);\n#define n1 ddigit(0x0281,uv);\n#define n2 ddigit(0x1177,uv);\n#define n3 ddigit(0x11E7,uv);\n#define n4 ddigit(0x5508,uv);\n#define n5 ddigit(0x11EE,uv);\n#define n6 ddigit(0x11FE,uv);\n#define n7 ddigit(0x2206,uv);\n#define n8 ddigit(0x11FF,uv);\n#define n9 ddigit(0x11EF,uv);\n\n#define A ddigit(0x119F,uv);\n#define B ddigit(0x927E,uv);\n#define C ddigit(0x007E,uv);\n#define D ddigit(0x44E7,uv);\n#define E ddigit(0x107E,uv);\n#define F ddigit(0x101E,uv);\n#define G ddigit(0x807E,uv);\n#define H ddigit(0x1199,uv);\n#define I ddigit(0x4466,uv);\n#define J ddigit(0x4436,uv);\n#define K ddigit(0x9218,uv);\n#define L ddigit(0x0078,uv);\n#define M ddigit(0x0A99,uv);\n#define N ddigit(0x8899,uv);\n#define O ddigit(0x00FF,uv);\n#define P ddigit(0x111F,uv);\n#define Q ddigit(0x80FF,uv);\n#define R ddigit(0x911F,uv);\n#define S ddigit(0x8866,uv);\n#define T ddigit(0x4406,uv);\n#define U ddigit(0x00F9,uv);\n#define V ddigit(0x2218,uv);\n#define W ddigit(0xA099,uv);\n#define X ddigit(0xAA00,uv);\n#define Y ddigit(0x4A00,uv);\n#define Z ddigit(0x2266,uv);\n#define _ ch_pos.x += ch_space.x / 1.5;\n\n#define s_dot     ddigit(0,uv);ch_pos.x -= ch_space.x/2.;\n\n#define s_minus   ddigit(0x1100,uv);\n#define s_plus    ddigit(0x5500,uv);\n#define s_greater ddigit(0x2800,uv);\n#define s_less    ddigit(0x8200,uv);\n#define s_sqrt    ddigit(0x0C02,uv);\n#define s_exc ch_pos.y+=0.5; ddigit(0x18,uv);ch_pos+=vec2(-ch_space.x,-0.5);ddigit(0,uv);ch_pos.x-=1.;\n#define s_que ch_pos.y+=0.5; ddigit(0x1414,uv);ch_pos+=vec2(-ch_space.x,-0.5);ddigit(0,uv);ch_pos.x-=.4;\n\n#define s_sobaka ddigit(0x50F7,uv);\n\nfloat dseg(vec2 p0, vec2 p1, vec2 uv)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\n\n#define saturate(x) clamp(x,0.,1.)\n#define rgb(r,g,b) (vec3(r,g,b)/255.)\n\nfloat rand(float x) { return fract(sin(x) * 71.); }\n\nfloat rand(vec2 x) { return rand(dot(x, vec2(13., 15.))); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    f *= f*(3.-2.*f);\n    return mix(mix(rand(i), rand(i+vec2(1,0)), f.x),\n               mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0, s = 1.0, w = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n{\n    return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*(iTime+47.)))-(1.0-density)), 1.0-sharpness);\n}\n\nvec3 render(vec2 uv)\n{\n\n    vec3 color = mix(rgb(255,212,166), rgb(204,235,255), uv.y);\n\n    // clouds\n    vec3 cl1 = mix(rgb(151,138,153), rgb(166,191,224),uv.y);\n    float d1 = mix(0.9,0.1,pow(uv.y, 0.7));\n    color = mix(color, cl1, cloud(uv,2.,8.,d1,0.4,0.04));\n    color = mix(color, vec3(0.9), 8.*cloud(uv,1.,1.,0.9,2.0,0.02) * cloud(uv,2.,5.,0.6,0.15,0.01)*uv.y);\n    color = mix(color, vec3(0.8), 5.*cloud(uv,12.,15.,0.9,0.0,0.03) * cloud(uv,2.,8.,0.5,0.0,0.02)*uv.y);\n    return color;\n}\nvoid ddigit(int n, vec2 uv)\n{\n\tfloat v = 1e6;\t\n\tvec2 cp = uv - ch_pos;\n\tif (n == 0)     v = min(v, dseg(vec2(-0.505, -1.000), vec2(-0.500, -1.000+sin(iTime)), uv));\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500+sin(iTime),  0.063), vec2( 0.500+sin(iTime),  0.937), uv));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000), uv));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063+cos(iTime),  1.000), vec2(-0.438+sin(iTime),  1.000), uv));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500+cos(iTime),  0.937), vec2(-0.500+cos(iTime),  0.062), uv));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500+sin(iTime), -0.063), vec2(-0.500+sin(iTime), -0.938), uv));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063+sin(iTime), -1.000), uv));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063+sin(iTime), -1.000+cos(iTime)), vec2( 0.438, -1.000), uv));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063), uv));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063+sin(iTime),  0.000), vec2( 0.438, -0.000), uv));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438+sin(iTime),  0.938+cos(iTime)), uv));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063+cos(iTime)), vec2( 0.000,  0.937), uv));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063+sin(iTime)), vec2(-0.438+sin(iTime),  0.938), uv));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438+sin(iTime),  0.000), vec2(-0.063, -0.000), uv));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063+sin(iTime), -0.063+cos(iTime)), vec2(-0.438, -0.938+sin(iTime)), uv));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938+cos(iTime)), vec2( 0.000, -0.063+cos(iTime)), uv));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938), uv));\n\tch_pos.x += ch_space.x+0.1*cos(iTime);\n\td = min(d, v);\n}\n\nvec3 render_points(vec2 uv) {\n    uv*=0.0308;\n    vec3 c=vec3(0.);\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n   uv.xy*=ma;\n   \n\tfor (float i=0.; i<particles; i++) {\n\t\tvec3 point=noise(i+floor(iTime/10.)*.1)-.5;\n          vec3 col2 = palette(length(uv) + i*.5 + iTime*.4);\n        float a=5.*smoothstep(0.,7.,1.);\n         \n        point.xz*=rot(iMouse.y*0.001);\n        point.yz*=rot(iMouse.x*0.001);\n\t\tpoint=pow(abs(point),vec3(1.3))*sign(point);\n        \n        float e=pow((dot(point,point)*.05+iTime*100.,.1)/.1,00.5);\n        point.xy/=max(1.,1.5+point.z);\n        point.x*=2.5;\n\t\tfloat l=max(0.,.1-distance(uv,point.xy))/.1;\n        vec3 col=mix(c1,c2,e)*col2*e;\n        c+=pow(l,20.)*col*2.;\n\t\tc+=pow(l,40.)*col*5.;\n       \n\t}\n\treturn c;\n}\n#define time iTime\n#define resolution iResolution.xy\n\nvoid mainImage( out vec4 o, vec2 fragCoord )\n{\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec3 feedback = texture(iChannel1,uv).rgb;\n    uv-=.5;\n    uv*=20.;\n\tvec2 position = (gl_FragCoord.xy/resolution.xy) -0.5;\n\t\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2.x -= 0.5;\n    uv2.x *= iResolution.x / iResolution.y;\n\tfloat y = 0.2 * position.y * sin(200.0*position.y - 20.0*time*0.35);\n\to = vec4(y *5., y, y* 5., 1.0);\n\ty = 1.0 / (600. * abs(position.y - y));\n\ty += 1./(665.*length(position - vec2(0., position.y)));\n\tfloat saule = 1./(65.*length(position - vec2(0, 0)));\n\t\n\tch_pos = ch_start;\n\tch_pos.x += 2.0; \n\tch_pos.y += 5.0;\n\t_ _  YA_ _ B_ O_ G_ _ _ \n\n    float v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n    \tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\tuv.x*=iResolution.x/iResolution.y;\n    \n\tvec3 color = mix(vec3(1.), vec3(0.), smoothstep(0.0, 0.0, d) - (0.10 / d));\n    vec3 c=render_points(uv);\n    \n    o=vec4(c+col+color,1.);\n  \n   \to*= vec4(render(uv2),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}