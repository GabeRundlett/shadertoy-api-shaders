{
    "Shader": {
        "info": {
            "date": "1691401379",
            "description": "Flight near a cliff (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "dtSczz",
            "likes": 17,
            "name": "Cliff Edge",
            "published": 3,
            "tags": [
                "truchet",
                "flight",
                "helicopter"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "// \"Cliff Edge\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Notes on methodology: Grid-based raymarching is used in this shader. If the\n  world-space containing multiple distinct objects can be partitioned by a grid,\n  so that objects do not overlap cell boundaries, then distance computations need\n  only consider objects contained in the marched ray's current cell. When a ray\n  reaches a cell boundary, the contents of the next cell are determined, and\n  details of its boundaries computed. Partitioning may be 1d/2d/3d, with square or\n  hexagonal 2d cells, and optional partitioning in the remaining direction.\n  Multiple independent grids can be used. Significant performance improvements are\n  achievable and potential aliasing artifacts avoided. Adaptations for objects\n  that overlap cell boundaries, as well as other specialized partitioning, are\n  possible.\n\n  This shader uses two separate hexagonal grids for the raymarching: the Truchet\n  tiling, on which the coastline is based, uses a bigger grid; the trees use a\n  smaller grid, with random displacements partly obscuring the grid layout.\n  There is also a regular raymarching loop for the flyer (with bounding box).\n\n  Earlier shaders using various realizations of these techniques (all 132 of\n  them) are listed at the end. (Reminder: raymarching and raytracing are entirely\n  different methods.)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Ssign (float x);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n\nmat3 flyerMat;\nvec4 cPath[PLEN];\nvec3 qHit, flyerPos, sunDir, tOff;\nvec2 cIdB, cIdS, cMidB, cMidS, csRotor;\nfloat dstFar, tCur, hgSizeB, hgSizeS, tEnd[PLEN + 1], tLen, trVel, cDir, cType, baseWd,\n   baseHt, csOcc;\nint nFrame, idObj;\nbool withTrees, isSh;\nconst int idGrnd = 1, idTrnk = 2, idLvs = 3, idHeli = 13, idRotorM = 14, idRotorT = 15, idSkd = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Truchet's Train\")\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nbool SideTrk (vec2 w, float sd)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, side;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  if (cyo) side = (cxy == 0. && wp.x > 0. || cxy == 1. && (wp.y < 0. && sd > 0. || w.x < -0.5) ||\n     cxy == 2. && (wm.y > 0. && wp.y > 0. || w.x > 0.) || cxy == 3. || cxy == 4. && wm.x < 0. ||\n     cxy == 5. && (wp.x > 0. || wm.y < 0.));\n  else side = (cxy == 1. && (wp.x > 0. || wp.y > 0. || sd > 0.) ||\n     cxy == 2. && (wp.y < 0. || sd > 0.) || cxy == 3. && (wp.y > 0. && sd > 0. || w.x > 0.5) ||\n     cxy == 4. || cxy == 5.);\n  side = side || (cxy >= 6.);\n  return side;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nfloat FlyerDf (vec3 p)\n{  // (from \"Piz Gloria With Helicopter\")\n  vec3 q;\n  float dMin, d, r, s, flyerSz;\n  flyerSz = 0.12;\n  dMin = dstFar / flyerSz;\n  p = flyerMat * (p - flyerPos) / flyerSz;\n  if (! isSh) d = PrRoundBoxDf (p - vec3 (0., 0.5, -1.2), vec3 (4.5, 2., 5.5), 0.1);\n  if (isSh || d < 0.1) {\n    q = p;\n    r = 1.;\n    if (q.z < -0.1) {\n      s = (q.z + 0.1) * (q.z + 0.1);\n      r *= 1. - 0.1 * s;\n      q.y -= 0.05 * s;\n    } else if (q.z > 0.1) {\n      s = (q.z - 0.1) * (q.z - 0.1);\n      r *= 1. - 0.03 * s;\n    }\n    q.x *= 0.8;\n    d = PrCapsDf (q, max (r, 0.), 2.);\n    q = p;\n    q.yz = Rot2D (q.yz - vec2 (1.1, -4.2), -0.05 * pi);\n    r = 0.2 * (1. + 0.25 * q.z);\n    q.y *= 0.7;\n    d = min (d, PrCapsDf (q, r, 1.5));\n    q = p;\n    q.yz -= vec2 (1.7, -0.2);\n    d = min (d, PrCylDf (q.xzy, 0.4, 0.4));\n    q = p;\n    q.yz -= vec2 (0.4, -1.);\n    r = 1.1;\n    if (q.z < 0.) {\n      s = q.z * q.z;\n      r *= 1. - 0.2 * s;\n      q.y -= 0.1 * s;\n    }\n    q.y *= 0.8;\n    d = SmoothMin (d, PrCapsDf (q, max (r, 0.), 1.5), 0.03);\n    q = p;\n    q.yz -= vec2 (1.4, -6.15);\n    d = min (d, max (PrRoundCylDf (q.yzx, 0.5, 0.05, 0.02), 0.35 - length (q.yz)));\n    q = p;\n    DMINQ (idHeli);\n    q = p;\n    q.yz = Rot2Cs (q.yz - vec2 (1.4, -6.15), csRotor);\n    d = PrRoundBoxDf (q, vec3 (0.01, 0.32, 0.04), 0.02);\n    DMINQ (idRotorT);\n    q = p;\n    q.yz -= vec2 (2., -0.2);\n    d = PrCylDf (q.xzy, 0.12, 0.5);\n    q.y -= 0.4;\n    q.xz = Rot2Cs (q.xz, csRotor);\n    d = min (d, PrRoundBoxDf (q, vec3 (4.5, 0.02, 0.08), 0.03));\n    DMINQ (idRotorM);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.9, -1.4);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.01, 1.4), 0.04);\n    q.xy = Rot2D (q.xy, -0.1 * pi);\n    q.z = abs (q.z);\n    q.yz -= vec2 (0.4, 0.7);\n    d = min (d, PrCylDf (q.xzy, 0.06, 0.4));\n    DMINQ (idSkd);\n    dMin *= 0.7;\n  } else dMin = min (dMin, d);\n  return flyerSz * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4;\n  if (idObj == idHeli) {\n    col4 = mix (vec4 (1., 1., 0., 0.2), vec4 (1., 0., 0.1, 0.2), smoothstep (0., 0.02,\n       abs (qHit.y) - 0.05));\n    if (length (vec2 (qHit.x, qHit.y / 0.8)) > 1.24 && qHit.y > 0.55 && qHit.z > 0.4 &&\n       abs (abs (qHit.x) - 0.3) > 0.05) col4 = vec4 (0., 0.5, 0.5, -2.);\n    if (qHit.z > 0.) col4 = mix (vec4 (0., 1., 0., -1.), col4, step (0.15, length (qHit.xy)));\n    else col4 = mix (vec4 (0.5 + 0.5 * step (0.5, fract (2. * tCur +\n       0.25 * sign (qHit.x))), 0., 0., -1.), col4, step (0.2, length (vec2 (abs (qHit.x) - 0.3,\n       qHit.y))));\n  } else if (idObj == idRotorM) {\n    col4 = (length (qHit.xz) < 4.2) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n  } else if (idObj == idRotorT) {\n    col4 = (length (qHit.yz) > 0.06) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n  } else if (idObj == idSkd) {\n    col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n  }\n  return col4;\n}\n\nfloat FlyerSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = FlyerDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 0.2;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 2.5 * f / aSum;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 w;\n  float dMin, d, gHt;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    w = (q.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (w);\n    if (cType <= 2. && cm3.y > 0. && OnTrk (w) || SideTrk (w, cm3.y)) gHt = baseHt;\n    else gHt = baseHt + GrndHt (p.xz);\n    d = q.y - gHt;\n    if (cType <= 2. && cm3.y < 0. && OnTrk (w)) {\n      d = SmoothMin (q.y - baseHt, SmoothMax (d, dot (vec2 (baseWd - hgSizeB * abs (cm3.x),\n         q.y - 0.4 * gHt), sin (0.17 * pi + vec2 (0.5 * pi, 0.))) - 0.2, 0.07), 0.25);\n    }\n    d *= 0.8;\n    DMIN (idGrnd);\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeB;\n  dHit = 0.;\n  cIdB = PixToHex (ro.xz / hgSizeB);\n  pM = HexToPix (cIdB);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 420; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      BConf ();\n      cNu = false;\n    }\n    d = BObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdB = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeB);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid SConf ()\n{\n  vec2 r;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  r = Hashv2v2 (73. * cIdS + 1.1);\n  tOff.xz = 0.4 * sqrt3 * hgSizeS * (0.5 + 0.5 * r.x) * sin (2. * pi * r.y + vec2 (0.5 * pi, 0.));\n  tOff.y = r.x + r.y;\n}\n\nvoid SBConf (vec2 cIdBT, vec2 u)\n{\n  vec3 cm3;\n  vec2 w;\n  cIdB = cIdBT;\n  BConf ();\n  w = (u - cMidB) / hgSizeB;\n  cm3 = TruchSDist (w);\n  if (cType <= 2. && cm3.y > 0. && OnTrk (w) || hgSizeB * abs (cm3.x) < baseWd + 0.4 ||\n     SideTrk (w, cm3.y)) csOcc = 0.;\n  else csOcc = 0.01 + 0.99 * Hashfv2 (17.11 * cIdS);\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  if (csOcc > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= tOff.xz;\n    h = 0.1 + 0.07 * tOff.y;\n    q.y -= h + GrndHt (cMidS);\n    d = max (length (q.xz) - 0.03, q.y - h);\n    DMIN (idTrnk);\n    if (Maxv2 (tOff.xz) > 0.) {\n      q.y -= h + 0.25;\n      d = PrConCapsDf (q.xzy, sin (0.085 * pi + vec2 (0.5 * pi, 0.)), 0.1, 0.2);\n    } else {\n      q.y -= h + 0.17;\n      d = SmoothMin (PrSphDf (q, 0.15), PrSphDf (vec3 (q.x, abs (q.y) - 0.17, q.z), 0.1), 0.15);\n    }\n    DMIN (idLvs);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM, u, cIdBT;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeS;\n  dHit = 0.;\n  cIdS = PixToHex (ro.xz / hgSizeS);\n  pM = HexToPix (cIdS);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SConf ();\n    }\n    u = cMidS + tOff.xz;\n    cIdBT = PixToHex (u / hgSizeB);\n    if (cNu || cIdB != cIdBT) SBConf (cIdBT, u);\n    cNu = false;\n    d = SObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdS = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeS);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, u;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    u = cMidS + tOff.xz;\n    SBConf (PixToHex (u / hgSizeB), u);\n    if (csOcc > 0.) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.1 * d, h));\n      d += h;\n    } else d += 0.1 * hgSizeS;\n    if (sh < 0.05 || d > 2. * hgSizeS) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h, tWav;\n  h = 0.01 * (1. + sin (4. * dot (p, sin (- pi / 6. + vec2 (0., 0.5 * pi))) - tCur));\n  q = p;\n  wFreq = 2.;\n  wAmp = 0.002;\n  tWav = 0.1 * tCur;\n  tw = tWav * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= qRot;\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return h;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec3 h;\n  vec2 e, ee[3];\n  e = vec2 (max (0.1, 5e-3 * d * d), 0.);\n  ee[0] = e.yy;\n  ee[1] = e.xy;\n  ee[2] = e.yx;\n  for (int j = VAR_ZERO; j < 3; j ++) h[j] = WaveHt (p.xz + ee[j]);\n  return vec4 (normalize (vec3 (h.x - h.yz, e.x)).xzy, h.x);\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn, inout vec2 vf)\n{\n  vec4 col4, cc4, cg4;\n  vec3 cm3;\n  vec2 w;\n  float dt, h;\n  if (idObj == idGrnd) {\n    w = (ro.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (w);\n    dt = hgSizeB * abs (cm3.x);\n    cg4 = vec4 (0.1, 0.6, 0.1, 0.) * (0.6 + 0.4 * Fbm2 (4. * ro.xz));\n    col4 = cg4;\n    if (cType <= 2. && cm3.y != 0. && OnTrk (w) && dt - baseWd < 0.3) {\n      cc4 = 0.9 * mix (vec4 (0.68, 0.68, 0.7, 0.), vec4 (0.7, 0.7, 0.75, 0.),\n         smoothstep (0.15, 0.25, abs (fract (8. * (ro.y / (0.5 + GrndHt (ro.xz)))) - 0.5)));\n      cc4 *= 1. - 0.1 * Fbm3 (16. * ro);\n      h = ro.y - baseHt;\n      if (h > 0.2) col4 = mix (cc4, col4, smoothstep (0.8, 0.9, vn.y));\n      else if (h > 0.) col4 = cc4;\n      col4 = mix (col4, cg4, smoothstep (0.25, 0.3, dt - baseWd));\n      col4 = mix (0.5 * cg4, col4, smoothstep (0.03, 0.1, h));\n      vf = vec2 (16., 0.5);\n    } else {\n      vf = vec2 (2., 2.);\n    }\n  }\n  return col4;\n}\n\nvec4 SObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4;\n  if (idObj == idTrnk) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n    vf = vec2 (32., 1.);\n  } else if (idObj == idLvs) {\n    col4 = vec4 (0.4, 0.7 * min (1., (1.2 - 0.4 * csOcc)), 0.1, 0.);\n    col4 = mix (col4, vec4 (0.9, 0.9, 0., 0.1), step (0.7, Fbm3 (64. * ro.xzy)));\n    vf = vec2 (16., 2.);\n  }\n  return col4;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.4, 0.45, 0.9), vec3 (0.9, 0.9, 0.85),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, roo, rdo;\n  vec2 vf, u;\n  float dstObj, dstFlyer, dstObjB, dstObjS, dstWat, reflFac, sh;\n  int idObjB, idObjS, idObjF;\n  bool isLit;\n  csRotor = sin (17.1 * pi * tCur + vec2 (0.5 * pi, 0.));\n  vf = vec2 (0.);\n  isSh = false;\n  dstWat = (rd.y < 0.) ? - (ro.y - baseHt - 0.05) / rd.y : dstFar;\n  roo = ro;\n  rdo = rd;\n  reflFac = 1.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = dstFar;\n    dstObjB = BObjRay (ro, rd);\n    idObjB = idObj;\n    dstObjS = withTrees ? SObjRay (ro, rd) : dstFar;\n    idObjS = idObj;\n    dstFlyer = FlyerRay (ro, rd);\n    idObjF = idObj;\n    if (min (min (dstObjB, dstObjS), dstFlyer) < dstFar) {\n      if (min (dstObjB, dstObjS) < dstFlyer) {\n        if (dstObjB < dstObjS) {\n          dstObj = dstObjB;\n          idObj = idObjB;\n        } else {\n          dstObj = dstObjS;\n          idObj = idObjS;\n        }\n      } else {\n        dstObj = dstFlyer;\n        idObj = idObjF;\n      }\n      if (k == 0 && dstWat < min (dstObj, dstFar)) {\n        ro += dstWat * rd;\n        vnw = WaveNf (ro, dstWat).xyz;\n        vnw = VaryNf (4. * ro, vnw, 0.05 * (1. - 0.9 * smoothstep (0.2, 0.3, dstWat / dstFar)));\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n        reflFac = 0.7;\n      } else {\n        ro += dstObj * rd;\n        break;\n      }\n    }\n  }\n  isLit = false;\n  if (min (min (dstObjB, dstObjS), dstFlyer) < dstFar) {\n    if (idObj == idObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      BConf ();\n      vn = BObjNf (ro);\n      col4 = GrndCol (ro, vn, vf);\n    } else if (idObj == idObjS) {\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      SConf ();\n      u = cMidS + tOff.xz;\n      SBConf (PixToHex (u / hgSizeB), u);\n      vn = SObjNf (ro);\n      col4 = SObjCol (ro, vf);\n    } else {\n      vn = FlyerNf (ro);\n      col4 = FlyerCol ();\n    }\n    if (col4.a >= 0.) {\n      if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      isLit = true;\n    } else  if (col4.a == -1.) {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    } else if (col4.a == -2.) {\n      col = mix (col4.rgb, 0.8 * SkyCol (reflect (rd, vn)), 0.8);\n    }\n  } else {\n    col = SkyCol (rd);\n  }\n  if (isLit) {\n    isSh = true;\n    sh = FlyerSShadow (ro + 0.01 * vn, sunDir);\n    if (withTrees) sh = min (sh, SObjSShadow (ro + 0.01 * vn, sunDir));\n    col = col4.rgb * (0.3 + 0.1 * max (- dot (sunDir, vn), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  }\n  if (reflFac < 1.) col = mix (mix (vec3 (0., 0.1, 0.), vec3 (0.08, 0.08, 0.1),\n     smoothstep (0.45, 0.55, Noisefv2 (128. * (roo + dstWat * rdo).xz))), reflFac * col,\n     1. - 0.95 * pow (max (dot (- rdo, vnw), 0.), 1.5));\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPos (float t)\n{\n  return vec3 (EvalPPos (t), 0.).xzy;\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vel, acc, va, flVd, fp, fpF, fpB;\n  vec2 cs;\n  float oRl, dt;\n  dt = 0.2;\n  fp = TrkPos (t);\n  flyerPos = fp;\n  flyerPos.y += 0.5 + 0.6 * (1. + sin (0.1 * pi * tCur));\n  fpF = TrkPos (t + dt);\n  fpB = TrkPos (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  acc = (fpF - 2. * fp + fpB) / (dt * dt);\n  va = cross (acc, vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 0.07 * length (va) * Ssign (va.y);\n  oRl += 0.02 * pi * sin (1. * pi * t);\n  oRl = smoothstep (0.01, 0.03, abs (oRl)) * oRl;\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flyerMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, t;\n  int vuId, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 3600.) + 30. * floor (dateCur.w / 3600.) + 20.;\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n    mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  withTrees = true;\n  hgSizeB = 16.;\n  hgSizeS = 1.;\n  baseHt = 0.;\n  baseWd = 1.8;\n  SetPath ();\n  trVel = 0.3;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  t = tCur * trVel;\n  FlyerPM (t);\n  if (vuId <= 1 && length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n     fract (tCur / 60.))) vuId = 1 - vuId;\n  if (vuId == 0 || vuId == 1) {\n    ro.xz = EvalPPos (t + sign (float (vuId) - 0.5) * 4. * trVel);\n    ro.x += 0.01;\n    ro.y = (vuId == 0) ? 2. : 2.5;\n    vd = normalize (flyerPos - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi - 0.1 * pi * ((vuId == 0) ? 1. : -1.);\n    el += asin (vd.y);\n    el = clamp (el, -0.3 * pi, 0.15 * pi);\n    zmFac = 2.5;\n    dstFar = 300.;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 60., (-3. * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x += 1.6 * hgSizeB;\n    vd = normalize (flyerPos - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 3.;\n    if (mPtr.z > 0. && vuId == regId) zmFac = max (30. + 60. * msw.y, zmFac);\n    dstFar = 200.;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 0.7, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n  Previous shaders using grid-based raymarching (chronological order, with\n  improving algorithms -- may have missed one or two):\n\n  \"Gotham City\"                     (XljXR3)     \"Panspermia Incoming\"             (tlcXD7)\n  \"Garage\"                          (Ms33Dj)     \"Live Assembly Instructions\"      (WlcSD2)\n  \"Pannini Flies Gotham\"            (4s3XzN)     \"Paper Rolls\"                     (WlKSRd)\n  \"Canal City\"                      (lsdXzM)     \"Love Is In The Air\"              (3dsyWB)\n  \"Thomas X3\"                       (ldtXD8)     \"Invasion Of The Covoids\"         (WdScD1)\n  \"Complex Tunnels\"                 (4dtXW4)     \"Library Lost and Found\"          (tdlBzH)\n  \"Express Train\"                   (MsdSDM)     \"Percolation\"                     (tlfcDn)\n  \"Visible Clock 2\"                 (ldtXRS)     \"Desert Reflections\"              (WtXyRB)\n  \"Dux\"                             (MlcSRn)     \"Cradles of Newton\"               (tlfcR2)\n  \"Fast Fish\"                       (Ml3XWH)     \"Bugs in the Shrubs\"              (wlScWy)\n  \"Urban Growth\"                    (XdXcRM)     \"Truchet Waves\"                   (3tScDc)\n  \"Deep Dive\"                       (4dXfD4)     \"Truchet Balls\"                   (tlXBW4)\n  \"Closely Watched Dolphins\"        (MdlfRl)     \"Edible Edifices\"                 (3ljBWt)\n  \"Hex Ducks\"                       (XsfBDj)     \"Underground Trains\"              (tsKyzw)\n  \"Island Flight\"                   (XdBBRR)     \"Truchet Passages\"                (WdKcWd)\n  \"Arctic Patrol\"                   (lsBfzy)     \"Desert Reflections 2\"            (wdtBDN)\n  \"Font3d\"                          (ltsyRr)     \"Desert Ducks\"                    (tdyBRD)\n  \"Lorem Ipsum\"                     (XlXyR8)     \"Mountain Lake with Tower\"        (3tdcWj)\n  \"Historical Text\"                 (4tXcRH)     \"Metallic Tubeworms\"              (3ltfzM)\n  \"Font Clock\"                      (MlscR8)     \"Truchetted Menger\"               (3lcBDl)\n  \"Alphaville\"                      (XtfczN)     \"Flying Bathtubs\"                 (Ndl3Ds)\n  \"Alphawall\"                       (MlXyWf)     \"Antarctic Flag\"                  (sdlSRl)\n  \"Active Flowers\"                  (4lXfWH)     \"Chateaux... v2\"                  (fsjXWG)\n  \"Buoyant Balls\"                   (MtsBW8)     \"Urban Smog\"                      (NsdGDN)\n  \"Endless Engines\"                 (ltffzB)     \"Vines at Night 2\"                (sdcGWB)\n  \"Franky and the Drakettes\"        (ltfBzf)     \"Balls Falling\"                   (NsKGR3)\n  \"Books and Stairs 2\"              (MtsfRl)     \"Spherical Metropolis\"            (ssG3W3)\n  \"Into the Woods\"                  (Mddczn)     \"Falling Random Numbers\"          (7stSWf)\n  \"Blob Zoo\"                        (4sdcWN)     \"Vessel Climbing\"                 (NdGXDD)\n  \"Hexpo\"                           (lsdcD7)     \"Wind Farm\"                       (Ntd3R2)\n  \"Alphapolis\"                      (4scyDj)     \"Helicopter Squadron\"             (flyGzD)\n  \"Iced Cake\"                       (4dGczw)     \"Greek Variants\"                  (ftVGDy)\n  \"Book of the Woods\"               (XsVyRw)     \"Forkscape\"                       (fttSR8)\n  \"Asteroid Field\"                  (4dGcDh)     \"Gold Edifices\"                   (NldSzM)\n  \"Big SETI\"                        (XsVcDW)     \"Mausolea\"                        (ftcSWS)\n  \"Falling Stars\"                   (lsVyz3)     \"Dynamic Block Grid\"              (sdsBDH)\n  \"Losing Focus\"                    (4d3fRM)     \"Drive the Mapper\"                (7dsBW2)\n  \"Ozymandias Redux\"                (lscBRB)     \"Losing Focus 2\"                  (sdSBzc)\n  \"Time Released\"                   (MdVBDK)     \"Random Slabs\"                    (7sKyWh)\n  \"Tux and Pals\"                    (XlyyRR)     \"Reading Room\"                    (fs3fzn)\n  \"Endless Penguins\"                (MlVyzR)     \"Ultimate Library 2\"              (flKyDt)\n  \"Penguins Can't Fly\"              (ltVyzh)     \"Martian Farming\"                 (ft3fWB)\n  \"Train Ride 2\"                    (XlVczW)     \"Hilbertian Saltation\"            (NtVfDh)\n  \"Fibonacci's Fugu\"                (Mltfzf)     \"Looping Hilbertian Saltation\"    (DdXGWn)\n  \"Fugu Watching\"                   (MtyfRW)     \"Generalized Truchet Path\"        (mdXGRf)\n  \"Knit\"                            (tsBSDz)     \"Twisted Passage\"                 (DdX3Rl)\n  \"Ride the Breeze\"                 (WdBXzG)     \"Truchet Nets\"                    (msj3RR)\n  \"Waterworld City\"                 (wlsGDn)     \"Truchet's Train\"                 (dd2GRy)\n  \"Palace on the Hill\"              (Wlj3DD)     \"Forest Train Ride\"               (csjGDd)\n  \"Stairs to Nowhere\"               (wtB3R3)     \"Monorail\"                        (cdfSzl)\n  \"Night of the Penguins\"           (ttlSRr)     \"Palladian Schneekugel\"           (mtf3zl)\n  \"Flying the Twisted Forest\"       (WtfXRS)     \"Dynamic Block Grid 2\"            (ctXSD2)\n  \"Chocolate Buttons\"               (3tlXWs)     \"Mriya Over Metropolis\"           (ct2SR1)\n  \"Cookies\"                         (tlBSzR)     \"Monorail 2\"                      (msc3zn)\n  \"Cupcakes\"                        (3lBSRm)     \"Falling Chips\"                   (DstGDr)\n  \"Vines at Night\"                  (WtBSD1)     \"Mini Metropolis\"                 (msc3W2)\n  \"Cookie Waves\"                    (wlSSWy)     \"Snapping Rockworms\"              (csGGWR)\n  \"Leaping Snakes 2\"                (3lBXWV)     \"Barque Fleet\"                    (mdKGzd)\n  \"Submerging Tower\"                (wdcGWr)     \"Desert Reflections 3\"            (msVXzz)\n  \"Moon Flight\"                     (tdVGWw)     \"Reflecting Dynamic Block Grid\"   (mtGGzh)\n  \"Engine Album\"                    (WsyGRK)     \"Falling Polyhedra\"               (DtKGDm)\n  \"Undersea Life\"                   (td3Szj)     \"Hexagonally Discretized Waves\"   (dlKGRV)\n  \"Dynamic Space Rocks\"             (WsGSzt)     \"Grid-Surfing Balls\"              (mlVGWy)\n  \"Trux in Space\"                   (tsVSW3)     \"Wind Walker Herd\"                (cl3SW7)\n  \"Planet Reboot 2\"                 (Wtc3Rf)     \"Truchet Path Journey\"            (mdXyRB)\n  \"Chateaux..\"                      (Wtd3Df)     \"Biplanes in the Badlands 2\"      (cdsBDX)\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}