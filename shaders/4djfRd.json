{
    "Shader": {
        "info": {
            "date": "1501740334",
            "description": "Coolio",
            "flags": 0,
            "hasliked": 0,
            "id": "4djfRd",
            "likes": 8,
            "name": "Cool",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mikatalk",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "// Forked from https://www.shadertoy.com/view/4dSfzt\n\n#define Pi 3.1415926\n#define Pi2 1.5707963\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nfloat Sphere( vec3 centre, float radius, vec3 pos )\n{\n    return length(centre-pos)-radius;\n}\n\nfloat Torus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 Sub( vec2 a, vec2 b )\n{\n    return max(-a.x, b.x) == -a.x ? a : b;\n}\n\nfloat BoxUn( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// A more interesting SDF:\nfloat Superellipsoid( vec3 centre, float radius, float power, vec3 pos )\n{\n    pos = abs(pos-centre)/radius; // scale and sign-flip pos into a [0,1] range\n    pos = pow(pos,vec3(power)); // apply power before summing components\n    float d = dot(pos,vec3(1)); // add the components together\n\td = pow(d,1./power); // apply inverse power so SDF is well behaved\n    float fix = min(1.,.5+.5*(power-1.)); // corrective factor for lower powers, ensure gradient of SDF doesn't exceed 1.\n    return fix*(d-1.)*radius; // undo the scaling, to hit the desired radius\n}\n\n// pass vec2's so we can attach an object-ID to objects in the SDF\nvec2 Union( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 Intersection( vec2 a, vec2 b )\n{\n    return a.x > b.x ? a : b;\n}\n\n\nfloat CappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec2 Scene( vec3 pos )\n{\n\tvec2 angle = vec2(-iTime,0);\n    Rotate(pos,angle);\n\n    float shapeIndex = 0.;\n    vec3 offset = vec3(5.,0.,0);\n    vec3 tmp = pos + offset;\n    \n    vec2 f = vec2(.0);\n\n    // C\n    Rotate(tmp,vec2(.0, -Pi2));    \n    vec2 torus = vec2( Torus(tmp+vec3(0.,0.,.25), vec2(1., .5)), shapeIndex );\n    vec2 box = vec2( BoxUn(tmp+vec3(0.,0.,1.25), vec3(2.,1.,1.)), shapeIndex );\n    f = Intersection( torus, box );\n\ttmp = pos + offset;\n    \n    box = vec2( CappedCylinder(tmp+vec3(1.,.25,0.), vec2(.5, .5)), shapeIndex);\n    f = Union(f, box );\n\n    Rotate(tmp,vec2(.0, Pi2));\n    torus = vec2( Torus(tmp+vec3(0.,0.,.75), vec2(1., .5)), shapeIndex );\n    box = vec2( BoxUn(tmp+vec3(0.,0.,1.75), vec3(2.,1.,1.)), shapeIndex );\n    f = Union(f, Intersection( torus, box ) );\n\n    \n    // O\n    offset = vec3(1.5,0.,0.);\n\ttmp = pos + offset;\n    Rotate(tmp,vec2(.0, -Pi2));\n    torus = vec2( Torus(tmp+vec3(0.,0.,.25), vec2(1., .5)), shapeIndex );\n    box = vec2( BoxUn(tmp+vec3(0.,0.,1.25), vec3(2.,1.,1.)), shapeIndex );\n    f = Union(f, Intersection( torus, box ));\n\t\n    tmp = pos + offset;\n    box = vec2( CappedCylinder(tmp+vec3(1.,.25,0.), vec2(.5, .5)), shapeIndex);\n    f = Union(f, box );\n\n    Rotate(tmp,vec2(.0, Pi2));\n    torus = vec2( Torus(tmp+vec3(0.,0.,.75), vec2(1., .5)), shapeIndex );\n    box = vec2( BoxUn(tmp+vec3(0.,0.,1.75), vec3(2.,1.,1.)), shapeIndex );\n    f = Union(f, Intersection( torus, box ) );\n    \n    tmp = pos + offset;\n    box = vec2( CappedCylinder(tmp+vec3(-1.,.25,0.), vec2(.5, .5)), shapeIndex);\n    f = Union(f, box );\n    \n    // O\n    offset = vec3(-2.,0.,0.);\n\ttmp = pos + offset;\n    Rotate(tmp,vec2(.0, -Pi2));\n    torus = vec2( Torus(tmp+vec3(0.,0.,.25), vec2(1., .5)), shapeIndex );\n    box = vec2( BoxUn(tmp+vec3(0.,0.,1.25), vec3(2.,1.,1.)), shapeIndex );\n    f = Union(f, Intersection( torus, box ));\n\t\n    tmp = pos + offset;\n    box = vec2( CappedCylinder(tmp+vec3(1.,.25,0.), vec2(.5, .5)), shapeIndex);\n    f = Union(f, box );\n\n    Rotate(tmp,vec2(.0, Pi2));\n    torus = vec2( Torus(tmp+vec3(0.,0.,.75), vec2(1., .5)), shapeIndex );\n    box = vec2( BoxUn(tmp+vec3(0.,0.,1.75), vec3(2.,1.,1.)), shapeIndex );\n    f = Union(f, Intersection( torus, box ) );\n    \n    tmp = pos + offset;\n    box = vec2( CappedCylinder(tmp+vec3(-1.,.25,0.), vec2(.5, .5)), shapeIndex);\n    f = Union(f, box );\n    \n    // L\n    offset = vec3(-4.5,0.,0.);\n    tmp = pos + offset;\n    box = vec2( CappedCylinder(tmp, vec2(.5, 2.)), shapeIndex);\n//    box = vec2( CappedCylinder(tmp, vec2(.5, 1.5)), shapeIndex);\n    f = Union(f, box );\n\n//    Rotate(tmp, vec2(1.3, 0.0));    \n  //  box = vec2( CappedCylinder(tmp, vec2(.5, 2.5)), shapeIndex);\n  //  f = Union(f, box );\n    \n    // floor\n    f = Union( f, vec2( Sphere(vec3(0,-80,0),78.,pos), ++shapeIndex ) );\n    \n    return f;\n}\n\nfloat SDF( vec3 pos )\n{\n    return Scene(pos).x;\n}\n\nfloat GetShapeIndex( vec3 pos )\n{\n    return Scene(pos).y;\n}\n\nfloat ShadowMarch( vec3 pos, vec3 light )\n{\n    vec3 ray = normalize(light-pos);\n    float e = length(light-pos);\n    float t = .02; // step away from the surface\n    for ( int i=0; i < 120; i++ )\n    {\n        float h = SDF(pos+ray*t);\n        if ( h < .001 )\n        {\n            return 0.; // hit something\n        }\n        if ( t >= e )\n        {\n            break;\n        }\n        t += h;\n    }\n    return 1.; // didn't hit anything\n}\n\n// material parameters, per shape\nconst vec3 albedo[] = vec3[](\n    vec3(.05),\n    vec3(1.01)\n);\nconst vec3 fresnelColour[] = vec3[](\n    vec3(.4, .03, .3),\n    vec3(.2, .0, .2)\n);\nconst float roughness[] = float[](\n   .4f,\n   .2f\n);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, // pixel pos on screen\n\t\t\t\t1 ) ); // place screen 1 unit in front of eye\n    vec3 pos = vec3(0,0,-15); // move eye 18 units back from scene\n\tvec2 angle = vec2(0,.25);\n\tif ( iMouse.z > .0 ) angle = (iMouse.xy/iResolution.xy-.5)*3.14;\n\tRotate(pos,angle);\n\tRotate(ray,angle);\n\n    fragColor = 4.*pow(texture(iChannel0,ray),vec4(2.2));\n    for ( int i=0; i < 100; i++ )\n    {\n        float h = SDF(pos);\n        if ( h < .01 )\n        {\n            fragColor = vec4(0);\n            break;\n        }\n        pos += ray*h;\n    }\n\n    if ( SDF(pos) < .01 )\n    {\n        vec3 normal;\n        normal.x = SDF(pos+vec3(.01,0,0)) - SDF(pos-vec3(.01,0,0));\n        normal.y = SDF(pos+vec3(0,.01,0)) - SDF(pos-vec3(0,.01,0));\n        normal.z = SDF(pos+vec3(0,0,.01)) - SDF(pos-vec3(0,0,.01));\n        normal = normalize(normal);\n\n        vec3 lightSource = vec3(4,4,-4);\n\t\tfloat light = max(.0,dot(normal,normalize(lightSource-pos)));\n        light *= ShadowMarch( pos, lightSource );\n\n        vec3 ambient = mix( vec3(.07), vec3(.05,.1,.15), normal.y*.5+.5 ); // looks better than a flat colour\n        vec3 lightCol = vec3(1.,.9,.8);\n        vec3 lighting = light*lightCol + ambient;\n\n        // material\n        int shapeIndex = int(GetShapeIndex(pos));\n        \n        fragColor.rgb = albedo[shapeIndex] * lighting;\n        \n        // specular highlight\n        \n        // reflection mapping\n        vec3 reflection = reflect(ray,normal);\n        vec3 refMap = 4.*pow(texture(iChannel0,reflection).rgb,vec3(2.2));\n        vec3 fresnel = mix( fresnelColour[shapeIndex], vec3(1.-roughness[shapeIndex]), pow(dot(normal,ray)+1.,5.) );\n        fragColor.rgb = mix( fragColor.rgb, refMap, fresnel );\n    }\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}