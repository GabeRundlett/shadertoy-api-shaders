{
    "Shader": {
        "info": {
            "date": "1530745216",
            "description": "A little ray traced scene with a variation of my music visualiser.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdGfD3",
            "likes": 9,
            "name": "Music Vis Scene",
            "published": 3,
            "tags": [
                "raytracing",
                "musicvisualizer",
                "musicvisualiser"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 781
        },
        "renderpass": [
            {
                "code": "//#define ANTIALIASING 1\n\nstruct Material\n{\n    // no diffuse lighting in this scene!\n    vec2 fresnel;\n    vec4 emit; // emissive colour - w = 0 => tint applied to visualiser, w = 1 => const colour\n    vec3 uvScale; // for triplanar mapping of visualiser - RELATIVE TO OBJECT SCALE!\n    vec3 uvOffset; // from centre of object\n};\n\nstruct Sphere\n{\n    vec3 centre;\n    float radius; // use -ve to do inverted\n    Material material;\n};\n\nstruct Cuboid // axis aligned\n{\n    vec3 centre;\n    vec3 halfDims; // use -ve to do inverted\n    Material material;\n};\n    \n    \n#define Schlick(ior) ((ior-1.)*(ior-1.))/((ior+1.)*(ior+1.))\n    \nSphere spheres[] = Sphere[](\n     Sphere(\n\t\tvec3(-.5,-1,0), .5,\n        Material( vec2(.7,1), vec4(0), vec3(0), vec3(0) )\n\t)\n    ,Sphere(\n\t\tvec3(1,-1.2,1), .3,\n        Material( vec2(Schlick(1.2),1), vec4(1,1,1,0), vec3(-.7,1,-.7), vec3(0) )\n\t)\n    ,Sphere(\n        vec3(-3,-1,3), .5,\n        Material( vec2(.7,1), vec4(0), vec3(0), vec3(0) )\n\t)\n    ,Sphere(\n        vec3(3,-1,3), .5,\n        Material( vec2(Schlick(1.2),1), vec4(vec3(.5),0), vec3(.01,.01,.0), vec3(.6,-.4,0) )\n     )\n    ,Sphere(\n        vec3(1,-1.1,3.1), .4,\n        Material( vec2(Schlick(1.2),1), vec4(vec3(.5),0), vec3(.01,.01,.0), vec3(.2,-.4,0) )\n     )\n    ,Sphere(\n        vec3(-1,-1.2,3.2), .3,\n        Material( vec2(Schlick(1.2),1), vec4(vec3(.5),0), vec3(.01,.01,.0), vec3(-.2,-.4,0) )\n     )\n);\n\nCuboid cuboids[] = Cuboid[](\n     Cuboid(\n\t\t// simple screen showing the visualiser\n        vec3(0,1,4), vec3(4,2.5,.1),\n        Material( vec2(0), vec4(1,1,1,0), vec3(1,2.5/4.,0), vec3(0) )\n     )\n    ,Cuboid(\n\t\t// second screen showing the visualiser\n        vec3(4,1,3), vec3(.1,2.5,.5),\n        Material( vec2(0), vec4(1,1,1,0), vec3(0,2.5/4.,1./8.), vec3(0,0,3.5/4.) )\n     )\n    ,Cuboid(\n        // inverted cube for the room\n        vec3(0,1,0), -vec3(4,2.5,4),\n        Material( vec2(Schlick(1.33),1), vec4(0), vec3(0), vec3(0) )\n     )\n    ,Cuboid(\n        // no reflections on the back wall\n        vec3(0,1,-4), -vec3(4,2.5,.01),\n        Material( vec2(0), vec4(vec3(.05),1), vec3(0), vec3(0) )\n     )\n    \n    // overhead lights\n    ,Cuboid(\n        vec3(-3,3.5,0), vec3(.1,.1,3),\n        Material( vec2(0), vec4(1), vec3(0), vec3(0) )\n     )\n    ,Cuboid(\n        vec3(-1,3.5,0), vec3(.1,.1,3),\n        Material( vec2(0), vec4(1), vec3(0), vec3(0) )\n     )\n    ,Cuboid(\n        vec3(1,3.5,0), vec3(.1,.1,3),\n        Material( vec2(0), vec4(1), vec3(0), vec3(0) )\n     )\n    ,Cuboid(\n        vec3(3,3.5,0), vec3(.1,.1,3),\n        Material( vec2(0), vec4(1), vec3(0), vec3(0) )\n     )\n    \n    // light boxes\n    ,Cuboid(\n        vec3(1,0,-4), vec3(.3,1.5,.1),\n        Material( vec2(0), vec4(1), vec3(0), vec3(0) )\n     )\n    ,Cuboid(\n        vec3(-2,-.5,-4), vec3(.5,1,.1),\n        Material( vec2(0), vec4(1), vec3(0), vec3(0) )\n     )\n    /*,Cuboid(\n        vec3(0,1,0), vec3(.5),\n        Material( vec2(Schlick(1.33),1), vec4(0), vec3(0), vec3(0) )\n     )*/\n    ,Cuboid(\n        vec3(3,-1.25,3), vec3(.333,.25,.333),\n        Material( vec2(Schlick(1.2),1), vec4(.3,.3,.3,0), vec3(.01,.01,.0), vec3(.6,-.4,0) )\n     )\n    ,Cuboid(\n        vec3(1,-1.3,3.1), vec3(.267,.2,.267),\n        Material( vec2(Schlick(1.2),1), vec4(.3,.3,.3,0), vec3(.01,.01,.0), vec3(.2,-.4,0) )\n     )\n    ,Cuboid(\n        vec3(-1,-1.35,3.2), vec3(.2,.15,.2),\n        Material( vec2(Schlick(1.2),1), vec4(.3,.3,.3,0), vec3(.01,.01,.0), vec3(-.2,-.4,0) )\n     )\n);\n\nstruct Intersection\n{\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec3 uvw; // normalized coordinates relative to the object\n    Material material;\n};\n    \nconst Intersection noIntersection = Intersection(1e30,vec3(0),vec3(0),vec3(0),Material(vec2(0),vec4(0),vec3(0),vec3(0)));\n\nIntersection TraceSpheres( vec3 rayStart, vec3 rayDirection )\n{\n    Intersection intersection = noIntersection;\n\n    for ( int i=0; i < spheres.length(); i++ )\n    {\n        vec3 centre = spheres[i].centre; // do everything relative to ray source\n        vec3 pc = centre - rayStart;\n        float radius = spheres[i].radius;\n        float rad2 = radius*radius;\n        \n        float hyp2 = dot(pc,pc);\n        float adj = dot(pc,rayDirection); // closest point on ray to sphere centre\n        float opp2 = hyp2-adj*adj;\n        \n\t\tif ( opp2 < rad2 )\n        {\n\t\t\tfloat t = adj - sqrt( rad2 - opp2 );\n            \n            if ( t < intersection.dist && t > 0. )\n            {\n                intersection.dist = t;\n                intersection.pos = rayStart + t*rayDirection;\n                intersection.normal = normalize(intersection.pos - centre);\n                intersection.material = spheres[i].material;\n                intersection.uvw = (intersection.pos - centre)/radius;\n            }\n        }\n    }\n    \n    return intersection;\n}\n\nIntersection TraceCuboids( vec3 rayStart, vec3 rayDirection )\n{\n    vec3 ir = 1./rayDirection;\n    vec3 ur = abs(ir);\n\n    // avoid division by zero\n    ur = max(ur,.000001);\n    ir = (step(0.,ir)*2.-1.)*ur;\n\n    vec3 cr = rayStart*ir;\n\n    Intersection intersection = noIntersection;\n    for ( int i=0; i < cuboids.length(); i++ )\n    {\n        vec3 centre = cuboids[i].centre;\n        vec3 halfDims = cuboids[i].halfDims;\n\n//dammit how do I make it work with inverted cuboid? it nearly does!\n        bool flip = ( halfDims.x < 0. );\n        halfDims = abs(halfDims);\n        \n        vec3 p = centre*ir - cr;\n        vec3 frontv = -halfDims*ur + p;\n        float front = max(max(frontv.x,frontv.y),frontv.z);\n        vec3 backv = halfDims*ur + p;\n        float back = min(min(backv.x,backv.y),backv.z);\n        if ( front > back ) continue;\n        if ( flip )\n        {\n\t\t\t// for inverted ones need to swap front and back\n            float temp = front;\n            front = back;\n            back = temp;\n            frontv = backv; // for normals\n        }\n        if ( front < 0. ) continue; // back face culling => don't care if ray starts inside box\n\n        if ( front < intersection.dist )\n        {\n            intersection.dist = front;\n            intersection.pos = rayStart + front*rayDirection;\n            intersection.normal = step(0.,-abs(vec3(front)-frontv)); // detect which component(s) of frontv == front - exact edges will get (1,1,0)\n            intersection.normal *= -sign(rayDirection);\n            intersection.material = cuboids[i].material;\n            intersection.uvw = (intersection.pos - centre)/halfDims;\n        }\n    }\n    \n    return intersection;\n}\n\nIntersection Trace( vec3 p, vec3 r )\n{\n    Intersection sphere = TraceSpheres(p,r);\n    \n    Intersection box = TraceCuboids(p,r);\n\n    if ( box.dist < sphere.dist )\n        return box;\n    else\n        return sphere;\n}\n\n\n// uv in range [-1,1]\nvec3 Vis( vec2 uv )\n{\n    float aa = iTime*.1;//1.618*6.283*floor(iTime);\n    uv = uv*cos(aa)+uv.yx*vec2(-1,1)*sin(aa);\n    uv.x = abs(fract(uv.x*.5)*2.-1.);\n\tuv.y = abs(uv.y/1.);\n\n    return texture(iChannel3,uv).rgb;\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = vec4(0);\n    \n    vec3 ray = vec3((fragCoord*2.-iResolution.xy)/iResolution.y,2.);\n    vec3 pos = vec3(0,0,-1.5)+sin(iTime*vec3(.2,.3,.5));\n    \n    vec2 a = sin(iTime*vec2(.11,.17))*.3;\n    a.y += .3;\n    ray.yz = ray.yz*cos(a.y) + sin(a.y)*vec2(-1,1)*ray.zy;\n    ray.zx = ray.zx*cos(a.x) + sin(a.x)*vec2(-1,1)*ray.xz;\n    \n    ray = normalize(ray);\n    \n    float modulation = 1.;\n\tfor ( int bounce = 0; bounce < 3; bounce++ )\n    {\n        Intersection i = Trace( pos, ray );\n\n        // map uv to the vis texture\n        vec3 uvw = i.uvw;\n        uvw *= i.material.uvScale;\n        uvw += i.material.uvOffset;\n        //vec2 uv = uvw.xy; // todo: triplanar mapping actually...\\/\n        vec2 uv = vec2( uvw.x + uvw.z, uvw.y ); // scale and offset can make this work\n        \n        float fresnel = pow( 1. + dot(ray,i.normal), 5. );\n\t\tfresnel = mix( i.material.fresnel.x, i.material.fresnel.y, fresnel );\n\n        fragColour.rgb += modulation * i.material.emit.rgb * mix( Vis(uv), vec3(1), i.material.emit.a );\n\n// debug normals\n//fragColour.rgb = .5+.5*i.normal; modulation = 0.;\n        \n        modulation *= fresnel;\n        if ( modulation < .001 ) break;\n        pos = i.pos;\n        ray = reflect(ray,i.normal);\n    }\n    \n    \n    // todo: fire reflection ray\n    \n    \n//\tfragColour.rgb = Vis((fragCoord*2.-iResolution.xy)/iResolution.x);\n    \n    fragColour.a = 1.;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#ifdef ANTIALIASING\n        // gosh the compiler really doesn't like this\n        vec4 tap;\n        fragColour = vec4(0);\n    \tmainImage2( tap, fragCoord + vec2(-3,1)/8. );\n        fragColour += tap;\n    \tmainImage2( tap, fragCoord + vec2(1,3)/8. );\n        fragColour += tap;\n    \tmainImage2( tap, fragCoord + vec2(3,-1)/8. );\n        fragColour += tap;\n    \tmainImage2( tap, fragCoord + vec2(-1,-3)/8. );\n        fragColour += tap;\n        \n        fragColour /= fragColour.a;\n#else\n        // disable AA\n    \tmainImage2( fragColour, fragCoord );\n#endif\n    \n    // gamma correct (convert linear colour values back to monitor-gamma space)\n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// row 0 = frequency\n// row 1 = waveform\nfloat Sample( float u, int row, int range )\n{\n    float f = 0.;\n    for ( int i=0; i < 128; i++ )\n    {\n        if ( i >= range ) break;\n        \n        float g = texelFetch(iChannel0,ivec2((int(u*iChannelResolution[0].x)+i-range/2)&int(iChannelResolution[0].x-1.),row),0).r;\n        \n\t    // gamma correct (convert to linear, before we do any blending with other samples)\n        // (source texture isn't strictly an image, so this is just a cosmetic tweak)\n    \tf += pow( g, 2.2 );\n    }\n    return f/float(range);\n}\n\n\nvec3 Vis( in vec2 uv )\n{\n    float l = uv.y;// *1.5;\n    float a = uv.x;\n    \n    float A = .25;\n    float B = .5;\n    if ( iMouse.z > 0. )\n    {\n        A = iMouse.x / iResolution.x; // strength of chromatic dispersion\n        B = iMouse.y / iResolution.y; // strength of waveform\n    }\n    A *= A; // apply a curve so mouse movements feel better\n    B *= B;\n    \n    vec3 o;\n    o.r = Sample(pow(mix(mix(l,.0,A),    Sample(a,1,1) ,B),2.), 0, 20);\n    o.g = Sample(pow(mix(mix(l,.5,A),(1.-Sample(a,1,64)),B),2.), 0, 8);\n    o.b = Sample(pow(mix(mix(l,1.,A),    Sample(a,1,128) ,B),2.), 0, 1);\n    \n    // tweak the contrast\n//    fragColour.rgb = smoothstep(vec3(.3,.2,.4),vec3(.9,1,.8),fragColour.rgb+.2*l);\n    o = 15.*smoothstep(vec3(.3,.2,.4),vec3(1.9,2,1.8),o+.2*l);\n    \n    return o;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // map the whole region so we get best resolution\n\n    fragColour.rgb = Vis(uv);\n    \n\t// motion blur/trails (use different rates for each component for a nice effect!)\n\tfragColour.rgb = mix( texelFetch(iChannel3,ivec2(fragCoord),0).rgb, fragColour.rgb, vec3(.2,.6,.1) );\n\n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}