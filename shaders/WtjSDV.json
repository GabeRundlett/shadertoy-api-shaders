{
    "Shader": {
        "info": {
            "date": "1567489055",
            "description": "More Beeple covert art: https://i.redd.it/fu5p0nwfaqsy.jpg\n\nIt actually does Mie scattering with Frostbite's phase function... which makes it somewhat expensive. But I like the end result :). Hope you like it too!",
            "flags": 0,
            "hasliked": 0,
            "id": "WtjSDV",
            "likes": 14,
            "name": "WE FUCKING LOVE OUR FANS!",
            "published": 3,
            "tags": [
                "raymarching",
                "raycasting",
                "scattering",
                "mie",
                "dragons",
                "beeple",
                "imagine"
            ],
            "usePreview": 1,
            "username": "toomuchvoltage",
            "viewed": 908
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   More Beeple cover art in Shadertoy! :D\n   This one was an album teaser for Imagine Dragons: https://i.redd.it/fu5p0nwfaqsy.jpg\n   It actually does Mie scattering with Frostbite's Mie phase function approximation.\n   Also raymarches/casts rather than sphere marches given that vast majority of what you see is the scattering.\n\n   This rendition is covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n#define SCATTERING_COEF 8.0\n#define TRANSMISSION_COEF 0.0\n#define EXTINCTION_COEF (SCATTERING_COEF + TRANSMISSION_COEF)\n\nfloat _2dNoise (vec2 forPos)\n{\n\tfloat noiseVal = texture (iChannel0, forPos * 0.5).r;\n    return 0.5 + noiseVal * 0.5;\n}\n\nvoid intersectBox(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, inout float finalK, inout vec3 norm) {\n    vec3 maxODiff = boxMax - rayOrigin;\n    vec3 minODiff = boxMin - rayOrigin;\n    vec3 invDir = vec3 (1.0) / rayDir;\n    if ( rayDir.x != 0.0 )\n    {\n        float k1 = maxODiff.x * invDir.x;\n        float k2 = minODiff.x * invDir.x;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.yz, boxMin.yz, boxMax.yz) == hitPt.yz )\n            {\n                norm = vec3 (-1.0, 0.0, 0.0);\n\t\t        finalK = k1;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.yz, boxMin.yz, boxMax.yz) == hitPt.yz )\n            {\n                norm = vec3 (1.0, 0.0, 0.0);\n\t\t        finalK = k2;\n            }\n        }\n    }\n    if ( rayDir.y != 0.0 )\n    {\n        float k1 = maxODiff.y * invDir.y;\n        float k2 = minODiff.y * invDir.y;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.xz, boxMin.xz, boxMax.xz) == hitPt.xz )\n            {\n                norm = vec3 (0.0, -1.0, 0.0);\n\t\t        finalK = k1;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.xz, boxMin.xz, boxMax.xz) == hitPt.xz )\n            {\n                norm = vec3 (0.0, 1.0, 0.0);\n\t\t        finalK = k2;\n            }\n        }\n    }\n    if ( rayDir.z != 0.0 )\n    {\n        float k1 = maxODiff.z * invDir.z;\n        float k2 = minODiff.z * invDir.z;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.xy, boxMin.xy, boxMax.xy) == hitPt.xy )\n            {\n                norm = vec3 (0.0, 0.0, -1.0);\n\t\t        finalK = k1;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.xy, boxMin.xy, boxMax.xy) == hitPt.xy )\n            {\n                norm = vec3 (0.0, 0.0, 1.0);\n\t\t        finalK = k2;\n            }\n        }\n    }\n}\n\nvoid intersectPlaneWithYHole (vec3 rayOrigin, vec3 rayDir, float y, vec2 holeXZ, float holeRad, inout float finalK, inout vec3 norm)\n{\n    if ( rayDir.y == 0.0 ) return ;\n    float lineK = (y - rayOrigin.y) / rayDir.y;\n    if ( lineK < finalK && lineK == clamp (lineK, 0.0, 1.0) )\n    {\n        vec3 hitPt = rayOrigin + rayDir * lineK;\n        vec3 toHoleCentDiff = hitPt - vec3 (holeXZ.x, y, holeXZ.y);\n        if ( dot (toHoleCentDiff, toHoleCentDiff) >= holeRad*holeRad )\n        {\n\t        finalK = lineK;\n\t        norm = vec3 (0.0, -1.0, 0.0);\n        }\n    }\n}\n\nvoid rayCylinderWithYAmount (vec3 rayOrigin, vec3 rayDir, vec2 cylinderXZ, vec2 bottomTopY, float cylinderRad, inout float finalK, inout vec3 norm)\n{\n    rayOrigin.xz -= cylinderXZ;\n    float A = rayDir.x * rayDir.x + rayDir.z * rayDir.z;\n    float B = 2.0 * rayOrigin.x * rayDir.x + 2.0 * rayOrigin.z * rayDir.z;\n    float C = rayOrigin.x * rayOrigin.x + rayOrigin.z * rayOrigin.z - cylinderRad * cylinderRad;\n    float q2 = (B * B) - (4.0 * A * C);\n    if ( q2 < 0.0 ) return ;\n    float inv2A = 1.0 / (2.0 * A);\n    float k1 = (-B + sqrt (q2)) * inv2A;\n    float k2 = (-B - sqrt (q2)) * inv2A;\n    bool k1IsGood = (k1 < finalK && k1 == clamp (k1, 0.0, 1.0));\n    bool k2IsGood = (k2 < finalK && k2 == clamp (k2, 0.0, 1.0));\n    if ( k1IsGood || k2IsGood )\n    {\n        float candidateK;\n        if ( k1IsGood && k2IsGood )\n        {\n            candidateK = min (k1,k2);\n        }\n        else if ( k1IsGood && !k2IsGood )\n        {\n            candidateK = k1;\n        }\n        else if ( !k1IsGood && k2IsGood )\n        {\n            candidateK = k2;\n        }\n        vec3 hitPt = rayOrigin + rayDir * candidateK;\n        if ( hitPt.y >= bottomTopY.x && hitPt.y <= bottomTopY.y )\n        {\n\t\t\tfinalK = candidateK;\n            norm = normalize (-vec3 (hitPt.x, 0.0, hitPt.z));\n        }\n    }\n}\n\nmat4 rotationMatrix(vec3 axis, float cosA, float sinA) {\n    float s = sinA;\n    float c = cosA;\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float cosA, float sinA) {\n\tmat4 m = rotationMatrix(axis, cosA, sinA);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat PHG (float g, float cosTheta)\n{\n    float Inv4Pi = 1.0 / (4.0 * M_PI);\n\tfloat gSq = g * g;\n\tfloat denomPreMul = max (abs (1.0 + gSq - (2.0 * g * cosTheta)), 0.00001);\n\treturn (1.0 - gSq) * Inv4Pi * inversesqrt(denomPreMul * denomPreMul * denomPreMul);\n}\n\nfloat miePhase (float cosTheta)\n{\n\treturn mix (PHG (0.8, cosTheta), PHG (-0.5, cosTheta), 0.5);\n}\n\nvoid LineMap (vec3 l1, vec3 rayDir, inout float minK, inout vec3 norm)\n{\n    intersectBox (l1, rayDir, vec3 (-3.0, -1.0, -5.0), vec3 (3.0, 10.0, 3.25), minK, norm);\n    intersectPlaneWithYHole (l1, rayDir, 1.2, vec2 (0.0, 2.0), 0.17, minK, norm);\n    intersectPlaneWithYHole (l1, rayDir, 0.8, vec2 (0.0, 2.0), 0.5, minK, norm);\n    intersectPlaneWithYHole (l1, rayDir, 0.7, vec2 (0.0, 2.0), 0.5, minK, norm);\n    rayCylinderWithYAmount (l1, rayDir, vec2 (0.0, 2.0), vec2 (0.7, 0.8), 0.5, minK, norm);\n\n    mat3 invTran1, invTran2, invTran3;\n    invTran1[0] = rotate (vec3 (1.0, 0.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, 0.30901699437);\n    invTran1[1] = rotate (vec3 (0.0, 1.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, 0.30901699437);\n    invTran1[2] = vec3 (0.0, 0.0, 1.0);\n    invTran2[0] = rotate (vec3 (1.0, 0.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, -0.30901699437);\n    invTran2[1] = rotate (vec3 (0.0, 1.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, -0.30901699437);\n    invTran2[2] = vec3 (0.0, 0.0, 1.0);\n    invTran3[0] = rotate (vec3 (1.0, 0.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.5, 0.86602540378);\n    invTran3[1] = rotate (vec3 (0.0, 1.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.5, 0.86602540378);\n    invTran3[2] = vec3 (0.0, 0.0, 1.0);\n    vec3 ySwing = vec3 (0.0, sin(iTime), 0.0) * 0.3;\n    vec3 trans1 = vec3 (-0.04, 0.04, 2.0) + ySwing;\n    vec3 trans2 = vec3 (0.06, 0.04, 2.0) + ySwing;\n    vec3 trans3 = vec3 (-0.14, -0.04, 2.0) + ySwing;\n    vec3 trans4 = vec3 (-0.1, -0.095, 1.87) + ySwing;\n    vec3 trans5 = vec3 (-0.1, -0.095, 2.13) + ySwing;\n    vec3 trans6 = vec3 (0.12, -0.15, 1.87) + ySwing;\n    vec3 trans7 = vec3 (0.12, -0.15, 2.13) + ySwing;\n    \n    float saveMinK;\n    saveMinK = minK;\n    intersectBox (invTran1 * (l1 - trans1), invTran1 * rayDir, vec3 (-0.075, -0.05, -0.15), vec3 (0.075, 0.05, 0.15), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;     // Flip the normal as it is inside as per the proc. above\n        norm *= invTran1; // With an orthonormal basis, transpose == inverse, so we can mul. by invTran\n    }\n    saveMinK = minK;\n    intersectBox (invTran2 * (l1 - trans2), invTran2 * rayDir, vec3 (-0.075, -0.05, -0.15), vec3 (0.075, 0.05, 0.15), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n        norm *= invTran2;\n    }\n    saveMinK = minK;\n    intersectBox (invTran3 * (l1 - trans3), invTran3 * rayDir, vec3 (-0.05, -0.05, -0.05), vec3 (0.05, 0.05, 0.05), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n        norm *= invTran3;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans4, rayDir, vec3 (-0.025, -0.15, -0.025), vec3 (0.025, 0.15, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans5, rayDir, vec3 (-0.025, -0.15, -0.025), vec3 (0.025, 0.15, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans6, rayDir, vec3 (-0.025, -0.2, -0.025), vec3 (0.025, 0.2, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans7, rayDir, vec3 (-0.025, -0.2, -0.025), vec3 (0.025, 0.2, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 finalColor = vec3 (0.0);\n    float timeSwing = sin (iTime * 1.125) + 3.0;\n    float timeSwing2 = (sin (iTime * 0.5) + 1.0) * 0.5 + 1.5;\n    vec3 curEye = vec3 (0.0, 0.0, 2.0) + vec3 (sin(timeSwing) * timeSwing2, -0.9, cos(timeSwing) * timeSwing2);\n    vec3 curLook = normalize (vec3 (0.0, 0.0, 2.0) - curEye);\n    vec3 curUp = vec3 (0.0, 1.0, 0.0);\n    vec3 curSide = normalize (cross (curLook, curUp));\n    curUp = cross (curSide, curLook);\n    if ( curUp.y < 0.0 ) curUp = -curUp;\n    vec3 sampleDirNorm = normalize (curLook + curSide * uv.x + curUp * uv.y);\n    float sampleDirLen = 0.05 * _2dNoise (uv);\n    vec3 sampleDir = sampleDirNorm * sampleDirLen;\n    \n    float minK = 2.0;\n    vec3 norm = vec3 (0.0);\n    float drawDist = 100.0;\n    vec3 sampleDirBig = sampleDirNorm * drawDist;\n    LineMap (curEye, sampleDirBig, minK, norm);\n    if ( minK == 2.0 )\n    {\n\t\tfragColor = vec4 (0.0);\n        return ;\n    }\n    float distToWall = (minK * drawDist) / sampleDirLen;\n    int nSteps = int(distToWall) + 1;\n    \n    vec3 mapHitPt = curEye + sampleDirBig * minK;\n    \n    vec3 toRedGreenLight = vec3 (-0.5, 0.0, 2.0) - mapHitPt;\n    vec3 toBlueGreenLight = vec3 (0.5, 0.0, 2.0) - mapHitPt;\n    float toRedGreenLightLen = length (toRedGreenLight);\n    float toBlueGreenLightLen = length (toBlueGreenLight);\n    vec3 toRedGreenLightNorm = toRedGreenLight / toRedGreenLightLen;\n    vec3 toBlueGreenLightNorm = toBlueGreenLight / toBlueGreenLightLen;\n    \n    float redLightIntensity = max (dot(toRedGreenLightNorm, norm), 0.0) * clamp (1.0 - toRedGreenLightLen/2.0, 0.0, 1.0);\n    float blueLightIntensity = max (dot(toBlueGreenLightNorm, norm), 0.0) * clamp (1.0 - toBlueGreenLightLen/2.0, 0.0, 1.0);\n    float fakeLightIntensity = 8.0 / SCATTERING_COEF;\n    finalColor += blueLightIntensity * vec3 (0.0, 0.1, 0.1) * fakeLightIntensity;\n    finalColor += redLightIntensity * vec3 (0.1, 0.1, 0.0) * fakeLightIntensity;\n    finalColor += clamp (4.0/distToWall, 0.0, 1.0) * vec3 (fakeLightIntensity);\n\n    float mediumDensity = 0.1; // Don't touch this. Since the secondary lighting is fake, it'll mess with perception.\n\tfloat scat = 1.0;\n\n    for (int jj = 0; jj != nSteps; jj++)\n    {\n        vec3 samplePt = curEye + float(jj) * sampleDir;\n\n        vec3 sumLightContrib = vec3 (0.0);\n        for (int i = 0; i != 3; i++)\n        {\n\t\t    vec3 lightPos, lightColor;\n            if ( i == 0 )\n            {\n                lightPos = vec3 (-0.1, 2.0, 2.0);\n                lightColor = vec3 (0.0, 0.0, 1.0);\n            }\n            else if ( i == 1 )\n            {\n                lightPos = vec3 (0.0, 2.0, 2.0);\n                lightColor = vec3 (0.0, 1.0, 0.0);\n            }\n            else\n            {\n                lightPos = vec3 (0.1, 2.0, 2.0);\n                lightColor = vec3 (1.0, 0.0, 0.0);\n            }\n\n            vec3 toLightDir = lightPos-samplePt;\n            float toLightLen = length (toLightDir);\n            vec3 toLightNorm = toLightDir / toLightLen;\n\n            float toLightHitMinK = 2.0;\n            vec3 toLightHitNorm = vec3 (0.0);\n            LineMap (samplePt, toLightDir, toLightHitMinK, toLightHitNorm);\n            if ( toLightHitMinK == 2.0 )\n            {\n                float atten = clamp (1.0/toLightLen, 0.0, 1.0) * 2500.0;\n                float evalLightDensity = exp (-mediumDensity * EXTINCTION_COEF * toLightLen) * atten;\n                sumLightContrib += lightColor * evalLightDensity * miePhase (dot (toLightNorm, sampleDirNorm));\n            }\n        }\n\n        vec3 lightScattering = mediumDensity * SCATTERING_COEF * sumLightContrib;\n        float toViewerExtinction = exp(-mediumDensity * EXTINCTION_COEF * sampleDirLen);\n        vec3 curScatteringIntegral = (lightScattering - lightScattering * toViewerExtinction) / max (mediumDensity * EXTINCTION_COEF, 0.000001);\n\n        finalColor += scat * curScatteringIntegral;\n\n        scat *= toViewerExtinction;\n        if ( scat < 0.01 ) break;\n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}