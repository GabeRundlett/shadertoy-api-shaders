{
    "Shader": {
        "info": {
            "date": "1551225288",
            "description": "Was one of my first shadertoys and experiment with SDFs though I never published. \n\nMaking it public now because why not?",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlfzB",
            "likes": 18,
            "name": "Doughnut Box",
            "published": 3,
            "tags": [
                "doughnut"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "const float NearClip         = 0.0;\nconst float FarClip          = 150.0;\nconst float Epsilon          = 0.0001;\nconst vec3  AmbientLight     = vec3(0.8);\nconst float SoftShadowFactor = 1024.0;\nconst float SoftShadowOffset = 0.3;\nconst uint  MultiSamples     = 4u;\n\nconst float PiUnderOne       = 0.31830988;\nconst float PiTwoUnderOne    = 0.15915494;\n\nconst vec3 PinkColor         = vec3(1.0, 0.40, 0.65);\nconst vec3 ChocolateColor    = vec3(0.415, 0.207, 0.085);\n\nconst vec3 SprinkleColors[3] = vec3[](\n    vec3(0.0, 1.0, 1.0),\n    vec3(0.7, 1.0, 0.0),\n    vec3(0.5, 0.0, 0.9));\n\nuint PRNGSeed = 1337u;\n\nvec3 BoxOrigin = vec3(0.0);\nconst float TimeLimit = 8.0;\n\n//------------------------------------------------------------------------------------------\n// Misc Math Functions\n//------------------------------------------------------------------------------------------\n\n/**\n * if(a > b) { return ra; } else { return rb; }\n */\nvec3 StepValue(float a, float b, vec3 ra, vec3 rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\n//------------------------------------------------------------------------------------------\n// Noise\n//------------------------------------------------------------------------------------------\n\n/**\n * Naive PRNG seeding function.\n */\nvoid Seed(vec2 coord)\n{\n    coord = abs(coord);\n    \n    float x = floor(coord.x * 1000.0);\n    float y = floor(coord.y * 1000.0);\n    \n    //PRNGSeed = uint(floor(length(coord) * 100.0));\n    PRNGSeed = uint((x * 63.0) + (y * 84.0));\n}\n\n/**\n * XorShift32 PRNG\n * Adapted from: https://github.com/ssell/noisegen/blob/master/scripts/noise.js\n *\n * \\return PRNG value on range [-1.0, 1.0]\n */\nfloat NoiseXorShift32()\n{\n    uint x = PRNGSeed;\n    \n    x = x ^ (x << 13u);\n    x = x ^ (x >> 17u);\n    x = x ^ (x << 5u);\n    \n    PRNGSeed = x;\n    \n    return (float(x % 200u) - 100.0) * 0.01;\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n  \tvec3  surfPos;\n    vec3  surfNorm;\n    float material;\n};\n\n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// Model Torus\n//------------------------------------------------------------------------------------------\n\nstruct ModelTorus\n{\n    vec3  origin;\n    float radius;\n    float thickness;\n};\n    \nfloat Torus_SDF(vec3 point, ModelTorus t)\n{\n    vec2 q = vec2(length(point.xz - t.origin.xz) - t.radius, point.y - t.origin.y);\n    return length(q) - t.thickness;\n}\n\n\n//------------------------------------------------------------------------------------------\n// Model Ellipsoid\n//------------------------------------------------------------------------------------------\n\nstruct ModelEllipsoid\n{\n    vec3 origin;\n    vec3 radius;\n};\n    \nfloat Ellipsoid_SDF(vec3 point, ModelEllipsoid e)\n{\n    return (length((point - e.origin) / e.radius) - 1.0) * min(min(e.radius.x, e.radius.y), e.radius.z);\n}\n\n//------------------------------------------------------------------------------------------\n// Model Box\n//------------------------------------------------------------------------------------------\n\nstruct ModelBox\n{\n    vec3 origin;\n    vec3 bounds;\n};\n    \nfloat Box_SDF(vec3 point, ModelBox box)\n{\n\treturn length(max(abs(point - box.origin) - box.bounds, 0.0));   \n}\n\n//------------------------------------------------------------------------------------------\n// Sprinkles\n//------------------------------------------------------------------------------------------\n\nfloat Sprinkle_SDF(vec3 point, float i, float a, float y, ModelTorus doughnut, ModelEllipsoid sprinkle)\n{\n    float sR = doughnut.radius + (doughnut.thickness * 0.5 * i);\n    vec3  sOrigin = doughnut.origin + vec3(sR * sin(a), y, sR * cos(a));\n    \n    sprinkle.origin = sOrigin;\n    \n    NoiseXorShift32();\n    \n    return Ellipsoid_SDF(point, sprinkle);\n}\n\nfloat Sprinkles_SDF(vec3 point, float s, ModelTorus doughnut, inout float material)\n{\n    float final = s;\n    float sdf = s;\n    \n    Seed(vec2(1337.0, 797.0));\n    \n    ModelEllipsoid sprinkle;\n    sprinkle.radius = vec3(0.35, 0.075, 0.075);\n    \n    for(float angle = 0.0; angle < 6.20; angle += 0.5)\n    {\n        sdf = Sprinkle_SDF(point,  0.0, angle, 1.85, doughnut, sprinkle);\n        material = StepValue(sdf, final, material, (8.0 + float(PRNGSeed % 3u)));\n        final = min(final, sdf);\n        \n        sdf = Sprinkle_SDF(point,  1.0, angle, 1.55, doughnut, sprinkle);\n        material = StepValue(sdf, final, material, (8.0 + float(PRNGSeed % 3u)));\n        final = min(final, sdf);\n        \n        sdf = Sprinkle_SDF(point, -1.0, angle, 1.55, doughnut, sprinkle);\n        material = StepValue(sdf, final, material, (8.0 + float(PRNGSeed % 3u)));\n        final = min(final, sdf);\n    }\n    \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Scene Structures and Functions\n//------------------------------------------------------------------------------------------\n\nfloat Doughnuts_SDF(vec3 point, inout RayHit hit, float shadow)\n{\n    float final = FarClip;\n    float sdf   = FarClip;\n    float time  = mod(iTime, TimeLimit);\n    \n    time *= step(time, TimeLimit - 2.0);\n    \n    ModelTorus doughnutA;\n    doughnutA.origin    = vec3(0.0);\n    doughnutA.radius    = 4.0;\n    doughnutA.thickness = 1.75;\n    \n    ModelEllipsoid doughnutB;\n    doughnutB.radius = vec3(5.75, 3.5, 5.75);\n    \n    doughnutA.origin = vec3(-12.0, 1.75, 0.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 1.5));\n    hit.material = StepValue(sdf, final, hit.material, 0.0);\n    final = min(final, sdf);\n    \n    doughnutA.origin = vec3(-12.0, 1.75, 12.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 2.0));\n    hit.material = StepValue(sdf, final, hit.material, 1.0);\n    final = min(final, sdf);\n    \n    doughnutB.origin = vec3(0.0, 1.75, 0.0);\n    sdf = Ellipsoid_SDF(point, doughnutB) + (FarClip * step(time, 2.5));\n    hit.material = StepValue(sdf, final, hit.material, 2.0);\n    final = min(final, sdf);\n    \n    doughnutB.origin = vec3(0.0, 1.0, 12.0);\n    sdf = Ellipsoid_SDF(point, doughnutB) + (FarClip * step(time, 3.0));\n    hit.material = StepValue(sdf, final, hit.material, 3.0);\n    final = min(final, sdf);\n    \n    doughnutA.origin = vec3(12.0, 1.75, 0.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 3.5));\n    hit.material = StepValue(sdf, final, hit.material, 5.0);\n    final = min(final, sdf);\n    \n    doughnutA.origin = vec3(12.0, 1.75, 12.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 4.0));\n    hit.material = StepValue(sdf, final, hit.material, 4.0);\n    final = min(final, sdf);\n    \n    if(sdf > Epsilon && sdf < 0.5 && shadow < Epsilon)\n    {\n    \tfinal = min(final, Sprinkles_SDF(point, final, doughnutA, hit.material));\n    }\n    \n    return final;\n}\n\nconst vec3 BoxOrigins[10] = vec3[](\n    vec3(   0.0, -89.9,    6.0),  vec3(  0.0, -0.1,  6.0),   // Bottom\n    vec3(-108.0,   2.4,    6.0),  vec3(-18.0,  2.4,  6.0),   // Left\n    vec3( 108.0,   2.4,    6.0),  vec3( 18.0,  2.4,  6.0),   // Right\n    vec3(   0.0,   2.4, -107.95), vec3(  0.0,  2.4, -7.95),  // Back\n     vec3(  0.0,   2.4,  109.95), vec3(  0.0,  2.4, 19.95)   // Front\n    );\n\nconst vec3 BoxBounds[5] = vec3[](\n    vec3(17.95, 0.1, 13.95),\n    vec3(0.05, 2.6, 14.0),\n    vec3(0.05, 2.6, 14.0),\n    vec3(18.0, 2.6, 0.05),\n    vec3(18.0, 2.6, 0.05)\n    );\n\nfloat DoughnutBoxBottom_SDF(vec3 point, inout RayHit hit)\n{\n    float sdf  = FarClip;\n    float lerp = clamp((mod(iTime, TimeLimit) * 0.85f), 0.0, 1.0);\n    \n    // Box Base\n    \n    ModelBox box;\n    \n    box.origin = mix(BoxOrigins[0], BoxOrigins[1], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[0];\n    \n    sdf = Box_SDF(point, box);\n    \n    if(sdf < Epsilon)\n    {\n    \thit.material = 7.0;\n        return sdf;\n    }\n    \n    // Box Left Side\n    \n    box.origin = mix(BoxOrigins[2], BoxOrigins[3], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[1];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Right Side\n    \n    box.origin = mix(BoxOrigins[4], BoxOrigins[5], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[2];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Back Side\n    \n    box.origin = mix(BoxOrigins[6], BoxOrigins[7], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[3];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Front Side\n    \n    box.origin = mix(BoxOrigins[8], BoxOrigins[9], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[4];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    hit.material = StepValue(sdf, Epsilon, hit.material, 6.0);\n    \n    return sdf;\n}\n\nfloat DoughnutBoxTop_SDF(vec3 point, inout RayHit hit)\n{\n    float sdf = FarClip;\n    vec3 offset = BoxOrigin + mix(vec3(0.0, 90.0, 0.0), vec3(0.0, 1.0, 0.0), clamp((mod(iTime, TimeLimit) - 4.0) * 0.65, 0.0, 1.0));\n    \n    // Box Top\n    \n    ModelBox box;\n    \n    box.origin = BoxOrigins[1] + vec3(0.0, 5.0, 0.0) + offset;\n    box.bounds = BoxBounds[0];\n    \n    sdf = Box_SDF(point, box);\n    \n    // Box Left Side\n    \n    box.origin = BoxOrigins[3] + offset;\n    box.bounds = BoxBounds[1];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Right Side\n    \n    box.origin = BoxOrigins[5] + offset;\n    box.bounds = BoxBounds[2];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Back Side\n    \n    box.origin = BoxOrigins[7] + offset;\n    box.bounds = BoxBounds[3];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Front Side\n    \n    box.origin = BoxOrigins[9] + offset;\n    box.bounds = BoxBounds[4];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    hit.material = StepValue(sdf, Epsilon, hit.material, 6.0);\n    \n    return sdf;\n}\n\n/**\n * Performs SDF test for the entire scene.\n * The scene is defined within this function and follows the pattern of:\n *\n *     - Test SDF of Object 0\n *         - If SDF 0 < Nearest Hit\n *         - Set RayHit nearest and position\n *         - Calculate RayHit normal for Object 0\n *     - Test SDF of Object 1\n *         - If SDF 1 < Nearest Hit\n *         - Set RayHit nearest and position\n *         - Calculate RayHit normal for Object 1\n *     - Continue for rest of Scene Objects\n */\nfloat Scene_SDF(vec3 point, inout RayHit hit, float shadow)\n{\n    float sdf = FarClip;\n    \n    float doughnutsSDF = Doughnuts_SDF(point, hit, shadow);\n    float boxBottomSDF = DoughnutBoxBottom_SDF(point, hit);\n    float boxTopSDF    = DoughnutBoxTop_SDF(point, hit);\n    \n    sdf = min(sdf, min(doughnutsSDF, min(boxBottomSDF, boxTopSDF)));\n    \n    return sdf;\n}\n\n/**\n * Calculates the normal of a given surface point.\n *\n * In essence it tests multiple points around the surface and uses those SDF\n * values to generate a normal vector.\n *\n * For example, if SDF(vec3(x + e, y, z)) is smaller than SDF(vec3(x - e, y, z))\n * then we know vec3(x + e, y, z) lies further within the surface and thus opposite\n * of the normal's x-component.\n */\nvec3 Scene_Normal(vec3 point)\n{\n    RayHit hit;\n\n\treturn normalize(vec3(\n        (Scene_SDF(vec3(point.x + Epsilon, point.y, point.z), hit, 0.0) - Scene_SDF(vec3(point.x - Epsilon, point.y, point.z), hit, 0.0)),\n        (Scene_SDF(vec3(point.x, point.y + Epsilon, point.z), hit, 0.0) - Scene_SDF(vec3(point.x, point.y - Epsilon, point.z), hit, 0.0)),\n        (Scene_SDF(vec3(point.x, point.y, point.z + Epsilon), hit, 0.0) - Scene_SDF(vec3(point.x, point.y, point.z - Epsilon), hit, 0.0))));\n}\n\n//------------------------------------------------------------------------------------------\n// Light Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct LightDirectional\n{\n    vec3 color;\n\tvec3 direction;  \n};\n    \nstruct LightPoint\n{\n  \tvec3 color;\n    vec3 position;\n    vec3 attenuation;\n};\n\n/**\n * Calculates the shadow factor on range [0.0, 1.0] for the given surface and light point.\n *\n * To determine if our light source is being occluded by scene geometry, we simply march\n * through the scene as we would for calculating the geometry SDF values.\n *\n * The only difference is that instead of using a ray originating from our camera, we\n * instead use a ray being projected from the light source.\n *\n * If our Scene_SDF returns a hit, then we know the light projecting from the point\n * onto the surface is occluded and in shadow.\n *\n * \\param[in] surfPos     Surface position to calculate the shadow factor for.\n * \\param[in] lightOrigin Origin of the light source.\n *\n * \\return Shadow factor value on range [0.0, 1.0]\n */\nfloat CalculateShadow(vec3 surfPos, vec3 lightOrigin)\n{\n    RayHit hit;\n    \n    float result   = 1.0;\n    vec3  lightRay = normalize(surfPos - lightOrigin);\n    \n    for(float depth = NearClip; depth < FarClip - Epsilon; )\n    {\n    \tvec3  point = (lightOrigin + (lightRay * depth));\n        float sdf   = Scene_SDF(point, hit, 1.0);\n        \n        if(sdf < Epsilon)\n        {\n            return 0.0;\n        }\n        \n        // https://iquilezles.org/articles/rmshadows\n        result = min(result, (SoftShadowFactor * sdf) / depth);\n        \n        depth += sdf;\n    }\n    \n    return result;\n}\n\nvec3 CalculatePhongBRDF(\n    vec3  surfNorm, \n    vec3  toLight, \n    vec3  toView, \n    vec3  diffColor,\n    vec3  specColor,\n    float roughness)\n{\n    vec3  diffuse   = diffColor * PiUnderOne;\n    float halfAngle = dot(normalize(-toLight + toView), surfNorm);\n    float schlick   = (halfAngle / (roughness - (roughness * halfAngle) + halfAngle));\n    vec3  specular  = ((roughness + 2.0) * PiTwoUnderOne) * specColor * schlick;\n\n    return (diffuse + specular);\n}\n\nvec3 CalculateDynamicLight(\n    vec3  surfPos,\n    vec3  surfNorm,\n    vec3  toView,\n    vec3  lightDir,\n    vec3  lightColor,\n    vec3  diffColor,\n    vec3  specColor,\n    float roughness)\n{\n    vec3  origin   = surfPos + (lightDir * (FarClip + SoftShadowOffset));\n    float shadow   = CalculateShadow(surfPos, origin);\n    vec3  brdf     = CalculatePhongBRDF(surfNorm, -lightDir, toView, diffColor, specColor, roughness);\n    float cosAngle = clamp(dot(surfNorm, lightDir), 0.0, 1.0);\n    \n    return (lightColor * brdf * shadow * cosAngle);\n}\n\n/**\n * Calculates total lighting (including shadows) for the given surface.\n */\nvec3 CalculateLighting(\n    vec3 surfPos, \n    vec3 surfNorm, \n    vec3 toView,\n    vec3 diffColor,\n    vec3 specColor, \n    float roughness)\n{\n    vec3 dynamicLighting = vec3(0.0, 0.0, 0.0);\n    \n    LightDirectional light;\n    \n    light.color     = vec3(0.85, 0.85, 0.8);\n    light.direction = normalize(vec3(1.0, 1.0, -0.8));\n    \n    dynamicLighting += CalculateDynamicLight(surfPos, surfNorm, toView, light.direction, light.color, diffColor, specColor, roughness);\n\n    return (AmbientLight + dynamicLighting * 1.25);\n}\n\n//------------------------------------------------------------------------------------------\n// Material Structures and Functions\n//------------------------------------------------------------------------------------------\n\n/**\n * Applies the base doughnut material.\n * The base material consists of:\n *\n *     * Base color\n *     * Middle lighter ring due to frying\n *     * Noise for texture\n */\nvec3 Material_DoughnutBase(vec3 surfNorm)\n{\n    // Base doughnut color\n    vec3 color = vec3(0.9637, 0.6853, 0.2904);\n    \n    // Color of the lighter ring due to frying on each side\n    vec3 centerColor = color + vec3(0.03, 0.10, 0.10);\n    \n    // Calculate the relative surface y-angle. We clamp to [-0.25, 0.25] where the value is cos(angle)\n    float angle = max(min(dot(surfNorm, vec3(0.0, 1.0, 0.0)), 0.25), -0.25);\n    \n    // Interpolate to the center ring color\n    color  = mix(centerColor, color, abs(angle * 4.0));\n   // color += vec3(0.025, 0.025, 0.025) * NoiseXorShift32();\n    \n    return color;\n}\n\nvec3 Material_Powdered(vec3 surfPos, vec3 base)\n{\n    Seed(surfPos.xz);\n    \n    float powderChance = step(0.0, NoiseXorShift32() + 0.85);\n    vec3  powderColor  = vec3(1.0 - (NoiseXorShift32() + 1.0) * 0.01) * powderChance;\n    \n    return max(base, powderColor);\n}\n\nvec3 Material_Jelly(vec3 surfPos, vec3 surfNorm, vec3 base)\n{\n    Seed(surfPos.xz); \n    \n    float angle = dot(vec2(0.0, surfNorm.y), vec2(0.0, 1.0)) * 1.75 - 0.75;\n    \n    float powderChance = step(0.0, NoiseXorShift32() + angle);\n    vec3  powderColor  = vec3(1.0 - (NoiseXorShift32() + 1.0) * 0.01) * powderChance;\n    \n    return max(base, powderColor);\n}\n\nvec3 Material_Frosted(vec3 surfNorm, vec3 base, vec3 color, float crests, inout float r)\n{\n    /** \n     * Here we calculate the surfNorm.y angle that the frosting begins at.\n     *\n     * We have a baseline angle of 0.3 (remember this is angle=acos(dot(surfNorm, vec3(0,1,0))).\n     * Then we modulate up and down (via cos) 8 times around the doughnut and \n     * the angle varies between 0.2 and 0.4.\n     *\n     *     (a) Convert surfNorm.xz to an angle where ( 1.0,  0.0) -> 0, 2pi       (think graph with axis X/Z)\n     *                                               ( 0.0,  1.0) -> pi/2\n     *                                               (-1.0,  0.0) -> pi\n     *                                               ( 0.0, -1.0) -> 3pi/2\n     *     (b) Modulate 8 times over the full circle\n     *     (c) Vary angle (surfNorm.y) by +/- 0.1\n     *\n     *     angle = 0.30 - cos((a) * (b)) * (c)\n     */\n    \n    float angle = 0.30 - cos(acos(dot(normalize(surfNorm.xz), vec2(1.0, 0.0))) * crests) * 0.1;\n    float iced  = step(angle, dot(surfNorm, vec3(0.0, 1.0, 0.0)));\n    \n    r = 4.0 * iced;\n    \n    return StepValue(iced, Epsilon, color, base);\n}\n\nvec3 Material_Stripes(vec3 surfPos, vec3 surfNorm, vec3 base, vec3 color, inout float r)\n{\n    float iced    = step(1.0, r);\n    float striped = step(0.65, cos(surfPos.z * 6.0) * iced);  // 0.65 = stripe thickness; 6.0 = stripe count\n    \n    return StepValue(striped, 0.65, color, base);\n}\n\nvec3 Material_Glazed(vec3 base, inout float r)\n{\n    r = 0.0;\n    return base;\n}\n\nvec3 Material_BoxInterior()\n{\n    return vec3(0.9, 0.9, 0.9);\n}\n\nvec3 Material_BoxExterior()\n{\n    return vec3(1.0, 0.84, 0.94);\n}\n\nvec3 Material_Apply(in RayHit hit, vec3 toView)\n{\n    vec3 color = SprinkleColors[int(clamp(hit.material - 8.0, 0.0, 2.0))];\n    float r = -2.0;\n    \n    if(hit.material < Epsilon)      // Powdered \n    {\n        color = Material_Powdered(hit.surfPos, Material_DoughnutBase(hit.surfNorm));\n    }\n    else if(hit.material < 1.1) // Chocolate Frosted w/ White Stripes\n    {\n        color = Material_Frosted(hit.surfNorm, Material_DoughnutBase(hit.surfNorm), ChocolateColor, 8.0, r);\n    \tcolor = Material_Stripes(hit.surfPos, hit.surfNorm, color, vec3(0.985, 0.877, 0.755), r);\n    }\n    else if(hit.material < 2.1) // ?\n    {\n        color = Material_DoughnutBase(hit.surfNorm);\n        color = Material_Frosted(hit.surfNorm, color, ChocolateColor, 4.0, r);\n    }\n    else if(hit.material < 3.1) // Jelly\n    {\n        color = Material_DoughnutBase(hit.surfNorm);\n        color = Material_Jelly(hit.surfPos, hit.surfNorm, color);\n    }\n    else if(hit.material < 4.1) // Pink Frosted w/ Sprinkles\n    {\n        color = Material_Frosted(hit.surfNorm, Material_DoughnutBase(hit.surfNorm), PinkColor, 10.0, r);\n    }\n    else if(hit.material < 5.1) // Glazed\n    {\n        color = Material_Glazed(Material_DoughnutBase(hit.surfNorm), r);\n    }\n    else if(hit.material < 6.1) // Box Exterior\n    {\n        color = Material_BoxExterior();\n    } \n    else if(hit.material < 7.1) // Box Interor\n    {\n        color = Material_BoxInterior();\n    }\n    \n    vec3 lighting = CalculateLighting(hit.surfPos, hit.surfNorm, toView, color, vec3(1.0), r);\n    \n    return lighting * color;\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\n/**\n * Basic Raymarching using SDF objects.\n *\n * For each raymarch step we:\n *\n *     - Find distance to nearest object along the ray\n *         - If distance <= 0, we are on or inside the object\n *         - If distance > 0, we are outside the object and must continue\n *           along the ray for a length of distance to find the next closest object.\n */\nRayHit RaymarchScene(in Ray ray)\n{\n    RayHit hit;\n    \n    hit.hit      = false;\n    hit.material = 0.0;\n    \n    float sdf = FarClip;\n    \n    for(float depth = NearClip; depth < FarClip; )\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos, hit, 0.0);\n        \n        if(sdf < Epsilon)\n        {\n            hit.hit      = true;\n            hit.surfPos  = pos;\n            hit.surfNorm = Scene_Normal(pos);\n            \n            return hit;\n        }\n        \n        // Continue along the ray to look for the next nearest object\n        depth += sdf;\n    }\n    \n    return hit;\n}\n\nvec3 Render(vec2 fragCoord, Camera camera)\n{\n    vec3 final = vec3(0.3, 0.3, 0.3);\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    Seed(uv);\n    \n    Ray    ray = Camera_GetRay(camera, uv);\n    RayHit hit = RaymarchScene(ray);\n    \n    if(hit.hit)\n    {\n        final.rgb = Material_Apply(hit, normalize(camera.origin - hit.surfPos));\n    }\n    \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nconst vec2 SampleCoords[4] = vec2[](\n    vec2(0.0, 0.5),\n    vec2(0.5, 0.0),\n    vec2(0.0, -0.5),\n    vec2(-0.5, 0.0));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    BoxOrigin = mix(vec3(0.0), vec3(0.0, 0.0, 70.0), clamp((mod(iTime, TimeLimit) - 6.0) * 0.75, 0.0, 1.0));\n    \n    // Angled\n    vec3 camPos = vec3(40.0, 35.0, 30.0);\n    Camera camera = Camera_LookAt(camPos, vec3(0.0, 0.0, 6.0));\n    \n    // Looking down\n    //vec3 camPos = vec3(0.0, 35.0, 5.9);\n    //Camera camera = Camera_LookAt(camPos, vec3(0.0, 0.0, 6.0));\n    \n    fragColor.rgb = Render(fragCoord, camera);\n    \n    for(uint i = 0u; i < MultiSamples; ++i)\n    {\n        fragColor.rgb += Render(fragCoord + SampleCoords[i], camera);\n    }\n    \n    fragColor.rgb /= (float(MultiSamples) + 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}