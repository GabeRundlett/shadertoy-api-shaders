{
    "Shader": {
        "info": {
            "date": "1488524540",
            "description": "Pine-style wood shader. Experimenting with some new noise functions... Not sure they're the best for this, but good enough.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldscDM",
            "likes": 51,
            "name": "Wood Shader Toy",
            "published": 3,
            "tags": [
                "procedural",
                "wood",
                "material",
                "train",
                "pine"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 2228
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 22.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat fade = 1.0;\nfloat exposure = 1.0;\nvec3 poofPos = vec3(0.0);\nfloat poofCycle = 0.0;\n\n// lighting vars\nvec3 sunDir = normalize(vec3(0.93, 1.0, 1.0));\nconst vec3 sunCol = vec3(250.0, 220.0, 200.0) / 3555.0;\nconst vec3 horizonCol = vec3(0.95, 0.95, 0.95)*1.3;\nconst vec3 skyCol = vec3(0.13,0.28,0.95);\nconst vec3 groundCol = vec3(0.003,0.7,0.75);\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n// noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 3D, Seed 1, Waves 128, Octaves 7, Smooth 1\nfloat NoiseGen(vec3 p) {\n    // This is a bit faster if we use 2 accumulators instead of 1.\n    // Timed on Linux/Chrome/TitanX Pascal\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec3(-1.316, 0.918, 1.398))) * 0.0783275458;\n    wave1 += sin(dot(p, vec3(0.295, -0.176, 2.167))) * 0.0739931495;\n    wave0 += sin(dot(p, vec3(-0.926, 1.445, 1.429))) * 0.0716716966;\n    wave1 += sin(dot(p, vec3(-1.878, -0.174, 1.258))) * 0.0697839187;\n    wave0 += sin(dot(p, vec3(-1.995, 0.661, -0.908))) * 0.0685409863;\n    wave1 += sin(dot(p, vec3(-1.770, 1.350, -0.905))) * 0.0630152419;\n    wave0 += sin(dot(p, vec3(2.116, -0.021, 1.161))) * 0.0625361712;\n    wave1 += sin(dot(p, vec3(0.405, -1.712, -1.855))) * 0.0567751048;\n    wave0 += sin(dot(p, vec3(1.346, 0.945, 1.999))) * 0.0556465603;\n    wave1 += sin(dot(p, vec3(-0.397, -0.573, 2.495))) * 0.0555747667;\n    wave0 += sin(dot(p, vec3(0.103, -2.457, -1.144))) * 0.0516322279;\n    wave1 += sin(dot(p, vec3(-0.483, -1.323, 2.330))) * 0.0513093320;\n    wave0 += sin(dot(p, vec3(-1.715, -1.810, -1.164))) * 0.0504567036;\n    wave1 += sin(dot(p, vec3(2.529, 0.479, 1.011))) * 0.0500811899;\n    wave0 += sin(dot(p, vec3(-1.643, -1.814, -1.437))) * 0.0480875812;\n    wave1 += sin(dot(p, vec3(1.495, -1.905, -1.648))) * 0.0458268348;\n    wave0 += sin(dot(p, vec3(-1.874, 1.559, 1.762))) * 0.0440084357;\n    wave1 += sin(dot(p, vec3(1.068, -2.090, 2.081))) * 0.0413624154;\n    wave0 += sin(dot(p, vec3(-0.647, -2.197, -2.237))) * 0.0401592830;\n    wave1 += sin(dot(p, vec3(-2.146, -2.171, -1.135))) * 0.0391682940;\n    wave0 += sin(dot(p, vec3(2.538, -1.854, -1.604))) * 0.0349588163;\n    wave1 += sin(dot(p, vec3(1.687, 2.191, -2.270))) * 0.0342888847;\n    wave0 += sin(dot(p, vec3(0.205, 2.617, -2.481))) * 0.0338465332;\n    wave1 += sin(dot(p, vec3(3.297, -0.440, -2.317))) * 0.0289423448;\n    wave0 += sin(dot(p, vec3(1.068, -1.944, 3.432))) * 0.0286404261;\n    wave1 += sin(dot(p, vec3(-3.681, 1.068, 1.789))) * 0.0273625684;\n    wave0 += sin(dot(p, vec3(3.116, 2.631, -1.658))) * 0.0259772492;\n    wave1 += sin(dot(p, vec3(-1.992, -2.902, -2.954))) * 0.0245830241;\n    wave0 += sin(dot(p, vec3(-2.409, -2.374, 3.116))) * 0.0245592756;\n    wave1 += sin(dot(p, vec3(0.790, 1.768, 4.196))) * 0.0244078334;\n    wave0 += sin(dot(p, vec3(-3.289, 1.007, 3.148))) * 0.0241328015;\n    wave1 += sin(dot(p, vec3(3.421, -2.663, 3.262))) * 0.0199736126;\n    wave0 += sin(dot(p, vec3(3.062, 2.621, 3.649))) * 0.0199230290;\n    wave1 += sin(dot(p, vec3(4.422, -2.206, 2.621))) * 0.0192399437;\n    wave0 += sin(dot(p, vec3(2.714, 3.022, 4.200))) * 0.0182510631;\n    wave1 += sin(dot(p, vec3(-0.451, 4.143, -4.142))) * 0.0181293526;\n    wave0 += sin(dot(p, vec3(-5.838, -0.360, -1.536))) * 0.0175114826;\n    wave1 += sin(dot(p, vec3(-0.278, -4.565, 4.149))) * 0.0170799341;\n    wave0 += sin(dot(p, vec3(-5.893, -0.163, -2.141))) * 0.0167655258;\n    wave1 += sin(dot(p, vec3(4.855, -4.153, 0.606))) * 0.0163155335;\n    wave0 += sin(dot(p, vec3(4.498, 0.987, -4.488))) * 0.0162770287;\n    wave1 += sin(dot(p, vec3(-1.463, 5.321, -3.315))) * 0.0162569125;\n    wave0 += sin(dot(p, vec3(-1.862, 4.386, 4.749))) * 0.0154338176;\n    wave1 += sin(dot(p, vec3(0.563, 3.616, -5.751))) * 0.0151952226;\n    wave0 += sin(dot(p, vec3(-0.126, 2.569, -6.349))) * 0.0151089405;\n    wave1 += sin(dot(p, vec3(-5.094, 4.759, 0.186))) * 0.0147947096;\n    wave0 += sin(dot(p, vec3(1.319, 5.713, 3.845))) * 0.0147035221;\n    wave1 += sin(dot(p, vec3(7.141, -0.327, 1.420))) * 0.0140573910;\n    wave0 += sin(dot(p, vec3(3.888, 6.543, 0.547))) * 0.0133309850;\n    wave1 += sin(dot(p, vec3(-1.898, -3.563, -6.483))) * 0.0133171360;\n    wave0 += sin(dot(p, vec3(1.719, 7.769, 0.340))) * 0.0126913718;\n    wave1 += sin(dot(p, vec3(-2.210, -7.836, 0.102))) * 0.0123746071;\n    wave0 += sin(dot(p, vec3(6.248, -5.451, 1.866))) * 0.0117861898;\n    wave1 += sin(dot(p, vec3(1.627, -7.066, -4.732))) * 0.0115417453;\n    wave0 += sin(dot(p, vec3(4.099, -7.704, 1.474))) * 0.0112591564;\n    wave1 += sin(dot(p, vec3(7.357, 3.788, 3.204))) * 0.0112252325;\n    wave0 += sin(dot(p, vec3(-2.797, 6.208, 6.253))) * 0.0107206906;\n    wave1 += sin(dot(p, vec3(6.130, -5.335, -4.650))) * 0.0105693992;\n    wave0 += sin(dot(p, vec3(5.276, -5.576, -5.438))) * 0.0105139072;\n    wave1 += sin(dot(p, vec3(9.148, 2.530, -0.383))) * 0.0103996383;\n    wave0 += sin(dot(p, vec3(3.894, 2.559, 8.357))) * 0.0103161113;\n    wave1 += sin(dot(p, vec3(-6.604, 8.024, -0.289))) * 0.0094066875;\n    wave0 += sin(dot(p, vec3(-5.925, 6.505, -6.403))) * 0.0089444733;\n    wave1 += sin(dot(p, vec3(9.085, 10.331, -0.451))) * 0.0069245599;\n    wave0 += sin(dot(p, vec3(-8.228, 6.323, -9.900))) * 0.0066251015;\n    wave1 += sin(dot(p, vec3(10.029, -3.802, 12.151))) * 0.0058122824;\n    wave0 += sin(dot(p, vec3(-10.151, -6.513, -11.063))) * 0.0057522358;\n    wave1 += sin(dot(p, vec3(-1.773, -16.284, 2.828))) * 0.0056578101;\n    wave0 += sin(dot(p, vec3(11.081, 8.687, -9.852))) * 0.0054614334;\n    wave1 += sin(dot(p, vec3(-3.941, -4.386, 16.191))) * 0.0054454253;\n    wave0 += sin(dot(p, vec3(-6.742, 2.133, -17.268))) * 0.0050050132;\n    wave1 += sin(dot(p, vec3(-10.743, 5.698, 14.975))) * 0.0048323955;\n    wave0 += sin(dot(p, vec3(-9.603, 12.472, 14.542))) * 0.0043264378;\n    wave1 += sin(dot(p, vec3(13.515, 14.345, 8.481))) * 0.0043208884;\n    wave0 += sin(dot(p, vec3(-10.330, 16.209, -9.742))) * 0.0043013736;\n    wave1 += sin(dot(p, vec3(-8.580, -6.628, 19.191))) * 0.0042005922;\n    wave0 += sin(dot(p, vec3(-17.154, 10.620, 11.828))) * 0.0039482427;\n    wave1 += sin(dot(p, vec3(16.330, 14.123, -10.420))) * 0.0038474789;\n    wave0 += sin(dot(p, vec3(-21.275, 10.768, -3.252))) * 0.0038320501;\n    wave1 += sin(dot(p, vec3(1.744, 7.922, 23.152))) * 0.0037560829;\n    wave0 += sin(dot(p, vec3(-3.895, 21.321, 12.006))) * 0.0037173885;\n    wave1 += sin(dot(p, vec3(-22.705, 2.543, 10.695))) * 0.0036484394;\n    wave0 += sin(dot(p, vec3(-13.053, -16.634, -13.993))) * 0.0036291121;\n    wave1 += sin(dot(p, vec3(22.697, -11.230, 1.417))) * 0.0036280459;\n    wave0 += sin(dot(p, vec3(20.646, 14.602, 3.400))) * 0.0036055008;\n    wave1 += sin(dot(p, vec3(5.824, -8.717, -23.680))) * 0.0035501527;\n    wave0 += sin(dot(p, vec3(6.691, 15.499, 20.079))) * 0.0035029508;\n    wave1 += sin(dot(p, vec3(9.926, -22.778, 9.144))) * 0.0034694278;\n    wave0 += sin(dot(p, vec3(-9.552, -27.491, 2.197))) * 0.0031359281;\n    wave1 += sin(dot(p, vec3(21.071, -17.991, -11.566))) * 0.0030453280;\n    wave0 += sin(dot(p, vec3(9.780, 1.783, 28.536))) * 0.0030251754;\n    wave1 += sin(dot(p, vec3(8.738, -18.373, 22.725))) * 0.0029960272;\n    wave0 += sin(dot(p, vec3(14.105, 25.703, -8.834))) * 0.0029840058;\n    wave1 += sin(dot(p, vec3(-24.926, -17.766, -4.740))) * 0.0029487709;\n    wave0 += sin(dot(p, vec3(1.060, -1.570, 32.535))) * 0.0027980099;\n    wave1 += sin(dot(p, vec3(-24.532, -19.629, -16.759))) * 0.0025538949;\n    wave0 += sin(dot(p, vec3(28.772, -21.183, -9.935))) * 0.0024494819;\n    wave1 += sin(dot(p, vec3(-28.413, 22.959, 8.338))) * 0.0024236674;\n    wave0 += sin(dot(p, vec3(-27.664, 22.197, 13.301))) * 0.0023965996;\n    wave1 += sin(dot(p, vec3(-27.421, 20.643, 18.713))) * 0.0023203498;\n    wave0 += sin(dot(p, vec3(18.961, -7.189, 35.907))) * 0.0021967023;\n    wave1 += sin(dot(p, vec3(-23.949, 4.885, 33.762))) * 0.0021727461;\n    wave0 += sin(dot(p, vec3(35.305, 8.594, 20.564))) * 0.0021689816;\n    wave1 += sin(dot(p, vec3(30.364, -11.608, -27.199))) * 0.0021357139;\n    wave0 += sin(dot(p, vec3(34.268, 26.742, 0.958))) * 0.0020807976;\n    wave1 += sin(dot(p, vec3(-26.376, -17.313, -32.023))) * 0.0020108850;\n    wave0 += sin(dot(p, vec3(31.860, -32.181, -2.834))) * 0.0019919601;\n    wave1 += sin(dot(p, vec3(25.590, 32.340, 21.381))) * 0.0019446179;\n    wave0 += sin(dot(p, vec3(-17.771, -23.941, 37.324))) * 0.0018898258;\n    wave1 += sin(dot(p, vec3(-38.699, 19.953, -22.675))) * 0.0018379538;\n    wave0 += sin(dot(p, vec3(-46.284, 11.672, -15.411))) * 0.0017980056;\n    wave1 += sin(dot(p, vec3(-32.023, -43.976, -7.378))) * 0.0016399251;\n    wave0 += sin(dot(p, vec3(-42.390, -21.165, -31.889))) * 0.0015752176;\n    wave1 += sin(dot(p, vec3(-18.949, -40.461, 39.107))) * 0.0015141244;\n    wave0 += sin(dot(p, vec3(-21.507, -5.939, -58.531))) * 0.0014339601;\n    wave1 += sin(dot(p, vec3(-51.745, -43.821, 9.651))) * 0.0013096306;\n    wave0 += sin(dot(p, vec3(39.239, 25.971, -52.615))) * 0.0012701774;\n    wave1 += sin(dot(p, vec3(-49.669, -35.051, -36.306))) * 0.0012661695;\n    wave0 += sin(dot(p, vec3(-49.996, 35.309, 38.460))) * 0.0012398870;\n    wave1 += sin(dot(p, vec3(27.000, -65.904, -36.267))) * 0.0011199347;\n    wave0 += sin(dot(p, vec3(-52.523, -26.557, 57.693))) * 0.0010856391;\n    wave1 += sin(dot(p, vec3(-42.670, 0.269, -71.125))) * 0.0010786551;\n    wave0 += sin(dot(p, vec3(-9.377, 64.575, -68.151))) * 0.0009468199;\n    wave1 += sin(dot(p, vec3(14.571, -29.160, 106.329))) * 0.0008019719;\n    wave0 += sin(dot(p, vec3(-21.549, 103.887, 36.882))) * 0.0007939609;\n    wave1 += sin(dot(p, vec3(-42.781, 110.966, -9.070))) * 0.0007473261;\n    wave0 += sin(dot(p, vec3(-112.686, 18.296, -37.920))) * 0.0007409259;\n    wave1 += sin(dot(p, vec3(71.493, 33.838, -96.931))) * 0.0007121903;\n    return wave0+wave1;\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir, float sunFilter)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*(40.0 + 110.0 * sunFilter))*7000.0;\n\tsunIntensity = min(sunIntensity, 8000.0);\n\treturn sunCol * sunIntensity*0.2;\n}\n\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir, float sunFilter)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir, sunFilter);\n    return finalColor;\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// https://iquilezles.org/articles/distfunctions\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nfloat cyl(vec3 p, float rad)\n{\n    return length(p.xy) - rad;\n}\n\nfloat cylcap(vec3 p, float rad, float lenrad)\n{\n    return max(abs(p.z) - lenrad, length(p.xy) - rad);\n}\n\nfloat sSphere(vec3 p, float rad)\n{\n    return length(p) - rad;\n}\n\nvec3 RepeatOffset(vec3 a, float len)\n{\n    return fract(a+vec3(-0.5, 0.0, 0.0)) - 0.5 * len;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface, a material index,\n// and the difference between the iceberg distance and the water distance.\nvec2 DistanceToObject(vec3 p)\n{\n    float dist;\n\n    vec3 lp = p + vec3(0.0, 1.5, 0.0);\n    dist = sdBox(lp, vec3(1.75, 0.2, 0.5));\n    dist = max(dist, (lp.x + lp.y)*0.72 - 1.1);\n    dist = min(dist, cylcap(p.zyx + vec3(0.0, 0.85, -0.2), 0.45, 1.15));\n    dist = min(dist, sdBox(p + vec3(1.5, 0.5, 0.0), vec3(0.5, 0.75, 0.5)));\n    dist = max(dist, -cyl(p + vec3(1.6, 0.25, 0.0), 0.25));\n    dist = min(dist, cylcap(p.zxy + vec3(0.0, -0.6, 0.0), 0.2, 0.5));\n    dist = min(dist, cylcap(p.zxy + vec3(0.0, 0.25, 0.3), 0.15, 0.35));\n    dist = min(dist, sdBox(p + vec3(1.4, -0.3, 0.0), vec3(0.8, 0.1, 0.6)));\n\n    float table = sdBox(p + vec3(0.0, 2.125, 0.0), vec3(46.0, 0.1, 6.0));\n    vec2 distAndMat = matmin(vec2(table, 1.0), vec2(dist, 0.0));\n\n    vec3 mirror = abs(p + vec3(0.4, 1.5, 0.0)) + vec3(-1.0, 0.0, -0.7);\n    dist = cylcap(mirror, 0.5, 0.1);\n    dist = min(dist, cylcap(mirror, 0.125, 0.15));\n    vec2 wheels = vec2(dist, 2.0);\n    distAndMat = matmin(distAndMat, wheels);\n\n    dist = length(p + poofPos) - (0.2 + poofCycle*0.5);\n    distAndMat = matmin(distAndMat, vec2(dist, 3.0));\n\n    return distAndMat;\n}\n\nfloat repramp(float x) {\n\treturn pow(sin(x)*0.5+0.5, 8.0) + cos(x)*0.7 + 0.7;\n}\n\nvec3 TraceOneRay(vec3 camPos, vec3 rayVec, out vec3 normal, out vec2 distAndMat, out float t) {\n    normal = vec3(0.0);\n    distAndMat = vec2(0.0, -1.0);  // Distance and material\n    vec3 finalColor = vec3(0.0);\n\t// ----------------------------- Ray march the scene ------------------------------\n\tt = 0.0;\n\tconst float maxDepth = 32.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = 250; i >= 0; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // move down the ray a safe amount\n        t += distAndMat.x;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        normal = normalize(normalU);\n\n        // calculate ambient occlusion values.\n        float ambientS = 1.0;\n        vec2 distAndMatA = DistanceToObject(pos + normal * 0.4);\n        ambientS *= saturate(distAndMatA.x*2.5);\n        distAndMatA = DistanceToObject(pos + normal * 0.8);\n        ambientS *= saturate(distAndMatA.x*1.25);\n        ambientS = max(0.05, ambientS);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.1;\n\t\tfor (int i = 0; i < 20; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*20.0);\n            if (tempDist <= 0.0) break;\n            iter += max(0.05, tempDist);\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.0);\n        if (distAndMat.y == 2.0) {\n\t\t    vec3 mirror = pos + vec3(0.4, 1.5, 0.0) + vec3(-1.0, 0.0, -0.7);\n            mirror.xz = RepeatOffset((pos + vec3(0.4, 1.5, 0.0)) + vec3(-1.0, 0.0, -0.7), 1.0).xz;\n            pos = RotateZ(mirror, -localTime/(PI/4.0));\n        }\n        if (distAndMat.y == 1.0) pos = pos.yxz + vec3(20.0, 2.0+localTime, 0.0);\n        if (distAndMat.y == 3.0) {\n            pos += poofPos;\n\t        pos.xzy = pos;\n        }\n\n        // Wood shader\n        float rings = repramp(length(pos.xz + vec2(NoiseGen(pos*vec3(8.0, 1.5, 8.0)), NoiseGen(-pos*vec3(8.0, 1.5, 8.0)+4.5678))*0.05)*64.0) / 1.8;\n        rings -= NoiseGen(pos *1.0)*0.75;\n        texColor = mix(vec3(0.3, 0.19, 0.075)*0.95, vec3(1.0, 0.73, 0.326)*0.4, rings)*1.5;\n        texColor = max(vec3(0.0), texColor);\n        float rough = (NoiseGen(pos*64.0*vec3(1.0, 0.2, 1.0))*0.1+0.9);\n        texColor *= rough;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(14.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\n        lightColor += skyCol * ((normal.y) * 0.5 + 0.5) * 0.5 * ambientS;\n\n        // apply the light to the texture.\n        finalColor = texColor * lightColor;\n        finalColor *= 2.0;\n\n        // specular highlight\n        finalColor += GetEnvMap(ref + rough*0.5, sunDir, 0.0)*0.005 * (0.5 - rings*0.5) * sunShadow * rough;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = vec3(1.0)*ambientS;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw background.\n        finalColor =vec3(0.9);\n    }\n    return finalColor;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    fade = 1.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 3.0;  // zoom in\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*9.0;\n#else\n    // Repeat the animation after time t3\n    float time = localTime *0.25;\n    camPos = vec3(0.0, 0.4, 8.0);\n    camPos.x = sin(time)*7.0;\n    camPos.y += (-cos(time*2.0)+1.0)*4.0;\n    camPos.z = cos(time)*7.0;\n    camUp=vec3(0,1,0);\n    camLookat=vec3(0,-0.5,0.5);\n#endif\n\n    // ---- animation ----\n    poofCycle = fract(localTime*0.25);\n    poofPos = -vec3(0.6 - poofCycle*poofCycle*12.0, poofCycle * 4.0 + 0.5, 0.0);\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n    vec3 normal;\n    vec2 distAndMat;\n    float t;\n    vec3 finalColor = TraceOneRay(camPos, rayVec, normal, distAndMat, t);\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}