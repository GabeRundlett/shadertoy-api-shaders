{
    "Shader": {
        "info": {
            "date": "1570645390",
            "description": "A reproduction of the cover of the first album by Blue Oyster Cult.\n\nBasic mouse interaction.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdyGzV",
            "likes": 23,
            "name": "Blue Oyster Cult ",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarch",
                "metal",
                "rock",
                "reproduction",
                "classicmetal"
            ],
            "usePreview": 0,
            "username": "crocidb",
            "viewed": 835
        },
        "renderpass": [
            {
                "code": "// Anti aliasing. Change to 2 or more for better graphics, but slooooow performance.\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n\n\n#define MAX_STEPS 250\n#define MAX_DIST 50.0\n#define SURF_DIST .001\n\nconst vec3 camera_pos = vec3(0.0, 0.0, 0.3);\nconst vec3 light_pos = vec3(-2.5, 5.5, -4.0);\n\n#define OBJ_EMPTY 0\n#define OBJ_BASE 1\n#define OBJ_TOP 2\n#define OBJ_DOOR 3\n\nstruct object\n{\n    float d;\n    int id;\n};\n    \nobject closest(object o1, object o2)\n{\n    if (o1.d < o2.d)\n        return o1;\n    \n    return o2;\n}\n\nfloat distRoom(vec3 p, vec3 s)\n{\n    float room = sdBox(p - vec3(0.0, -4.0, 0.0), s);\n    return room;\n}\n\nfloat distRooms(vec3 p, vec3 s)\n{\n    vec3 c = vec3(0.999, 0.0, 1.5);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return distRoom(q, s);\n}\n\nobject distBase(vec3 p)\n{\n    float base = sdBox(p - vec3(-10.0, -4.0, 5.0), vec3(100.0, 3.0, 60.0));\n    float room = distRooms(p, vec3(0.33, 3.0, 0.55));\n    \n    base = opSmoothSubtraction(room, base, 0.03);\n    \n    return object(base, OBJ_BASE);\n}\n\nobject distTop(vec3 p)\n{\n    float base = sdBox(p - vec3(-10.0, -1.0, 5.0), vec3(100.0, 0.05, 60.0));\n    float room = distRooms(p, vec3(0.28, 4.0, 0.50));\n    \n    base = opSmoothSubtraction(room, base, 0.03);\n    \n    return object(base, OBJ_TOP);\n}\n\nobject distDoor(vec3 p)\n{\n    p = p - vec3(0.0, -1.4, 3.65);\n    vec3 c = vec3(1.03, 0.0, 1.5);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    \n    float door = sdBox(q, vec3(0.08, 0.2, 0.1));\n    \n    return object(door, OBJ_DOOR);\n}\n\nobject distDoorBase(vec3 p)\n{\n    p = p - vec3(0.0, -1.4, 3.65);\n    vec3 c = vec3(1.03, 0.0, 1.5);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    \n    float base = sdBox(q, vec3(0.11, 0.23, 0.12));\n    float doorSub = sdBox(q, vec3(0.08, 0.2, 0.2));\n\n    \n    base = opSmoothSubtraction(doorSub, base, 0.006);\n    \n    return object(base, OBJ_TOP);\n}\n\nobject getDist(vec3 p) \n{\n    object base = distBase(p);\n    object top = distTop(p);\n\tobject door = distDoor(p);\n    object doorBase = distDoorBase(p);\n\n    return closest(closest(closest(base, top), door), doorBase);\n}\n\nobject rayMarch(vec3 ro, vec3 rd)\n{\n    object obj;\n    obj.id = OBJ_EMPTY;\n    obj.d = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * obj.d;\n        object o = getDist(p);\n        \n        obj.d += o.d;\n        obj.id = o.id;\n        \n        if (obj.d > MAX_DIST || o.d < SURF_DIST) break;\n    }\n    \n    return obj;\n}\n\n// Auxiliar functions\nvec3 getNormal(vec3 p)\n{\n    object o = getDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = o.d - vec3(\n        getDist(p - e.xyy).d,\n        getDist(p - e.yxy).d,\n        getDist(p - e.yyx).d);\n    \n\treturn normalize(n);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURF_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt)\n\t{\n\t\tobject o = getDist(p0 + rd * t);\n\n\t\tif(o.d < SURF_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.d / t);\n\n\t\tt += o.d;\n\t}\n\n\treturn f;\n}\n\nvec3 lighting(vec3 n, vec3 rd, vec3 pos, float spec_power)\n{\n    vec3 light_dir = normalize(light_pos - pos);\n    float light_intensity = 0.5;\n    \n    vec3 refd = reflect(rd, n);\n    float diff = max(0.0, dot(light_dir, n));\n    float spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n    float rim = (1.0 - max(0.0, dot(-n, rd)));\n    \n    vec3 l = vec3(diff, spec, rim);\n    \n    return l * .8 + (l * light_intensity * 2.0); \n}\n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.004f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tobject obj = getDist(p + n * t);\n\t\toc += t - obj.d;\n\t\tt += float(i * i) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nvec3 getSky(vec2 uv)\n{\n    float n = fbm(uv * 250.0);\n    \n    n = smoothstep(0.6, 0.65, n);\n    \n    return vec3(n);\n}\n\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\nvec3 baseTexture(vec2 uv)\n{\n    uv *= 360.0;\n    uv.y *= 0.01;\n    float n = smoothstep(0.1, 1.0, noise(uv));\n    return vec3(n);\n}\n\nvec3 baseMaterial(vec3 pos, vec3 n)\n{\n    pos += vec3(.2);\n    pos *= 0.4;\n    n = abs(n);\n    vec3 t0 = baseTexture(triplanar(pos, n));\n    return t0;\n}\n\nvec3 doorTexture(vec2 uv)\n{\n    uv *= 340.0;\n    uv.y *= 0.01;\n    float n = smoothstep(0.0, 0.7, mod(uv.x, 1.0));\n\n    return vec3(n);\n}\n\nvec3 doorMaterial(vec3 pos, vec3 n)\n{\n    pos += vec3(.2);\n    pos *= 0.4;\n    n = abs(n);\n    vec3 t0 = doorTexture(triplanar(pos, n));\n    return t0;\n}\n\nvec3 topTexture(vec2 uv)\n{\n    uv.x += .52;\n    uv.y += .829;\n\n    uv.x *= 5.0;\n    uv.y *= 3.34;\n\n    float len = 0.015;\n\tfloat val = max(smoothstep(0.03, len, mod(uv.x, 2.0)), smoothstep(0.03, len, mod(uv.y, 2.0)));\n    return vec3((1.0 - val) * .7 + .3);\n}\n\nvec3 topMaterial(vec3 pos, vec3 n)\n{\n    pos += vec3(.2);\n    pos *= 0.4;\n    n = abs(n);\n    vec3 t0 = topTexture(triplanar(pos, n));\n    return t0;\n}\n\nvec3 render(object o, vec3 p, vec3 ro, vec3 rd, vec2 suv)\n{\n    vec3 normal = getNormal(p);\n    float shadow = getVisibility(p, light_pos, 50.0);\n    vec3 l = lighting(normal, rd, p, 55.0);\n    float ao = ambientOcclusion(p, normal);\n    \n    if (o.id == OBJ_EMPTY || o.d > MAX_DIST)\n    {\n        return getSky(suv - vec2(0.0, iTime * .0007));\n    }\n    else if (o.id == OBJ_BASE)\n    {\n        vec3 t = vec3(.4) * baseMaterial(p, normal);\n        vec3 c = ao * ((t * .5) + (l.r * t * shadow * .8) + l.g + (l.b * .1 * shadow));\n        return c;\n    }\n    else if (o.id == OBJ_DOOR)\n    {\n        vec3 t = vec3(.7) * doorMaterial(p, normal);\n        vec3 c = ao * ((t * .5) + (l.r * t * shadow * .8) + l.g + (l.b * .1 * shadow));\n        return c;\n    }\n    else if (o.id == OBJ_TOP)\n    {\n        vec3 t = vec3(.6) * topMaterial(p, normal);\n        vec3 c = ao * ((t * .5) + (l.r * t * shadow * .8) + l.g + (l.b * .1 * shadow));\n        return c;\n    }\n    \n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = camera_pos;\n    ro.xy += ((iMouse.xy / iResolution.xy) - vec2(.5)) * 0.2;\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p,2.0) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = normalize( vec3(px,2.0) );\n        vec3 rdy = normalize( vec3(py,2.0) );\n        \n        // render\t\n        object obj = rayMarch(ro, rd);\n        vec3 p2 = ro + rd * obj.d;\n\n        vec3 col = clamp(render(obj, p2, ro, rd, uv), vec3(0.0), vec3(1.0));\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    tot = tot * .9 + .1;\n    \n    float size = 1.6 + sin(PI_2 * cos(iTime * .3)) * .6;\n    \n    float mask = clamp((1.0 - pow(length(uv * size), 120.0)), 0.0, 1.0);\n    float border = pow(abs(length(uv * (size - .02))), 120.0);\n    \n    fragColor = vec4(tot, 1.0) * mask + (1.0 - mask) * vec4(1.0) * border;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Math\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) \n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\n// Noise\n\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Primitives\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}