{
    "Shader": {
        "info": {
            "date": "1584640460",
            "description": "Lagrangian mechanics for a double pendulum, with numerical solution of the Euler-Lagrange equation.\n\n#define ORBIT in common to see elliptical orbit.\n\nShader based on [url]https://github.com/matthewarcus/lagrange[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "tdlyWr",
            "likes": 26,
            "name": "Lagrangian Mechanics",
            "published": 3,
            "tags": [
                "mechanics",
                "lagrangian"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 643
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Lagrangian Mechanics\n//\n// Matthew Arcus, 2020\n//\n// Double pendulum, simulated by direct numeric solution of Euler-Lagrange\n// equations.\n//\n// Uncomment #define of ORBIT in Common to see elliptical orbit.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = 2.0*fragCoord.xy/iResolution.y;\n  vec3 col = vec3(1);\n  float colwidth = 0.025;\n\n  if (uv.x < 5.0*colwidth) {\n    vec4 ev = texelFetch(iChannel1,ivec2(0,2),0);\n    float etot = dot(ev,vec4(1));\n    bool incolumn = false;\n    if (uv.x < 1.0*colwidth) incolumn = uv.y < etot;\n    else if (uv.x < 2.0*colwidth) incolumn = uv.y < 0.5+ev.x/etot;\n    else if (uv.x < 3.0*colwidth) incolumn = uv.y < 0.5+ev.y/etot;\n    else if (uv.x < 4.0*colwidth) incolumn = uv.y < 0.5+ev.z/etot;\n    else incolumn = uv.y < 0.5+ev.w/etot;\n    if (incolumn) col = vec3(0);\n  } else {\n    vec4 dv = texelFetch(iChannel1,ivec2(fragCoord),0);\n    col = vec3(smoothstep(0.0,0.01,dv.x));\n    // Proper screen coordinates\n    uv -= iResolution.xy/iResolution.y;\n    uv *= scale;\n    // Get pv values\n    vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n    // and coordinates\n    vec4 coords = getcoords(pv.xy,pv.zw);\n    vec2 p0 = vec2(0), p1 = coords.zw, p2 = coords.xy;\n    float d = min(segment(uv,p0,p1),segment(uv,p1,p2));\n    col = mix(vec3(0),col,smoothstep(0.0,0.01,d));\n    d = min(distance(uv,p0),min(distance(uv,p1),distance(uv,p2)));\n    col = mix(vec3(1,0,0),col,smoothstep(0.02,0.03,d));\n  }\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x), j = int(uv.y); // Texel coordinates\n  t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state     \n  if (i == 0 && j == 0) {\n    if (iFrame == 0) {\n      t = initpv;\n    } else {\n      // Get last p,v and last time..\n      vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n      vec4 tv = texelFetch(iChannel1,ivec2(0,1),0);\n      // .. and update\n      t = lagrange(pv.xy,pv.zw,iTime-tv.x);\n    }\n  } else if (i == 0 && j == 1) {\n    // Store last time and screen resolution\n    t = vec4(iTime,0,iResolution.xy);\n  } else if (i == 0 && j == 2) {\n    // Output energy values.\n    vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n    t = E(pv.xy,pv.zw);\n  } else if (iFrame == 0 || texelFetch(iChannel1,ivec2(0,1),0).zw != iResolution.xy) {\n    // If first frame or screensize has changed, reset min distance.\n    t = vec4(1e8);\n  } else {\n    // Otherwise, update minimum distance to current coords\n    uv = (2.0*uv-iResolution.xy)/iResolution.y;\n    uv *= scale;\n    vec4 pv = texelFetch(iChannel1,ivec2(0,0),0);\n    vec4 coords = getcoords(pv.xy,pv.zw);\n    t.x = min(t.x,distance(uv,coords.xy));\n    t.y = min(t.y,distance(uv,coords.zw));\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define ORBIT //Uncomment for an elliptical orbit.\n//#define QUALITY  //Uncomment for more accuracy, slower compilation\nconst float PI = 3.14159;\nconst float scale = 1.1;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\nfloat point(vec2 p, vec2 q) {\n  return distance(p,q);\n}\n\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  vec2 pa = p-q;\n  vec2 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// The Maths\n////////////////////////////////////////////////////////////////////////////////\n\n// The energy function for the Lagrangian\nvec4 E(vec2 p, vec2 v);\n\nfloat L(vec2 p, vec2 v) {\n  vec4 e = E(p,v);\n  float ke0 = e.x,ke1 = e.y,pe0 = e.z,pe1 = e.w;\n  return (ke0+ke1)-(pe0+pe1);\n}\n\n// Using Richardson & fixed step Runge-Kutta gives reasonable\n// accuracy, but slower compilation.\n// Variable step RK doesn't always help.\n#if defined QUALITY\n#define pdiffLp pdiffLp1\n#define pdiffLv pdiffLv1\n#define derivs derivs1\n#else\n#define pdiffLp pdiffLp0\n#define pdiffLv pdiffLv0\n#define derivs derivs0\n#endif\n#define step rk4\n//#define step rk4var\n//#define step single\n\n// Basic partial differentiation wrt p.\nfloat pdiffLp0(vec2 p, vec2 v, int i,float eps) {\n  float pi = p[i];\n  p[i] = pi-eps;\n  float x0 = L(p,v);\n  p[i] = pi+eps;\n  float x1 = L(p,v);\n  p[i] = pi;\n  return (x1-x0)/(2.0*eps);\n}\n\nfloat pdiffLv0(vec2 p, vec2 v, int i,float eps) {\n  float vi = v[i];\n  v[i] = vi-eps;\n  float x0 = L(p,v);\n  v[i] = vi+eps;\n  float x1 = L(p,v);\n  v[i] = vi;\n  return (x1-x0)/(2.0*eps);\n}\n\n// Richardson extrapolation\nfloat pdiffLv1(vec2 p, vec2 v,int i,float eps) {\n  float d1 = pdiffLv0(p,v,i,eps);\n  float d2 = pdiffLv0(p,v,i,2.0*eps);\n  return d1+(d1-d2)/3.0;\n}\n\nfloat pdiffLp1(vec2 p, vec2 v,int i,float eps) {\n  float d1 = pdiffLp0(p,v,i,eps);\n  float d2 = pdiffLp0(p,v,i,2.0*eps);\n  return d1+(d1-d2)/3.0;\n}\n\n// NB: this modifies parameters p and v\nvoid evaluate(inout vec2 p, inout vec2 v, float eps);\n\n// Time derivatives\nvoid derivs0(vec2 p, vec2 v, out vec2 dp, out vec2 dv, float eps) {\n  vec2 p1 = p, v1 = v;\n  vec2 p2 = p, v2 = v;\n  evaluate(p1,v1,eps);\n  evaluate(p2,v2,-eps);\n  dp[0] = (p1[0]-p2[0])/(2.0*eps);\n  dp[1] = (p1[1]-p2[1])/(2.0*eps);\n  dv[0] = (v1[0]-v2[0])/(2.0*eps);\n  dv[1] = (v1[1]-v2[1])/(2.0*eps);\n}\n\n// It's that Richardson again.\n// https://en.wikipedia.org/wiki/Lewis_Fry_Richardson\nvoid derivs1(vec2 p, vec2 v, out vec2 dp, out vec2 dv, float eps) {\n  vec2 p1,p2,v1,v2;\n  derivs0(p,v,p1,v1,eps);\n  derivs0(p,v,p2,v2,2.0*eps);\n  dp[0] = p1[0] + (p1[0]-p2[0])/3.0;\n  dp[1] = p1[1] + (p1[1]-p2[1])/3.0;\n  dv[0] = v1[0] + (v1[0]-v2[0])/3.0;\n  dv[1] = v1[1] + (v1[1]-v2[1])/3.0;\n}\n\n// d(df/dxj)/dxi - components of Hessian (Jacobian for PDs).\nfloat hessian(int i,int j,vec2 p,vec2 v,float eps) {\n  //return pdiffHess(function(a) { return pdiff(f,a,j,eps);}, a,i,eps);\n  float vi = v[i];\n  v[i] = vi-eps;\n  float x0 = pdiffLv(p,v,j,eps);\n  v[i] = vi+eps;\n  float x1 = pdiffLv(p,v,j,eps);\n  v[i] = vi;\n  return (x1-x0)/(2.0*eps);\n}\n\n// Vector of partial derivs\nvec2 pdiffsLp(vec2 p,vec2 v,float eps) {\n  return vec2(pdiffLp(p,v,0,eps),pdiffLp(p,v,1,eps));\n}\n\nvec2 pdiffsLv(vec2 p,vec2 v,float eps) {\n  return vec2(pdiffLv(p,v,0,eps),pdiffLv(p,v,1,eps));\n}\n\nvoid single(inout vec2 p, inout vec2 v, float dt, float eps) {\n  vec2 dp,dv;\n  derivs(p,v,dp,dv,eps);\n  p[0] += dt*dp[0];\n  p[1] += dt*dp[1];\n  v[0] += dt*dv[0];\n  v[1] += dt*dv[1];\n}\n\nvoid rk4(inout vec2 p, inout vec2 v, float dt, float eps) {\n  vec2 p1, v1,p2,v2,p3,v3,p4,v4;\n  derivs(p,v,p1,v1,eps);\n  derivs(p+0.5*dt*p1,\n         v+0.5*dt*v1,\n         p2,v2,eps);\n  derivs(p+0.5*dt*p2,\n         v+0.5*dt*v2,\n         p3,v3,eps);\n  derivs(p+dt*p3,\n         v+dt*v3,\n         p4,v4,eps);\n  p[0] += dt*(p1[0] + 2.0*p2[0] + 2.0*p3[0] + p4[0])/6.0;\n  p[1] += dt*(p1[1] + 2.0*p2[1] + 2.0*p3[1] + p4[1])/6.0;\n  v[0] += dt*(v1[0] + 2.0*v2[0] + 2.0*v3[0] + v4[0])/6.0;\n  v[1] += dt*(v1[1] + 2.0*v2[1] + 2.0*v3[1] + v4[1])/6.0;\n}\n\n// Variable step Runge-Kutta.\nint steps = 1;\nvoid rk4var(inout vec2 p,inout vec2 v,float dt, float eps) {\n  while (true) {\n    vec2 p1 = p, v1 = v, p2 = p, v2 = v;\n    rk4(p1,v1,dt/float(steps),eps);\n    rk4(p2,v2,dt/float(2*steps),eps);\n    vec2 p3 = p2,v3 = v2;\n    rk4(p3,v3,dt/float(2*steps),eps);\n    //Sum the squares of the errors\n    vec2 errorvec = v3-v1;\n    float error = dot(errorvec,errorvec);\n    if (error > 1e-5 && steps < 100) {\n      steps *= 2;\n    } else if (error < 1e-7 && steps > 1) {\n      steps /= 2;\n      //p = p2; v = v2; // FIXME: this is wrong!\n      rk4(p,v,dt/float(steps),eps); // Recalculate for smaller step\n      break;\n    } else {\n      p = p3; v = v3;\n      break;\n    }\n  }\n  for (int i = 1; i < steps; i++) {\n    rk4(p,v,dt/float(steps),eps);\n  }\n}\n\n// NB: this modifies parameters p and v\nvoid evaluate(inout vec2 p, inout vec2 v, float eps) {\n  //var pp = pdiffs(function(p) { return L(p,v,t) }, p,eps);\n  //var pv = pdiffs(function(v) { return L(p,v,t) }, v,eps);\n  //p0 = p; v0 = v;\n  vec2 pp = pdiffsLp(p,v,eps);\n  vec2 pv = pdiffsLv(p,v,eps);\n  p[0] += v[0]*eps;\n  p[1] += v[1]*eps;\n  // Compute new values of pv (apply Euler-Lagrange)\n  pv[0] += pp[0]*eps;\n  pv[1] += pp[1]*eps;\n  // pv is PD of L at t+eps\n  // Now find new v' st pdiff(Lp,v') = pv\n  // Initial guess is v, use Hessian to refine guess\n  // F(v') = F(v+dv) = F(v) + (JF)(dv), here F is the partial\n  // derivatives of L at v.\n  // Then v' = v + dv where dv = inv(JF)(F(v')-F(v))\n  // Doing this step 2 or 3 times seems to be enough\n  // I'm surprised it works at all really.\n  for (int k = 0; k < 3; k++) {\n    vec2 pv2 = pdiffsLv(p,v,eps);\n    vec2 t = pv-pv2;\n    float a = hessian(0,0,p,v,eps);\n    float b = hessian(0,1,p,v,eps);\n    float c = b; // Symmetry\n    float d = hessian(1,1,p,v,eps);\n    float det = a*d - b*c; // If det is too small, we'll just diverge here\n    v[0] += (d*t[0] - b*t[1])/det;\n    v[1] += (-c*t[0] + a*t[1])/det;\n  }\n}\n\n#if !defined ORBIT\n// Lagrangian for Double Pendulum\nfloat G = 1.0; // Gravity\nfloat M0 = 1.0, M1 = 1.0; // Bob weight\nfloat R0 = 0.5, R1 = 0.618; // Pendulum section length.\nvec4 initpv = vec4(0.5*PI,0.5*PI,0.01,0);\n\nvec4 E(vec2 p, vec2 v) {\n  float y0,y1,ke0,ke1,pe0,pe1;\n  vec2 v0,v1;\n  y0 = R0*sin(p[0]);\n  y1 = y0 + R1*sin(p[1]);\n  v0 = vec2(-R0*sin(p[0])*v[0], R0*cos(p[0])*v[0]);\n  v1 = vec2(-R1*sin(p[1])*v[1], R1*cos(p[1])*v[1]);\n  ke0 = 0.5*M0*(dot(v0,v0));\n  ke1 = 0.5*M1*(dot(v0+v1,v0+v1));\n  pe0 = G*M0*y0;\n  pe1 = G*M1*y1;\n  return vec4(ke0,ke1,pe0,pe1);\n}\n\n// Convert into euclidean coordinates.\nvec4 getcoords(vec2 p,vec2 v) {\n  float x0,y0,x1,y1;\n  x0 = R0*cos(p[0]);\n  y0 = R0*sin(p[0]);\n  x1 = x0 + R1*cos(p[1]);\n  y1 = y0 + R1*sin(p[1]);\n  return vec4(x1,y1,x0,y0);\n}\n#else\n// OrbitPolar\nfloat G = 2.0; // Gravity\nvec4 initpv = vec4(1,0,0,1);\nvec4 E(vec2 p, vec2 v) {\n  float m = 1.0;\n  float r = p[0];\n  float rv = v[0];\n  float thetav = v[1];\n  float ke = m*0.5*(rv*rv + r*thetav*r*thetav);\n  float pe = 3.0-m*G/r;\n  return vec4(ke,0,pe,0);\n}\nvec4 getcoords(vec2 p, vec2 v) {\n  return vec4(p[0]*sin(p[1]), p[0]*cos(p[1]),0,0);\n}\n#endif\n\nfloat maxstep = 5e-3;\nvec4 lagrange0(vec2 p, vec2 v,float dt) {\n  float eps = 5e-3;\n  while(dt > 0.0) {\n    //var f = function(p,v,t,eps) { Lagrange.evaluate(system.L,p,v,t,eps); }\n    float delta = min(maxstep,dt);\n    step(p,v,delta,eps);\n    dt -= delta;\n  }\n  return vec4(p,v);\n}\nvec4 lagrange(vec2 p, vec2 v,float dt) {\n  step(p,v,dt,5e-3);\n  return vec4(p,v);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}