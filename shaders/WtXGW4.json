{
    "Shader": {
        "info": {
            "date": "1556298436",
            "description": "this is a mildly cleaned up version of [AD26], with namespaces translated to its children.\n[AD26] predates the commonTab feature.\n\ni notice longer parsing times, how bad is it?",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXGW4",
            "likes": 2,
            "name": "AD26 cleanup",
            "published": 3,
            "tags": [
                "normal",
                "automaticdifferentiation",
                "calculus"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 403
        },
        "renderpass": [
            {
                "code": "/**/ //--- start Modifiers\n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 3\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\n/**/ //--- end__ Modifiers\n     //\n/**/ //--- start AD-introduction\n/*\n\nchild  AD34 : https://www.shadertoy.com/view/Wlf3WN\nself   AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\nAunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision increases more on areas with sharp corners\n- shapes with functions that that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function, for:\n-more precise anti-alasing (by starting from a DoubleIntegral)\n-faster better gradient|contour calculation. (2d ovals. metaballs)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nThis converts ALL operants into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n/**//*\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n/**/ //--- end__ AD-introduction\n     //\n/**/ //--- start \n                                    \n\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(DAm2 a, DAm2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperprim(DAm2 p, v3 s,vec2 r\n){//vec2 r=vec2(.2,.5);\n  //vec4 s=vec4(1.5,.5,1.5,.5);\n  //vec4 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=vec4(0);dz=vec4(0);d=vec4(0);\n  //e=vec4(0);f=vec4(0);q=vec4(0);\n  //a=vec4(0);b=vec4(0);c=vec4(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out vec4 s,out vec2 r\n){     if(i==0){s=vec4(1)           ;r=vec2(0)     ;//cube\n }else if(i==1){s=vec4(vec3(1),.25) ;r=vec2(0)     ;//corridor\n }else if(i==2){s=vec4(vec3(1),.25) ;r=vec2(1)     ;//pipe\n }else if(i==3){s=vec4(1)           ;r=vec2(1,0)   ;//cylinder\n }else if(i==4){s=vec4(1,1,2,1)     ;r=vec2(1)     ;//pill\n }else if(i==5){s=vec4(1)           ;r=vec2(1)     ;//sphere\n }else if(i==6){s=vec4(1,1,.25,1)   ;r=vec2(1,.25) ;//pellet\n }else if(i==7){s=vec4(1,1,.25,.25) ;r=vec2(1,.25) ;//torus\n }else if(i==8){s=vec4(2,.5,.25,.25);r=vec2(.5,.25);//sausage mouth\n }else if(i==9){s=vec4(.7,1,1,.25)  ;r=vec2(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n                                            \n //demo playground for boolean unions of implicit surfaces.\nd2 aBool(DAm2 p\n){\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n ;d2 box=fBoxCheap(p,vec3(1))\n ;p=su(p,vec3(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;d2 box2=fBox(p,vec3(1))\n ;//return mind(box,box2);//(box or     box2)\n ;//return maxd(box,box2);//(box and     box2)\n ;//return maxd(box,-box2);//(box and not box2)\n ;return fOpUnionRound(box,box2,1.)\n ;//return fOpIntersectionRound(box,box2,.3)\n ;//return fOpDifferenceRound(box,box2,.5)\n ;//return box\n ;}\n \n //set camera position & target\n void setCam(out vec3 o,out vec3 i,v0 t,v0 m){\n  o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;float m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(DAm2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\nDAMValue df(DAm2 p){d2 r;\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces:\n ;r=aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,vec3(1))\n ;//r=fBoxCheap(p,vec3(1))\n ;float holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;d2 s=fSphere(mu(p,vec3(holesize)))\n ;r=ma(r,ne(s))   ;\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;float t=iTime,u=ss01(ss01(fract(t)))\n ;vec4 a,b;vec2 c,d\n ;getfactor(imsc(t   ),a,c)\n ;getfactor(imsc(t+1.),b,d)\n ;DAm2 q=DAm2(p.y,p.z,p.x)\n ;if(iMouse.z>.5\n ){vec2 m=iMouse.xy/iResolution.xy\n  ;r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m)\n ;}else r=sdSuperprim(q,mix(a,b,u),mix(c,d,u))\n ;d2 box=fBoxCheap(su(p,vec3(1.,1,-.5)),vec3(.61))\n ;//p=su(p,vec3(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//r=box2=fBox(p,vec3(1))\n ;//r=mind(box,box2);//(box or     box2)\n ;//r=maxd(box,box2);//(box and     box2)\n ;//r=maxd(box,-box2);//(box and not box2)\n ;r=fOpUnionRound(r,box,1.)\n ;//r=fOpIntersectionRound(box,box2,.3)\n ;//r=fOpDifferenceRound(box,box2,.5)\n ;//r=box   \n ;float holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;d2 s=di(((fSphere(mu(mi(p,vec3(.5,.61,-.4)),vec3(holesize))))),holesize)\n ;r=ma(r,ne(s))  ;\n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(v2 p){DAMValue d=df(da_domain1(p));return vec2(d.d.a,d.m);}\n//return material at p with normal n\nvec4 material(v2 p,v2 n ){d2 d=df(da_domain1(vec3(p.x,0.,p.z))).d\n ;return mix(vec4(n*.5+.5,.1)\n            ,vec4(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nfloat shadow(v2 o,v2 i\n){const float a=32.//shadow hardnes\n ;float r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const float it=clamp(IterSh,0.,64.)\n ;for(float j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(vec3 p,vec3 n,vec3 i,float d,vec4 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=vec3(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(v2 o,v2 i\n){const float m=20.//distance.Max\n ;float e=.0,h=e,t=0.//intersection.precission\n ;const float irm=clamp(IterRm,1.,256.)\n ;for(float j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;float r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n   vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nvec3 getDt1(in vec3 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a vec4. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\nvec4 in3d(vec2 u\n){u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;vec2 m=iMouse.xy/iResolution.xy  //mouse\n ;vec3 o,i,c=vec3(0)\n ;setCam(o,i,iTime,m.y+.2)//camMovement\n ;vec3 d=normalize(calcLookAtMatrix(o,i,camRoll)*vec3(u.xy,camLens))//ray.direction\n ;float t=rm(o,d)//Distance.raymarched\n ;if(t>-.5\n ){vec3 p=o+t*d,n=getDt1(p)//position & normal\n  ;vec4 m=material(p,n)  //material\n  ;c=light(p,n,d,t,m);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), vec3(0.4545) )\n ;return vec4(c,1.);}\n                         \n                                    \n                                    \n//v3 in2d(vec2 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){vec2 m=fra(iMouse.xy)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;DAm1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;float outlineThickness=iResolution.y*.5\n ;float i=length(vec2(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;float ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//float r=1.-f.x.x\n ;float r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//float b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//float div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(vec2 u\n ){u=fra(u)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  float h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n\nvoid mainImage( out vec4 O,in vec2 U ){\n #if (scene==3)\n O=mix(in3d(U),in2d(U),.1)\n #elif (scene==2)\n  O=in3d(U)\n #elif (scene==1)\n  O=in2d(U)\n #elif (scene==0)\n  O=in1d(U)\n #endif \n;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**/ //--- start Basics\n//very common subroutines and defines\n\n//index starts with 0\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n//the below is basically an [m0]\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define i0 int\n\n#define pi acos(-1.)\n#define sat(a) clamp(a,0.,1.)\n#define fra(u) camLens*(u-.5*iResolution.xy)/iResolution.y  \n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n//vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nvec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n//vec2 aXorB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a*(1.-b)+b*(1.-a));}\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n//--- all above is NOT AD structure (but may be requred)\n\n\n/**/ //--- end__ Basics\n     //\n/**/ //--- start AD-structure\n\n/*\n\nthis uses SIunits:\n-       time()SIunit==[s]second\n-     length()SIunit==[m]meter\n-       mass()SIunit==[g]kilogramm  //aka [linear inertia]\n-  EMcurrent()SIunit==[A]ampere\n-Temperature()SIunit==[K]kelvin\n-     Amount()SIunit==[M]Mole\n-Luminousity()SIunit==[c]candela\n\nwe assert that time=s is scalar, has only one dimension (at least true for past experiences)\notherwise causality is an [arbitiary field] and math of that gets a bit too statistical\nfor simpler syntax, we derive over [t] and label Nth derivatives as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=ds²=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=ds³=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\nand sometimes some notations are more intuitive than others.\n\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate terms below (into an up to +3-lines-lowerTerm)\n ;//and then the higher-terms can be used to [filter] a lower-term\n ;//  https://www.shadertoy.com/results?query=filter\n;}\n\n?        =1.*s*s\nTime     =1.*s\nFrequency=1./s      aka[becquerel] aka [fluxion]==initially proposed term for [dt]\nPhase    =1./s/s    aka[frequency drift] https://en.wikipedia.org/wiki/Instantaneous_phase\n?        =1./s/s/s\n\nWaveLength=m\n\n--- position|displacement-integrals are:  \n\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n\nlength ==1.*m/1    //beware: [relativistic length-contraction]\nSpeed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n\nlength|speed are implicitly scalar single-dimensional length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are VECTORS with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\nThey include a relative direction; (angles|UnitQuaternion)*length())\nThis includes all angular reference points\n, as a polar transformation implies 2 dimensions.\nThis includes all issues of periodic/circular displacement\nwhere you can do a lot of work, and can end up exactly where you started, plus some entropy\n  https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n\n“farness”    ==1.*m*s*s*s*s*s*s*s*s*s*s*s*s\nAbsput       ==1.*m*s*s*s*s*s*s*s*s*s*s*s\nAbshot       ==1.*m*s*s*s*s*s*s*s*s*s*s\nAbsrop       ==1.*m*s*s*s*s*s*s*s*s*s\nAbsock       ==1.*m*s*s*s*s*s*s*s*s\nAbsop        ==1.*m*s*s*s*s*s*s*s\nAbsrackle    ==1.*m*s*s*s*s*s*s\nAbsounce     ==1.*m*s*s*s*s*s\nAbserk       ==1.*m*s*s*s*s\nAbseleration ==1.*m*s*s*s\nAbsity       ==1.*m*s*s \nAbsement     ==1.*m*s       = [maintenance cost] of [long distance communication]\nDisplacement ==1.*m/1.      //beware: [relativistic length-contraction]\nVelocity     ==1.*m/s       //beware: https://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\nAccelleration==1.*m/s/s/s\nJounce/Snap  ==1.*m/s/s/s/s\nCrackle      ==1.*m/s/s/s/s/s\nPop          ==1.*m/s/s/s/s/s/s \nLock         ==1.*m/s/s/s/s/s/s/s\nDrop         ==1.*m/s/s/s/s/s/s/s/s \nShot         ==1.*m/s/s/s/s/s/s/s/s/s\nPut          ==1.*m/s/s/s/s/s/s/s/s/s/s\n“swiftness”  ==1.*m/s/s/s/s/s/s/s/s/s/s/s\n\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure “nearness”.\n\n“nearness”   ==1./m*s*s*s*s*s*s*s*s*s*s*s*s\nPresput      ==1./m*s*s*s*s*s*s*s*s*s*s*s\nPreshot      ==1./m*s*s*s*s*s*s*s*s*s*s\nPresrop      ==1./m*s*s*s*s*s*s*s*s*s\nPresock      ==1./m*s*s*s*s*s*s*s*s\nPresop       ==1./m*s*s*s*s*s*s*s\nPresackle    ==1./m*s*s*s*s*s*s\nPresounce    ==1./m*s*s*s*s*s\nPreserk      ==1./m*s*s*s*s\nPreseleration==1./m*s*s*s\nPresity      ==1./m*s*s\nPresement    ==1./m*s\nPlacement    ==1./m\n?            ==1./m/s    [reciprocal of velocity]\n\n?               =1.*g*m/s/s/s/s\nspectral power  =1.*g*m/s/s/s\n?               =1.*g*m/s/s\n?               =1.*g*m/s\n?               =1.*g*m\nmomentum|impulse=1.*g*m/s\nforce|weight    =1.*g*m/s/s        aka [Newton] aka [action|actergy]\nYank            =1.*g*m/s/s/s      aka [joule][NewtonMetre][linear work]\nTug.            =1.*g*m/s/s/s/s    aka [linear power]\nSnatch          =1.*g*m/s/s/s/s/s\nShake           =1.*g*m/s/s/s/s/s/s\n“forceness”     =1.*g*m/s/s/s/s/s/s/s\n\nabove are \"real vectors\" of below \"pseudo vectors\"\nAngular/rotational quantities in polar coordinates:\nthe difference between above and below is a [coreolis effect]\nrad=radians, where acos(-1.)*2.==1 full rotation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below i mixed a lot of things together, as long as they have the same SI-inut-formula\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware i confuce nounfs for quanitities, because i really dont care.\n\npower density      =1.*g/m/s/s/s  aka: [spectral irradiance]\npascal             =1.*g/m/s/s\n?                  =1.*g/m/s\nlinear mass density=1.*g/m \ndynamic viscosity  =1.*g/m/s\nenergy density     =1.*g/m/s/s\n\ninertiaMoment =1.*g*m*m*s\ninertia       =1.*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\nspin          =1.*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nangular energy=1.*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\nangular power =1.*g*m*m/s/s/s  [watt] [radiant  intensity]\n\nmass           =g\nmass flow rate =g/s\nsurface tension=g/s/s    aka [stiffness]\nradiance       =g/s/s/s  aka [heat flux density, irradiance]\n\nangular displacement   =rad\nangular|radial velocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\nangular acceleration   =rad/s/s\nangular jerk           =rad/s/s/s\n\nspecific angular momentum =m*m/s\ngray|sievert              =m*m/s/s\nabsorbed dose rate        =m*m/s/s/s\n\nangular momentum|Impulse=1.*g*m/s \nangular torque  |moment =1.*g*m/s/s       \nangular rotatum         =1.*g*m/s/s/s  aka [spectral power, spectral intensity]\n\ncoulomb           =1.*A*s\nEMcharge          =1.*A\nEMcurrent         =1.*A/s\n\nweber   =1./A*g*m*m/s/s\nvolt    =1./A*g*m*m/s/s/s\n\nhenry   =1./A/A*g*m*m/s/s\nohm     =1./A/A*g*m*m/s/s/s\n\nfarad   =1./g*A*A/m/m*s*s*s*s\nsiemens =1./g*A*A/m/m*s*s*s\n\nenergy flux density=g/s/s/s\nradiant exposure   =g/s/s\n\nAreaDensity g/m/m\nMassdensity\tg/m/m/m \n\narea                =1.*m*m\ndiffusionCoefficient=1.*m*m/s aka: [specific energy,KinematicViscosity,Diffusivity]\n\nmol   = mol\nkatal = mol/s\n\nmolar volume          =1./mol*m*m*m\ncatalytic efficiency  =1./mol*m*m*m/s\n\nvolume            =1.*m*m*m\nVolumetricFlowRate=1.*m*m*m/s   //Rate of change of volume with respect to time \t\n\n//--- above is differentials over time\n//---\n//--- below is differentials over space\n\n?               =1.*m*m*m*m*m\nhyper-volume    =1.*m*m*m*m\nvolume          =1.*m*m*m\narea            =1.*m*m\ndisplacement    =1.*m    (displacement or SCALAR length)\ncurvature       =1./m    aka [wavenumber , optical power, spatial frequency]\nfuel efficiency =1./m/m\n?               =1./m/m/m\n\n?        =1.*s*m*m\nAbsement =1.*s*m\nTime     =1.*s\n?        =1.*s/m  [reciprocal of velocity]\n\nmoment of inertia  =1.*g*m*m \n?                  =1.*g*m\nmass               =1.*g\nlinear mass density=1.*g/m\n\nwatt               =1.*g/s/s/s*m*m\n?                  =1.*g/s/s/s*m\nweber ,  radiance  =1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\nspectral radiance  =1.*g/s/s/s/m    aka[spectral power]\nradiant  intertua  =1.*g/s/s/s/m/m\n\nspin               =1.*g/s*m*m [angular torque  |moment] [energy density] [action]\nangular momentum   =1.*g/s*m    [angular Impulse]\nmass flow rate \t   =1.*g/s\ndynamic viscosity  =1.*g/s/m\n\nangular energy     =1.*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n?                  =1.*g/s/s*m\nsurface tension    =1.*g/s/s       aka [spring constant, stiffness]\n\njoule              =1.*g/s/s*m*m\n?                  =1.*g/s/s*m\nradiant exposure   =1.*g/s/s\n\nAreaDensity        =1.*g/m/m\nMassdensity\t       =1.*g/m/m/m \n\nwatt               =1.*g/s/s/s*m*m\nangular rotatum    =1.*g/s/s/s*m\n\nVolumetricFlowRate =1./s*m*m*m\nviscosity          =1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n//-----residue with no  no known ds chain:\nwavenumber         =1./m     aka [optical power, curvature, spatial frequency ]\nspecific volume    =1./g*m*m*m\ncompressibility    =1./g*m*s*s\nspectral radiance  =1.*g/m/s/s/s\ntesla              =1./A*g/s/s\nlux                =cd*steradian/m/m\n\n//----residue with no known dm chain:\n\ngray|sievert      =1./s/s*m*m\ninertiaMoment     =1.*g*s*m*m\ninertia           =1.*g*m*m        https://en.wikipedia.org/wiki/Moment_of_inertia\nspecific volume   =1./g*m*m*m\ncompressibility   =1./g*s*s*m\ncoulomb       =A*s\nlux           =cd*steradian/m/m\n\n//------- dual residual\n\nabsorbed dose rate =1./s/s/s*m*m\nmolality           =mol/g\nmolar mass         =g/mol\nmolar energy \t   =g/mol*m*m/s/s\nmolar heat capacity=g/mol/K*m*m/s/s aka[molar entropy]\nmolar conductivity =A*A/g/mol*s*s*s\nmolarity           =1.*mol/m/m/m\nhenry              =1./A/A*g/s/s*m*m\nohm                =1./A/A*g/s/s/s*m*m\ntesla              =1./A*g/s/s\nweber              =1./A*g/s/s*m*m\nvolt               =1./A*g/s/s/s*m*m\npower density      =1.*g/s/s/s/m   aka: [spectral irradiance]\nfarad              =1./g*A*A*s*s*s*s/m/m\nsiemens            =1./g*A*A*s*s*s/m/m\n\n\n\n//--------------\n\n\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a vec4 trough many functions:\n\n\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt²=+2th derivative (and dt)\n[d***]dt³=+3th derivative (and dt adnd dt²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n/**/\n\n\n#define ST struct\n\n//struct d(v0 a;);//just use v0 instead.\n\n/*\nit seems below struck is silly\n\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nshould actually be a transpose of itself\nST   d111{v0   t;v3   x;v3   y       ;};//2 domains t,dt,dt²,dt³ \nt=point\nx=dt,dt² dt³ over the .x domain\ny=dt,dt² dt³ over the .y domain\n\n//DAm111 is ther same, but its subs are now swiveled\nST DAm111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \n\nwhat does this to the old su()  ?\n\n*/\n\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00 D00(v2   a){return d00(a.x,a.y,a.z);}\nv2   V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0 D0(v1  a){return d0(a.x,a.y);}\nv1 V1(d00 a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\nST DAm0  {d0   x                     ;};//1 domains t,dt\nST DAm00 {d00  x                     ;};//1 domains t,dt,dt²\nST DAm000{d000 x                     ;};//1 domains t,dt²dt³ \nST DAm1  {d1   x;d1   y              ;};//2 domains t,dt    \nST DAm11 {d11  x;d11  y              ;};//2 domains t,dt,dt² \nST DAm111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \nST DAm2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST DAm22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt² \nST DAm222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dt²dt³  \nST DAm3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST DAm33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt²   \nST DAm333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt²,dt³  \n\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\nv2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n\n/*\noh wait, this structure is VERY inefficient\nI think i must swap this into\n\nbut once again, i need to first finish the inefficient thing\n, see if that works\n, and THEN can think better about optimizing for efficiency\n\nprogramming teachers fail at the [parable of the perfect pott(ery)\n\n/**/\n\n\n//struct ADm2{vec3 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n    //a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\nDAm000 da_domain3(v0 p){return DAm000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nDAm111 da_domain3(v1 p){return DAm111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nDAm222 da_domain3(v2 p){return DAm222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.y,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nDAm333 da_domain3(v3 p){return DAm333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\n\nDAm00  da_domain2(v0 p){return DAm00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nDAm11 da_domain2(v1 p){return DAm11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nDAm22 da_domain2(v2 p){return DAm22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nDAm33 da_domain2(v3 p){return DAm33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\n\nDAm0   da_domain1(v0 p\n){return DAm0(d0  (p,1.));}//1 derivatives over 1d\nDAm1 da_domain1(v1 p){return DAm1\n(d1(p.x,v1(1,0))//2 derivatives over 2d\n ,d1(p.y,v1(0,1)));}\nDAm2 da_domain1(v2 p){return DAm2\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))//1 derivatives over 3d\n,d2(p.z,v2(0,0,1)));}\nDAm3 da_domain1(v3 p){return DAm3\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))//1 derivatives over 4d\n,d3(p.w,v3(0,0,0,1)));}\n\n//2d one is \n// [wikipedia contour_Line] //for 2 domains (heightmap, isoline, contour)\n//1d one is linear equations.\n\n/*\nimplementation example:\n/*the [DAm*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(DAm2 p,v2 s){//p=point; s=boxSize\n ;DAm2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(DAm2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n/*\nnote: beware  intuitive problems of the above atructure\nIt has 2 different (easily-mistaken-identity) cases:\n- A 2d gradient has NULL differential along +1 additional domain.\n- A vector gets all components scaled \n ,when multiplying a vector by a float.\n*/\n/**/ //--- __end AD-structure\n     //\n/**/ //--- start AD-functions \n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\nFor a monadic structure, we imply prefix notation for everything:\nInfix notation is a 2000 year old dumd idea;\nGood enough for abacuss multiplication, bad for log((a+b)/(c-d))\n\ninitially i liked to sort by number of input params, but this fails\n- atan() takes 1 input, but its subroutines ad()po()di() take more than 1 input.\n\n/**/\n//negation identity: max(a,b)=-min(-a,-b), requires struct negation\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\n\nDAm0   ne(DAm0   a){return DAm0  (ne(a.x));}\nDAm00  ne(DAm00  a){return DAm00 (ne(a.x));}\nDAm000 ne(DAm000 a){return DAm000(ne(a.x));}\nDAm1   ne(DAm1   a){return DAm1  (ne(a.x),ne(a.y));}\nDAm11  ne(DAm11  a){return DAm11 (ne(a.x),ne(a.y));}\nDAm111 ne(DAm111 a){return DAm111(ne(a.x),ne(a.y));}\nDAm2   ne(DAm2   a){return DAm2  (ne(a.x),ne(a.y),ne(a.z));}\nDAm22  ne(DAm22  a){return DAm22 (ne(a.x),ne(a.y),ne(a.z));}\nDAm222 ne(DAm222 a){return DAm222(ne(a.x),ne(a.y),ne(a.z));}\nDAm3   ne(DAm3   a){return DAm3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nDAm33  ne(DAm33  a){return DAm33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nDAm333 ne(DAm333 a){return DAm333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n//floor(a) is a basis-function for mod() and fract()\n//because mod() is a mess, so i needed a trueMod(fract())\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies above 2 lines to 2 defines\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to lultiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0 fl(d0 a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1 fl(d1 a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2 fl(d2 a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3 fl(d3 a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n\n//also, since mod(a,1.) NEVER returns 1 (its a halfoven interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\n/*    //residue from AD16 on mod() derivatives                   \n//mo() ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, modd(a,b) outperforms mu(fractd(divd(a,b)),b)\n//v4 modd(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 modd(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 modd(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does\n#define may fract(a.b));}\n#define maz mod(a.a,b),may\n#define mab mod(a.a,b.a)\n//v0 mo(v0 a,v0 b){return mod(a,b);}                        \nd2 mo(d2 a,v0 b){return d2(maz\nd1 mo(d1 a,v0 b){return d1(maz\nd0 mo(d0 a,v0 b){return d0(maz\nd0 mo(d0 a,d0 b){return d0(mab,may\nd2 mo(d2 a,d0 b){return d2(mab,may\nd2 mo(d2 a,d2 b){return d2(mab,may\nd2 mo(d2 a,d1 b){return d2(mab,may\nd2 mo(d0 a,d2 b){return d2(mab,v2(0));}\nd2 mo(d1 a,d2 b){return d2(mab,v2(0));}\nd2 mo(v0 a,d2 b){return d2(mo(a,b.a),v2(0));}\nd1 mo(v0 a,d1 b){return d1(mo(a,b.a),v1(0));}\nd0 mo(v0 a,d0 b){return d0(mo(a,b.a),   0.);}\n*/\n                         \n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,vec4 o){float O=a.c*o.x\n ;return D000(o.xyyy*vec4(1.,a.b,a.c,a.d)\n +vec4(0,0,a.b*vec2(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\n//above so far is only useful for sin() or cos()\nvec4 siD(float a){return vec4(+si(a),+co(a),-si(a),-co(a));}\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\n\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nd111 si(d111 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd111 co(d111 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd222 co(d222 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd333 si(d333 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=si(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\nd333 co(d333 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=co(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\n//once more a clear sign of my structure extending poorly.\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//DAm111 si(DAm111 a){return DAm111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n/*\n//atan is implemented, but further below, it needs more subroutines:\ntodo, all the trigonometry functions with glES100 to gles300 porting\n*/\nv0 rec(float a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n\n\n//single parameter operations are MUCH simpler here:\nv0 sr(v0 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\n\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n\n//ex(d00) seems to be fine\nd00 ex(d00 a){return d00(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n);}\n//exp2() is not THAT simple here.\n\n//ex(d000) seems to be fine\nd000 ex(d000 a){return d000(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b\n+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}\n//exp2() is not THAT simple here.\n\nd11 ex(d11 a){\n ;d00 x=ex(d00(a.a,a.b.x,a.c.x))\n ;d00 y=ex(d00(a.a,a.b.y,a.c.y))\n ;return d11(x.a,v1(x.b,y.b)\n                ,v1(x.c,y.c));}\nd22 ex(d22 a){\n ;d00 x=ex(d00(a.a,a.b.x,a.c.x))\n ;d00 y=ex(d00(a.a,a.b.y,a.c.y))\n ;d00 z=ex(d00(a.a,a.b.z,a.c.z))\n ;return d22(x.a,v2(x.b,y.b,z.b)\n                ,v2(x.c,y.c,z.c));}\nd33 ex(d33 a){\n ;d00 x=ex(d00(a.a,a.b.x,a.c.x))\n ;d00 y=ex(d00(a.a,a.b.y,a.c.y))\n ;d00 z=ex(d00(a.a,a.b.z,a.c.z))\n ;d00 w=ex(d00(a.a,a.b.w,a.c.w))\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b)\n                ,v3(x.c,y.c,z.c,w.c));}\nd111 ex(d111 a){\n ;d000 x=ex(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=ex(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b)\n                 ,v1(x.c,y.c)\n                 ,v1(x.d,y.d));}\nd222 ex(d222 a){\n ;d000 x=ex(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=ex(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=ex(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd333 ex(d333 a){\n ;d000 x=ex(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=ex(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=ex(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=ex(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\n\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd1 ln(d1 a){return d1(log(a.a),a.b/a.a);}\nd2 ln(d2 a){return d2(log(a.a),a.b/a.a);}\n//        pow (x,y) ex(   ln(x)*y )//wait till we define mu()\n//#define powd(x,y) ex(mu(ln(x),x))//wait till we define mu()\n\n//ln() 2nd and 3rd derivative imply quotientRule\n//i hope i did this corretcly. last time i did this 15 years ago.\n\n\nd00 ln(d00 a){return d00(\n ln(a.a) //t\n,a.b/a.a //dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dt²\n\nd000 ln(d000 a){return d000(\n ln(a.a)//t\n,a.b/a.a//dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dt²\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))\n /(a.a*a.a*a.a*a.a)//dt³\n    //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() overlaps a lot with di() the a are only off by 1.\n //ln() is a special case of di()\n\n\n\n\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\n\nd00 ab(d00 a){return d00(  \n abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\n\nd000 ab(d000 a){return d000(  \n abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use modd() instead, modd() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.a),djum(a.b));}\nd1 fractd(d1 a){return d1(floor(a.a),djum(a.b));}\nd0 fractd(d0 a){return d0(floor(a.a),djum(a.b));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n/*\nmathematical ifentity\nof fract(x) \nis mod(x,1.)\nis mod(x,1.)\n*/\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of modd() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\nv0 su(v0 a,v0 b){return a-b;} \nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\n\n\nd000 su(d000 a,d000 b){return d000(a.a-b.a\n                                  ,a.b-b.b\n                                  ,a.c-b.c\n                                  ,a.d-b.d\n                                );}\n\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³\nd111 su(d111 a,d111 b){\n ;d000 xa=d000(a.a,a.b.x,a.c.x,a.d.x)\n ;d000 ya=d000(a.a,a.b.y,a.c.y,a.d.y)\n ;d000 xb=d000(b.a,b.b.x,b.c.x,b.d.x)\n ;d000 yb=d000(b.a,b.b.y,b.c.y,b.d.y)\n  ;xa=su(xa,xb)\n  ;ya=su(ya,yb)\n  ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d))\n ;}\nd222 su(d222 a,d222 b){\n ;d000 xa=d000(a.a,a.b.x,a.c.x,a.d.x)\n ;d000 ya=d000(a.a,a.b.y,a.c.y,a.d.y)\n ;d000 za=d000(a.a,a.b.z,a.c.z,a.d.z)\n ;d000 xb=d000(b.a,b.b.x,b.c.x,b.d.x)\n ;d000 yb=d000(b.a,b.b.y,b.c.y,b.d.y)\n ;d000 zb=d000(b.a,b.b.z,b.c.z,b.d.z)\n  ;xa=su(xa,xb)\n  ;ya=su(ya,yb)\n  ;za=su(za,zb)\n  ;return d222(xa.a,v2(xa.b,ya.b,za.b)\n                   ,v2(xa.c,ya.c,ya.c)\n                   ,v2(xa.d,ya.d,za.d))\n ;}\n//this one hints at inefficient structure\n//glide-translations along multiple domains:\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n/*\nDAm3333 su(DAm3 p,v3 s){return DAm333\n(su(p.x,s.x)//su(d3,v0)\n.su(p.y,s.y)//su(d3,v0)\n,su(p.z,s.z)//su(d3,v0)\n,su(p.w,s.w));}//su(d3,v0)*/\n\n\nDAm3 su(DAm3 p,v3 s){return DAm3(su(p.x,s.x),//su(d3,v0)\n                                 su(p.y,s.y),//su(d3,v0)\n                                 su(p.z,s.z),//su(d3,v0)\n                                 su(p.w,s.w));}//su(d3,v0)\nDAm2 su(DAm2 p,v2 s){return DAm2(su(p.x,s.x),\n                                 su(p.y,s.y),\n                                 su(p.z,s.z));}\nDAm1 su(DAm1 p,v1 s){return DAm1(su(p.x,s.x),\n                                 su(p.y,s.y));}\nDAm0 su(DAm0 p,v0 s){return DAm0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\nd3 suab(d3 p,float s){return su(ab((p)),s);}                     \nd2 suab(d2 p,float s){return su(ab((p)),s);}\nd1 suab(d1 p,float s){return su(ab((p)),s);}\nd0 suab(d0 p,float s){return su(ab((p)),s);}\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n\nDAm3 suab(DAm3 p,v3 s){return DAm3(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z),\n                                   suab(p.w,s.w));}\nDAm2 suab(DAm2 p,v2 s){return DAm2(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z));}\nDAm1 suab(DAm1 p,v1 s){return DAm1(suab(p.x,s.x),\n                                   suab(p.y,s.y));}\nDAm0 suab(DAm0 p,v0 s){return DAm0(suab(p.x,s));}\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\nv0 mu(v0 a,v0 b){return a*b;}\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\nd2 mu(d2 a,d2 b){return d2(a.a*b.a,a.b*b.a+a.a*b.b);}\nd1 mu(d1 a,d1 b){return d1(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 b){return d0(a.a*b.a,a.b*b.a+a.a*b.b);}\nd1 mu(d0 a,d1 b){return d1(a.a*b.a,a.b*b.a+a.a*b.b);}\nd1 mu(d1 a,d0 b){return d1(a.a*b.a,a.b*b.a+a.a*b.b);}\n//d2 mu(d2 a,d1 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 mu(d2 a,d0 b){return d2(a.a*b.a,a.b*b.a+a.a*b.b);}\n//d2 mu(d1 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 mu(d0 a,d2 b){return d2(a.a*b.a,a.b*b.a+a.a*b.b);}\nDAm2 mu(DAm2 p,v2 s){return DAm2(mu(p.x,s.x),\n                                 mu(p.y,s.y),\n                                 mu(p.z,s.z));}\nDAm1 mu(DAm1 p,v1 s){return DAm1(mu(p.x,s.x),\n                                 mu(p.y,s.y));}\nDAm0 mu(DAm0 p,v0 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\nv0 di(v0 a,v0 b){return a/b;}\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),x))\n  \n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\nv0 mi(v0 a,v0 b){return min(a,b);}\nv1 mi(v1 a,v1 b){return min(a,b);}\nv2 mi(v2 a,v2 b){return min(a,b);}\nv3 mi(v3 a,v3 b){return min(a,b);}\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nDAm2 mi(DAm2 a,v2 p){return DAm2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nDAm2 madm(DAm2 a,v2 p){return DAm2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\n\nDAm2 madm(DAm2 a,v0 p){return madm(a,v2(p));}\nDAm2 mi(DAm2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(DAm2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(DAm2 a){return madm(a.x,a.y,a.z);}\n                           \n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n#define e2(a) mu(a,a)\n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\nv0 dt(v0 a,v0 b){return dot(a,b);}\nv0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}\nv0 dt(v3 a,v3 b){return dot(a,b);}\n#define dd(a) dt(a,a)\n\n                           \n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(DAm1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(DAm2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){float q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(DAm2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is f´(x)=1/x*x+1\nd2 ata(d2 a\n){float b=atan(a.a)\n ;d2 e=mu(a,a)\n ;e=ad(e,1.)\n ;e=di(1.,e)//e=divd(1.,addd(mu(a,a),1.));\n ;return d2(b,e.b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;\n}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\nd1 atand(d1 a,d1 b){return a;\n}\n\n/**/ //--- end__ AD-functions \n     //\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n     //\n/**/ //--- start AD-/mercury.sexy/hd_sdf\n\n\n\n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(DAm2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(DAm2 p){p.x.a=mix(0.,p.x.a,step(p.x.a,0.));\n d2 q=sd(p.x,p.y,p.z);return su(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nfloat fBoxCheap(v2 p,v2 b){\n v2 q=abs(p);q=q-p;//mirror clamp\n return max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(DAm2 p,v2 s){\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n    \n DAm2 u=suab(p,s);//mirror clamp\n return madm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\nfloat fBox(vec3 p,vec3 s){\n v2 d=abs(p)-s;//mirror clamp\n v0 a=length(max(d,0.));//rounded corners\n v2 q=min(d,0.);//clamp\n v0 b=max(max(q.x,q.y),q.z);//keep largest of 3\n return a+b;}//add //hg_sdf\nd2 fBox(DAm2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n DAm2 d=suab(p,s);//mirror clamp\n d2 a=sd(ma(d,0.));//rounded corners\n DAm2 q=mi(d,0.);//clamp\n d2 b=madm(q);//keep largest of 3\n return ad(a,b);}//add\n\nfloat fOpUnionRound(float a,float b,float r\n){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nfloat fOpIntersectionRound(float a,float b,float r\n){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,float r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\n\nfloat pMod1(inout float p,float s){p/=s\n;float c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//vec4 c=floord4(p);//c=subd(c,.5);//float c=floor((p)+.5);\n;p=ad(p,.5);p=fractd(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}