{
    "Shader": {
        "info": {
            "date": "1635898074",
            "description": "Dr. Heavenly, Toya... Quad.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nld3z7",
            "likes": 23,
            "name": "Draft Quadtree [learning level 2",
            "published": 3,
            "tags": [
                "2d",
                "tiles",
                "quadrtree"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 389
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Draft Quadtree [learning level 2]\n    11/2/21 @byt3_m3chanic\n\n    Ver2 of my last shader in just playing with quadtrees.\n    \n    @Shane has a good example for 2d tiles here:\n    https://www.shadertoy.com/view/llcBD7\n\n    Done in an attempt to learn the basics and how to use\n    and match up ID's with spaces. IDK might delete later?\n \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\nvec3 hue(float t){ \n    t*=5.;//tweak for other color variations\n    const vec3 d = vec3(0.067,0.812,0.915);\n    return .35 + .45*cos(PI2*t*(vec3(.97,.97,.98)*d)); \n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat px = .0231;\n\nvec3 doHatch(vec2 p, float res) {\n    p *= res/10.;\n    vec2 id = floor(p*.5)-.5;\n    float rnd = hash21(floor(p*.5));\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n    if (chk > 0.5) p.x *=-1.;\n    float hatch = clamp(sin((p.x - p.y)*PI*3.)*3. + 0.25, 0., 1.);\n    if(rnd>.66) hatch = rnd;\n    return vec3(clamp(hatch,.3,.7),id);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 ms = (2.*M.xy-R.xy)/max(R.x,R.y);\n                \n    px = fwidth(uv.x)*2.;\n            \n    vec2 vuv= uv*(2.+.25*sin(T*.135));\n    vuv.xy*=rot(.5*sin(T*.2));\n\n    vuv.y+=T*.35;\n    float px = fwidth(uv.x);\n    float level=1.;\n    vec3 dht = doHatch(vuv,155.);\n    float chk = mod(dht.z + dht.y,2.) * 2. - 1.;\n    \n    vec3 C = mix(hue((chk+vuv.x)*.05),vec3(.01),dht.x);\n \n    vec2 muv = M.z>1.?uv-ms:uv-vec2(.5*sin(T)/level,.25*cos(T)/level);\n    float tp = length(muv)-.1;\n    tp=smoothstep(px,.0,abs(tp)-.0075);\n\n    \n    for(int k=0; k<4; k++){\n        vec2 id = floor(vuv*level);\n        float rnd = hash21(id);\n        \n        // threshold or if last loop\n        if(rnd>.45||k>2) {\n\n            vec2 p = vuv -(id+.5)/level;\n            rnd = hash21(rnd+id.yx);\n            float dir = rnd>.5 ?-1.:1.;\n\n                                    \n            vec2 off1= clamp(vec2(muv*.17),vec2(-.1275),vec2(.1275));\n            off1/=level;\n            \n            // make ring parts - very basic\n            float angle = atan(p.x+off1.x, p.y+off1.y);\n            float f = length(p);\n            float width = .5/level;\n            float amt = 24.;\n            //vec for moving ring\n            vec2 q = vec2(\n                fract(dir*amt*angle/PI+T*1.75)/level,\n                f-width\n            );\n            //id for moving ring\n            vec2 tid = vec2(\n                floor(dir*amt*angle/PI+T*1.75),\n                floor(f-width)\n            );\n            \n            tid.x=mod(tid.x,2.);\n            float ds = length(p+off1-vec2(.125/level))-.065/level;\n            float dt = length(p+off1+vec2(.115/level))-.030/level;\n            float d = length(p)-.455/level;\n            float s = length(p)-.375/level;\n            float c = box(q+vec2(0,.4/level),vec2(1.,.25)/level);\n            float l = length(p+off1)-.195/level;\n            float h = abs(l)-.014/level;\n            \n            float fd = smoothstep(.005+px,-px,abs(d)-.025/level);\n            float md = smoothstep(.025+px,-px,length(p)-.275/level);\n            d = smoothstep(.0075+px,-px,d);\n            s = smoothstep(.05+px,-px,s);\n            c = smoothstep(.01+px,-px,c);\n            l = smoothstep(.01+px,-px,l);\n            h = smoothstep(.01+px,-px,h);\n            ds = smoothstep(.01+px,-px,ds);\n            dt = smoothstep(.01+px,-px,dt);\n            \n            C=mix(C,vec3(.35),d);\n            C=mix(C,vec3(.1),min(s,d));\n            c=min(c,s);\n            vec3 clr = hue(hash21(float(k)+tid.yx));\n            if(tid.x<1.) clr = hue(hash21(tid.yx));\n            C=mix(C,clr,min(c,d)+md );\n            C=mix(C,vec3(.015),min(l,d));\n            C=mix(C,vec3(.005),h);\n            C=mix(C,vec3(.9),ds+dt+fd);\n            break;\n        }\n        level*=2.;\n    }\n    \n    C = mix(C,M.z>0.?vec3(.8,.1,.01):vec3(.01,.4,.9),tp);\n    C = pow(C, vec3(.4545)); \n    O = vec4(C,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}