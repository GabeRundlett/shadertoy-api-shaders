{
    "Shader": {
        "info": {
            "date": "1510880366",
            "description": "A jiggling Mobius knot on a trippy sliding grid background!\nI'll be honest, I almost like the grid more than the knot lol\n\nThis is an improved version the first iteration of this shader: https://www.shadertoy.com/view/4tXfR8",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXBRH",
            "likes": 13,
            "name": "Mobius Noodle Floater",
            "published": 3,
            "tags": [
                "grid",
                "rings",
                "mobius",
                "knot",
                "loops",
                "loadingcircle"
            ],
            "usePreview": 0,
            "username": "Zanzlanz",
            "viewed": 777
        },
        "renderpass": [
            {
                "code": "// Use it, change it, enjoy! By Zanzlanz :)\n// This is an improved version the first iteration of this shader: https://www.shadertoy.com/view/4tXfR8\n\n#define pi 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Black background\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // Make the X coordinates the same distance as the Y\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    uv.xy -= .5;\n\tuv.x += (1.0-iResolution.x/iResolution.y)/2.0;\n    \n    \n    // This whole grid here is a huge unnecessary mess, but I love it\n    float d2E = 0.0;\n    float iT = iTime + uv.x*uv.y*10.0; // I liked @Polygon's equation here better that what I had :)\n    if(mod(iT*.04, .2) < .1) {\n        if(mod(uv.y, .1)<.05) d2E = smoothstep(0.0, 1.0, min(min(mod(uv.x+iT*.04, .05), mod(uv.y, .05)), min(.05-mod(uv.x+iT*.04, .05), .05-mod(uv.y, .05)))*300.0);\n        else d2E = smoothstep(0.0, 1.0, min(min(mod(uv.x+iT*.02, .05), mod(uv.y, .05)), min(.05-mod(uv.x+iT*.02, .05), .05-mod(uv.y, .05)))*300.0);\n    } else {\n        if(mod(uv.x+iT*.02, .1)<.05) d2E = smoothstep(0.0, 1.0, min(min(mod(uv.x+iT*.02, .05), mod(uv.y-iT*.02, .05)), min(.05-mod(uv.x+iT*.02, .05), .05-mod(uv.y-iT*.02, .05)))*300.0);\n        else d2E = smoothstep(0.0, 1.0, min(min(mod(uv.x+iT*.02, .05), mod(uv.y, .05)), min(.05-mod(uv.x+iT*.02, .05), .05-mod(uv.y, .05)))*300.0);\n    }\n    \n    col = vec3(d2E*.20+.80, d2E*.20+.80, d2E*.20+.80);\n    \n    \n    \n    // See https://www.shadertoy.com/view/4tXfR8 for more comments on this section\n    \n    \n    uv.x += sin(iTime/5.0)*.4;\n    uv.y += cos(iTime/4.0)*.1;\n    \n    float globalRotationTime = iTime/3.0;\n    uv.xy = vec2(uv.x*cos(globalRotationTime) - uv.y*sin(globalRotationTime), uv.x*sin(globalRotationTime) + uv.y*cos(globalRotationTime));\n    \n    uv.xy *= 1.0+sin(iTime/6.0)*.15;\n    \n    \n    float cuts = 5.5;\n\n    \n    float rotA = atan(uv.y, uv.x) - pi/2.0;\n    float rawRad = sin(+iTime*1.0+rotA*3.0)*.02+sin(-iTime*2.0+rotA*8.0)*.015+.3;\n    \n\n\tfloat dist = sqrt(uv.x*uv.x + uv.y*uv.y);\n\n\n\tfloat radA = sin(rotA*cuts)*.02+rawRad;\n\n\n\tif(abs(dist - radA) < .018+.005)\tcol = vec3(0.0, 0.0, 0.0);\n\tif(abs(dist - radA) < .018) \t\tcol = vec3(1.0, 1.0, 1.0);\n\n\n\tfloat rotB = rotA + pi*2.0/cuts/2.0;\n\tfloat radB = sin(rotB*cuts)*.02+rawRad;\n\tif(fract((rotB/2.0/pi+1.0/(cuts*4.0))*cuts)>.5 || abs(dist - radA) > .018+.005) {\n\t\tif(abs(dist - radB) < .018+.005)\tcol = vec3(0.0, 0.0, 0.0);\n\t\tif(abs(dist - radB) < .018) \t\tcol = vec3(1.0, 1.0, 1.0);\n\t}\n    \n\tfragColor.rgb = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}