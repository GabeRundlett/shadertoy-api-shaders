{
    "Shader": {
        "info": {
            "date": "1716168092",
            "description": "i was told that structs are slow so bye bye",
            "flags": 0,
            "hasliked": 0,
            "id": "M33Gz4",
            "likes": 2,
            "name": "super epic raymarcher 4: endgame",
            "published": 3,
            "tags": [
                "raymarcher",
                "super",
                "epic"
            ],
            "usePreview": 0,
            "username": "derpygamer2142",
            "viewed": 119
        },
        "renderpass": [
            {
                "code": "#define epsilon 0.001\n#define maxDist 500.0\n#define fov 90.0\n#define PI 3.14159\n\nvec3 a = vec3(0.0, 0.0, 25.0);\nvec3 b = vec3(-10.0, -3.0, 25.0);\n\nfloat atan2 (float x, float y) {\n    return radians(degrees(atan(x/y)) + (180.0 * float(y < 0.0)));\n}\n\nvec3 aces(vec3 x) {\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nstruct Plane {\n// WHAT DO WE WANT\n// planes\n// WHEN DO WE WANT THEM\n// neeeeeeeeeeeoooooooooooooooooooowwwwwwwwwwwwwww *plane noises*\n    float h;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float r;\n};\n\nvec2 sphereRay( in vec3 ro, in vec3 rd, in vec3 ce, float ra ) {\n    // https://iquilezles.org/articles/intersectors/\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2(-b-h,-b+h);\n}\n\nfloat spheresdf (vec3 p, vec3 sc, float r) {\n        return length(sc - p) - r;\n}\n\nfloat balla (vec3 p) {\n    return spheresdf(p, a, 5.0);\n}\n\nfloat ballb (vec3 p) {\n    return spheresdf(p, vec3(-10.0, -3.0, 25.0), 5.0);\n}\n\n\nvec3 spherenormal (vec3 p, vec3 sc) {\n    return normalize(p - sc);\n}\n\nfloat planesdf (vec3 p, float h) {\n    return p.y - (h);\n}\n\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    // https://iquilezles.org/articles/distfunctions/\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return (mix( d2, d1, h ) - k*h*(1.0-h));\n}\n\n/*float distFromType(vec3 p, int type, Sphere ball, Plane pl) {\n    if (type == 1) {\n        return spheresdf(p, ball);\n    }\n    else if (type == 2) {\n        return planesdf(p, pl);\n    }\n}*/\n\nSphere balls[] = Sphere[2] (\n        Sphere(vec3(0.0, 0.0, 25.0), 5.0),\n        Sphere(vec3(-10.0, -3.0, 25.0), 5.0)\n    \n    ); // haha it says balls\n\nfloat ground = -5.0;\n\nfloat minDist (vec3 rp) {    \n    return smoothUnion(planesdf(rp, ground), min(balla(rp), ballb(rp)), 2.0); //vec2(type, heldDist);\n}\n\nvec2 minObj (vec3 rp) {\n    float a = balla(rp);\n    float b = ballb(rp);\n    float heldDist = min(a,b);\n    int type = 1;\n    int index = a < b ? 0 : 1;\n    \n    float c = smoothUnion(planesdf(rp, ground), heldDist, 2.0);\n    type = c < heldDist ? 2 : 1;\n    index = c < heldDist ? -1 : index;\n    \n    return vec2(type, index);\n}\n\nvec3 smoothNorm(vec3 p) {\n    // int lastType, int type, Sphere ball, Plane pl\n    \n    /*// this formula caused me pain\n    // normal from sdf function taken from alltrue on scratch(they might have taken it from elsewhere)\n    // if there's a faster way ffs please tell me\n    vec3 norm = vec3 (\n        smoothUnion(distFromType(p + vec3(epsilon, 0.0, 0.0), lastType, ball, pl), distFromType(p + vec3(epsilon, 0.0, 0.0), type, ball, pl), 5.0)   -   smoothUnion(distFromType(p - vec3(epsilon, 0.0, 0.0), lastType, ball, pl), distFromType(p - vec3(epsilon, 0.0, 0.0), type, ball, pl), 5.0),\n        smoothUnion(distFromType(p + vec3(0.0, epsilon, 0.0), lastType, ball, pl), distFromType(p + vec3(0.0, epsilon, 0.0), type, ball, pl), 5.0)   -   smoothUnion(distFromType(p - vec3(0.0, epsilon, 0.0), lastType, ball, pl), distFromType(p - vec3(0.0, epsilon, 0.0), type, ball, pl), 5.0),\n        smoothUnion(distFromType(p + vec3(0.0, 0.0, epsilon), lastType, ball, pl), distFromType(p + vec3(0.0, 0.0, epsilon), type, ball, pl), 5.0)   -   smoothUnion(distFromType(p - vec3(0.0, 0.0, epsilon), lastType, ball, pl), distFromType(p - vec3(0.0, 0.0, epsilon), type, ball, pl), 5.0)\n    );\n    norm = normalize(norm); // if i had to put any more code in that one statement i would go insane\n    return norm;*/\n    \n    // https://iquilezles.org/articles/normalsSDF/\n    // i think this formula and the above one are basically the same\n    // but this one is a bit more compact and probably faster\n    vec2 k = vec2(epsilon, 0);\n    return normalize( vec3(\n        minDist(p+k.xyy) - minDist(p-k.xyy),\n        minDist(p+k.yxy) - minDist(p-k.yxy),\n        minDist(p+k.yyx) - minDist(p-k.yyx)\n        ) );\n}\n\nvec3 rotateVec(vec3 v, vec3 rot) {\n    // i didn't make this matrix but at this point idk who to credit so i'll just say i stole it from 3dgas\n    float sx = sin(rot.x);\n    float sy = sin(rot.y);\n    float sz = sin(rot.z);\n    \n    float cx = cos(rot.x);\n    float cy = cos(rot.y);\n    float cz = cos(rot.z);\n    float rotmat[] = float[9] (\n        (cx * cz) - (sx * sy * sz),\n        0.0 - (sz * cy),\n        (sy * cx * sz) + (sx * cz),\n        (sy * sx * cz) + (cx * sz),\n        cy * cz,\n        (sx * sz) - (sy * cx * cz),\n        0.0 - (sx * cy),\n        sy,\n        cy * cx\n    );\n    \n    return vec3(\n        (rotmat[0] * v.x) + (rotmat[1] * v.y) + (rotmat[2] * v.z),\n        (rotmat[3] * v.x) + (rotmat[4] * v.y) + (rotmat[5] * v.z),\n        (rotmat[6] * v.x) + (rotmat[7] * v.y) + (rotmat[8] * v.z)\n    );\n}\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n    // https://iquilezles.org/articles/rmshadows/\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ ) {\n        float h = minDist(ro + rd*t);\n        if( h<mint/10.0 ) {\n            return 0.3; // this looks pretty bad\n        }\n        res = min( res, k*h/t ); // k is the softness, h is the nearest miss, t is the raylength\n        // softness falls off over distance\n        t += h;\n    }\n    return clamp(res+0.3, 0.0, 1.0); // value between epsilon and 1?\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //vec3 lightvec = normalize(rotateVec(normalize(vec3(1.0,1.0,-1.0)), vec3(iTime/8.0, 0.0, 0.0)));\n    vec3 lightvec = normalize(vec3(1.0, 1.0, -1.0));\n    //vec3 campos = vec3(0.0,0.0,0.0);\n    //vec3 camrot = vec3(0.0, 0.0, 0.0);\n    //vec3 camrot = vec3(iTime + ((iMouse.x/iResolution.x + 0.5) * 5.0),0.0,0.0);\n    vec3 camrot = vec3(0, 0, 0);\n    vec3 campos = vec3(0.0, 0.0, -10.0);\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = fragCoord;\n   \n    float focalLength = iResolution.x / tan(radians(fov/2.0)); // this shader uses focal length but fov is cooler\n    \n    coords.x -= iResolution.x/2.0;\n    coords.y -= iResolution.y/2.0;\n    \n    float heldDist = 9999.99; // big number go brrrrr\n    float raylen = 0.0;\n    float last = -1.0;//Sphere(vec3(0.0, 0.0, -99999.0), 5.0);\n    int lastType = -1; // -1 means you fucked up\n    vec3 lastNorm = vec3(0.0,1.0,0.0);\n    // can i say fuck on shadertoy?\n    // imma do it anyways\n    /*\n    1 - sphere\n    2 - plane\n    */\n    \n    \n    vec3 rp = campos;\n    vec3 rv = rotateVec(normalize(vec3 (coords.xy, focalLength)),camrot); // directiony thingy\n    float ypos = sin(iTime * 2.0) * 2.0;\n    ground = ypos - 5.0;\n    while ((raylen < maxDist) && (heldDist > epsilon)) {\n        heldDist = minDist(rp);\n        vec2 objData = minObj(rp);\n        lastType = int(objData.x);\n        if (objData.x == 1.0) {\n            last = objData.y; //balls[int(objData.y)]; \n            lastNorm = spherenormal(rp, last == 0.0 ? a : b);\n        }\n        else if (objData.x == 2.0) {\n            //lastNorm = normalize(vec3(0,1.0,0.0));\n            lastNorm = smoothNorm(rp);\n        }\n       \n        // zooooom\n        raylen += heldDist;\n        rp += rv*heldDist;\n    }\n    \n    \n   \n    if (raylen >= maxDist) {\n        // no bonk : (\n        fragColor = vec4(10.0/255.0, 171.0/255.0, 199.0/255.0, 1.0);\n    }\n    else {\n        // bonk\n        // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model\n        // this is most likely wrong\n        // til it's blinn not bling\n        vec3 normal = lastNorm;//vec3(0,1,0);\n        vec2 uv = vec2 (1.0 - (atan(normal.x,normal.z)/6.28318 + 0.5), normal.y*0.5 + 0.5);\n        vec4 tex = texture(iChannel0,uv);\n        \n        vec3 halfa = normalize(rv + lightvec);\n        float spec = pow(max(dot(halfa, normal),0.0),16.0);\n        // i think the specular highlight direction is backwards but idrc\n        //... or is it?\n        // it is, final answer locking it in\n        float l = clamp((dot(normal, lightvec)*0.55), 0.01, 1.0) + spec; // scene can be made brighter by increasing the 0.55\n        \n        //float l = dot(normal, lightvec);\n        //l *= shadow(rp, lightvec, 0.1, maxDist, 8.0);\n        \n        fragColor = vec4(pow(aces(vec3(l)),vec3(1.0/2.2)) * 1.0, 1.0); // lastType == 1 ? tex.rgb + l : vec3(l)\n       \n    }\n    \n    \n    //fragColor = vec4(uv.x,1.0-uv.y,0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}