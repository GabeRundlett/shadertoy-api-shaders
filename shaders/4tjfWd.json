{
    "Shader": {
        "info": {
            "date": "1517613764",
            "description": "Modified from:\n\nhttps://www.shadertoy.com/view/4d2Xzw\n\nuse the mouse to change the blur intensity and day-night cycle",
            "flags": 32,
            "hasliked": 0,
            "id": "4tjfWd",
            "likes": 12,
            "name": "LOD bokeh blur",
            "published": 3,
            "tags": [
                "blur",
                "bokeh",
                "lod"
            ],
            "usePreview": 1,
            "username": "battlebottle",
            "viewed": 1385
        },
        "renderpass": [
            {
                "code": "//Modified from:\n//\n//https://www.shadertoy.com/view/4d2Xzw\n//\n//A bokeh blur is calculated using by evenly sampling the area of a circle around each pixel, \n//and averaging the result. With a limited set of samples this creates visual artefacts as the \n//blur radius gets bigger. Using lod hides these artifacts without significantly decreasing the \n//blur quality in general.\n//\n//My math for calculating the LOD is probably wrong, but it's close enough to prove the concept.\n//High intensity lights were added to the photo of London to help highlight the bokeh effect.\n\n\n#define GOLDEN_ANGLE 2.39996\n\n#define ITERATIONS 128\n\n#define PI 3.14159265359\n\nconst float SRGB_GAMMA = 1.0 / 2.2;\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n\nvec2 randomPointInCircle(vec2 rand) {\n\tfloat a = rand.x * 2.0 * PI;\n\tfloat r = sqrt(rand.y);\n\tfloat x = r * cos(a);\n\tfloat y = r * sin(a);\n    return vec2(x,y);\n    \n    \n}\n\n\n//Sourced from: //https://www.shadertoy.com/view/4d2Xzw\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, sampler2D noise, vec2 noiseCoord)\n{\n\tvec3 acc = vec3(0);\n    float r = 1.;\n    \n    int iters = int(max(1.0, float(ITERATIONS) * pow(radius, 2.0)));\n    \n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    \n\tfor (int j = 0; j < iters; j++)\n    {\n        r += 1. / r;\n\t    vangle = rot * vangle;\n        vec3 col = textureLod(tex, uv + (r-1.) * vangle, 0.0).xyz;//(radius / 1.5) * sqrt(128.0 / float(iters)) ).xyz * 1.0;\n        acc += col;\n\t}\n    \n\treturn acc / (vec3(float(iters)));\n}\n\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //get uv with correct aspect ratio\n    vec2 uv = fragCoord / iResolution.x + vec2(0.0,0.15); \n    \n    //calculate the blur radius we want\n\tfloat blurRadius = 1.6 - 1.6*cos(mod(iTime*.10 +.25, 3.0) * 6.283); \n    \n    if (iMouse.z > 0.0) {\n     \tblurRadius = iMouse.x / iResolution.x ;   \n    \tblurRadius *= 4.0 ;//* (iResolution.x / 512.0);\n    }\n    \n    \n    //apply bokeh blur\n    vec3 bokeh = Bokeh(iChannel0, uv, blurRadius, iChannel1, fragCoord.xy);\n    \n    //apply ACES Filmic tonemap\n    vec3 bokehACES = ACESFitted(bokeh);\n    \n    //Get a bokeh blurred sample of Buffer A and convert to sRGB\n    fragColor = vec4(pow(bokehACES, vec3(SRGB_GAMMA)), 1.0);\n    \n    //fragColor = texture(iChannel1,  );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float SRGB_GAMMA = 1.0 / 2.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    //Sample texture and convert to linear sRGB color space\n    fragColor =  vec4(pow(texture(iChannel0, uv).rgb, vec3(1.0 / SRGB_GAMMA)), 1.0);\n    \n    //Day-night cycle\n    float dayNightCycle = sin(iTime / 5.0) / 2.0 + 0.5;\n    \n    if (iMouse.z > 0.0) {\n     \tdayNightCycle = 1.0 - iMouse.y / iResolution.y;\n    }\n    \n    \n    vec3 nightColor = vec3(0.1, 0.15, 0.9);\n    vec3 dayColor = vec3(1.0, 0.9, 0.95);\n    vec3 lightColor = nightColor * dayNightCycle + dayColor * (1.0 - dayNightCycle);\n    \n    fragColor = vec4(fragColor.rgb * lightColor, 1.0);\n    \n    \n    //Street lamps\n\tif(distance( uv, vec2(0.1,0.54)) < 0.01){\n\t    fragColor += vec4(vec3(3.6, 3.4, 5.33) * 6.0, 1.0);\n\t}\n\tif(distance( uv, vec2(0.382,0.53)) < 0.008){\n\t    fragColor += vec4(vec3(3.6, 3.4, 5.33) * 6.0, 1.0);\n\t}\n\tif(distance( uv, vec2(0.672,0.53)) < 0.008){\n\t    fragColor += vec4(vec3(3.6, 3.4, 5.33) * 6.0, 1.0);\n\t}\n    \n    //Bus break lights\n\tif(distance( uv, vec2(0.22,0.354)) < 0.003){\n\t    fragColor += vec4(vec3(4.6, 2.4, 1.33) * 4.0, 1.0);\n\t}\n\tif(distance( uv, vec2(0.255,0.357)) < 0.003){\n\t    fragColor += vec4(vec3(4.6, 2.4, 1.33) * 4.0, 1.0);\n\t}\n    \n    //Bus indicator light\n    if (mod(iTime, 1.0) > 0.5) {\n\t\tif(distance( uv, vec2(0.219,0.365)) < 0.0025){\n\t\t    fragColor += vec4(vec3(4.6, 4.4, 1.33) * 4.0, 1.0);\n\t\t}\n    }\n    \n    //fade out\n    \n    if ((1.0 - dayNightCycle) < 0.12) {\n    \tfloat fade = (1.0 - dayNightCycle) * 10.0 -.2;\n        fragColor *= fade;\n        fragColor = max(fragColor, vec4(0.0));\n    };\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}