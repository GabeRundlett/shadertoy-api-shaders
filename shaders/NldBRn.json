{
    "Shader": {
        "info": {
            "date": "1662526422",
            "description": "sdf text test",
            "flags": 0,
            "hasliked": 0,
            "id": "NldBRn",
            "likes": 4,
            "name": "sdf text atlas test",
            "published": 3,
            "tags": [
                "sdftextatlas"
            ],
            "usePreview": 0,
            "username": "jcyuan",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "vec4 charLUT(in vec2 p, in int c) {\n    p.y += .5;\n    vec2 range = step(vec2(0.), p) * step(p, vec2(1.));\n    float check = range.x * range.y;\n    if (check == 0.) return vec4(vec3(0.), 1e+3);\n    vec2 o = p / 16.;\n\treturn textureGrad(iChannel0, o + fract(vec2(c, 15 - c / 16) / 16.), dFdx(o), dFdy(o));\n}\n\nvec4 _tmpChrVal;\nfloat charSpacing = .5;\nvec2 textUv;\nvec4 textOutput;\n\nvoid reset() {\n    _tmpChrVal = vec4(vec3(0.), 1e+3);\n    textUv = vec2(0);\n    textOutput = vec4(vec3(0), 1e+3);    \n}\n\nfloat getWold1(in vec2 p, float size) {\n    reset();\n    textUv = p * 64. / size;\n    textUv.x += 13.5 * charSpacing * .5;\n    \n    _H _e _l _l _o _space _W _o _r _l _d _exc\n    \n    return textOutput.w;\n}\n\nfloat getWold2(in vec2 p, float size) {\n    reset();\n    textUv = p * 64. / size;\n    textUv.x += 17.5 * charSpacing * .5;\n    \n    _I _space _a _m _space _a _space _t _e _x _t _space _t _e _s _t _exc\n    \n    return textOutput.w;\n}\n\nfloat timeSpan(float t, float from, float to) {\n    return clamp((t - from) / (to - from), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float d1 = getWold1(uv, 20.);\n    float d2 = getWold2(uv, 20.);\n    float t = mod(iTime, 4.);\n    float t1 = timeSpan(t, .0, .4);\n    float t2 = timeSpan(t, .4, 1.);\n    float t3 = timeSpan(t, 1.2, 1.8);\n    float t4 = timeSpan(t, 1.8, 2.6);\n    float t5 = timeSpan(t, 2.6, 3.8);\n    float d = mix(1., d1, t1);\n    d = mix(d, d1, t2);\n    d = mix(d, d2, t3);\n    d = mix(d, d2, t4);\n    d = mix(d, 1., t5);\n    \n    fragColor = vec4(vec3(smoothstep(.0, .08, abs(d))), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define S(c) _tmpChrVal = charLUT(textUv, c); textOutput.xyz += _tmpChrVal.xyz; textOutput.w = min(textOutput.w, 2. * _tmpChrVal.w - 1.); textUv.x -= charSpacing;\n\n#define _A S(65)\n#define _B S(66)\n#define _C S(67)\n#define _D S(68)\n#define _E S(69)\n#define _F S(70)\n#define _G S(71)\n#define _H S(72)\n#define _I S(73)\n#define _J S(74)\n#define _K S(75)\n#define _L S(76)\n#define _M S(77)\n#define _N S(78)\n#define _O S(79)\n#define _P S(80)\n#define _Q S(81)\n#define _R S(82)\n#define _S S(83)\n#define _T S(84)\n#define _U S(85)\n#define _V S(86)\n#define _W S(87)\n#define _X S(88)\n#define _Y S(89)\n#define _Z S(90)\n\n#define _a S(97)\n#define _b S(98)\n#define _c S(99)\n#define _d S(100)\n#define _e S(101)\n#define _f S(102)\n#define _g S(103)\n#define _h S(104)\n#define _i S(105)\n#define _j S(106)\n#define _k S(107)\n#define _l S(108)\n#define _m S(109)\n#define _n S(110)\n#define _o S(111)\n#define _p S(112)\n#define _q S(113)\n#define _r S(114)\n#define _s S(115)\n#define _t S(116)\n#define _u S(117)\n#define _v S(118)\n#define _w S(119)\n#define _x S(120)\n#define _y S(121)\n#define _z S(122)\n\n#define _0 S(48)\n#define _1 S(49)\n#define _2 S(50)\n#define _3 S(51)\n#define _4 S(52)\n#define _5 S(53)\n#define _6 S(54)\n#define _7 S(55)\n#define _8 S(56)\n#define _9 S(57)\n\n#define _add  S(43)\n#define _dot  S(46)\n#define _exc  S(33)\n#define _space S(32)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}