{
    "Shader": {
        "info": {
            "date": "1584203185",
            "description": "I used a crude version of this of this for [url=https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/source.gif]Fractal Polycephaly[/url]\n\nOld version can be found here [url]https://www.shadertoy.com/view/tscfRS[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wslyzH",
            "likes": 13,
            "name": "Logarithmic Conical Spiral",
            "published": 3,
            "tags": [
                "fractal",
                "spiral",
                "camera",
                "loop",
                "path",
                "logarithmic"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 753
        },
        "renderpass": [
            {
                "code": "/*\n\n\tLogarithmic Conical Spiral Center and Axis\n\t------------------------------------------\n\n\tWhen iteratively applying a transformtion matrix, the\n\tpositions visited form a logarithmic spiral on a cone.\n\t\n\tThis calculates the center (tip) and axis of that cone,\n\tas well as the angle between each iteration.\n\n\tThe general approach is to ignore the scaling component\n\tof the matrix, such that multiple iterations form a\n\tcylinder instead of a cone. Once we have the axis and\n\tposition of the cylinder, we can triangulate the tip of\n\tthe cone.\n\n\tWith these parameters, we can create a method that\n\trotates and scales space over time to smoothly transform\n\tthe second instance into the first, forming a\n\tseamless loop.\n\n\tSee also the 2d version:\n\thttps://www.shadertoy.com/view/tscBDH\n\n*/\n\n// Matrix functions\n// --------------------------------------------------------\n\nmat4 mTranslate(vec3 t) {\n\treturn mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0, 1\n   \t);\n}\n\nmat4 mRotate(vec3 forward, vec3 up) {\n    vec3 ww = normalize(forward * vec3(1,1,-1));\n    vec3 uu = normalize(cross(up * vec3(-1,1,1),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    return mat4(\n        uu, 0,\n        vv, 0,\n        ww, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 mScale(float s) {\n\treturn mat4(\n    \ts, 0, 0, 0,\n        0, s, 0, 0,\n        0, 0, s, 0,\n        0, 0, 0, 1\n    );\n}\n\nfloat getScale(mat4 m) {\n\treturn length(m[0].xyz);\n}\n\nvec3 mul(vec3 p, mat4 m) {\n\treturn (vec4(p, 1) * m).xyz;\n}\n\n\n// Logarithmic conical spiral center, axis, and angle\n// --------------------------------------------------------\n\n#define PI 3.1415926\n\n// Logarithmic spiral center\n// https://www.shadertoy.com/view/tscBDH\nvec2 spiralCenter(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\nvoid conicalSpiral(mat4 txm, float txmScale, out vec3 axis, out float angle, out vec3 center) {\n\n    // Remove scaling from transformation matrix\n    mat4 txmns = mScale(1. / txmScale) * txm;\n    \n    // Get first four positions, these form a cylinder\n    vec3 v0 = vec3(0);\n    vec3 v1 = mul(v0, txmns);\n    vec3 v2 = mul(v1, txmns);\n    vec3 v3 = mul(v2, txmns);\n    \n\n\t// Cylinder axis\n    // -------------\n    \n    // Calculate normals for the two middle points\n    vec3 n0 = v1 - mix(v0, v2, .5);\n    vec3 n1 = v2 - mix(v1, v3, .5);\n\n    // Cross for cylinder axis\n    axis = normalize(cross(n0, n1));\n\n    // Rotation matrix for cylinder direction\n    mat3 mAxis = mat3(n0, cross(axis, n0), axis);\n\n\n  \t// Angle between iterations\n    // ------------------------\n\n    // Project points onto axis plane\n    vec2 p1 = (v1 * mAxis).xy;\n    vec2 p2 = (v2 * mAxis).xy;\n\n    // Angle between the points\n    angle = PI - acos(dot(normalize(-p1), normalize(p2 - p1)));    \n    \n\n\t// Cone center (tip)\n\t// -----------------\n\n    // Center of the 2d logarithmic spiral\n    vec2 center2d = spiralCenter(p1, angle, txmScale);\n\n    // Transform back into 3d\n    center = vec3(center2d, 0) * inverse(mAxis);\n    \n    // Extrapolate the line between v0 and v1 to find the tip\n    float v1Height = dot(v1, axis);\n    float v1Radius = distance(center2d, p1);\n    center += axis * v1Height * (length(center2d) / (length(center2d) - v1Radius));\n}\n\n\n// Camera movement\n// --------------------------------------------------------\n\nmat4 txm;\nmat4 txmi;\nfloat txmScale;\n\nvec3 cameraAxis;\nfloat cameraAngle;\nvec3 cameraApex;\n\n// Rotate around axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n// With the calculated spiral properties, rotate and scale space\n// (aka move the camera), by a given amount until we have transformed\n// the second iteration into the first iteration\nfloat tweenCamera(inout vec3 p, float t) {\n    float scale = pow(txmScale, t);\n    p -= cameraApex;\n    p = erot(p, cameraAxis, cameraAngle * t);\n    p *= scale;    \n    p += cameraApex;\n    return scale;\n}\n\n\n// Modeling\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fLine(vec3 p, vec3 n) {\n    float t = dot(p, n) / dot(n, n);\n    return length((n * t) - p) ;\n}\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    int id;\n};\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    }\n    return b;\n}\n\nModel mGizmo(vec3 p) {\n\tfloat d = fBox(p, vec3(.5, .5, .5));\n   \treturn Model(d, p, 1);\n}\n\nModel mAxisAndCenter(vec3 p) {\n    float axis = fLine(p - cameraApex, cameraAxis) - .08;\n    float center = length(p - cameraApex) - .3;\n    float d = min(axis, center);\n   \treturn Model(d, p, 2);\n}\n\nModel scene(vec3 p) {\n    \n    Model model = mAxisAndCenter(p);\n\n    float scale = 1.;\n    vec3 pp = p;\n    \n    for (int i = 0; i < 15; i++) {\n        // Draw gizmo\n\t\tModel gizmo = mGizmo(p);\n        gizmo.d *= scale; // Fix distance for scale factor\n        model = opU(model, gizmo);\n        \n        // Apply matrix and scale\n        p = mul(p, txmi);\n        scale *= txmScale;\n    }\n\n\tscale = 1.;\n    p = mul(pp, txm);\n    \n    for (int i = 0; i < 12; i++) {\n        // Draw gizmo\n\t\tModel gizmo = mGizmo(p);\n        gizmo.d *= scale; // Fix distance for scale factor\n        model = opU(model, gizmo);\n        \n        // Apply matrix and scale\n        p = mul(p, txm);\n        scale /= txmScale;\n    }\n    \n    return model;\n}\n\nModel map(vec3 p) {\n    float scale = tweenCamera(p, mod(iTime * 2., 1.));\n    Model model = scene(p);\n    model.d /= scale;\n    return model;\n}\n\n\n\n// Rendering\n// --------------------------------------------------------\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    float t = iTime / 3. + .5;\n    \n    // Build the TRS transformation matrix for each iteration\n    mat4 mT = mTranslate(vec3(0, cos(t/2.), -sin(t/2.)) * (cos(t/2.) * .25 + 1.5));\n    mat4 mR = mRotate(vec3(cos(t) * -.5, cos(t/2.) * -.5, -1), vec3(sin(t) * -.5, 1, 0));\n    mat4 mS = mScale(.8 + sin(t) * .05);\n\ttxm = mS * mR * mT;\n    txmScale = getScale(txm);\n\ttxmi = inverse(txm);    \n\n    // Find conical spiral parameters for camera movement\n    conicalSpiral(txm, txmScale, cameraAxis, cameraAngle, cameraApex);\n    \n    \n    // Ray marching\n\n    float focalLength = 2.4;\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(vec3(p, -focalLength));\n    vec3 rayOrigin = vec3(0,0,15);\n    vec3 rayPosition = rayOrigin;\n    float rayLength = 0.;\n\n    Model model;\n    float dist = 0.;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 color = bgcol;\n    bool isBackground = false;\n\n    for (float i = 0.; i < 100.; i++) {\n        rayLength += dist;\n        rayPosition = rayOrigin + rayDirection * rayLength;\n        model = map(rayPosition);\n\t\tdist = model.d;\n        \n        if (dist < .001) {\n            break;\n        }\n\n        if (rayLength > 50.) {\n            isBackground = true;\n            break;\n        }\n    }\n\n    if ( ! isBackground) {\n        if (model.id == 2) {\n        \tcolor = vec3(1);\n        } else {\n    \t\tvec3 face = step(vec3(vmax(abs(model.p))), abs(model.p)) * sign(model.p);\n            float faceIndex = max(vmax(face * vec3(0,1,2)), vmax(face * -vec3(3,4,5)));\n    \t\tcolor = spectrum(faceIndex / 6.);\n    \t}\n    }\n    \n    float fog = 1. - exp((rayLength - 13.) * -.25);\n    color = mix(color, bgcol, clamp(fog, 0., 1.));\n\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n    fragColor = vec4(color, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}