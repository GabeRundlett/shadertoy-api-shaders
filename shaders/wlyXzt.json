{
    "Shader": {
        "info": {
            "date": "1583445047",
            "description": "Don't ask me about the name idk what it means",
            "flags": 32,
            "hasliked": 0,
            "id": "wlyXzt",
            "likes": 62,
            "name": "Chromatic crystalline veneer",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "mandelbulb",
                "pathtracing",
                "tracing",
                "fresnel",
                "path",
                "realism"
            ],
            "usePreview": 1,
            "username": "loicvdb",
            "viewed": 1421
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.4 * iResolution.y, fragCoord) * .07;\n    bloomSum += bloom(.07 * iResolution.y, fragCoord) * .07;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = ACESFilm(fragColor.rgb+bloomSum);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Pi 3.14159265359\n\n// radius of the scene\n#define SceneRadius 100.\n// minimum distance before considering a hit\n#define MinDist .01\n// maximum number of steps when tracing a ray\n#define MaxSteps 512\n// number of light bounces\n#define RayDepth 3\n// Ior of the fresnel effect on the reflections\n#define Ior 1.45\n// enable reflexion caustics for more realism\n#define Caustics false\n\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n\nfloat seed;\n\nvec3 CamPos = vec3(0, 0, -4.);\nvec3 CamRot = vec3(0., -1.5, 0.);\nfloat CamFocalLength = 1.5;\nfloat CamFocalDistance = 3.25;\nfloat CamAperture = .05;\n\nvec3 LightDir = normalize(vec3(-.0, -.1, .1));\nvec3 LightColor = vec3(4.);\nfloat LightRadius = .3;\n\n// self explanatory ...\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\n// cosine weighted sample for diffuse samples\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n// cone sample for NEE on a spherical cap\nvec3 getConeSample(vec3 dir, float theta) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = 1. - r.y*(1.-cos(min(theta, Pi*.5)));\n\tfloat oneminus = sqrt(1.0 - r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n// fresnel\nfloat fresnel(vec3 dir, vec3 n, float ior) {\n    float cosi = dot(dir, n);\n    float etai = 1.0;\n  \tfloat etat = ior;\n    if (cosi > 0.0) {\n         float tmp = etai;\n         etai = etat;\n         etat = tmp;\n     }\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if (sint >= 1.0) return 1.0;\n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\n// julia variant of the quadratic mandelbulb\n// http://www.bugman123.com/Hypercomplex/index.html\nfloat sdfMandelbulb(vec3 z, vec3 c, out vec3 diffuseColor){\n    z *= rotationMatrix(vec2(.0, .08).xxy);\n    vec3 orbitTrap = vec3(1);\n    float r = length(z);\n\tfloat dr = 1., xxyy;\n    for (int i = 0; i < 100; i++) {\n        xxyy = z.x*z.x+z.y*z.y;\n        r = sqrt(xxyy+z.z*z.z);\n        orbitTrap = min(orbitTrap, abs(z*3.));\n        if (r>10.) break;\n        dr = r*2.*dr + 1.;\n        z = vec3(vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y)*(1.-z.z*z.z/xxyy), -2.*z.z*sqrt(xxyy)) + c;\n    }\n    diffuseColor = 1.-orbitTrap;\n\treturn 0.5*log(r)*r/dr;\n    \n}\n\n// plane with a texture and POM\nfloat sdfPlane(vec3 pos, out vec3 diffuseColor){\n    diffuseColor = texture(iChannel2, pos.xz*.5).rgb;\n    // uncomment for a checkerboard pattern\n    //diffuseColor = fract(pos.x)<.5 ^^ fract(pos.z)<.5 ? vec3(0) : vec3(1);\n    return pos.y + .51 + length(diffuseColor)*.001;\n}\n\nfloat sdf(vec3 pos, out vec3 diffuseColor){\n    \n    vec3 c = vec3(-1.26, .37, .0);\n    \n    vec3 dcM, dcS;\n    float s = sdfPlane(pos, diffuseColor);\n    float sM = sdfMandelbulb(pos, c, dcM);\n    if(sM < s){\n        diffuseColor = dcM;\n        s = sM;\n    }\n    return s;   \n}\n\nfloat sdf(vec3 pos){\n    vec3 ph; // placeholder\n    return sdf(pos, ph);\n}\n\n// UPDATE (29/12/2021) : fixed the NaN issue causing a black screen\nvec3 normal(vec3 pos, float dist){\n    vec2 k = vec2(abs(dist) + 0.0000001, 0.);\n    return normalize(vec3(sdf(pos + k.xyy),\n\t  \t\t\t\t\t  sdf(pos + k.yxy),\n  \t\t\t\t          sdf(pos + k.yyx)) - vec3(dist));\n}\n\n// traces a ray\nbool rayHit(inout vec3 pos, vec3 dir){\n    pos += RANDOM * sdf(pos) * dir;\n    float dist;\n    for(int i = 0; i < MaxSteps; i++){\n        dist = sdf(pos);\n        if(length(pos) > SceneRadius) break;\n        if(dist < MinDist) return true;\n        pos += dir * dist * .99;\n    }\n    return false;\n}\n\n// traces a shadow ray and computes direct light on the surface\nvec3 directLight(vec3 pos, vec3 n){\n    vec3 dir = getConeSample(-LightDir, LightRadius);\n    float dnrd = dot(n, dir);\n    if(dnrd < 0.0) return vec3(0);\n    return rayHit(pos, dir) ? vec3(0.) : LightColor * dnrd * (1.-fresnel(-dir, n, Ior));\n}\n\n\nvec3 background(vec3 dir) {\n    vec3 col = texture(iChannel1, dir).rgb;\n    return col*col+col;\n}\n\n// path tracing algorithm\nvec3 pathTrace(vec3 pos, vec3 dir){\n    \n    vec3 light = vec3(0.), attenuation = vec3(1.);\n    \n    // set this to zero for no reflected light at all (when fireflies are too annoying)\n    vec3 LCsLR2 = LightColor/(sin(LightRadius)*sin(LightRadius)); \n    \n    bool diffuse = false;\n    for(int i = 0; i <= RayDepth; i++){\n        \n        if(sdf(pos) < 0.) return light;\n        \n        // if the ray doesn't hit anything, the background gets rendered\n        if(!rayHit(pos, dir))\n            return light + attenuation *\n            \t(dot(dir, -LightDir) > cos(LightRadius)\t\t// if the ray end up in the light\n                    ? diffuse\t\t\t\t\t\t\t\t// if the ray if a diffuse ray\n                        ? vec3(0.)\t\t\t\t\t\t\t// then don't add any background (direct light already in nee)\n                        : LCsLR2\t\t\t\t\t\t\t// else add the light color\n                    : background(dir)\t\t\t\t\t\t// else sample the cubemap\n                );\n        \n        vec3 diffuseColor;\n        float dist = sdf(pos, diffuseColor);\n        vec3 n = normal(pos, dist);\n        pos += n*(1.5*MinDist-dist);\n        \n        // nee\n        light += attenuation * diffuseColor * directLight(pos, n);\n        \n        if(fresnel(dir, n, Ior) > RANDOM) {\n            // reflection\n            dir = reflect(dir, n);\n            if(Caustics) diffuse = false;\n        } else {\n            // diffuse\n            dir = getCosineWeightedSample(n);\n        \tattenuation *= diffuseColor;\n            diffuse = true;\n        }\n    }\n    return light;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation){\n    \n    // create a point on the first \"blade\"\n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.) tri = vec2(1.-tri.x, -1.+tri.y);\n    tri *= vec2(side, sqrt(1.-side*side));\n    \n    // rotate it to create the other blades\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    \n    //mouse mouvement\n    CamRot.yx -= Pi*(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    CamPos *= rotationMatrix(CamRot);\n    \n    // random numbers seed\n    seed = cos(iTime)+cos(fragCoord.x)+sin(fragCoord.y);\n    \n    // uv on the camera sensor (from -1 to 1 vertically)\n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy*.5) / iResolution.y;\n    \n    // gerenate ray direction & position in camera space\n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n    vec3 dir = normalize(focalPoint-aperture);\n    vec3 pos = aperture;\n    \n    // convertion to world space\n    mat3 CamMatrix = rotationMatrix(CamRot);\n    dir *= CamMatrix;\n    pos = pos*CamMatrix + CamPos;\n    \n    fragColor = iFrame == 0 ? vec4(0.) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.) fragColor.a = 0.;\n    fragColor.rgb = mix(fragColor.rgb, pathTrace(pos, dir), 1.0/(++fragColor.a));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}