{
    "Shader": {
        "info": {
            "date": "1533799226",
            "description": "For the 2018 Shadertoy Competition\n\n[insert mildly witty remark about 'the human race' here]",
            "flags": 32,
            "hasliked": 0,
            "id": "ltdyDr",
            "likes": 49,
            "name": "[SH18] Zoomin' Humans",
            "published": 3,
            "tags": [
                "distancefields",
                "human",
                "sh18"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 1082
        },
        "renderpass": [
            {
                "code": "// My submission for the 2018 Shadertoy 'Human' Challenge\n\n// Tip #1: Mess with the human proportions in the common tab for a wilder variety of people.\n\n// Tip #2: The main runner moves at 111 BPM, so you can sync him with \"St. Elmo's Fire (Man in Motion)\"\n// by John Parr if you want to add some extra drama (and a bit of camp) to the scene.\n\n// Special thanks to the Shadertoy community. I only joined recently, but reverse engineering projects\n// on this site is how I first learned shader programming around four years ago.\n\n// Also, possible bug report: If I use an input like 'iTime' in the common tab, I receive an\n// \"undeclared identifier\" warning but it works just fine. Is this intentional?\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x = 1.0-uv.x;\t//quick image flip because I prefer it this way but I programmed it the other way around\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    #ifdef ENABLE_BLOOM\n    //bloom - vertical pass\n    vec3 bloom = vec3(0.0);\n    float acc;\n    for( float f=-BLOOM_SAMPLES; f<BLOOM_SAMPLES; f++ ) {\n        float offset = f+hash(uv.x+uv.y+iTime)-0.5;\n        float weight = gaussian(offset, 1.0/BLOOM_SAMPLES);\n        acc += weight;\n        vec2 sp = vec2( uv.x, uv.y+offset*BLOOM_SCALE );\n        bloom += texture(iChannel1, sp).rgb * weight;\n    }\n    bloom /= acc;\n    col += bloom*BLOOM_STRENGTH;\n    #endif\n    \n    //filmic tonemapping -- http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    col = max(col-0.004, 0.0);\n    col = col*(6.2*col+0.5)/(col*(6.2*col+1.7)+0.06);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//RUNNER REFLECTIONS\n\n\nfloat distancetocoverage( float d ) {\n    return clamp(d*iResolution.y/2.0+0.5, 0.0, 1.0);\n}\n\n\nvec2 processhumandf( vec2 d, float z ) {\n\tfloat area = distancetocoverage(d.y/z);\n    float near = distancetocoverage(d.x/z);\n    float edge = clamp(1.0-d.y*75.0, 0.0, 1.0);\n    //float dist = clamp(sin(d.x*200.0+iTime*10.0), 0.0, 1.0);\n    \n\treturn vec2( max(min(max(near, near-d.x*10.0), 1.0),edge*3.0)*area, area );\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n//MAIN\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y*2.0 - vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec3 col = vec3(0.0);\n    vec2 rd = vec2(0.0);\n    \n    //ground plane\n    if( uv.y<0.0 ) {\n        //'distant runner reflections'\n        col *= clamp(-uv.y*7.0-0.1, 0.0, 1.0);\n        \n        //reflections\n    \tvec2 uvr = vec2( uv.x, -uv.y );\n    \trd = runnerhq(uvr-vec2(0.0,1.6), iTime, 1.0, 1.0, 0.0, 0.4, 0.25, 0.12, 0.005);\n        rd = processhumandf( rd, 1.0 );\n        \n    \tfloat rz = rd.y;\n    \n    \tfor(float f=0.0; f<RUNNER_REFLECTIONS; f++) {\n        \tfloat zdist = mix(2.0, MAX_RUNNER_DISTANCE, sqrt(f/NUMBER_OF_RUNNERS));\n        \n        \t//break if uv.y is too low to show character at zdist, or if nearer runner has filled pixel\n        \tif ( (uvr.y>3.1/zdist) || rd.y==1.0 ) break;\n        \n        \tfloat speed = mix(0.5, 3.0, hash(f+10.0));\n        \tfloat xpos = hash(f+50.0)*100.0*zdist + (iTime+20.0)*(speed-1.0);\n        \tfloat limblength = mix( LIMB_MIN, LIMB_MAX, hash(f+100.0) );\n            float bodylength = mix( TORSO_MIN, TORSO_MAX, hash(f+200.0) );\n        \n        \tspeed /= limblength*2.0/0.8;\n        \txpos = mod(xpos, 4.0*zdist)-2.0*zdist;\n            \n            if ( (abs(uvr.x*zdist+xpos)<limblength*2.0+0.2) &&\n                 (uvr.y<((limblength+bodylength+HEAD_MAX+MAX_THICKNESS)*2.0+0.95)/zdist) && (uvr.y>0.8/zdist) ) {\n            float headsize   = mix( HEAD_MIN, HEAD_MAX, hash(f+300.0) );\n        \t\tfloat thickness  = hash(f+400.0)*MAX_THICKNESS;\n            \n        \t\tvec2 h = zdist<5.0 ? runnerhq(uvr-vec2(0.0,1.6/zdist), iTime+f, speed, zdist, xpos, limblength, bodylength, headsize, thickness) :\n            \t\t\t\t\t\t runnerlq(uvr-vec2(0.0,1.6/zdist), iTime+f, speed, zdist, xpos, limblength, bodylength, headsize, thickness);\n                \n                h = processhumandf( h, zdist );\n                \n                //check bounding boxes\n            \t//rd += 0.2;\n                \n            \tif(h.y>0.0) {\n                \trz = mix(rz, 1.0/zdist, 1.0-rd.y);\n                \trd.x = mix(rd.x, h.x, h.y);\n                    rd.y = min(h.y+rd.y, 1.0);\n                \t//rd.y = h.y*(1.0-rd.y)+rd.y;\n        \t\t}\n        \t}\n    \t}\n\n        col = vec3(6.0,0.75,0.15);\n        col *= rd.x*0.5+0.5;\n    \tcol = mix(vec3(0.0), col, rz*rz);\n    \t//col = max(col*uv.y/rz+1.0, 0.0);\n    }\n    \n    fragColor = vec4(col,rd.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define NUMBER_OF_RUNNERS\t1000.0\n#define MAX_RUNNER_DISTANCE\t40.0\n\n#define REFLECTION_STRENGTH 0.1\n#define RUNNER_REFLECTIONS\t300.0\n#define REFLECTION_SAMPLES  3.0\n#define REFLECTION_SMEAR    0.03\n\n#define ENABLE_BLOOM\n#define BLOOM_SAMPLES       5.0\n#define BLOOM_SCALE         0.01\n#define BLOOM_STRENGTH      0.03\n\n#define HEAD_MIN\t\t\t0.07\n#define HEAD_MAX\t\t\t0.17\n#define TORSO_MIN\t\t\t0.15\n#define TORSO_MAX\t\t\t0.35\n#define LIMB_MIN\t\t\t0.2\n#define LIMB_MAX\t\t\t0.6\n#define MAX_THICKNESS\t\t0.075\n\n\n//#define iTime (iTime+hash(iTime*uv.x*uv.y)/60.0)\n\n\n#define PI      3.14159265\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n//MATH FUNCTIONS\n\n\n//from Dave Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat hash( float p ) {\n\tvec3 p3  = fract(vec3(p) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat gaussian( float p, float s ) {\n    return exp2(p*p*-s);\n}\n\n\nvec3 child( vec3 parent, float l, float theta ) {\n    //offset and rotate joint relative to parent\n    theta += parent.z;\n    vec2 offset = vec2(sin(theta),cos(theta))*l;\n\treturn vec3(parent.xy + offset, theta);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n//DISTANCE FUNCTIONS (>0 = inside shape,  <0 = outside shape)\n\n\nfloat circle( vec2 uv, vec2 p, float r ) {\n    return r-distance(uv,p);\n}\n\n\nfloat linesegment( vec2 uv, vec2 pa, vec2 pb, float r) {\t\t//pa and pb are endpoints of line\n    vec2 o = uv-pa;\t\t\t\t\t\t\t\t\t\t\t\t//pa relative to uv\n    vec2 l = pb-pa;\t\t\t\t\t\t\t\t\t\t\t\t//pb relative to pa\n    float h = clamp( dot(o,l)/dot(l,l), 0.0, 1.0 );\t\t\t\t//position of nearest point along line from pa to pb\t\n    return r-distance(o,l*h);\n}\n\n\nfloat linesegment( vec2 uv, vec2 pa, vec2 pb, float ra, float rb) {\n    //Bug: draws only pa circle if rb>ra and ra is within area of rb\n    //The 'nc' definition may not be correct. I initially calculated that\n    //the (ll-xa+xb) should be (ll-xa*2.0+xb), but that didn't work and I\n    //never figured out why this does instead.\n    vec2 o = uv-pa;\t\t\t\t\t\t\t\t\t\t\t\t//uv relative to pa\n    vec2 l = pb-pa;\t\t\t\t\t\t\t\t\t\t\t\t//pb relative to pa\n    float ll = length(l);\t\t\t\t\t\t\t\t\t\t//distance from pa to pb\n    float theta = (ra-rb)/ll;\t\t\t\t\t\t\t\t\t//sin of slope angle\n    float xa = ra*theta;\t\t\t\t\t\t\t\t\t\t//projection of furthest valuable radius a onto line\n    float xb = rb*theta;\t\t\t\t\t\t\t\t\t\t//projection of furthest valuable radius b onto line\n    float h = dot(o,l)/ll;\t\t\t\t\t\t\t\t\t\t//(nearest point on line as a mix between pa and pb) * (line length)\n    float nc = clamp((h-xa)/(ll-xa+xb),0.0,1.0);\t\t\t\t//linear position of nearest circle\n    return mix(ra,rb,nc)-distance(o,l*nc);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n//HUMAN DISTANCE FIELD FUNCTIONS\n\n\nvec2 runnerhq( vec2 uv, float t, float speed, float zdist, float xpos, float legl, float bod, float headsize, float th ) {    \n    uv *= zdist;\n    uv.x += xpos;\n    \n    t *= speed*PI*0.925;\n\tfloat ct = cos(t)*PI;\n    float st = sin(t)*PI;\n    \n    float arml = legl*0.75;\n    float twist = ct*0.025;\n    \n    //joint positions - z component stores rotation\n    vec3 root      = vec3(0.0, legl*2.0-0.8+th+abs(ct*0.02), -0.25);\n    vec3 mid       = child(root,  \t   bod, -PI*0.05);\n    vec3 collar    = child(mid,   0.05+bod,  PI*0.1);\n    vec3 head      = child(collar, 0.08+headsize, -PI*0.1);\n    \n    vec3 shoulderl = child(collar,  -twist, -PI*0.5);\n    vec3 shoulderr = child(collar,   twist, -PI*0.5);\n    vec3 elbowl    = child(shoulderl, arml, -PI*0.5-ct*0.4);\n    vec3 elbowr    = child(shoulderr, arml, -PI*0.5+ct*0.4);\n    vec3 handl     = child(elbowl,    arml,  PI*0.4-ct*0.2);\n    vec3 handr     = child(elbowr,    arml,  PI*0.4+ct*0.2);\n    \n    vec3 hipl      = child(root,\t twist, -PI*0.5);\n    vec3 hipr      = child(root,\t-twist, -PI*0.5);\n    vec3 kneel     = child(hipl,      legl, -PI*0.35+ct*0.35);\n    vec3 kneer     = child(hipr,      legl, -PI*0.35-ct*0.35);\n    vec3 anklel    = child(kneel,     legl, -PI*0.35+st*0.35);\n    vec3 ankler    = child(kneer,     legl, -PI*0.35-st*0.35);\n    vec3 toesl     = child(anklel,    0.15,  PI*0.5+ct*0.15);\n    vec3 toesr     = child(ankler,    0.15,  PI*0.5-ct*0.15);\n    \n    //distance fields - dn for 'near' body parts, df for 'far' body parts\n    float dn, df;\n    \n    dn = \t     linesegment( uv, hipl.xy,      mid.xy,    0.075, 0.05 );\t\t//left hip\n    df = \t\t linesegment( uv, hipr.xy,      mid.xy,    0.075, 0.05 );\t\t//right hip\n    dn = max(dn, linesegment( uv, mid.xy,       collar.xy, 0.05 ) );\t\t\t//upper torso\n    dn = max(dn, linesegment( uv, shoulderl.xy, mid.xy,    0.05 ) );\t\t\t//left ribs\n    df = max(df, linesegment( uv, shoulderr.xy, mid.xy,    0.05 ) );\t\t\t//right ribs\n    dn = max(dn, linesegment( uv, shoulderl.xy, collar.xy, 0.05 ) );\t\t\t//left shoulder\n    df = max(df, linesegment( uv, shoulderr.xy, collar.xy, 0.05 ) );\t\t\t//right shoulder\n    dn = max(dn, linesegment( uv, collar.xy,    head.xy,   0.05 ) );\t\t\t//neck\n    dn = max(dn, circle(      uv, head.xy,                 headsize ) );\t\t//head\n    \n    dn = max(dn, linesegment( uv, shoulderl.xy, elbowl.xy, 0.05 ) );\t\t\t//left upper arm\n    df = max(df, linesegment( uv, shoulderr.xy, elbowr.xy, 0.05 ) );\t\t\t//right upper arm\n    dn = max(dn, linesegment( uv, elbowl.xy,    handl.xy,  0.05,  0.025 ) );\t//left forearm\n    df = max(df, linesegment( uv, elbowr.xy,    handr.xy,  0.05,  0.025 ) );\t//right forearm\n    dn = max(dn, circle(      uv, handl.xy,                0.05 ) );\t\t\t//left hand\n    df = max(df, circle(      uv, handr.xy,                0.05 ) );\t\t\t//right hand\n\n    df = max(df, linesegment( uv, hipl.xy,      hipr.xy,   0.075 ) );\t\t\t//groin\n    dn = max(dn, linesegment( uv, hipl.xy,      kneel.xy,  0.075, 0.05 ) );\t\t//left thigh\n    df = max(df, linesegment( uv, hipr.xy,      kneer.xy,  0.075, 0.05 ) );\t\t//right thigh\n    dn = max(dn, linesegment( uv, kneel.xy,     anklel.xy, 0.05,  0.025 ) );\t//left shin\n    df = max(df, linesegment( uv, kneer.xy,     ankler.xy, 0.05,  0.025 ) );\t//right shin\n    dn = max(dn, linesegment( uv, anklel.xy,    toesl.xy,  0.025, 0.0125 ) );\t//left foot\n    df = max(df, linesegment( uv, ankler.xy,    toesr.xy,  0.025, 0.0125 ) );\t//right foot\n    \n    dn += th;\n    df += th;\n    \n    return vec2( dn, max(dn,df) );\n}\n\n\nvec2 runnerlq( vec2 uv, float t, float speed, float zdist, float xpos, float legl, float bod, float headsize, float th ) {\n\tuv *= zdist;\n    uv.x += xpos;\n    \n    t *= speed*PI*0.925;\n\tfloat ct = cos(t)*PI;\n    float st = sin(t)*PI;\n    \n    float arml = legl*0.75;\n    \n    //joint positions - z component stores rotation\n    vec3 root   = vec3(0.0, legl*2.0-0.8+th+abs(ct*0.02), -0.25);\n    vec3 collar = child(root,   bod*2.0+0.05, -PI*0.01);\n    vec3 head   = child(collar, 0.08+headsize, 0.0);\n    vec3 elbowl = child(collar, arml, -PI-ct*0.4);\n    vec3 elbowr = child(collar, arml, -PI+ct*0.4);\n    vec3 handl  = child(elbowl, arml,  PI*0.4-ct*0.2);\n    vec3 handr  = child(elbowr, arml,  PI*0.4+ct*0.2);\n    vec3 kneel  = child(root,   legl, -PI*0.85+ct*0.35);\n    vec3 kneer  = child(root,   legl, -PI*0.85-ct*0.35);\n    vec3 anklel = child(kneel,  legl, -PI*0.35+st*0.35);\n    vec3 ankler = child(kneer,  legl, -PI*0.35-st*0.35);\n    \n    //distance fields - dn for 'near' body parts, df for 'far' body parts\n    float dn, df;\n    dn =         linesegment( uv, root.xy,   head.xy,   0.0625 );\t\t//torso\n    dn = max(dn, circle( \t  uv, head.xy,              headsize ) );\t//head\n    dn = max(dn, linesegment( uv, collar.xy, elbowl.xy, 0.05 ) );\t\t//left upper arm\n    df =         linesegment( uv, collar.xy, elbowr.xy, 0.05 );\t\t\t//right upper arm\n    dn = max(dn, linesegment( uv, elbowl.xy, handl.xy,  0.0375 ) );\t\t//left forearm\n    df = max(df, linesegment( uv, elbowr.xy, handr.xy,  0.0375 ) );\t\t//right forearm\n    dn = max(dn, linesegment( uv, root.xy,   kneel.xy,  0.0625 ) );\t\t//left thigh\n    df = max(df, linesegment( uv, root.xy,   kneer.xy,  0.0625 ) );\t\t//right thigh\n    dn = max(dn, linesegment( uv, kneel.xy,  anklel.xy, 0.05 ) );\t\t//left shin\n    df = max(df, linesegment( uv, kneer.xy,  ankler.xy, 0.05 ) );\t\t//right shin\n    \n    dn += th;\n    df += th;\n    \n    return vec2(dn, max(dn,df));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//LAND, SKY, RUNNERS\n\n\nfloat distancetocoverage( float d ) {\n    return clamp(d*iResolution.y/2.0+0.5, 0.0, 1.0);\n}\n\n\nvec2 processhumandf( vec2 d, float z ) {\n\tfloat area = distancetocoverage(d.y/z);\n    float near = distancetocoverage(d.x/z);\n    float edge = clamp(1.0-d.y*75.0, 0.0, 1.0);\n    //float dist = clamp(sin(d.x*200.0+iTime*10.0), 0.0, 1.0);\n    \n\treturn vec2( max(min(max(near, near-d.x*10.0), 1.0),edge*3.0)*area, area );\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n//MAIN\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y*2.0 - vec2(iResolution.x/iResolution.y, 1.0);\n    \n\tvec2 d = runnerhq(uv, iTime, 1.0, 1.0, 0.0, 0.4, 0.25, 0.12, 0.005);\n    d = processhumandf( d, 1.0 );\n    \n    float z = d.y;\n    \n    for(float f=0.0; f<NUMBER_OF_RUNNERS; f++) {\n        float zdist = mix(2.0, MAX_RUNNER_DISTANCE, sqrt(f/NUMBER_OF_RUNNERS));\n        \n        //break if uv.y is too high or low to show character at zdist, or if nearer runner has filled pixel\n        if ( (uv.y<-0.85/zdist) || (uv.y>((HEAD_MAX+TORSO_MAX+LIMB_MAX+MAX_THICKNESS)*2.0-0.65)/zdist) || d.y==1.0 ) break;\n        \n        float speed = mix(0.5, 3.0, hash(f+10.0));\n        float xpos = hash(f+50.0)*100.0*zdist + (iTime+20.0)*(speed-1.0);\n        float limblength = mix( LIMB_MIN, LIMB_MAX, hash(f+100.0) );\n        float bodylength = mix( TORSO_MIN, TORSO_MAX, hash(f+200.0) );\n        \n        speed /= limblength*2.0/0.8;\n        xpos = mod(xpos, 4.0*zdist)-2.0*zdist;\n        \n        //only attempt to draw runner if pixel is within bounding box\n        if ( (abs(uv.x*zdist+xpos)<limblength*2.0+0.2) && (uv.y<((limblength+bodylength+HEAD_MAX+MAX_THICKNESS)*2.0-0.65)/zdist) ) {\n        \tfloat headsize   = mix( HEAD_MIN, HEAD_MAX, hash(f+300.0) );\n        \tfloat thickness  = hash(f+400.0)*MAX_THICKNESS;\n            \n        \tvec2 h = zdist<15.0 ? runnerhq(uv, iTime+f, speed, zdist, xpos, limblength, bodylength, headsize, thickness) :\n            \t\t\t\t\t  runnerlq(uv, iTime+f, speed, zdist, xpos, limblength, bodylength, headsize, thickness);\n            \n            h = processhumandf( h, zdist );\n            \n            //check bounding boxes\n            //d += 0.2;\n            \n            if(h.y>0.0) {\n                z = mix(z, 1.0/zdist, 1.0-d.y);\n                d.x = mix(d.x, h.x, h.y);\n                d.y = min(h.y+d.y, 1.0);\n                //d.y = h.y*(1.0-d.y)+d.y;\n        \t}\n        }    \n    }\n    \n    \n    //sky\n    vec3 col = max( pow(1.0-( vec3(1.2,0.9,0.4) * abs(abs(uv.y)-vec3(0.0,0.1,0.3)) ),vec3(5.0)), 0.0 );\n    \n    //ground plane\n    if( uv.y<0.0 && d.y<1.0 ) {\n        //black gradient toward horizon to approximate reflections of distant runners\n        col *= clamp(-uv.y*7.0-0.1, 0.0, 1.0);\n        \n        //floor pattern\n        //float stripes = clamp(sin(uv.x*5.0/uv.y+iTime*15.0)*50.0, 0.0, 1.0);\n        float stripes = clamp(sin(uv.x*5.0/uv.y+iTime*15.0) * sin(5.0/uv.y) * 1000.0, 0.0, 1.0);\n        \n        //add runner reflections from Buffer A\n        vec4 rcol = texture(iChannel0, fragCoord/iResolution.xy);\n        vec4 smear = vec4(0.0);\n    \tfloat acc;\n    \tfor( float f=-REFLECTION_SAMPLES; f<REFLECTION_SAMPLES; f++ ) {\n        \tfloat offset = f+hash(uv.x*uv.y+iTime)-0.5;\n        \tfloat weight = gaussian(offset, 1.0/REFLECTION_SAMPLES);\n        \tacc += weight;\n        \tvec2 sp = vec2( fragCoord.x/iResolution.x, fragCoord.y/iResolution.y+offset*REFLECTION_SMEAR*(1.0+uv.y) );\n        \tsmear += texture(iChannel0, sp).rgba * weight;\n    \t}\n    \tsmear /= acc;\n        rcol = mix( rcol, smear, stripes );\n        col = mix( col, rcol.rgb, rcol.a );\n        \n        col = mix( vec3(0.03,0.03,0.05)*stripes, col*REFLECTION_STRENGTH, 1.0-sqrt(-uv.y) );\n    }\n    \n    //draw runners\n    vec3 hcol = vec3(6.0,0.75,0.15);\n    hcol *= d.x*0.5+0.5;\n    hcol = mix(vec3(0.0), hcol, z*z);\n    //hcol = max(hcol*(uv.y/z+1.0), 0.0);\n    col = mix( col, hcol, d.y);\n    \n    //vignette\n    col *= 1.0 - pow(length(uv)*0.4, 1.5);\n    \n    col = max(col, 0.0);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    #ifdef ENABLE_BLOOM\n    //bloom - horizontal pass\n    float acc;\n    for( float f=-BLOOM_SAMPLES; f<BLOOM_SAMPLES; f++ ) {\n        float offset = f+hash(uv.x+uv.y+iTime)-0.5;\n        float weight = gaussian(offset, 1.0/BLOOM_SAMPLES);\n        acc += weight;\n        vec2 sp = vec2( uv.x+offset*BLOOM_SCALE*iResolution.y/iResolution.x, uv.y );\n        col += texture(iChannel0, sp).rgb * weight;\n    }\n    col /= acc;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}