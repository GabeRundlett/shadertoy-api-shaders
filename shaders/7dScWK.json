{
    "Shader": {
        "info": {
            "date": "1644082040",
            "description": "Top: Projected grid points relative to the orange line.\nMain: Map of integers, field of view. Mouse moves projection target.\nArrow: Horizon.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7dScWK",
            "likes": 5,
            "name": "Projection of Integers onto Line",
            "published": 3,
            "tags": [
                "visualization",
                "projection"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "vec3 fin(vec2 x) {\n    return vec3(x, 1);\n}\n\nvec3 inf(vec2 x) {\n    return vec3(x, 0);\n}\n\nvec2 hom(vec3 x) {\n    return x.xy / x.z;\n}\n\nvoid mainImage(out vec4 C, in vec2 O0)\n{\n    f = 5. / iResolution.y;\n    vec2 O = world(O0);\n\n    vec2 cam = vec2(3, 3) + .1 * f;\n    vec2 a0 = cam + vec2(-10, 1) / 10.;\n    vec2 b0 = cam + vec2(1, -10) / 10.;\n    if (iMouse.z > 0.)\n        cam = world(iMouse.xy + .1);\n\n    /*\n    Invariants A.1 and A.2 imply that without further constraints,\n    you can't infer camera parameters from a single image.\n    \n    Yet, the map between points on the line and projected points\n    is exactly 1:1. This can be seen as follows:\n    - Given distinct points A, B, T and \"the line\".\n        - and T not in \"the line\".\n        - and T not in line AB.\n    - For all points X in \"the line\" (including point at infinity):\n        - The line XT joins X and the projection target T.\n        - This line XT meets the screen line AB at exactly one point (possibly at infinity).\n    - For all points X in the line AB (including point at infity):\n        - The line XT joins X and the projection target T.\n        - This line XT meets \"the line\" at exactly one point (possibly at infinity).\n    -> The image can be inferred from the world and vice versa.\n    \n    Things to try:\n        - \"cf = 1\": Intersection between AB and \"the line\" stays fixed.\n        - \"sf, cf = 0, 1\": Above + Space stretches/squishes along y-axis.\n    */\n\n    // Invariant A.1: Y-scale perpendicular to line does not move projected points\n    float hf = .8 + .2 * cos(iTime / 3.);\n    cam.y *= hf;\n    a0.y*=hf;\n    b0.y *= hf;\n    \n    // Invariant A.2: Y-Shear perpendicular to line does not move projected points\n    float sf = .5 * cos(iTime / 2.);\n    //sf = 0.;\n    cam.x += cam.y * sf;\n    a0.x += a0.y * sf;\n    b0.x += b0.y * sf;\n    \n    // Invariant B: Uniform scale around projection target does not move projected points\n    // This just moves the line AB without changing its direction.\n    float cf = 1. + cos(iTime);\n    //cf = 1.;\n    vec2 a = a0 + (a0 - cam) * cf;\n    vec2 b = b0 + (b0 - cam) * cf;\n\n    C = vec4(0);\n    blend(C, vec3(0,0.2,1), abs(O.y) / f);\n    blend(C, vec3(.2,.2,.2), length(O-cam) / f - 2.);\n    blend(C, vec3(.2,.2,.2), line(O, cam, a, 0., 1e2) / f);\n    blend(C, vec3(.2,.2,.2), line(O, cam, b, 0., 1e2) / f);\n    blend(C, vec3(.2,.2,.2), length(O-a0) / f - 2.);\n    blend(C, vec3(.2,.2,.2), length(O-b0) / f - 2.);\n    vec3 ab = cross(fin(a), fin(b));\n    {\n        for (float i=-20. ; i<=20. ; i++)\n        {\n            vec2 s = vec2(1, 0) * i;\n            vec2 t = hom(cross(cross(fin(s), fin(cam)), ab));\n            blend(C, vec3(0,0.2,1), line(O, t, s) / f);\n        }\n        vec2 v = vec2(-1, 0);\n        vec2 t = hom(cross(cross(inf(v), fin(cam)), ab));\n        blend(C, vec3(0,0.2,1), arrow(O, t, t+v) / f);\n\n        blend(C, vec3(1,0.2,0), line(O, a, b) / f);\n        blend(C, vec3(.5,0,0), line(O, a, b, -1e2, 0.) / f);\n        blend(C, vec3(.5,0,0), line(O, a, b, 1., 1e2) / f);\n    }\n    \n    f = 1. / iResolution.x;\n    O = wcam(O0);\n    {\n        blend(C, vec3(0), -(O.y / f + iResolution.x * .06));\n        vec2 ca = floor(vec2(0.1, -0.01) / f) * f;\n        vec2 cb = floor(vec2(0.9, -0.01) / f) * f;\n        blend(C, vec3(1,0.2,0), line(O, ca, cb) / f);\n        blend(C, vec3(.5,0,0), line(O, ca, cb, -1e2, 0.) / f);\n        blend(C, vec3(.5,0,0), line(O, ca, cb, 1., 1e2) / f);\n        blend(C, vec3(.2,.2,.2), line(O, ca, ca-vec2(0,.02)) / f);\n        blend(C, vec3(.2,.2,.2), line(O, cb, cb-vec2(0,.02)) / f);\n        for (float i=-20. ; i<=20. ; i++)\n        {\n            vec2 s = vec2(1, 0) * i;\n            vec2 t = hom(cross(cross(fin(s), fin(cam)), ab));\n            t = ca + (cb - ca) * dot(t - a, b - a) / dot(b - a, b - a);\n            blend(C, vec3(0,0.2,1), line(O, t, t-vec2(0,.02)) / f);\n        }\n        vec2 v = vec2(-1, 0);\n        vec2 t = hom(cross(cross(inf(v), fin(cam)), ab));\n        t = ca + (cb - ca) * dot(t - a, b - a) / dot(b - a, b - a);\n        blend(C, vec3(0,0.2,1), arrow(O, t, t+vec2(0,-.04)) / f);\n    }\n    \n    C = sqrt(C);\n}\n\nvec2 world(vec2 O)\n{\n    O -= floor(iResolution.xy / 2.) + .5;\n    O *= f;\n    O += vec2(0, 2);\n    return O;\n}\n\nvec2 wcam(vec2 O)\n{\n    O -= floor(vec2(0, 1) * iResolution.xy) + .5;\n    O *= f;\n    O += vec2(0);\n    return O;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 world(vec2 O);\nvec2 wcam(vec2 O);\n\nfloat line(vec2 p, vec2 a, vec2 b, float c0, float c1)\n{\n    p -= a;\n    b -= a;\n    float u = clamp(dot(p, b) / dot(b,b), c0, c1);\n    return length(p - b*u);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    return line(p, a, b, 0., 1.);\n}\n\nfloat arrow(vec2 p, vec2 a, vec2 b)\n{\n    a -= b;\n    p -= b;\n    vec2 u = .2 * a;\n    vec2 v = .4 * vec2(-u.y, u.x);\n    return min(\n        line(p, a, vec2(0), 0., 1.),\n        min(\n            line(p, vec2(0), u+v, 0., 1.),\n            line(p, vec2(0), u-v, 0., 1.)\n        )\n    );\n}\n\nfloat f;\n\nvoid blend(inout vec4 C, vec3 v, float r)\n{\n    float a = smoothstep(1.0, 0.0, r);\n    C = mix(C, vec4(v, 1), a);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}