{
    "Shader": {
        "info": {
            "date": "1501628698",
            "description": "for slanted glyphs, without atan, a look up table stores some\nhttps://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nthis actually gets rod of the division by 0 of dot()/dot()",
            "flags": 0,
            "hasliked": 0,
            "id": "ldBBRt",
            "likes": 0,
            "name": "24 rotations real radicals",
            "published": 3,
            "tags": [
                "rotation"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 494
        },
        "renderpass": [
            {
                "code": "/*\narrow-shaped distance field:\niMouse.xyzw is used to set 4 parameters of this \"superprim\", which is not too user friendly:\n- where you click sets roundness of the handle and the size of the tip.\n- dragging the mouse sets size   of the handle.\n\nThe tip is calculaed without cos() or atan() or normalize(), by using a single dot() and\nhttps://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nwith 2 sqrt(const) that are also useful for other things and worth buffering at some point.\n\nit is not too user friendly in its parameter parsing, because it is made for performance.\nthe handle distance field is not too defined for its interior.\nthe handles distance field has 3 better solutions here\nhttps://www.shadertoy.com/view/ldjBRV\nbut for performance, the one used here is good enough for most cases;\n... as long as (sqrt(2)*roundness>=epsilonForNormalGradientCalculation) this should be good enough,\n... and that min() is easily set.\n\n*/\n\n/*\nthe principle:\nIn a quest to increase symmetry for performance and modular shaders.\n- instead of writing a general function, \n- ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- ... only write atomic special cases and transformations, to construct general functions from.\n...\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- substituting max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - see - https://www.shadertoy.com/view/ldBfzc\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- Modify simple bisymmetry of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about Binimials.\n- and 2 symmetric functions tend to cancel factors out, down to abs(a)*abs(a)=1.\n- Your function turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*log2(-1.)*pow(0,0)*a/0.\n\n------------\n\n[envelope]s and [window function]s and [Passband]s are pretty much mean the same to me now.\ni just lack a noun for min||max([window function],[envelope]) that is not [MoDem] or [context]\nhttps://en.wikipedia.org/wiki/Context_(computing)\nhttps://en.wikipedia.org/wiki/Modulation\nFor a lack of a better term, the terms I use are knowinggly fuzzy.\n\nthey come down to y=f(x) that often are only, or especially \n...focused on (inout) ranges [-.5..+.5] to [-3.14..+3.14]\n...while their parameters (like uv or scaling) are any range.\n\n[window function]s \n- tend to have smoother derivatives, nicer Local Lipschitz Constants. they include \n- https://en.wikipedia.org/wiki/Window_function\n[envelope]s tend to be more symmetric and opften less less continuous. they include \n- https://en.wikipedia.org/wiki/Envelope_(waves)\n- where continuity is easily broken due to Fourier Transform (of a square,triangle,seesaw wave)\n-\n- means envelopeD(log(envelopeE())), for lack of a better term.\n- ... where envelopeA()=envelopeB(envelopeC())\n- does not mean \n- https://en.wikipedia.org/wiki/Envelope_(mathematics)\n*/\n\n/*\nnotes to self, for improvement:\nuse #define to take a domain (x,y, z or w) as function parameter \nyour #define basically defines patterns over single domains, \nand their context lies on how these \n#defines are utilized min() mic() smin() swiveled or otherwise transformed.\n\n\nthe comments of\nhttps://www.shadertoy.com/view/MdSfzt\nare all about \n- line breaks in a define\n- using a buffer texxture and a single define to display a string.\nthis is a current process...\n*/\n\n//sharpness of FullScreenAntiAliasing\n#define fsaa 5./iResolution.y\n//maximum view zoom\n#define viewZoom 3.\n\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//squareroots for https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nconst vec4 s2=sqrt(vec4(2,3,5,6));//s6=sqrt(vec4(7,10,11,12));//arrays and matrices are too bulky here.\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//use a matrix as if it is a list.\nfloat gm3(mat3 a,int n){return a[n/3][n%3];}\n//return a[int(n/3.)][int(mod(n,3.))];}//float variant\n#define gp(a) gm3(co,a)\n\n\n//m.y sets zoom (makes sense for waveforms)\n//length sets zoom\n//#define scaledot(u) length(m)*u\n//length*length sets zoom, for EXTREME zoom out\n//#define scaledot(u) dot(m,m)*u\n//near main axes, zoom in\n//#define scaledot(u) min(abs(m.x),abs(m.y)   )*u\n//mix of axial distances sets zoom\n//#define scaledot(u) mix(abs(m.x),abs(m.y),.5)*u\n#define scaledot(u) u=min(abs(m.x),abs(m.y))*u\n\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n\n//return distance to infinite line segment\n//float ils(vec2 u,vec4 m){if(0.<u.x)return u.y;return length(u);}\n//is not too useful for this shape, just a bit too dirty.\n\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u, vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n//lookup table for https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nvec2 getRealRadical(int a){int b=(a/4)*2;a%=4;\n const mat4 r=mat4(.5*vec4(2,0,1,s2.y),.25*vec4(s2.w+s2.x,s2.w-s2.x,s2.w-s2.x,s2.w+s2.x),\n .5*vec4(s2.y,1,0,2),.5*s2.x*vec4(1,1,0,0));return vec2(r[a][b],r[a][b+1]);}\n\nfloat sum(vec2 a){return a.x+a.y;}\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u){\n //const float s2=sqrt(2.), s6=sqrt(6.);\n //extreme unpoinry: return dot(u,vec2(s6+s2,s6-s2)*.25)\n //might as well just do a look up table matrix over one quater.\n return dot(u.yx,vec2(sum(s2.xw),s2.w-s2.x)*.25);}\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n\nfloat arrow(vec2 u,vec4 m){\n u.y*=sign(u.y);\n //if(u.y>m.x) return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n m.z*=.25;\n m.zw=abs(m.zw);\n //vec2 d=vec2(1,-sqrt(2.))*.5; //12th rotation\n float a=r12(u)-m.z;            //24th rotation\n a=max(a,-u.x);\n u.x=-mStretchM(u.x,m.x);u.y=-mStretchM(u.y,m.y);\n return min(a,length(u)-m.w);}\n\n\n//glyph \"2\"\nfloat g2(vec2 u,vec4 m){\n int t=int(iTime*3.);  \n if(t%24>11){u=-u;}//180deg rotation\n if(t%12>5 ){u=vec2(u.y,-u.x);}//90deg rotation\n t=t%6;//resolve quadrant\n float a=abs(length(u)-1.)-.01;\n vec2 b=getRealRadical(t);\n float c=length(u-b)-.1;\n float d=dot(u,b);\n a=min(a,min(c,d));\n return a;}\n\n//some mouse cursor code, shading the same color space, inverting\nfloat mouseNeg(float c,float m){return sign(c)*min(m,abs(c));}\n//mix c and m where m is a disturbing distance field [m]  as \"mouse pointer\" in field [c]\nfloat mouseDif(float c,float m){//return sign(c)*max(-sign(c)*c,m);//alternative to below\n //return min(c*sign(m),m);//shorter variant of below\n float s=sign(m)*c;m-=s;return s+.5*(m-abs(m));}\n\nvoid mainImage(out vec4 fragColor, in vec2 u){//calculate color for fragment\n u-=iResolution.xy*.5;\n vec4 m=vec4(fr(iMouse.xy),fr(iMouse.zw));u=(u);//put vec2(0) in the center of the view, adjust for aspect ratio.\n m.w=abs(m.w*.5);//scaling mouse input for this one\n/*\n if(iMouse.z<0.)\n m=vec4(sin(iTime*acos(0.))*2.+2.//length.x of handle\n       ,cos(iTime)            +1.//length.y of handle\n       ,sin(iTime)            +4.//size of the tip\n       ,cos(iTime*.61)*.2     +.2//roundness of handle\n       )*3.;\n*/\n//   else m=fr(iMouse.xy);\n //scaledot(u);scaledot(m);//scale view, depending on m\n //u+=m;m+=m;//move view center away from vec2(0)\n vec3 c;//color composition\n c.r=g2(u,m);//distance field at u, set by parameters m\n\n //c.r=circleStretch(u,m);//distance field at u, set by parameters m\n //c.r=analstretching(u.xy,m.xy).x-u.y;\n \n float d=sin(iTime)*.5+.5;\n //if (sign(c.r)>sign(cur))c.r=-c.r;\n float mo=length(u-m.zw);//distance to mouse cursor\n //float e=length(u-m.zw)-1.;//distance to where mouse was pushed down\n //c.r=min(c.r,e);    \n      \n //c.r=mouseDif(c.r,mo);\n //c.r=mouseNeg(c.r,mo);\n //c.r=mouseDif(mouseNeg(c.r,mo),mo);\n c.r=mouseNeg(mouseDif(c.r,mo),mo);\n //c.r=mix(mouseDif(c.r,mo),mouseNeg(c.r,mo),.5);\n c.bg=u;//making x-axis green comes naturally\n c=sawCos3(c,.9);//smoothest gradient visualization so far\n c.gb+=vec2(sawCos(length(u),.5)*.003);//show circles around (0,0)\n \n //the color mix below usually looks nice, \n //but hues cyclically bleed into another, causing some optical illusions if one domain is very low\n //it also means if any domain is NaN, it becomes 0.\n if(isnan(c.r))c.r=0.;//projecting NaN to 0.\n if(isnan(c.b))c.b=0.;//projecting NaN to 0.\n if(isnan(c.g))c.g=0.;//projecting NaN to 0.\n c=sqrt(c);//more evenly gamma correcting\n c=max(vec3(0),c);\n fragColor=vec4(c*.5+c.yzx*.25,0);} //#define mainImage(o,u)o=vec4(co(u),1.);\n\n//vector dotproduct with vecN(1) is a faster sum.\n//float sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\n//float sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n\n/*\n//just some demo y=f(x) functions\nfloat fx(vec2 u,vec2 m){\n float x=u.x;\n float logE = log(x);\n float expE = exp(x);\n float pow3 = (x*1.)*(x*x);\n float pow4 = (x*x )*(x*x);\n mat3 co=mat3(-10,8,-6,5,-6,4,-7,-2,1);//9 coeficients to a polynomial should be enough\n //co=1.co; //reciprocal coeficcients\n //co*=.1;//smaller coefficients\n //float polyn=x*gm3(co,0)-u.y;\n   \n float polyn=x*(gp(0)+x*(x*(gp(1)+x*(x*(gp(2)+x*(x*(gp(3)+x*gp(4)+x*(gp(5)))))))));\n float cosine=cos(x*.1)*10.;//a large amplitude large interval cosine.\n x*=.1;\n float fourier=cos(x*gp(0))\n              +cos(x*gp(1)*2.)\n              +cos(x*gp(2)*3.)\n              +cos(x*gp(3)*5.)\n              +cos(x*gp(4)*7.)\n              +cos(x*gp(5)*13.);//cosines, scaled by primes.\n    \n //return fourier;\n \n //return cosine;\n //return logE; //makes negative blue green, i see no way to cath this NaN\n return fourier+cosine+x*x;\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}