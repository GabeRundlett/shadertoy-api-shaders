{
    "Shader": {
        "info": {
            "date": "1725463249",
            "description": "12 leaves collapsing into a single rhombic hexecontahedron.\nThanks to Scratch-Minion for the wonderful idea.\nhttps://en.wikipedia.org/wiki/Rhombic_hexecontahedron",
            "flags": 16,
            "hasliked": 0,
            "id": "lf2BRG",
            "likes": 7,
            "name": "Floating Leaves Surprise",
            "published": 3,
            "tags": [
                "3d",
                "polyhedron"
            ],
            "usePreview": 0,
            "username": "ruudhelderman",
            "viewed": 108
        },
        "renderpass": [
            {
                "code": "// \"Floating Leaves Surprise\"\n// https://www.shadertoy.com/view/lf2BRG\n// Ruud Helderman, September 2024 - MIT License\n// Based on the Scratch project \"Floating Leaves Surprise\" by Scratch-Minion\n// https://scratch.mit.edu/projects/1056205283/\n// Cartesian coordinates of rhombic hexecontahedron by David I. McCooey\n// http://dmccooey.com/polyhedra/RhombicHexecontahedron.html\n// http://dmccooey.com/polyhedra/RhombicHexecontahedron.txt\n\n#define AUTOROTATE (1.0 - texelFetch(iChannel3, ivec2(77, 2), 0).x)    /* press M to toggle between 1.0 and 0.0 */\n\nconst vec3 cam = vec3(0, 0, -8);             // coordinates of camera\nconst vec3 sun = vec3(-0.3, 0.3, -0.3);      // coordinates of light source\n\nmat2 rotate(in float a)\n{\n    vec2 s = sin(vec2(1.5707963268, 0) + a); // equivalent to but potentially faster than vec2(cos(a), sin(a))\n    return mat2(s, -s.y, s.x);\n}\n\nvec2 from_pixels(in vec2 p)\n{\n    vec2 r = iResolution.xy;\n    return (p - 0.5 * r) / min(r.x, r.y);    // screen coordinates, normalized and centered\n}\n\nvoid rhombus(inout vec4 fragColor, in vec3 ray, in mat2 rx, in mat2 ry, in float h, in vec3 a, in vec3 b, in vec3 c)\n{\n    vec3 k = 0.3 * a + 0.5;                  // a = center vertex of leaf; let it dictate leaf's color\n    \n    a.yz *= rx; b.yz *= rx; c.yz *= rx;      // rotate the 3 vertices a, b, c around the origin\n    a.xz *= ry; b.xz *= ry; c.xz *= ry;      // (note: the 4th vertex is implicitly b+c-a)\n    \n    // (For a funny variation, swap the following 2 lines...)\n    vec3 n = cross(b -= a, c -= a);          // normal vector of the rhombus\n    a *= h;                                  // leaf hovers away from the origin\n    \n    float d = dot(ray, n);                            // intersect rhombus with ray\n    n *= sign(d);                                     // reverse normal when watching face's backside\n    \n    if ((d = abs(d)) > 1e-9 &&                        // ray and rhombus are not parallel?\n        (d = dot(a -= cam, n) / d) < fragColor.a)     // intersection is the closest so far?\n    {\n        vec2 u = inverse(mat2(b.xy, c.xy)) * (ray * d - a).xy;   // map rhombus to unit square\n        if (floor(u) == vec2(0))                                 // intersection is within rhombus?\n        {\n            k *= 1.0 - dot(n, sun);                   // add shading\n            k *= 1.0 - 0.2 * dot(u - 1.0, u - 1.0);   // add gradient, darkening the 'veins'\n            fragColor = vec4(k, d);\n        }\n    }\n}\n\nvoid rhombus12(inout vec4 fragColor, in vec3 ray, in mat2 rx, in mat2 ry, in float h, in vec3 a, in vec3 b, in vec3 c)\n{\n    vec3 s = vec3(1);\n    for (int i = 0; i < 12; i++, a = a.yzx, b = b.yzx, c = c.yzx, s *= vec3(s.y, -1, -s.y))\n    {\n        rhombus(fragColor, ray, rx, ry, h, a * s, b * s, c * s);\n    }\n}\n\nvoid rhombus60(inout vec4 fragColor, in vec3 ray, in mat2 rx, in mat2 ry, in float h)\n{\n    const float c0 = 0.525731112119133606025669084848;\n    const float c1 = 0.850650808352039932181540497063;\n    const float c2 = c0 + c1;\n    const float c3 = c1 + c1;\n    \n    const vec3 v0 = vec3(c0, 0, c1);\n    const vec3 v1 = vec3(0, 0, c3);\n    const vec3 v2 = vec3(c0, -c1, c2);\n    const vec3 v3 = vec3(c2, -c0, c1);\n    const vec3 v4 = vec3(c2, c0, c1);\n    const vec3 v5 = v4.yzx;\n    \n\trhombus12(fragColor, ray, rx, ry, h, v0, v1, v2);\n\trhombus12(fragColor, ray, rx, ry, h, v0, v2, v3);\n\trhombus12(fragColor, ray, rx, ry, h, v0, v3, v4);\n\trhombus12(fragColor, ray, rx, ry, h, v0, v4, v5);\n\trhombus12(fragColor, ray, rx, ry, h, v0, v5, v1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = iTime * AUTOROTATE * vec2(0.4, 0.8) + from_pixels(iMouse.xy).yx * 5.0;\n    mat2 rx = rotate(angle.x);                                                    // rotation around X axis\n    mat2 ry = rotate(angle.y);                                                    // rotation around Y axis\n    float h = smoothstep(0.2, 0.3, abs(fract(0.05 * iTime) - 0.5)) * 3.0 + 1.0;   // hovering away from center\n    \n    vec2 uv = from_pixels(fragCoord);\n    vec3 ray = vec3(uv, 1);\n    \n    fragColor = vec4(mix(vec3(0), vec3(1.6, 1.4, 1), uv.y), 99);                  // background gradient\n\trhombus60(fragColor, ray, rx, ry, h);                                         // raytracing the 60 rhombuses\n    fragColor.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"postprocess existing shaders\" by FabriceNeyret2\n// https://www.shadertoy.com/view/NdyfRz\n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\nconst int _N = 3;\n\n#define mainImage mainImage0(out vec4 O, vec2 U);            \\\nvoid mainImage(out vec4 O, vec2 U) {                         \\\n    vec4 o; mainImage0(O,U);                                 \\\n    if (fwidth(length(O)) > .01) {                           \\\n      for (int k=0; k<_N*_N; k+=k==_N*_N/2-1?2:1, O+=o)      \\\n        mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); \\\n      O /= float(_N*_N);                                     \\\n    }                                                        \\\n}                                                            \\\nvoid mainImage0\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}