{
    "Shader": {
        "info": {
            "date": "1527197848",
            "description": "CIE 1931 xy chromaticity diagram\nI used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\nUse the defines to enable / disable various visualisations.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MstcD7",
            "likes": 30,
            "name": "CIE 1931 chromaticity diagram ",
            "published": 3,
            "tags": [
                "xy",
                "cie",
                "chromaticity"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 1541
        },
        "renderpass": [
            {
                "code": "// CIE 1931 xy chromaticity diagram\n// https://www.shadertoy.com/view/MstcD7\n// @P_Malin\n\n// I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\n// https://www.youtube.com/watch?v=EN1Uk6vJqRw\n// https://research.activision.com/t5/Publications/HDR-in-Call-of-Duty/ba-p/10744846\n// Use the defines to enable / disable various visualisations.\n\n#define DRAW_COLOR_FILL\t\t\t\t\t1\n\n#define DRAW_D65\t\t\t\t\t\t1\n\n#define DRAW_REC_709 \t\t\t\t\t1\n#define DRAW_REC_2020 \t\t\t\t\t0\n#define DRAW_DCI_P3\t\t\t\t\t\t0\n#define DRAW_ADOBE\t\t\t\t\t\t0\n#define DRAW_AP0                        0\n#define DRAW_AP1                        0\n\n#define DRAW_SPECTRAL_LOCUS\t\t\t\t0\n\n#define DRAW_PLANCKIAN_LOCUS \t\t\t0\n#define DRAW_PLANCKIAN_LOCUS_COLOR\t\t0\n\n#define DRAW_WAVELENGTH_LABELS\t\t\t1\n#define DRAW_PLANCKIAN_LOCUS_LABELS\t\t1\n#define DRAW_AXIS_LABELS\t\t\t\t1\n#define DRAW_WHITE_POINT_LABELS \t\t1\n#define DRAW_COLOR_PRIMARY_LABELS \t\t1\n\n\n// Set to 1 or 2:\n#define DRAW_SCRGB_EXAMPLE\t\t\t\t0\n#define ZOOM_OUT\t\t\t\t\t\t0\n\n#define DRAW_OBSERVER_GRAPH\t\t\t\t0\n\n\n#define ADD_AMBIENT                     0\n#define AMBIENT                         0.3\n#define AMBIENT_SCALE                   0.5\n\n#if !FONT_PRINTING\n#undef DRAW_WAVELENGTH_LABELS\n#define DRAW_WAVELENGTH_LABELS 0\n#undef DRAW_PLANCKIAN_LOCUS_LABELS\n#define DRAW_PLANCKIAN_LOCUS_LABELS 0\n#undef DRAW_AXIS_LABELS\n#define DRAW_AXIS_LABELS 0\n#undef DRAW_WHITE_POINT_LABELS\n#define DRAW_WHITE_POINT_LABELS 0\n#undef DRAW_COLOR_PRIMARY_LABELS\n#define DRAW_COLOR_PRIMARY_LABELS 0\n#endif\n\nfloat fPointSize = 0.007;\nfloat fPointOutlineThickness = 0.0025;\n\nfloat fLocusThickness = 0.003;\nfloat fGamutOutlineThickness = 0.002;\n\n#if FONT_PRINTING\n#define iChannelFont iChannel0\n#endif\n\n\n// Hack to speed up compilation on Shadertoy\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLF(X) (X + min(0.0f,float(iFrame)))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n\n// http://www.cie.co.at/technical-work/technical-resources\nconst vec3 standardObserver1931[] =\nvec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n    );\n\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nconst vec2 whiteD65 = vec2(.3127, 0.3290 );\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \n\nconst Chromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nconst Chromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nconst Chromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nconst Chromaticities Primaries_AdobeRGB =\nChromaticities(\n        vec2( 0.6400,  0.3300 ),\t// R\n        vec2( 0.2100,  0.7100 ),\t// G\n        vec2( 0.1500,  0.0600 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nconst Chromaticities Primaries_AP0 =\nChromaticities(\n        vec2( 0.7347, 0.2653 ),\t// R\n        vec2( 0.0, 1.0 ),\t// G\n        vec2( 0.0001, -0.0770 ),  \t// B\n        vec2( 0.32168,0.33767) );\t// W\n\nconst Chromaticities Primaries_AP1 =\nChromaticities(\n        vec2( 0.713, 0.293 ),\t// R\n        vec2( 0.165, 0.830 ),\t// G\n        vec2( 0.128, 0.044 ),  \t// B\n        vec2( 0.32168,0.33767 ) );\t// W\n\nconst vec3 sRGBLuminosityCoeffs = vec3(0.2126, 0.7152, 0.0722);\n\nfloat sRGBFromLinear( float linearValue )\n{\n\t// values from IEC 61966-2-1\n    float sRGBValue\t= ( linearValue <= 0.0031308f ) \n        \t\t\t\t? 12.92f * linearValue \n        \t\t\t\t: 1.055f * pow( linearValue, 1.0f/2.4f ) - 0.055f;\n    \n    return sRGBValue;\n}\n\nvec3 sRGBFromLinear( vec3 linearValues )\n{\n\tvec3 sRGBValues;\n    \n    sRGBValues.x = sRGBFromLinear( linearValues.x );\n    sRGBValues.y = sRGBFromLinear( linearValues.y );\n    sRGBValues.z = sRGBFromLinear( linearValues.z );\n\n    return sRGBValues;\n}\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)\n{\n\tconst mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,\n\t\t\t\t\t\t\t                 3.0, -6.0,  0.0, 4.0,\n\t\t\t\t\t\t\t                -3.0,  3.0,  3.0, 1.0,\n\t\t\t\t\t\t\t                 1.0,  0.0,  0.0, 0.0) / 6.0;\t\n\t\n\tfloat t2 = t * t;\n\tvec4 T = vec4(t2 * t, t2, t, 1.0);\n\t\t\n\tvec4 vWeights = T * mSplineBasis;\n\t\n\tvec3 vResult;\n\n\tvec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);\n\tvec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);\n\tvec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);\n\t\n\tvResult.x = dot(vWeights, vCoeffsX);\n\tvResult.y = dot(vWeights, vCoeffsY);\n\tvResult.z = dot(vWeights, vCoeffsZ);\n\t\n\treturn vResult;\n}\n\nvec3 WavelengthToXYZSpline( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n\n    int iIndex1 = int(fFloorIndex);\n    int iIndex0 = iIndex1 - 1;\n    int iIndex2 = iIndex1 + 1;\n    int iIndex3 = iIndex1 + 2;\n\n    iIndex0 = clamp( iIndex0, 0, standardObserver1931_length - 1 );\n    iIndex1 = clamp( iIndex1, 0, standardObserver1931_length - 1 );\n    iIndex2 = clamp( iIndex2, 0, standardObserver1931_length - 1 );\n    iIndex3 = clamp( iIndex3, 0, standardObserver1931_length - 1 );\n    \n    vec3 vA = standardObserver1931[iIndex0];\n    vec3 vB = standardObserver1931[iIndex1];\n    vec3 vC = standardObserver1931[iIndex2];\n    vec3 vD = standardObserver1931[iIndex3];\n\n\treturn BSpline( vA, vB, vC, vD, fBlend );    \n}\n\n\nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,Y);\n}\n\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R_xyz = CIE_xy_to_xyz( chroma.R );\n    vec3 G_xyz = CIE_xy_to_xyz( chroma.G );\n    vec3 B_xyz = CIE_xy_to_xyz( chroma.B );\n    vec3 W_xyz = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R_xyz, G_xyz, B_xyz );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W_xyz / W_xyz.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( \n        R_xyz * vScale.r, \n        G_xyz * vScale.g, \n        B_xyz * vScale.b ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\t\n        \n\nmat3 Convert( Chromaticities a, Chromaticities b )\n{\n    return RGBtoXYZ( a ) * XYZtoRGB( b );\n}\n\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}\n        \nvec3 BlackBodyXYZ( float t )\n{\n    vec3 vTotal = vec3(0);\n \n    for (int i=0; i<NO_UNROLL(standardObserver1931_length); i++)\n    {\n        float fWavelength = standardObserver1931_w_min + float(i) * (standardObserver1931_w_max - standardObserver1931_w_min) / (float(standardObserver1931_length) - 1.0);\n        float fAmount = BlackBody( t, fWavelength );\n        vTotal += standardObserver1931[i] * fAmount;\n    }\n    \n    return vTotal;\n}\n\n\n\nstruct DrawContext\n{\n    vec2 vUV;\n    vec3 vResult;\n    float fEdgeFade;\n};\n\nDrawContext DrawContext_Init( vec2 vUV, vec3 vClearColor )\n{\n    vec2 vA = fwidth( vUV );\n    float fEdgeFade = 1.0 / max(abs(vA.x), abs(vA.y));\n    return DrawContext( vUV, vClearColor, fEdgeFade );\n}\n\nbool DrawContext_OnCanvas( DrawContext drawContext )\n{\n    vec2 vUV = drawContext.vUV;\n    if ( (vUV.x >= 0.0f) && (vUV.y >= 0.0f) && (vUV.x < 1.0f) && (vUV.y < 1.0f) ) \n    {    \n    \treturn true;\n    }\n    return false;\n}\n    \nfloat LineSmooth( DrawContext drawContext, float fDist, float fThickness )\n{\n    return clamp( (fThickness - fDist) * drawContext.fEdgeFade, 0.0, 1.0 );\n}\n\nfloat LineInfo( vec2 vUV, vec2 vA, vec2 vB, out vec2 vClosest )\n{\n    vec2 vDir = vB - vA;\n\n    float fLen = length(vDir);\n\n    float fDist = 10000.0;\n    float fSide = -1.0;\n    \n    float fEpsilon = 0.002f;\n    \n    if ( fLen < fEpsilon )\n    {\n        vClosest = vA;\n    }\n    else\n    {\n        vDir /= fLen;            \n        vec2 vOffset = vUV - vA.xy;            \n\n        float cp = vDir.x * vOffset.y - vDir.y * vOffset.x;\n        if ( cp > 0.0f )\n        {\n            fSide = 1.0;\n        }\n\n        float d = dot( vDir, vOffset );\n        d = clamp( d, 0.0, fLen );\n        vClosest = vA + vDir * d;\n    }  \n    fDist = length( vClosest - vUV );\n    \n    return fDist * fSide;\n}\n\n\nfloat LineInfo( vec2 vUV, vec2 vA, vec2 vB )\n{\n    vec2 vClosestUnused;\n    return LineInfo( vUV, vA, vB, vClosestUnused );\n}\n\nvoid DrawBlend( inout DrawContext drawContext, vec3 vColor, float fBlend )\n{\n    drawContext.vResult = mix( drawContext.vResult, vColor, clamp( fBlend, 0.0, 1.0 ) );\n}\n\nvoid DrawOutlinePoint( inout DrawContext drawContext, vec3 vOutlineColor, vec3 vColor, vec2 vPos, float fStrokeThickness, float fOutlineThickness )\n{\n    float fDist = length( drawContext.vUV - vPos );\n    \n    DrawBlend( drawContext, vOutlineColor, LineSmooth( drawContext, fDist, fStrokeThickness + fOutlineThickness) );\n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, fDist, fStrokeThickness ) );  \n}\n\nvoid DrawRect( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB )\n{\n    vec2 vUV = drawContext.vUV;\n    \n    if ( (vUV.x >= vA.x) && (vUV.y >= vA.y) && (vUV.x < vB.x) && (vUV.y < vB.y) ) \n    {    \n    \tdrawContext.vResult = vColor;\n    }\n}\n\nvoid DrawLine( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB, float fThickness )\n{\n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, abs(LineInfo( drawContext.vUV, vA, vB )), fThickness ) );\n}\n\nstruct PolyInfo\n{\n\tfloat fDist;\n\tfloat fEdgeDist;\n};\n\nPolyInfo Poly_Init()\n{\n    return PolyInfo( -10000.0f, 10000.0f );\n}\n\nvoid Poly_Edge( inout PolyInfo polyInfo, float fEdgeInfo )\n{\n    polyInfo.fDist = max( polyInfo.fDist, fEdgeInfo );\n    polyInfo.fEdgeDist = min( polyInfo.fEdgeDist, abs( fEdgeInfo ) );\n}\n\nfloat PlaneProjectScale( vec3 v )\n{\n    // project onto the plane through (1,0,0), (0, 1, 0), (0, 0, 1)    \n    return 1.0 / dot( v, vec3(1.0) );\n}\n\nvec3 LinearRGBfromChromaticity( vec2 xy, Chromaticities chromaticities )\n{    \n    vec3 XYZ = CIE_xyY_to_XYZ( vec3(xy, 1.0) );\n    \n    vec3 vDisplayLinear = XYZ * XYZtoRGB( chromaticities );\n    \n#if ADD_AMBIENT\n    vDisplayLinear = normalize(vDisplayLinear) * AMBIENT_SCALE + AMBIENT;\n    return vDisplayLinear;\n#endif\n    \n    float fScale = 1.0;\n\tfloat fBoostWhite = 0.0;\n    float fBoostWhiteShape = 2.0;\n    \n#define INTENSITY_METHOD 3\n    \n#if (INTENSITY_METHOD == 1)\n    \n    // project onto the plane through (1,0,0), (0, 1, 0), (0, 0, 1)\n    fScale *= PlaneProjectScale(vDisplayLinear);\n    fBoostWhite = 1.5;\n    fBoostWhiteShape = 2.0;\n            \n#elif (INTENSITY_METHOD == 2)\n    \n    // scale so biggest component = 1.0    \n    fScale = 1.0 / max( vDisplayLinear.x, max( vDisplayLinear.y, vDisplayLinear.z ));\n    \n#elif (INTENSITY_METHOD == 3)\n\n    // normalize length\n    fScale = 1.0f / length( vDisplayLinear );\n\tfBoostWhite = 0.5;\n    fBoostWhiteShape = 2.0;\n\n#elif (INTENSITY_METHOD == 4)\n    \n    float sRGBLum = dot( vDisplayLinear, sRGBLuminosityCoeffs );\n    fScale = 0.8 / sRGBLum;    \n    \n#endif    \n\n    // boost intensity near white\n    //vec3 vSRGBDesaturated = vec3(dot(sRGBLuminosityCoeffs, sRGBLinear));\n    float fDesaturated = dot( vDisplayLinear, vec3( 1.0 / 3.0 ));\n    float l = length( vDisplayLinear - fDesaturated );\n    fScale *= 1.0 + exp(-l * fBoostWhiteShape) * fBoostWhite;\n    \n    vDisplayLinear *= fScale; \n    \n    return vDisplayLinear;\n}\n\nvec3 GetSrgbDisplayColor_xy( vec2 xy )\n{\n\tvec3 sRGBLinear = LinearRGBfromChromaticity( xy, Primaries_Rec709 );\n    \n    sRGBLinear = clamp( sRGBLinear, vec3(0.0), vec3(1.0) );\n    vec3 sRGBGamma = sRGBFromLinear( sRGBLinear );\n\n    return sRGBGamma;\n}\n\nPolyInfo PrimariesPoly( DrawContext drawContext, Chromaticities c )\n{\n\tPolyInfo poly = Poly_Init();\n    Poly_Edge( poly, LineInfo( drawContext.vUV, c.R, c.B ) );\n    Poly_Edge( poly, LineInfo( drawContext.vUV, c.B, c.G ) );\n    Poly_Edge( poly, LineInfo( drawContext.vUV, c.G, c.R ) );\n    \n    return poly;\n}\n\nvoid DrawRGBPrimaryPoints( inout DrawContext drawContext, vec2 vR, vec2 vG, vec2 vB, float fPointSize, float fOutlineThickness )\n{\n    DrawOutlinePoint( drawContext, vec3(0,0,0), vec3(1,0,0), vR, fPointSize, fOutlineThickness );\n    DrawOutlinePoint( drawContext, vec3(0,0,0), vec3(0,1,0), vG, fPointSize, fOutlineThickness );\n    DrawOutlinePoint( drawContext, vec3(0,0,0), vec3(0,0,1), vB, fPointSize, fOutlineThickness );\n}\n\nvoid GetFrequencyTickInfo( out vec2 xy, out vec2 vPerp, float w )\n{\n    vec3 wXYZ = WavelengthToXYZSpline( w );    \n    vec3 wxyY = CIE_XYZ_to_xyY( wXYZ );\n\n    vec3 wXYZ_p1 = WavelengthToXYZSpline( w + 1.0 );    \n    vec3 wxyY_p1 = CIE_XYZ_to_xyY( wXYZ_p1 );\n    \n    vec2 vDir = normalize( wxyY_p1.xy - wxyY.xy );\n    vPerp = vec2( -vDir.y, vDir.x );    \n    xy = wxyY.xy;\n}\n        \nvoid DrawFrequencyTick( inout DrawContext drawContext, vec3 vColor, float fLength, float fThickness, float w )\n{\n    vec2 xy, vPerp;\n    GetFrequencyTickInfo( xy, vPerp, w );\n    DrawLine( drawContext, vColor, xy, xy + vPerp * fLength, fThickness );            \n}\n        \nvec2 CIE_1960_xy_to_uv( vec2 xy )\n{\n    // https://en.wikipedia.org/wiki/CIE_1960_color_space\n    \n    float x = xy[0];\n    float y = xy[1];\n    \n    float u =  4.0 * x / ( 12.0 * y - 2.0 * x + 3.0 );\n    float v =  6.0 * y / ( 12.0 * y - 2.0 * x + 3.0 );\n    \n    return vec2( u, v );\n}\n        \nvec2 CIE_1960_uv_to_xy( vec2 uv )\n{\n    // https://en.wikipedia.org/wiki/CIE_1960_color_space\n    \n    float u = uv[0];\n    float v = uv[1];\n    \n    float x =  3.0 * u / ( 2.0 * u - 8.0 * v + 4.0 );\n    float y =  2.0 * v / ( 2.0 * u - 8.0 * v + 4.0 );\n    \n    return vec2( x, y );\n}\n\nvoid GetBlackbodyTickInfo( out vec2 xy, out vec2 vPerp, float t )\n{\n\tvec3 XYZ_0 = BlackBodyXYZ( t );\n\tvec3 XYZ_1 = BlackBodyXYZ( t + 100.0 );\n\n    vec3 xyY_0 = CIE_XYZ_to_xyY( XYZ_0 );\n    vec3 xyY_1 = CIE_XYZ_to_xyY( XYZ_1 );\n    \n    // The tick lines indicate the \"correlated color temperature\" lines perceptually closest to the planckian locus\n    // This is done by finding the perpendicular in the CIE 1960 color space\n    \n    vec2 uv_0 = CIE_1960_xy_to_uv( xyY_0.xy );\n    vec2 uv_1 = CIE_1960_xy_to_uv( xyY_1.xy );\n\n    vec2 vDirUV = normalize( uv_1.xy - uv_0.xy );\n    vec2 vPerpUV = vec2( -vDirUV.y, vDirUV.x );\n    \n    vec2 xy0PlusPerp = CIE_1960_uv_to_xy( uv_0.xy + vPerpUV );\n    \n    xy = xyY_0.xy;\n    vPerp = normalize( xy0PlusPerp - xyY_0.xy );\n    \n}\n        \nvoid DrawBlackbodyTick( inout DrawContext drawContext, vec3 vColor, float fLength, float fThickness, float t )\n{         \n    vec2 xy, vPerp;\n    \n\tGetBlackbodyTickInfo( xy, vPerp, t );\n    \n    DrawLine( drawContext, vColor, xy - vPerp * fLength, xy + vPerp * fLength, fThickness );\n}\n\n\nvoid DrawGrid( inout DrawContext drawContext )\n{\n    float fDivisions = 10.0;\n    // Grid lines\n    for ( float f = 0.0f; f < 1.0f; f += 1.0 / fDivisions )\n    {\n\t    DrawLine( drawContext, vec3(0.8), vec2(f,0), vec2(f, 1), 0.002f );    \n    \tDrawLine( drawContext, vec3(0.8), vec2(0,f), vec2(1, f), 0.002f );    \n    }\n    \n    // Diagonal\n    DrawLine( drawContext, vec3(0.7), vec2(1,0), vec2(0, 1), 0.001f );    \n    \n    // Grid Axes\n    DrawLine( drawContext, vec3(0.5f), vec2(0,0), vec2(1.0, 0.0), 0.003f );\n    DrawLine( drawContext, vec3(0.5f), vec2(0,0), vec2(0.0, 1.0), 0.003f );            \n}\n\nvoid DrawPrimaries( inout DrawContext drawContext, Chromaticities primaries, vec3 color, bool drawPoints )\n{\n    PolyInfo rec709Poly = PrimariesPoly( drawContext, primaries );\n    DrawBlend( drawContext, color, LineSmooth( drawContext, rec709Poly.fEdgeDist, fGamutOutlineThickness ) );        \n    if ( drawPoints )\n    {\n    \tDrawRGBPrimaryPoints( drawContext, primaries.R, primaries.G, primaries.B, fPointSize, fPointOutlineThickness );\n    }\n}\n\nvoid DrawCIE1931( inout DrawContext drawContext )\n{        \n#if FONT_PRINTING\n    LayoutStyle style = LayoutStyle_Default();\n    style.vSize = vec2(0.03, 0.05);\n    RenderStyle renderStyle = RenderStyle_Default( vec3(0.0) );\n    \n    vec2 vPrintUV = vec2( drawContext.vUV.x, 1.0f - drawContext.vUV.y );\n    PrintState state = PrintState_InitCanvas( vPrintUV, fwidth(drawContext.vUV) );\n#endif \n    \n    bool drawPrimaryPoints = true;\n    vec3 drawPrimaryColor = vec3(0.0, 0.0, 0.0);\n#if DRAW_SCRGB_EXAMPLE\n    drawPrimaryColor = vec3(1.0, 1.0, 1.0);\n#endif    \n    \n    vec3 sRGBGamma = GetSrgbDisplayColor_xy( drawContext.vUV );\n\n    PolyInfo locusInfoOpen = Poly_Init();\n    \n    float fClosestPointOnLocusDist = 10000.0;\n    vec2 vClosestPointOnLocus = vec2(0);\n    \n    {\n        float fStep = 1.0f;\n        vec3 XYZ = WavelengthToXYZSpline(standardObserver1931_w_min);\n        vec2 vPrev_xy = CIE_XYZ_to_xyY( XYZ ).xy;\n        for (float fWavelength = standardObserver1931_w_min + fStep; fWavelength < NO_UNROLLF(standardObserver1931_w_max); fWavelength+= fStep )\n        {\n            XYZ = WavelengthToXYZSpline(fWavelength);        \n            vec2 xy = CIE_XYZ_to_xyY( XYZ ).xy;\n\n            vec2 vSegmentClosestPoint;\n            float fEdgeInfo = LineInfo( drawContext.vUV, vPrev_xy, xy, vSegmentClosestPoint );\n\n            Poly_Edge( locusInfoOpen, fEdgeInfo );\n            if ( abs ( fEdgeInfo ) < fClosestPointOnLocusDist )\n            {\n                vClosestPointOnLocus = vSegmentClosestPoint;\n                fClosestPointOnLocusDist = abs ( fEdgeInfo );\n            }     \n            vPrev_xy = xy;\n        }\n    }\n\n    PolyInfo locusInfoClosed = locusInfoOpen;\n    \n    {\n        vec3 XYZ0 = WavelengthToXYZSpline(standardObserver1931_w_max);\n        vec3 XYZ1 = WavelengthToXYZSpline(standardObserver1931_w_min);\n        \n\t    vec3 xyY0 = CIE_XYZ_to_xyY( XYZ0 );\n\t    vec3 xyY1 = CIE_XYZ_to_xyY( XYZ1 );\n        \n    \tfloat fClosingEdgeInfo = LineInfo( drawContext.vUV, xyY0.xy, xyY1.xy );\n    \tPoly_Edge( locusInfoClosed, fClosingEdgeInfo );            \n    }\n    \n    vec3 bgCol = vec3(0.9f);\n#if ADD_AMBIENT    \n    bgCol = vec3(sRGBFromLinear(AMBIENT));\n#endif\n    \n    \n    DrawRect( drawContext, bgCol, vec2(0), vec2(1.0) );    \n\n    DrawGrid( drawContext );\n        \n    #if DRAW_AXIS_LABELS\n\t    style.vSize = vec2(0.02, 0.03);    \t\n    \n    \tMoveTo( state, vec2( 0.0 - 0.01, 1.03 ) );\n\t    Print( state, style, iChannelFont, 0.0f, 1 );\n\n    \tMoveTo( state, vec2( 1.0 - 0.01, 1.03 ) );\n\t    Print( state, style, iChannelFont, 1.0f, 1 );\n    \n\n    \tMoveTo( state, vec2( 0.0 - 0.04, 1.0 + 0.005 ) );\n\t    Print( state, style, iChannelFont, 0.0f, 1 );\n\n    \tMoveTo( state, vec2( 0.0 - 0.04, 0.0 + 0.005 ) );\n\t    Print( state, style, iChannelFont, 1.0f, 1 );\n    \n    \n    \n    \tstyle.bItalic = true;\n    \tstyle.bBold = true;\n    \n    \tMoveTo( state, vec2( 0.5 - 0.01, 1.03 ) );\n\t    PrintCh( state, style, iChannelFont, _x );\n\n    \tMoveTo( state, vec2( -0.03, 0.5 + 0.005 ) );\n\t    PrintCh( state, style, iChannelFont, _y );\n    \n    \tstyle.bBold = false;\n    \tstyle.bItalic = false;\n        \n\t#endif    \n    \n    // Draw frequency tick marks\n    for ( float w = 400.0; w < 700.0f; w += 5.0 )\n    {\n        float fLen = 0.01;\n        if ( int( floor(w) ) % 20 == 0 )\n        {\n            fLen *= 2.0;\n        }\n    \tDrawFrequencyTick( drawContext, vec3(0.2), fLen, 0.002f, w );\n    }\n    \n    \n#if DRAW_WAVELENGTH_LABELS\n    style.vSize = vec2(0.03, 0.05);\n\n    float wavelengthLabel[] = float[]( 460.0, 480.0, 500.0, 520.0, 540.0, 560.0, 580.0, 600.0, 620.0 );\n    \n    for ( int labelIndex = 0; labelIndex < NO_UNROLL(wavelengthLabel.length()); labelIndex++ )\n    {\n        float w = wavelengthLabel[labelIndex];\n        \n        vec2 xy, vPerp;\n        GetFrequencyTickInfo( xy, vPerp, w );\n        \n        vec2 vPos = xy + vPerp * 0.06;\n        vPos += vec2(-0.03, -0.015);\n        \n    \tMoveTo( state, vec2(vPos.x, 1.0 - vPos.y) );\n\n        Print( state, style, iChannelFont, uint(w) );\n    }\n#endif\n   \n    \n    // Color\n#if DRAW_COLOR_FILL\n    vec3 vFillColor = sRGBGamma;\n    \n#if DRAW_SPECTRAL_LOCUS\n    float fFade = 0.6;\n    vFillColor = sRGBGamma * sRGBGamma;\n    //vFillColor = mix( vFillColor, vec3(0.8), fFade );\n    vFillColor = mix( drawContext.vResult * drawContext.vResult, vFillColor, 1.0 - fFade );\n    \n    vFillColor = sqrt( vFillColor );\n#endif \n    \n\tDrawBlend( drawContext, vFillColor, LineSmooth( drawContext, locusInfoClosed.fDist, 0.0 ) );            \n#endif    \n\n#if DRAW_SPECTRAL_LOCUS    \n    vec3 vSpectrumColor = GetSrgbDisplayColor_xy( vClosestPointOnLocus );\n    \n    //vec3 vFadeColor = sqrt(sRGBGamma * sRGBGamma * 0.05);\n\t//DrawBlend( drawContext, vFadeColor, LineSmooth( drawContext, locusInfoClosed.fDist, 0.0 ) * 0.9 );            \n    DrawBlend( drawContext, vSpectrumColor, min( LineSmooth( drawContext, locusInfoOpen.fEdgeDist, 0.04f ), LineSmooth( drawContext, locusInfoClosed.fDist, 0.0 ) ) );\n    \n    //DrawBlend( drawContext, vSpectrumColor, LineSmooth( drawContext, locusInfoOpen.fEdgeDist, 0.025f ) );\n#endif    \n\n    // Locus\n\tDrawBlend( drawContext, vec3(0.0), LineSmooth( drawContext, locusInfoOpen.fEdgeDist, fLocusThickness ) );    \n\n#if DRAW_PLANCKIAN_LOCUS\n    {\n             \n\t    PolyInfo planckianLocusInfo = Poly_Init();\n        \n        float fStartK = 900.0;\n        vec3 vPrev = CIE_XYZ_to_xyY( BlackBodyXYZ( fStartK ) );\n        int iSteps = 20;\n        for ( int i = 1; i<NO_UNROLL(iSteps); i++)\n        {\n            float t = exp2(float(i) * 0.2 + log2(fStartK));\n            if ( i == iSteps -1 )\n            {\n                t = 1e10;\n            }\n            vec3 vCurr = CIE_XYZ_to_xyY( BlackBodyXYZ( t ) );\n\n            float fEdgeInfo = LineInfo( drawContext.vUV, vPrev.xy, vCurr.xy );\n\n            Poly_Edge( planckianLocusInfo, fEdgeInfo );\n            \n            vPrev = vCurr;\n        }\n\t\t\n#if DRAW_PLANCKIAN_LOCUS_COLOR\n        DrawBlend( drawContext, vec3(0.0), LineSmooth( drawContext, planckianLocusInfo.fEdgeDist, fLocusThickness * 4.0 ) );    \n        DrawBlend( drawContext, sRGBGamma, LineSmooth( drawContext, planckianLocusInfo.fEdgeDist, fLocusThickness * 3.0) );    \n#else        \n        DrawBlend( drawContext, vec3(0.0), LineSmooth( drawContext, planckianLocusInfo.fEdgeDist, fLocusThickness ) );    \n        \n        {\n            float small = 0.01;\n            float med = 0.02;\n            float large = 0.04;\n            vec2 tickMarks[] = vec2[](\n                vec2(   1500.0, small ),\n                vec2(   2000.0, large ),\n                vec2(   2500.0, large ),\n                vec2(   3000.0, large ),\n                vec2(   3500.0, small ),\n                vec2(   4000.0, large ),\n                vec2(   4500.0, med ),\n                vec2(   5000.0, small ),\n                vec2(   5500.0, med ),\n                vec2(   6000.0, large ),\n                vec2(   7000.0, small ),\n                vec2(   8000.0, small ),\n                vec2(   9000.0, small ),\n                vec2(  10000.0, large )\n            );\n            for ( int tickMarkIndex = 0; tickMarkIndex < NO_UNROLL(tickMarks.length()); tickMarkIndex++ )\n            {\n                float fTempK = tickMarks[tickMarkIndex].x;\n                float fLen = tickMarks[tickMarkIndex].y;\n\t        \tDrawBlackbodyTick( drawContext, vec3(0), fLen, 0.002f, fTempK );\n            }\n        }\n        \n    \n    #if DRAW_PLANCKIAN_LOCUS_LABELS\n        vec2 blackbodyLabel[] = vec2[]( \n            vec2(1500.0, -0.5), \n            vec2(2000.0, -1.0), \n            vec2(2500.0,  1.0), \n            vec2(3000.0,  1.0), \n            vec2(4000.0,  1.0), \n            vec2(6000.0,  1.0), \n            vec2( 10000.0, 1.0 ) );\n\n\t    style.vSize = vec2(0.02, 0.03);\n\n        \n        for ( int labelIndex = 0; labelIndex < NO_UNROLL(blackbodyLabel.length()); labelIndex++ )\n        {\n            float t = blackbodyLabel[labelIndex].x;\n            float fDir = blackbodyLabel[labelIndex].y;\n            \n\t\t\tvec2 xy, vPerp;    \n\t\t\tGetBlackbodyTickInfo( xy, vPerp, t );\n            \n            \n            vec2 vPos = xy + vPerp * 0.06 * -fDir;\n            vPos -= vec2(0.02, 0.01);\n\n            MoveTo( state, vec2(vPos.x, 1.0 - vPos.y) );\n\n            Print( state, style, iChannelFont, uint(t) );\n        }\n        \n\t    style.vSize = vec2(0.04, 0.06);\n        {\n\t\t\tvec2 xy, vPerp;    \n\t\t\tGetBlackbodyTickInfo( xy, vPerp, 1e10 );\n            \n            \n            vec2 vPos = xy - vec2(0.02, 0.04);\n\n            MoveTo( state, vec2(vPos.x, 1.0 - vPos.y) );\n\n            PrintCh( state, style, iChannelFont, 153u ); // inf\n        }\n    #endif\n\n#endif     \n\n    }\n#endif    \n    \n#if DRAW_REC_709\n    DrawPrimaries( drawContext, Primaries_Rec709, drawPrimaryColor, drawPrimaryPoints );\n    \n#if DRAW_COLOR_PRIMARY_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2(0.29, 0.48 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _R, _e, _c, _PERIOD, _SP, _7, _0, _9 );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif     \n#endif    \n    \n#if DRAW_SCRGB_EXAMPLE == 2\n\tChromaticities scRGB = Primaries_Rec709;\n    vec3 r = CIE_xy_to_xyz(scRGB.R);\n    vec3 g = CIE_xy_to_xyz(scRGB.G);\n    vec3 b = CIE_xy_to_xyz(scRGB.B);\n    vec3 w = CIE_xy_to_xyz(scRGB.W);\n    float s = 3.35;\n    r = w + (r - w) * s;\n    g = w + (g - w) * s;\n    b = w + (b - w) * s;\n    scRGB.R = CIE_XYZ_to_xyY(r).xy;\n    scRGB.G = CIE_XYZ_to_xyY(g).xy;\n    scRGB.B = CIE_XYZ_to_xyY(b).xy;\n    \n    //scRGB.R = vec2(1.41, 0.33);\n    //scRGB.G = vec2(0.27, 1.24);\n    //scRGB.R = vec2(1.41, 0.33);\n    DrawPrimaries( drawContext, scRGB, vec3(0.0, 0.0, 0.0), false );\n#endif    \n\n#if DRAW_REC_2020    \n    DrawPrimaries( drawContext, Primaries_Rec2020, drawPrimaryColor, drawPrimaryPoints );\n    \n#if DRAW_COLOR_PRIMARY_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2(0.03, 0.7 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _R, _e, _c, _PERIOD, _SP, _2, _0, _2, _0 );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif     \n    \n#endif\n\n#if DRAW_DCI_P3    \n    DrawPrimaries( drawContext, Primaries_DCI_P3_D65, drawPrimaryColor, drawPrimaryPoints );\n    \n    \n#if DRAW_COLOR_PRIMARY_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2(0.28, 0.66 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _D, _C, _I, _SP, _P, _3 );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif     \n#endif    \n\n#if DRAW_ADOBE  \n    DrawPrimaries( drawContext, Primaries_AdobeRGB, drawPrimaryColor, drawPrimaryPoints );\n    \n    \n#if DRAW_COLOR_PRIMARY_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2(0.2, 0.72 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _A, _d, _o, _b, _e );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif     \n#endif    \n\n\n#if DRAW_AP0 \n    DrawPrimaries( drawContext, Primaries_AP0, drawPrimaryColor, drawPrimaryPoints );\n    \n    \n#if DRAW_COLOR_PRIMARY_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2(0.05, 0.95 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _A, _P, _0 );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif     \n#endif  \n    \n#if DRAW_AP1\n    DrawPrimaries( drawContext, Primaries_AP1, drawPrimaryColor, drawPrimaryPoints );\n    \n    \n#if DRAW_COLOR_PRIMARY_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2(0.2, 0.8 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _A, _P, _1 );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif     \n#endif      \n    \n#if DRAW_D65    \n    DrawOutlinePoint( drawContext, vec3(0), vec3(1,1,1), whiteD65.xy, fPointSize, fPointOutlineThickness );\n    \n#if DRAW_WHITE_POINT_LABELS\n    {\n        style.vSize = vec2(0.03, 0.05);\n\n        vec2 vPos = vec2( whiteD65.xy ) + vec2(0.02, -0.04);\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n        uint str[] = uint[] ( _D, _6, _5 );\n        \n        ARRAY_PRINT( state, style, iChannelFont, str );    \n    }\n#endif    \n    \n#endif    \n    \n#if FONT_PRINTING\n\tRenderFont( state, style, renderStyle, drawContext.vResult );\n#endif    \n    \n}\n\nvoid DrawCIE1931Observer( inout DrawContext drawContext, vec3 vColor, int iChannel, float fYScale )\n{\n    PolyInfo graphInfo = Poly_Init();\n\n    vec2 vPrev = vec2( 0.0, standardObserver1931[0][iChannel] * fYScale );\n    \n    int indexCount = standardObserver1931_length;\n    for ( int i = 1; i < NO_UNROLL(indexCount); i++ )\n    {\n        float f = float(i) / float(indexCount);\n\t    vec2 vCurr = vec2( f, standardObserver1931[i][iChannel] * fYScale );\n\n        float fEdgeInfo = LineInfo( drawContext.vUV, vPrev, vCurr );\n\t\tPoly_Edge( graphInfo, fEdgeInfo ); \n        \n        vPrev = vCurr;\n    }    \n    \n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, graphInfo.fEdgeDist, 0.008 ) );    \n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUV = vFragCoord/iResolution.xy;\n\n    float fScale = 1.1;\n#if ZOOM_OUT    \n    fScale = 2.0;\n    vUV.y -= 0.1;\n#endif\n    \n    // scale down around centre of square\n    vec2 vDiagramUV = (vUV - 0.5) * fScale + 0.5;\n    \n    // aspect ratio adjust\n    vDiagramUV.x *= iResolution.x / iResolution.y;\n        \n    \n    // centre image horizontally\n    vDiagramUV.x += (1.0 - (iResolution.x / iResolution.y)) / 2.0;\n    \n    vec3 vClearColor = vec3( 1.0 );\n#if ADD_AMBIENT\n    vClearColor = vec3( 0.4 );\n#endif\n    \n    DrawContext drawContext = DrawContext_Init( vDiagramUV, vClearColor );\n    \n    DrawCIE1931( drawContext );\n    \n#if DRAW_OBSERVER_GRAPH\n    \n    vec3 graphColors[3] = vec3[3]( \n        vec3( 1, 0.1, 1),\n        vec3( 1, 1, 1),\n        vec3( 0, 0, 1)\n        );\n    for ( int i=0; i<3; i++)\n    {\n        DrawContext observerContext = DrawContext_Init( vUV * 4.5 - vec2( 0, 0.5 + float(i) ), vClearColor );    \n        DrawCIE1931Observer( observerContext, graphColors[i], i, 0.5 );\n        if ( DrawContext_OnCanvas( observerContext ) )\n        {\n            drawContext.vResult = observerContext.vResult;\n        }\n    }\n#endif    \n\n    \n    // Output to screen\n    vFragColor = vec4(drawContext.vResult,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define FONT_PRINTING 1\n\n#if FONT_PRINTING\n\n///////////////////////////\n// Rect\n///////////////////////////\n\nstruct Rect\n{\n    vec2 vPos;\n    vec2 vSize;\n};      \n\nbool Inside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return all( greaterThanEqual( vPos, vMin ) ) && all( lessThan( vPos, vMax ) );\n}\n\nbool Outside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return any( lessThan( vPos, vMin ) ) || any( greaterThanEqual( vPos, vMax ) );\n}\n\nbool Inside( vec2 vPos, Rect rect )\n{\n    return Inside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n    \nbool Outside( vec2 vPos, Rect rect )\n{\n    return Outside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n\nvoid RectExpand( inout Rect region, vec2 vPadding )\n{\n    // Padding\n    region.vPos -= vPadding;\n    region.vSize += vPadding * 2.0;        \n}\n\nvoid RectShrink( inout Rect region, vec2 vPadding )\n{\n    RectExpand( region, -vPadding);\n}\n\n///////////////////////////\n// Font\n///////////////////////////\n\n// Font printing based on https://www.shadertoy.com/view/ldfcDr\n\n#define AUTO_FONT_SPACING\n//#define HANDLE_EOL\n#define HANDLE_PRINT_STYLES\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au\n\n\t,_LCUB = 0x7Bu\t\t// '{'\n    ,_VERBAR = 0x7Cu\t// '|'\n    ,_RCUB = 0x7Du\t\t// '}'\n    ,_TILDE = 0x7Eu\t\t// '~'\n    \n#ifdef HANDLE_EOL       \n    ,_EOL = 0x1000u \t// End of Line - Carriage Return & Line Feed    \n#endif    \n#ifdef HANDLE_PRINT_STYLES    \n    ,_BOLDON = 0x1001u\t// Special\n    ,_BOLDOFF = 0x1002u\t// Special\n    ,_ITALON = 0x1003u\t// Special\n    ,_ITALOFF = 0x1004u\t// Special    \n#endif    \n;\n\n\nvec4 SampleCharacterTex( sampler2D sFontSampler, uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( sFontSampler, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( sampler2D sFontSampler, uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n    // Skip texture sample when not in character boundary\n    // Ok unless we have big font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( sFontSampler, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n        \n    return vSample;\n}\n\n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos( sampler2D sFontSampler, uint iChar, vec2 vUV ) \n{\n    vec4 vSample = SampleCharacterTex(sFontSampler, iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( sampler2D sFontSampler, uint iChar )\n{\n    CharExtents result;\n\n    result.left = CharVerticalPos( sFontSampler, iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( sFontSampler, iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vPixelPos;\n    \n    vec2 vLayoutStart;\n    // print position\n    vec2 vCursorPos;\n    vec2 vPixelSize;\n\n#ifdef HANDLE_EOL\n    bool EOL;\n#endif\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vLayoutStart = vPos;\n    state.vCursorPos = vPos;\n#ifdef HANDLE_EOL\n    state.EOL = false;\n#endif\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;   \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vPixelPos = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n#ifdef HANDLE_PRINT_STYLES    \n    bool bItalic;\n    bool bBold;  \n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(24.0f, 32.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n#ifdef HANDLE_PRINT_STYLES    \n    style.bItalic = false;\n    style.bBold = false;       \n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;   \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;  \n    return style;\n}\n\nconst float g_fFontDescent = 0.15f;\nconst float g_fFontAscent = 0.65f;\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vCursorPos.x = state.vLayoutStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n\tstate.vCursorPos.y += style.vSize.y * g_fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n\tstate.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);\n}\n\n#ifdef HANDLE_EOL\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n#endif\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, sampler2D sFontSampler, const uint iChar )\n{\n#ifdef HANDLE_EOL\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n#endif\n#ifdef HANDLE_PRINT_STYLES            \n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n#endif\n    \n#ifdef HANDLE_EOL\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n#endif\n    \n    vec2 vUV = ((state.vPixelPos - state.vCursorPos) / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( sFontSampler, iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n#endif\n    \n    vec3 v = SampleCharacter( sFontSampler, iChar, vUV ).agb;\n\n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n#endif    \n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;       \n    }\n    \n    state.vCursorPos.x += style.vSize.x * (extents.width + style.fAdvancement);\n}\n\n\nRect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )\n{\n    Rect rect;\n    \n    rect.vPos = state.vLayoutStart;\n    if ( initialLineOffset )\n    {\n    \trect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);\n    }\n\trect.vPos.y -= style.vSize.y * (g_fFontAscent);\n    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;\n    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );\n    \n    return rect;\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( PrintState state, LayoutStyle style, RenderStyle renderStyle, inout vec3 color )\n{   \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n// Font print helpers\n\n// need to find a way to do this from common\nint NO_UNROLL(int X) { return X; }\nuint NO_UNROLLU(uint X) { return X; }\n\n#define ARRAY_PRINT( STATE, STYLE, SAMPLER, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, SAMPLER, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > NO_UNROLLU( 0u ) )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, sFontSampler, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, sFontSampler, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, sFontSampler, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, sFontSampler, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= NO_UNROLL( -decimalPlaces ) )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, sFontSampler, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, sFontSampler, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n#endif ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}