{
    "Shader": {
        "info": {
            "date": "1477228076",
            "description": "This is twister used in \"8th Annual Laundry Party by HUGE LOAD\"\nhttp://www.pouet.net/prod.php?which=67975",
            "flags": 0,
            "hasliked": 0,
            "id": "XtVGDc",
            "likes": 27,
            "name": "Twister - 8th Annual Laundry",
            "published": 3,
            "tags": [
                "raymarching",
                "twister",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1723
        },
        "renderpass": [
            {
                "code": "// http://bit.ly/shadertoy-plugin\n\n#define FAR 30.\n#define INFINITY 1e32\n#define t iTime\n#define FOV 60.0\n#define FOG .4\n#define PI 3.14159265\n\nfloat \n    glow = 0.;\n\nint iterations = 0;\n    \nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 dF(vec3 p) {\n    p = p.yzx;\n\n    \n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj;\n        \n    p.z += sin(t / 2.) * 3.;\n    p.z *= sin(t) * 1.;\n    \n    pR(p.xy, -t * 2. + p.z);\n    \n    p.x += sin(p.z) / 2.;\n    \n    vec3 orgP = p;\n    \n    pModPolar(p.xy, 4.);\n\n    p.x -= .9;\n        \n    obj = vec3(\n        fBox(p, vec3(0.4, 0.7, 13.4)),\n        2.0,\n        0.0\n    );\n    \n    p = orgP;\n    \n    obj2 = vec3(\n        fBox(p, vec3(1.1, 1.1, 20.)),\n        1.0,\n        0.0\n    );\n\n    return opU2(obj, obj2);\n}\n\nfloat t_min = 0.001;\nfloat t_max = 50.;\nconst int MAX_ITERATIONS = 40;\n\nvec3 trace(vec3 ro,vec3 rd) \n{\n    vec3 mp = dF(ro);\n    glow = 0.;\n    float minDist = INFINITY;\n    float function_sign = (mp.x < 0.) ? -1. : 1.;\n\n    float h = .001;\n    float t = 0.;\n    \n\tfor(int i = 0; i < 60; i++) \n\t{\n        if (abs(h) < .001 || t > FAR) break;\n\t\tmp = dF(ro + rd * t);\n\t\tminDist = min(minDist, mp.x * 9.);\n        glow = pow(1. / minDist, 1.) / 4.;\n        h = function_sign * mp.x;\n        t += h;\n\t}\n    mp.x = t;\n    return mp;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 18;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 2.0;\n    float dist = .05;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = dF(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.1), 1.0);\n}\n\n#define E .1\nvec3 getNormalHex(vec3 pos) {\n\tfloat d=dF(pos).x;\n\treturn normalize(\n        vec3(\n            dF(\n                pos+vec3(E,0,0)).x-d,\n                dF(pos+vec3(0,E,0)).x-d,\n                dF(pos+vec3(0,0,E)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal) {\n    float dist = 0.4;\n    vec3 spos = hitp + normal * dist;\n    float sdist = dF(spos).x;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec2 mat) {\n    vec3 col = vec3(1);\n    \n    if (mat.x == 2.0) {\n        col = vec3(8., 3., 0.);\n        col.r *= sin(t);\n        col.g *= cos(t * .2);\n    }\n    \n    return col ;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 \n        ld = lp - sp,\n        objCol = getObjectColor(sp, sn, mat);\n\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    float \n        atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*0.05),\n    \tdiff = max(dot(sn, ld), 0.),\n\t\tspec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 7.0);\n    \n    // fresnel\n    vec3 H = normalize(normalize(ld) + rd);\n    \n    float \n        F = 14.0,\n    \tb = 1. - dot(rd, H),\n\t\texponential = pow( b, 5.0),\n\t\tfresnel = exponential + F * (1. - exponential);\t\n    \n    return (objCol * (diff + 0.15) + vec3(1.) * spec * fresnel) * atten;\n\n}\n\nvec4 pixelColor(vec2 fragCoord) {\n    fragCoord *= tan(radians (FOV) / 2.0);\n    \n    vec3 \n        light = vec3(0., 0., 5.),    \n    \tsceneColor = vec3(1.),\n    \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(0., 0. , 8.2), // cam pos\n    \tvrp =  vec3(0., 0., 0.), // lAt\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + fragCoord.x * u * iResolution.x/iResolution.y + fragCoord.y * v),\n    \t\n        rd = normalize(scrCoord - ro),\n    \ttr = trace(ro, rd),\n        sn;\n    \n    ro += rd * tr.x;\n    sn = getNormalHex(ro);\t\n    \n    float \n        fog = smoothstep(FAR * FOG, 0., tr.x),\n\t\tsh = softShadow(ro, light, .9),\n\t\tao = getAO(ro, sn);\n    \n    sceneColor += doColor(ro, rd, sn, light, tr.yz);\n    \n    if (tr.x < FAR) {\n        sceneColor *= fog;\n        sceneColor *= ao;\n        sceneColor *= sh;\n        sceneColor += pow(max(0., sn.y) , 5.);\n    } else {\n     \tsceneColor *= 0.;\n        sceneColor += pow(glow, 1.4) * .8;\n    }\n\n    return vec4(clamp(sceneColor, 0.0, 1.0), tr.x > 10. ? 0. : pow(abs(ro.z) * .5, 5.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixelColor(fragCoord / iResolution.xy - .5);\n    //fragColor = fragColor.aaaa;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}