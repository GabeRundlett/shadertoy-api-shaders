{
    "Shader": {
        "info": {
            "date": "1715549750",
            "description": "A little demo trying to make temporal flow-map not suck quite as much using a bunch of modifications. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4c33D7",
            "likes": 8,
            "name": "Temporal Flowmap (but better)",
            "published": 3,
            "tags": [
                "flow",
                "flow",
                "field",
                "vector",
                "advection",
                "directional",
                "flowmap",
                "temporal"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI've created a little demo of a temporal flowmap, incorporating all the \nenhancements I could find to optimize its aesthetics. If you have more\nplease feel free to comment suggestions.\n\nThe temporal flowmap includes the following modifications:\n- Sine hills (very cheap quasi noise) offset the time to mask the pulsing \n   effect and introduce minimal counterflow. Counterflow creates an \n   illusion where the flow direction appears to move backwards, despite \n   the vector pointing in the opposite direction, which we want to avoid.\n- The distortion range is from -0.5 to 0.5, allowing for increased \n   distortion without distorting the image into noise.\n- Each new phase is offset to prevent the animation from noticeably \n   repeating.\n- I've eliminated the smooth weight as, in my opinion, it makes the \n   pulsing more obvious.\n- Fabrice's histogram adjustment is used to make the blending more subtle.\n*/\n\n// Enable boyband, lol no. This makes the flow direction mouse controled\n//#define ONE_DIRECTION\n\n// Enable this to show arrows pointing in the flow direction\n//#define QUIVERPLOT\n\n// Colors the different phases in red and green for debugging\n//#define SHOW_PHASE\n\n// Sine hill tiling mask, which is faster than a texture lookup\nfloat hills(vec2 uv) {\n    vec2 d = sin(uv*3.1415); // Remove pi-sized grid\n    return (d.x+d.y)*0.25+0.5; // Add and rescale to 0-1\n}\n\n// Temporal Flowmap with some extra stuff to make it nicer\nvec3 flowmap(sampler2D tex, vec2 uv, vec2 direction, float time) { \n\n    // Temporal offset to remove pulsing, but creates counterflow so be careful\n    time -= hills(uv); // Noise texture is more expensive and has more counterflow\n    \n    // Generate timers range -0.5 to 0.5\n    float progressA = fract(time)-0.5;\n    float progressB = fract(time +0.5)-0.5;\n    \n    // Offset each new phase\n    vec2 jump = vec2(0.248, 0.201);\n    vec2 offsetA = (time - progressA) * jump;\n    vec2 offsetB = (time - progressB) * jump +0.5;\n    \n    // Sample color texture using different timers to scale offset strength\n    vec3 colorA = texture(tex, uv -progressA *direction +offsetA).xyz;\n    vec3 colorB = texture(tex, uv -progressB *direction +offsetB).xyz;\n    \n    #ifdef SHOW_PHASE\n        // Make the different phases red and green for debugging\n        colorA = vec3(colorA.x, 0,0);\n        colorB = vec3(0, colorB.x, 0);\n    #endif\n    \n    // Generate interpolation weights\n    float weight = abs(progressA*2.); \n    \n    // Optional Contrast. Why is everyone using this? It makes blend so much more obvious\n    //weight = smoothValue(weight); \n\n    // Interpolate the two offset samples\n    vec3 color = mix(colorA, colorB, weight);\n\n    #ifndef SHOW_PHASE\n        // NB: Histogram correction: https://hal.inria.fr/inria-00536064v2\n        // Modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \n        vec2 weights = vec2(weight, 1.-weight);    \n        float squaredWeightSum = dot(weights, weights);       \n\n        // Sampling mips lowest level to get the mean. Can be a constant if known.\n        vec3 mean = textureLod(tex, vec2(0), 99.).xyz; \n\n        // Variance restoration with normalization\n        color = mean + (color - mean) / sqrt(squaredWeightSum);\n    #endif\n    \n    // Clamping because histogram correction sometimes overdoes it\n    return clamp(color, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Square UVs with (0,0) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 2.; \n    \n    #ifdef ONE_DIRECTION\n        // If the mouse was not clicked, animate\n        vec2 direction;\n        if (iMouse.x > 0.0) {\n            // Normalize the vector\n            direction = safeNormalize(iMouse.xy / iResolution.xy - 0.5);\n\n        } else {\n            // Rotate vector\n            direction = vec2(cos(iTime * 0.2), sin(iTime * 0.2));        \n        }\n\n        // Apply Gauss/normal distribution to distance\n        direction *= exp(-1.0 * dot(uv,uv));\n    #else \n    \n        // Some vector noise\n        vec2 direction = curl(uv, uint(2), uvec2(421));\n    #endif\n       \n    // Flow completes one cycle every 1 time, so make it way slower\n    float flowTime = iTime * 0.15;\n    \n    // Temporal flowmap sample \n    vec3 color = flowmap(iChannel0, uv, direction * 0.3, flowTime);\n       \n    #ifndef SHOW_PHASE\n        // Apply cosmetic colormap\n        color = magma(pow(1.-color.x, 1.5));\n    #endif\n\n    #ifdef QUIVERPLOT\n        // Debug quiver plot to show the flow direction as arrows\n        color += quiverPlot(uv, direction, 8.);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERIC ____________________________________________________________\n\n// Safe Normalization using dot product and square root\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 safeNormalize(vec2 vector) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector using the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(0,1);\n    }\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Simplified Smootherstep https://www.desmos.com/calculator/5fkazkmq6q\nvec2 smootherValue(vec2 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * x * (x * (x * 6. - 15.) + 10.); \n}\n\n// Derivative of simplified Smootherstep above\nvec2 smootherDerivative(vec2 x) {\n    x = clamp(x, 0.0, 1.0); \n    vec2 part = (x - 1.); \n    return 30. * part * part * x * x; \n}\n\n// NOISE ____________________________________________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}\n\n// Helper Function for curl Perlin noise\nvec3 rndGradient(vec2 grid, vec2 id, vec2 offset, uint gridsize, uvec2 seed) {\n\n    // Current cell coordinates\n    vec2 cell = id + offset;\n\n    #ifdef TILING\n        // This makes the noise repeat between positions 0 and 1\n        cell = mod(cell, float(gridsize));\n    #endif\n\n    // Generate a random offset for the current cell\n    vec2 randomOffset = hash22(cell + vec2(seed)) - 0.5;\n    \n    // Generate random gradient    \n    float gradient = dot(grid - offset, randomOffset);\n    \n    return vec3(randomOffset, gradient);\n}\n\n// Function to generate Curl noise from Perlin 2D noise\n// Cleaned up version originally from https://www.shadertoy.com/view/Dd3yW4\nvec2 curl(vec2 position, uint gridsize, uvec2 seed) {\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 id = floor(position.xy); // Integer coordinates\n    vec2 grid = position.xy - id; // Fractional coordinates    \n    \n    // Sample noise at the corners\n    vec3 a = rndGradient(grid, id, vec2(0,0), gridsize, seed);\n    vec3 b = rndGradient(grid, id, vec2(1,0), gridsize, seed);\n    vec3 c = rndGradient(grid, id, vec2(0,1), gridsize, seed);\n    vec3 d = rndGradient(grid, id, vec2(1,1), gridsize, seed);\n    \n    // Generate smoother transitions between the weights\n    vec2 smoothCoords = smootherValue(grid); // For some contrast\n    vec2 smoothDX = smootherDerivative(grid);\n    \n    // Analytic derivative calculation\n    vec2 gradient =  a.xy + smoothCoords.x * (b.xy-a.xy) + \n                     smoothCoords.y * (c.xy-a.xy) + \n                     smoothCoords.x * smoothCoords.y *(a.xy-b.xy-c.xy+d.xy) + \n                     (smoothCoords.yx * (a.z - b.z - c.z + d.z) +\n                     vec2(b.z,c.z) - a.z) * smoothDX;\n    \n    // Rescale result\n    return gradient;\n}\n\n// DEBUG ____________________________________________________________\n\n// makes jet colormap with polynimal 6\nvec3 magma(float t) {\n    const vec3 c0 = vec3(-0.002292,-0.001348,-0.011890);\n    const vec3 c1 = vec3(0.234451,0.702427,2.497211);\n    const vec3 c2 = vec3(8.459706,-3.649448,0.385699);\n    const vec3 c3 = vec3(-28.029205,14.441378,-13.820938);\n    const vec3 c4 = vec3(52.814176,-28.301374,13.021646);\n    const vec3 c5 = vec3(-51.349945,29.406659,4.305315);\n    const vec3 c6 = vec3(18.877608,-11.626687,-5.627010);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n\n    // constants that maybe should be input variables\n    const float lineThickness = 0.03;    // Thickness of the arrow line\n    const float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    const float maxSize = 0.9;           // Maximum arrow length (1 should be the max)\n    const float minSize = 0.1;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the direction vector length is almost 0\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        //return step(arrowDist, 0.0); // no AA\n        float blur = (gridSize * 1.0)/(size * 420.);\n        return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}