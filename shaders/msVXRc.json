{
    "Shader": {
        "info": {
            "date": "1681437256",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "msVXRc",
            "likes": 19,
            "name": "Year of Truchets #010",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #010\n    04/14/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI    3.14159265358\n#define PI2   6.28318530718\n#define SQ3   1.732\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n// @iq.\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat time,ga1,ga2,ga3,ga4,tmod;\n\n// @Shane\nvec4 hexGrid(vec2 uv, float scale) {\n    uv*=scale;\n    const vec2 s = vec2(SQ3, 1.);\n    vec4 hC = floor(vec4(uv, uv - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\n\n// globals and constants\nmat2 r60,turn,twist;\nvec2 gid,sid;  \nvec3 hp, hit;\nvec4 hexTiles = vec4(0);\nfloat thrs=.15,xln,tm,bgf=0.;\n\nconst float scale = .255;\nconst float sx = SQ3/scale;\nconst float s4 = .577350;\nconst float s3 = .288683;\nconst float amt = 9.;\n\nvec2 map(vec3 pos, float sg) {\n\n    vec2 res =vec2(1e5,0.);\n\n    // scale and grid motion\n    pos.z  *= scale;\n    pos.xy *= rot(ga3*-1.5707);\n    pos.x  += ga2*sx;\n    \n    hexTiles=hexGrid(pos.xy,scale);\n    vec2 p  = hexTiles.xy;\n    vec2 id = hexTiles.zw;\n\n    float rnd = hash21(id);\n    float dir = 1.;\n\n    if (rnd>.5) {\n        p *= r60;\n        p.y=-p.y;\n        dir = -1.;\n    } \n    \n    // set vectors\n    vec2 p0 = p - vec2(-s3, .5);\n    vec2 p1 = p - vec2(s4,  0);\n    vec2 p2 = p - vec2(-s3,-.5);\n    \n    vec2 da = vec2(0);\n    \n    // find closest points\n    vec3 a3 = vec3(atan(p0.x, p0.y),atan(p1.x, p1.y),atan(p2.x, p2.y));\n    vec3 d3 = vec3(length(p0), length(p1), length(p2));\n    vec2 pp = vec2(0);\n\n    if (d3.x>d3.y) {\n        pp = p1;\n        da = vec2(d3.y, a3.y);\n    }\n    if (d3.y>d3.z) {\n        pp = p2;\n        da = vec2(d3.z, a3.z);\n    }\n    if (d3.z>d3.x && d3.y>d3.x) {\n        pp = p0;\n        da = vec2(d3.x, a3.x);\n    }\n    \n    const float zset = .35;\n    vec3 dp = vec3(pp,pos.z+zset);\n    float ft = .02+.01*sin(pos.x*.415);\n    float tx = torus(dp,vec2(s3,ft));\n    float ff = .11+.1*sin(pos.x*.213+T);\n    float tp = torus(dp+vec3(0,0,3.5),vec2(s3,ff));\n\n    float d = length(pp);\n    float pathMotion = da.y / PI2 * amt + (time*.65);\n    float x =fract(pathMotion) - .5;\n    float y = d-s3;\n\n    //fix id's for each ball\n    vec2 cid = vec2(\n       floor(d),\n       floor(pathMotion)-.5\n    );\n\n    cid = mod(cid,3.);\n        \n    vec3 tu = vec3(vec2(x*.25,y),pos.z+zset);\n    vec3 ty = tu, du = tu;\n    \n    float balls=length(ty)-.095;\n    twist = rot(cid.y*PI+T*dir);\n    tu.zy *= twist;\n    du.zy *= rot(cid.y*PI-T*dir);\n    \n    float boxs = box(tu,vec3(.075))-.002;\n    boxs = max(boxs,-balls);\n\n    if (boxs<res.x && cid.y<1.) {\n        res = vec2(boxs*.8,4.);\n        hp = tu;\n    }\n\n    balls = box(du,vec3(.025,.0075,.065))-.002;\n    \n    if(balls<res.x && cid.y>2.) {\n        res = vec2(balls,3.);\n        hp = ty;\n    }\n    \n    if (tx<res.x) {\n        res = vec2(tx,1.);\n        hp = dp;\n    }\n    \n    if (tp<res.x) {\n        res = vec2(tp,2.);\n        hp = dp;\n    } \n    \n    float fx = pos.z+4.5;\n    if (fx<res.x && bgf==1.) {\n        res = vec2(fx,9.);\n        hp = pos;\n    }\n    \n    // rescale\n    res.x *= 1./scale;\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = 1e-3*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d,0.);\n        if(ray.x<1e-4*d||d>40.) break;\n        d += i<32?ray.x*.3:ray.x*.95;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n.zy*=twist;//??maybe\n    n = max(abs(n), 1e-4);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec4 FC = vec4(.075);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100);\n    hit = hp;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<40.)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(10.,15.,25.);\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hit;\n \n        float diff = clamp(dot(n,l),.1,.95);\n\n        if (m==1.) { h = vec3(.05); ref=vec3(.0); }\n        if (m==2.) { h = vec3(0.502,0.502,0.502); ref=h*.3; }\n        if (m==3.) { h = vec3(0.659,0.000,0.000); ref=h*.5; }\n        if (m==4.) { h = tex3D(iChannel2,hp*6.,n).rgb; ref=vec3(.1); }\n        if (m==9.) { \n            h = texture(iChannel2,hp.xy).rgb; \n            ref = h;\n            vec2 f = fract(hit.xy*.15)-.5;\n            if(f.x*f.y>0.) { h=vec3(.0);  }\n\n        }\n        \n        C = (diff*h);\n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r60 = rot(1.0471975512);\n    time = T*.75;\n    tmod = mod(time, 10.);\n    float t1 = lsp(0., 5., tmod);\n    float t2 = lsp(5., 10., tmod);\n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n    ga2 = ga1+floor(time*.1);\n    ga3 = eoc(t2);\n    ga3 = ga3*ga3*ga3;\n    ga3 = ga3+floor(time*.1);\n\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,6.75);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    \n    \n    float ttt = T*.5;\n    tm   = mod(ttt, 20.);\n    \n    float t3 = lsp(3.,  5., tm);\n    float t4 = lsp(13., 15., tm);\n    \n    ga4 = ((t3-t4)*2.2)-1.1;\n    xln = ga4-(.025*sin(uv.y*25.+T*5.));\n\n    if(uv.x>xln) {\n        ro = vec3(0,0,2.15);\n        FC.rgb = vec3(.095);\n        bgf=1.;\n    }\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.;\n    \n    float clip = length(uv)-.5;\n    \n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.0001*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    if(uv.x+.01>xln && uv.x-.01<xln)C=vec3(1);\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}