{
    "Shader": {
        "info": {
            "date": "1647966439",
            "description": "random snowflake generator",
            "flags": 0,
            "hasliked": 0,
            "id": "ftsyW8",
            "likes": 3,
            "name": "Raymarch Snowflakes",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "karo",
            "viewed": 224
        },
        "renderpass": [
            {
                "code": "////// PI CONSTANTS //////\n#define M_PI   3.14159265358979323846264338327950288\n#define M_PI_4 .785398163397448309615660845819875721\n#define M_PI_6 .523598775598298873077107230546583814\n\n////// LIGHT POSITION //////\n#define LIGHT_X 0\n#define LIGHT_Y 3\n#define LIGHT_Z -3\n\n////// RAYMARCH SETTINGS /////\n#define MARCH_STEPS 100\n#define MARCH_DIST 100.0\n#define MARCH_TERMINATE .001\n\n////// PRNG //////\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n////// OPERATORS //////\n// rotate around axis\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// smooth step combine\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n////// BASIC SDFS //////\n// sphere = (x, y, z, radius)\nfloat dSphere(vec3 p, vec4 sphere){\n    return length(p - sphere.xyz) - sphere.w;\n}\n// torus = (x, y, z, radius)\nfloat dTorus(vec3 p, vec4 torus, float rThick){\n    vec3 pFloor = vec3(p.x, p.y, 0);\n    float dFloor = length(pFloor.xy - torus.xy) - torus.w;\n    float dRing = length(vec2(dFloor, p.z));\n    return dRing - rThick;\n}\n    \n///// COMPLEX SDFS /////\nfloat dHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// s = size\nfloat dOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat dCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// i made this :)\n// need to implement angle\nfloat dCylinderArrow(vec3 p, float r, float h, float angle) {\n    p.y += h * M_PI;\n    p.x -= h * M_PI;\n    pR(p.xy, M_PI_4);\n    float c1 = dCylinder(p, r, h);\n    pR(p.xy, -M_PI_4);\n    p.x += h * M_PI * 2.;\n    \n    pR(p.xy, -M_PI_4);\n    float c2 = dCylinder(p, r, h);\n    return opSmoothUnion(c1, c2, .1);\n}\n\n////// SCENE //////\nfloat calcScene(vec3 rayPoint) {\n    // random\n    //int tCenter = int(floor(clamp(rand(iTime) * 3., 0., 3.)));\n    //int tSpike  = int(floor(clamp(rand(iTimeDelta) * 2., 0., 2.)));\n    //int tOuter  = int(floor(clamp(rand(sin(iTime)) * 2., 0., 2.)));\n    \n    // showcase\n    int f = int(floor(float(iFrame) / 50.));\n    int tCenter = f % 3;\n    int tSpike = f % 2;\n    int tOuter = f % 2;\n    \n    float final = 1000.;\n    vec3 rayPointOrig = vec3(rayPoint.x, rayPoint.y, rayPoint.z);\n    \n    for(int i = 0; i < 6; i++) {\n        rayPoint = rayPointOrig;\n        \n        pR(rayPoint.xy, M_PI_6 * 2. * float(i));\n        rayPoint.y -= 1.;\n    \n        float dCenter = 0.;\n        float dSpike = 0.;\n        float dOuter = 1000.;\n        \n        float yOffset = 0.;\n\n        switch(tCenter) {\n            case 0:\n                dCenter = dSphere(rayPoint, vec4(0, .2, 0, .6));\n                yOffset = 1.5;\n                break;\n            case 1:\n                dCenter = dTorus(rayPoint, vec4(0, .2, 0, .5), .1);\n                yOffset = 1.8;\n                break;\n            case 2:\n                dCenter = dOctahedron(rayPoint, .6);\n                yOffset = 1.4;\n                break;\n        }\n\n        rayPoint.y -= yOffset;\n        switch(tSpike) {\n            case 0:\n                dSpike = dCylinder(rayPoint, 1.2, .2);\n                break;\n            case 1:\n                dSpike = dHexPrism(rayPoint.xzy, vec2(.2, 1.2));\n                break;\n        }\n\n        rayPoint.y -= 1.;\n        switch(tOuter) {\n            case 0:\n                dOuter = dOctahedron(rayPoint, .7);\n                break;\n            case 1:\n                dOuter = dCylinderArrow(rayPoint, 1.1, .2, 2.);\n                break;\n            \n        }\n\n        float flake = opSmoothUnion(opSmoothUnion(dCenter, dSpike, .3), dOuter, .8);\n        final = opSmoothUnion(flake, final, .3);    \n    }\n    return final;\n}\n\nfloat march(vec3 camPos, vec3 rayNorm) {\n    float rayDist = 0.0;\n    \n    for(int i = 0; i < MARCH_STEPS; i++) {\n        vec3 rayPoint = camPos + (rayNorm * rayDist);\n        float distToGeometry = calcScene(rayPoint);\n        rayDist += distToGeometry;\n        \n        if(rayDist > MARCH_DIST || distToGeometry <= MARCH_TERMINATE) break;\n    }\n    return rayDist;\n}\n\n////// LIGHTING //////\n// returns point's normal vector by calculating average\n// of three points .1 unit away on each axis\nvec3 getNormal(vec3 point) {\n    float distToGeometry = calcScene(point);\n    vec2 diff = vec2(.001, 0);\n    \n    return normalize(vec3(distToGeometry - vec3(\n        calcScene(point - diff.xyy),\n        calcScene(point - diff.yxy),\n        calcScene(point - diff.yyx)\n    )));\n}\n\n// simple shading using dot product of normals\n// returns 1.0 if light is parallel to rayHit, 0.0 if perpendicular\nfloat getSimpleShading(vec3 hitPoint) {\n    vec3 lightPos = vec3(LIGHT_X, LIGHT_Y, LIGHT_Z);\n    \n    // rotate light\n    //lightPos.x -= sin(iTime) * 2.;\n    //lightPos.z -= cos(iTime) * 2.;\n    \n    vec3 lightNorm = normalize(lightPos - hitPoint);\n    vec3 hitPointNorm = getNormal(hitPoint);\n    float illumination = 1.;\n    \n    // march another ray back from the hit point to the light\n    // start slightly offset to avoid terminating march prematurely\n    float distToLight = march(hitPoint + hitPointNorm * 0.15, lightNorm);\n    // if it hits something before it gets to the light,\n    if(distToLight < length(lightPos - hitPoint)){\n        // we are in a shadow\n        illumination = .3;\n    }\n    \n    // a light directly above will illuminate more than angled.\n    // dot product is 1 if light norm + point norm are identical,\n    // 0 at a right angle, and -1 when parallel -\n    // clamp this to [0, 1] to get simple shading value\n    return clamp(dot(hitPointNorm, lightNorm), 0., 1.) * illumination;\n}\n\n////// ENTRYPOINT //////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0, 0, -10); \n    vec3 rayNorm = normalize(vec3(uv.x, uv.y, 1));\n\n    float rayDist = march(camPos, rayNorm);\n    vec3 hitPoint = camPos + (rayNorm * rayDist);\n    vec3 col = vec3(getSimpleShading(hitPoint));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}