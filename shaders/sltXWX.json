{
    "Shader": {
        "info": {
            "date": "1639924754",
            "description": "A bath taken in the middle of the night.\nIt was a place of relaxation, but also a bit of anxiety.",
            "flags": 0,
            "hasliked": 0,
            "id": "sltXWX",
            "likes": 17,
            "name": "In the bathroom",
            "published": 3,
            "tags": [
                "3d",
                "modeling"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// Uncommenting this macro will enable anti-aliasing.\n// However, it takes a long time to compile\n// (less than 30 seconds on my machine with Windows 10 and RTX 2070).\n// #define AA 2\n\n/******************** Config ********************/\nconst vec3 CAMERA_POSITION = vec3(-2, -2, 6);\nconst vec3 CAMERA_DIRECTION = vec3(0.5, 0.25, -1.5); // <- will normalized\nconst float CAMERA_AMP = 0.005;\n\nconst float FAR = length(CAMERA_POSITION) * 2.0;\n\n// the main wall is always the plane z = 0\n\n// light\nconst float LIGHT_SCALE = 1.5;\nconst mat3 LIGHT_ROTATE = rotate3D(vec3(1, 0, 0), PI/2.0);\n// LIGHT_DISP does not exist. Light is always at the origin.\n\n// shower base\nconst float BASE_SCALE = 0.5;\nconst mat3 BASE_ROTATE =\n    rotate3D(vec3(0, 0, 1), PI / 2.0) * rotate3D(vec3(1, 0, 0), PI / 2.0);\nconst vec3 BASE_DISP = vec3(-1.2, -1.7, 0);\n\n// shower\nconst float SHOWER_SCALE = 0.6;\nconst mat3 SHOWER_ROTATE = rotate3D(vec3(1, 0, 0), PI / 6.0)\n        * rotate3D(vec3(0, 0, 1), -PI / 2.0)\n        * rotate3D(vec3(1, 0, 0), -PI / 2.0);\nconst vec3 SHOWER_DISP = vec3(-1.2, -1.4, 0.21);\nconst float SHOWER_HOLE_RADIUS = 6.0;\nconst float SHOWER_HOLE_THETA = 20.0;\n\n// mirror\nconst vec3 MIRROR_DISP = vec3(2, -3.5, 0);\n// Mirror is easy to model and directly tweak the SDF for scale and rotation.\n\n// hanger\nconst float HANGER_SCALE = 1.0;\nconst mat3 HANGER_ROTATE = rotate3D(vec3(0, 0, 1), PI / 2.0)\n        * rotate3D(vec3(0, 1, 0), PI / 2.0);\nconst vec3 HANGER_DISP = vec3(4.5, -2.2, 2.5);\n\n// after effect\nconst float LIGHT_FLICKER = 0.1;\nconst float STEAM = 0.025;\n\n/******************** Object SDFs ********************/\nfloat sdWall(in vec3 p) {\n    return p.z;\n}\n\nfloat sdLight(in vec3 p) {\n    vec3 q; // temporary\n\n    q = p - vec3(0, 0.05, 0.0);\n    float base = sdCylinder(q, 0.3, 0.05);\n\n    q = p - vec3(0, 0.3, 0.0);\n    float head = sdCylinder(q, 0.4, 0.15) - 0.05;    \n\n    return min(base, head);\n}\n\nfloat sdShowerBase(in vec3 p) {\n    vec3 q; // temporary\n    \n    float dist = sdTrape(p, 0.4, 0.3, 0.5);\n\n    q = rotate3D(vec3(0, 0, 1), PI / 2.0) * (p - vec3(0, 0.35, 0));\n    dist = max(dist, -sdCylinder(q, 0.2, 1.0));\n\n    return dist - 0.005;\n}\n\nfloat sdShower(in vec3 p) {\n    vec3 q; // temporary\n\n    // shower head\n    q = p + vec3(0.3, 0, 0);\n    float head = sdCylinder(q, 0.5, 0.1) - 0.1;\n\n    // shower nozzle\n    q = rotate3D(vec3(0,0,1), PI/1.5) * (p - vec3(0.15, 0, 0));\n    float nozzle = sdTrape(q, 0.2, 0.1, 0.4);\n\n    q = rotate3D(vec3(0, 0, 1), PI / 1.5) * (p - vec3(0.9, -0.43, 0)) - vec3(0, 1, 0);\n    float hose = sdCylinder(q, 0.1, 2.0);\n    return opSmoothUnion(opSmoothUnion(head, nozzle, 0.05), hose, 0.05);\n}\n\nfloat sdMirror(in vec3 p) {\n    float dist = sdBox(p, vec3(1, 2, 0.1)) - 0.1;\n    dist = max(dist, p.z - 0.1);\n    return dist;\n}\n\nfloat sdRightWall(in vec3 p) {\n    return 4.5 - p.x;\n}\n\nfloat sdHanger(in vec3 p) {\n    vec3 q; // temporary\n    float dist = 100.0;\n\n    q = p - vec3(-2, 0, 0);\n    dist = min(dist, sdCylinder(q, 0.1, 0.3) - 0.1);\n    q = p - vec3(2, 0, 0);\n    dist = min(dist, sdCylinder(q, 0.1, 0.3) - 0.1);\n    q = rotate3D(vec3(0, 0, 1), PI / 2.0) * (p - vec3(0, 0.2, 0));\n    dist = min(dist, sdCylinder(q, 0.1, 2.0));\n\n    return dist;\n}\n\n/******************** Macro utility ********************/\n#define DEF_RAYMARCHING(raymarch, sDist, LOOP_MAX) \\\nfloat raymarch(in Ray ray) {\\\n    float dist = 0.0;\\\n    for (int i = 0; i < LOOP_MAX; i++) {\\\n        vec3 p = ray.origin + dist * ray.direction;\\\n        float dist0 = sDist(p);\\\n        if (dist0 < 1.0e-6 || dist > FAR) break;\\\n        dist += dist0;\\\n    }\\\n    return dist;\\\n}\n\n// Take a sample point from the surface of the light and average it.\n#define DEF_SURFACE_LIGHTING(color, colorOneLight) \\\nvec3 color(in vec3 p, in Ray ray, in vec3 normal) {\\\n    int index = objectIndex(p);\\\n    float lightRadius = 0.4 * LIGHT_SCALE;\\\n    float lightDistance = length(p.xy);\\\n    float theta = acos(lightRadius / lightDistance);\\\n    vec3 col = vec3(0);\\\n    const int U_SAMPLE = 5;\\\n    const int V_SAMPLE = 3;\\\n    for (int i = 0; i < U_SAMPLE; i++) {\\\n        float u = float(i) / float(U_SAMPLE - 1);\\\n        u = theta * (2.0 * u - 1.0);\\\n        float cu = cos(u), su = sin(u);\\\n        mat2 mat = mat2(cu, su, -su, cu);\\\n        vec2 lpb = mat * normalize(p.xy) * lightRadius;\\\n        for (int j = 0; j < V_SAMPLE; j++) {\\\n            float h = float(j) / float(V_SAMPLE - 1);\\\n            h = (0.1 + 0.4 * h) * LIGHT_SCALE;\\\n            col += colorOneLight(p, ray, normal, vec3(lpb, h));\\\n        }\\\n    }\\\n    return col / float(U_SAMPLE * V_SAMPLE);\\\n}\n\n/******************** Global SDF ********************/\nfloat sDist(in vec3 p) {\n    vec3 q; // temporary\n\n    float dist = sdWall(p);\n\n    q = transpose(LIGHT_ROTATE) * p / LIGHT_SCALE;\n    dist = min(dist, sdLight(q) * LIGHT_SCALE);\n    \n    q = transpose(BASE_ROTATE) * (p - BASE_DISP) / BASE_SCALE;\n    dist = min(dist, sdShowerBase(q) * BASE_SCALE);\n\n    q = transpose(SHOWER_ROTATE) * (p - SHOWER_DISP) / SHOWER_SCALE;\n    dist = min(dist, sdShower(q) * SHOWER_SCALE);\n\n    q = p - MIRROR_DISP;\n    dist = min(dist, sdMirror(q));\n\n    dist = min(dist, sdRightWall(p));\n\n    q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    dist = min(dist, sdHanger(q) * HANGER_SCALE);\n\n    return dist;\n}\n\nDEF_RAYMARCHING(raymarch, sDist, 256)\n\nvec3 calcNormal(in vec3 p) {\n    const vec2 e = vec2(0, 1.0e-4);\n    return normalize(vec3(\n        sDist(p + e.yxx) - sDist(p - e.yxx),\n        sDist(p + e.xyx) - sDist(p - e.xyx),\n        sDist(p + e.xxy) - sDist(p - e.xxy)\n    ));\n}\n\n/******************** coloring ********************/\nint objectIndex(in vec3 p) {\n    vec3 q;\n\n    float dist = sdWall(p);\n    if (dist < 1.0e-5) return 0;\n\n    q = transpose(LIGHT_ROTATE) * p / LIGHT_SCALE;\n    dist = sdLight(q) * LIGHT_SCALE;\n    if (dist < 1.0e-5) return 1;\n    \n    q = transpose(BASE_ROTATE) * (p - BASE_DISP) / BASE_SCALE;\n    dist = sdShowerBase(q) * BASE_SCALE;\n    if (dist < 1.0e-5) return 2;\n\n    q = transpose(SHOWER_ROTATE) * (p - SHOWER_DISP) / SHOWER_SCALE;\n    dist = sdShower(q) * SHOWER_SCALE;\n    if (dist < 1.0e-5) return 3;\n\n    q = p - MIRROR_DISP;\n    dist = sdMirror(q);\n    if (dist < 1.0e-5) return 4;\n\n    dist = sdRightWall(p);\n    if (dist < 1.0e-5) return 5;\n    \n    q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    dist = sdHanger(q) * HANGER_SCALE;\n    if (dist < 1.0e-5) return 6;\n\n    return 7;\n}\n\nvec3 colWallOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    vec3 lightDir = normalize(p - lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.1, 0.8);\n\n    float shadow = 1.0, dist = 0.01,\n        lightDist = distance(p, lightPos), k = 2.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0; vec3 q;\n        q = transpose(BASE_ROTATE) * (p0 - BASE_DISP) / BASE_SCALE;\n        dist0 = sdShowerBase(q) * BASE_SCALE;\n\n        q = transpose(SHOWER_ROTATE) * (p0 - SHOWER_DISP) / SHOWER_SCALE;\n        dist0 = min(dist0, sdShower(q) * SHOWER_SCALE);\n\n        if (dist0 < 1.0e-2) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nDEF_SURFACE_LIGHTING(colWall, colWallOneLight)\n\nvec3 colShowerBaseOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    vec3 lightDir = normalize(p - lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.2, 0.5) * 0.9;\n    c += microfacet(normal, ray.direction, ray.direction, 0.0, 0.5) * 0.1;\n\n    float shadow = 1.0, dist = 0.01,\n        lightDist = distance(p, lightPos), k = 2.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0 = 100.0; vec3 q;\n        q = transpose(BASE_ROTATE) * (p0 - BASE_DISP) / BASE_SCALE;\n        dist0 = sdShowerBase(q) * BASE_SCALE;\n\n        q = transpose(SHOWER_ROTATE) * (p0 - SHOWER_DISP) / SHOWER_SCALE;\n        dist0 = min(dist0, sdShower(q) * SHOWER_SCALE);\n\n        if (dist0 < 1.0e-3) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nDEF_SURFACE_LIGHTING(colShowerBase, colShowerBaseOneLight)\n\nvec3 colShowerOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    float shadow = 1.0, dist = 0.05,\n        lightDist = distance(p, lightPos), k = 2.0;\n    vec3 lightDir = normalize(p - lightPos);\n    for (int i = 0; i < 64; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0 = 100.0; vec3 q;\n        q = transpose(BASE_ROTATE) * (p0 - BASE_DISP) / BASE_SCALE;\n        dist0 = sdShowerBase(q) * BASE_SCALE;\n\n        q = transpose(SHOWER_ROTATE) * (p0 - SHOWER_DISP) / SHOWER_SCALE;\n        dist0 = min(dist0, sdShower(q) * SHOWER_SCALE);\n\n        if (dist0 < 1.0e-3) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    mat3 mat = transpose(SHOWER_ROTATE);\n    p = mat * (p - SHOWER_DISP) / SHOWER_SCALE;\n    normal = mat * normal;\n    lightPos = mat * (lightPos - SHOWER_DISP) / SHOWER_SCALE;\n    ray.direction = mat * ray.direction;\n    lightDir = normalize(p - lightPos);\n\n    k = length(p.zx + vec2(0.0, 0.3));\n    vec3 q = rotate3D(vec3(0, 0, 1), PI / 1.5) * (p - vec3(0.9, -0.43, 0));\n    float c;\n    if (p.y < 0.00001 && k < 0.5) {\n        vec2 r = (p.zx + vec2(0.0, 0.3)) / 0.5;\n        float r_int = (floor(length(r) * SHOWER_HOLE_RADIUS) + 0.5) / SHOWER_HOLE_RADIUS;\n        float theta = acos(clamp(normalize(r).x, -1.0, 1.0)) * sign(r.y);\n        c = 1.0;\n        k = length(r);\n        if ((theta < PI * 0.4 || PI * 0.6 < theta || k < 0.5) && k > 0.2) {\n            float theta_int = (floor(theta / (2.0 * PI) * SHOWER_HOLE_THETA) + 0.5);\n            theta_int *= 2.0 * PI / SHOWER_HOLE_THETA;\n            vec2 center = r_int * vec2(cos(theta_int), sin(theta_int));\n            c = clamp(distance(r, center) / 0.025, 0.0, 1.0);\n        }\n        c = microfacet(normal, ray.direction, ray.direction, 0.2, 0.8) * c * c * 0.3;\n    } else if (q.y < -0.43) {\n        c = microfacet(normal, ray.direction, lightDir, 0.2, 0.45) * 0.8;\n        c += microfacet(normal, ray.direction, ray.direction, 0.0, 0.5) * 0.2;\n    } else {\n        c = microfacet(normal, ray.direction, lightDir, 0.2, 1.0);\n    }\n    c = min(c, 1.0);\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nDEF_SURFACE_LIGHTING(colShower, colShowerOneLight)\n\nvec3 colMirrorSideOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    vec3 lightDir = normalize(p - lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.9, 0.3);\n    return vec3(c);\n}\n\nDEF_SURFACE_LIGHTING(colMirrorSide, colMirrorSideOneLight)\n\n// It is far enough away from the viewpoint and lights. The light is considered a point source.\nvec3 colRightWall(in vec3 p, in Ray ray, in vec3 normal) {\n    vec3 lightPos = vec3(0, 0, 0.4);\n    vec3 lightDir = normalize(p - lightPos);\n    float lightDist = distance(p, lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.1, 0.8) / (lightDist * lightDist * 0.05);\n\n    float shadow = 1.0, dist = 0.01, k = 2.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0; vec3 q;\n        q = transpose(HANGER_ROTATE) * (p0 - HANGER_DISP) / HANGER_SCALE;\n        dist0 = sdHanger(q) * HANGER_SCALE;\n\n        if (dist0 < 1.0e-2) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nvec3 colHanger(in vec3 p, in Ray ray, in vec3 normal) {\n    vec3 lightPos = vec3(0, 0, 0.4);\n    vec3 lightDir = normalize(p - lightPos);\n    float lightDist = distance(p, lightPos);\n\n    vec3 q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    vec3 col;\n    if (q.y > 0.3001) {\n        col = vec3(0.7, 0.8, 0.9);\n        col *= microfacet(normal, ray.direction, lightDir, 0.5, 0.2);\n    } else if (length(abs(q.zx) - vec2(0, 2)) > 0.2001) {\n        col = vec3(1.0);\n        col *= microfacet(normal, ray.direction, lightDir, 0.7, 0.5);\n    } else {\n        col = vec3(1.0);\n        col *= microfacet(normal, ray.direction, lightDir, 0.5, 0.2);\n    }\n\n    return col;\n}\n\nfloat sdInMirror(in vec3 p) {\n    vec3 q;\n\n    float dist = sdRightWall(p);\n\n    q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    dist = min(dist, sdHanger(q) * HANGER_SCALE);\n\n    return dist;\n}\n\nDEF_RAYMARCHING(raymarchInMirror, sdInMirror, 128)\n\nvec3 colInMirror(in vec3 p, in Ray ray, in vec3 normal) {\n    int index = objectIndex(p);\n    switch(index) {\n        case 5:\n            return colRightWall(p, ray, normal);\n        case 6:\n            return colHanger(p, ray, normal);\n    }\n}\n\nvec3 colMirror(in vec3 p, in Ray ray, in vec3 normal) {\n    if (normal.z < 1.0e-4) {\n        return colMirrorSide(p, ray, normal);\n    }\n\n    Ray refRay;\n    refRay.origin = p;\n    refRay.direction = reflect(ray.direction, normal);\n    float dist = raymarchInMirror(refRay);\n    vec3 refPos = refRay.origin + dist * refRay.direction;\n    vec3 refNormal = calcNormal(refPos);\n    return colInMirror(refPos, refRay, refNormal);\n}\n\nvec3 color(in vec3 p, in Ray ray, in vec3 normal) {\n    int index = objectIndex(p);\n    switch(index) {\n        case 0:\n            return colWall(p, ray, normal);\n        case 1:\n            float c = -dot(ray.direction, normal);\n            return vec3(1.0 - (1.0 - c) * (1.0 - c));\n        case 2:\n            return colShowerBase(p, ray, normal);\n        case 3:\n            return colShower(p, ray, normal);\n        case 4:\n            return colMirror(p, ray, normal);\n    }\n}\n\n/******************* main function ********************/\nvoid mainImage3D(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 disp = smoothnoise31(iTime * 0.05);\n    disp = 2.0 * CAMERA_AMP * disp - CAMERA_AMP;\n    Camera camera = newCamera(\n        CAMERA_POSITION + disp,\n        normalize(CAMERA_DIRECTION - disp),\n        vec3(0, 1, 0),\n        PI / 5.0,\n        1.0\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.y);\n\n    vec2 xy = ray.origin.xy - ray.direction.xy * ray.origin.z / ray.direction.z;\n    float a = 0.9 * LIGHT_SCALE, b = 0.5 * LIGHT_SCALE;\n    bool lightDomain = (xy.x * xy.x) / (a * a) + (xy.y * xy.y) / (b * b) < 1.0 || xy.y > 0.0;\n    bool showerDomain = xy.x < 0.0;\n\n    float dist = raymarch(ray);\n    vec3 p = ray.origin + dist * ray.direction;\n    vec3 normal = calcNormal(p);\n    vec3 col = color(p, ray, normal) * pow(vec3(1, 1, 0.9), vec3(2.2));\n\n    fragColor = vec4(col, 1);\n}\n\n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage3DAA(out vec4 O, in vec2 U) {\n    mainImage3D(O, U);\n    \n    #ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        vec4 o;\n    #if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage3D(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n    #elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage3D(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n    #endif\n\n    // If defined, visualize anti-aliased pixels.\n    //#define VISUALIZE_AA\n    #ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n    #endif\n    }\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord.x -= (iResolution.x - iResolution.y) / 2.0;\n    if (fragCoord.x < 0.0 || fragCoord.x > iResolution.y) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n\n    mainImage3DAA(fragColor, fragCoord);\n\n    vec2 uv = fragCoord / iResolution.y;\n    fragColor.xyz *= 1.0 - LIGHT_FLICKER * (1.0 - fbm113(iTime * 30.0, 0.0) / 3.0);\n    float br = smoothfbm125(uv * vec2(sqrt(2.0), sqrt(5.0)) * 10.0 - vec2(0, iTime * 0.5), 0.0);\n    br = (1.0 - br / 5.0) * STEAM;\n    fragColor.xyz = 1.0 - (1.0 - fragColor.xyz) * (1.0 - br);\n\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n    fragColor.w = 1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/******************** 3D toolkit ********************/\n\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n#define rotate3D(axis, angle) mat3(\\\n    axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\\\n    axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\\\n    axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\\\n)\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n/******************** hash & noise ********************/\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return mix(hash(uvec3(s)), hash(uvec3(s + 1u)), t);\n}\n\nfloat noise11(float x) {\n    return noise31(x).x;\n}\n\n#define three_mix(a0, a1, a2, t) (\\\n      a0 * (1.0 - t) * (1.0 - t) * 0.5\\\n    + a1 * ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5\\\n    + a2 * t * t * 0.5\\\n)\n\nvec3 smoothnoise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return three_mix(\n        hash(uvec3(s - 2u)),\n        hash(uvec3(s - 1u)),\n        hash(uvec3(s)),\n        t\n    );\n}\n\nfloat fbm113( in float x, in float H ) {\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i = 0; i < 3; i++ ) {\n        t += a*noise11(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec3 smoothnoise32(vec2 x) {\n    const int k = 2147483647;\n    uvec2 s = uvec2(ivec2(floor(x)) + k);\n    vec2 t = fract(x);\n    uvec3 e = uvec3(0, 1, 2);\n    return three_mix(\n        three_mix(\n            hash(uvec3(s - e.zz, k)),\n            hash(uvec3(s - e.yz, k)),\n            hash(uvec3(s - e.xz, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zy, k)),\n            hash(uvec3(s - e.yy, k)),\n            hash(uvec3(s - e.xy, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zx, k)),\n            hash(uvec3(s - e.yx, k)),\n            hash(uvec3(s - e.xx, k)),\n            t.x\n        ),\n        t.y\n    );\n}\n\nfloat smoothnoise12(vec2 x) {\n    return smoothnoise32(x).x;\n}\n\nfloat smoothfbm125( in vec2 x, in float H ) {\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < 5; i++ ) {\n        t += a*smoothnoise12(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n/******************** Primitive SDF ********************/\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( in vec3 p, in float angle, float h ) {\n  vec2 q = h*vec2(tan(angle),-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n// r0 > r1\nfloat sdTrape(in vec3 p, in float r0, in float r1, in float h) {\n    float theta = atan((r0 - r1), h);\n    float x = r0 * h / (r0 - r1);\n    return max(sdCone(p - vec3(0, x, 0), theta, x), p.y - h);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}