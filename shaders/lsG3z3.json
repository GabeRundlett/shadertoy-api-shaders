{
    "Shader": {
        "info": {
            "date": "1468026776",
            "description": "voxel builder, look at line 183 in Buf A for procedurally generated scene at the beginning",
            "flags": 48,
            "hasliked": 0,
            "id": "lsG3z3",
            "likes": 6,
            "name": "voxel builder",
            "published": 3,
            "tags": [
                "voxel",
                "builder"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 894
        },
        "renderpass": [
            {
                "code": "//Ethan Shulman 2016\n//Voxel ray casting code from fb39ca4's shader 'Branchless Voxel Raycasting' https://www.shadertoy.com/view/4dX3zl\n\n\n/*\n\nCONTROLS:\n\nmove camera - ARROW keys\nplace block - SPACE\ndelete block - B\nnext block - X\nlast block - Z\n\nrender - R\n\n*/\n\n\n//Image - Render\n\n\n\n\n#define pi 3.14\n#define ftx (.5/iResolution.xy)\n\n\nvec3 cameraLocation = vec3(5.);\n\n\n\n//VOLUME_SIZE.x*VOLUME_SIZE.y*VOLUME_SIZE.z must be smaller than iResolution.x*iResolution.y\nconst vec3 VOLUME_SIZE = vec3(60,39,60);\nvec3 ONE_DIV_VOLUME_SIZE = 1./VOLUME_SIZE;\n\n//lerp a to b where i=0 is 100% a, 0% b and 10=100 is 0% a, 100% b\nint imix(in int a, in int b, in int i) {\n    return ((b-a)*100)/i+a;\n}\n//mod for integers\nint imod(in int i, in int m) {\n    return i-m*(i/m);\n}\n//3d->1d coord\nint w2i(in vec3 p) {\n    return int(p.x)+int(p.y)*int(VOLUME_SIZE.x)+int(p.z)*int(VOLUME_SIZE.x*VOLUME_SIZE.y);\n}\n//2d->1d coord\nint t2i(in vec2 uv) {\n    return int(uv.x*iResolution.x)+int(uv.y*iResolution.y)*int(iResolution.x);    \n}\n//1d->2d coord\nvec2 i2t(in int id) {\n    return vec2(imod(id,int(iResolution.x)),\n                id/int(iResolution.x))/iResolution.xy;\n}\n//1d->3d coord\nvec3 i2w(in int id) {\n    return vec3( imod(id,int(VOLUME_SIZE.x)),\n                 imod(id/int(VOLUME_SIZE.x),int(VOLUME_SIZE.y)),\n                 id/(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)) );    \n}\n//3d->2d coord\nvec2 w2t(in vec3 p) {\n    int id = int(p.x)+int(p.y)*int(VOLUME_SIZE.x)+int(p.z)*int(VOLUME_SIZE.x*VOLUME_SIZE.y);\n    return vec2(fract(float(id)/iResolution.x), float(id/int(iResolution.x))/iResolution.y);\n}\n//2d->3d coord\nvec3 t2w(in vec2 uv) {\n    int id = int(uv.x*iResolution.x)+int(uv.y*iResolution.y)*int(iResolution.x);\n    return vec3( mod(float(id),float(VOLUME_SIZE.x)),\n                 mod(float(id/int(VOLUME_SIZE.x)),float(VOLUME_SIZE.y)),\n                 float(id/int(VOLUME_SIZE.x*VOLUME_SIZE.y)) );\n}\n\n//random float from 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//2d rotation\nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\n\nfloat hue(float a, float b, float c) {\n    float p = a, q = b, t = c;\n    if(t < 0.) t++;\n    if(t > 1.) t--;\n    if(t < 1./6.) return p + (q - p) * 6. * t;\n    if(t < 1./2.) return q;\n    if(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}\n\n//voxel color from id\nvec3 voxel(float id) {\n    float h = id/100.,\n          s = cos(id*2.385+cos(id))*.25+.75,\n          l = cos(id*1.34+cos(id))*.25+.5;\n    \n    vec3 c;\n    if(s == 0.) {\n        c = vec3(l);\n    } else {\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s,\n              p = 2. * l - q;\n        \n        c = vec3(hue(p,q,h+1./3.),\n                 hue(p,q,h),\n                 hue(p,q,h-1./3.));\n    }\n    \n    return c;\n}\n\n\n\n//background\nvec3 background(vec3 rd) {\n    const vec3 topBlue = vec3(155., 203., 202.)/355.,\n        \t   bottomBlue = vec3(.25),\n        \t   sun = vec3(254., 252., 2.)/255.,\n        \t   clouds = vec3(.12);\n    \n    vec2 ruv = vec2(.5+atan(abs(rd.z),rd.x)/(2.*pi),\n                    .5-asin(rd.y)/pi);\n    float cloudAmount = clamp((texture(iChannel3, 1.44+ruv*.5+0.2323).x-.64)*5., 0., 1.)*clamp(1.-abs(rd.y+.3)*2., 0., 1.),\n          sunAmount = dot(rd, normalize(vec3(0.,-1.,-1.)));\n    \n    vec3 sky = mix(mix(topBlue, bottomBlue, clamp((rd.y)*2., 0., 1.)),\n                   sun*40.,\n                   max(max(0.,sunAmount-.99)/.01, max(0., sunAmount)/140.));\n    \n    vec3 nSky = normalize(sky);\n    return mix(nSky,\n               clouds*(.5+texture(iChannel2,ruv*19.).x*.5), pow(max(cloudAmount-length(sky)/200., 0.),.45))*\n        mix( length(sky), 1., cloudAmount);\n    \n    \n    //float light = dot(normalize(vec3(3,-6,2)), d);\n   // return vec3(.43,.55,.94)+vec3(1.2,.75,.85)*(max(0.,light)*.25+max(0.,light-.99)/.01);\n}\n\n//0 = nothing, >0 = block id\nfloat scene(vec3 rp) {    \n    vec4 tex = texture(iChannel0, w2t(rp)+ftx);\n    \n    return tex.x;\n}\n\n\n//this function uses code from fb39ca4's shader 'Branchless Voxel Raycasting' https://www.shadertoy.com/view/4dX3zl\n//returns w=-1 if nothing was hit or if something was hit xyz=surface normal, w=voxel id\nivec4 trace(vec3 p, vec3 d) {\n    vec3 rp = floor(p),\n         dd = abs(1./d),\n         st = sign(d),\n         dst = (st*(rp-p)+(st*.5)+.5)*dd,\n         mask;\n        \n    for (int i = 0; i < 164; i++) {\n\n        bvec3 b1 = lessThan(dst, dst.yzx),\n              b2 = lessThanEqual(dst, dst.zxy);\n        mask = vec3(b1.x&&b2.x, b1.y&&b2.y, b1.z&&b2.z);\n\n\t\tdst += mask*dd;\n\t\trp += mask*st;\n        \n        if (rp.x<0.||rp.x>=VOLUME_SIZE.x||\n            rp.y<0.||rp.y>=VOLUME_SIZE.y||\n            rp.z<0.||rp.z>=VOLUME_SIZE.z) {\n            return ivec4(-1.);\n        }\n        \n        float vx = scene(rp);\n        if (vx > .5) return ivec4(mask*st, w2i(rp) );\n    }\n    \n    return ivec4(-1.);\n}\n\n\n//render scene simple lambert lighting\nvec3 renderSimple(vec3 p, vec3 d) {\n\tivec4 s = trace(p,d);\n    if (s.w < 0) return pow(background(d), vec3(1./2.2));\n    \n    vec3 vp = i2w(s.w),\n         norm = vec3(s.xyz),\n         color = voxel(scene(vp));\n    \n    return pow( (.2+.8*max(0., dot(normalize(vec3(.34,.84,.24)), norm)))*color, vec3(1./2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy,\n         uv = (R-fragCoord.xy*2.)/R.y;\n    vec2 cameraRotation = vec2(iTime, iTime*.4);\n\n    //if other.z > 1 then we are path tracing\n    vec4 other = texture(iChannel0, i2t(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)*int(VOLUME_SIZE.z)+1)+ftx);\n    if (other.z < 2.) {\n        vec4 camera = texture(iChannel0, i2t(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)*int(VOLUME_SIZE.z))+ftx);\n        cameraLocation = camera.xyz;\n        cameraRotation = vec2(camera.w-floor(camera.w),\n                              floor(camera.w)/2048.)*pi*2.;\n\t\t\n        vec3 rp,rd;\n        rp = cameraLocation,\n            rd = normalize(vec3(uv,1.));\n\n        rd.yz = rot(rd.yz,cameraRotation.y);\n        rd.xz = rot(rd.xz,cameraRotation.x);\n\n        //mix simple rendering and cursor\n        fragColor = vec4(mix(renderSimple(rp,rd),\n                             vec3(1.), max(0., 1.-2048.*max(0., length(uv)-length(2./iResolution.xy)))), 1.);\n    \t\n        //draw selected voxel and next/last in selection\n        #define dbx(p,s) length(max(abs(uv-p)-s,0.))\n        #define obx(d,c,o) mix(c,o,min(1.,d*128.))\n        #define dcl(d) min(1., max(0.,d-.01)*length(iResolution.xy*2.))\n        \n        float cdst1 = dbx(vec2(1.7,-.85), vec2(.06)),\n              cdst2 = dbx(vec2(1.5,-.85), vec2(.1)),\n              cdst3 = dbx(vec2(1.3,-.85), vec2(.06));\n        \n        fragColor = mix(vec4(obx(cdst1,voxel(max(1.,other.x-1.)),vec3(0.)),1.),\n                        fragColor, dcl(cdst1));\n        fragColor = mix(vec4(obx(cdst2,voxel(other.x),vec3(0.)),1.),\n                        fragColor, dcl(cdst2));\n        fragColor = mix(vec4(obx(cdst3,voxel(other.x+1.),vec3(0.)),1.),\n                        fragColor, dcl(cdst3));\n    } else {\n        fragColor = pow(texture(iChannel1, fragCoord/R)/(float(iFrame)-other.z), vec4(1./2.2));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Shulman 2016\n//Buf A - voxel map building\n\n\n#define pi 3.14\n#define ftx .5/iResolution.xy\n\n\n//VOLUME_SIZE.x*VOLUME_SIZE.y*VOLUME_SIZE.z must be smaller than iResolution.x*iResolution.y\nconst vec3 VOLUME_SIZE = vec3(60,39,60);\n\n\nstruct material {\n    vec3 diffuse,specular;\n    float metallic,\n          roughness,\n          emissive;\n};\n\n//lerp a to b over i(0-100)\nint imix(in int a, in int b, in int i) {\n    return ((b-a)*100)/i+a;\n}\n//mod for integers\nint imod(in int i, in int m) {\n    return i-m*(i/m);\n}\n//3d->1d coord\nint w2i(in vec3 p) {\n    return int(p.x)+int(p.y)*int(VOLUME_SIZE.x)+int(p.z)*int(VOLUME_SIZE.x*VOLUME_SIZE.y);\n}\n//2d->1d coord\nint t2i(in vec2 uv) {\n    return int(uv.x*iResolution.x)+int(uv.y*iResolution.y)*int(iResolution.x);    \n}\n//1d->2d coord\nvec2 i2t(in int id) {\n    return vec2(imod(id,int(iResolution.x)),\n                id/int(iResolution.x))/iResolution.xy;\n}\n//1d->3d coord\nvec3 i2w(in int id) {\n    return vec3( imod(id,int(VOLUME_SIZE.x)),\n                 imod(id/int(VOLUME_SIZE.x),int(VOLUME_SIZE.y)),\n                 id/(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)) );    \n}\n//3d->2d coord\nvec2 w2t(in vec3 p) {\n    int id = int(p.x)+int(p.y)*int(VOLUME_SIZE.x)+int(p.z)*int(VOLUME_SIZE.x*VOLUME_SIZE.y);\n    return vec2(fract(float(id)/iResolution.x), float(id/int(iResolution.x))/iResolution.y);\n}\n//2d->3d coord\nvec3 t2w(in vec2 uv) {\n    int id = int(uv.x*iResolution.x)+int(uv.y*iResolution.y)*int(iResolution.x);\n    return vec3( mod(float(id),float(VOLUME_SIZE.x)),\n                 mod(float(id/int(VOLUME_SIZE.x)),float(VOLUME_SIZE.y)),\n                 float(id/int(VOLUME_SIZE.x*VOLUME_SIZE.y)) );\n}\n\n//all of c's values must be clamped to 0-1\n//vec3 -> float\nfloat encodeVec3(vec3 c) {\n    return (floor(c.x*100.)/100.)/100.+\n           (floor(c.y*100.)/100.)+\n            floor(c.z*100.);\n}\n//float -> vec3\nvec3 decodeVec3(float v) {\n    float q = v;\n    vec3 c;\n    q -= c.z = floor(q);\n    c.z /= 100.;\n    q -= c.y = floor(q*100.)/100.;\n    c.z = floor(q*10000.)/100.;\n    return c;\n}\n\n//material -> vec3\nvec3 encodeMaterial(material m) {\n    return vec3(encodeVec3(m.diffuse), \n                encodeVec3(m.specular),\n                encodeVec3(vec3(m.metallic, m.roughness, m.emissive)));\n}\n//vec3 -> material\nmaterial decodeMaterial(vec3 v) {\n    vec3 o = decodeVec3(v.z);\n    return material(decodeVec3(v.x),\n                    decodeVec3(v.y),\n                    o.x, o.y, o.z);\n}\n\n//2d rotation\nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nfloat hash2(vec2 p) {\n    return fract(fract(p.x*43993.)*128.2483+fract(p.y*34834.)*128.345);\n}\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n\nfloat ruins(in vec3 p) {\n    vec3 rp = p;\n    float d = 0.;\n    float s = 18.;\n    \n    #define seed 2.054\n    #define seed2 1.53\n    for (int i = 0; i < 3; i++) {\n        rp -= s/8.;\n        d = max(-sdBox(mod(abs(rp), s*2.)-s, vec3(s*.9)), d);\n        \n        if (mod(float(i),2.) > 0.) {\n            rp.xz = abs(rot(rp.xz,float(i)*1.2+seed));\n        } else {\n            rp.zy = abs(rot(rp.zy,float(i)*1.2+seed2));\n        }\n        \n    \ts /= 2.;\n    }\n                       \n    return max(sdTriPrism(p*vec3(1.,-1.,1.), vec2(60., 40.)), d);\n                      \n                       /*  \n\tfloat d = smax( -(length(rp-vec3(6.,-28.,0.))-12.), sdTorus(rp.yzx-vec3(-8.,0.,0.), vec2(22.,6.)), 1.);   \n    \n    return smin(d, min(sdCapsule(rp,vec3(12.,-28.,0.),vec3(4.,-40.,0.),6.1),\n                       sdCapsule(rp,vec3(-3.,-29.,0.),vec3(-6.,-50.,0.),6.1)), 4.);\n*/\n}\n\n//default scene, returns voxel material id\nfloat scene(vec3 p) {\n     \n    if (p.y > 10.) {\n        return 3.;\n    }\n    return max(0., ceil(1.-ruins(p*3.))*(32.+hash3(floor(p*.25))*8.));\n    \n    \n    float theight = 0.;\n    for (int i = 1; i < 4; i++) {\n        float pii = pow(float(i),1.6);\n        theight += (abs(cos(float(i)*3.4+p.x*(1./pii)))*abs(cos(float(i)*5.4+p.z*(1./pii))))*pii;\n    }\n    \n    if (length(p)-7. < .01) {\n        return 64.;\n    }\n    if (p.y+theight > 10.) {\n        return 102.;\n    }\n    \n    return 0.;\n}\n\n\n//this function uses code from fb39ca4's shader 'Branchless Voxel Raycasting' https://www.shadertoy.com/view/4dX3zl\n//returns w=-1 if nothing was hit or if something was hit xyz=surface normal, w=voxel id\nivec4 trace(vec3 p, vec3 d) {\n    vec3 rp = floor(p),\n         dd = abs(1./d),\n         st = sign(d),\n         dst = (st*(rp-p)+(st*.5)+.5)*dd,\n         mask;\n        \n    for (int i = 0; i < 164; i++) {\n\n        bvec3 b1 = lessThan(dst, dst.yzx),\n              b2 = lessThanEqual(dst, dst.zxy);\n        mask = vec3(b1.x&&b2.x, b1.y&&b2.y, b1.z&&b2.z);\n\n\t\tdst += mask*dd;\n\t\trp += mask*st;\n        \n        if (rp.x<0.||rp.x>=VOLUME_SIZE.x||\n            rp.y<0.||rp.y>=VOLUME_SIZE.y||\n            rp.z<0.||rp.z>=VOLUME_SIZE.z) {\n            return ivec4(-1.);\n        }\n        \n        float vx = texture(iChannel0, w2t(rp)+ftx).x;\n        if (vx > .5) return ivec4(mask*st, w2i(rp));\n    }\n    \n    return ivec4(-1.);\n}\n\n\nconst int volumeSize = int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)*int(VOLUME_SIZE.z);\nconst int maxIndex = volumeSize+3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 p = t2w(uv);\n    int ind = t2i(uv);\n    if (ind > maxIndex) {return;}\n    \n    vec4 camera = texture(iChannel0, i2t(volumeSize)+ftx),\n         other = texture(iChannel0, i2t(volumeSize+1)+ftx);\n    float place = texture(iChannel1, vec2(32.5, 127.5)/255.).x,\n          delete = texture(iChannel1, vec2(66.5, 127.5)/255.).x;\n    float placeOrDelete = float(delete>0.);\n    \n    \n    vec2 cameraRot = vec2(camera.w-floor(camera.w),\n                                  floor(camera.w)/2048.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    rd.yz = rot(rd.yz,cameraRot.y*pi*2.);\n    rd.xz = rot(rd.xz,cameraRot.x*pi*2.);\n        \n    if (ind > volumeSize-1) {\n        ind -= volumeSize;\n        if (ind < 1) {//camera\n            \n            if (iFrame < 120) {\n            \tfragColor = vec4(20.,10.,20.,300.125);\n                return;\n            }\n            \n            if (other.z < 2.) {\n                //movement\n                float movementA = texture(iChannel1, vec2(38.5, 25.5)/255.).x-\n                                 texture(iChannel1, vec2(40.5, 25.5)/255.).x;\n                if (movementA != 0.) {\n                    camera.xyz += movementA*rd*.05;\n                }\n                float movementB = texture(iChannel1, vec2(37.5, 25.5)/255.).x-\n                     \t\t\t  texture(iChannel1, vec2(39.5, 25.5)/255.).x;\n                if (movementB != 0.) {\n                    vec3 rdB = vec3(1.,0.,0.);    \n                    rdB.yz = rot(rdB.yz,cameraRot.y*pi*2.);\n        \t\t\trdB.xz = rot(rdB.xz,cameraRot.x*pi*2.);\n                    camera.xyz += movementB*rdB*.05;\n                }\n                \n                //rotation\n                if (iMouse.z > 0.) {\n                    vec2 muv = (iMouse.xy/iResolution.xy)-.5;\n                    cameraRot += muv*.01;\n                }\n            }\n            \n            camera.w = fract(cameraRot.x)+\n                \t   floor(.5+fract(cameraRot.y)*2048.);\n            camera.xyz = clamp(camera.xyz,vec3(0.),VOLUME_SIZE);\n            fragColor = camera;\n        \n        } else if (ind < 2) {//other, x = selected color and z = is rendering\n            \n            if (iFrame < 120) {\n                fragColor = vec4(1.);\n                return;\n            }\n            \n            if (texture(iChannel1, vec2(82.5, 127.5)/255.).x > 0.) {\n\t\t\t\t//set initial rendering frame\n                other.z = other.z<2.?float(iFrame):1.;\n            }\n            \n            //go forward/backward in voxel material selection\n            if (iTime-other.y > .1 && texture(iChannel1, vec2(88.5, .5)/255.).x > 0.) {\n                other.x++;\n                other.y = iTime;\n            }\n            if (iTime-other.y > .1 && texture(iChannel1, vec2(90.5, .5)/255.).x > 0.) {\n                other.x = max(1., other.x-1.);\n                other.y = iTime;\n            }\n            \n            fragColor = other;\n        }\n        return;\n    }\n    if (iFrame < 120) {\n        //set default scene\n        fragColor = vec4(scene(p-VOLUME_SIZE/2.));\n        return;\n    }\n    \n    \n    //place or delete blocks\n    fragColor = texture(iChannel0, uv);\n    \n    ivec4 hit = trace(camera.xyz, rd);\n    hit.w = delete>0.?\n        hit.w:w2i(i2w(hit.w)-vec3(hit.xyz));\n    \n    fragColor = mix(fragColor,\n                    mix(vec4(other.x),vec4(0.),placeOrDelete),\n                    max(place,delete)*float(hit.w == ind));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Shulman 2016\n//Voxel ray casting code from fb39ca4's shader 'Branchless Voxel Raycasting' https://www.shadertoy.com/view/4dX3zl\n\n//Buf B - Renders scene with montecarlo path tracing\n\n\n\n#define bounces 4\n\n\n#define pi 3.14\n#define ftx (.5/iResolution.xy)\n\n\nvec3 cameraLocation = vec3(5.);\n\n\n\n//VOLUME_SIZE.x*VOLUME_SIZE.y*VOLUME_SIZE.z must be smaller than iResolution.x*iResolution.y\nconst vec3 VOLUME_SIZE = vec3(60,39,60);\nvec3 ONE_DIV_VOLUME_SIZE = 1./VOLUME_SIZE;\n\n\n//lerp a to b where i=0 is 100% a, 0% b and 10=100 is 0% a, 100% b\nint imix(in int a, in int b, in int i) {\n    return ((b-a)*100)/i+a;\n}\n//mod for integers\nint imod(in int i, in int m) {\n    return i-m*(i/m);\n}\n//3d->1d coord\nint w2i(in vec3 p) {\n    return int(p.x)+int(p.y)*int(VOLUME_SIZE.x)+int(p.z)*int(VOLUME_SIZE.x*VOLUME_SIZE.y);\n}\n//2d->1d coord\nint t2i(in vec2 uv) {\n    return int(uv.x*iResolution.x)+int(uv.y*iResolution.y)*int(iResolution.x);    \n}\n//1d->2d coord\nvec2 i2t(in int id) {\n    return vec2(imod(id,int(iResolution.x)),\n                id/int(iResolution.x))/iResolution.xy;\n}\n//1d->3d coord\nvec3 i2w(in int id) {\n    return vec3( imod(id,int(VOLUME_SIZE.x)),\n                 imod(id/int(VOLUME_SIZE.x),int(VOLUME_SIZE.y)),\n                 id/(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)) );    \n}\n//3d->2d coord\nvec2 w2t(in vec3 p) {\n    int id = int(p.x)+int(p.y)*int(VOLUME_SIZE.x)+int(p.z)*int(VOLUME_SIZE.x*VOLUME_SIZE.y);\n    return vec2(fract(float(id)/iResolution.x), float(id/int(iResolution.x))/iResolution.y);\n}\n//2d->3d coord\nvec3 t2w(in vec2 uv) {\n    int id = int(uv.x*iResolution.x)+int(uv.y*iResolution.y)*int(iResolution.x);\n    return vec3( mod(float(id),float(VOLUME_SIZE.x)),\n                 mod(float(id/int(VOLUME_SIZE.x)),float(VOLUME_SIZE.y)),\n                 float(id/int(VOLUME_SIZE.x*VOLUME_SIZE.y)) );\n}\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\nvec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return mix(d, rand*sign(dot(d,rand)), amount);\n}\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\n//used for calculating absolute position on voxel\nfloat rayBox(in vec3 rp, in vec3 rd, in vec3 lb, in vec3 rt) {\n    vec3 df = 1./rd;\n    \n\tvec3 t_lb = (lb-rp)*df,\n         t_rt = (rt-rp)*df;\n\n\treturn max(max(min(t_lb.x, t_rt.x), min(t_lb.y, t_rt.y)), min(t_lb.z, t_rt.z));\n}\n\n\n\n//hue function used in voxel\nfloat hue(float a, float b, float c) {\n    float p = a, q = b, t = c;\n    if(t < 0.) t++;\n    if(t > 1.) t--;\n    if(t < 1./6.) return p + (q - p) * 6. * t;\n    if(t < 1./2.) return q;\n    if(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}\n\n//voxel color from id\nvec3 voxel(float id) {\n    float h = id/100.,\n          s = cos(id*2.385+cos(id))*.25+.75,\n          l = cos(id*1.34+cos(id))*.25+.5;\n    \n    vec3 c;\n    if(s == 0.) {\n        c = vec3(l);\n    } else {\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s,\n              p = 2. * l - q;\n        \n        c = vec3(hue(p,q,h+1./3.),\n                 hue(p,q,h),\n                 hue(p,q,h-1./3.));\n    }\n    \n    return c;\n}\n\n\n//background sample\nvec3 background(vec3 rd) {\n    const vec3 topBlue = vec3(155., 203., 202.)/355.,\n        \t   bottomBlue = vec3(.25),\n        \t   sun = vec3(254., 252., 2.)/255.,\n        \t   clouds = vec3(.12);\n    \n    vec2 ruv = vec2(.5+atan(abs(rd.z),rd.x)/(2.*pi),\n                    .5-asin(rd.y)/pi);\n    float cloudAmount = clamp((texture(iChannel3, 1.44+ruv*.5+0.2323).x-.64)*5., 0., 1.)*clamp(1.-abs(rd.y+.3)*2., 0., 1.),\n          sunAmount = dot(rd, normalize(vec3(0.,-1.,-1.)));\n    \n    vec3 sky = mix(mix(topBlue, bottomBlue, clamp((rd.y)*2., 0., 1.)),\n                   sun*100.,\n                   max(max(0.,sunAmount-.99)/.01, max(0., sunAmount)/140.));\n    \n    vec3 nSky = normalize(sky);\n    return mix(nSky,\n               clouds*(.5+texture(iChannel2,ruv*19.).x*.5), pow(max(cloudAmount-length(sky)/200., 0.),.45))*\n        mix( length(sky), 1., cloudAmount);\n    \n    \n    //float light = dot(normalize(vec3(3,-6,2)), d);\n   // return vec3(.43,.55,.94)+vec3(1.2,.75,.85)*(max(0.,light)*.25+max(0.,light-.99)/.01);\n}\n//0 = nothing, >0 = block id\nfloat scene(vec3 rp) {    \n    vec4 tex = texture(iChannel0, w2t(rp)+ftx);\n    \n    return tex.x;\n}\n\n\n//this function uses code from fb39ca4's shader 'Branchless Voxel Raycasting' https://www.shadertoy.com/view/4dX3zl\n//returns w=-1 if nothing was hit or if something was hit xyz=surface normal, w=voxel id\nivec4 trace(vec3 p, vec3 d) {\n    vec3 rp = floor(p),\n         dd = abs(1./d),\n         st = sign(d),\n         dst = (st*(rp-p)+(st*.5)+.5)*dd,\n         mask;\n        \n    for (int i = 0; i < 164; i++) {\n\n        bvec3 b1 = lessThan(dst, dst.yzx),\n              b2 = lessThanEqual(dst, dst.zxy);\n        mask = vec3(b1.x&&b2.x, b1.y&&b2.y, b1.z&&b2.z);\n\n\t\tdst += mask*dd;\n\t\trp += mask*st;\n        \n        if (rp.x<0.||rp.x>=VOLUME_SIZE.x||\n            rp.y<0.||rp.y>=VOLUME_SIZE.y||\n            rp.z<0.||rp.z>=VOLUME_SIZE.z) return ivec4(-1.);\n        \n        float vx = scene(rp);\n        if (vx > .5) return ivec4(mask*st, w2i(rp) );\n    }\n    \n    return ivec4(-1.);\n}\n\n//diffuse only montecarlo path tracing\nvec3 render(in vec3 p, in vec3 d) {\n    vec3 c = vec3(1.),\n         rp = p,\n         rd = d;\n    \n    ivec4 tres;\n    \n    for (int i = 0; i < bounces+1; i++) {\n        tres = trace(rp,rd);\n        if (tres.w < 0) break;\n        \n        vec3 vp = i2w(tres.w);\n\n        rp += rd*(rayBox(rp,rd,vp,vp+1.)-.0001);\n        c *= voxel(scene(vp));\n        \n        float ifrm = float(iFrame);\n    \t#define rndifrm (fract(fract(ifrm*vec3(.014,.024,.034))*1024.+vec3(ifrm*.0004923)+rp)*2.-1.)*1024.2479\n        rd = randomHemiRay(-vec3(tres.xyz),rp+rndifrm,1.);\n    }\n\n    if (tres.w < 0) return c*background(rd);\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy,\n         uv = (R-fragCoord.xy*2.)/R.y;\n    \n    float rfrm = texture(iChannel0, i2t(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)*int(VOLUME_SIZE.z)+1)+ftx).z;\n    if (rfrm < 2.) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec4 camera = texture(iChannel0, i2t(int(VOLUME_SIZE.x)*int(VOLUME_SIZE.y)*int(VOLUME_SIZE.z))+ftx);\n    vec3 cameraLocation = camera.xyz;\n    vec2 cameraRotation = vec2(camera.w-floor(camera.w),\n                              floor(camera.w)/2048.)*pi*2.;\n\t\t\n    vec3 rp,rd;\n    rp = cameraLocation;\n    rd = normalize(vec3(uv,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n    fragColor = texture(iChannel1, fragCoord/R)+vec4(render(rp,rd),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}