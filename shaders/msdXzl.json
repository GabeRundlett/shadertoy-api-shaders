{
    "Shader": {
        "info": {
            "date": "1680287264",
            "description": "Basically a simplified version of my Blue Planet shader with different parameters: https://www.shadertoy.com/view/Ds3XRl",
            "flags": 0,
            "hasliked": 0,
            "id": "msdXzl",
            "likes": 18,
            "name": "Procedural Red Planet",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching",
                "fbm",
                "planet"
            ],
            "usePreview": 0,
            "username": "jsulpis",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "// Procedural Red Planet by Julien Sulpis (https://twitter.com/jsulpis)\n// https://www.shadertoy.com/view/msdXzl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Ray marching params\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n// Planet geometry\n#define PLANET_POSITION vec3(0, 1, 6)\n#define PLANET_RADIUS 2.\n#define NOISE_STRENGTH .2\n#define ROTATION_SPEED .1\n#define PLANET_ROTATION rotateY(iTime * ROTATION_SPEED)\n\n// Planet colors\n#define PLANET_COLOR vec3(0.6, 0.3, 0.23)\n#define ATMOSPHERE_COLOR vec3(0.9, 0.15, 0.05)\n\n// Lighting\n#define SUN_DIR normalize(vec3(0.0, 1.0, .0))\n#define SUN_COLOR vec3(1.0, 1.0, 0.9) * 3.\n#define AMBIENT_LIGHT vec3(.5)\n#define SPACE_COLOR vec3(0., 0., 0.002)\n#define SPACE_DUST vec3(0.1, 0., 0.2)\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float t = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, t);\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\n// https://github.com/yiwenl/glsl-fbm/blob/master/3d.glsl\nfloat noise(vec3 p) {\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = permute(b.xyxy);\n  vec4 k2 = permute(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = permute(c);\n  vec4 k4 = permute(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Comes from a course by SimonDev (https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A)\n// https://simondev.teachable.com/p/glsl-shaders-from-scratch\nfloat fbm(vec3 p, int octaves, float persistence, float lacunarity, float exponentiation) {\n  float amplitude = 0.5;\n  float frequency = 3.0;\n  float total = 0.0;\n  float normalization = 0.0;\n\n  for(int i = 0; i < octaves; ++i) {\n    float noiseValue = noise(p * frequency);\n    total += noiseValue * amplitude;\n    normalization += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  total /= normalization;\n  total = total * 0.8 + 0.1;\n  total = pow(total, exponentiation);\n\n  return total;\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\nvec3 nmzHash33(vec3 q) {\n  uvec3 p = uvec3(ivec3(q));\n  p = p * uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n  p = p.yzx * (p.zxy ^ (p >> 3U));\n  return vec3(p ^ (p >> 16U)) * (1.0 / vec3(0xffffffffU));\n}\n\n// https://www.shadertoy.com/view/XsyGWV\nvec3 stars(in vec3 p) {\n  vec3 c = vec3(0.);\n  float res = iResolution.x * 0.8;\n\n  for(float i = 0.; i < 5.; i++) {\n    vec3 q = fract(p * (.15 * res)) - 0.5;\n    vec3 id = floor(p * (.15 * res));\n    vec2 rn = nmzHash33(id).xy;\n    float c2 = 1. - smoothstep(0., .6, length(q));\n    c2 *= step(rn.x, .0005 + i * 0.002);\n    c += c2 * (mix(vec3(1.0, 0.49, 0.1), vec3(0.75, 0.9, 1.), rn.y) * 0.25 + 0.75);\n    p *= 1.4;\n  }\n  return c * c;\n}\n\n//================//\n//  Project code  //\n//================//\n\n/**\n* Standard SDF function for a sphere but with fbm noise added on the radius\n*/\nfloat planetSDF(vec3 p) {\n  vec3 position = (p - PLANET_POSITION) * PLANET_ROTATION + PLANET_POSITION;\n  float noise = fbm(position, 6, .6, 2., 5.) * NOISE_STRENGTH;\n\n  return length(position - PLANET_POSITION) - (PLANET_RADIUS + noise);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.;\n\n  for(int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = planetSDF(p);\n    dO += dS;\n    if(dO > MAX_DIST || dS < SURF_DIST)\n      break;\n  }\n  return dO;\n}\n\nvec3 getNormal(vec3 p) {\n  float dist = planetSDF(p);\n  vec2 e = vec2(.01, 0);\n  \n  vec3 normal = dist - vec3(\n    planetSDF(p - e.xyy), \n    planetSDF(p - e.yxy), \n    planetSDF(p + e.yyx)\n  );\n  return normalize(normal);\n}\n\nvec3 addLight(vec3 color, vec3 p) {\n  vec3 normal = getNormal(p);\n\n  // Diffuse\n  float exposition = pow(max(0.0, dot(SUN_DIR, normal)), 1.5); // The power softens the shadow. Not physically accurate but it looks better\n  vec3 diffuse = exposition * SUN_COLOR;\n\n  return color * (AMBIENT_LIGHT * 0.006 + diffuse);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y); \n  vec2 pixelCoords = (uv - 0.5) * iResolution.xy / iResolution.y;\n\n  vec3 ro = vec3(0, 1, 0);\n  vec3 rd = normalize(vec3(pixelCoords.x, pixelCoords.y, 1));\n\n  // space Background\n  mat3 backgroundRotation = rotateY(-iTime * ROTATION_SPEED / 4.);\n  vec3 backgroundCoord = rd * backgroundRotation;\n  float spaceNoise = fbm(backgroundCoord * 2.5, 4, .5, 2., 6.);\n  vec3 color = mix(SPACE_COLOR, SPACE_DUST, spaceNoise);\n\n  // planet geometry\n  float distance = rayMarch(ro, rd);\n  vec3 position = ro + rd * distance;\n  float spaceMask = step(MAX_DIST / 2., distance);\n  float planetMask = 1.0 - spaceMask;\n\n  // planet colors\n  vec3 planetColor = addLight(PLANET_COLOR, position);\n  color = mix(color, planetColor, planetMask);\n  \n  // atmosphere\n  float distCameraToSphere = length(PLANET_POSITION - ro);\n  vec3 coordFromCenter = (ro + rd * distCameraToSphere) - PLANET_POSITION;\n  float distFromEdge = abs(length(coordFromCenter.xy) - PLANET_RADIUS);\n  float planetEdge = max(1. - distFromEdge, 0.);\n  float atmosphereDensity = pow(remap(dot(SUN_DIR.xy, coordFromCenter.xy), -2., 1., 0., 1.), 5.);\n\n  vec3 atmosphere = pow(planetEdge, 50.) * ATMOSPHERE_COLOR * 2. * spaceMask;\n  atmosphere += pow(planetEdge, 30.) * ATMOSPHERE_COLOR * (1.5 - planetMask);\n  atmosphere += pow(planetEdge, 4.) * ATMOSPHERE_COLOR * .02;\n  atmosphere += pow(planetEdge, 2.) * ATMOSPHERE_COLOR * .1 * (planetMask);\n\n  color += atmosphere * atmosphereDensity;\n\n  // stars\n  color += stars(backgroundCoord) * spaceMask;\n\n  // gamma correction\n  color = pow(color, vec3(1.0 / 2.4));\n\n  // vignette\n  color *= 1. - pow(length((uv - 0.5) * iResolution.xy) / iResolution.x * 1.5, 3.);\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}