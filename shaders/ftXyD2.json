{
    "Shader": {
        "info": {
            "date": "1648678336",
            "description": "https://www.highperformancegraphics.org/2022/student-competition/\nUnoptimized path tracer for the High Performance Graphics student competition.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftXyD2",
            "likes": 14,
            "name": "HPG Student Competition 2022",
            "published": 3,
            "tags": [
                "pathtracing",
                "hpgconf"
            ],
            "usePreview": 1,
            "username": "hpg_conf",
            "viewed": 1865
        },
        "renderpass": [
            {
                "code": "// The following built-in quality knobs are available:\n//\n// (1) Uncomment the preprocessor definition FULL_SCENE to get the full scene.\n// (2) Set NUM_SAMPLES to increase the number of rays per pixel.\n// \n// We will judge your submitted shader as follows:\n// \n//  - Shader run time must not exceed 2x of our baseline shader \n//    with FULL_SCENE and NUM_SAMPLES==1\n//\n//  - Final image quality will be measured using FLIP against a reference \n//    with FULL_SCENE and NUM_SAMPLES==100000\n// \n// Note: Changing these definitions will increase shader compilation times.\n// \n// Windows users will need to configure their browser to use the native OpenGL backend.\n//\n// If you are using Chrome:\n//  - Go to chrome://flags and search for \"Angle\"\n//  - Change backend from \"Default\" to \"OpenGL\"\n//  - Restart your browser\n//\n//#define FULL_SCENE\n#define NUM_SAMPLES 1\n\n#define VERSION 2\n\n// Changelog:\n//\n// Update (2022-06-14): We have updated the quality evaluation metric to\n//                      FLIP (Andersson et al., HPG 2020) instead of SSIM\n//\n// Version 2:\n//   NEE computation: added epsilon for NdotL, commented in NdotL in BRDF term\n//   Thanks to Arthur Firmino for the bug report!\n\n\n// If you have developed your solution with the old code, and cannot update your\n// submission with reasonable effort, we will grade your solution against our version 1\n// renderer.\n\n#define INFINITY 9999999.0 // sorry, webgl doesn't allow to use proper float infinity :(\n#define PI 3.141592653589\n\n#ifdef FULL_SCENE\n#define NUM_BOUNCES 8\n#else\n#define NUM_BOUNCES 2\n#endif\n\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n};\n\nint seed;\nint flat_idx;\n\nconst float cube_light_size = 0.08;\nconst vec4 cube_light_pos[4] = vec4[4](\n\t\tvec4(  -0.9, -1.0 + cube_light_size * 0.495,  0.6, 0.4),\n\t\tvec4(  0.3, -1.0 + cube_light_size * 0.495,  0.2, 0.8),\n\t\tvec4(  1.0 - 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -1.0 + 5.0 * cube_light_size, 0.0),\n\t\tvec4(  -1.0 + 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -0.6, 0.0)\n\t\t);\n\nconst vec3 light_color[4] = vec3[4](\n\t\tvec3(5),\n\t\tvec3(5),\n\t\tvec3(80.0, 50, 30),\n\t\tvec3(30, 30, 80.0)\n\t\t);\n\n\n// H\nconst vec4 coordinates_H[3] = vec4[3](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.427, 0.000, 0.627, 0.750),\nvec4(0.116, 0.310, 0.516, 0.450));\n// P\nconst vec4 coordinates_P[4] = vec4[4](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.400, 0.360, 0.540, 0.675),\nvec4(0.044, 0.288, 0.471, 0.428),\nvec4(0.000, 0.610, 0.471, 0.750));\n// G\nconst vec4 coordinates_G[6] = vec4[6](\nvec4(0.000, 0.060, 0.200, 0.670),\nvec4(0.425, 0.060, 0.625, 0.265),\nvec4(0.425, 0.520, 0.625, 0.670),\nvec4(0.100, 0.000, 0.625, 0.140),\nvec4(0.315, 0.265, 0.625, 0.405),\nvec4(0.077, 0.610, 0.550, 0.750));\n// 2\nconst vec4 coordinates_2[5] = vec4[5](\nvec4(0.000, 0.000, 0.140, 0.365) * 0.5,\nvec4(0.474, 0.365, 0.614, 0.680) * 0.5,\nvec4(0.044, 0.000, 0.614, 0.140) * 0.5,\nvec4(0.044, 0.288, 0.544, 0.428) * 0.5,\nvec4(0.044, 0.610, 0.544, 0.750) * 0.5);\n\n// TNB, sorry!\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\n// adapted from https://cwyman.org/code/dxrTutors/tutors/Tutor14/tutorial14.md.html\nfloat\nggxNormalDistribution(float NdotH, float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = ((NdotH * a2 - NdotH) * NdotH + 1.0);\n\treturn a2 / (d * d * PI);\n}\n\nfloat\nschlickMaskingTerm(float NdotL, float NdotV, float roughness)\n{\n\t// Karis notes they use alpha / 2 (or roughness^2 / 2)\n\tfloat k = roughness*roughness / 2.0;\n\n\t// Compute G(v) and G(l).  These equations directly from Schlick 1994\n\t//     (Though note, Schlick's notation is cryptic and confusing.)\n\tfloat g_v = NdotV / (NdotV*(1.0 - k) + k);\n\tfloat g_l = NdotL / (NdotL*(1.0 - k) + k);\n\treturn g_v * g_l;\n}\n\nvec3\nschlickFresnel(vec3 f0, float lDotH)\n{\n\treturn f0 + (vec3(1.0, 1.0, 1.0) - f0) * pow(1.0 - lDotH, 5.0);\n}\n\n// When using this function to sample, the probability density is:\n//      pdf = D * NdotH / (4 * HdotV)\nvec3\ngetGGXMicrofacetTS(vec2 randVal, float roughness, vec3 hitNorm)\n{\n\t// GGX NDF sampling\n\tfloat a2 = roughness * roughness;\n\tfloat cosThetaH = sqrt(max(0.0, (1.0 - randVal.x) / ((a2 - 1.0) * randVal.x + 1.0)));\n\tfloat sinThetaH = sqrt(max(0.0, 1.0 - cosThetaH * cosThetaH));\n\tfloat phiH = randVal.y * PI * 2.0;\n\n\t// Get our GGX NDF sample (i.e., the half vector)\n\treturn vec3(sinThetaH * cos(phiH), cosThetaH, sinThetaH * sin(phiH));\n}\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nmat4\nlook_at(vec3 eye, vec3 center, vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\n\nvec3\nsample_light(vec3 rng, out vec3 normal, out float pdf, out vec3 Le)\n{\n\tint face_idx = int(rng.z * float(cube_light_pos.length()) * 6.0);\n\tint cube_idx = face_idx / 6;\n\tface_idx %= 6;\n\n\tLe = light_color[cube_idx];\n\n\tvec3 p, n;\n\tswitch(face_idx) {\n\tdefault:\n\tcase 0: p = vec3(rng.x, 0, rng.y); n = vec3( 0, -1,  0); break; \n\tcase 1: p = vec3(rng.x, 1, rng.y); n = vec3( 0,  1,  0); break; \n\tcase 2: p = vec3(rng.x, rng.y, 0); n = vec3( 0,  0, -1); break; \n\tcase 3: p = vec3(rng.x, rng.y, 1); n = vec3( 0,  0,  1); break; \n\tcase 4: p = vec3(0, rng.x, rng.y); n = vec3(-1,  0,  0); break; \n\tcase 5: p = vec3(1, rng.x, rng.y); n = vec3( 1,  0,  0); break; \n\t}\n\n\tp -= vec3(0.5);\n\tp = (rotate_y(cube_light_pos[cube_idx].w) * vec4(p, 1.0)).xyz;\n\tn = (rotate_y(cube_light_pos[cube_idx].w) * vec4(n, 0.0)).xyz;\n\tp *= cube_light_size;\n\n\tnormal = n;\n\n\tpdf = 1.0 / (float(cube_light_pos.length()) * 6.0 * cube_light_size * cube_light_size);\n\n\treturn p + cube_light_pos[cube_idx].xyz;\n}\n\nfloat\nget_light_pdf()\n{\n    return 1.0 / (float(cube_light_pos.length()) * 6.0 * cube_light_size * cube_light_size);\n}\n\n// convert pdf from area measure to solid angle\nfloat\npdf_a_to_w(float pdf, float dist2, float cos_theta)\n{\n    float abs_cos_theta = abs(cos_theta);\n    if(abs_cos_theta < 1e-8)\n        return 0.0;\n\n    return pdf * dist2 / abs_cos_theta;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(position_min, position_max), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\n\t\tvec3 center = (position_min + position_max) * 0.5;\n\n\t\tnormal = p - center;\n\n\t\tvec3 an = abs(normal) / (position_max - position_min);\n\n\t\tif(an.x > an.y && an.x > an.z) {\n\t\t\tnormal = vec3(normal.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t}\n\t\tif(an.y > an.x && an.y > an.z) {\n\t\t\tnormal = vec3(0, normal.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\tif(an.z > an.x && an.z > an.y) {\n\t\t\tnormal = vec3(0, 0, normal.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, inout vec3 p, inout vec3 normal, out MaterialSample ms)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n\n\tfor(int i = 0; i < coordinates_H.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.35);\n\t\tray_tmp.origin -= vec3(-0.9, -1, 0.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.75);\n\t\tray_tmp.origin -= vec3(-0.28, -1, 0.2);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.4);\n\t\tray_tmp.origin -= vec3(0.35, -1, -0.20);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n#ifdef FULL_SCENE\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_LEFT;\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_RIGHT;\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\t\t\t\tmaterial = MAT_FLOOR;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_CEILING;\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_BACK;\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch(material) {\n\tcase MAT_LEFT   : ms = MaterialSample(vec3(0.9, 0.1, 0.1), 0.5,  false); break;\n\tcase MAT_RIGHT  : ms = MaterialSample(vec3(0.1, 0.9, 0.1), 0.5,  false); break;\n\tcase MAT_CEILING: ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n\tcase MAT_FLOOR  : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.12, false); break;\n\tcase MAT_BACK   : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n\tcase MAT_H      : ms = MaterialSample(vec3(1.0, 0.0, 0.0), 0.10, false); break;\n\tcase MAT_P      : ms = MaterialSample(vec3(0.0, 0.7, 0.7), 0.10, false); break;\n\tcase MAT_G      : ms = MaterialSample(vec3(0.1, 0.1, 0.7), 0.10, false); break;\n\tcase MAT_2      : ms = MaterialSample(vec3(0.8, 0.8, 0.8), 0.55, false); break;\n\tdefault         : ms = MaterialSample(light_color[material - MAT_LIGHT0], 0.0, true); break;\n\t}\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tMaterialSample ms;\n\tfloat t_shadow = intersect(r, p, n, ms);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tMaterialSample ms;\n\tfloat t = intersect(ray, position, normal, ms);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(ms.is_light) { /* hit light source */\n\t\treturn ms.color;\n\t}\n\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\tfloat NdotV = max(1e-4, dot(normal, -ray.dir));\n\n\t\t{ /* NEE */\n\t\t\tvec3 light_normal;\n\t\t\tfloat light_pdf;\n\t\t\tvec3 Le;\n\t\t\tvec3 pos_ls = sample_light(vec3(get_random(), get_random().x), light_normal, light_pdf, Le);\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee /= sqrt(rr_nee);\n\n\t\t\tvec3 H = normalize(-ray.dir + l_nee);\n\t\t\tfloat NdotH = max(0.0, dot(normal, H));\n\t\t\tfloat LdotH = max(0.0, dot(l_nee, H));\n\t\t\tfloat NdotL = max(1e-6, dot(normal, l_nee));\n\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);\n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness);\n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);\n\n\t\t\t{\n\t\t\t\tvec3 brdf = D * G * F / (4.0 * NdotV  * NdotL );\n                float brdf_pdf = D * NdotH / (4.0 * LdotH);\n                \n                float light_pdf_w = pdf_a_to_w(light_pdf, rr_nee, -dot(l_nee, light_normal));\n                float w = light_pdf / (light_pdf_w + brdf_pdf);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tcontrib += w * tp * (Le * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ /* brdf */\n\t\t\t// Randomly sample the NDF to get a microfacet in our BRDF \n\t\t\tvec3 H = onb * getGGXMicrofacetTS(get_random(), ms.roughness, normal);\n\n\t\t\t// Compute outgoing direction based on this (perfectly reflective) facet\n\t\t\tvec3 L = normalize(reflect(ray.dir, H));\n\n\t\t\t// Compute some dot products needed for shading\n\t\t\tfloat  NdotL = max(1e-6, dot(normal, L));\n\t\t\tfloat  NdotH = max(1e-6, dot(normal, H));\n\t\t\tfloat  LdotH = max(1e-6, dot(L, H));\n\n\t\t\t// Evaluate our BRDF using a microfacet BRDF model\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);          \n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness); \n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);                 \n\t\t\tvec3  brdf = D * G * F / (4.0 * NdotL * NdotV);        \n\n\t\t\t// What's the probability of sampling vector H from getGGXMicrofacet()?\n\t\t\tfloat brdf_pdf = D * NdotH / (4.0 * LdotH);\n\n\t\t\tray = Ray(position + L * 1e-5, L);\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tMaterialSample ms_next;\n\t\t\tfloat t = intersect(ray, position_next, normal_next, ms_next);\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            if(ms_next.is_light) {\n\t\t\t\tfloat light_pdf_a = get_light_pdf();\n\t\t\t\tfloat light_pdf_w = pdf_a_to_w(light_pdf_a, t * t, -dot(ray.dir, normal_next));\n\t\t\t\tfloat w = brdf_pdf / (brdf_pdf + light_pdf_w);\n\t\t\t\tcontrib += tp * (ms_next.color * w * brdf) / brdf_pdf;\n\t\t\t\tbreak;\n            }\n\n\t\t\ttp *= NdotL * brdf / brdf_pdf;\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\tms = ms_next;\n\t\t}\n\t}\n\n\treturn contrib;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tseed = iFrame * NUM_SAMPLES;\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\t//vec3 cam_center = vec3(0, 0, 3.0);\n\tvec3 cam_center = vec3(sin(iTime) * 0.25, sin(iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    float exposure = 2.0;\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n\t\tvec3 c = pt_mis(ray);\n\t\ts += c;\n\t}\n\n\tfragColor = vec4(pow(exposure * s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}