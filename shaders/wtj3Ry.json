{
    "Shader": {
        "info": {
            "date": "1560695410",
            "description": "It's [url]https://www.shadertoy.com/view/Md3yRB[/url] but in the hyperbolic plane! \nDrag the red generator point to change tiling. Press SPACE to toggle UI, C to center view. Press M or click outside circle to resume motion. ",
            "flags": 48,
            "hasliked": 0,
            "id": "wtj3Ry",
            "likes": 96,
            "name": "Hyperbolic Wythoff explorer",
            "published": 3,
            "tags": [
                "geometry",
                "tesselation",
                "hyperbolic",
                "wythoff",
                "pqr"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 2404
        },
        "renderpass": [
            {
                "code": "/* Hyperbolic Wythoff explorer, by mattz\n   License https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   Based on:\n\n     - \"Wythoff explorer\" \n       https://www.shadertoy.com/view/Md3yRB\n\n     - \"Fun with the Poincar√© disk\" \n       https://www.shadertoy.com/view/3tBGDD\n\n   These links were helpful when creating this shader:\n\n     - https://en.wikipedia.org/wiki/Wythoff_construction\n     - https://en.wikipedia.org/wiki/Wythoff_symbol\n\n*/\n\n///////////////////////////////////////////////////\n// global vars for drawing\n\nfloat textDist;\nvec2 textPos;\n\nfloat lineWidth;\nfloat inkDist;\nvec3 colorOut;\n\nivec3 drawCodes;\n\nconst vec3 colors[3] = vec3[3](PCOLOR, QCOLOR, RCOLOR);\n\n///////////////////////////////////////////////////\n// utility functions for drawing:\n\n// construct a line from 2 points\nvec3 line2D(vec2 a, vec2 b) {\n    vec2 n = perp(b - a);\n    return vec3(n, -dot(n, a));\n}\n\n// 2D distance to line\nfloat lineDist2D(vec3 l, vec2 p) {\n    float s = length(l.xy);\n    return (dot(l.xy, p) + l.z)/s;\n}\n\n// 2D distance to line\nfloat lineDist2D(vec2 a, vec2 b, vec2 p) {\n    return lineDist2D(line2D(a, b), p);\n}\n\n// 2D distances to line and line segment\nvec2 lineSegDist2D(vec2 a, vec2 b, vec2 p) {\n\n    p -= a;\n    b -= a;\n    \n    vec2 n = normalize(perp(b));\n    \n    float u = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    \n    return vec2(dot(b, n) - dot(p, n), length(p-u*b));\n    \n}\n\n// mix src into dst by smoothstepping k with threshold d\nvoid ink(vec3 src) {\n    colorOut = mix(src, colorOut, smoothstep(0.0, 1.0, inkDist));\n    inkDist = 1e5;\n}\n\n// draw either line or circle (using geodesicDist above)\nvoid drawLine(in vec3 l, in vec3 p) {\n    inkDist = min(inkDist, (abs(geodesicDist(l, p.xy))-lineWidth)/p.z);\n}\n\n// draw a 2D point\nvoid drawPoint(in vec2 x, in vec3 p) {\n\tinkDist = min(inkDist, (length(x-p.xy)-pointSize)/p.z);\n}\n\n// draw an open dot\nvoid drawDot(in vec2 x, in vec3 p) {\n    float d = (length(x-p.xy)-pointSize)/p.z;\n    colorOut = mix(colorOut, WHITE, smoothstep(1.0, 0.0, d));\n\tinkDist = min(inkDist, abs(d)-0.5);\n}\n\n// draw a geodesic segment between two points\nvoid drawSeg(vec2 p, vec2 q, vec3 cpq, vec3 uv) {\n    \n    float d = abs(geodesicDist(cpq, uv.xy))-lineWidth;\n    \n    vec2 diff = normalize(q - p);\n    \n    d = max(d, dot(p - uv.xy, diff)-lineWidth);\n    d = max(d, dot(uv.xy - q, diff)-lineWidth);\n    d = max(d, length(uv.xy)-1.);\n    \n    inkDist = min(inkDist, d/uv.z);\n\n}\n\n// distance to character in SDF font texture\nfloat fontDist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n      \n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv)-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n// distance to triangle for spin box\nfloat spinIconDist(vec2 pos, float size, bool flip, bool dim) {\n    \n    if (flip) { pos.y = -pos.y; }  \n    pos.x = abs(pos.x);\n    \n    vec2 p0 = vec2(0, -0.7)*textSize;\n    vec2 p1 = vec2(0.35, -0.7)*textSize;\n    vec2 p2 = vec2(0.0, -1.1)*textSize;\n    \n    float d = max(lineDist2D(p0, p1, pos), \n                  lineDist2D(p1, p2, pos));\n    \n    if (dim) { \n        d = abs(d + 0.02*textSize) - 0.02*textSize;\n    }\n    \n    return d;\n       \n}\n\n// draw color icon (RGB or facet-shaded selectors)\nvoid drawColorIcon(vec2 p, float sz, int i, bool enable, inout vec3 color) {\n    \n    const float k = 0.8660254037844387;\n    \n    mat2 R = mat2(-0.5, k, -k, -0.5);\n    \n    vec2 p1 = vec2(k*sz, 0);\n    vec2 p2 = vec2(0, 0.5*sz);\n    \n    mat3 colors;\n    \n    if (i == 0) {\n        colors = mat3(vec3(1, 0, 0),\n                      vec3(1, 1, 0),\n                      vec3(0, 0, 1));\n    } else {\n        colors = mat3(vec3(0.6, 0, 0.6),\n                      vec3(0.7, 0.4, 0.7),\n                      vec3(0.1, 0.5, 0.5));\n    }\n    \n    float ue = enable ? 1. : 0.3;\n    float ds = 1e5;\n    \n    for (int j=0; j<3; ++j) {\n        \n        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));\n        \n        vec2 dls = lineSegDist2D(p2, p1, ap);\n        \n        p = R*p;\n        \n        color = mix(color, colors[j], smoothstep(1.0, 0.0, -dls.x+0.5) * ue);\n        ds = min(ds, dls.y);\n    \n    }\n\n    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);\n    \n}\n\n// distance to decor icon\nfloat decorIconDist(vec2 p, float sz, int style) {\n    \n    float s = sign(p.x*p.y);\n    \n    p = abs(p);\n    \n    vec2 a = vec2(0, sz);\n    vec2 b = vec2(sz, 0);\n    \n    float l = lineDist2D(a, b, p);\n    float c = length( p - (p.x > p.y ? b : a)*0.8 );\n    \n    if (style == 0) {\n        return c - 0.2*sz;\n    } else if (style == 1) {\n        return abs(l + 0.04*sz) - 0.08*sz;\n    } else if (style == 2) {\n        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;\n    } else {\n        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// hyperbolic tiling drawing functions\n\n// decide between two region colors\nvec3 decide2(vec3 uv, int i, int j) {\n    \n    int k = 3 - i - j;\n    \n    float d = geodesicDist(perps[k], uv.xy);\n    \n    vec3 fg, bg;\n    \n    if (d * geodesicDist(perps[k], verts[i]) >= 0.) {\n        fg = colors[i];\n        bg = colors[j];\n    } else {\n        fg = colors[j];\n        bg = colors[i];\n    }\n    \n    return mix(fg, bg, 0.5*smoothstep(0.5*uv.z, 0.0, abs(d)));\n    \n}\n\n// decide between three region colors when generator on edge\nvec3 decide3Edge(vec3 uv, int i, int j) {\n    \n    int k = 3 - i - j;\n    vec3 g = geodesicFromPoints(generator, verts[k]);\n    \n    if (geodesicDist(g, uv.xy) * geodesicDist(g, verts[j]) >= 0.) {\n        return decide2(uv, j, k);\n    } else {\n        return decide2(uv, i, k);\n    }\n    \n}\n\n\n// decide between three region colors\nvec3 decide3(vec3 uv) {\n\n    int perpCode = drawCodes.y;\n\n    if (perpCode == 3) {\n        return decide3Edge(uv, 0, 1);\n    } else if (perpCode == 5) {\n        return decide3Edge(uv, 0, 2);\n    } else if (perpCode == 6) {\n        return decide3Edge(uv, 1, 2);\n    } else {\n        \n        int j;\n        \n        if (geodesicDist(perps[0], uv.xy)*geodesicDist(perps[0], verts[1]) >= 0.) {\n            j = 1;\n        } else {\n            j = 2;\n        }\n        \n        vec3 g = geodesicFromPoints(verts[j], generator);\n        \n        if (geodesicDist(g, uv.xy)*geodesicDist(g, verts[0]) >= 0.) {\n            return decide2(uv, 0, j);\n        } else {\n            return decide2(uv, 1, 2);\n        }\n        \n    }\n    \n}\n\n// decide region color based on triangle setup\nvec3 getFaceColor(vec3 uv) {\n    \n    int regionCode = drawCodes.x;\n    \n    if (regionCode == 1) {\n        return colors[0];\n    } else if (regionCode == 2) {\n        return colors[1];\n    } else if (regionCode == 4) {\n        return colors[2];\n    } else if (regionCode == 3) {\n        return decide2(uv, 0, 1);\n    } else if (regionCode == 5) {\n        return decide2(uv, 0, 2);\n    } else if (regionCode == 6) { \n        return decide2(uv, 1, 2);\n    } else {\n        return decide3(uv);\n    }\n    \n}\n\n// 16 repeated involutions to flip a point into the fundamental domain\n// covers the entire visible circle\nvoid flipIntoFundamental(inout vec4 uvsf) {\n\t\n    for (int i=0; i<16; ++i) {\n        \n        vec2 diff = uvsf.xy - edges[0].xy;\n        float d0 = dot(diff, diff);\n                \n        if (d0 < edges[0].z) {\n                        \n            float k = edges[0].z / d0;\n            uvsf.xy = edges[0].xy + k*diff;\n            uvsf.z *= k;\n            uvsf.w = -uvsf.w;\n            \n        }\n        \n        float d1 = dot(uvsf.xy, edges[1].xy);\n        \n        if (d1 < 0.) {\n\n            uvsf.xy -= 2.*d1*edges[1].xy;\n            uvsf.w = -uvsf.w;            \n \n        }\n        \n        float d2 = dot(uvsf.xy, edges[2].xy);\n\n        if (d2 < 0.) {\n            \n            uvsf.xy -= 2.*d2*edges[2].xy;\n            uvsf.w = -uvsf.w;   \n                        \n        }        \n\n    }\n    \n}\n\n// for shading alternate triangles and coloring triangle edges\nvec2 getEdgeDistAndShading(vec4 uvsf) {\n    \n    float d = abs(geodesicDist(edges[2], uvsf.xy));\n    d = min(d, abs(geodesicDist(edges[1], uvsf.xy)));\n    d = min(d, abs(geodesicDist(edges[0], uvsf.xy)));\n    \n    return vec2(d, mix(uvsf.w < 0. ? 0.8 : 1.0, 0.9, smoothstep(0.5*uvsf.z, 0.0, d)));\n\n}\n\n// hue from color in [0, 1]\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// convert triplet of bools to bitmask\nint intFromBool3(bool v[3]) {\n    return ((v[0] ? 1 : 0) | (v[1] ? 2 : 0) | (v[2] ? 4 : 0));\n}\n\n// compute some globals to help with triangle drawing\nvoid setupTriangleDrawing(vec3 gbary) {\n    \n    if (gbary.z >= 0.) {\n        generator = verts[int(gbary.z)];  \n    } else {\n        generator = diskFromBary(gbary.xy);\n    }\n    \n    bool regionValid[3] = bool[3](true, true, true);\n    bool perpValid[3];\n    bool perpDrawable[3];\n    \n    for (int i=0; i<3; ++i) {\n        \n        perps[i] = geodesicPerpThruPoint(edges[i], generator.xy);\n        perpValid[i] = abs(geodesicDist(edges[i], generator.xy)) > TOL;\n        perpDrawable[i] = perpValid[i];\n        \n        int j = (i + 1) % 3;\n        int k = (i + 2) % 3;\n                \n        if (abs(geodesicDist(perps[i], verts[j])) < TOL) { \n            regionValid[j] = false; \n            perpValid[i] = false;\n        }\n        \n        if (abs(geodesicDist(perps[i], verts[k])) < TOL) { \n            regionValid[k] = false;\n            perpValid[i] = false;\n        }\n        \n    }\n    \n    drawCodes = ivec3(intFromBool3(regionValid),\n                      intFromBool3(perpValid),\n                      intFromBool3(perpDrawable));\n    \n    \n}\n\n// draw the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // load variables from buffer A\n    vec4 pqrg = LOAD(PQR);\n    vec3 gbary = LOAD(GENERATOR).xyz;\n    int style = int(LOAD(STYLE).x);\n    vec2 m = LOAD(SCROLL).yx; // note flip along y=x line\n\n    // set up options from loaded things\n    pqr = pqrg.xyz;\n    \n    bool gui = (pqrg.w != 0.);\n    bool colorByRegion = bool(style & STYLE_COLOR_BY_REGION);\n    bool shadeTriangles = bool(style & STYLE_SHADE_TRIANGLES);\n    bool drawPolygonEdges = bool(style & STYLE_DRAW_POLYGONS);\n    bool drawTriangleEdges = bool(style & STYLE_DRAW_TRIANGLES);\n    bool drawGenerator = bool(style & STYLE_DRAW_GENERATOR);\n    \n    // set up coordinate transforms\n    setupScene(iResolution.xy);\n    \n    // note flip along y=x line\n    vec4 uvsf = vec4(sceneFromFrag(fragCoord).yxz, -1.);\n         \n    // set up drawing globals\n    colorOut = WHITE;\n\n    textDist = 1e5;\n    inkDist = 1e5;\n            \n    // don't do triangle setup math if not needed\n    bool insideUnit = dot(uvsf.xy, uvsf.xy) < 1.;\n    bool insideInset = boxDist(fragCoord, insetBox) <= 0.;\n\n    if (insideUnit || (insideInset && gui)) {\n        setupTriangle(pqr);\n        setupTriangleDrawing(gbary);\n    }\n\n\t// draw unit circle\n    const vec3 unitCircle = vec3(0., 0., 1.);\n    lineWidth = 0.005;\n    drawLine(unitCircle, uvsf.xyz);\n    \n    // are we in the poincare disk?\n    if (insideUnit) {\n            \n        // apply scrolling transform\n        uvsf.xyz = hyperTranslate(uvsf.xyz, m);\n\n        // stash where we were for coloring, before we flip into fundamental domain\n        vec3 shadeUV = uvsf.xyz;\n        \n        // flip into fundamental domain\n        flipIntoFundamental(uvsf);\n        \n        // get edge distance and shading fraction\n        vec2 es = getEdgeDistAndShading(uvsf);\n        \n        // choose background color\n        if (colorByRegion) {\n            \n            colorOut = getFaceColor(uvsf.xyz);\n            \n        } else {\n            \n            vec3 rgb = hue(0.5*atan(shadeUV.x, shadeUV.y)/PI);\n            colorOut = mix(rgb, WHITE, 1.-dot(shadeUV.xy, shadeUV.xy));\n            \n        }\n\n        // shade triangles if needed\n        if (shadeTriangles) { colorOut *= es.y; }\n        \n        // draw polygon edges if needed\n        if (drawPolygonEdges) {\n            lineWidth = 0.01;\n            for (int i=0; i<3; ++i) {\n                if (bool(drawCodes.z & (1 << i))) {\n                    vec2 pinter = intersectGG(perps[i], edges[i]).xy;\n                    drawSeg(generator.xy, pinter, perps[i], uvsf.xyz);\n                }\n            }\n        }\n        \n        // draw generator point if needed\n        if (drawGenerator) { drawPoint(generator.xy, uvsf.xyz); }\n        \n        // draw triangle edges if needed\n        if (drawTriangleEdges) {\n            lineWidth = 0.005;\n            inkDist = min(inkDist, (es.x-lineWidth)/uvsf.z);\n        }\n        \n    } // done drawing inside circle\n    \n    // ink the lines that were drawn\n    ink(BLACK);\n\n    if (gui) {\n\n        // inset triangle\n        if (insideInset) {\n\n            vec3 ipos = insetFromFrag(fragCoord);\n\n            // shade triangle\n            colorOut = mix(colorOut, LIGHTGRAY, step(insetTriDist(ipos), 0.));\n\n            // draw triangle outline\n            lineWidth = 0.5*ipos.z;\n\n            for (int i=0; i<3; ++i) {\n\n                int j = (i+1)%3;\n                int k = 3-i-j;\n                vec3 edge = geodesicFromPoints(insetVerts[j], insetVerts[k]);\n\n                drawSeg(insetVerts[j], insetVerts[k], edge, ipos.xyz);\n\n            }\n\n            // ink the lines\n            ink(BLACK);\n\n            // draw all 7 vertices\n            pointSize = max(4.0*ipos.z, 0.06*insetBox.z*insetOffsetPx.z);\n\n            for (int i=0; i<7; ++i) {\n                drawDot(insetVerts[i], ipos.xyz);\n            }\n\n            // ink outlines\n            ink(BLACK);\n            \n            // draw generator in red\n            vec2 insetGenerator = insetFromOrig(vec3(generator,0)).xy;\n\n            pointSize -= ipos.z;\n            drawPoint(insetGenerator, ipos.xyz);\n            ink(vec3(0.7, 0, 0));    \n\n        } // done drawing inset\n\n\n        float dBlack = 1e5;\n        float dGray = 1e5;\n\n        // text and spin icons\n        for (int i=0; i<3; ++i) {\n\n            textPos = fragCoord.xy - digitUIBox(i).xy;\n            dBlack = min(dBlack, fontDist(textPos, textSize, vec2(pqr[i], 12.0)));\n\n            dGray = min(dGray, spinIconDist(textPos, textSize, true, pqr[i] == MAX_PQR));\n            dGray = min(dGray, spinIconDist(textPos, textSize, false, pqr[i] == MIN_PQR));\n\n        }\n\n\n        // top row of clickable icons\n        for (int i=0; i<4; ++i) {\n\n            vec2 p = iconUIBox(ivec2(i, 0)).xy;\n            float idist = decorIconDist(fragCoord - p, iconSize, i);\n\n            if (bool(style & (1 << i))) {\n                dBlack = min(dBlack, idist);\n            } else {\n                dGray = min(dGray, idist);\n            }\n\n        }\n\n        // bottom row of clickable icons\n        for (int i=0; i<2; ++i) {\n            bool enable = (colorByRegion && i == 0) || (!colorByRegion && i == 1); \n            vec2 pos = iconUIBox(ivec2(i+1, 1)).xy;\n            drawColorIcon(fragCoord - pos, iconSize, i, enable, colorOut);\n        }\n\n        // draw the things\n        colorOut = mix(GRAY, colorOut, smoothstep(0.0, 1.0, dGray));\n        colorOut = mix(BLACK, colorOut, smoothstep(0.0, 1.0, dBlack));\n        \n    }\n\n    // gamma correction & display\n    colorOut = sqrt(colorOut);\n    fragColor = vec4(colorOut, 1);\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define DEMO_MODE 1\n\n#define PQR ivec2(0,0)\n#define MOUSE ivec2(0,1)\n#define GENERATOR ivec2(0,2)\n#define STYLE ivec2(0,3)\n#define SCROLL ivec2(0,4)\n#define TIME ivec2(0,5)\n\n#define STYLE_DRAW_GENERATOR  1\n#define STYLE_DRAW_POLYGONS   2\n#define STYLE_DRAW_TRIANGLES  4\n#define STYLE_SHADE_TRIANGLES 8\n#define STYLE_COLOR_BY_REGION 16\n\n#define LOADC(c, var) texelFetch(c, var, 0)\n#define LOAD(var) texelFetch(iChannel0, var, 0)\n\n#define PCOLOR vec3(1, 0, 0)\n#define QCOLOR vec3(1, 1, 0)\n#define RCOLOR vec3(0, 0, 1)\n\n#define BLACK vec3(0)\n#define GRAY vec3(.5)\n#define LIGHTGRAY vec3(.8)\n#define WHITE vec3(1)\n\n\n#define PI 3.141592653589793\n\n#define MIN_PQR 2.\n#define MAX_PQR 9.\n\nconst vec4 NO_INTERSECT = vec4(-1e5);\n\nconst float TOL = 1e-3;\nconst float TOL_SQR = TOL*TOL;\n\nconst float SNAP_TOL = 12.0;\n\n//////////////////////////////////////////////////\n// drawing globals\n\nvec2 theResolution; \n\nfloat px;\nfloat perpSize;\n\nfloat textSize;\nfloat pointSize;\nfloat insetSize;\nfloat iconSize;\n\nvec2 sceneCenter;\nvec4 insetBox;\nvec2 textCenter;\nvec2 iconCenter;\n\n//////////////////////////////////////////////////\n// triangle globals\n\nvec3 pqr;     \nvec2 verts[7];  // 0,1,2 are triangle vertices near origin; 3,4,5,6 are special points\n\nvec3 edges[3];\nvec2 generator;\n\nvec3 perps[3];\n\nmat2 insetR; \nvec3 insetOffsetPx;\n\nvec2 insetVerts[7];\n\n//////////////////////////////////////////////////\n// setup transforms and sizes\n\nvoid setupScene(vec2 res) {\n        \n    const float diam = 2.0;\n        \n    theResolution = res;\n\n    float rmax = max(res.x, res.y);\n    float rmin = min(res.x, res.y);\n\n    float csize = (rmin * 0.98);\n    \n    insetSize = 0.5*(rmax - csize);\n\n    if (res.x > res.y) {\n        insetBox = vec4(0.5*insetSize);\n        textCenter = vec2(0.5*insetSize, 0.5*res.y);\n    } else {\n        insetBox = vec4(res-vec2(0.5*insetSize), vec2(0.5*insetSize));\n        textCenter = vec2(0.5*res.x, res.y-0.5*insetSize);\n    }\n\n    iconCenter = vec2(0.5*insetSize, res.y-0.5*insetSize);\n    \n    textSize = insetSize * 0.2;\n        \n    px = diam / csize;\n    pointSize = max(0.025, 4.0 * px);\n    perpSize = textSize * px;\n    \n    iconSize = insetSize * 0.08;\n\n}\n\n// scene coords + pixel size from fragment\nvec3 sceneFromFrag(vec2 frag) {\n    return vec3((frag.xy - 0.5*theResolution) * px, px);\n}\n\n// distance to 2D box given by (ctr, radius)\nfloat boxDist(vec2 p, vec4 b) {\n    \n    p = abs(p - b.xy) - b.zw;\n    return max(p.x, p.y);\n    \n}\n\n// box for icon in grid\nvec4 iconUIBox(ivec2 idx) {\n    \n    vec2 iconCtr = iconCenter;\n    \n    iconCtr = floor(iconCtr+0.5);\n    \n    vec2 scl = vec2(2.5*iconSize, 3.*iconSize);\n    iconCtr += vec2(float(idx.x), float(-idx.y))*scl + vec2(-1.5, 0.5)*scl; \n    \n    return vec4(iconCtr, vec2(iconSize));\n    \n}\n\n// box for digit in triplet\nvec4 digitUIBox(int idx) {\n    \n    const vec2 digitRad = vec2(0.35, 0.5);\n    \n    return vec4(textCenter.x + (float(idx - 1))*textSize,\n                textCenter.y,\n                digitRad*textSize);\n\n}\n\n// box for triangle above digit\nvec4 triUIBox(int idx, float delta) {\n    \n    return vec4(digitUIBox(idx).xy + vec2(0, 0.9*delta*textSize), \n                0.4*textSize, 0.3*textSize);\n    \n}\n\n//////////////////////////////////////////////////\n// geometric utility functions\n\n// are two points on the same diameter of the unit circle?\nbool alongDiameter(vec2 p, vec2 q) {\n   \n    vec4 pq = abs(vec4(p, q));\n    float m = max(max(pq.x, pq.y), max(pq.z, pq.w));\n    \n    float k = abs(p.x*q.y - p.y*q.x);\n    \n    return k < TOL*m;\n    \n}\n\n// are two points the same length?\nbool sameLength(float pp, float qq) {\n    return abs(pp - qq) < TOL*max(pp, qq);\n}\n\n// rotate by 90 degrees\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// circle centered at center containing point p\nvec3 compass2D(vec2 ctr, vec2 p) {\n    vec2 diff = p - ctr;\n    return vec3(ctr, dot(diff, diff));\n}\n\n// Construction 1.2: invert a point through a circle\nvec2 invertPC(vec2 p, vec3 c) {\n    vec2 po = p - c.xy;    \n    return c.xy + po * c.z / dot(po, po);\n}\n\n//////////////////////////////////////////////////\n// hyperbolic geometry functions\n\n// distance from a point to a line or circle\nfloat geodesicDist(vec3 l, vec2 p) {\n\tif (l.z > 0.0) {\n\t\treturn length(p-l.xy) - sqrt(l.z);\n\t} else {\n\t\treturn dot(normalize(l.xy), p);\n\t}\n}\n\n// return the point of the pair with the smaller norm\nvec3 smaller(vec4 ab) {\n    return vec3(dot(ab.xy, ab.xy) < dot(ab.zw, ab.zw) ? ab.xy : ab.zw,\n                ab == NO_INTERSECT ? 0 : 1);\n}\n\n// intersection of a circle with a line thru the origin perpendicular\n// to normal n (must be a unit vector)\nvec4 intersectCL(vec3 c, vec2 n) {\n\n    float d = dot(n, c.xy);\n    vec2 p = c.xy - d * n;\n    \n    float d2 = d*d;\n    \n    if (d2 >= c.z) {\n        return NO_INTERSECT;\n    }\n    \n    vec2 t = perp(n);\n    \n    float a = sqrt(c.z - d2);\n    \n    return vec4(p + a*t, p - a*t);\n    \n}\n\n// intersection of two circles\nvec4 intersectCC(vec3 c1, vec3 c2) {\n    \n    vec2 diff = c2.xy - c1.xy;\n    \n    float d2 = dot(diff, diff);\n    float d2inv = 1.0/d2;\n\n    vec2 n = perp(diff);\n\n    float ad = 0.5*(c1.z - c2.z + d2);\n\n    float a2 = ad*ad*d2inv;\n    \n    if (c1.z < a2) {\n        return NO_INTERSECT;\n    }\n\n    float h = sqrt((c1.z - a2)*d2inv);\n\n    vec2 mid = c1.xy + (ad*d2inv)*diff;\n    \n    return vec4(mid + h*n, mid - h*n);\n    \n}\n\n// intersection of two geodesics\nvec3 intersectGG(vec3 c1, vec3 c2) {\n    if (c1.z == 0.) {\n        if (c2.z == 0.) {\n            return vec3(0, 0, 1);\n        } else {\n            return smaller(intersectCL(c2, c1.xy));\n        }\n    } else if (c2.z == 0.) {\n        return smaller(intersectCL(c1, c2.xy));\n    } else {\n        return smaller(intersectCC(c1, c2));\n    }\n}\n\n\n// special case of Construction 1.6 for unit circle\nvec3 geodesicFromPole(vec2 p) {\n    float h2 = dot(p, p);\n    float r2 = (h2 - 1.);\n    return vec3(p, r2);\n}\n\n// Polar of a point p about the unit circle\n// 2D line passing thru the midpoint of p and its inverse, perp. to p.\nvec3 polarFromPoint(vec2 p) {\n    return vec3(p, -0.5*dot(p, p) - 0.5);\n}\n\n// invert point about geodesic (either arc or line)\nvec2 reflectPG(vec2 p, vec3 c) {\n    if (c.z == 0.) {\n        return p - (2.*dot(p, c.xy))*c.xy;\n    } else {\n        return invertPC(p, c);\n    }\n}\n\n// Construction 2.2: geodesic from polars of points\nvec3 geodesicFromPoints(vec2 p, vec2 q) {\n    \n    if (alongDiameter(p, q)) {\n        vec2 n = normalize(perp(p - q));\n        return vec3(n, 0);\n    }\n\n    vec3 ppolar = polarFromPoint(p);\n    vec3 qpolar = polarFromPoint(q);\n    vec3 inter = cross(ppolar, qpolar);\n\n    return compass2D(inter.xy/inter.z, p);\n    \n}\n\n// Construction 3.4: geodesic from point & direction\nvec3 geodesicFromPointDir(vec2 p, vec2 d) {\n    \n    if (alongDiameter(p, d)) {\n        return vec3(normalize(perp(d)), 0);\n    } \n        \n    vec3 ppolar = polarFromPoint(p);\n    vec3 l = vec3(d, -dot(d, p));\n    \n    vec3 pinter = cross(ppolar, l);\n    \n    return geodesicFromPole(pinter.xy/pinter.z);\n    \n}   \n\n// return the geodesic passing through p that is perpendicular to g\nvec3 geodesicPerpThruPoint(vec3 g, vec2 p) {\n\n    if (abs(geodesicDist(g, p)) > TOL) {\n        return geodesicFromPoints(p, reflectPG(p, g));\n    } else if (g.z > 0.) {\n        return geodesicFromPointDir(p, p - g.xy);\n    } else {\n        return geodesicFromPointDir(p, g.xy);\n    }\n    \n}\n\n\n// Construction 3.1: Perpendicular bisector\nvec3 hyperbolicBisector(vec2 p, vec2 q) {\n\n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) { \n        \n        // p is at origin\n        float h2 = 1.0/qq;\n        return vec3(q*h2, (h2 - 1.));\n       \n    } else if (qq < TOL_SQR) { \n        \n        // q is at origin                \n        float h2 = 1.0/pp;\n        return vec3(p*h2, (h2 - 1.));\n        \n    } else if (sameLength(pp, qq)) {\n        \n        // p and q are same length, return the diameter\n        return vec3(normalize(p - q), 0);\n        \n    }\n    \n    // this remarkably small piece of code reflects the following algebra:\n    //\n    // let d = q - p be the difference between p & q\n    // let x be the pole of the bisector\n    //\n    // since the pole of the bisector is on the line from p to q, we know\n    //\n    //   x = p + k*d\n    //\n    // for some unknown k with abs(k) > 1 (because the pole isn't between p & q)\n    //\n    // now let's try to solve for k.\n    //\n    // we know that since the pole x is orthogonal to the unit circle, \n    // the radius of the bisector circle is governed by\n    //\n    //   r^2 = ||x||^2 - 1\n    //       = ||p + k*d ||^2 - 1\n    //       = p.p + 2k*p.d + k^2*d.d\n    //\n    // also since p and q are inverted through the bisector circle with radius\n    // r we know\n    //\n    //   r^2 = || x-p || * || x-q || = ||d|| * || k*d - d ||\n    //       = k*(k-1)*d.d \n    //\n    // now we can set the two equations equal and solve for k\n\n    vec2 d = q - p;\n    float k = (1.0 - dot(p,p))/(dot(d,d) + 2.0*dot(p,d));\n    \n    return geodesicFromPole( p + k*d );\n    \n}\n\n// hyperbolic translation to move the origin to point m\nvec3 hyperTranslate(vec3 uv, vec2 m) {\n\n    float mm = dot(m, m);\n    if (mm < TOL_SQR || mm >= 1.) { return uv; }\n\n    vec3 g1 = hyperbolicBisector(vec2(0), m);\n\n    vec2 diff = uv.xy - g1.xy;\n    float k = g1.z / dot(diff, diff);\n    uv.xy = g1.xy + k*diff; \n    uv.z *= k;\n\n    vec2 n = m / sqrt(mm);\n    uv.xy -= 2.*dot(uv.xy, n)*n;\n    \n    return uv;\n    \n}\n\n// is this a valid pqr for hyperbolic tiling (such that 1/p + 1/q + 1/r < 1)?\nbool isValidPQR(vec3 pqr) {\n    return (pqr.x*pqr.y + pqr.x*pqr.z + pqr.y*pqr.z) < pqr.x*pqr.y*pqr.z;   \n}\n\n// setup the fundamental triangle domain for tiling\nvoid setupTriangle(vec3 scenePQR) {\n\n    // setup triangle\n\n    pqr = scenePQR;\n    vec3 angles = PI/pqr;\n    \n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n\n    float cpqr = (c.x*c.y + c.z);\n    \n    float f2 = 1./(cpqr*cpqr - s.x*s.x*s.y*s.y);\n    float f = sqrt(f2);\n   \n    float d2 = s.x*s.x*f2;\n    \n    float k = (cpqr - s.x*s.y)*f;\n\n    float bsz = (c.x*c.z + c.y - s.x*s.z)*f;\n\n    edges[0] = vec3(f*cpqr, s.x*f*c.y, d2);    \n    edges[1] = vec3(s.x, -c.x, 0);\n    edges[2] = vec3(0, 1, 0);\n\n    verts[0] = vec2(0);\n    verts[1] = vec2(k, 0);\n    verts[2] = bsz*vec2(c.x, s.x);\n    \n    vec2 dA = normalize(perp(verts[1] - edges[0].xy));\n    vec2 dB = normalize(perp(edges[0].xy - verts[2]));\n\n    vec3 bisectors[3];\n\n    bisectors[0] = vec3(sin(0.5*angles.x), -cos(0.5*angles.x), 0);\n    bisectors[1] = geodesicFromPointDir(verts[1], dA + vec2(1, 0));\n    bisectors[2] = geodesicFromPointDir(verts[2], dB + vec2(c.x, s.x));\n    \n    verts[3] = intersectGG(bisectors[0], edges[0]).xy;\n    verts[4] = intersectGG(bisectors[1], edges[1]).xy;\n    verts[5] = intersectGG(bisectors[2], edges[2]).xy;\n    verts[6] = intersectGG(bisectors[0], bisectors[1]).xy;\n    \n    \n    //////////////////////////////////////////////////\n        \n    for (int i=0; i<7; ++i) {\n        insetVerts[i] = hyperTranslate(vec3(verts[i], 0), verts[6]).xy;\n    }\n    \n    float pqrMin = min(pqr.x, min(pqr.y, pqr.z));\n    \n    vec2 b;\n    \n    b = insetVerts[1] - insetVerts[0];\n    \n    b = normalize(b);\n\n    if (theResolution.x > theResolution.y) {\n        insetR = mat2(b.x, -b.y, b.y, b.x);\n    } else {\n        insetR = mat2(b.y, b.x, -b.x, b.y);\n    }\n    \n    vec2 p0 = vec2(1e5);\n    vec2 p1 = vec2(-1e5);\n    \n    for (int i=0; i<7; ++i) {\n        insetVerts[i] = insetR*insetVerts[i];\n        p0 = min(p0, insetVerts[i]);\n        p1 = max(p1, insetVerts[i]);\n    }\n        \n    vec2 psz = p1 - p0;\n    float insetBaseline = max(psz.x, psz.y);\n    \n    float insetMargin = max(20.0, 0.05*theResolution.y);\n    float baselinePx = max(0., insetSize - 2.*insetMargin);\n    \n    insetOffsetPx = vec3(0.5*(p1 + p0), insetBaseline/baselinePx);\n    \n}\n\n// convert from poincare disk coords to barycentric coords within\n// fundamental triangle\nvec2 baryFromDisk(vec2 p) {\n    \n    mat2 m = mat2(verts[1], verts[2]);\n    \n    return inverse(m)*p;\n    \n}\n\n// convert from barycentric coords to poincare disk coords,\n// clamping result to fundamental triangle\nvec2 diskFromBary(vec2 b) {\n        \n    mat2 m = mat2(verts[1], verts[2]);\n    vec2 p = m*b;\n    \n    vec2 diff = p - edges[0].xy;\n    \n    float d0 = dot(diff, diff);\n    float d1 = dot(p, edges[1].xy);\n    float d2 = dot(p, edges[2].xy);\n    \n    if (d0 > edges[0].z && d1 >= 0. && d2 >= 0.) {\n        return p;\n    }\n    \n    vec2 pc[3];\n\n    vec2 d21 = verts[2] - verts[1];\n    pc[0] = edges[0].xy + diff*sqrt(edges[0].z/d0);\n    \n    vec2 dp2 = p - verts[2];\n    vec2 dp1 = p - verts[1];\n    \n    if (dot(dp2, d21) > 0. || dot(dp2, perp(verts[2] - edges[0].xy)) < 0.) {\n        pc[0] = verts[2];\n    } else if (dot(dp1, d21) < 0. || dot(dp1, perp(verts[1] - edges[0].xy)) > 0.) {\n        pc[0] = verts[1];\n    }\n    \n    pc[1] = verts[1]*clamp(dot(p, verts[1])/dot(verts[1], verts[1]), 0., 1.);\n    pc[2] = verts[2]*clamp(dot(p, verts[2])/dot(verts[2], verts[2]), 0., 1.);\n    \n    vec2 pmin = p;\n    float dmin = 1e5;\n    \n    for (int i=0; i<3; ++i) {\n        diff = p - pc[i];\n        float d = dot(diff, diff);\n        if (d < dmin) { \n            dmin = d;\n            pmin = pc[i];\n        }\n    }\n    \n    return pmin;\n    \n}\n\n// convert between original pose (triangle at origin) and inset pose (translated, rotated)\nvec3 origFromInset(vec3 ipos) {\n\n    ipos.xy = ipos.xy * insetR;\n    return hyperTranslate(ipos, -verts[6]);\n\n}\n\n// inverse of above\nvec3 insetFromOrig(vec3 opos) {\n    \n    vec3 ipos = hyperTranslate(opos, verts[6]);\n    ipos.xy = insetR * ipos.xy;\n    \n    return ipos;\n    \n}\n\n// distance to inset triangle\nfloat insetTriDist(vec3 ipos) {\n    \n    vec3 opos = origFromInset(ipos);\n    \n    float d0 = -geodesicDist(edges[0], opos.xy);\n    float d1 = -geodesicDist(edges[1], opos.xy);\n    float d2 = -geodesicDist(edges[2], opos.xy);\n    \n    return max(d0, max(d1, d2)) / opos.z;\n    \n}\n\n// inset triangle coords from fragment coords\nvec3 insetFromFrag(vec2 fragCoord) {\n            \n    vec3 ipos = vec3(fragCoord - insetBox.xy, 1)*insetOffsetPx.z;\n    ipos.xy += insetOffsetPx.xy;\n\n    return ipos;\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 data;\nivec2 fc;\n\n#define STORE(oc, value) if(fc == (oc)) { data = (value); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    // set up coordinate conversions\n    setupScene(iResolution.xy);\n\n    // get integer frag coords and texel data from last frame\n    fc = ivec2(fragCoord);\n    \n    data = texelFetch(iChannel0, fc, 0);\n    \n    // load all the important variables\n    pqr = LOAD(PQR).xyz;\n    vec3 gbary = LOAD(GENERATOR).xyz;\n    vec4 mstate = LOAD(MOUSE);\n    float style = LOAD(STYLE).x;\n    vec4 scroll = LOAD(SCROLL);\n    vec4 time = LOAD(TIME);\n    \n    // update time (for pause detection)\n    time.x = time.y;\n    time.y = iTime;\n    \n    \n    // setup for initial frame\n    if (iFrame == 0) { \n\n#ifdef DEMO_MODE\n        pqr = vec3(6,4,3);\n        gbary = vec3(0, 0, 6);\n        style = 43.;\n#else\n        pqr = vec3(5,4,2); \n        gbary = vec3(0, 0, 6);\n        style = 26.;\n#endif\n        \n    } \n    \n    // see https://www.shadertoy.com/view/XdtyWB for explanation of this\n    bool paused = (time.x == iTime);\n    \n    \n#ifdef DEMO_MODE    \n    bool gui = false;\n#else\n    // space toggles GUI\n    bool gui = texelFetch(iChannel1, ivec2(32, 2), 0).x == 0.;\n#endif\n    \n    \n    // update motion if not paused\n    if (!paused && scroll.z == 0.) {\n            \n        scroll.w += iTimeDelta;\n        float t = scroll.w*PI/10.0;\n        float r = 0.5*smoothstep(0.0, 4.0, scroll.w);\n        scroll.xy = r*vec2(cos(t), sin(t));\n        \n    }\n    \n#ifdef DEMO_MODE\n    \n    float t = iTime*2.*PI/5.0;\n    float r = 0.4;\n    scroll.xy = r*vec2(cos(t), sin(t));\n    \n#endif\n\n    // is moue down?\n    bool mouseIsDown = min(iMouse.z, iMouse.w) > 0.; \n    \n    // are we clicking?\n    bool click = mouseIsDown && mstate.w == 0.;\n    \n    // update mouse state\n    if (mouseIsDown) {\n        mstate.w = 1.;\n    } else {\n        mstate = vec4(0); \n    }\n\n\t// handle clicking on triangles\n    if (gui && click && fc == PQR) {\n\n        for (int i=0; i<3; ++i) {\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            for (float delta=-1.; delta <= 1.; delta += 2.) {\n            \n                bool enabled = (delta < 0.) ? data[i] > MIN_PQR : data[i] < MAX_PQR;\n                if (!enabled) { continue; }\n\n                float d = boxDist(iMouse.xy, triUIBox(i, delta));       \n                if (d > 0.) { continue; }\n\n                pqr[i] += delta;\n                \n                for (int try=0; try<10; ++try) {\n                    if (isValidPQR(pqr)) { continue; }\n                    int m = pqr[j]*delta > pqr[k]*delta ? j : k;\n                    pqr[m] -= delta;\n                }\n                \n            }\n        }\n        \n        \n    }\n    \n    // handle mouse to move generator\n    if (gui && (fc == GENERATOR || fc == MOUSE)) {\n                \n        setupTriangle(pqr);\n\n        if (click && boxDist(iMouse.xy, insetBox) < SNAP_TOL) {\n            \n            vec3 ipos = insetFromFrag(iMouse.xy);\n\n            float dmin = 1e5; \n\n            int imin;\n            vec2 omin;\n\n            for (int i=0; i<7; ++i) {\n                vec2 o = (insetVerts[i] - ipos.xy) / ipos.z;\n                float d = length(o);\n                if (d < dmin) {\n                    dmin = d;\n                    imin = i;\n                    omin = o;\n                }\n            }\n\n            if (dmin < SNAP_TOL) {\n                gbary.xy = baryFromDisk(verts[imin]);\n                gbary.z = float(imin);\n                mstate.xy = omin;\n                mstate.z = 1.;\n            } else {\n                vec3 opos = origFromInset(ipos);\n                vec3 newbary = vec3(baryFromDisk(opos.xy), -1.);\n                vec3 newdisk = vec3(diskFromBary(newbary.xy), opos.z);\n                vec3 newipos = insetFromOrig(newdisk);\n                if (length(newipos.xy - ipos.xy)/ipos.z < SNAP_TOL) {\n                    gbary = newbary;\n                    mstate.z = 2.;\n                } \n            }\n                \n        } else {\n            \n            if (mstate.z == 1.) {\n                if (length(iMouse.xy - iMouse.zw) > 0.25*SNAP_TOL) {\n                    mstate.z = 2.;\n                }\n            } \n                \n            if (mstate.z == 2.) {\n                vec3 ipos = insetFromFrag(iMouse.xy + mstate.xy);\n                vec3 opos = origFromInset(ipos);\n                gbary = vec3(baryFromDisk(opos.xy), -1.);\n            }\n            \n        }\n        \n   \n    }\n    \n    // handle clicking to change display style\n    if (fc == STYLE && click && gui) {\n        \n        int istyle = int(style);\n        \n        for (int i=0; i<4; ++i) {\n            if (boxDist(iMouse.xy, iconUIBox(ivec2(i, 0))) <= 0.) {\n                istyle ^= (1 << i);\n            }\n        }\n        \n        for (int i=0; i<2; ++i) {\n            if (boxDist(iMouse.xy, iconUIBox(ivec2(i+1, 1))) <= 0.) {\n                if (i == 0) {\n                    istyle |= STYLE_COLOR_BY_REGION;\n                } else {\n                    istyle &= ~STYLE_COLOR_BY_REGION;\n                }\n            }\n        }\n\n        style = float(istyle);\n        \n    }\n    \n    // handle mouse to do motion\n    if (fc == SCROLL || fc == MOUSE) {\n        \n        vec3 uv = sceneFromFrag(iMouse.xy);\n        float l = length(uv);\n        bool insideCircle = l < 0.85;\n        \n        if (click) {\n            if (insideCircle) {\n                mstate.z = 3.;\n                scroll.xy = uv.xy;\n                scroll.z = 1.;\n            } else if (!gui || iMouse.x > insetSize) {\n                scroll.z = 0.;\n            }\n        } else if (mstate.z == 3.) {\n            if (l > 0.85) { uv.xy *= 0.85/l; }\n            scroll.xy = uv.xy;\n        } else if (texelFetch(iChannel1, ivec2(67, 1), 0).x == 1.) {\n            scroll.z = 1.;\n            scroll.xy = vec2(0.);\n        } else if (texelFetch(iChannel1, ivec2(77, 1), 0).x == 1.) {\n            scroll.z = 0.;\n        }\n        \n    }\n\n\t// store all of the things\n    STORE(PQR, vec4(pqr, gui ? 1. : 0.));\n    STORE(MOUSE, mstate);\n    STORE(GENERATOR, vec4(gbary, 0));\n    STORE(STYLE, vec4(style, 0, 0, 0));\n    STORE(SCROLL, scroll);\n    STORE(TIME, time);\n        \n    // stash result\n    fragColor = data;\n                \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}