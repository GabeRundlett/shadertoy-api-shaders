{
    "Shader": {
        "info": {
            "date": "1694483554",
            "description": "The triangles were made painstakingly by hand! It wasn't too hard placing the triangles and getting them to render, but placing the vertices in a standard order (e.g. GL_TRIANGLE_STRIP) sure was.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtGGWK",
            "likes": 9,
            "name": "Ray-Tracing Triangles",
            "published": 3,
            "tags": [
                "ray",
                "tracing",
                "traced",
                "tracer",
                "rt",
                "trace"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "#pragma debug(on)\n#pragma optimize(off)\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n#define exposure 2.0\n\n#define fov 1.0\n\nstruct intersection\n{\n    bool  hit; // Hit\n    int   id ; // Triangle ID\n    float t  ; // Intersection\n    vec3  n  ; // Normal\n    vec2  uv ; // UV\n};\n\n// triangle intersection from https://iquilezles.org/articles/intersectors (modified)\nintersection triIntersect(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, rd  );\n\n    float d = 1.0 / dot(rd, n);\n\n    float u = d * dot(-q, v2v0);\n    float v = d * dot( q, v1v0);\n    float t = d * dot(-n, rov0);\n\n    if(u < 0.0 || u > 1.0 || v < 0.0 || (u + v) > 1.0)\n    {\n        t = -1.0;\n    }\n\n    intersection output_data;\n\n    output_data.hit = t > 0.0     ;\n    output_data.t   = t           ;\n    output_data.n   = normalize(n);\n    output_data.uv  = vec2(u, v)  ;\n\n    return output_data;\n}\n\nbool AABB(vec3 ro, vec3 rd, vec3 b_min, vec3 b_max)\n{\n    vec3 t1 = (b_min - ro) / rd;\n    vec3 t2 = (b_max - ro) / rd;\n\n    vec3 Tmin = min(t1, t2);\n    vec3 Tmax = max(t1, t2);\n\n    float tMin = max(max(Tmin.x, Tmin.y), Tmin.z);\n    float tMax = min(min(Tmax.x, Tmax.y), Tmax.z);\n\n    return tMin <= tMax && tMin > 0.0;\n}\n\nintersection compareIntersection(intersection t, intersection t_)\n{\n    if(t_.hit)\n    {\n        if(t.hit)\n        {\n            intersection output_data;\n\n            output_data.hit = true;\n\n            if(t.t < t_.t)\n            {\n                /*\n                output_data.id = t.id;\n                output_data.t  = t.t ;\n                output_data.n  = t.n ;\n                output_data.uv = t.uv;\n                */\n                output_data = t;\n            }\n            else\n            {\n                /*\n                output_data.id = t_.id;\n                output_data.t  = t_.t ;\n                output_data.n  = t_.n ;\n                output_data.uv = t_.uv;\n                */\n                output_data = t_;\n            }\n\n            return output_data;\n        }\n\n        return t_;\n    }\n\n    return t;\n}\n\nintersection trace(vec3 ro, vec3 rd)\n{\n    const int num_tris = 4;\n\n    /*\n    // GL_TRIANGLE_STRIP\n    // https://en.wikipedia.org/wiki/Triangle_strip\n    // 72 bytes\n    const vec3[] vert = vec3[] (\n    vec3(-1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3(-1.0,  1.0, -1.0),\n    vec3( 1.0,  1.0, -1.0)\n    );\n    */\n\n    // 144 bytes\n    const vec3[] vert = vec3[] (\n    vec3(-1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3(-1.0, -1.0, -1.0),\n\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0, -1.0),\n\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3(-1.0,  1.0, -1.0),\n\n    vec3(-1.0,  1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0),\n    vec3( 1.0,  1.0, -1.0)\n    );\n\n    vec3 bound_min = vert[0];\n    vec3 bound_max = vert[0];\n\n    for(int i = 1; i < 3 * num_tris; i++)\n    {\n        bound_min = min(bound_min, vert[i]);\n        bound_max = max(bound_max, vert[i]);\n    }\n\n    intersection output_data;\n\n    output_data.hit = false    ;\n    output_data.id  = -1       ;\n    output_data.t   = -1.0     ;\n    output_data.n   = vec3(0.0);\n    output_data.uv  = vec2(0.0);\n\n    //st_assert(AABB(ro, rd, bound_min, bound_max), 0);\n\n    if( AABB(ro, rd, bound_min, bound_max) )\n    {\n        for(int i = 0; i < num_tris; i++)\n        {\n            int index = 3 * i;\n\n            intersection input_data = triIntersect(ro, rd, vert[index + 0], vert[index + 1], vert[index + 2]);\n\n            input_data.id = i;\n\n            output_data = compareIntersection(output_data, input_data);\n        }\n    }\n\n    return output_data;\n}\n\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x * c - vec.y * s, vec.x * s + vec.y * c);\n}\n\nfloat hash13(vec3 p3)\n{\n    p3 *= 0.1031;\n    p3  = fract(p3);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract( (p3.x + p3.y) * p3.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize( vec3(fov * uv, -1.0) );\n\n    ro = vec3(rotate(ro.xz, iTime), ro.y).xzy;\n    rd = vec3(rotate(rd.xz, iTime), rd.y).xzy;\n\n    intersection t = trace(ro, rd);\n\n    if(t.hit)\n    {\n        vec3 h = ro + rd * t.t;\n\n        vec3 a = vec3(1.0, 0.0, 1.0);\n\n        if(t.id == 0 || t.id == 1)\n        {\n            a = mod(floor(4.0*h.x) + (4.0 * h.z), 2.0) < 1.0 ? vec3(0.400, 0.400, 0.400) : vec3(0.800, 0.800, 0.800);\n        }\n        if(t.id == 2 || t.id == 3)\n        {\n            a = vec3(0.8);\n        }\n\n        vec3 l = vec3(0.0, 0.5, 0.0);\n\n        vec3 c = l - h;\n\n        vec3 d = normalize(c);\n\n        float f = 1.0 / max(dot(c, c), 0.001);\n\n        fragColor.rgb = a * dot(t.n, f * d);\n        //fragColor.rgb = vec3(t.uv, 0.0);\n    }\n    else\n    {\n        fragColor.rgb = vec3(0.0);\n    }\n\n    #ifdef exposure\n    fragColor.rgb = clamp(1.0 - exp(-max(fragColor.rgb, 0.0) * exposure), 0.0, 1.0);\n    #endif\n\n    fragColor.rgb += hash13( vec3(fragCoord, iFrame) ) / 64.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}