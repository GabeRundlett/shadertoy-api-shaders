{
    "Shader": {
        "info": {
            "date": "1632662027",
            "description": "procedural bubbles rising at irregular speed. Loopless ( appart 3 iterations for solving the inverse ).\nvelocity = x + cos(x+t)  ( = stop and go )\nYpos = integral(v).  procedural draw â†’ inverse it.",
            "flags": 0,
            "hasliked": 0,
            "id": "7stSz8",
            "likes": 26,
            "name": "bubbles ( loopless )",
            "published": 3,
            "tags": [
                "short",
                "loopless"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 552
        },
        "renderpass": [
            {
                "code": "//#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define hash(p)  fract(sin( (p)* vec2(12.9898, 78.233)) * 43758.5453)\n  \nfloat A = .6, t, d=0.;\n#define f(x)   ( d+x + A*cos(x+t) ) // function to inverse\n#define df(x)  ( 1.- A*sin(x+t) )   // first derivative\n#define ddf(x)    ( -A*cos(x+t) )   // second derivative\n\nfloat invF(float x) {    // --- iterative solving the inverse function https://www.shadertoy.com/view/sd3XRH\n    float y0 = x-d, D;\n    for (int i = 0; i < 3; i++ )\n#if 1                                  // using order1 Taylor series : slow conv if A > .6 \n        y0 += ( x-f(y0) ) / df(y0);    // Note that here, even 1 step of TS1 is enough\n#else                                  // using order2 Taylor series : fast convergence\n        D  = df(y0)*df(y0) -2.*ddf(y0)*(f(y0)-x),\n        y0 += ( -df(y0) + sqrt(D) ) / ddf(y0);\n#endif\n    return y0;\n}\n\n#define Sa(v) smoothstep( 1.5*min(fwidth(v),10./R.y), 0., abs(v) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y;\n // U /= 5. - U.y;   // perspective  ( comment for sky view )\n    t = iTime;\n    float i = floor(U.x);              // column id\n    vec2 H = hash(i);                  // attributes\n    t *= .5 + H.y;                     // random speed\n    U.y += 3.*H.x - t;                 // random offset + rise\n    \n // for (float k=-1.; k<1.; k++){      // if you want to avoid trimmed bubbles\n    float y0 = invF( U.y ),// +k ,     // get bubble y location\n           j = floor(y0),\n          v0 = df(j), x;\n    vec2  H0 =  hash(j+H.x);           // bubble attributes\n           x = U.x + .1*sin(10.*j-10.*t); // horizontal offset\n          y0 = U.y - f(j),\n       \n    O = Sa( length(vec2(fract(x)-.5,y0-.5*v0))-.2*H0.y ) * vec4(.5,1,1,0);\n // O +=                                               //  hue(H.x);\n}//}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}