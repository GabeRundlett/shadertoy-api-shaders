{
    "Shader": {
        "info": {
            "date": "1588976645",
            "description": "patching up of: \nhttps://www.shadertoy.com/view/4ttBD4\n\ngrandpoarent: \nhttps://www.shadertoy.com/view/4ttBD4",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXfDB",
            "likes": 3,
            "name": "tartan weave brickwork chord 2",
            "published": 3,
            "tags": [
                "starguitar",
                "irrationalstride",
                "arpshepardtone",
                "ditherhairlinequantize",
                "chromaticscalecordtartanweave",
                "euclideanbeats",
                "euclideanrythm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "/*\nthis is a different approach to a [*stride] pMod segment\nthis rasterizes any interval perfectly with modulo arithmetic (and scales it by viewZoom)\nthe issue is, that you need multitapping for kerning\n,but this shows how far you can get with a single tap\nthis can do any chord and apreggio with single taps\narpeggios with overlapping notes may need a 4d to 2d fold.\n*/\n\n//this is a namespoace merger of 2 parents:e\n//https://www.shadertoy.com/view/4ttBD4  : tartan weave brickwork chord 1\n//https://www.shadertoy.com/view/3l2GDR  : ReTrAdUi amalgations2 (automatic differentiation)\n\n//circle radius\n#define radius 1.\n\n//#define hl2 290.*8.\n//https://www.shadertoy.com/view/4ttBD4 is pixel perfecrt, iff(viewZoom==hl2/floor(i))\n//zooming is just for a debug focus.\n#define viewzoom (.2)\n//(hl2/floor(mix(1.,hl2*.1,u5(-cos(iTime)))    ))\n//hl2*mix(9.,99.,(-sin(cos(iTime))))))\n//(mix(1./hl2,hl2,(-sin(cos(iTime)))))\n//#define viewZoom (hl2)\n//#define hl (viewZoom/hl2)\n#define hl (viewzoom/hl2)\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n\n//#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n//float ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(float u,vec2 m){return smoothstep(m.x,m.y,u);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n\n//return square tesselaion grod for [u]fragmentPos\n//float grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);return smoothstep(hl,-hl,abs(r-1.)-hl);}\n\n//domain-general pmod(), and 4 instanciated domain verisons:\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n//repetitive only for less repetitive legacy namespace support.\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define coVelEm 2.99792458e8\n#define lightspeed coVelEm\n//commonly known as \"speed of light\" or \"c\"; in in length/second==velocity\n//a better term would be [Electromagnetic velocity]\n//this is a maximum velocity in a vacuum. Usually a straight direct path is obstructed by mass\n//, cuvring spacetime, deforming a straight and shootrest path into a longer line.\n//Without a maximum velocity, causality over time is nonlinear/discontinuous.\n#define coPlanck 6.62607004e-34\n//smallest EM-observable quantity, smallest physically EM-percievable interval \n//;in joule*second==newton*length*second==length*length*kilogram/second/second == length*kilogram*acceleration\n//==length*kilogram*acceleration\n#define coPlanckR (coPlanck/pi/2.)\n//==1.0545718e-34\n//\"reduced PlanckConstant\" is a common scalar, where EM interferrences are about [fourier butterflies]\n//this involves the issue of [squaring an (epi)circle], within limited resolution of DFT|FFT\n#define coGravity 6.674e-11\n//gravitational constant; in newton/kilogram/kilogram/length/length\n//spacetime curvature over inverse_squared_distance to mass\n//gravity is not a force, but an effect of curving spacetime, poportional to squared mass and inverse squared distance.\n//you can model gravity as if it is a force, but that model will not be relativistic.\n#define coPlanckT sqrt(coPlanckR*coGravity/coVelEm/coVelEm/coVelEm/coVelEm/coVelEm)\n//PlanckTime; smallest EM-ovservavle interval over time\n//;5.3911252e-44 == sqrt(1.0545718e-34*6.674e-11/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8)\n//minimum time that information takes to traverse length(coPlanck) in coMaVelEm\n//whilst smaller units of time can exist, they are so small their effect on our existence is negligible\n#define planckT .0001    \n//smallest measurable distance to an asymptote\n//smallest measurable angle between 1 non-parallel lines\n//smallest feasible epsilon, regardles of contextual scaling, to evade divisions by 0.\n//an ideall model defines planck==coPlanckT or planck=coPlanck, depending on context of your model\n//, but 32bit float precision is not good enough for this.\n//so we chose to scale our model resolution down significantly, with less addressSpace/precision\n// PlanckLengt/PlanckTime =coMaxSpeed\n//[u]FragmentPos, [m]=start [n]=end\n\n//pmod-tartan-octave-key:\n//pmod fraction with epsilon\n#define pmodfe2(a,b,e) (fract(((a)/(b))+.5)-.5-(e))*(b)\n//...within floor quantizing\n#define pmodfq2(u,n,f,e) floor(pmodfe2(floor((u)+.5),(n)/(max(f,1.+(e))-1.),e)+.5)\n//...offset by m\n#define pmodfM2(u,n,m,f,e) pmodfq2(((u)-(m)),((n)-(m)),f,e)\n//...m is quantized (this is \"tartan basis\", and you check if returned all() any() values are <e.\n#define pmodfm2(u,n,m,f,e) pmodfM2(u,n,floor((m)+.5),f,e) \n//return distance of [u] to line srgment from [a] to [b]\n//pmod fraction with epsilon\n#define pmodfe(a,b,e) (fract(((a)/(b))+.5)-.5-(e))*(b)\n//...within floor quantizing\n#define pmodfq(u,n,f,e) floor(pmodfe(floor((u)+.5),(n)/(max(f,1.+(e))-1.),e)+.5)\n//...offset by m\n#define pmodfM(u,n,m,f,e) pmodfq(((u)-(m)),((n)-(m)),f,e)\n//...m is quantized (this is \"tartan basis\", and you check if returned all() any() values are <e.\n#define pmodfm(u,n,m,f,e) pmodfM(u,n,floor((m)+.5),f,e)\n//uv,start,end,segmentswithin [start,end],epsilonPlanck\n\nfloat dotList(vec2 u,vec2 m,vec2 n,float i//todo, no longer used function. i want to generalize with pmod\n){float s=segment(u,m,n)\n ;vec2 a=abs(m-n)\n ;//if(a.x-a.y<1.)\n ;a=pmodfm2(u,m,n,4.,planckT)\n ;s=sat(4.-s)\n ;return sat(8.-length(a))\n ;return min(sat(8.-length(a)),s)\n ;}//above without rotation, below is rotated and constrained by lineSegmentation\n\n//input [i] sets number of dots in line segment! (does not loop over i)\n//hacky overly general solution, still need to chose what to specialize this on.\n//set radius to 1 or whatever your zoom factors are.\n//or just floor the dot at the circle centers (without a hole)\nfloat dotListp(vec2 u,vec2 m,vec2 n,float i//todo, no longer used function. i want to generalize with pmod\n){vec2 a=(n-m)\n ;//min of 2 shapes, vars descripte dottedlineparams; linesegment thichmess=torRadius!\n ;float radi=8. //(length(m-n)+1.)\n ;float thickness=radi-6.//-6 is size of a hole insote the dot. must be <radi\n ;float r=-atan(a.y,a.x)     \n ;float s=segment(u,m,n)//line segment\n ;s=sat(radi-s)\n ;u=roth(u,r)\n ;m=roth(m,r)\n ;n=roth(n,r)\n ;a=pmodfm2(u,m,n,i,planckT)//[i] sets number of dots in line segment!\n ;//a.x=pmodfm2(length(u-n),length(m-n),length(n-n),4.,planckT)//niced try, very false\n ;a.x=abs(length(abs(vec2(a.x,-u.y+m.y)))-radi+thickness)\n ;a.x=(sat(thickness-a.x))\n ;float b=2.\n ;if(u.x<m.x||u.x>n.x)b=min(abs(length(m-u)-radi+thickness)\n                           ,abs(length(n-u)-radi+thickness))\n ;b=(sat(thickness-b))//2 half circle caps\n ;//return b\n ;//return a.x\n ;//return (a.x+s)*.2\n ;return max(min(a.x,s),b)\n ;}//this function is lame and hacky, the caps are smooth, but all else is not!\n\n//remember this identity for tartan domain folds:\n//;if(min(v.x,v.y)<0.)\n//==\n//;//if(v.x<0.||v.y<0.)\n//==\n//;//if(any(lessThan(v,vec2(0))))\n//above is for lines, below is for dots\n//;if(max(v.x,v.y)<0.)\nvec3 TartanPeriodVariating(vec2 u,vec2 m,vec2 n//uv,start,end\n){vec3 c=vec3(0)\n ;vec2 b3=pmodfm(u,n,m, 5.,planckT)//rasterized fold\n ;vec2 b5=pmodfm(u,n,m, 7.,planckT)//rasterized fold\n ;vec2 b7=pmodfm(u,n,m,13.,planckT)//rasterized fold\n ;if(any(lessThan(abs(b3),vec2(planckT))))c.xy+=1.//rasterized octave lines\n ;if(all(lessThan(abs(b3),vec2(planckT))))c.xy+=.5//rasterized octave dots     \n ;if(any(lessThan(abs(b7),vec2(planckT))))c.zx+=1.//rasterized octave lines\n ;if(any(lessThan(abs(b7),vec2(planckT))))c.zx+=1.//rasterized octave lines\n ;if(all(lessThan(abs(b5),vec2(planckT))))c.yz+=.5//rasterized octave dots\n ;if(all(lessThan(abs(b5),vec2(planckT))))c.yz+=.5//rasterized octave dots\n ;return c/4.5;}\n\n#define FRA(u) ((u-.5*iResolution.xy)*viewzoom)\n\nvec4 mainImage3(in vec2 U\n){vec3 c=vec3(0)\n ;float vZ=.2//resolution\n ;vec2 u=FRA(U)\n ;vec4 mouse=iMouse;mouse=iMouseZwFix(mouse,true)\n ;vec2 m=FRA(mouse.zw)\n ;vec2 n=FRA(mouse.xy)\n ;if(iMouse.z<0.\n ){\n  ;//vec2 rr=iResolution.xy*vZ//vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=vec2(cos(iTime),sin(iTime*.61))*iResolution.xy*.5*viewzoom\n  ;m=vec2(cos(iTime*.61),sin(iTime))*iResolution.xy*.5*viewzoom\n  ;}/**/\n     //note, this is the lame screenspace transform that left-aligns a square.\n //3 splitscreen contexts test 2 of the above functions, as this is all very experimental.\n ;c =TartanPeriodVariating(u,m,n)\n ;c+=dotListp(u,m,n,12.)\n ;return vec4(c,1.)\n ;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){//o=image(u,iMouse.xyzw,iResolution.xy,iTime)//fm synth shader vis\n ;o+=mainImage3(u)\n ;//o*=.5\n ;}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define vec1 float\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec2 c2p(vec2 a){return vec2(length(a),atan(a.y,a.x));}\nvec2 p2c(vec2 a){return cs(a.y)*a.x;}\nvec2 roth(vec2 u,float b){u=c2p(u);u.y+=b;return p2c(u);}//rotate u by b\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n/*pixelation && tartan weave intervals\nparent: https://www.shadertoy.com/view/4ttBD4\nself  : https://www.shadertoy.com/view/tdXfDB\nuseful for brickworkPatterns\nhttps://en.wikipedia.org/wiki/Brickwork#Load-bearing_bonds\nhttps://www.shadertoy.com/results?query=tartan\n- dither, pixelation, tiling, quantum, fold, fibonacci, weave, pmod, tartan, hairline, dotted, notekey, starguitar, chord,arpeggio\ndiscarded tags: bokeh (it used to be a bit bokeh-ish and theres some bokeh-context utility)\n- that is, pixerlation is reciprocal of bokeh.\n- that is, calculating bokeh within a bayer-matrix context\n- , not for all pixel, but for a regular interval of pixels, for better performance.\nMoire aliasing includes the fraction that defines black piano key distribution:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\nthis may extend\nhttp://mercury.sexy/hg_sdf/\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n\n\n//todo, fract() lacks AD code\n//todo, many lack the option to only calculate 2 derivatives (over n domains)== types d00,d11,d22,d33\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**/ // end__: shadertoy-iChannel-pattern\n/**/ // start: compatibilityCore \n\n//todo this commontab does not have a c2p() p2c() carthesianToPolar bijection-function-set, add that!\n\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n#define u2(a) su(mu(a,2.),1.)\n#define u5(a) su(mu(a,.5),.5)\n#define cosu5(a) u5(co(a))\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n/**/ //end__: compatibilityCore\n/**/ // start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created equal.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**/ // end__: openGl NaN-precision\n/**/ //start AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt²=+2th derivative (and dt)\n[d***]dt³=+3th derivative (and dt adnd dt²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n/**/\n//struct d(v0 a;);//just use v0 instead of a [d]  struct\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00 D00(v2   a){return d00(a.x,a.y,a.z);}\nv2   V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0 D0(v1  a){return d0(a.x,a.y);}\nv1 V1(d00 a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dt²\nST c000{d000 x                     ;};//1 domains t,dt²dt³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dt² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dt²dt³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt²,dt³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//I am still not perfectly sure about above srtucture\n//i think it enables you to define:\n//-  https://en.wikipedia.org/wiki/Multivariable_calculus#Applications_and_uses\n//-  https://en.wikipedia.org/wiki/Differential_dynamic_programming\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\nv2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.y,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\n\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0   da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d [wikipedia contour_Line]\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example for the d2,d222 structs\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=suab(p,s)//u=abs(p)-s \n ;return ma(u)  //return max(u.x,u.y);}//for 1 derivative over 3d space\nd222 fBoxCheap(c2 p,v2 s){;return ma(suab(p,s));}//for 3 derivatives over 3d space\n*/\n/**/ // end__: AD structure\n/**/ // start: AD-functions \n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\nFor a monadic structure, we imply prefix notation for everything:\nInfix notation is a 2000 year old dumb idea;\nGood enough for abacuss multiplication, bad for log((a+b)/(c-d))\nmemo to self: initially I liked to sort functions by number of input params, but this fails\n- atan() takes 1 input, but its subroutines ad()po()di() take more than 1 input./**/\n\n//negation identity: max(a,b)=-min(-a,-b), makes definition of negation the top oriority\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n//floor(a) is a basis-function for mod() and fract()\n//because mod() is a mess, so i needed a trueMod(fract())\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies above 2 lines to 2 defines\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to lultiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n\n//also, since mod(a,1.) NEVER returns 1 (its a halfoven interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\n/*    //residue from AD16 on mod() derivatives                   \n//mo() ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, mod(a,b) outperforms mu(fractd(divd(a,b)),b)\n//v4 mod(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 mod(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 mod(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does\n#define may fract(a.b));}\n#define maz mod(a.a,b),may\n#define mab mod(a.a,b.a)\n//v0 mo(v0 a,v0 b){return mod(a,b);}                        \nd2 mo(d2 a,v0 b){return d2(maz\nd1 mo(d1 a,v0 b){return d1(maz\nd0 mo(d0 a,v0 b){return d0(maz\nd0 mo(d0 a,d0 b){return d0(mab,may\nd2 mo(d2 a,d0 b){return d2(mab,may\nd2 mo(d2 a,d2 b){return d2(mab,may\nd2 mo(d2 a,d1 b){return d2(mab,may\nd2 mo(d0 a,d2 b){return d2(mab,v2(0));}\nd2 mo(d1 a,d2 b){return d2(mab,v2(0));}\nd2 mo(v0 a,d2 b){return d2(mo(a,b.a),v2(0));}\nd1 mo(v0 a,d1 b){return d1(mo(a,b.a),v1(0));}\nd0 mo(v0 a,d0 b){return d0(mo(a,b.a),   0.);}\n*/                     \nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\n//above so far is only useful for sin() or cos()\nv3 siD(v0 a){return v3(+si(a),+co(a),-si(a),-co(a));}\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\n\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nd111 si(d111 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd111 co(d111 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd222 co(d222 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd333 si(d333 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=si(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\nd333 co(d333 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=co(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\n//once more a clear sign of my structure extending poorly.\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n/*\n//atan is implemented, but further below, it needs more subroutines:\ntodo, all the trigonometry functions with glES100 to gles300 porting\n*/\nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n\n\n//single parameter operations are MUCH simpler here:\nv0 sr(v0 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\n\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n\n//ex(d00) seems to be fine\nd00 ex(d00 a){return d00(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n);}\n//exp2() is not THAT simple here???\n\n//ex(d000) seems to be fine\nd000 ex(d000 a){return d000(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b\n+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}\n//exp2() is not THAT simple here.\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\nd11 ex(d11 a){\n ;d00 Omg(ex,x)\n ;d00 Omg(ex,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){\n ;d00 Omg(ex,x)\n ;d00 Omg(ex,y)\n ;d00 Omg(ex,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){\n ;d00 Omg(ex,x)\n ;d00 Omg(ex,y)\n ;d00 Omg(ex,z)\n ;d00 Omg(ex,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\n\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd1 ln(d1 a){return d1(log(a.a),a.b/a.a);}\nd2 ln(d2 a){return d2(log(a.a),a.b/a.a);}\n//        pow (x,y) ex(   ln(x)*y )//wait till we define mu()\n//#define powd(x,y) ex(mu(ln(x),x))//wait till we define mu()\n\n//ln() 2nd and 3rd derivative imply quotientRule\n//i hope i did this corretcly. last time i did this 15 years ago.\nd00 ln(d00 a){return d00(\n ln(a.a) //t\n,a.b/a.a //dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dt²\nd000 ln(d000 a){return d000(\n ln(a.a)//t\n,a.b/a.a//dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dt²\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))\n /(a.a*a.a*a.a*a.a)//dt³\n    //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() overlaps a lot with di() the a are only off by 1.\n //ln() is a special case of di() == one antiderivative higher.\n\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0   sg(d0   a){return   d0(sign(a.a),0.);}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd2 sg(d2 a){\n   ;d0 x=sg(d0(a.a,a.b.x))\n   ;d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))      \n   ;return d2(x.a,v2(x.b,y.b,z.b));}\n\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nc2 ab(c2 a){\n ;d2 x=ab(a.x)\n ;d2 y=ab(a.y)\n ;d2 z=ab(a.z)\n ;return c2(x,y,z);}\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use mod() instead, mod() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.a),djum(a.b));}\nd1 fractd(d1 a){return d1(floor(a.a),djum(a.b));}\nd0 fractd(d0 a){return d0(floor(a.a),djum(a.b));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n//todo, higher derivatives for fract()\n\n/*\nmathematical ifentity\nof fract(x) \nis mod(x,1.)\nis mod(x,1.)\n*/\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\n\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)     \nv0 su(v0 a,v0 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\n//this d000 to d222 structure hints at inefficient structure\n//glide-translations along multiple domains:\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n/*\nc3333 su(c3 p,v3 s){return c333\n(su(p.x,s.x)//su(d3,v0)\n.su(p.y,s.y)//su(d3,v0)\n,su(p.z,s.z)//su(d3,v0)\n,su(p.w,s.w));}//su(d3,v0)*/\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\nd3 suab(d3 p,v0 s){return su(ab((p)),s);}                     \nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\n\nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z),\n                                   suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),\n                                   suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\n\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}//special utility cases come last\nd000 mu(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n\n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n\nd000 di(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),x))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n\nd000 mi(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n//#define p2(a) ex(a,2.)\n//#define p3(a) ex(a,3.)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n/**/\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\nd000 dt(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\nd111 dt(d111 a,d111 b){d000 xa=omG(dt,x);d000 ya=omG(dt,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 dt(d222 a,d222 b){d000 xa=omG(dt,x);d000 ya=omG(dt,y);d000 za=omG(dt,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\n/*\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n\nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n/**/                           \n //;d2 c=p2(p.z) //1 derivative over 3 domains\n //;3 domain-1stDerivatives are stored in .b\n //.a is a 1d point? how does that make sense?                       \n                           \n/*\n//dotProduct of a and b, 1 derivative over 1 domain\n//the mindMelter here is that a dorProduct folds to 1 domain\n//but the inputs likely have more domains than that\nd0 dt(c0 a,c0 b){\n   ;d0 r=\n    return a; //totally false function\n;}//dotProduct of a and b, 1 derivative over 1 domain\n\n                           /*\n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(c1 a,c1 b\n){d0 r=D0(v1(    \n    dot(a.a,b.a)\n             ,0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 2 domains\n                           \n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(c2 a,c2 b\n){d0 r=D0(v1(dot(a.a,b.a),0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 3 domains \n                           \n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(d3 a,d3 b\n){d0 r=D0(v1(dot(a.a,b.a),0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 4 domains\n                        \n/**/\n                           \n#define dd(a) dt(a,a)\n                           \n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is f´(x)=1/x*x+1\nd2 ata(d2 a\n){v0 b=atan(a.a)\n ;d2 e=mu(a,a)\n ;e=ad(e,1.)\n ;e=di(1.,e)//e=divd(1.,addd(mu(a,a),1.));\n ;return d2(b,e.b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\nv0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\n\n\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n/**/ // end__: common aliases\n/**/ // start: iDiegeticUI v2 header:\n/*\n\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n\n/**/ //end__ diecetic_UI_2 header\n/**/ //start diecetic_UI_2 \n/*\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return min(b.z-b.x,b.y-b.w)<mi(b) ;}\n\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m\n){if(d<r\n ){r=d\n  ;state.x=f\n  ;o=center-m;}}\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*v2(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define tiny .00001\n\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;//if (dotperp==0.)return A\n ;//dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n#define Over 0.\n#define Atop 1.\n//#define ut(a,b) (a*(1.-b))\nv3 ut(v3 a,v0 b){return a*(1.-b);}\nv2 ut(v2 a,v0 b){return a*(1.-b);}\nv1 ut(v1 a,v0 b){return a*(1.-b);}\nv0 ut(v0 a,v0 b){return a*(1.-b);}\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//v3 pdOut(v31 a,v31 b){return ut(b,a.b);}\n\nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n                          \n//project point [a] onto line trough vecN(0) and vecN([b])\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest distance between point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  add(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b))\n ;}\n\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L//https://www.shadertoy.com/view/4ltyWr\n){v1 l = p2-p0\n ;v0 h = sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)\n ;return (p0+p2)/2.+sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)*norma( v1(-l.y,l.x) )     \n ;}\n                          \n/**/ //--- start AD-/mercury.sexy/hd_sdf\n\n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(c2 p){p.x.a=mix(0.,p.x.a,step(p.x.a,0.));\n d2 q=sd(p.x,p.y,p.z);return su(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nv0 fBoxCheap(v2 p,v2 b\n){v2 q=abs(p);q=q-p//mirror clamp\n ;return max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(c2 p,v2 s\n){c2 u=suab(p,s)//mirror clamp\n ;return madm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\nv0 fBox(v2 p,v2 s\n){v2 d=abs(p)-s//mirror clamp\n ;v0 a=length(max(d,0.))//rounded corners\n ;v2 q=min(d,0.)//clamp\n ;v0 b=max(max(q.x,q.y),q.z)//keep largest of 3\n ;return a+b;}//add //hg_sdf\nd2 fBox(c2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n c2 d=suab(p,s);//mirror clamp\n d2 a=sd(ma(d,0.));//rounded corners\n c2 q=mi(d,0.);//clamp\n d2 b=madm(q);//keep largest of 3\n return ad(a,b);}//add\n\nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fractd(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}\n       \n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//explicit type dual_v0 dd()\n#define dd2(a,b) ad(p2(a),p2(b))\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n\n                          \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n                          \nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n\n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n                          \n                          \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n\n//bellow code is RE7:\n                          /*\nrelativistic engine, with mutable/slower speedOfLight\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\nblatantly false\n- shadows are unaffected by gravity\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow\nDoes not simulate:\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- Mass of object\n/**/\n//ESDF keyboard layout is more compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//light settings\n#define cSpe 2.5\n//SpeedOfLight in meter/second\n//divides by /(cSpe*cSpe), so do not make it too large!\n#define cLag 1.\n//PhotonLatency [0..1]; zero=instant vision,makes easier to see how relativity affect time & space\n#define FOVAberrationOfLight 1.\n//take relative velocity of photons to camera & distort field of view\n//optical settings\n#define dopplerFactor .5\n//take player/object/light vel to shift color\n#define repeatDoppler 0\n//relativity\n#define LgthContraction  1.\n//shrink map along velocity vector at high speed\n#define TimeDilation 1.\n//speed map frame time at high speed\n#define SimultaneousEvents 1.\n//see past behind you, futur foward at high speed (not supposed to be observed)\n#define relativisticDoppler .2\n//take light source speed into account and their own time dilation\n//black hole\n#define BlackHoleMassFactor 2.\n#define AccretionDisk 2.\n//player and cam\n#define fishEye false\n#define FOV 1.3\n//1.57 = 90\n#define maxSpeed 2.4\n//do not go over speed of light it breaks time & space\n#define thrustForce 15.\n//player acceleration\n#define RayPrecision 1.\n#define MaxRayDist 9.0\n#define numMats 7\n#define numLights 3\n#define GI 1.3\n#define GIDist 2.5\n#define gravity v2(0.,-3.,0.)\n\n#define ab012(a,b)(a+b*v2(0,1,2))//desaturation.rgb kernel;b scales offset\n//v2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbow2(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\n//v2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbow2(v0 a){return rainbow2(a,1./3.);}\n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID == processedMaterial || processedMaterial == -1) { nextMat = matID; lastrDist = o;\n#define endMaterial() } if (o != lastrDist) rayMat = nextMat;  \n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\ni0 nextMat;\ni0 rayMat;\ni0 rayObj;\nv0 matSize;\nv0 lastrDist;\nv0 lastrDistObj;\nv3 volumetricCol;\n//BuffCoords of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer]\n//- 0<=x<Resolution.xy\n#define RePos   0.\n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n#define ReTime  5.\n#define ReCol   6.  //not used by Image\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\nv0 varWdth=1.;\n//#define ReTraT  9.  \n//v0 PROPER_D_POS = 8.;\n//v0 TRAIN_TIME = 9.;\n\n//v0 varWdth = 5.;\n/*\nv0 POS = 0.;\nv0 D_POS = 1.;\nv0 DD_POS = 2.;\nv0 QUAT = 3.;\nv0 D_QUAT = 4.;\nv0 TIME = 5.;\nv0 COLLISION = 6.;\nv0 CAM_PITCHYAW = 7.;\nv0 PROPER_D_POS = 8.;\nv0 TRAIN_TIME = 9.;\n*/\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays of structparams: \n#define objNum 7\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n//for below object properties;\nv3 [objNum] objRot;//rotation\nv2 [objNum] objPos;//position\nv2 [objNum] objVel;//velocity\nv2 [objNum] objSca;//scale\n//v0[objNum] objRad;//radius optimization\n//\n//lights have no labels\nv3 [numLights] oliCol;//colorIntensity;\nv2 [numLights] oliPos;//position\nv0[numLights] oliHal;//HaloResult\n//v0[numLights] oliSiz;//size\nv0 maxGISize;//what is this?\nv0 lorentzF;\n//mat3x3 LZLgthContract;\nv2 pos;\n//v2 dpos;\nv0 playerTime;\nint curObj = 0;//es100 error , first class array\nint minObjDepth = -1; \n    \n//Quaternions\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dot(a,a)! \nv3 qn(v3 q){return q/dot(q,q);}\n/**/\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n//RayMarchingPrimitivesBasic\nv0 sphere(v3 ray,v2 u, v0 radius\n){maxGISize = max(maxGISize,radius*ray.w)\n ;return ray.w*(length(ray.xyz-u)-radius);}\nv0 cylinderY(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize=max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xz-u.xz)\n -radius, abs(ray.y-u.y)-height));}\nv0 cylinderZ(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize = max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xy-u.xy)\n -radius, abs(ray.z-u.z)-height));}\nv0 cube(v3 ray, v2 u, v0 size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\nv0 line(v3 ray, v2 u, v0 size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(ray.z,ray.y);}\nv0 box(v3 ray, v2 u, v2 size\n){maxGISize = max(maxGISize,length(size)*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\n//DopplerShift\nv0 GetMatch(v2 c,v2 s,v0 t //col,shiftedFreq,targetFreq\n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;c*=max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.)\n #else\n ;c*=max(v2(0),1.-abs(s)*3.)\n #endif\n ;return c.x+c.y+c.z;}\n//dopplerShiftFactor\nv2 dsf(v2 c,v2 f//all values of f are identical.\n){f*=v2(1.,1.257,1.58)\n ;v2 r=v2(1,2,4)/3.\n ;return v2(GetMatch(c,f,0. )+GetMatch(c,f,1.)*.3+GetMatch(c,f,-r.x)*.2\n             ,GetMatch(c,f,r.x) \n             ,GetMatch(c,f,r.y)+GetMatch(c,f,1.)*.5+GetMatch(c,f,r.z)*.25);}\nv2 dsf(v2 c,v0 f){return dsf(c,v2(f));}\n//v2 DopplerShift(v2 c,v0 s//color,speed\n//){return dsf(c,v2(cSpe/(cSpe-s*dopplerFactor)));}\nv3 Transform(int i,v3 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(v2(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\nvoid ProcessCamPos(v2 u, v3 rot\n){objPos[oCam]= u\n ;objRot[oCam]=rot;}//es100 error , no array of class allowed\nv0 LorentzFactor(v0 v//velocity\n){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\nv2 dpos;//relevant for each pixel of [RE] and [Image] \nvoid ProcessObjectPos(v0 time\n){objPos[oCubeMy]=v2(0) \n ;objRot[oCubeMy]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oCubeMy]=v2(.8)//es100 error , no array of class allowed\n ;objPos[oBlackHole]=v2(5.,sin(time*0.2),-5.)//es100 error , no array of class allowed\n ;objRot[oBlackHole]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oBlackHole]=v2(1)//es100 error , no array of class allowed\n ;objPos[oCubeChil]=v2(1)//es100 error , no array of class allowed\n ;objRot[oCubeChil]=aa2q(time*1.,norma(objPos[oCubeChil]))//es100 error , no array of class allowed\n ;//o_myCubeChildren.rot = v3(0,0,0,1)\n ;objSca[oCubeChil]=v2(.4)//es100 error , no array of class allowed\n ;v0 trainV = 2.2\n ;objVel[oTrain]= v2((floor(mod(trainV*time/16.,2.))*2.-1.)*trainV,0,0)//es100 error , no array of class allowed\n ;v0 trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.//es100 error , no array of class allowed\n ;objPos[oTrain]=v2(abs(1.-mod(trainV*time/16.,2.))*16.-8.,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTrain]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTrain]= v2(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;//objects[o_train].b.x = 0.//es100 error , no array of class allowed\n ;objPos[oTunnel]=v2(0,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTunnel]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTunnel]=v2(1.,1.,1)//es100 error , no array of class allowed\n ;objPos[oTunnelDoor]=objPos[oTunnel]//es100 error , no array of class allowed\n ;objRot[oTunnelDoor]=objRot[oTunnel]//es100 error , no array of class allowed\n ;v0 open = clamp((1.-abs(3.*objPos[oTrain].x))*2.,0.,1.)//es100 error , no array of class allowed\n ;objSca[oTunnelDoor]= v2(open,open,1);}//es100 error , no array of class allowed\n//es100 error , no array of class allowed\nvoid ProcessLightValue(v0 t\n){oliPos[0]=v2(6.,1.,sin(t))\n ;oliCol[0]=3.*v3(0.2,1.,.2,1)\n ;oliPos[1]=v2(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*v3(1,1,0.5,1)\n ;oliPos[2]=v2(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*v3(1,.2,1,1);}\nvoid SetTime(v0 t){ProcessLightValue(t);ProcessObjectPos(t);}//es100 error , no array of class allowed\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n#define VOL(func)  if (func < rDist)\n//volume marching accumulator, used for blackHoleAccretionDisk\nv0 vma=0.;\nv0 map(v2 pos, int processedMaterial\n){v0 o = 0. //0. if first operation is a SUB(), 1e10 otherwise\n ;maxGISize = 0.\n ;rayObj = 0\n ;v3 w = v3(pos,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(box(w,v2(0,0,0),v2(10,2.5,10)))\n ;ADD(cylinderY(w,v2(-6,0,-2.),0.1,3.))\n ;ADD(cylinderY(w,v2(5,0,-2.),0.1,3.))\n ;endMaterial()\n ;v3 c=beginObj(oCubeMy,w)//cubespace, not color\n ;//ADD(box(c,v2(0,0,0),v2(1)))\n ;//c.xz = abs(c.xz)\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(sphere(c,v2(0,0,0),1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;v3 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(sphere(blackHoleSpace,v2(0,0,0),.5))\n ;endMaterial()\n ;v3 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(box(tunnelSpace,v2(0,.5,0),v2(.2,.1,1.5)))\n ;ADD(box(tunnelSpace,v2(0,-.5,0),v2(.2,.1,1.5)))\n ;endMaterial()\n ;v3 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(box(tunnelDoorSpace,v2(0,0,1.4),v2(.2,.4,0.1)))\n ;ADD(box(tunnelDoorSpace,v2(0,0,-1.4),v2(.2,.4,0.1)))\n ;endMaterial()\n ;v3 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(box(trainSpace,v2(0,0,-.8),v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0,0,-.4),v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0)      ,v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0,0, .4),v2(.1,.1,.18)))\n ;ADD(box(trainSpace,v2(0,0,.68),v2(.1,.1,.06)))\n ;ADD(cylinderZ(trainSpace,v2(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;v0 temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;v0 tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0; L<3; L++\n ){\n  ;ADD(sphere(w,oliPos[L]\n              //o_lights[L].b\n              ,0.001))\n  ;\n  ;v2 relPos = oliPos[L]-pos//o_lights[L].b\n  ;oliHal[L]//o_lights[L].haloResult \n      += o*(0.02/(dot(relPos,relPos)+0.01))\n  ;}\n ;return o;}\nv3 GetNormal(v2 u\n){v1 e = v1(0.003,0.)\n ;v0 o=map(u,-1)\n ;return v3(norma(v2(map(u+e.xyy,-1)\n                    ,map(u+e.yxy,-1)\n                    ,map(u+e.yyx,-1))-o),o);}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}