{
    "Shader": {
        "info": {
            "date": "1477878602",
            "description": "Importance sampled procedural mosque with global illumination. The fractal patterns are made after [url]https://www.shadertoy.com/view/Mt3Szr[/url]. Click the screen to reset the rendering.",
            "flags": 32,
            "hasliked": 0,
            "id": "ltdXRr",
            "likes": 82,
            "name": "Islamic Art",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "global",
                "pathtracing",
                "montecarlo"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 4315
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    // number of samples is stored in alpha channel\n    fragColor.rgb = col.rgb / col.a;\n    // exposition\n    fragColor.rgb *= 0.4;\n    // gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    // color grading\n    fragColor.rgb = pow( fragColor.rgb, vec3(0.8,0.85,0.9) );\n    // vigneting\n    vec2 p = uv * 2.0 - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.2);\n    \n    fragColor.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n#define PHI 1.61803398875\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,3,1,0)))\n#define Z min(0, iFrame)\n\n// size of a carpet, also the dimensions of 4 pillars\nconst vec2 carpetSize = vec2(PHI, 1);\n// number of pillars\nconst vec2 pillarsSize = vec2(8, 4);\n// distance from axis to windows\nconst float lenWind = carpetSize.y*(pillarsSize.y-1.0)*0.5;\n// colors\nconst vec3 lightWalls = vec3(1.0, 0.9, 0.85);\nconst vec3 darkWalls = vec3(0.7, 0.65, 0.6);\nconst vec3 darkRed = vec3(0.1, 0.01, 0.01);\n\n// iq's integer hash https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x ) {\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// iq's functions\nfloat smin( in float a, in float b, in float s) {\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\nfloat smax( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// arch distance\nfloat arch( in vec2 p ) {\n    const float d = 0.2;\n    float base = length(abs(p) + vec2(d, 0)) - d;\n    return base;\n}\n\n// wall tiles deformation\nfloat tileBump( in vec3 p ) {\n    const vec3 tileSize = vec3(0.2, 0.2, 0.072);\n    p /= tileSize;\n    p += PHI*vec3(1, 2, 6);\n    p.xy += mod(floor(p.z), 5.0)/3.0;\n    vec3 inTile = (fract(p) * 2.0 - 1.0);\n    vec3 bump = smoothstep(0.9, 1.0, abs(inTile));\n   \treturn max(max(bump.x, bump.y), bump.z);\n}\n\n// window recess\nfloat window( in vec3 p ) {\n    vec3 inArch = p - vec3(0.0, 0.0, 1.1);\n    inArch.z = max(0.0, inArch.z);\n    float dist = arch(inArch.xz)-0.6;\n    dist = max(dist, abs(p.y)-0.4);\n    dist = max(dist, -p.z);\n    return dist;\n}\n\n// pillar\nfloat pillar( in vec3 p, out vec4 color, in bool doColor ) {\n    \n    // cylindrical pillar\n    float cyl = length(p.xy) - 0.12;\n    \n    // add spiral grooves\n    float theta = atan(p.y, p.x) * 27.0;\n    theta += smin(smax(p.z, 0.1, 0.02), 0.75, 0.02)*200.0;\n    float grooves = (sin(theta)*0.5+0.5)*smoothstep(0.85, 0.82, p.z);\n\tcyl += grooves*0.008;\n    cyl = max(cyl, p.z-0.93);\n    \n    // add a box\n    float cube = sdBox(p-vec3(0, 0, 6.2), vec3(vec2(0.15), 5.2));\n    float de = smin(cube, cyl, 0.2);\n    \n    // color with grooves\n    if (doColor) {\n        color = mix(vec4(lightWalls, 0.4), vec4(darkWalls, 0.2), grooves);\n    }\n        \n    return de;\n}\n\n// roof texture (fractal+border)\nfloat roof( in vec3 p, out vec4 color, in bool doColor ) {\n    \n    // base plane\n    float distCube = -p.z;\n    \n    // add archs\n    float le1 = arch(p.xz)-carpetSize.x*0.5+0.15;\n    float le2 = arch(p.yz)-carpetSize.y*0.5+0.15;\n    float le3 = -p.z+0.01;\n    \n    float seed = step(le2, le1);\n    float border = smoothstep(0.022, 0.02, min(max(le1, le2), -le3));\n\t\n    float de = max(distCube, -min(le1, le2));\n    \n    // add fractal tiles\n    if (doColor) {\n        \n        float scale = 0.0;\n        vec2 uv = p.xy;\n        \n    \t// accumulated alpha and color\n    \tfloat alpha = 0.0;\n        color = vec4(vec3(0), 0.7);\n        uv *= 0.05;\n\n        for (int i = 0 ; i < 10 ; i++) {\n            float s = 2.0;\n            uv = 1.0 - abs(s*fract(uv-0.5)-s*0.5);\n            float theta = float(i) * PI * 0.125;\n            theta += seed * PI * 0.172;\n            uv.xy *= rot(theta);\n            scale *= s;\n            \n            if (i < 5) continue;\n            \n            vec2 ab = abs(uv);\n\t\t\tfloat tileDist = length(uv)-0.3;\n            tileDist = min(tileDist, min(ab.x, ab.y)-0.1);\n\n            if (doColor) {\n                vec3 c = hsv2rgb(vec3(float(i)*0.02 + seed*0.06+0.9, 0.9, 0.8));\n                c = mix(c, vec3(0.02), smoothstep(0.008, 0.02, tileDist));\n                float f = smoothstep(0.05, 0.04, tileDist);\n                c *= f;\n\n                color.rgb = (1.0-alpha)*c+color.rgb;\n        \t\talpha = (1.0-alpha)*f+alpha;\n            }\n        }\n        \n        color.rgb = mix(vec3(0.4, 0.01, 0.01), color.rgb, alpha);\n\n        // remove tiles, add a rim\n        color = mix(color, vec4(darkRed, 0.4), border);\n        de -= border*0.002;\n    }\n    \n    return de;\n}\n\n// floor texture\nvec4 carpetFloor( in vec3 p, in float bump ) {\n    \n    vec3 carpetCenter = vec3(floor( p.xy / carpetSize + 0.5 ), 0.0);\n    carpetCenter.y = min(1.0, carpetCenter.y);\n    carpetCenter.xy *= carpetSize;\n    float seed = cos(dot(carpetCenter.xy, vec2(123.331, 442.341)))*0.5+0.5;\n    \n    vec3 inCarpet = p - carpetCenter;\n    inCarpet.xy *= rot(seed*0.03);\n    \n    // add a border\n    vec2 inBorder = abs(inCarpet.xy) - carpetSize*0.5 + vec2(0.17, 0.03);\n    float border = max(inBorder.x, inBorder.y);\n        \n    // fractal formula\n    float scale = 1.0;\n    // accumulated alpha\n    float alpha = 0.0;\n    // accumulated color\n    vec3 color = vec3(0);\n    \n    // fractal patterns\n    vec2 uv = inCarpet.xy;\n    uv *= 0.1;\n    for (int i = 0 ; i < 11 ; i++) {\n        float s = 2.0;\n        uv = 1.0 - abs(s*fract(uv-0.5)-s*0.5);\n        float theta = float(i) * PI * PHI + seed*0.1;\n        uv *= rot(theta);\n        scale *= s;\n        \n        if (i < 5) continue;\n        \n        vec2 ab = abs(uv);\n        float helix = length(uv) - sin(atan(uv.y, uv.x)* 6.0)*0.1-0.5;\n        float dist = min(min(ab.x, ab.y)+0.1, helix);\n        float f = smoothstep(0.2, 0.18, dist);\n        vec3 c = hsv2rgb(vec3(float(i)*0.03 - 0.15 - seed*0.04, 0.9, 0.9));\n        c = mix(c, darkRed, smoothstep(0.12, 0.15, dist));\n        \n        c *= f;\n        \n        color = (1.0-alpha)*c+color;\n        alpha = (1.0-alpha)*f+alpha;\n    }\n\n    vec4 carpetColor = vec4(mix(vec3(0.3, 0.01, 0.01), color, alpha), 0.0);\n    // add a border\n    carpetColor.rgb = mix(carpetColor.rgb, darkRed, smoothstep(-0.06, -0.04, border));\n    // mix carpet color with white border\n    carpetColor = mix(carpetColor, vec4(vec3(0.9), 0.0), smoothstep(-0.04, -0.03, border));\n    // and mix with floor\n    vec4 floorColor = mix(vec4(darkWalls, 0.4), vec4(darkWalls*0.5, 0.3), bump);\n    carpetColor = mix(carpetColor, floorColor, smoothstep(0.0, 0.01, border));\n    \n    return carpetColor;\n    \n}\n\n// main distance function\nfloat de( in vec3 p, out vec4 color, in bool doColor ) {\n    \n    float stepWind = smoothstep(lenWind-0.09, lenWind-0.05, p.y);\n    float stepFloor = smoothstep(0.02, 0.01, p.z);\n\n    // borders of the room\n    vec3 inRoom = abs(p - vec3(0, 0, 1.5)) - vec3(carpetSize*(pillarsSize-vec2(1)), 3)*0.5;\n    float distRoom = -max(max(inRoom.x, inRoom.y), inRoom.z);\n    float bump = tileBump(p);\n    distRoom += bump*0.004*(1.0-stepWind)*(1.0-stepFloor);\n    // add windows\n    vec3 pWindow = p - vec3(0, lenWind, 0);\n    vec3 windowCenter = vec3(floor( pWindow.x / carpetSize.x + 0.5) * carpetSize.x, 0.0, 0.0);\n    float distWindow = window(pWindow - windowCenter);\n    distRoom = max(distRoom, -distWindow);\n    \n    // center of the nearest pillar\n    vec3 pPillar = p + vec3(carpetSize*0.5, 0);\n    vec3 pillarCenter = vec3(floor( pPillar.xy / carpetSize + 0.5 ) * carpetSize, 0.0);\n    vec4 pillarColor = vec4(0);\n    float distPillar = pillar(pPillar - pillarCenter, pillarColor, doColor);\n    \n    // roof\n    vec3 roofCenter = vec3(floor( p.xy / carpetSize + 0.5) * carpetSize, 1.1);\n    vec4 roofColor = vec4(0);\n    float distRoof = roof( p - roofCenter, roofColor, doColor );\n    \n    float de = min(distPillar, distRoom);\n    de = min(de, distRoof);\n    \n    if (doColor) {\n        if (de == distPillar) {\n            color = pillarColor;\n        } else if (de == distRoom) {\n            color = vec4(darkWalls, 0.6);\n            color = mix(color, vec4(0.0), (bump*bump)*0.5),\n            color = mix(color, vec4(lightWalls, 0.2), stepWind);\n            color = mix(color, carpetFloor(p, bump), stepFloor);\n        } else {\n            color = roofColor;\n            // blend with borders\n            color.rgb = mix(color.rgb, darkRed, smoothstep(-0.04, -0.03, abs(p.y)-lenWind));\n        }\n    }\n    \n    return de;\n    \n}\n\n// stained glass texture\nvec4 glass( in vec3 p ) {\n    \n    // get distance to the scene to add wood borders first\n    vec4 dummyColor = vec4(0);\n    float borderDist = de(p, dummyColor, false)-0.04;\n    borderDist = min(borderDist, p.z-0.2);\n    \n    // transform uv to a grid domain\n    vec2 sizeBorder = vec2(0.28, 0.8);\n    vec2 uv = p.xz;\n    uv.x = mod(uv.x-carpetSize.x*0.5, carpetSize.x)-carpetSize.x*0.5;\n    float seed = 0.0;\n    \n    if (uv.y > 1.0) {\n        sizeBorder = vec2(sizeBorder.x*2.0, 0.5);\n        seed = 15.0+floor(abs(uv.x) / sizeBorder.x + 0.5);\n        uv.x = mod(uv.x, sizeBorder.x);\n        uv += vec2(sizeBorder.x*0.5, 1.0);\n    } else {\n        seed = floor(abs(uv.x) / sizeBorder.x);\n        uv.x = mod(uv.x, sizeBorder.x);\n        uv += vec2(0.0, 0.6);\n    }\n    \n    seed += floor(p.x / carpetSize.x + 0.5) * 100.0;\n    uv = mod(uv, sizeBorder) - sizeBorder*0.5;\n    \n    // create border\n    vec2 grid = abs(uv) - sizeBorder*0.5;\n    float borderGrid = -max(grid.x, grid.y);\n    borderDist = min(borderDist, borderGrid);\n   \tfloat border = step(borderDist, 0.03);\n    vec3 bb = mix(vec3(0.2, 0.05, 0.05), vec3(0.05), smoothstep(0.00, 0.018, borderDist));\n    float borderShadows = clamp(exp(-borderDist*16.0)*0.6, border, 1.0);\n\tvec4 borderColor = vec4(bb, borderShadows);\n    \n    // fractal patterns\n    float scale = 1.0;\n    vec3 color = vec3(0.0);\n    uv *= 0.15;\n    for (int i = 0 ; i < 7 ; i++) {\n        float s = 2.0;\n        uv = 1.0 - abs(s*fract(uv-0.5)-s*0.5);\n        float theta = float(i) * PI / PHI + seed*0.26;\n        uv.x = abs(uv.x);\n        uv *= rot(theta);\n        scale *= s;\n    }\n    \n    float d = mod(floor(uv.x*3.0), 3.0);\n    vec3 hsv = vec3(fract(seed*0.442)*0.52 + d*0.1 - 0.1, 0.97, 0.97);\n    color = hsv2rgb( hsv );\n\n    // add border and shadows to the glass\n    color = mix(color, borderColor.rgb, borderColor.a);\n    return vec4(color, border);\n}\n\n\n// normal function\nvec3 normal( in vec3 p ) {\n    vec4 dummyColor = vec4(0);\n\tvec3 e = vec3(0.0, 0.0001, 0.0);\n    float d = de(p, dummyColor, false);\n\treturn normalize(vec3(\n\t\td-de(p-e.yxx, dummyColor, false),\n\t\td-de(p-e.xyx, dummyColor, false),\n\t\td-de(p-e.xxy, dummyColor, false)));\t\n}\n\n// trace function, return true if we hit the light source\nbool trace( in vec3 from, in vec3 dir, in bool doNormal, out vec3 pos, out vec3 norm, out vec4 diff ) {\n    \n    // raymarch to the scene\n    float totdist = 0.0;\n\tbool set = false;\n\tfor (int steps = Z ; steps < 150 ; steps++) {\n\t\tif (set) continue;\n\t\tvec3 p = from + totdist * dir;\n\t\tfloat dist = de(p, diff, false)*0.95;\n\t\ttotdist += dist;\n\t\tif (dist < 0.0001) {\n\t\t\tset = true;\n\t\t}\n\t}\n    \n    // raytrace to the lighting source (windows)\n    float yWind = lenWind + 0.2 - from.y;\n    float distWind = yWind / dir.y;\n    if (distWind < totdist && distWind > 0.0) {\n        pos = from + distWind * dir;\n        if (doNormal) norm = vec3(0, -1, 0);\n        diff = glass(pos);\n        return true;\n    }\n    \n    // otherwise we hit the scene\n    pos = from + totdist * dir;\n    if (doNormal) norm = normal(pos);\n    de(pos, diff, true);\n    \n    return false;\n}\n\n// background color\nconst vec4 colorSun = vec4(1.0, 1.0, 0.8, 100000.0);\nconst vec4 colorAmbient = vec4(0.6, 0.7, 0.9, 1.0);\nconst vec4 colorGround = vec4(0.3, 0.2, 0.2, 0.5);\nconst vec3 sunDir = normalize(vec3(0.25, -1.0, -0.98));\nconst float sunAngle = 0.01;\nconst float sunCosAngle = cos(sunAngle);\nvec3 getBackground( in vec3 dir ) {\n    float d = dot(dir, -sunDir);\n    vec3 base = colorAmbient.rgb;\n    base.rgb = mix(base.rgb, colorSun.rgb, smoothstep(0.5, 1.0, d)*0.5);\n    base = mix(base, colorSun.rgb, smoothstep(sunCosAngle, sunCosAngle+0.001, d));\n    base = mix(base, colorGround.rgb, step(dir.z, 0.0));\n    return base.rgb;\n}\n\n// trace to a random light source (the sky)\nvec3 traceLight( in vec3 from, in vec3 norm, in uvec3 seed ) {\n    \n    vec3 pos = vec3(0);\n    vec4 diff = vec4(0);\n    vec3 dummyNorm = vec3(0);\n    \n    // create a random dir in a hemisphere\n    vec3 rand = hash(seed);\n    float dirTemp1 = 2.0*PI*rand.x;\n    float dirTemp2 = sqrt(1.0-rand.y*rand.y);\n    vec3 dir = vec3(\n        cos(dirTemp1)*dirTemp2,\n        sin(dirTemp1)*dirTemp2,\n        rand.y);\n    dir.y = abs(dir.y);\n    \n    // pick the sun more often (priority sampling)\n    const float sunContrib = colorSun.a*2.0*PI*(1.0 - sunCosAngle);\n    const float ambientContrib = colorAmbient.a*2.0*PI;\n    const float groundContrib = colorGround.a*2.0*PI;\n    const float sumContrib = sunContrib+ambientContrib+groundContrib;\n    \n    float a = sunContrib / sumContrib;\n    float b = a + ambientContrib / sumContrib;\n    \n    if (rand.z < a) {\n        const vec3 sunDirTan = normalize(cross(sunDir, vec3(0, 0, 1)));\n        const vec3 sunDirCoTan = cross(sunDir, sunDirTan);\n        float rot = 2.0*PI*rand.x;\n        float the = acos(1.0 - rand.y*(1.0 - cos(sunAngle)));\n        float sinThe = sin(the);\n        dir = sunDirTan*sinThe*cos(rot) + sunDirCoTan*sinThe*sin(rot) - sunDir*cos(the);\n    } else if (rand.z < b) {\n        dir.z = abs(dir.z);\n    } else {\n        dir.z = -abs(dir.z);\n    }\n    \n    if (trace(from, dir, false, pos, dummyNorm, diff)) {\n        vec3 back = getBackground(dir);\n        vec3 color = back.rgb * diff.rgb * (1.0 - diff.a);\n        float l = dot(norm, norm) > 0.0 ? max(0.0, dot(dir, norm)) : 1.0;\n        return color*l*sumContrib;\n    } else {\n        return vec3(0);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // initialize color\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    if (iFrame == 0 || iMouse.z > 0.0) fragColor = vec4(0);\n    \n    // decouple rendering, it can get a bit unresponsive\n  \tvec2 gridSize = vec2(256, 256); // increase these number if you have a good GPU\n    vec2 gridCount = floor(iResolution.xy / gridSize) + 1.0;\n    vec2 inGrid = floor(fragCoord.xy / gridSize);\n    float gridPos = inGrid.x + inGrid.y * gridCount.x;\n    float gridPosMax = gridCount.x*gridCount.y;\n    if ( mod(float(iFrame), gridPosMax) != gridPos ) return;\n    \n    \n    // seed\n    uvec3 seed = uvec3(fragCoord.xy, iFrame*20);\n    vec3 rand = hash(seed);\n    \n    // cylindrical projection\n    vec2 alias = rand.xy - 0.5;\n    vec2 uv = (fragCoord.xy+alias) / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    float theta = (PI*0.5 + uv.x)*1.5;\n    vec2 dirPos = vec2(cos(theta), sin(theta));\n\tvec3 dir = normalize(vec3(dirPos.xy, uv.y*1.8));\n\tdir.xy *= rot(1.2);\n    \n    vec3 from = vec3(-0.1, -0.5, 0.5);\n    \n    // find the first position\n    vec3 pos = vec3(0);\n    vec3 norm = vec3(0);\n    vec4 diff = vec4(0);\n    vec3 color = vec3(0);\n    if (trace(from, dir, true, pos, norm, diff)) {\n        // direct lighting\n        color += diff.rgb*(1.0-diff.a)*1.5;\n    }\n    \n    // add light from the sun/sky\n    pos += norm*0.001;\n    vec3 sunLight = traceLight(pos, norm, seed+uvec3(0, 0, 1));\n\tcolor += diff.rgb * sunLight.rgb;\n    \n    // add volumetrics\n    vec3 posVol = from + (pos-from)*rand.z;\n    vec3 sunLightVol = traceLight(posVol, vec3(0), seed+uvec3(0, 0, 2));\n    color += sunLightVol*0.1; // super fake (the fog is emissive)\n    \n    // do bounces (increase this loop if you have a good GPU)\n    vec3 acc = diff.rgb;\n    for (int i = Z ; i < 4 ; i++) {\n        vec3 normTan = normalize(cross(norm, vec3(1, PI, PHI)));\n        vec3 normCoTan = cross(norm, normTan);\n        vec3 rand = hash(seed+uvec3(0, 0, 3+2*i));\n        float rot = 2.0*PI*rand.x;\n        float the = acos(sqrt(rand.y));\n        float sinThe = sin(the);\n        vec3 bounceDir = normTan*sinThe*cos(rot) + normCoTan*sinThe*sin(rot) + norm*cos(the);\n\n        trace(pos, bounceDir, true, pos, norm, diff);\n        vec3 bounceLight = traceLight(pos + norm*0.001, norm, seed+uvec3(0, 0, 3+2*i+1));\n        acc *= diff.rgb; // color keep getting absorbed\n        color += acc * bounceLight;\n    }\n    \n    // accumulate color\n    fragColor.rgb += color;\n    fragColor.a += 1.0;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}