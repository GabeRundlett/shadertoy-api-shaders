{
    "Shader": {
        "info": {
            "date": "1488578485",
            "description": "multi-scale blurring for Buf A and Buf B, volume binning (bass, mid, treb), read and write 1024 data cells in a subregion in Buf D with an index\n\nhttps://soundcloud.com/rumpistol/forest-drops\n\n",
            "flags": 96,
            "hasliked": 0,
            "id": "4sfyzS",
            "likes": 14,
            "name": "soundcloud beatdetect slingshot",
            "published": 3,
            "tags": [
                "multiscaleblur",
                "volumebinning",
                "dataarray"
            ],
            "usePreview": 0,
            "username": "Flexi",
            "viewed": 1716
        },
        "renderpass": [
            {
                "code": "vec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec4 vol(int t){\n    float lo = bass(t, iChannel3);\n    float mi = mid(t, iChannel3);\n    float hi = treb(t, iChannel3);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level)\n{\n    return spectrum2D(uv, thickness, level, iChannel3);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    return BlurB(uv, level, iChannel1, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    fragColor = vec4(0);\n    fragColor =  mix(fragColor, vec4(0.1), spectrum2D(uv, 0.05, 0));\n    fragColor =  mix(fragColor, vec4(0.2), spectrum2D(uv, 0.04, 1));\n    fragColor =  mix(fragColor, vec4(0.3), spectrum2D(uv, 0.03, 2));\n    fragColor =  mix(fragColor, vec4(0.5), spectrum2D(uv, 0.02, 3));\n    fragColor =  mix(fragColor, vec4(0.8), spectrum2D(uv, 0.01, 4));\n    fragColor = mix(fragColor*0., vec4(1), rainbowSpectra(uv, iChannel3));\n//    fragColor = vec4(spectrum(uv.x, 0, 3));\n//    fragColor =  mix(fragColor, vec4(1), texture(iChannel3, uv)); // blur level stack\n\n//    fragColor = Cell(2);\n//    fragColor = texture(iChannel2, uv); // see, the upper right quarter is not used yet\n//    fragColor = vec4(1.) * BlurA(uv, 0).z; // single channel\n\n    vec4 rnd0 = Cell(10);\n    vec4 rnd1 = Cell(11);\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\tvec4 beat_residual = Cell(4);\n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n\n    float c1 = smoothcircle(uv - aspect.yx*0.5 + rnd1.xy*aspect.yx, aspect, 0.03, 600.);\n    float c2 = smoothcircle(uv - aspect.yx*0.5 + rnd0.xy*aspect.yx, aspect, 0.015, 800.);\n    float c3 = smoothcircle(uv - aspect.yx*0.5 + mix(rnd0.xy, rnd1.xy, beat_relative)*aspect.yx, aspect, 0.005, 1400.);\n\n    vec4 vol = Cell(9);\n    float beat = vol.x;\n\tvec4 C12 = Cell(12);\n\tvec4 C13 = Cell(13);\n    vec2 p_bass = C12.xy;\n    vec2 p_mid = C12.zw;\n    vec2 p_treb = C13.xy;\n    vec2 p_vol = C13.zw;\n    \n\tfloat c4 = smoothcircle(uv - aspect.yx*0.5 + p_bass*aspect.yx, aspect, 0.0025, 800.);\n    float c5 = smoothcircle(uv - aspect.yx*0.5 + p_mid*aspect.yx, aspect, 0.0025, 800.);\n    float c6 = smoothcircle(uv - aspect.yx*0.5 + p_treb*aspect.yx, aspect, 0.0025, 800.);\n    \n    float c8 = smoothcircle(uv, aspect, 0.25, 800.);\n    \n    fragColor *= (1.-beat_relative)*0.75+0.25;\n    \n    fragColor =  mix(fragColor, vec4(0.5), mix(BlurB(uv, 1).x*0.5, BlurB(uv, 0).x, c8*0.75));\n    fragColor =  mix(fragColor, vec4(1), c8*0.166);\n    fragColor =  mix(fragColor, vec4(1.15), BlurB(uv, 0).y*0.66);\n    fragColor =  mix(fragColor, vec4(1), BlurA(uv, 0) - BlurB(uv, 2).y*1.33);\n    fragColor =  mix(fragColor, vec4(1.-c8), c1*0.5);\n    fragColor =  mix(fragColor, vec4(1.-c8), c2*0.66);\n    fragColor =  mix(fragColor, vec4(1.-c8), c3*0.75);\n    fragColor =  mix(fragColor, vec4(1,1,0,0), c6);\n    fragColor =  mix(fragColor, vec4(1,0,1,0), c4);\n    fragColor =  mix(fragColor, vec4(0,1,1,0), c5);\n    \n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    \n    float c_p1 = smoothcircle(uv - aspect.yx*0.5 + p1.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p2 = smoothcircle(uv - aspect.yx*0.5 + p2.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p3 = smoothcircle(uv - aspect.yx*0.5 + p3.xy*aspect.yx, aspect, 0.0025, 800.);\n    \n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_p1);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_p2);\n    fragColor =  mix(fragColor, vec4(0,1,0,0), c_p3);    \n  \n    fragColor =  mix(fragColor, fragColor*vec4(2.,1.,0,0), beat*0.);\n    \n    //fragColor = BlurB(uv, 0);\n\n    // blur level stack\n\t//fragColor =  mix(fragColor*0., vec4(1), texture(iChannel3, uv));\n    \n    // bypass\n    // fragColor = BlurA(uv, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_size = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixel_size;\n    vec4 noise = (texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime))-0.5)*2.;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    \n    vec2 pixelSize = 1./iResolution.xy;\n    vec2 mouseV = mouseDelta(iResolution, iMouse, iChannel3);\n    \n    vec4 C18 = Cell(18, iChannel3);\n        \n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1., iResolution);\n    uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw*4., iResolution);\n    \n    fragColor = BlurA( 0.5 + (uv - 0.5)*vec2(1.006,1.) + vec2(2,0)*pixelSize + vec2(0,iTime*0.0), 0, iChannel0, iChannel3)*1.0- 0./256.;\n    \n    vec4 v0 = Cell(0, iChannel3);\n    vec4 v1 = Cell(1, iChannel3);\n    vec4 v3 = Cell(3, iChannel3);\n    vec2 uv_v0 =vec2(0.95, v0.w);\n    vec2 uv_v3 =vec2(0.95, v3.w*4. + 0.25);\n    vec4 beat_residual = Cell(4, iChannel3);\n    float energy = (v0.w - v1.w);\n    vec2 uv_v1 =vec2(0.95, energy +0.05);\n    if(uv.x >= 0.95 - 1./256.){\n        fragColor.z = Cell(9, iChannel3).x;\n    }\n    fragColor = mix(fragColor, vec4(0,1,0,0), circle(uv - uv_v0+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,0,0,0), circle(uv - uv_v1+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,1,0), circle(uv - uv_v3+0.5, aspect, 256.));\n\n    vec2 uv_v4 =vec2(0.95, beat_residual.w*0.5);\n    fragColor = mix(fragColor, vec4(0,1,1,0), circle(uv - uv_v4+0.5, aspect, 256.));\n\n    vec4 last_beat_min = Cell(7, iChannel3);\n    vec4 last_beat_max = Cell(8, iChannel3);\n\n    vec2 uv_lo =vec2(0.95, last_beat_min.w*0.5);\n    vec2 uv_hi =vec2(0.95, last_beat_max.w*0.5);\n\n    fragColor = mix(fragColor, vec4(1,0,1,0), circle(uv - uv_lo+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,0,0), circle(uv - uv_hi+0.5, aspect, 256.));\n\n    vec4 vol = Cell(9, iChannel3);\n    float beat = vol.x;\n\tvec4 C12 = Cell(12, iChannel3);\n\tvec4 C13 = Cell(13, iChannel3);\n    vec2 p_bass = C12.xy;\n    vec2 p_mid = C12.zw;\n    vec2 p_treb = C13.xy;\n    vec2 p_vol = Cell(17, iChannel3).xy;\n    \n\tfloat c4 = smoothcircle(uv - aspect.yx*0.5 + p_bass*aspect.yx, aspect, 0.0025, 800.);\n    float c5 = smoothcircle(uv - aspect.yx*0.5 + p_mid*aspect.yx, aspect, 0.0025, 800.);\n    float c6 = smoothcircle(uv - aspect.yx*0.5 + p_treb*aspect.yx, aspect, 0.0025, 800.);\n    float c7 = smoothcircle(uv - aspect.yx*0.5 + Cell(17, iChannel3).xy*aspect.yx, aspect, 0.0025, 800.);    \n    float c8 = smoothcircle(uv - aspect.yx*0.5 + C18.xy*aspect.yx, aspect, 0.0025, 800.);    \n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n    \n    //fragColor *= beat_relative;\n    //fragColor =  mix(fragColor, vec4(.45), mix(BlurA(uv, 1).x*0.175, BlurA(uv, 0).x*0.1, c8*0.75));\n    //fragColor =  mix(fragColor, vec4(1), BlurA(uv, 0)*0.);\n    fragColor =  mix(fragColor, vec4(1,1,0,0), c6);\n    fragColor =  mix(fragColor, vec4(1,0,1,0), c4);\n    fragColor =  mix(fragColor, vec4(0,1,1,0), c5);\n//    fragColor =  mix(fragColor, vec4(1.), c7);\n    fragColor =  mix(fragColor, vec4(1), c8);\n    \n    vec4 p1 = Cell(14, iChannel3);\n    vec4 p2 = Cell(15, iChannel3);\n    vec4 p3 = Cell(16, iChannel3);\n    vec4 volume = Cell(19, iChannel3);\n    \n    float c_p1 = circle(uv - aspect.yx*0.5 + p1.xy*aspect.yx, aspect, 128.);\n    float c_p2 = circle(uv - aspect.yx*0.5 + p2.xy*aspect.yx, aspect, 128.);\n    float c_p3 = circle(uv - aspect.yx*0.5 + p3.xy*aspect.yx, aspect, 128.);\n    \n    float c_bass = circle(uv - vec2(0.8,-0.4 + volume.x*0.01)*aspect.yx, aspect, 256.);\n    float c_mid = circle(uv - vec2(0.8,-0.4 + volume.y*0.01)*aspect.yx, aspect, 256.);\n    float c_treb = circle(uv - vec2(0.8,-0.4 + volume.z*0.01)*aspect.yx, aspect, 256.);\n    float c_vol = circle(uv - vec2(0.8,-0.4 + volume.w*0.01)*aspect.yx, aspect, 256.);\n    \n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_p1);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_p2);\n    fragColor =  mix(fragColor, vec4(.35,1,0,0), c_p3);\n\n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_bass);\n    fragColor =  mix(fragColor, vec4(0,1,0,0), c_mid);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_treb);\n    fragColor =  mix(fragColor, vec4(1,1,1,0), c_vol);\n    \n    fragColor =  mix(fragColor, vec4(0,0,0,0), border(uv, 0.04));\n    \n    fragColor = clamp(fragColor, 0., 1.);\n  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n\n    if(iFrame<16)\n    {\n        fragColor = noise;\n        return;\n    }\n    \n    //uv = 0.5 + (uv - 0.5)*0.99;\n    vec2 pixelSize = 1./iResolution.xy;\n    vec2 mouseV = mouseDelta(iResolution, iMouse, iChannel3);\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1., iResolution);\n\n    vec4 C18 = Cell(18, iChannel3);\n    uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw*4., iResolution);\n\n    float c8 = smoothcircle(uv, aspect, 0.25, 256.);\n\n    float time = iTime;\n   \tuv = uv + (1.-c8)*vec2(sin(time*0.1 + uv.x*2. +1.) - sin(time*0.214 + uv.y*2. +1.), sin(time*0.168 + uv.x*2. +1.) - sin(time*0.115 +uv.y*2. +1.))*pixelSize*0.5;\n\n    //uv = 0.5 + (uv - 0.5)*0.99;\n    float w = - time*4.*asin(1.)/60.;\n    vec2 rot_uv = 0.5 + complex_mul((uv-0.5)*aspect*1.618, vec2(cos(w),-sin(w)))/aspect;\n\n    fragColor.x = BlurB(mix(uv, rot_uv, c8), 0, iChannel1, iChannel3).x;\n    fragColor.x += ((BlurB(uv, 1, iChannel1, iChannel3).x - BlurB(uv, 2, iChannel1, iChannel3).x)*1.5 + (noise.x-0.5) * 0.04); \n\n    vec2 rot = vec2(sin(w),-cos(w));\n    \n    fragColor.y = smoothcircle(uv - 6./32.*rot/aspect, aspect, 1./16. + Cell(9, iChannel3).x*0.05, 128.);\n    float l = 3.;\n    vec2 o = vec2(0.33, 0.26);\n    float angle = -asin(1.)/1.5;\n    vec2 rot_left = vec2(cos(angle),-sin(angle));\n    vec2 uv_left = 0.5 + complex_mul((uv - 0.5)*aspect*l + rot90(rot)*o.x - rot*o.y, rot_left)/aspect;\n    angle *= -1.;\n    vec2 uv_right = 0.5 + complex_mul((uv - 0.5)*aspect*l - rot90(rot)*o.x - rot*o.y, vec2(cos(angle),-sin(angle)))/aspect;\n    vec2 uv_main = 0.5 + (uv - 0.5)*(1.33) + aspect.yx*rot*0.166;\n    float square_left = unit_square(uv_left, aspect);\n    float square_right = unit_square(uv_right, aspect);\n    fragColor.y = mix(fragColor.y, 1., unit_square(uv_main, aspect)*BlurB(uv_main, 0, iChannel1, iChannel3).y - 1./256.);\n    fragColor.y = mix(fragColor.y, 1., square_left*BlurB(uv_left, 0, iChannel1, iChannel3).y);\n    fragColor.y = mix(fragColor.y, 1., square_right*BlurB(uv_right, 0, iChannel1, iChannel3).y);\n\n    float c = circle(uv, aspect, 1./8.);\n    fragColor.z = square_right*0.;\n    \n//    fragColor.x = 0.;\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n   // fragColor = noise; // reset\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// resolution reduction and horizontal blur\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel3, uv1) * 0.05;\n    sum += texture(iChannel3, uv2) * 0.09;\n    sum += texture(iChannel3, uv3) * 0.12;\n    sum += texture(iChannel3, uv4) * 0.15;\n    sum += texture(iChannel3, uv5) * 0.16;\n    sum += texture(iChannel3, uv6) * 0.15;\n    sum += texture(iChannel3, uv7) * 0.12;\n    sum += texture(iChannel3, uv8) * 0.09;\n    sum += texture(iChannel3, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// vertical blur (second pass)\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            uv1 = upper_left(uv1);\n            uv2 = upper_left(uv2);\n            uv3 = upper_left(uv3);\n            uv4 = upper_left(uv4);\n            uv5 = upper_left(uv5);\n            uv6 = upper_left(uv6);\n            uv7 = upper_left(uv7);\n            uv8 = upper_left(uv8);\n            uv9 = upper_left(uv9);\n        }\n        else\n        {\n            uv1 = lower_left(uv1);\n            uv2 = lower_left(uv2);\n            uv3 = lower_left(uv3);\n            uv4 = lower_left(uv4);\n            uv5 = lower_left(uv5);\n            uv6 = lower_left(uv6);\n            uv7 = lower_left(uv7);\n            uv8 = lower_left(uv8);\n            uv9 = lower_left(uv9);\n        }\n    }\n    else\n    {\n        vec2 uv_s = upper_right(uv*2.)*2.;\n        uv1 = clamp(vec2(uv_s.x, uv_s.y - 4.0*v), 0., 1.);\n        uv2 = clamp(vec2(uv_s.x, uv_s.y - 3.0*v), 0., 1.);\n        uv3 = clamp(vec2(uv_s.x, uv_s.y - 2.0*v), 0., 1.);\n        uv4 = clamp(vec2(uv_s.x, uv_s.y - 1.0*v), 0., 1.);\n        uv5 = clamp(vec2(uv_s.x, uv_s.y + 0.0*v), 0., 1.);\n        uv6 = clamp(vec2(uv_s.x, uv_s.y + 1.0*v), 0., 1.);\n        uv7 = clamp(vec2(uv_s.x, uv_s.y + 2.0*v), 0., 1.);\n        uv8 = clamp(vec2(uv_s.x, uv_s.y + 3.0*v), 0., 1.);\n        uv9 = clamp(vec2(uv_s.x, uv_s.y + 4.0*v), 0., 1.);\n        depth--;\n        uv1 = upper_right(uv1);\n        uv2 = upper_right(uv2);\n        uv3 = upper_right(uv3);\n        uv4 = upper_right(uv4);\n        uv5 = upper_right(uv5);\n        uv6 = upper_right(uv6);\n        uv7 = upper_right(uv7);\n        uv8 = upper_right(uv8);\n        uv9 = upper_right(uv9);\n    }\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n    if(uv.x > 0.5 && uv.y > 0.5)\n    {\n        //return vec4(0);\n        sum += texture(iChannel3, uv1) * 0.05;\n        sum += texture(iChannel3, uv2) * 0.09;\n        sum += texture(iChannel3, uv3) * 0.12;\n        sum += texture(iChannel3, uv4) * 0.15;\n        sum += texture(iChannel3, uv5) * 0.16;\n        sum += texture(iChannel3, uv6) * 0.15;\n        sum += texture(iChannel3, uv7) * 0.12;\n        sum += texture(iChannel3, uv8) * 0.09;\n        sum += texture(iChannel3, uv9) * 0.05;\n    }\n    else\n    {\n        sum += texture(iChannel2, uv1) * 0.05;\n        sum += texture(iChannel2, uv2) * 0.09;\n        sum += texture(iChannel2, uv3) * 0.12;\n        sum += texture(iChannel2, uv4) * 0.15;\n        sum += texture(iChannel2, uv5) * 0.16;\n        sum += texture(iChannel2, uv6) * 0.15;\n        sum += texture(iChannel2, uv7) * 0.12;\n        sum += texture(iChannel2, uv8) * 0.09;\n        sum += texture(iChannel2, uv9) * 0.05;\n    }\n    return sum/0.98; // normalize\n}\n\n\nvoid set_cell(inout vec4 bufD, vec2 uv, int index, vec4 value)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n\n\n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n\n    // store\n    if(abs(uv - center).x <= cell_size.x*0.5 && abs(uv - center).y <= cell_size.y*0.5)\n    {\n        bufD = value;\n    }\n}\n\nvoid spring(float force, inout vec4 p1, inout vec4 p2) {\n    vec2 f = (p2.xy-p1.xy) * force;\n    p1.zw += f;\n    p2.zw -= f;\n}\n\nvoid resist(float friction, inout vec4 p){\n    friction = max(0., 1. - length(p.zw)*friction);\n    p.zw *= friction;\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec4 vol(int t){\n    float lo = bass(t, iChannel3);\n    float mi = mid(t, iChannel3);\n    float hi = treb(t, iChannel3);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_size = 1./iResolution.xy;\n    vec2 uv = fragCoord.xy * pixel_size;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }\n        uv_half = fract(uv_orig*2.);\n\n        if(uv_orig.y > 0.5)\n        {\n            if(uv_half.x < pixel_size.x *128.)\n            {\n                fragColor = texture(iChannel1, uv_half.yx);\n            }else{\n                fragColor = texture(iChannel3, uv_orig - vec2(64.,0.) * pixel_size);\n                //fragColor = vec4(0);\n            }\n        }\n    }\n\n    // \n    vec4 v0 = vol(0, iChannel3);\n    vec4 v0_prev = Cell(20);\n    vec4 v1 = vol(1);\n\n    set_cell(fragColor, uv, 0, v0);\n    set_cell(fragColor, uv, 1, v1);\n    set_cell(fragColor, uv, 2, vec4(iMouse.xy * pixel_size, iMouse.zw * pixel_size));\n\n    vec4 v2 = vol(2);\n    vec4 attack = v2 + v0 - 2.*v1;\n    set_cell(fragColor, uv, 3, attack);\n\n    vec4 old_beat_residual = Cell(4);\n    vec4 beat_residual = old_beat_residual*0.96 + max(attack*4., 0.);\n    set_cell(fragColor, uv, 4, beat_residual);\n    set_cell(fragColor, uv, 5, old_beat_residual);\n\n    attack = beat_residual - old_beat_residual;\n    set_cell(fragColor, uv, 6, attack );\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n    \n    float frames_since_last_beat = Cell(9).y;\n    bool beat = (v0.w-v0_prev.w)*2. > 4./frames_since_last_beat;// || ((last_beat_min.w < 0.01) && attack.w > 0.05) || ((frames_since_last_beat > 120.) && attack.w > 0.15);\n    beat = beat && (frames_since_last_beat > 15.);\n    \n    vec4 noise = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy + fract(vec2(42,56)*iTime));\n\n    if(beat)\n    {\n        set_cell(fragColor, uv, 7, old_beat_residual);\n        set_cell(fragColor, uv, 8, beat_residual);\n        set_cell(fragColor, uv, 11, Cell(10));\n        set_cell(fragColor, uv, 10, noise);\n        frames_since_last_beat = 1.;\n    }\n    else\n    {\n        set_cell(fragColor, uv, 7, min(last_beat_min, beat_residual));\n        set_cell(fragColor, uv, 8, max(last_beat_max, beat_residual));\n        set_cell(fragColor, uv, 10, Cell(10));\n        set_cell(fragColor, uv, 11, Cell(11));\n        frames_since_last_beat += 1.;\n    }\n\n    set_cell(fragColor, uv, 9, vec4(beat, frames_since_last_beat, 0, 0));\n    \n    vec4 vol = vol(0);\n    float r = - iTime*4.*asin(1.)/60.;;\n    float w = asin(1.)*0./3. + r;\n    vec4 p_bass = vec4(0.5 + sin(w)*vol.x, 0.5 - cos(w)*vol.x, 0, 0);\n    w = asin(1.)*4./3. + r;\n    vec4 p_mid = vec4(0.5 + sin(w)*vol.y, 0.5 - cos(w)*vol.y, 0, 0);\n    w = -asin(1.)*4./3. + r;\n    vec4 p_treb = vec4(0.5 + sin(w)*vol.z, 0.5 - cos(w)*vol.z, 0, 0);\n    vec4 p_vol = (p_bass + p_mid + p_treb)/3.;\n    \n    set_cell(fragColor, uv, 12, vec4(p_bass.xy, p_mid.xy));\n    set_cell(fragColor, uv, 13, vec4(p_treb.xy, p_vol.xy));\n    \n    // p_.xy = pos, p_.zw = velocity\n    \n    vec4 p0 = Cell(17);\n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = Cell(18);\n    \n    float force = 0.005;\n    float friction = 0.05;\n    float speed = 4.;\n    float grav = 0.0003*0.;\n    \n    float impactfactor = 0.33;\n    spring(force * impactfactor, p0, p_bass);\n    spring(force * impactfactor, p0, p_mid);\n    spring(force * impactfactor, p0, p_treb);\n    spring(force, p0, p1);\n    spring(force, p1, p2);\n    spring(force, p2, p3);\n    spring(force, p3, p4);\n    \n    resist(friction, p0);\n    resist(friction, p1);\n    resist(friction, p2);\n    resist(friction, p3);\n    resist(friction, p4);\n    \n    p1.w += grav;\n    p2.w += grav;\n    p3.w += grav;\n    p4.w += grav;\n    \n    \n    // Verlet integration\n    p0.xy += p0.zw * speed;\n    p1.xy += p1.zw * speed;\n    p2.xy += p2.zw * speed;\n    p3.xy += p3.zw * speed;\n    p4.xy += p4.zw * speed;\n    \n    if(iFrame < 2){\n\t    p0.xy = p_vol.xy;\n\t    p1.xy = p_vol.xy;\n    \tp2.xy = p_vol.xy;\n    \tp3.xy = p_vol.xy;\n    \tp4.xy = p_vol.xy;\n    }\n\n    set_cell(fragColor, uv, 17, p0);\n    set_cell(fragColor, uv, 14, p1);\n    set_cell(fragColor, uv, 15, p2);\n    set_cell(fragColor, uv, 16, p3);\n    set_cell(fragColor, uv, 18, p4);\n    \n    // integrate the volume\n    \n    vec4 volume = Cell(19)*0.85 + vol*16.;\n    \n    set_cell(fragColor, uv, 19, volume);\n    \n    // save last frame's vol(0)\n    \n    set_cell(fragColor, uv, 20, v0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 11995,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/rumpistol/forest-drops"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level, sampler2D bufA, sampler2D bufD)\n{\n    if(level <= 0)\n    {\n        return texture(bufA, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv);\n}\n\nvec4 BlurB(vec2 uv, int level, sampler2D bufB, sampler2D bufD)\n{\n    if(level <= 0)\n    {\n        return texture(bufB, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level, sampler2D bufA, sampler2D bufD){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level, bufA, bufD) - 0.5*BlurA(uv - vec2(1.,0.)*d, level, bufA, bufD);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level, bufA, bufD) - 0.5*BlurA(uv - vec2(0.,1.)*d, level, bufA, bufD);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level, sampler2D bufB, sampler2D bufD){\n    vec4 dX = 0.5*BlurB(uv + vec2(1.,0.)*d, level, bufB, bufD) - 0.5*BlurB(uv - vec2(1.,0.)*d, level, bufB, bufD);\n    vec4 dY = 0.5*BlurB(uv + vec2(0.,1.)*d, level, bufB, bufD) - 0.5*BlurB(uv - vec2(0.,1.)*d, level, bufB, bufD);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nfloat unit_square(vec2 uv, vec2 aspect){\n    uv = 0.5 + (uv - 0.5)/aspect.yx;\n    return (uv.x > 0. && uv.x < 1. && uv.y > 0. && uv.y < 1. ) ? 1. : 0.;\n}\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n    vec2 rot = vec2(cos(ang), sin(ang))*zoom;    \n    return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat unit_square(vec2 uv){\n\treturn float((uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.));\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp, vec3 iResolution)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16., iResolution) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp, iResolution);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.125;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate if they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)), iResolution);\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)), iResolution);\n    return (circle1 + circle2) / 2.;\n}\n \nfloat border(vec2 domain, float thickness){\n   vec2 uv = fract(domain-vec2(0.5));\n   uv = min(uv,1.-uv)*2.;\n   return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index, sampler2D bufD)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n    \n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n    \n    return texture(bufD, center);\n}\n\nvec2 mouseDelta(vec3 iResolution, vec4 iMouse, sampler2D bufD){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = Cell(2, bufD);\n    vec4 nowMouse = vec4(iMouse.xy * pixelSize.xy, iMouse.zw * pixelSize.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\n// sampling from spectrogram\n\nfloat spectrum(float domain, int t, int level, sampler2D bufD)\n{\n    float sixty_fourth = 1./32.;\n    vec2 uv = vec2(float(t)*3.*sixty_fourth + sixty_fourth, domain);\n    uv = upper_right(uv); level++;\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv).x;\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level, sampler2D bufD)\n{\n    float val = spectrum(uv.x, 0, level, bufD);\n    return (abs(uv.y - val) < thickness/2.) ? (1.-abs(uv.y - val)*2./thickness) : 0.;\n}\n\nvec4 rainbowSpectra(vec2 uv, sampler2D bufD)\n{\n    float thickness = 0.015;\n    // make this a loop?\n    vec4 spectra =         vec4(0.25,0,0.5,0)* spectrum2D(uv, thickness, 7, bufD);\n    spectra = mix(spectra, vec4(0.5,0,1.,0), spectrum2D(uv, thickness, 6, bufD));\n    spectra = mix(spectra, vec4(0,0.5,1,0), spectrum2D(uv, thickness, 5, bufD));\n    spectra = mix(spectra, vec4(0,1.,0.5,0), spectrum2D(uv, thickness, 4, bufD));\n    spectra = mix(spectra, vec4(1,1,0,0), spectrum2D(uv, thickness, 3, bufD));\n    spectra = mix(spectra, vec4(0.6,0.25,0,0), spectrum2D(uv, thickness, 2, bufD));\n    spectra = mix(spectra, vec4(0.85,0,0,0), spectrum2D(uv, thickness, 1, bufD));\n    spectra = mix(spectra, vec4(1), spectrum2D(uv, thickness, 0, bufD));\n    \n    return spectra*unit_square(uv);\n}\n\nfloat bass(int t, sampler2D bufD){\n    return spectrum(0.125, t, 3, bufD);\n}\n\nfloat mid(int t, sampler2D bufD){\n    return spectrum(0.5, t, 3, bufD);\n}\n\nfloat treb(int t, sampler2D bufD){\n    return spectrum(0.875, t, 3, bufD);\n}\n\nvec4 vol(int t, sampler2D bufD){\n    float lo = bass(t, bufD);\n    float mi = mid(t, bufD);\n    float hi = treb(t, bufD);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nvec4 BlurSpectrogram(vec2 uv, int level, sampler2D bufD)\n{\n    uv = upper_right(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv); // Buf D in Texture C\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}