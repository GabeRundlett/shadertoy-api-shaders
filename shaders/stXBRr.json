{
    "Shader": {
        "info": {
            "date": "1650459126",
            "description": "Spring Mass System test",
            "flags": 32,
            "hasliked": 0,
            "id": "stXBRr",
            "likes": 12,
            "name": "Spring Mass System",
            "published": 3,
            "tags": [
                "physics",
                "spring"
            ],
            "usePreview": 0,
            "username": "lasoy",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "#define P_COLOR 1.0\n#define DC_COLOR 2.0\n#define AC_COLOR 3.0\n#define BOUNDS_COLOR 4.0\n\nvec2 getInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));\n    info.xy = info.xy * 2. - 1.;\n    \n    return info.xy;\n}\n\nvec2 opU( vec2 d1, float d2, float material )\n{\n    return (d1.x<d2) ? d1 : vec2(d2, material);\n}\n\nvec2 map(vec2 p){\n    vec2 d = vec2(99999.9, 0);\n    for(int i = 0;i < P_COUNT;i ++) {\n       d = opU(d, sdCircle(p - getInfo(i), R), P_COLOR);\n    }\n\n    for(int i = 0;i < DC_COUNT;i ++) {\n      int a = int(dc[i][0]);\n      int b = int(dc[i][1]);\n      d = opU(d, sdSegment(p, getInfo(a).xy,  getInfo(b).xy), DC_COLOR);\n    }\n    \n    for(int i = 0;i < AC_COUNT;i ++) {\n      AC info = ac[i];\n      d = opU(d, sdSegment(p, getInfo(info.a).xy,  getInfo(info.b).xy), AC_COLOR);\n      d = opU(d, sdSegment(p, getInfo(info.b).xy,  getInfo(info.c).xy), AC_COLOR);\n    }\n    \n    d = opU(d, sdSegment(p, vec2(-1, -1), vec2(-1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(-1, 1), vec2(1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, 1), vec2(1, -1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, -1), vec2(1, 1)), BOUNDS_COLOR);\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float w = length(fwidth(uv)) * 5.0;\n    \n    vec2 d = map(uv);\n    float c = smoothstep(0.0, w, abs(d.x));\n    vec3 col = vec3(1.0-c);\n    if (d.y == P_COLOR) {\n      col *= vec3(.3, .9, .6);\n    } else if (d.y == DC_COLOR) {\n      col *= vec3(.3, .6, .9);\n    } else if (d.y == AC_COLOR) {\n      col *= vec3(.6, .9, .3);\n    } else if (d.y == BOUNDS_COLOR) {\n      col *= vec3(.5, .5, .5);\n    }\n\n    col = mix(col, vec3(1, 1, .95), c/4.0);\n\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653589793\n#define R .04\n#define STEP 0.1\nfloat friction = 0.9;\n\nstruct AC {\n    int a;\n    int b;\n    int c;\n    float angle;\n    float stiffness;\n};\n\n#define P_COUNT 16\nconst vec2 pos[P_COUNT] = vec2[P_COUNT](\n    vec2(0.5,0.85),\n    vec2(0.6172747223702044,0.79352347027881),\n    vec2(0.6462391868272735,0.6666218599065528),\n    vec2(0.5650825608676338,0.5648546698146371),\n    vec2(0.4349174391323663,0.5648546698146371),\n    vec2(0.35376081317272645,0.6666218599065528),\n    vec2(0.3827252776297955,0.79352347027881),\n    vec2(0.2,0.9),\n    vec2(0.28,0.9),\n    vec2(0.4,0.6),\n    vec2(0.47000000000000003,0.6),\n    vec2(0.54,0.6),\n    vec2(0.6100000000000001,0.6),\n    vec2(0.68,0.6),\n    vec2(0.75,0.6),\n    vec2(0.8200000000000001,0.6)\n);\n\n#define DC_COUNT 21\nconst vec4 dc[DC_COUNT] = vec4[DC_COUNT](\n    vec4(0,1,0.1301651217352674,0.5),\n    vec4(0,2,0.23454944474040898,0.5),\n    vec4(1,2,0.13016512173526748,0.5),\n    vec4(1,3,0.23454944474040895,0.5),\n    vec4(2,3,0.1301651217352674,0.5),\n    vec4(2,4,0.23454944474040895,0.5),\n    vec4(3,4,0.13016512173526745,0.5),\n    vec4(3,5,0.23454944474040898,0.5),\n    vec4(4,5,0.13016512173526745,0.5),\n    vec4(4,6,0.23454944474040898,0.5),\n    vec4(5,6,0.13016512173526748,0.5),\n    vec4(5,0,0.23454944474040898,0.5),\n    vec4(6,0,0.13016512173526745,0.5),\n    vec4(6,1,0.2345494447404089,0.5),\n    vec4(7,8,0.08000000000000002,0.5),\n    vec4(9,10,0.07,0.5),\n    vec4(10,11,0.07,0.5),\n    vec4(11,12,0.07000000000000006,0.5),\n    vec4(12,13,0.06999999999999995,0.5),\n    vec4(13,14,0.06999999999999995,0.5),\n    vec4(14,15,0.07000000000000006,0.5)\n);\n\n#define AC_COUNT 7\nconst AC ac[AC_COUNT] = AC[AC_COUNT](\n    AC(0,1,2,2.2439947525641384,0.9),\n    AC(1,2,3,2.243994752564138,0.9),\n    AC(2,3,4,2.243994752564138,0.9),\n    AC(3,4,5,2.2439947525641384,0.9),\n    AC(4,5,6,2.243994752564138,0.9),\n    AC(5,6,0,2.243994752564138,0.9),\n    AC(6,0,1,2.2439947525641375,0.9)\n);\n\n#define PC_COUNT 3\nconst vec3 pc[PC_COUNT] = vec3[PC_COUNT](\n    vec3(7,0.2,0.9),\n    vec3(9,0.4,0.6),\n    vec3(15,0.8200000000000001,0.6)\n);\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 getPInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));    \n    return info;\n}\n\nvoid bounds(inout vec4 info) {\n    float min = R/2.0;\n    float max = 1.0 - R/2.0;\n\n    if (info.x < min) {\n        info.x = min;\n    } else if (info.x > max) {\n        info.x = max;\n    }\n\n    if (info.y < min) {\n        info.y = min;\n    } else if (info.y > max) {\n        info.y = max;\n    }\n}\n\nvoid relaxDC(int index, inout vec4 color) {\n  for(int i = 0;i < DC_COUNT;i ++) {\n    vec4 info = dc[i];\n    int a = int(info[0]);\n    int b = int(info[1]);\n    float dist = info[2];\n    float stiffness = info[3];\n\n    if (a == index || b == index) {\n      vec2 d;\n      if(a == index) {\n        d = color.xy - getPInfo(b).xy;\n      } else {\n        d = getPInfo(a).xy - color.xy;\n      }\n      d = getPInfo(a).xy - getPInfo(b).xy;\n      float m = dot(d, d);\n      d *=((dist*dist - m)/m)*stiffness*0.5;\n      if (a == index) {\n        color.xy += d;\n      } else if(b == index) {\n        color.xy -= d;\n      }\n    }\n  }\n}\n\nvoid relaxPC(int index, inout vec4 color) {\n  for(int i = 0;i < PC_COUNT;i ++) {\n    vec3 info = pc[i];\n    if (int(info.x) == index) {\n      color.xy = info.yz;\n    }\n  }\n}\n\nvoid rotate(inout vec2 pos, vec2 origin, float angle) {\n  vec2 offset = pos - origin;\n  float c = cos(angle);\n  float s = sin(angle);\n  pos.x = origin.x + offset.x * c - offset.y * s;\n  pos.y = origin.y + offset.x * s + offset.y * c;\n}\n\nvoid relaxAC(int index, inout vec4 color) {\n  for(int i = 0;i < AC_COUNT;i ++) {\n    AC info = ac[i];\n    if (info.a == index || info.b == index || info.c == index) {\n      vec2 aPos;\n      vec2 bPos;\n      vec2 cPos;\n      if (info.a == index) {\n        aPos = color.xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = getPInfo(info.c).xy;\n      } else if (info.b == index) {\n        aPos = getPInfo(info.a).xy;\n        bPos = color.xy;\n        cPos = getPInfo(info.c).xy;\n      } else {\n        aPos = getPInfo(info.a).xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = color.xy;\n      }\n      vec2 l = aPos-bPos;\n      vec2 r = cPos-bPos;\n\n      float diff = atan(l.x * r.y - l.y * r.x, dot(l,r)) - info.angle;\n      \n      if (diff <= -PI)\n        diff += 2.0 * PI;\n      else if (diff >= PI)\n        diff -= 2.0 * PI;\n\n      diff *= STEP * info.stiffness;\n      rotate(aPos, bPos, diff);\n      rotate(cPos, bPos, -diff);\n      rotate(bPos, aPos, diff);\n      rotate(bPos, cPos, -diff);\n      if (info.a == index) {\n        color.xy = aPos;\n      } else if(info.b == index) {\n        color.xy = bPos;\n      } else if(info.c == index) {\n        color.xy = cPos;\n      }   \n    }\n  }\n}\n\nvoid relaxMouse(int index, inout vec4 color) {\n  if (iMouse.z > 0.) {\n    vec2 target = getPInfo(index).xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x = (mouse.x - 0.5)*iResolution.x/iResolution.y + 0.5;\n    float l = dot(mouse - target, mouse - target);\n\n    if (l < R*R) {\n      color.xy = mouse;\n    }\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord;\n    int col = int(uv.x);\n    int row = int(uv.y);\n    \n    col/=1;\n \n    if (col >= P_COUNT || row > 0) {\n        return;\n    }\n\n    vec4 color = getPInfo(col);\n    \n    if (iFrame == 0) {\n        color.xy = pos[col];\n        color.zw = color.xy;\n    } else {\n        vec2 v = color.xy - color.zw;\n        v *= friction;\n        vec2 g = vec2((sin(iTime*1.))*0.01, (cos(iTime*1.5))*0.01);\n        v += g;\n        \n        color.zw = color.xy;\n        color.xy += v;\n        \n        relaxAC(col, color);\n        relaxDC(col, color);\n        relaxMouse(col, color);\n        relaxPC(col, color);\n        bounds(color);\n    }\n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}