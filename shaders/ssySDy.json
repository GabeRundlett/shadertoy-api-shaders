{
    "Shader": {
        "info": {
            "date": "1635210272",
            "description": "Raymarching in sliced  blob chain of balls and  point lights",
            "flags": 0,
            "hasliked": 0,
            "id": "ssySDy",
            "likes": 5,
            "name": "Blob chain",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield",
                "blob",
                "ball",
                "kerning"
            ],
            "usePreview": 0,
            "username": "op",
            "viewed": 344
        },
        "renderpass": [
            {
                "code": "\nconst vec3 g_lightDir = normalize(vec3(-1.0, 0.6, -1.0));\nconst vec3 g_bakLightDir = normalize(vec3(1.0, -0.7, 1.5));\n\nconst float g_tg = 0.98; // point light trigger\n\n// ------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n#define saturate(_a) clamp(_a, 0.0,1.0)\n\n\nfloat hash13(ivec3 p)\n{\n    vec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// from IQ\nvec3 hash33( uvec3 x )\n{\n    const uint k = 1103515245U;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash33( ivec3 x )\n{\n    return hash33( uvec3(x) );\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n\n// smin for 2 components, driven by first one(distance)\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    h = h*h*0.25/k;\n    \n    \n    float g = (b.y-a.y)*h;\n    \n    \n    return a.x<b.x ? vec2(a.x-h, a.y+g) : vec2(b.x-h, b.y-g);    \n}\n\n\n#define RING_RADIUS 1.0\n#define RING_AMPLITUDE 1.0\n\nconst float distErr = max(0.0, sqrt(pow(RING_RADIUS+RING_AMPLITUDE,2.0)*2.0) - 1.5);\n\nvec2 map( in bool highOnly, in vec3 p )\n{\n\n    vec2 res = vec2(1000000.0, 1.0);\n\n    float s = 1.0;\n    p *= s;\n    \n\n    // animate smin\n    float sm = 0.01 + 0.99*max(0.0,sin(iTime*0.2));\n\n    // scan 3 rings of ball (left, center, right)\n    for(int i=-1; i<=1; i++)\n    {                                \n        vec3 f = fract(p);\n        f.y = p.y;\n        f.z = p.z;\n\n\n        vec3 cc = vec3(i,0,0);\n        vec3 cw = p-f + cc;\n        ivec3 bid = ivec3(cw);\n        cc += 0.5;// center\n\n        cc.y += RING_AMPLITUDE * sin( cw.x +  iTime*1.33);\n        cc.z += RING_AMPLITUDE * cos( cw.x +  iTime*1.23);\n\n\n        const int nb = 8;\n        float a = iTime*(1.17 + sin(cw.x*7.27) ); // twist !\n        for(int j=0; j<nb; j++, a+=2.0*3.14159/float(nb))\n        {\n            ivec3 id = bid; id.y += j;\n            vec3 hs = hash33( id );\n\n            float e = fract(hs.x+hs.z);  // random color scale                    \n            if(highOnly && e<g_tg) continue;\n\n            vec3 c=cc;\n            c.z += RING_RADIUS * cos(a) * (0.4 + 0.6*hs.y);\n            c.y += RING_RADIUS * sin(a) * (0.4 + 0.6*hs.z);\n\n            // Random radius\n            float r = 0.1 + 0.3*hs.x*(0.7 + 0.3*sin( (0.1 +hs.z*7.31) *  iTime));\n\n            // Random offset\n            float o = fract(hs.x+hs.y)*(1.0-2.0*r) - (0.5-r);                   \n            o *= 0.5 + 0.5*sin( (0.1 + hs.x*5.51)*iTime)*sin(iTime*(0.2 + 11.1*hs.y));\n            c.x += o;\n\n            // sdf\n            float d = length(f-c) - r;\n\n            res = smin(res, vec2(d, e), sm );\n\n            res.y = min(1.0, res.y);                                        \n        }\n\n        if(res.x<=0.0) break;\n    }\n    \n    res.x /= s;\n    \n    return res;\n}\n\n\n\nvec3 calcNormal(in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy,outside, MAP_DETAIL_STD ).x + \n       e.yyx*map( pos + e.yyx).x ) + \n       e.yxy*map( pos + e.yxy).x ) + \n       e.xxx*map( pos + e.xxx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(false, pos+0.001*e).x;\n    }\n    return normalize(n);\n\n#endif    \n}\n\n\nvec2 intersect(in float maxdist, in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0, 0);\n\n\n    float t = 0.0;\n\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( false, p );\n        \n        if( h.x<(0.0001*t) ||  t>maxdist ) return vec2(t, h.y);\n\n        // we should have perfect distance:\n        // but since we offset in a vertical slice, and only scan left&right neigboor,\n        // then we need to detect potentially over evaluated distances\n      \n        t+= h.x<=distErr ? h.x : max(distErr, h.x-distErr);\n\n    }\n\n    return vec2(maxdist, 0.0); //res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n\n    float tmax = 120.0;\n    \n    float t = 0.02;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(false, ro + rd*t ).x;\n          \n#if 1\n        res = min( res, 4.0*h/t );// soft\n#else        \n        if(t>0.1 && h<=0.0) return 0.0;// hard\n#endif        \n\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return max(.0, res );\n}\n\n\n\nfloat specular(vec3 ld, vec3 n, vec3 rd, float s)\n{\n    return pow( max(0.0, dot(reflect(ld,n), rd )), s);\n}\n\nfloat diffuse(vec3 ld, vec3 n)\n{\n    return saturate( dot(n , ld) );\n}\n\n\nvec3 background(vec3 p, vec3 n)\n{\n    return vec3(0.3,0.4,0.5)*0.3 * (0.5 + 0.5*dot(n,g_lightDir)  );\n}\n\nvec3 calcPointColor(float id)\n{\n    id = saturate( (id-g_tg)/(1.0-g_tg) );\n    float tm = iTime * ( 0.7 + 0.3*id);\n    \n    float tc = pow(sin(0.1*tm),2.0);\n    vec3 c1 = mix( 1.5*vec3(1.0,0.5 + tc ,0.0), 1.5*vec3(0.0, tc+0.5,tc*tc), tc );\n    \n    vec3 c2 = mix( 1.5*vec3(1.0,tc*2.0, 0.0), 1.5*vec3(1.0,0.0, tc), tc );\n        \n    tc = saturate( sin(tm*0.23)*4.0 );\n    \n    return mix(c1, c2, tc );       \n}\n\n\nvec3 render(in vec2 fragCoord, in vec3 ro, in vec3 rd, out float tt )\n{\n    float maxDist = 50.0;\n    vec2 t = intersect(maxDist, ro,rd);\n    \n    tt = t.x;\n    \n    vec3 col, colBackground = background(ro,rd);\n    \n    if(t.x>=maxDist)\n        col = colBackground; // background\n    else\n    {\n\n        vec3 p = ro + rd*t.x;\n        vec3 n  = calcNormal(p , 0.0001);\n\n\n        if(t.y>g_tg)\n        { // point light/self illum\n            col  = calcPointColor(t.y);\n\n            // small halo..\n            float r= 0.5; // max radius of a sphere\n            float e = map(true, p+rd*r).x;\n            col *= smoothstep(0.8, 0.0, e/r);\n\n        }\n        else\n        {\n            // ambient\n            vec3 amb = 0.2*textureLod( iChannel3, n.xy, 0.0 ).xyz;\n            amb += 0.5*background(ro,n);\n\n            // Ball color\n            float ty = t.y / g_tg;            \n            vec3 colBall = 0.5*mix(vec3(0.3, 0.1, 0.5), vec3(0.9, 0.3, 0.5), ty);\n\n\n            // directional lighting\n            float atten = 0.5 + 0.5*calcSoftshadow(p, g_lightDir);\n            col = colBall * ( amb + atten*diffuse(g_lightDir, n) );\n            col+= atten*specular(g_lightDir, n, rd, 16.0);\n\n\n            // animation: show shadowed only\n            {\n                float u = saturate( sin(iTime*0.2 + fragCoord.x*0.001)*4.0 );\n                col = mix(vec3(atten), col, u );\n            }\n    \n    \n            // back light\n            float d = 1.0 - min(1.0, 0.1*length(p-vec3(0)) );\n            col += /*atten**/0.6*vec3(0.0, 0.7, 1.0)* diffuse(g_bakLightDir, n) * d;\n\n\n            // lighting with closest point light, by calculating the distance variation along normal, in the light field !\n            {\n                const float rl = 3.0; // point light radius\n                vec2 pl = map( true, p ); // closest point light\n                if(pl.x < rl)\n                {\n                    float dl = (rl-pl.x) * max(0.0, pl.r-map(true, p+n).x) / rl;\n                    // lighting + some 'reflectivity'\n                    vec3  cl = calcPointColor(pl.y);\n                    col += cl*(colBall + 0.2) * dl * 4.0;\n                }\n            }\n        }\n        \n        // fog\n        col = mix(colBackground, col \n                        , smoothstep(maxDist, -3.0, t.x) );\n                        //,min(1.0,exp(-.05*t.x + 1.0)) );\n    }\n\n    \n    return col;\n}\n\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    \n    return mat3( cu, cv, cw );\n}\n\nvec3 pathCamera(out vec3 ta)\n{\n    float cTime = iTime*0.3;\n\n    // camera\n    float an = 0.025*sin(0.5*cTime) - 1.25;\n    vec3 ro = vec3(5.7,1.6, 5.7);\n    \n    ro.x = 0.0+ cos(0.5*cTime)*10.0;  \n    ro.z = 0.0+ sin(0.5*cTime)*12.0;\n\n    ro.y += sin(0.351*cTime)*16.0;\n\n    ta = vec3(0.0,0.0 + 0.0*sin(0.1*cTime),0);    \n\n    return ro;\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n\n    // camera\n    vec3 ta, ro=pathCamera(ta);\n\n\n    // ray\n    const float fl = 3.5;\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,fl) );\n\n    vec3 col = vec3(0.0);\n\n\n    // render\n    float t;    col += render(fragCoord, ro, rd, t);\n\n\n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    \n    // Output to screen    \n    fragColor = vec4( ACESFilm(col), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}