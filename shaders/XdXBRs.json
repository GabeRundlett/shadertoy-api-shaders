{
    "Shader": {
        "info": {
            "date": "1497418515",
            "description": "combined phase 1",
            "flags": 64,
            "hasliked": 0,
            "id": "XdXBRs",
            "likes": 4,
            "name": "Combine",
            "published": 3,
            "tags": [
                "showreel"
            ],
            "usePreview": 0,
            "username": "yahe",
            "viewed": 615
        },
        "renderpass": [
            {
                "code": "\n//////////////////////////////////////////////////////////////////////////////////////\n// use voronoi function from iq \n\n// https://iquilezles.org/articles/voronoilines\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o )/2.;\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Solve cubic ax^3 + bx^2 + cx + d = 0 \n// Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    // normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs / coeffs[0];\n\n    // substitute x = y - A/3 \n    // depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA/3.0) / 3.0;\n    float q = ( (N[1] * sqA)/13.5 - (N[1] * N[2])/3.0 + N[3]) * 0.5;\n\n    // Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse // one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q / sqrt(-cbP)) / 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi/3.0);\n\t\troots[2] = -t * cos(phi - Pi/3.0);\n\t\tnS = 3;\n    }\n    \n    else // one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] / 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// x is a point\n// {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    // Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    // Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    // Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    // Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy / iResolution.xy) - 1.0;\n    a.x *= iResolution.x / iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iTime * 7.0;\n    \n    float P = 0.0;\n    vec3 L = vec3(0.0);\n    \n    vec2 p0 = vec2(uv.x, -1.);\n    \n    for (float i = 0.0; i < 50.; i++) {\n    \n    vec2 p2 = vec2(1.5*sin(t*.5+i), 1.5*cos(t*.1+i)); \n    vec2 p4 = -p2;\n    vec2 p5 = vec2(-p2.y, p2.x);\n        \n        vec2 p = vec2(1.5*sin((t*0.04+i)), sin((t*.1+i) - 1.));\n    \tfloat d1 = smoothstep(0.02, 0.00, DistanceQuadraticBezier(uv, p0, p2, p));\n    \tfloat d2 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p0, p4, p));\n    \tfloat d3 = smoothstep(0.05, 0.00, DistanceQuadraticBezier(uv, p0, p5, p));\n        \n    vec3 L1 = d1 * vec3(0.2 , 0.4, 0.4+ .5*sin(i));\n    vec3 L2 = d2 * vec3(0.3, 0.2, 0.4+ .2*cos(i));\n        \n        L += L1 + L2;\n    }\n    \n    return P + L;\n}   \n\n//////////////////////////////////////////////////////////////////////////////////\n\n#define NUM_PARTICLES 200.0\n#define GLOW 0.5\n\nvec3 Orb(vec2 uv, vec3 color, float radius, float offset)\n{        \n    vec2 position = vec2(sin(offset * (iTime+30.)),\n                         cos(offset * (iTime+30.)));\n    \n    position *= sin((iTime ) - offset) * cos(offset);\n     \n    //offset = pModPolar(position,2.);\n    \n    radius = radius * offset;\n    float dist = radius / distance(uv, position);\n    return color * pow(dist, 1.0 / GLOW);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265358979323846\n\n#define W(x,k,c) A*sin(k*(X=x*2.-c*t))*exp(-X*X)\n\n#define C( r, R, t) smoothstep(t, 0., abs(R-(r)) )\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\nvec2 rotate( vec2 inVec, float angle )\n{\n \tmat4 rotMatrix = mat4\n    (\n    \tcos( angle ),\t-sin( angle ),\t0,\t0,\n        sin( angle ), \tcos( angle ),\t0,\t0,\n        0,\t\t\t\t0,\t\t\t\t1,\t0,\n        0,\t\t\t\t0,\t\t\t\t0,\t1    );\n    \n    return ( vec4( inVec, 0.0, 1.0 ) * rotMatrix ).xy;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// Lissajous curve\n// http://en.wikipedia.org/wiki/Lissajous_curve\n\n#define NUM 200.0\n#define TOW_PI 6.28318\n#define STEPS 300.\n\nvec2 lissajous(float t, float a, float b, float d)\n{\n\treturn vec2(sin(a*t+d), sin(b*t));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec2 c11;\n\nfloat avgDistance(vec2 uv)\n{\n \tfloat d = 0.0;\n    float k = 50.;\n    \n    for(int i=0; i<5; i++)    \n     \td+= cos(k*  sqrt((uv.x - c11.x) * (uv.x - c11.x) + (uv.y - c11.y) * (uv.y - c11.y)) ); \n    \n    return d/float(5);  \n}\n\nvec3 distToColor(float d)\n{\n    return vec3(sin(d),sin(d),sin(d));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat F(vec2 p, float s)\n{\n\tfloat x = abs(p.x);\n    float y = abs(p.y);\n    \n    x *= s;\n    y *= s;\n    \n    float ScaleX = (1.0 - sqrt(abs(1.0 - x)))/(x);\n    float ScaleY = (1.0 - sqrt(abs(1.0 - y)))/(y);\n    \n    float brightness = 1.1;\n    \n    return ScaleX * ScaleY * brightness;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec3 Orb13(vec2 uv, vec3 color, float radius, float offset)\n{        \n    float t = (iTime+200.)/5.;\n    vec2 position = vec2(sin(offset * t)*sin(offset * t)+ sin(iTime),\n                         cos(offset * t)*cos(offset * t)+ cos(iTime));\n    \n    if (sin(offset * t) < 0.&& cos(offset * t) > 0.) {\n     \n        position = vec2(-sin(offset * t)*sin(offset * t)+sin(iTime),\n                         cos(offset * t)*cos(offset * t)+cos(iTime));\n    } else if (cos(offset * t) < 0. && sin(offset * t) > 0.) {\n        \n        position = vec2(sin(offset * t)*sin(offset * t)+sin(iTime),\n                         -cos(offset * t)*cos(offset * t)+cos(iTime));\n        \n    } else if (cos(offset * t) < 0. && sin(offset * t) < 0.) {\n        \n        position = vec2(-sin(offset * t)*sin(offset * t)+sin(iTime),\n                         -cos(offset * t)*cos(offset * t)+cos(iTime));\n    }\n    \n    position *= sin((t + offset )*2. )* offset;\n    \n    radius = radius * sqrt(abs(position.x * position.y)) ;\n    \n    float dist = radius / distance(uv, position);\n    \n    return color * pow(dist, 1.0 / .4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime*3.0;\n\t\n\n\t//col = pow( col, vec3(0.7, 1., .9) );\n\n    vec2 uv = fragCoord.xy/iResolution.xx;\n\n    vec3 c = voronoi( 3.0*uv + ( sin(iTime)/2. +.5) );\n\n    c = c*c*1.5;\n    vec3 color2 = vec3(c.x*3., c.y*c.x, c.y);\n    color2 = mix( vec3(sin(iTime)+.3,sin(iTime)+.6,.9), color2, 0.5 );\n    \n    ////////////////////////////////////////////////////////\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec2 q2 = 2.0*uv2 - 1.0;\n    q2.x *= iResolution.x / iResolution.y;   \n    \n    vec3 color3 = vec3(0.15, 0.15, 0.19);\n    color3 = max(color3, Curves(q2));\n       \n    color3 = sqrt(color3) * .7;\n    color3 = color3 * (1.0 - 0.2*dot(q2,q2));\n    \n    ////////////////////////////////////////////////////////\n\n    vec2 uv3 =  vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel = vec3(0.0, 0.0, 0.0);\n   \tvec3 color4 = vec3(0.0, 0.0, 0.0);\n    \n \tcolor4.r = ((sin(((iTime)) * 0.55) + 1.5) * 0.4);\n    color4.g = ((sin(((iTime)) * 0.34) + 2.0) * 0.4);\n    color4.b = ((sin(((iTime)) * 0.31) + 4.5) * 0.3);\n    \n    float radius = 0.005;\n    \n    for\t(float i = 0.0; i < NUM_PARTICLES; i++)\n        pixel += Orb(uv3, color4, radius, i / NUM_PARTICLES);\n\n    color4 = mix(vec3(uv3,0.8+0.5*sin(iTime)), vec3(pixel), 0.8);\n    \n    ////////////////////////////////////////////////////////  \n\n    float A=3., X, y, Y=0.,  T = iTime,  t=mod(T,5.);\n    \n\tvec2 uv4 = fragCoord.xy / iResolution.xy;\n     \n    vec2 p4 = uv4 - vec2(0.5);\n    p4.x *= iResolution.x / iResolution.y;\n\n    float pr = length(p4);\n    float pa = atan(p4.y, p4.x);\n    \n    float radius5;\n    \n    float o = 0.0;\n    \n\tfloat wave_width = 0.01;\n    \n    for( float i = 1.0 ; i < 10.0 ; i += 1.0 )\n    {\n        radius5 = .1 + i*i/700. + 0.01 * ( W( (cos(pa * i / 5.) + PI/2.), i, sqrt(i) ) );\n        \n    \to += C(radius5 + (sin(T)+1.)/10., pr, 2./iResolution.y);\n    }\n    \n    vec4 color5 = mix( vec4(0.7, 0.85, 1. - 0.2*p.y, 0) * (1.0 - 0.2 * pr), o + p.xyyy * sin(T), o );\n    \n    //////////////////////////////////////////////////////// \n    \n    vec2 uv7 = fragCoord.xy/iResolution.x;\n    \n    float noise = fractalNoise2d(uv7);\n    uv7 = rotate2D(uv7, noise*300.);\n    \n    uv7 = .5*uv7;\n    float plasma = noise*(sin(uv7.x)+cos(uv7.y))*5.;\n    \n    vec3 color7 = vec3(sin((-plasma)+iTime),\n                    sin((-plasma+.4)+iTime),\n                    sin((-plasma+.5)+iTime));\n    \n    //////////////////////////////////////////////////////// \n    \n\tvec2 uv8 = fragCoord.xy / iResolution.xy;\n    uv8 -= .5;\n    uv8.x += sin(iTime/4.)/2.;\n    uv8.y += sin(iTime*2.)/4.;\n    \n    float offsetVal = iTime;\n    \n    vec2 uvR = uv8;\n    uvR.y /= abs(uvR.x);\n    uvR = rotate( uvR, offsetVal );\n    \n    vec2 uvG = uv8;\n    uvG.x /= abs(uvG.y);\n    uvG = rotate( uvG, offsetVal );\n    \n    vec2 uvB = uv;\n    uvB.xy -= sin( offsetVal );\n    \n    vec3 color8 = vec3( uvR.y * 0.5 + 0.5, uvG.y * 0.5 + 0.5, uvB.y * 0.5 + 0.5 );\n\n    //////////////////////////////////////////////////////// \n    \n\t\n\tvec2 uv9 = (fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    //vec3 c=vec3(0.9,0.55,0.6); //background color\n    \n    vec2 polar;\n    polar.y = sqrt(uv9.x * uv9.x + uv9.y * uv9.y);\n    polar.y /= iResolution.x / 2.0;\n    polar.y = 1.0 - polar.y;\n\n    polar.x = atan(uv9.y, uv9.x);\n    polar.x -= 1.57079632679;\n    if(polar.x < 0.0){\n\t\tpolar.x += 6.28318530718;\n    }\n    polar.x /= 6.28318530718;\n    polar.x = 1.0 - polar.x;\n    \n    vec3 color9 = vec3(sin( (uv9.x*uv9.x+uv9.y*uv9.y)*6.1-iTime*2.345)*.1+.15,sin((uv9.x*uv9.x+uv9.y*uv9.y)*3.1-iTime*1.2)*0.1+0.1,sin((uv9.x*uv9.x+uv9.y*uv9.y)*1.5-iTime*3.123)*0.01+.1);\n    \n    //vec3 c = smoothstep(-0.6+w,1.4+w+f,sqrt(p.x*p.x+p.y*p.y));\n\t\n    float radius9 = .4;\n    float brightness = 0.0005;\n    \n    for(float i=0.0; i<500.0; i++){\n        radius9 += sin(i*45.+iTime)*0.1;\n        \n\t\t//get location of dot\n        float x = sin(2.*3.14*i/(500.0))*radius9;\n        float y = cos(2.*3.14*i/(500.0))*radius9;\n        vec2 o = vec2(x,y);\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tcolor9 += brightness/(length(p-o))*radius9;\n    }\n    \n    radius9 = .15;\n    brightness = 0.0009;\n     for(float i=0.0; i<300.0; i++){\n        radius9 += sin(i*45.+iTime)*0.1;\n        \n\t\t//get location of dot\n        float x = sin(2.*3.14*i/(300.0))*radius9;\n        float y = cos(2.*3.14*i/(300.0))*radius9;\n        vec2 o = vec2(x,y);\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tcolor9 += brightness/(length(p-o))*radius9;\n    }\n\t \n\n    //////////////////////////////////////////////////////// \n\n    vec2 uv10 = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\tuv10.x *= iResolution.x / iResolution.y;\n    \n\tfloat a = 2. + mod(iTime, 10.);\n\tfloat b = 4.0;\n\tfloat d = 1.;\t// phase\n\t\n\tfloat m = .006;\n    vec2 lp = lissajous(log(iTime), a, b, d)*0.8;\n    \n    vec3 pixel10 = vec3(0.0, 0.0, 0.0);\n   \tvec3 color10 = vec3(0.0, 0.0, 0.0);\n    \n    for\t(float i = 0.0; i < NUM; i++) {\n        float t = float(i)*TOW_PI / STEPS;\n\t\tt += log(iTime);\n        vec2 p = lissajous(t, a, b, d)*0.8;\n\t\t\n\t\t// distance to line\n        vec2 pa = uv10 - p;\n        vec2 ba = lp - p;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        vec2 q = pa - ba*h;\n        \n        m = min( m, dot( q, q )*50.);\n\t\t\n            \n        pixel10 += vec3(1., 1., 1.) * m;\n     }\n    \n    color10 = mix(vec3(uv10,0.8+0.5*sin(iTime)), pixel10, 0.8);\n    \n    //////////////////////////////////////////////////////// \n\n    vec2 uv11 = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    for(int i=0; i<5; i++)\n    {\n     float fi = 2.0*3.14*float(i)/5.0;\n     c11= vec2(sin(fi+iTime/10.), cos(fi+iTime/10.))*cos(iTime/10.);\n    }\n    \n\tvec3 color11 = distToColor(avgDistance(uv11))*1.;\n    \n    \n    //////////////////////////////////////////////////////// \n\tvec2 uv12 = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv12.x = uv12.x * aspect;\n    vec2 p12 = uv12 - vec2(0.5 * aspect, 0.5);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float scale = 0.;\n    \n    for (float i=0.; i<20.; i++) {\n    \tscale += F(rotate(p12,(i+1.)*iTime/10.), (i*(sin(iTime/2.)/5.+.5)+1.));\n    }\n    \n    vec3 color12 = vec3(0.5);\n    color12 = color12 * scale / 4.;\n    \n    \n    \n    //////////////////////////////////////////////////////// \n\n    vec2 uv13 =  vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel13 = vec3(0.0, 0.0, 0.0);\n   \tvec3 color = vec3(1.);\n    \n    float radius13 = 0.02;\n    \n    for\t(float i = 0.0; i < 500.; i++) {\n        pixel13 += Orb13(uv13, color, radius13,  i / 500.);\n    //pixel += Orb(uv, color, radius, i / NUM_PARTICLES);\n    }\n\n    \n    vec3 color13 = pixel13;\n\n    \n    if (iTime <= 10.) {\n\t    fragColor = vec4( color3, 1.0 );\n    } else if (iTime <= 12.) {\n        fragColor = vec4(mix( color3, color2, 1.-(12.-iTime)/2. ), 1.0 );\n    } else if (iTime < 22.) {\n        fragColor = vec4( color2, 1.0 );\n    } else if (iTime < 24.) {\n        fragColor = vec4(mix( color2, color4, 1.-(24.-iTime)/2. ), 1.0 );\n    } else if (iTime < 34.) {\n        fragColor = vec4( color4, 1.0 );\n    } else if (iTime < 36.) {\n        fragColor = mix( vec4(color4, 1.0), color5, 1.-(36.-iTime)/2. );\n    } else if (iTime < 46.) {\n        fragColor = color5;\n    } else if (iTime < 48.) {\n        fragColor = mix( color5, vec4(color7, 1.0), 1.-(48.-iTime)/3. );\n    } else if (iTime < 58.) {\n        fragColor = vec4( color7, 1.0 );\n    } else if (iTime < 60.) {\n        fragColor = vec4(mix( color7, color8, 1.-(60.-iTime)/2. ), 1.0 );\n    } else if (iTime < 70.) {\n        fragColor = vec4( color8, 1.0 );\n    } else if (iTime < 72.) {\n        fragColor = vec4(mix( color8, color9, 1.-(72.-iTime)/2. ), 1.0 );\n    } else if (iTime < 82.) {\n        fragColor = vec4( color9, 1.0 );\n    } else if (iTime < 84.) {\n        fragColor = vec4(mix( color9, color10, 1.-(84.-iTime)/2. ), 1.0 );\n    } else if (iTime < 94.) {\n        fragColor = vec4( color10, 1.0 );\n    } else if (iTime < 96.) {\n        fragColor = vec4(mix( color10, color13, 1.-(96.-iTime)/2. ), 1.0 );\n    } else if (iTime < 106.) {\n        fragColor = vec4( color13, 1.0 );\n    } else if (iTime < 108.) {\n        fragColor = vec4(mix( color13, color12, 1.-(108.-iTime)/2. ), 1.0 );\n    } else {\n        fragColor = vec4( color12, 1.0 );\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 10867,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/yanling-he/phase2"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}