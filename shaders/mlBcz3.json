{
    "Shader": {
        "info": {
            "date": "1692679855",
            "description": "An improved version of my fluid simulation, this time featuring linear interpolants.",
            "flags": 32,
            "hasliked": 0,
            "id": "mlBcz3",
            "likes": 6,
            "name": "Fluid sim mk3",
            "published": 3,
            "tags": [
                "simulation",
                "fluid",
                "physics"
            ],
            "usePreview": 0,
            "username": "thepinkpanzer",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "#define T(p) texture(iChannel0,(p))\n#define B(p) texture(iChannel1,(p))\n\nvec4 jet(float x) // from 0 to 1\n{\n    return pow(vec4(x*x*(1.-x)/0.148, pow(x*(1.-x)*4.,2.), x*(1.-x)*(1.-x)/0.148, 0), vec4(1.6));\n}\nvec4 twilight(float x) // from -1 to 1\n{\n    float s  = sign(x);\n    x *= s;\n    \n    float r  = mix(1., (s > 0. ? x*x : x*x*x*x*x), 0.8);\n    float b  = mix(1., (s < 0. ? x*x : x*x*x*x*x), 0.8);\n    float g  = mix(1., x*x*x*x, 0.95);\n    return vec4(r, g, b, 0);\n}\n\nvec4 recolor(float x)\n{\n    x = tanh(x);\n    return jet(x);\n}\n\n#define ZOOM   1.0\n#define CENTER vec2(0.5,0.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fract((fragCoord/iResolution.xy - 0.5)/ZOOM+CENTER);\n    vec4 Q   = T(uv);\n    vec4 q   = Q/Q.r;\n    \n    float ek = 0.5*(q.g*q.g+q.b*q.b);\n    float t  = q.a-ek;\n    float s  = (GAMMA-1.)*t*pow(Q.r, -GAMMA);\n    \n    // ek  is kinetic energy per unit mass\n    // t   is thermal energy per unit mass\n    // s   is related to the entropy\n    // Q.r is density\n    \n    // Colour scheme: vec4(tanh(ek/t*10.));//\n    //if (fragCoord.y/iResolution.y > 0.5)\n    //{\n        fragColor = tanh(normalize(recolor(pow(t/7., 0.6)))*pow(Q.r*2., 0.4));//tanh(vec4(Q.r));//recolor(q.b*2.);\n    //}\n    //else\n    //{\n    //    fragColor = recolor(t*Q.r*1.);\n    //}\n    //fragColor = twilight(tanh(q.b*20.));\n    // Draw obstacles in black\n    fragColor*= (1.-B(uv).r);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// here i will store the fundamental laws of the universe\n// DT:    Timestep\n// GAMMA: Adiabatic constant for the gas (1.67=monatomic, 1.4=diatomic, 1.33=polyatomic)\n#define DT      0.03\n#define GAMMA   1.67\n\n// Boundary conditions\n// 0: Loop\n#define X_BOUNDARY 0\n#define Y_BOUNDARY 0\n\n// Limiter type\n#define LIMITER    2\n\n/*\nThis simulation is based on Van Leer's Monotonic Upstream-centered \nScheme for Conservation Laws (MUSCL). Unlike Godunov's earlier scheme,\nwhich takes each cell to have a constant mass, momentum, and energy\ndensity (see https://www.shadertoy.com/view/NtGBDR), MUSCL uses a linear\napproximation within cells, which makes it second-order in space. This\nallows it to better capture fine detail, and results in much less blurring.\n\nUnfortunately, the naive approaches are very unstable (Godunov's Theorem\nproves that every scheme which attempts to be second-order everywhere is\nunstable - schemes must reduce to first-order to be stable around discont-\ninuities. The solution is to ensure monotonicity, hence the M of MUSCL.\nWhenever a gradient estimate would produce a new maximum or minimum, it is\ncorrected (\"limited\") to reachieve monotonicity. At true maxima and minima,\nthe gradient is set to zero. While it results in extra blurring \n(\"dissipation\"), it also makes the scheme second-order where possible and\nfirst-order at shocks, as required by Godunov's theorem.\n\nThe solver I am using is unfortunately not always stable, and so I have a \ncheck to remove NaN and extreme values. This should hopefully not happen \noften, so won't do much to the results.\n\nThe initial conditions here have a dense but very low-pressure cloud, \nimmersed in a high-pressure, low-density gas. This makes it susceptible\nto Rayleigh-Taylor instability, which results in the mushroom-like swirls.\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define T(p) texture(iChannel0, (mod(p, iResolution.xy)/iResolution.xy))\nvec4 LimitedDeriv(vec4 a, vec4 b, vec4 c, float v)\n{\n    vec4 dm = 2.*(b - a);\n    vec4 dc =    (c - a)/2.;\n    vec4 dp = 2.*(c - b);\n    \n    #if LIMITER == 0\n        vec4 maxgrad = mix(sign(dp)*min(abs(dp), abs(dm)), vec4(0.), 1.-step(vec4(0.), dp*dm));\n        vec4 limited = sign(maxgrad)*min(abs(dc), abs(maxgrad))*1.;\n    #elif LIMITER == 1\n        vec4 limited = 0.5*sign(dc)*(min(abs(dm), abs(dp)))*step(-dm*dp,vec4(0.));\n    #elif LIMITER == 2\n        vec4 limited = sign(dc)/(1./abs(dm) + 1./abs(dp))*step(-dm*dp,vec4(0.));\n    #endif\n    \n    return limited;\n}\nvec4 Prim(vec4 Q)\n{\n    float ek = (dot(Q.gb, Q.gb))/(2.*Q.r);\n    float T  = Q.a-ek;\n    float P  = T*(GAMMA-1.);\n    return vec4(Q.r, Q.gb/Q.r, P);\n}\nvec4 Cons(vec4 P)\n{\n    float ek = dot(P.gb, P.gb)*0.5*P.r;\n    float T  = P.a/(GAMMA-1.);\n    float U  = T + ek;\n    return vec4(P.r, P.gb*P.r, U);\n}\nvec4 ConsG(vec4 P, vec4 Pxy)\n{\n    float dek = dot(P.gb, Pxy.gb*P.r + 0.5*P.gb*Pxy.r);\n    float dT  = Pxy.a/(GAMMA-1.);\n    float dU  = dT + dek;\n    return vec4(Pxy.r, (Pxy.gb*P.r)+(P.gb*Pxy.r), dU);\n}\nvec4 Evolve(vec4 P, vec4 Px, vec4 Py, float u, float v)\n{\n    /* Euler equations:\n    Time derivative=          A d v e c t i o n           +           p h y s i c s \n        (density )   (d/dx(density )*u + d/dy(density )*v +     density   *(d/dx(u) + d/dy(v)))\n    d/dt(   u    ) = (d/dx(   u    )*u + d/dy(   u    )*v +   (1/density) *   d/dx(pressure)  )\n        (   v    )   (d/dx(   v    )*u + d/dy(   v    )*v +   (1/density) *   d/dy(pressure)  )\n        (pressure)   (d/dx(pressure)*u + d/dy(pressure)*v + GAMMA*pressure*(d/dx(u) + d/dy(v)))\n    */\n    float density  = P.r;\n    float pressure = P.a;\n    \n    vec4 dP = vec4(\n    Px.r*u + Py.r*v +    density    *(Px.g + Py.b),\n    Px.g*u + Py.g*v +  (1./density) *    Px.a,\n    Px.b*u + Py.b*v +  (1./density) *    Py.a,\n    Px.a*u + Py.a*v + GAMMA*pressure*(Px.g + Py.b));\n    \n    P -= 0.5*min(DT, 0.5*min(abs(P.r/dP.r), abs(P.a/dP.a)))*dP;\n    \n    return P;\n}\nfloat P(vec4 Q)\n{\n    float ek = (dot(Q.gb, Q.gb))/(2.*Q.r);\n    float T  = Q.a-ek;\n    float P  = T*(GAMMA-1.);\n    return P;\n}\nvec4 Flux(vec4 Q)\n{\n    float P = P(Q);\n    return vec4(Q.g, (Q.g*Q.g/Q.r + P), Q.g*Q.b/Q.r, Q.g/Q.r*(Q.a + P));\n}\n//*\nvec4 Flux(vec4 Pn0, vec4 Pnp)\n{\n    // Momenta inside here are rotated so the outwards-facing normal is along +x\n    // Have to rotate to and from outside of here.\n    \n    // Q0/|_Qp\n    \n    // Enthalpy on sides:\n    float H0 = GAMMA*Pn0.a/Pn0.r/(GAMMA-1.) + 0.5*(Pn0.g*Pn0.g + Pn0.b*Pn0.b);\n    float Hp = GAMMA*Pnp.a/Pnp.r/(GAMMA-1.) + 0.5*(Pnp.g*Pnp.g + Pnp.b*Pnp.b);\n    // Sqrt densities:\n    float s0 = sqrt(Pn0.r);\n    float sp = sqrt(Pnp.r);\n    // Roe averages:\n    float H  = (s0* H0   + sp* Hp  )/(s0 + sp);\n    float u  = (s0*Pn0.g + sp*Pnp.g)/(s0 + sp);\n    float v  = (s0*Pn0.b + sp*Pnp.b)/(s0 + sp);\n    \n    float ek = 0.5*(u*u+v*v);\n    float a  = sqrt((GAMMA-1.)*(H - ek));\n    \n    // Small CFL number approximation (no gradients)\n    mat4 L   = mat4(vec4(((GAMMA-1.)*ek+a*u)/(2.*a*a), ((1.-GAMMA)*ek+a*a)/(a*a), ((GAMMA-1.)*ek-a*u)/(2.*a*a),  v),\n                    vec4(((1.-GAMMA)*u -a  )/(2.*a*a), ((GAMMA-1.)*u     )/(a*a), ((1.-GAMMA)*u +a  )/(2.*a*a),  0),\n                    vec4(((1.-GAMMA)*v     )/(2.*a*a), ((GAMMA-1.)*v     )/(a*a), ((1.-GAMMA)*v     )/(2.*a*a), -1),\n                    vec4(((GAMMA-1.)       )/(2.*a*a), ((1.-GAMMA)       )/(a*a), ((GAMMA-1.)       )/(2.*a*a),  0.));\n    vec4 eigenvalues = vec4( u-a,  u ,  u+a ,  u);\n    mat4 R   = mat4(vec4(1., u-a, v, H-a*u),\n                    vec4(1., u  , v, ek   ),\n                    vec4(1., u+a, v, H+a*u),\n                    vec4(0., 0., -1., 0.));\n    \n    vec4 w0 = L*Cons(Pn0);\n    vec4 wp = L*Cons(Pnp);\n    \n    vec4 flux = -0.5*R*(eigenvalues*(wp+w0) + abs(eigenvalues)*(wp-w0));\n    return flux;\n}\n//*/\n/*\nvec4 Flux(vec4 Pn0, vec4 Pnp)\n{\n    vec4 Qn0  = Cons(Pn0);\n    vec4 Qnp  = Cons(Pnp);\n    // Momenta inside here are rotated so the outwards-facing normal is along +x\n    // Have to rotate to and from outside of here.\n    float z   = (GAMMA-1.)/(2.*GAMMA);\n    \n    float ek0 = (dot(Qn0.gb, Qn0.gb))/(2.*Qn0.r);\n    float T0  = Qn0.a-ek0;\n    float P0  = T0*(GAMMA-1.);\n    float a0  = sqrt(GAMMA*P0/Qn0.r);\n    float u0  = Qn0.g/Qn0.r;\n    \n    float ekp = (dot(Qnp.gb, Qnp.gb))/(2.*Qnp.r);\n    float Tp  = Qnp.a-ekp;\n    float Pp  = Tp*(GAMMA-1.);\n    float ap  = sqrt(GAMMA*Pp/Qnp.r);\n    float up  = Qnp.g/Qnp.r;\n    \n    float Pstar = pow((a0 + ap - (GAMMA-1.)*0.5*(up-u0))/(a0/pow(P0, z)+ap/pow(Pp, z)), 1./z);\n    float q0    = Pstar > P0 ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Pstar/P0-1.)) : 1.;\n    float qp    = Pstar > Pp ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Pstar/Pp-1.)) : 1.;\n    \n    // Wave speeds\n    float S0    = u0 - q0*a0;\n    float Sp    = up + qp*ap;\n    float Sstar = (Pp - P0 + Qn0.r*u0*(S0-u0) - Qnp.r*up*(Sp-up))\n                 /(Qn0.r*(S0-u0) - Qnp.r*(Sp-up));\n    \n    float k0    = Qn0.r*(S0-u0)/(S0-Sstar);\n    vec4  Qn1   = k0*vec4(1, Sstar, Qn0.b/Qn0.r, Qn0.a/Qn0.r + (Sstar-u0)*(Sstar + P0/(Qn0.r*(S0-u0))));\n    \n    float kp    = Qnp.r*(Sp-up)/(Sp-Sstar);\n    vec4  Qn2   = kp*vec4(1, Sstar, Qnp.b/Qnp.r, Qnp.a/Qnp.r + (Sstar-up)*(Sstar + Pp/(Qnp.r*(Sp-up))));\n    \n    vec4  QL    = Cons(Pn0);\n    vec4  QR    = Cons(Pnp);\n    \n    // Fluxes\n    vec4 flux;\n    if (Sstar > 0.)\n    {\n        flux = Flux(QL);\n        if (S0 < 0.)\n        {\n            flux += S0*(Qn1 - QL);\n        }\n    }\n    else\n    {\n        flux = Flux(QR);\n        if (Sp > 0.)\n        {\n            flux += Sp*(Qn2 - QR);\n        }\n    }\n    return flux;\n    \n}//*/\n\nvoid mainImage( out vec4 Q1, in vec2 c )\n{\n    /* \n    Need a 13-cell stencil:\n    Cells:\n    p/m = plus one/minus one. d/s = plus two/minus two (double and subtract)\n    Edges:\n    L/R = plus 0.5/minus 0.5, starting from the given cell\n\n    We need to:\n    1) estimate gradients for current cell and neighbours\n    2) limit said gradients\n    3) calculate edge states\n    4) boost edge states by half timestep\n    5) get fluxes\n    easy.\n    */\n    \n    // Stencil!\n    // These are our cell and its neighbours\n    vec4 Q00 = T(c            );\n    vec4 Qp0 = T(c+vec2( 1, 0));\n    vec4 Qm0 = T(c+vec2(-1, 0));\n    vec4 Q0p = T(c+vec2( 0, 1));\n    vec4 Q0m = T(c+vec2( 0,-1));\n    // These are only needed for gradients and limiting\n    vec4 Qd0 = T(c+vec2( 2, 0));\n    vec4 Qs0 = T(c+vec2(-2, 0));\n    vec4 Q0d = T(c+vec2( 0, 2));\n    vec4 Q0s = T(c+vec2( 0,-2));\n    vec4 Qpp = T(c+vec2( 1, 1));\n    vec4 Qmp = T(c+vec2(-1, 1));\n    vec4 Qpm = T(c+vec2( 1,-1));\n    vec4 Qmm = T(c+vec2(-1,-1));\n    \n    // Primitive variables!\n    vec4 P00 = Prim(Q00);\n    vec4 Pp0 = Prim(Qp0);\n    vec4 Pm0 = Prim(Qm0);\n    vec4 P0p = Prim(Q0p);\n    vec4 P0m = Prim(Q0m);\n    vec4 Pd0 = Prim(Qd0);\n    vec4 Ps0 = Prim(Qs0);\n    vec4 P0d = Prim(Q0d);\n    vec4 P0s = Prim(Q0s);\n    vec4 Ppp = Prim(Qpp);\n    vec4 Pmp = Prim(Qmp);\n    vec4 Ppm = Prim(Qpm);\n    vec4 Pmm = Prim(Qmm);\n    \n    // Gradients! (Only five in each direc)\n    // x direc\n    vec4 Px00 = LimitedDeriv(Pm0, P00, Pp0, P00.g);\n    vec4 Pxp0 = LimitedDeriv(P00, Pp0, Pd0, Pp0.g);\n    vec4 Pxm0 = LimitedDeriv(Ps0, Pm0, P00, Pm0.g);\n    vec4 Px0p = LimitedDeriv(Pmp, P0p, Ppp, P0p.g);\n    vec4 Px0m = LimitedDeriv(Pmm, P0m, Ppm, P0m.g);\n    // y direc\n    vec4 Py00 = LimitedDeriv(P0m, P00, P0p, P00.b);\n    vec4 Pyp0 = LimitedDeriv(Ppm, Pp0, Ppp, Pp0.b);\n    vec4 Pym0 = LimitedDeriv(Pmm, Pm0, Pmp, Pm0.b);\n    vec4 Py0p = LimitedDeriv(P00, P0p, P0d, P0p.b);\n    vec4 Py0m = LimitedDeriv(P0s, P0m, P00, P0m.b);\n    // We need some extra gradients beyond the ones needed for \n    // the edge states to get second order accuracy in time\n        \n    // Edge states! (We need eight)\n    // in x:\n    vec4 PL000 = (P00 - 0.5*Px00);\n    vec4 PR000 = (P00 + 0.5*Px00);\n    vec4 PL0p0 = (Pp0 - 0.5*Pxp0);\n    //vec4 PR0p0 = (Pp0 + 0.5*Pxp0);\n    //vec4 PL0m0 = (Pm0 - 0.5*Pxm0);\n    vec4 PR0m0 = (Pm0 + 0.5*Pxm0);\n    //vec4 PL00p = (P0p - 0.5*Px0p);\n    //vec4 PR00p = (P0p + 0.5*Px0p);\n    //vec4 PL00m = (P0m - 0.5*Px0m);\n    //vec4 PR00m = (P0m + 0.5*Px0m);\n    // in y:\n    vec4 P0L00 = (P00 - 0.5*Py00);\n    vec4 P0R00 = (P00 + 0.5*Py00);\n    vec4 P0L0p = (P0p - 0.5*Py0p);\n    //vec4 P0R0p = (P0p + 0.5*Py0p);\n    //vec4 P0L0m = (P0m - 0.5*Py0m);\n    vec4 P0R0m = (P0m + 0.5*Py0m);\n    //vec4 P0Lp0 = (Pp0 - 0.5*Pyp0);\n    //vec4 P0Rp0 = (Pp0 + 0.5*Pyp0);\n    //vec4 P0Lm0 = (Pm0 - 0.5*Pym0);\n    //vec4 P0Rm0 = (Pm0 + 0.5*Pym0);\n    \n    // Recalculate gradients with new limited edge states\n    // x direc\n    //Px00 = (PR000 - PL000);\n    //Pxp0 = (PR0p0 - PL0p0);\n    //Pxm0 = (PR0m0 - PL0m0);\n    //Px0p = (PR00p - PL00p);\n    //Px0m = (PR00m - PL00m);\n    // y direc\n    //Py00 = (P0R00 - P0L00);\n    //Pyp0 = (P0Rp0 - P0Lp0);\n    //Pym0 = (P0Rm0 - P0Lm0);\n    //Py0p = (P0R0p - P0L0p);\n    //Py0m = (P0R0m - P0L0m);\n    \n    \n    // Estimate speeds at useful edges (only four)\n    float uL0 = (sqrt(PL000.r)*PL000.g + sqrt(PR0m0.r)*PR0m0.g)/(sqrt(PL000.r) + sqrt(PR0m0.r));\n    float uR0 = (sqrt(PR000.r)*PR000.g + sqrt(PL0p0.r)*PL0p0.g)/(sqrt(PR000.r) + sqrt(PL0p0.r));\n    float v0L = (sqrt(P0L00.r)*P0L00.b + sqrt(P0R0m.r)*P0R0m.b)/(sqrt(P0L00.r) + sqrt(P0R0m.r));\n    float v0R = (sqrt(P0R00.r)*P0R00.b + sqrt(P0L0p.r)*P0L0p.b)/(sqrt(P0R00.r) + sqrt(P0L0p.r));\n    \n    // Evolve edge states by a half-timestep (only eight)\n    PL000 = Evolve(PL000, Px00, Py00, uL0, PL000.b);\n    PR000 = Evolve(PR000, Px00, Py00, uR0, PR000.b);\n    PL0p0 = Evolve(PL0p0, Pxp0, Pyp0, uR0, PL0p0.b);\n    PR0m0 = Evolve(PR0m0, Pxm0, Pym0, uL0, PR0m0.b);\n    \n    P0L00 = Evolve(P0L00, Px00, Py00, P0L00.g, v0L);\n    P0R00 = Evolve(P0R00, Px00, Py00, P0R00.g, v0R);\n    P0L0p = Evolve(P0L0p, Px0p, Py0p, P0L0p.g, v0R);\n    P0R0m = Evolve(P0R0m, Px0m, Py0m, P0R0m.g, v0L);\n    \n    /*\n    // Convert back to conserved quantities at edges (eight again)\n    vec4 QL000 = Cons(PL000);\n    vec4 QR000 = Cons(PR000);\n    vec4 QL0p0 = Cons(PL0p0);\n    vec4 QR0m0 = Cons(PR0m0);\n    \n    vec4 Q0L00 = Cons(P0L00);\n    vec4 Q0R00 = Cons(P0R00);\n    vec4 Q0L0p = Cons(P0L0p);\n    vec4 Q0R0m = Cons(P0R0m);\n    \n    vec4 QxL   = ConsG(PL000, Px00);\n    vec4 QxR   = ConsG(PR000, Px00);\n    vec4 QyL   = ConsG(P0L00, Py00);\n    vec4 QyR   = ConsG(P0R00, Py00);\n    \n    vec4 QxpL  = ConsG(PL0p0, Pxp0);\n    vec4 QxmR  = ConsG(PR0m0, Pxm0);\n    vec4 QypL  = ConsG(P0L0p, Py0p);\n    vec4 QymR  = ConsG(P0R0m, Py0m);\n    */\n\n    // Writing the new state of the system\n    Q1  =  Q00;\n    \n    // Calculate fluxes (at long last!) (only four!)\n    Q1 -= DT*(Flux(PR000, PL0p0) + Flux(P0R00.xzyw, P0L0p.xzyw).xzyw\n            - Flux(PR0m0, PL000) - Flux(P0R0m.xzyw, P0L00.xzyw).xzyw);\n    \n    if (Q1 != Q1 || Q1.r < 0.01 || Q1.a < (dot(Q1.gb, Q1.gb)/(2.*Q1.r)) || Q1.r > 100. || Q1.a > 100.)\n    {\n        Q1 = vec4(1,0,0,10);\n        //Q1.ra = max(Q1.ra, vec2(0.01,0.05*Q1.r+dot(Q1.gb,Q1.gb)/(2.*Q1.r)));\n    }\n    //Q1 = Cons(P00);\n    // Initial conditions\n    if (iFrame == 0)\n    {\n        \n        if (length((c-iResolution.xy/2. + 2.*sin(c.yx+sin(c+20.*cos(c.yx))))*vec2(0.6,1./0.6)) > iResolution.y/3.)\n        {\n            Q1 = vec4(1,0,0,10);\n        }\n        else\n        {\n            Q1 = vec4(10,0,0,0.1);\n        }\n        /*\n        if (cos(6.*3.14159265*(c.y+5.*sin(3.14159*c.x/iResolution.x*10.))/iResolution.y) > 0.)\n        {\n            Q1 = vec4(1, 3.0,0,10);\n        }\n        else\n        {\n            Q1 = vec4(1,-3.0,0,10);\n        }*/\n    }\n    //Q1 = vec4(Px00.a)*100.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}