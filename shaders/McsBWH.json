{
    "Shader": {
        "info": {
            "date": "1723717876",
            "description": "source https://www.shadertoy.com/view/NlK3Wt",
            "flags": 0,
            "hasliked": 0,
            "id": "McsBWH",
            "likes": 1,
            "name": "city in shake",
            "published": 3,
            "tags": [
                "city"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 59
        },
        "renderpass": [
            {
                "code": "\n#define h21(p) ( fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453) ) //hash21\n#define BC vec3(.26,.4,.6) //base color\n\nvec4 getHex(vec2 p) //hex grid coords \n{\n    vec2 s = vec2(1, 1.7320508);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n#define iTime time\n#define iResolution resolution\n\nfloat noise( in vec2 f ) //gradient noise\n{\n    vec2 i = floor( f );\n    f -= i;\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( h21( i + vec2(0,0) ), \n                     h21( i + vec2(1,0) ), u.x),\n                mix( h21( i + vec2(0,1) ), \n                     h21( i + vec2(1,1) ), u.x), u.y);\n}\n\nvec3 HexToSqr (vec2 st, inout vec2 uf) //hexagonal cell coords to square face coords \n{ \n    vec3 r;\n   \n    uf = vec2((st.x+st.y*1.73),(st.x-st.y*1.73))-.5; //upper face coord space\n     \n    if (st.y > 0.-abs(st.x)*0.57777)\n        if (st.x > 0.) \n      \n            r = vec3(fract(vec2(-st.x,(st.y+st.x/1.73)*0.86)*2.),2.); //right face\n        else\n            r = vec3(fract(vec2(st.x,(st.y-st.x/1.73)*0.86)*2.),3.); //left face\n    else \n        r = vec3 (fract(uf+.5),1); //top face\n    return r;\n} \n\n#define resolution iResolution.xy\n#define time iTime\nvoid pixel (float hh, float sm, vec2 st, vec2 s, float n,  vec4 R, inout vec4 C) //blinking pixels\n{\n    st = vec2(st.x,1.-st.y);\n    \n        \n    \n    \n\n    vec2    lc = 1.-fract(st*10.) //pixel local coords\n        ,   id = floor(st*10.) + s; //id of pixel or neigbour \n\n    float   b = ((4.-n)*2.2+.8)*.05 //face lightness\n        ,   th = .05            //pixel border thickness\n        ,   T = mod(iTime+hh*20.,20.) //local timer\n        ,   d = ((T < 3.) ? sin((T)*.52) :  //hole diameter\n                        ((T < 6.5) ? 1. :   \n                        ((T < 9.5) ? sin((9.5-T)*.52) : \n                                0.)))\n        ,   f =  min(\n                (pow(noise(id*hh*n+iTime*(.75+h21(id)*.15)*1.),8.)*2. //small picks\n                + (noise(id*.2 + iTime*(.5+hh*n)*.5)-.1)) //big noise\n                * smoothstep (6.,2.,length(id-4.5)) //fade noise to face edges\n                * ((n == 1.) ? (smoothstep(d*5., d*5.+2. ,length(id-4.5)+.5)) : 1.) //remove noise on top face while sphere is up \n                , 0.95); \n\n    vec4 P =  vec4(BC*(2.+hh*.75)*b,1); // pixel base color\n     P.zx*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime) );\n\n    if (s == vec2(0)) C = mix (P*5.7, P*.9, step(0.,lc.x-lc.y)); //pixel background\n\n    vec2 m = s*2.-1.;\n      \n    if (s.x!=s.x) C = mix (C\n                            ,   mix(    P*11.7\n                                    ,   P*.9\n                                    ,   step(lc.x-lc.y,0.))\n                            , step(lc.x+lc.y,f+f)\n                    *((m.y==-1.)?step(lc.x-lc.y+1.,1.):step(1.,lc.x-lc.y+1.))); //pixel side faces\n    C = mix (C, P,smoothstep(f+sm*m.x,f-sm*m.x,lc.x)*smoothstep(f+sm*m.y,f-sm*m.y,lc.y)); //pixel top face background\n    C = mix (C, mix(P*(.4+(f+pow(f,2.))*4.),R,.25) \n    ,smoothstep(f-(th-sm)*m.x,f-(th+sm)*m.x,lc.x)*smoothstep(f-(th-sm)*m.y,f-(th+sm)*m.y,lc.y)); //pixel top face color + sphere reflection\n}\n\nvoid tile(vec2 uv,inout vec4 C) \n{\n    vec4 hx = getHex(uv);\n  \n    vec2 s; //top face square coordiantes \n    vec3 sqr = HexToSqr(hx.xy, s);\n     \n    float n = sqr.z       //face id\n          ,sm = 3./iResolution.y  //smoothness\n          ,hh = h21(hx.zw*200.); //random value for tile\n          \n    vec2 st = sqr.xy*sqr.xy; //  face square coordinates\n\n    vec4 R=hx; //sphere or sphere reflection\n    \n  \n    pixel (hh, sm, st, vec2(0,0), n,  R, C); //drawing pixel and his neighbors\n    pixel (hh, sm, st, vec2(5,0), n,  R, C);\n    pixel (hh, sm, st, vec2(5,5), n,  R, C);\n    pixel (hh, sm, st, vec2(100,1), n,  R, C);\n\n    if (n==1.) C = mix (C,R,R.a); //draw sphere on top face\n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 rz = iResolution.xy\n    \n        ,uv = (g+g-rz)/-rz.y;\n        \n         vec4 c= C;\n    vec2 p = uv;\n vec2 v = iResolution.xy;\n    p = (p-v*.5)*.5 / v.y;\n    \n    // breathing effect\n    p += p * sin(dot(p, p)*20.-iTime) * .04;\n    \n    // color\n    c *= 0.;\n    for (float i = .5 ; i < 8. ; i++)\n        \n        // fractal formula and rotation\n        p = abs(2.*fract(p-.5)-1.) * mat2(cos(.01*(iTime+iMouse.x*.1)*i*i + .85*vec4(1,8,3,1))),\n        \n        // coloration\n        c += exp(-abs(p.y)*5.) * (cos(vec4(2,3,1,0)*i)*.5+.5);\nuv.xy*=mat2(cos(iTime*0.1),sin(iTime*0.1),-sin(iTime*0.1),cos(iTime*0.1) );\n    uv *= 2.7; //camera scale\n     uv -= uv * pow(length(uv.xy),2.5-sin(iTime*.3)*.5)*.015 +  //camera distortion\n        vec2(iTime*.02,cos(iTime*.2));   //camera translate\n    uv -= uv * pow(length(c.xz),2.5-cos(iTime*.3)*.5)*.035 +  //camera distortion\n        vec2(iTime*.02,cos(iTime*.2));   //camera translate\n        \n    \n    C -= C;\n    C+=c;\n    tile(uv,C);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}