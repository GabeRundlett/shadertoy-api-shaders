{
    "Shader": {
        "info": {
            "date": "1722875324",
            "description": "source https://glslsandbox.com/e#53580.2 https://glslsandbox.com/e#72891.0",
            "flags": 0,
            "hasliked": 0,
            "id": "lc2cRd",
            "likes": 1,
            "name": "triangle in space",
            "published": 3,
            "tags": [
                "fractal",
                "triangle",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 123
        },
        "renderpass": [
            {
                "code": "\n#define time iTime\n#define resolution iResolution.xy\nfloat plane(vec3 p, vec3 o, vec3 n) {\n\treturn dot(p - o, n);\n}\n#define rot(a) mat2(cos(a + vec4(0, 33, 11, 0)))\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat tetrahedron(vec3 p, float s) {\n\n\tfloat k = .57735026919;\n\t\n\tfloat a = plane(p, vec3(s, s, s), vec3(-k, k, k));\n\tfloat b = plane(p, vec3(s, -s, -s), vec3(k, -k, k));\n\tfloat c = plane(p, vec3(-s, s, -s), vec3(k, k, -k));\n\tfloat d = plane(p, vec3(-s, -s, s), vec3(-k, -k, -k));\n\t\n\t// return max(a, b);\n\treturn max(max(a, b), max(c, d));\n\n}\n\nfloat map(vec3 p) {\n\tp.xy *= rot(time);\n\tp.xz *= rot(time);\n\treturn tetrahedron(p, .5);\n\t\n}\n\nvec3 normal(vec3 p) {\n\tfloat eps = .001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x + eps, p.y, p.z)) - map(vec3(p.x - eps, p.y, p.z)),\n\t\tmap(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n\t\tmap(vec3(p.x, p.y, p.z + eps)) - map(vec3(p.x, p.y, p.z - eps))\n\t));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nvec3 random3( vec3 p ) {\n\tvec2 r1=random2(p.xy);\n\tvec2 r2=random2(vec2(p.z,r1.x));\n\treturn vec3(r1.y,r2.x,r2.y);\n\t}\n\nvec4 voronoi(in vec3 st, float scale, float speed){\n    vec3 color = vec3(0.);\n    vec3 i_st = floor(st/scale);\n    vec3 f_st = fract(st/scale);\n    vec3 pid=vec3(0.);\n    vec3 randoffset=vec3(speed,2.*speed,3.*speed);\n\n    float m_dist = 1.000;// minimum distance\n\tvec3 m_point;//minimum point\n    for (int z= -1; z <= 1; z++) {\n    for (int y= -1; y <= 1; y++) {\n    for (int x= -1; x <= 1; x++) {\n            vec3 neighbor =vec3(float(x),float(y),float(z));// Neighbor place in the grid\n            vec3 point = random3(i_st+neighbor+randoffset);// Random position from current + neighbor place in the grid\n\t    vec3 tid=point;\n            point = 0.5 + 0.5*sin(time*speed + 6.2831*point);// Animate the point\n            vec3 diff = neighbor + point - f_st;// Vector between the pixel and the point\n            float dist = length(diff);// Distance to the point\n            \n            if(dist<m_dist){\n                m_dist = min(m_dist, dist);\n                m_point = point;\n\t\tpid=tid;\n            }\n        }\n    }}\n\n    return vec4(m_point.x,\n\t\tm_point.y,\n\t\tm_point.z,random3(pid).z);\n}\n\n\nvec2 rtSphere(vec3 epos,vec3 rdir, float rad){\n\tvec3 tz=epos;\n\tvec3 tzn=normalize(tz);\n\tfloat dd=dot(rdir,-tz);\n\tvec3 nearest=epos+rdir*dd;\n\tfloat ndist=length(nearest);\n\tfloat bus=rad*rad-ndist*ndist;\n\tif (bus<0.) return vec2(-1.0);\n\treturn vec2(dd-sqrt(bus),dd+sqrt(bus));//epos+rdir*(dd-sqrt(bus));\n}\n\nvoid dpoint(vec3 p, vec3 norm, float layer,vec3 light, inout vec4 c, inout float AA, float cover){\n         \tfloat tt=time*0.1;\n\t\tvec4 voron=voronoi(p,3.0*(5.0/(layer*0.4+1.0)),1.0+layer*0.1);\n\t\tif (fract(voron.w)<0.9){ return;}\n\t\t\n\t\tfloat diffuse = dot(norm,light);\n\t\tvec3 rrvec=random3(vec3(voron.w));\n\t\trrvec*=20.;\n\t\trrvec=(sin(rrvec+vec3(tt, tt*1.2538628,tt*9.928796))+1.0)/2.0;\n\t\tvec3  mat =normalize(rrvec*cover+vec3(1.)*(1.-cover));\n\t\tfloat emit=min(1.0,\n\t\t\t       max(\n\t\t\t\t       max(diffuse, .3),\n\t\t\t\t       layer*0.1)\n\t\t\t      );\n\t\t\t\n\t\tvec3 color = clamp(vec3(emit*mat),vec3(0.0),vec3(1.0));\n\t        c = vec4(AA*color, 1.)+c*(1.0-AA);\n\t        AA=(0.0*cover+AA*(1.0-cover));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\t\n\tvec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n    vec2 uv2 = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n    vec4 O = fragColor;\n    vec2 C = fragCoord;\n float tt=time*0.1;\n\t\n\tvec3 ro3 = vec3(vec2(cos(time*20.),sin(time*20.))*0.1, 100);\n\tvec3 rd3 = normalize(vec3(uv*0.5, -1));\n\tfloat m=iMouse.x*3.14179;//+sin(time*30.)*0.003;\n\tro3.xz=vec2(cos(m)*ro3.x+sin(m)*ro3.z,cos(m)*ro3.z-sin(m)*ro3.x);\n\trd3.xz=vec2(cos(m)*rd3.x+sin(m)*rd3.z,cos(m)*rd3.z-sin(m)*rd3.x);\n\tm=iMouse.x*3.14179;//+cos(time*30.)*0.003;\n\tro3.yz=vec2(cos(m)*ro3.y+sin(m)*ro3.z,cos(m)*ro3.z-sin(m)*ro3.y);\n\trd3.yz=vec2(cos(m)*rd3.y+sin(m)*rd3.z,cos(m)*rd3.z-sin(m)*rd3.y);\n\t\n\t\n\t\n\tvec3 ro = vec3(0, 0, -2);\n\tvec3 rd = vec3(uv2, 1);\n\t\n\n\n\n\t\n\t\n\n\t O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n       \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n\n\n\t\n    vec3 col3 = vec3(0.);\n\tvec3 ro2 = vec3(0, 0, -2);\n\tvec3 rd2= vec3(uv2, 1);\n\t\n\tfloat t = 0.;\n\tfor (int i = 0; i < 45; i++) {\n\t\tvec3 p4 = ro2 + rd2 * t;\n\t\tfloat d = map(p4);\n\t\tt += .5 * d;\n\t\tcol3 += .03 / t;\n\t}\n\t\n\tvec3 p4 = ro2 + rd2 * t;\n\tvec3 N = normal(p4);\n\tvec3 L = vec3(0, 2, -6);\n\t\n\tvec3 ld = normalize(L - p4);\n\tfloat diff = max(dot(ld, N*O.xyz), 0.);\n\t\n\t\n\tcol3 += diff / (1. + t * t * .025);\n\tcol3 = .5 + .5 * cos(time + col3 * 4. + vec3(23, 21, 0));\n\t\n\t\n\t\n    vec3 light = normalize(vec3(1.,1., 1));\n\tfloat dist = 0.;\n\tvec3 color;\n\tfloat l=1.;\n\tfloat alpha=1.0;\n\tvec2 nf=rtSphere(ro,rd,50.);\n\tfloat midp=(nf.x+nf.y)/2.0;\n\tfloat torig=length(ro+rd*midp)*length(ro+rd*midp);\n\tfor (int i = 0; i < 15; i++) {\n\t\tl=float(i);\n\t\tvec3 p = ro+ rd * dist; \n\t\tfloat fd=pow((50.-l),2.)-torig;\n\t\tif (fd<0.) continue;\n\t\tfd=sqrt(fd);\n\t\tvec3 p1=ro+rd*(midp+(fd));//near_far.y;\n\t\tvec3 p2=ro+rd*(midp-(fd));//near_far.y;\n                dpoint(p1,-normalize(p1),l,light,fragColor,alpha,0.0);\t\t\n                dpoint(p2,normalize(p2),l,light,fragColor,alpha,1.0);\t\t\n\n\t\t}\n    fragColor*= vec4(col3, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}