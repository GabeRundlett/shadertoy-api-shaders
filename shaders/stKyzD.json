{
    "Shader": {
        "info": {
            "date": "1661286299",
            "description": "metaballs, translucency, and stacked harmonic patterns",
            "flags": 0,
            "hasliked": 0,
            "id": "stKyzD",
            "likes": 11,
            "name": "3d metaball third order motion",
            "published": 3,
            "tags": [
                "raymarch",
                "materials"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 406
        },
        "renderpass": [
            {
                "code": "// Fork of \"sphere material test\" by ufffd. https://shadertoy.com/view/sl2yWR\n// 2022-08-21 15:55:05\n\n// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\n#define PI 3.141592653589793\n#define MAX_STEP 100\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.15\n#define AMBIENT\t\t\t\t.95\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.7\n#define FADE_POWER\t\t\t1.\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat boxDist(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat boxDist(vec3 p, float s) {\n    return boxDist(p,vec3(s));\n}\nfloat bevelboxDist(vec3 p, float s, vec3 rot) {\n  // p.yz *= Rot(rot.x);\n  // p.zx *= Rot(rot.y);\n  // p.xy *= Rot(rot.z);\n  vec3 q = abs(p) - s;\n  float d = min(max(q.x,max(q.y,q.z)),0.0);\n  d += length(max(q,0.0));\n  // d = max(d, q.x*2.+q.y+0.2);\n  d = max(d, q.x+q.y*2.+0.2);\n  d = max(d, q.y*2.+q.z+0.2);\n  // d = max(d, q.y+q.z*2.+0.2);\n  // d = max(d, q.z+q.x+0.1);\n  return d;\n}\n\nfloat chamferboxDist(vec3 p, vec3 s, float ch) {   \n    vec3 p1 = p - clamp(p, ch - s, s - ch);\n    p1 = abs(p1);\n    float d1 = (p1.x + p1.y + p1.z - ch) / 3.0;\n    vec3 point = p1 - d1;\n    vec3 d2 = min(point, 0.0);\n    point += (d2.x + d2.y + d2.z) * 0.5 - d2 * 1.5;\n    point = clamp(point, 0.0, ch); \n    float d3 = length(p - point) * sign(d1);\n    // return max(d3, 0.0);\n    \n    vec3 p2 = abs(p) - s;\n    float d4 = max(max(p2.x, p2.y), p2.z);\n    float d5 = (p2.x + p2.y + p2.z + 2.0 * ch) / sqrt(3.0);\n    float d6 = (max(max(p2.x + p2.y, p2.x + p2.z), p2.y + p2.z) + ch) / sqrt(2.0);\n    return max(d3, 0.0) + min(max(max(d4, d5), d6), 0.0);\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    vec3 jiggle_p = JIGGLE*vec3(\n        noise(vec2(iTime*.7,1.)),\n        noise(vec2(iTime*.8,2.)),\n        noise(vec2(iTime*.9,3.))\n    );\n    \n    vec3 s_p = vec3(0.);\n    float sphere = 0.;\n    \n    for (int i=1;i<20;i++) {\n        float fi = float(i) * 0.3;\n        float ft = iTime*10. - fi;\n        // sphere 1\n        s_p = vec3(\n            cos(ft) + cos(ft*0.1),\n            sin(ft) + sin(ft * 0.5),\n            cos(ft * 0.5) + sin(ft*0.1)\n        ) * sin(iTime*0.1);\n        sphere = sphereDist(p - s_p + jiggle_p, 1.-fi*0.2);\n        // if (sphere < 0.125) mater = 2.;\n        d = smin(d, sphere, 0.5);\n    }\n    \n    if (d < 0.001) mater = 2.; // apply material to all smoothed objects thus far\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in int i) {\n    if (i==1){\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n        return lightPos;\n    }\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    vec3 lp = getLightPos(1);\n    vec3 l = normalize(lp-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = map(p+n*SURF_DIST*2.).x;\n    if(d<length(lp-p)) dif *= .1;\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 50.);\n    \n    return dif + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.r*100.));\n        col *= norm;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        vec3 text = texture(iChannel0, txuv).rrr;\n        col = mix(col,text*0.5,1.-col.r);\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.5,0.3,-3.); \n    ro.xz *= Rot(iTime*0.3);\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uv.x-.15, uv.y-.2, 1.0));\n    rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    // vec3 backColor = vec3(54./255., 57./255., 63./255.);\n    vec3 backColor = vec3(0.1);\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) {\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                vec3 lp = getLightPos(1);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                // ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    \n    \n    // col += glow*glow*glow*0.00000000000000001 * nsin(iTime*.5);\n\n    // Output to screen\n    // col = pow(col, vec3(.45));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}