{
    "Shader": {
        "info": {
            "date": "1588366564",
            "description": "Watch your head.",
            "flags": 64,
            "hasliked": 0,
            "id": "tdsfD8",
            "likes": 15,
            "name": "Pink beamkiller!",
            "published": 3,
            "tags": [
                "raymarching",
                "demoscene",
                "volumetric",
                "lights"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// sdf functions by iq\n// music by Twisterium\n// 02.05.2020: slightly enlarged beamrays\n//\n\nconst int iterationAmount=512;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\n//\n//\n//\n\nvec2 SDF(vec3 r)\n{\n    float mat=0.0;\n    vec3 origR=r;\n    float rotTime=iTime/1.0;\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    float cylRad=0.15+0.1*fft;\n    \n    r=rotz(r,rotTime);\n    r=roty(r,-rotTime);\n    float t = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    r=rotx(r,3.141592/2.0);\n    float t2 = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    r=rotz(r,3.141592/2.0);\n    float t3 = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    \n    t=min(min(t,t2),t3);\n    \n    return vec2(t,1.0);\n}\n\nvec2 SDFsolid(vec3 r)\n{\n    vec3 origR=r;\n    float t=1000.0;\n    float rotTime=iTime/1.0;\n\n    r=rotz(r,rotTime);\n    r=roty(r,-rotTime);\n\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    //float rbox = sdRoundBox(r,vec3(.5,.5,.5),.1);\n    float rbox = sdSphere(r,.69+fft*0.33);\n    float amt=10.0;\n    //rbox+=0.2*(0.5+abs(sin(iTime)))*cos(r.x*amt)*sin(r.y*amt)*cos(r.z*amt);\n    rbox+=(.10+0.05*fft)*cos(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=rbox;\n    \n    float cyllen=.55;\n    float cylrad=.19;\n    float tcyl0=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl0);\n    r=rotx(r,3.141592/2.0);\n    float tcyl1=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl1);\n    r=rotz(r,3.141592/2.0);\n    float tcyl2=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl2);\n    \n    /*\n    origR+=vec3(0.0,0.0,iTime);\n    int numq=5;\n    for (int i=0;i<numq;i++)\n    {\n        float c=.9;\n        vec3 q = vec3(origR.x,origR.y,mod(origR.z+0.5*c,c)-0.5*c);\n        vec3 rotatedr=rotz(q,(float(i)*3.141592*2.0)/float(numq));\n    \t//float abox=sdRoundBox(rotatedr-vec3(0.0,-2.3,4.0),vec3(1.82,.01,3.5),.1);\n        float box=sdSphere(rotatedr-vec3(0.0,-1.0,0.0),.2);\n        //float box=sdPlane(rotatedr-vec3(0.0,-1.0,0.0),vec4(0.0,1.0,0.0,1.0));\n        t=min(t,box);\n    }\n\t*/\n    \n    float ibox=sdInvertedBox(origR,vec3(5.5));\n    t=min(t,ibox);\n\n    if ((t==tcyl0)||(t==tcyl1)||(t==tcyl2)) return vec2(t,3.0);\n    if (t==rbox) return vec2(t,2.0);\n    return vec2(t,4.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFsolid(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float mintlc=100000.0;\n    float lightAccum=0.0;\n    float fogAccum=0.0;\n    \n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    \n    // light cone\n    float tlc = 0.0;\n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * tlc);\n        if (res[0]<0.0)\n        {\n            float fact=distance(vec3(0.),rayOrigin + rayDir * tlc);\n            float k=(abs(noise((rayOrigin+rayDir*tlc))));\n            //k*=0.02;\n            k*=0.08*fft;\n            //float cnst=0.08;\n            lightAccum+=mix(k,0.08,0.4)/fact;\n            //lightAccum+=k/fact;\n            if (tlc<mintlc) mintlc=tlc;\n        }\n        tlc += 0.0155;\n    }\n    \n    //lightAccum/=2.0;\n    //lightAccum=clamp(lightAccum,0.0,1.0);\n    \n    // solid shapes\n    float t=0.0;\n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDFsolid(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n    \t\tif (lightAccum>0.0)\n            {\n                vec3 vecLight=rayOrigin+rayDir*mintlc;\n                vec3 vecSolid=rayOrigin+rayDir*t;\n                \n                if (distance(rayOrigin,vecSolid)<=distance(rayOrigin,vecLight))\n                {\n                    return vec4(t,res[1],0.0,fogAccum);\n                }\n                else\n                {\n                    return vec4(t,res[1],lightAccum,fogAccum);\n                }\n            }\n            else\n            {\n                return vec4(t,res[1],0.0,fogAccum);\n            }\n        }\n\n        float n=abs(noise((rayOrigin+rayDir*tlc)));\n        //n=cos(n)*n*sin(n);\n        fogAccum+=n*0.04;\n        t += res[0];\n    }\n    \n\tif (lightAccum>0.0) return vec4(0.0,1.0,clamp(0.0,1.0,lightAccum),fogAccum);\n     \n    return vec4(-1.0,-1.0,-1.0,-1.0);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.0,0.0,-1.0));\n\n    vec4 rayHit = castRay(rayOrigin, rayDir);\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n\n    if (mat==1.0)\n    {\n        col=vec3(1.0,1.0,1.0)*rayHit[2];\n    }\n    else if (((mat==2.0)||(mat==3.0))||(mat==4.0))\n    {\n        vec3 N=calcNormal(rayOrigin + rayDir * rayHit[0]);\n        if (mat==2.0) \n        {\n    \t\tfloat rotTime=iTime/4.0;\n            vec3 N2=N;\n            N2=rotz(N2,rotTime);\n            N2=roty(N2,-rotTime);\n            vec2 matuv = vec2( atan(N2.x,N2.z), acos(N2.y ) );\n\t\t\tfloat intensity=max((dot(N2,L)),0.0);\n            intensity+= pow(intensity, 2.0);            \n            //col=texture(iChannel0,matuv).rrr;\n            //col=mix(col,vec3(intensity),0.9);\n            //col=vec3(intensity*0.817,intensity*0.32,intensity*0.5);\n            vec3 colstart=vec3(0.03,0.045,0.18);\n            vec3 colenddd=vec3(0.817,0.32,0.5);\n            col=mix(colstart,colenddd,intensity/2.0);\n        }\n        else if (mat==3.0) \n        {\n        \tfloat NoL=max(dot(N, L),0.0);\n            col=vec3(1.,1.,1.)*NoL;\n        }\n        else if (mat==4.0) \n        {\n            //vec3 ll=vec3(1.0,0.0,0.0);\n        \t//float NoL=max(dot(N, ll),0.0);\n            //float intens=0.1;\n            //col=vec3(intens)*NoL;\n            //col+=vec3(0.1,0.1,0.4);\n            //col/=pHit.z/3.2;\n        \tvec2 a=vec2(1.0);\n            if ((N.z>0.01)||(N.z<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.y, 1.)));\n            }\n            else if ((N.x>0.01)||(N.x<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.y, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n            }\n            else if ((N.y>0.01)||(N.y<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n            }\n            col = vec3(.6-a.x,.7-a.y,0.8-a.x);\n            //col*=NoL;\n        }\n        \n        // add fog\n        col+=vec3(rayHit[3]);\n        \n        // add lightrays\n        col+=vec3(rayHit[2]);\n        \n        // add beat\n        if (iTime>15.0) col+=pow(fft,16.0);\n    }\n    else\n    {\n        col=vec3(0.0,0.0,0.0);\n    }\n\n    //col=fog(col,, vec3 fxcol)\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime;\n    float rotTime=iTime*1.5;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    float radius=2.0+2.0*abs(sin(iTime));\n    //camPos = vec3(radius*sin(myTime),0.0,-radius*cos(myTime));\n    //camTarget = vec3(0.0,cos(myTime)*2.0,0.0);\n    camPos=vec3(radius*sin(rotTime),2.0*sin(rotTime),-radius*cos(rotTime));\n    camTarget=vec3(0.0,0.0,0.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz,1.0);\n\tfinalCol+=0.09;    \n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 22384,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/twisterium/trance-2-free-instrumental-background-music-creative-commons"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}