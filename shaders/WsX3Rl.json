{
    "Shader": {
        "info": {
            "date": "1547126293",
            "description": "study:\nit's very  convenient to draw elements (here, concentric rings) loopless using floor and fract. But managing antialiasing at borders can sometime be tedious.\nHere, I show how to antialias between rings using such loopless scheme. ",
            "flags": 0,
            "hasliked": 0,
            "id": "WsX3Rl",
            "likes": 16,
            "name": "antialiasing concentric rings",
            "published": 3,
            "tags": [
                "2d",
                "antialiasing",
                "hsv",
                "hue",
                "tuto",
                "short",
                "loopless"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 909
        },
        "renderpass": [
            {
                "code": "//#define hue(h) (  .6 + .6 * cos( h + vec4(0,23,21,0)  ) ) // Fabrice cos hue https://www.shadertoy.com/view/ll2cDc\n#define hue(h)   smoothstep( 0., 1.,  abs( mod( .955*(h) + vec4(0,4,2,0) , 6. ) - 3. ) -1. ) // IQ smooth hue https://www.shadertoy.com/view/MsS3Wc\n\nvec4 t(vec2 U, float c) {\n    float p = fwidth(U.y); if (p>3.) p = abs(p-6.283);       // pixel width (using hardware derivatives - 2Pi jump)\n  //float p = 1./ (.5*iResolution.y *U.x/2.5 );              //   explicit calculation\n    float k = 30.;                                           // strips along rings\n  //float k = 3.*(c+2.);                                     //   squares variant\n    return c > 0. && c < 9.\n            ? U.y += c * .03*iTime, //iMouse.x/R.x,          // individual ring rotation\n              ( .4 + .6* clamp(cos(k*U.y)/k/p, 0., 1.) )     // stripped pattern with angular antialiasing\n              * hue(U.y) \n            : vec4(0) ;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; \n    U = ( U+U - R ) / R.y;\n    U = vec2( 2.5*length(U), atan(U.y,U.x) ); // to polar\n    float c = 4.28*(U.x-.48), // floor: ring id (1..8). fract: index in ring\n          d = fwidth(c);      // pixel width at current location (using hardware derivatives)\n    \n    // --- managing antialiased ring drawing\n#if 1 // simple form    \n    O = mix( t(U,floor(c)), t(U,ceil(c)), min(fract(c)/d,1.) );\n\n#else // optimized form ( if most warps are not in borders )\n    O = fract(c) > d\n            ? t(U,ceil(c))    // seminal case\n            : mix( t(U,floor(c)), t(U,ceil(c)), fract(c)/d ); // border pixel\n#endif\n    \n  O = pow(O,vec4(1./2.2));  // better antialiasing if proper sRGB conversion\n                            // NB: with hueFabrice + sRGB colors are less vivid.\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}