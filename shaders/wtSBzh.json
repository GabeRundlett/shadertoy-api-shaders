{
    "Shader": {
        "info": {
            "date": "1598808371",
            "description": "Just a sad little chap sitting on a wall.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSBzh",
            "likes": 16,
            "name": "Waiting...",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "mood"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 381
        },
        "renderpass": [
            {
                "code": "// 'Waiting...'\n//\n// My first attempt at modelling a character.\n// Sort of a sad little wonkly wax chap...  With a butt...\n//\n// Concrete texture reused from my earlier shader:\n// https://www.shadertoy.com/view/WllfzB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n\n#define AA  // Comment out this line for a speed boost.\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// Thanks iq.\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fbm(vec3 p) {\n    return (texture(iChannel0, p * 0.01).r\n    + texture(iChannel0, p * 0.01978).r * 0.4848\n    + texture(iChannel0, p * 0.0391).r * 0.235\n    + texture(iChannel0, p * 0.07739).r * 0.114\n    + texture(iChannel0, p * 0.15307).r * 0.055\n    + texture(iChannel0, p * 0.30278).r * 0.027) / 1.9158;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 min2(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 f = pa*l2 - ba*y;\n    float x2 = dot(f, f);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat getConcreteMaterial(vec3 p, out vec3 mat) {\n    // Set rnd seed from id.\n    vec3 tp = p;\n    \n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(tp));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    float rough = noise(tp * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(tp * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    // Fade surface roughness(/deflection) out with distance to prevent screen noise.\n    return rough;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nbool isEye = false;\nfloat nod = 0.0;\nfloat head(vec3 p) {\n    p.y += 0.9;\n    nod = pow(abs(sin(iTime * 0.4) * 0.5 + 0.5), 2.0);\n    p.yz *= rot(0.4 * nod - 0.3);\n    p.xz *= rot(sin(iTime) * 0.2 * (1.0 - pow(nod, 2.0)));\n    p.y -= 0.9;\n    \n    float rough = fbm(p);\n    float d = length(p) - 1.0 - mix(-0.5, 0.5, rough);\n    \n    float eye = length(p + vec3(0.025, 0.3, 0.825)) - rough * 0.4; // Left eye\n    eye = min(eye, length(p + vec3(-0.4, 0.2, 0.75)) - rough * 0.5); // Right eye\n\n    isEye = eye < d;\n    return min(d, eye);\n}\n\n// Map the scene using SDF functions.\nvec4 map(vec3 p) {\n    vec3 op = p;\n    \n    // Wall.\n    float wall = sdBox(p + vec3(0.0, 4.15, -0.1), vec3(12.0, 2.0, 1.0));\n    vec3 mat;\n    wall -= getConcreteMaterial(p, mat);\n    mat *= 0.2;\n    \n    // Head.\n    p.y += 0.08;\n    p.z += 0.45;\n    float headd = head(p);\n    float d = headd;\n    \n    // Torso.\n    float rough = fbm(p);\n    d = smin(d, sdCapsule(p, vec3(0.0, -0.5, 0.0), vec3(0.0, -1.8, 0.0), rough - 0.25), 0.1);\n    \n    // Arms.\n    p.x = abs(p.x - 0.1);\n    const vec3 shoulder = vec3(0.34, -1.2, -0.1);\n    const vec3 elbow = vec3(0.44, -1.5, -0.1);\n    float w = sign(op.x) > 0.0 ? 0.2 : 0.08;\n    float fbm5 = fbm(p * 5.0);\n    float upper = sdCapsule(p, shoulder, elbow, fbm5 * w);\n    float lower = sdCapsule(p, elbow, vec3(0.34, -1.8, -0.2), fbm5 * w);\n    d = smin(d, smin(upper, lower, 0.02), mix(0.1, 0.0, min(distance(p, shoulder) * 2.5, 1.0)));\n    \n    // Butt.\n    p.x = abs(op.x - 0.04);\n    d = smin(d, length(p + vec3(-0.06, 1.95, -0.24)) - fbm5 * 0.3, 0.02);\n    \n    // Thighs.\n    p.x = abs(op.x - 0.06);\n    vec3 hip = vec3(0.12, -1.98, 0.0); \n    vec3 knee = vec3(0.15, -1.98, -0.55); \n    d = smin(d, sdCapsule(p, hip, knee, fbm5 * 0.3), 0.07);\n    \n    // Shins.\n    vec3 ankleDelta = vec3(0.0, -0.32, 0.0);\n    mat2 swing = rot(-max(0.0, abs(0.6 * sin(iTime * 1.5+ sign(op.x) * 0.3))));\n    ankleDelta.yz *= swing;\n    vec3 ankle = knee + ankleDelta;\n    d = min(d, sdRoundCone(p, knee, ankle, fbm5 * 0.3, fbm5 * 0.1));\n    \n    // Feet.\n    vec3 toeDelta = vec3(0.02, -0.04, -0.1);\n    toeDelta.yz *= swing;\n    vec3 toe = ankle + toeDelta;\n    d = min(d, sdRoundCone(p, ankle, toe, fbm5 * 0.15, fbm5 * 0.1));\n    \n    if (d < wall) {\n        mat = vec3(0.3, 0.3, 0.35);\n    \tif (isEye && abs(d - headd) < 0.001) mat = vec3(0.001);\n    }\n    \n    d = min(d, op.y + 5.0);\n    \n    return vec4(min(d, wall), mat);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float res = 1.0;\n    float t = 0.05;\n    for(float i = 0.0; i < 45.0; i++)\n    {\n        float h = map(p + rd * t).x;\n        if (h < MIN_DIST * t)\n            return 0.0; // Hit an object - Full shadow.\n        \n        res = min(res, 48.0 * h / t);\n        t += h;\n        \n        if (t > 20.0)\n            break; // Marched far enough - Stop.\n    }\n    \n    return res;\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).x / h;\n}\n\n// Subsurface scattering.\nfloat sss(vec3 p, vec3 ld, float h) {\n    return smoothstep(0.0, 1.0, map(p + h * ld).x / h);\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 back(vec2 uv) {\n    return vec3(fbm(vec3(0.0, uv * 20.0)) * 0.02) * (1.0 - uv.y * 2.0);\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, vec3 mat) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(10.0, 5.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p);\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    diff += sss(p, sunDir, 0.5);\n    \n    // Primary light (Sun).\n    float sha = calcShadow(p, sunPos) + 0.25;\n    vec3 lig = diff * sunCol * sha;\n\n    // Specular.\n    float spe = pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), 15.0);\n    lig += spe;\n\n    // Seconary light (Bounce light);\n    lig += max(0.0, dot(-sunDir, n)) * sunCol * 0.1 * amb;\n    \n    float fre = 1.0 + dot(rd, n);\n    const vec3 back = vec3(0.0);\n    return mix(mat.r == 0.001 ? vec3(spe) : mat * lig, back, fre);\n}\n\nvec4 march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01, prevd = 1.0;\n    vec4 h;\n    for (float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.x) < MIN_DIST)\n            break; // We've hit a surface - Stop.\n        if (d > 20.0) return vec4(1e7);\n        \n        d += h.x; // No hit, so keep marching.\n    }\n    \n    return h;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n  \tvec4 hit = march(ro, rd, p);\n    \n    if (hit.x > 1e6) return back(rd.xy);\n    \n    // Lighting.\n    return applyLighting(p, rd, hit.yzw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 12.0));\n    float phase = mod(floor(iTime / 12.0), 3.0);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 12.0)), 100.0);\n    \n    vec3 ro;\n    vec3 lookAt = vec3(0.0, -1.0, 0.0);\n    \n    if (phase == 0.0) {\n        ro = vec3(0.0, -0.5, mix(-8.0, -4.6, ft)); // -8.0 -4.6\n        ro.xz *= rot(mix(1.24, -0.3, ft)); // 1.24, -0.3\n    } else if (phase == 1.0) {\n        ro = vec3(0.0, mix(2.0, -2.0, ft), mix(-8.0, -4.2, ft)); // -3.9 -8.0\n        ro.xz *= rot(mix(-0.43, -0.2, ft)); // -0.2 -0.43\n    } else if (phase == 2.0) {\n        ro = vec3(0.0, -0.5, mix(-1.0, -4.23, ft)); // -1.0  -4.23\n        ro.xz *= rot(mix(2.19, 0.13, ft)); // 2.19 0.13\n        lookAt = vec3(0.0, -1.6, 0.0);\n    }\n    \n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 rd = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rd);\n#ifdef AA\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    // Output to screen.\n    col = vignette(pow(col * dim, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}