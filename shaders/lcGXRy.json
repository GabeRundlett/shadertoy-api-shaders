{
    "Shader": {
        "info": {
            "date": "1715355780",
            "description": "Based on my Spinning Nested Squares shader, but improved and generalized to support any number of faces. Click to set the number of faces or control the rotation.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcGXRy",
            "likes": 5,
            "name": "Spinning Nested Polygons",
            "published": 3,
            "tags": [
                "mouse",
                "recursion",
                "polygon"
            ],
            "usePreview": 0,
            "username": "Bingle",
            "viewed": 142
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define MAXITER 200.0\n\n// Spinning Nested Polygons by Bingle\n\n// Using this much trig might be a bad idea, but if it works it works lol\nfloat polarPoly(float theta, int sides){\n    float fs = float(sides);\n    return 1.0/cos(theta-2.0*(PI/fs)*round((fs*theta)/(2.0*PI)));\n}\n\nfloat rotScale(float angle, int sides){\n    float fs = float(sides);\n    float piFs = PI/fs;\n    return 1.0/(2.0*cos(mod(angle,2.0*piFs)-piFs)*cos(piFs));\n}\n\n// Returns the Beraha constants (Never heard of these until today while trying to figure out what sequence I was looking at)\nfloat beraha(int n){\n    return 2.0 + 2.0*cos((2.0*PI)/float(n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // Setup\n    float increment = 0.25*iTime+0.125;\n    int sides = int(iMouse.x/iResolution.x*7.0)+3;\n    \n    if (iMouse.x==0.0 && iMouse.y==0.0){\n        sides = 6;\n    }\n    \n    // Loop stuff\n    float depth = 0.0;\n    float scale = 1.0;\n    float angle = 0.0;\n    \n    if (iMouse.z>0.0){\n        increment = iMouse.y/iResolution.y * (PI*2.0);\n    }\n    \n    float theta = atan(uv.y,uv.x);\n    float r = length(uv);\n    \n    float scaleFac = rotScale(increment,sides)*beraha(sides)*0.5;\n    while (true){\n        if (depth>MAXITER){\n            break; // break statement so my gpu doesn't break\n        }\n        \n        if (r<scale*polarPoly(theta+angle,sides)){\n            depth++;\n            angle+=increment;\n            scale *= scaleFac;\n        }else{\n            break;\n        }\n        \n    }\n    \n    vec3 col = vec3(mod(depth,2.0));\n    \n    if (depth>MAXITER){\n        col = vec3(0.5); // Just go with grey because since we dont want the GPU to explode\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}