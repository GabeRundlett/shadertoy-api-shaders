{
    "Shader": {
        "info": {
            "date": "1475076048",
            "description": "Having fun with minimal 2D SDF-s. Messing around with the defines is encouraged :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4lK3W1",
            "likes": 23,
            "name": "Sloppy Day",
            "published": 3,
            "tags": [
                "2d",
                "sun",
                "moon",
                "night",
                "day"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 1053
        },
        "renderpass": [
            {
                "code": "#define SPEED 1.\n#define SMOOTH .2\n#define COLOR 1\n#define OUTLINE 0\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI 3.14159265359\n\n// circle distance function\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// distance field subtraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// smoot distance field union, thanks to iq \nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// moon distance function\nfloat moon(vec2 p, float r) {\n    return opS(circle(p, r), circle(p - vec2(r * .5, 0), r));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= .75;\n    uv.y += .4;\n    \n    // distance field\n    float dist = circle(uv + vec2(0, 6), 6.1);\n    \n    // celestial object glow\n    vec3 glow = vec3(0);\n    \n    // ellapsed time\n    float time = iTime * SPEED;\n    \n    // day/night cycle time\n    float dTime = -time - sin(time * 2.) * .25;\n    \n    // object space\n    vec2 suv;\n    \n    // add moon\n    suv = uv + vec2(cos(dTime), sin(dTime)) * .7;\n    suv *= rot(-dTime - PI/ 2.);\n    \n    dist = opSU(moon(suv, .2), dist, SMOOTH);\n    glow += smoothstep(1., 0., length(suv)) * vec3(.91, .76, .34) * .2;\n    \n    // add sun\n    dTime += PI;\n    suv = uv + vec2(cos(dTime), sin(dTime)) * .7;\n    \n    glow += smoothstep(1., 0., length(suv)) * vec3(.66, .63, .12) * .3;\n    dist = opSU(circle(suv, .2), dist, SMOOTH);\n    \n    // slope for antialiasing and outline\n    float width = fwidth(dist);\n    \n    // create a mask for the scene\n    float mask = smoothstep(-width, width, dist);\n    \n    #if COLOR\n    // gradients for foreground and background\n    float gradFg = smoothstep(0., 1., uv.y * 1. + .5);\n    float gradBg = smoothstep(0., 1., uv.y * .7 + .2);\n    \n    // daytime foreground and background\n    vec3 fg = mix(vec3(.12, .65, .34), vec3(.91, .76, .34), gradFg);\n    vec3 bg = mix(vec3(.54, .72, .91), vec3(.14, .33, .76), gradBg);\n    \n    // day/night colors interpolation value\n    float day = sin(dTime + PI) * .5 + .5;\n    \n    // nighttime foreground and background\n    fg = mix(mix(vec3(.15, .34, .31), vec3(.66, .63, .32), gradFg), fg, day);\n    bg = mix(mix(vec3(.14, .27, .49), vec3(.0, .09, .22), gradBg), bg, day);\n    \n    // add the glow\n    bg += glow;\n    \n    // create color using mask\n    fragColor = vec4(mix(fg, bg, mask), 1.);\n    #else\n    fragColor = vec4(mask);\n\t#endif\n    \n    // add the outline\n    #if OUTLINE\n    fragColor = fragColor * smoothstep(0., width* 1.5, abs(dist));\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}