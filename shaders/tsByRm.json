{
    "Shader": {
        "info": {
            "date": "1586301149",
            "description": "bluh",
            "flags": 0,
            "hasliked": 0,
            "id": "tsByRm",
            "likes": 3,
            "name": "the army of balls",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "hazenn",
            "viewed": 449
        },
        "renderpass": [
            {
                "code": "\n#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\nfloat smin( float a, float b)\n{\n\n    return smin(a,b,25.);\n}\n\nstruct RM{\n    float d;\n    int steps;\n};\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat GetDist(in vec3 p){\n    float d = MAX_DIST;\n    p = fract(abs(p)/3.)*3.-1.5;\n    d = length(p)-(0.2+0.4*abs(cos(iTime)));\n    d = smin(d,\n            length(p+0.2)-(0.2+0.4*abs(sin(iTime)))\n            );\n    d = smin(d,\n            length(p-0.5)-(0.2+0.4*abs(sin(iTime)+1.))\n            );\n    return d;\n}\n\n\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.1,0);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n    \n}\nRM RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    int steps = 0;\n    for(int i=0;i<MAX_STEPS;i++){\n        steps = i;\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if (d0>MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return RM(d0,steps);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    vec3 ro = vec3(10.*uv+2.,-iTime);\n    vec3 rd = (rot(vec3(0.,1.,0.),-(1.+abs(sin(iTime))))*vec4(0.75, uv.y, uv.x,1.)).xyz;\n    RM rm = RayMarch(ro,rd);\n    \n    float d = rm.d;\n    \n    \n    \n    \n    vec3 col = vec3(0);\n\t\n    col+= 1.-0.30*float(rm.steps);\n    col += 0.1*d;\n    col /= 10.;\n    col += 0.5+0.5*GetNormal(ro+rd*d); //normals\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat4 rot(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}