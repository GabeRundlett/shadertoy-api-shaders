{
    "Shader": {
        "info": {
            "date": "1598087005",
            "description": "More random boat moves.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsBzr",
            "likes": 5,
            "name": "Waves v.7",
            "published": 3,
            "tags": [
                "learning"
            ],
            "usePreview": 0,
            "username": "pli",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n\n#define SHARK_COLOR vec3(.5, .5, .5)\n\n#define SHADOW_COLOR vec3(1.0)\n\n\n#define BOAT_INITIAL_X -0.25\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distWaves(vec3 pos) {\n     vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n\n\treturn dist;\n}\n\nvec3 transformedFlotterPosition(vec3 position) {\n    position.xz = rot(0.35 * cos(iTime)) * position.xz;\n    vec3 translation = vec3(BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime), 0., BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime)); \n    vec3 transformedFlotterPosition = position + translation;\n\treturn transformedFlotterPosition;\n}\n\nfloat distBoat(vec3 pos, out vec3 headPosition) {\n\n    vec3 position = transformedFlotterPosition(vec3(0., 0., 0.));\n    vec3 p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    float distBoat = distSphere(pos, p, 0.05);\n\n    position = transformedFlotterPosition(vec3(0.05, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.1, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    \n    position = transformedFlotterPosition(vec3(0.0, 0., 0.05));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.05));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n\n\n    position = transformedFlotterPosition(vec3(0.0, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.05, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.1, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    headPosition = transformedFlotterPosition(vec3(0.05, 0., 0.05));\n\n    \n\treturn distBoat;\n}\n\nfloat distHead(vec3 pos, vec3 headPosition) {\n    vec3 p = vec3(headPosition.x, boatYAt(gridFromCoords(vec3(headPosition.x - 0.05, headPosition.y, headPosition.z))) + 0.05, headPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n\n    return headDist;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  float d = sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    \n\treturn d;\n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n\n    float dist = distWaves(pos);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    vec3 headPosition;\n\tfloat boatDist = distBoat(pos, headPosition);\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .6;\n    }\n    \n    \n    // head \n    float headDist = distHead(pos, headPosition);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.19, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch to the scene\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totalDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totalDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totalDist += dist;\n    }\n    \n    if(totalDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n    col = colorVariation * (1. + dot(normal, light));\n    \n    \n    // raymarch back toward the light to compute the shadows\n    light = normalize(vec3(1., 1.3, -3)); // tweak light to avoid the waves casting shadows on themselves\n\n    float shadow = 1.;\n    totalDist = 0.01;\n    dist = 0.0;\n\tfloat sv;\n    vec3 cv;\n    for(float s = 0.; s < STEPS; s++){\n        dist = distScene(pos + light * totalDist, cv, sv);\n        totalDist += dist;\n        shadow = min( shadow, 10.0*dist/totalDist );\n        if(shadow < 0.001 || totalDist > maxDist){\n            break;\n        }\n    }\n    shadow = clamp(shadow, 0., 1.);\n    col = col * (0.5 + 0.5*shadow);\n    \n    \n    //white highlight\n    if (shadow > 0.9) { // we don't want highlights in the shade, notably from the boat\n\t\tlight = normalize(vec3(1., 0.5, -3)); // tweak light to get higher shine\n        float shine = 10.;\n        vec3 refl = reflect(normalize(pos - light), normal);\n        float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n        spec = smoothstep(0.25, 0.45, spec - 0.4);\n        col = mix(col, vec3(1.), (shineVariation -  0.8 * colorVariation) * spec);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}