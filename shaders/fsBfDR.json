{
    "Shader": {
        "info": {
            "date": "1646893660",
            "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "fsBfDR",
            "likes": 12,
            "name": "[CrzClm] Multi Level AO",
            "published": 3,
            "tags": [
                "ao",
                "occlusion",
                "ambient",
                "crazyclimbers"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 477
        },
        "renderpass": [
            {
                "code": "#define LIGHTING\n#define AA\n\n#define PI acos(-1.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MIN_DIST 0.0001\n#define MAX_DIST 30.0\nvec3 ro = vec3(0), rd = vec3(0), camup;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v) {\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n  p.x = abs(p.x);\n  vec2 sc = vec2(sin(per), cos(per));\n  float k = (sc.y * p.x > sc.x * p.z) ? dot(p.xz, sc) : length(p.xz);\n  return sqrt(dot(p, p) + r.x * r.x - 2.0 * r.x * k) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, vec3(0))) + vmax(min(d, vec3(0.0)));\n}\n\nfloat sdScene(vec3 p) {\n  p += vec3(0, 0, .3);\n  R(p.xz, PI);\n  float d = sdBox(p - vec3(0, .275, .4), vec3(.75, .5, .5));\n  d = abs(d - .025) - .02;\n  d = max(d, -p.z);\n  d = min(length(p + vec3(.25, .125 - abs(cos(iTime * 1.5)) * .2 - .0125, -.5)) - .125 + .0125 - length(vec2(sin(p.z * 50.), sin(p.y * 50.))) * .0125, d);\n  d = min(length(p + vec3(-.25, .125 - abs(sin(iTime * 1.5)) * .2, -.5)) - .125, d);\n  R(p.xz, sin(iTime * .5));\n  const float BR = .005;\n  d = min(sdBox(p + vec3(0, .125, -.75), vec3(.125 + abs(sin(iTime * .5)) * .125, .125, .125) - BR) - BR, d);\n  R(p.xz, cos(iTime * .5) * .5);\n  p += vec3(0, abs(cos(iTime * .25)) * .125, -.75);\n  R(p.yz, sin(iTime) * PI);\n  d = min(sdBox(p, vec3(.125 + abs(cos(iTime * .5)) * .125, .125, .125) - BR) - BR, d);\n\n  return d;\n}\n\nfloat intersect() {\n  float d = MIN_DIST;\n  for(int i = 0; i < 60; i++) {\n    vec3 p = ro + d * rd;\n    float res = sdScene(p);\n    if(abs(res) < MIN_DIST) break;\n    d += res;\n    if(d >= MAX_DIST) return MAX_DIST;\n  }\n  if(d > MAX_DIST) return MAX_DIST;\n  return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n  vec3 n = vec3(0.0);\n  for(int i = 0; i < 4; i++) {\n    vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n    n += e * sdScene(p + 0.0005 * e);\n  }\n  return normalize(n);\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat aoSeed = 0.;  // for reduce artefact that occur in lower number of samping.\nconst float MAX_SAMP = 4.;  // you can reduce number of samping at each level.\nfloat ao(vec3 p, vec3 n, float radius) {\n  float ao = 0.;\n  for(float i = 0.; i <= MAX_SAMP; i++) {\n    vec2 rnd = hash21(i + 1. + aoSeed);\n\n    // The contribution is adjusted according to the distance from the origin.\n    // http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n    float scale = (i + 1.) / MAX_SAMP;\n    scale = mix(.0, 1., pow(scale, .5));  // I should pow with 2., but it looks nicer with .5. I dont know why...\n\n    // random radians for rotate normal in hemisphere.\n    rnd.x = (rnd.x * 2. - 1.) * PI * .5;\n    rnd.y = (rnd.y * 2. - 1.) * PI;\n    vec3 rd = normalize(n + hash21(i + 2. + aoSeed).xyx);\n    rd.xy *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n    rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n\n    // http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\n    rd *= sign(dot(rd, n));\n\n    float raylen = radius * scale;\n    vec3 rndp = p + normalize(n + rd) * raylen;\n    float res = clamp(sdScene(rndp) / raylen, .01, 1.);\n    ao += res;\n    aoSeed++;\n  }\n  return ao / float(MAX_SAMP);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld) {\n  float norm_factor = (shininess + 5.) / (2. * PI);\n  vec3 h = normalize(-vd + ld);\n  return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\n\nvec3 ACESFilm(vec3 x) {\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid camera(vec2 uv) {\n  const float pY = .5;\n  const float cL = 10.;\n  const vec3 forcus = vec3(0, .2, -.137);\n  const float fov = .015;\n  vec3 up = vec3(0, 1, 0);\n  vec3 pos = vec3(0, .8, 3) * 8.;\n  if(iMouse.z > .5) {\n    pos = vec3(sin(iMouse.x / iResolution.x * PI + PI * .5), sin(iMouse.y / iResolution.y * PI * 2.), cos(iMouse.x / iResolution.x * PI + PI * .5)) * cL;\n    R(pos.xz, PI);\n  }\n  vec3 dir = normalize(forcus - pos);\n  vec3 target = pos - dir;\n  vec3 cw = normalize(target - pos);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu, cw));\n  camup = cv;\n  mat3 camMat = mat3(cu, cv, cw);\n  rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n  ro = pos;\n}\n\n#ifdef AA\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#endif\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = (uv * 2. - 1.);\n  uv.x *= iResolution.x / iResolution.y;\n  camera(uv);\n  float hit = intersect();\n  vec3 p = ro + hit * rd;\n  vec3 n = normal(p);\n\n  // For example:\n  // 4 levels x 4 sampling = 16 sampling\n  // I think this is not so bad :)\n  float a = ao(p, n, .2);\n  a += ao(p, n, .5);\n  a += ao(p, n, .8);\n  a += ao(p, n, 1.2);\n  a /= 5.;  // a little bit darker.\n\n#ifdef LIGHTING\n  vec3 ldir = normalize(vec3(0, 1.5, 1.75));\n  R(ldir.xz, sin(iTime * .25) * .75);\n  float diff = max(0., dot(n, ldir)) * (1. / PI);\n  float indr = (dot(n, -ldir) * .5 + .5) * (1. / PI);\n  float spec = normalizedBlinnPhong(1. / .0005, n, rd, ldir);\n  const float albd = .45;\n  float st = 0.;\n  float sdw = 1.;\n  p += n * .01;\n  for(int i = 0; i < 80; i++) {\n    float d = sdScene(p + ldir * st);\n    d += length(hash21(fragCoord.x * fragCoord.y + iTime + float(i))) * .0005;\n    if(d < MIN_DIST * 20.) {\n      sdw = 0.;\n      break;\n    }\n    if(st > MAX_DIST * .8) { break; }\n    st += d;\n  }\n  a = albd * diff * 4. * sdw + .25 * a + indr * a * .8 + spec * 10. * sdw;\n  a += length(hash21(fragCoord.x * fragCoord.y + iTime)) * (1. - pow(a, .75)) * .025;  // add a little dithering\n\n  a = ACESFilm(vec3(a)).r;\n  a = smoothstep(.0, 1., pow(a, 1.5));\n#endif\n\n  fragColor = vec4(vec3(pow(a, .4545)), 1);\n}\n\n#ifdef AA\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n  mainImage0(O, U);\n  if(fwidth(length(O)) > .01) {  // difference threshold between neighbor pixels\n    vec4 o;\n    for(int k = 0; k < 9; k += k == 3 ? 2 : 1) {\n      mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.);\n      O += o;\n    }\n    O /= 9.;\n    // O.r++;                        // uncomment to see where the oversampling occurs\n  }\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}