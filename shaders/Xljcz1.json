{
    "Shader": {
        "info": {
            "date": "1507498372",
            "description": "variation of https://www.shadertoy.com/view/XlfyWl\n",
            "flags": 32,
            "hasliked": 0,
            "id": "Xljcz1",
            "likes": 81,
            "name": "BloOoOoOoOoOom",
            "published": 3,
            "tags": [
                "bloom",
                "glow"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 8279
        },
        "renderpass": [
            {
                "code": "// BloOoOoOoOoOom\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nvariation of https://www.shadertoy.com/view/XlfyWl\n*/\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// BloOoOoOoOoOom\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nvariation  of https://www.shadertoy.com/view/XlfyWl\n*/\n\n#define SPOT_COUNT_MUL 12.0\n\n// #define USE_SSAA\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi2  = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define If(cond, tru, fls) mix(fls, tru, cond)\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggestes by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggestes by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggestes by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n    \n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n#if 0\n// shoulder of the s-curve\nfloat SCurveU_Sh(float x)\n{\n    float a = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 1.0 / 60.0 :\n              x < 0.75 ?  47.0 / 60.0 :\n                         -49.0 / 15.0 ;\n    \n    float b = x < 0.25 ?   2.0        :\n              x < 0.5  ?   7.0 /  3.0 :\n              x < 0.75 ? -17.0 /  3.0 :\n                          64.0 /  3.0 ; \n\n    float c = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 8.0 /  3.0 :\n              x < 0.75 ?  88.0 /  3.0 :\n                         -128.0/  3.0 ; \n\n    float d = x < 0.25 ?   0.0        :\n              x < 0.5  ?  32.0 /  3.0 :\n              x < 0.75 ? -160.0/  3.0 :\n                          128.0/  3.0 ; \n    \n    float e = x < 0.25 ?   0.0        :\n              x < 0.5  ? -64.0 /  3.0 :\n              x < 0.75 ?  128.0/  3.0 :\n                         -64.0 /  3.0 ;    \n    \n    float f = x < 0.25 ? -64.0 / 15.0 :\n              x < 0.5  ?  64.0 /  5.0 :\n              x < 0.75 ? -64.0 /  5.0 :\n                          64.0 / 15.0 ;  \n    \n    float r = a + x*(b + x*(c + x*(d + x*(e + x*f))));   \n    \n    return r;\n}\n\n// s-curve [-1..1]\nfloat SCurveU(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU_Sh(abs(x)) * s;\n}\n\nfloat Noise(vec2 uv, float time, uvec3 seed)\n{       \n    uv = uv * vec2(0.97617, 1.38559) + vec2(0.93792, 0.77608);// diffusion\n    time = time * 1.17739 + 0.62852;\n    \n    return Hash(vec3(uv, time), seed);  \n}\n\nfloat BNoise(vec2 uv, float time, uvec3 seed)\n{    \n    float v  = Noise(uv, time, seed);\n    \n    float v0 = Noise(uv + vec2(-1.0, 0.0), time, seed);\n    float v1 = Noise(uv + vec2( 1.0, 0.0), time, seed);\n    float v2 = Noise(uv + vec2( 0.0,-1.0), time, seed);\n    float v3 = Noise(uv + vec2( 0.0, 1.0), time, seed);\n      \n    float vf = (v0+v1+v2+v3) * 0.125 + v * -0.5;    \n    \n    vf = SCurveU(vf);\n    \n    return vf;// return v to get white noise for comparison \n}\n#endif\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n// Spherical Fibonacci Mapping\n// http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/\n// Authors: Benjamin Keinert, Matthias Innmann, Michael Sänger, Marc Stamminger\n// (code copied from: https://www.shadertoy.com/view/4t2XWK)\n//-------------------------------------------------------------------------------------------------//\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nProjSphereArea - returns the screen space area of the projection of a sphere (assuming its an ellipse)\n\nIN:\n\trdz- z component of the unnormalized ray direction in camera space\n\tp  - center position of the sphere in camera space\n\trr - squared radius of the sphere\n\n\"Sphere - projection\" code used under\nThe MIT License\nCopyright © 2014 Inigo Quilez\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nfloat ProjSphereArea(float rdz, vec3 p, float rr)\n{\n\tfloat zz = p.z * p.z;\t\n\tfloat ll = dot(p, p);\n\t\n\t//return Pi * rdz*rdz * rr * sqrt(abs((rr - ll) / (zz - rr))) / (zz - rr);\n    return Pi * rdz*rdz * rr * rsqrt(abs(Pow3(rr - zz) / (rr - ll)));\n}\n\n// https://www.shadertoy.com/view/XtfyWs\nvec4 ProjDisk(vec3 rd, vec3 p, vec3 n, float rr)\n{   \n    vec3 np0 = n * p.xyz;\n    vec3 np1 = n * p.yzx;\n    vec3 np2 = n * p.zxy;  \n\n    mat3 k_mat = mat3(vec3( np0.y + np0.z,  np2.x        ,  np1.x        ),\n\t\t\t\t\t\t  vec3(-np2.y        ,  np1.y        , -np0.x - np0.z),\n\t\t\t\t\t\t  vec3(-np1.z        , -np0.x - np0.y,  np2.z        ));    \n    \n    vec3 u =     k_mat * rd;\n    vec3 k = u * k_mat;\n    \n    \n    float nrd = dot(n, rd);\n    \n    float nrd_rr = nrd * rr;\n\n    \n    float v = dot(u, u) - nrd * nrd_rr; \n    vec3  g =    (k     - n   * nrd_rr) * 2.0;   \n    \n    return vec4(g.xy, 0.0, v);\n}\n\n\n\nfloat Sph(float x, float rr) { return sqrt(rr - x*x); }\nfloat SphX0(float d, float rr0, float rr1) { return 0.5 * (d + (rr0 - rr1) / d); }\n\nvec3 EvalSceneCol(vec3 cpos, mat3 cam_mat, float focalLen, vec2 uv0, float time)\n{      \n    const vec3 cBG = 0.0 * vec3(0.9, 1.0, 1.2);\n\n        \n    vec2 uv2 = uv0 - PixelCount.xy * 0.5;\n    \n  \tvec3 rdir0 = vec3(uv2, focalLen);\n    vec3 rdir = normalize(cam_mat * rdir0); \n    \n    float rdir0S = 0.5 * PixelCount.x;\n    rdir0 /= rdir0S;\n    \n    \n    \n    vec2 t;\n\tfloat hit = Intersect_Ray_Sphere(cpos, rdir, vec3(0.0), 1.0, OUT t);\n    \n    if(hit <= 0.0) return cBG;\n\n\n    vec3 pf = cpos + rdir * t.x;\n    vec3 pb = cpos + rdir * t.y;\n\n\tvec3 col = cBG;\n\n    //float lerpF = 0.0;\n    \n    float rra = 0.0;\n\n    vec3 p2;\n    float rr;\n    {\n        const float s = SPOT_COUNT_MUL; //       SPOT_COUNT_MUL\n        const float n = 1024.0*s;\n\n        float id = sf2id(pf.xzy, n);\n              p2 = id2sf(id,     n).xzy;        \n\n        float u = id / n;\n       \n        float arg = (-u* 615.5*2.0*s) + time * 1.0;//238-3 384.-2 615-1\n\n        rra = sin(arg);\n\n        #if 1    \n        //for(float i = 0.0; i < 2.0; ++i)        \n        rra = (Pow2(rra)*2.-1.);\n        #endif\n\n        rra = Pow2(rra);        \n\n        rr = 0.0025/s * rra; \n    }\n    \n    \n    vec3 n2 = normalize(p2);\n    \n    const float maskS = 0.5;// sharpness\n\n    \n    if(SqrLen(pf - p2) > rr) return cBG;\n\n    float d = length(p2);\n\n    float x0 = SphX0(d, 1.0, rr);        \n    vec3 d0c = n2 * x0;\n\n    float d0rr = 1.0 - x0*x0;\n\n    vec3 dp_c = (d0c - cpos) * cam_mat;\n    vec3 dn_c = n2 * cam_mat;\n\n    vec4 r = ProjDisk(rdir0, dp_c, dn_c, d0rr);        \n\n    float cmask = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n\n    float cmask2 = 0.0;\n    {\n        vec3 d1c = n2 * (x0 - 0.008);\n\n        vec4 r = ProjDisk(rdir0, (d1c - cpos) * cam_mat, n2 * cam_mat, (1.0 - x0*x0)*rra);\n        cmask2 = clamp01(-r.w * rsqrt(dot(r.xy, r.xy))*rdir0S * maskS);\n    }\n\n\n    #if 1\t\n    float A = ProjSphereArea(rdir0.z, dp_c, d0rr);        \n    A *= rdir0S*rdir0S;\n\n    float NdV = abs(dot(dn_c, normalize(dp_c)));\n\n    A *= NdV;\n    \n    #ifndef USE_SSAA\n    A *= NdV;\n    cmask *= clamp01((A -2.0)*0.125);\n    #else\n    A = mix(A, A*NdV, 0.5);\n    cmask *= clamp01((A - 3.)*0.125);\n    #endif\n\n\n    #endif\n\n\n    const vec3 cB = vec3(0.1, 0.35, 1.0);\n    const vec3 cR = vec3(1., 0.02, 0.2);\n\n    //vec3 cX = mix(cB, cR, lerpF);\n    //vec3 cY = mix(cR, cB, lerpF);\n\n    return mix(cBG, mix(cB*1.2, vec3(0.4, -0.15, -0.05), cmask2), cmask);        \n    //return mix(cBG, mix(cR, cB, cmask2), cmask);\n    //return mix(cBG, mix(cX, cY, cmask2), cmask);        \n    //return mix(cBG, mix(cW, cX, cmask2), cmask);\n    //return mix(cBG, vec3(1.0), cmask);\n    //return vec3(-r.w*10.0);\n    //return vec3(1.0);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n  \n    float time = Time; \n    //float noise0 = BNoise(uv, Time, uvec3(0x3824E65Cu, 0xDE74DC07u, 0x779899B8u));\n    //float noise1 = BNoise(uv, Time, uvec3(0xF41058FCu, 0xEA297D0Au, 0xC0EE8F01u));\n    //float noise = noise0 * 0.5;\n    //noise = (noise0 + noise1) * 0.5;\n    float noise = Hash(vec3(uv, Time) * 0.435 + 0.847, uvec3(0x0D5B3B33u, 0x1451393Cu, 0x29176787u)) * 0.5;\n    \n    time += iTimeDelta * noise;\n    //vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.3);\n    //ang += mouseAccu.xy * 0.008;\n\n    #if 1\n    ang.x += time * 0.15*1.5;\n    ang.y += sin(time * 0.27 * Pi) * 0.1;\n    \n    //ang.y += time * 0.073;\n    #endif\n\n    float fov = Pi * 0.5;\n    \n    mat3 cam_mat;\n    float focalLen;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        vec3 up    = cross(right, front);\n\n        focalLen = PixelCount.x * 0.5 * tan(Pi05 - fov * 0.5);\n        \n        cam_mat = mat3(right, up, front);\n    }\n    \n    //vec3 cpos = -cam_mat[2] * (exp2(-0.3 + mouseAccu.w * 0.03));\n    vec3 cpos = -cam_mat[2] * (exp2(-0.3));\n\n    cpos.y += .75;\n    cpos.y += cos(time * 0.153 * Pi*1.0) * 0.08;\n    \n    #ifndef USE_SSAA\n    \n\tcol = EvalSceneCol(cpos, cam_mat, focalLen, uv0, time);\n    \n\t#elif 1\n    \n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7));\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9));   \n    col *= 0.2;\n    \n \t#elif 1\n    \n    float o = 1.;\n    col  = EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.3, 0.1) * o - 0.5*o+0.5) * vec3(1.5, 0.75, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.9, 0.3) * o - 0.5*o+0.5) * vec3(0.0, 0.0, 3.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.5, 0.5) * o - 0.5*o+0.5) * vec3(0.0, 3.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.1, 0.7) * o - 0.5*o+0.5) * vec3(3.0, 0.0, 0.0);\n    col += EvalSceneCol(cpos, cam_mat, focalLen, uv + vec2(0.7, 0.9) * o - 0.5*o+0.5) * vec3(0.0, 0.75, 1.5);   \n    \n    col /= vec3(4.5, 4.5, 4.5);\n\n    #endif\n\n\n    \n    #if 1\n    vec2 tex = uv0.xy / PixelCount;\n    vec2 o = .0006 * vec2(1., PixelCount.x / PixelCount.y);\n    float h = Hash(vec3(uv, Time) * 0.435 + 0.847, uvec3(0xB5701DB5u, 0xDB985643u, 0x2063262Fu));\n    vec2 od = AngToVec(h * Pi);\n    //od = vec2(rsqrt(2.0));\n    \n    vec3 c0 = textureLod(iChannel0, tex, 0.0).rgb;\n    vec3 c1 = textureLod(iChannel0, tex + o * vec2( od.x, od.y) , 0.0).rgb;\n    vec3 c2 = textureLod(iChannel0, tex + o * vec2(-od.y, od.x) , 0.0).rgb;\n    vec3 c3 = textureLod(iChannel0, tex + o * vec2( od.y,-od.x) , 0.0).rgb;\n    vec3 c4 = textureLod(iChannel0, tex + o * vec2(-od.x,-od.y) , 0.0).rgb;\n    \n    vec3 cc = (c1 + c2 + c3 + c4) * 0.25;\n    \n    col *= 8.;\n    col = mix(cc, col, iTimeDelta / (iTimeDelta + 1.));\n    //col = col * 0.2  + c0 * 0.95;\n    //col =cc;\n    #endif\n    \n    outCol = vec4(col, 0.);\n\t//outCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}