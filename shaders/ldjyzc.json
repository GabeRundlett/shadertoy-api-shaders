{
    "Shader": {
        "info": {
            "date": "1493648510",
            "description": "A path running through some dry rocky terrain. Rendered in a pseudo low-poly style.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldjyzc",
            "likes": 81,
            "name": "Mountain Path",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "bump",
                "cellular",
                "lowpoly",
                "path",
                "stairs"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 7169
        },
        "renderpass": [
            {
                "code": "/*\n\n\tMountain Path\n\t-------------\n\n    A path running through some dry rocky terrain. Rendered in a pseudo low-poly style.\n\n\tThis was orginally supposed to be a simple curvy path through a field, but then I wondered what\n\tstepping the path would look like, then I wanted to see what it'd look like going through\n\tsomething... so now, I'm not really sure what it is, or why anyone in their right mind would \n\tbuild a ridiculously long path in the middle of a mountainous pass that leads to nowhere. :)\n\n\tI'm fond of the old demo scenes and those pictures on 80s sci-fi novels, so I went for a psuedo \n\tlow-poly look with a little realism thrown into the mix. The geometry was surprisingly simple to \n    produce - I thought the stairs might present some problems, but it just involved stepping the \n    path heights and dealing with the overlap.\n\n\tThe low poly terrain is just a sinusoidal-based layer with some relatively cheap cellular noise \n\tadded to it. Anyway, this is just a practice run for a more interesting variation I have in mind.\n\t\n\n\n*/\n\n#define FAR 80. // Maximum ray distance. Analogous to the far plane.\n\n\n// Scene object ID. Either the path (0) or the surroundings (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(cos(dot(p, vec3(157, 113, 7)))*45758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p);\n    //return max(max(p.x, p.y), p.z);  \n\n    \n    // Cubic.\n    p = abs(fract(p) - .5); \n    return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    //p = abs(fract(p) - .5); \n    //p = max(p*.866025 + p.yzx*.5, p.yzx);\n    //return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return 1. - min(d.x, d.y)*2.; // Scale between zero and one... roughly.\n    \n    // For anyone wanting to experiment with this, the following gives better variance:\n    //const float scale = 1.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    //return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\n/*\n// Second order version.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.; // Normalize.\n    \n}\n*/\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Path 1.\n    //return vec2(sin(z*.05)*cos(z*.1)*2.5, sin(z*.06)*2.); // Path 2.\n    return vec2(sin(z*.15)*2.5, cos(z*.1)); // Path 3.\n}\n\n// Stair path.\nvec2 sPathF(in vec2 p){ \n\n    //return vec2(0); // Path 1.\n    //return sin(p*.06)*2.; // Path 2.\n    return cos(p*.1); // Path 3.\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    return cellTile(p/8.);//*.8 + dot(tri(p*0.384*2. + tri(p.yzx*0.192*2.)), vec3(0.666))*.2;\n     \n    // More interesting formations, and still quick, but not fast enough for this example.\n    //return cellTile(p/10.)*.75 + cellTile(p/10.*3.)*.25; \n \n    // Very cheap triangle noise. Looks OK, all things considering.\n    //p /= 2.5;\n\t//float n = dot(tri(p*0.5 + tri(p.yzx*0.25)), vec3(0.666));\n    //return n*.75 + dot(tri(p*0.75 + tri(p.yzx*0.375)), vec3(0.666))*.25;\n\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Drawing repeat objects right up again one another causes inaccuracies, so you get \n// around that by rending two sets of repeat objects in each dimension. Two for one\n// axis, four for two axes, and eight (I think) for three.\n//\n// Basically, the aforementioned is just a way to say that to draw stairs along the \n// Z-axis, you need to draw two sets of repeat boxes. The boxes are aligned with the \n// path position. In the case of the step portion, the path's height has to be \n// snapped to a quantized number. You do that via flooring, etc.\nfloat stairs(in vec3 p, vec2 pth){\n   \n    const float sc = 2.; // Stair scaling factor. It affects the length.\n    // The quantized stair heights. Basically, making the surface flat. Two heights are \n    // being passed in to account for the two boxes we have to render to account for the\n    // overlap.\n    vec2 iPthY = sPathF(floor(vec2(p.z/sc, p.z/sc + .5))*sc);\n    // Snapping the stair height to factors of four. Makes the step layers equal height.\n    iPthY = floor(iPthY*4.)/4. - 2.5;   \n\n    // Railings. Draw one railing using the path's X and Y positions, then use the\n    // \"abs\" repeat trick to render the other one at the same time.\n    float sY = abs(p.y - pth.y + 2.); // Railing height.\n    p.x = abs(p.x - pth.x); // Railing X-position.\n\n    // Railing, with a bit carved out.\n    float rails = max(abs(p.x - 1.75 + .35/2.) - .35/2., sY - .85);\n    float rails2 = max(abs(p.x - 1.75 + .35/2. + .3) - .35/2., sY - .65);\n    rails = max(rails, -rails2);\n    \n    // Stair render.\n    p.z /= sc;\n    \n    vec2 iy = p.yy - iPthY; // Quantized stair heights.\n    // Render a couple of boxes, then take the minimum.\n    vec2 qz  = abs(fract(vec2(p.z, p.z + .5)) - .5); \n    vec2 n = max(max(p.xx - 1.7, qz - .27), abs(iy) - .75);\n\n    // Return the path object - the minimum of the stairs and the railings.\n    return min(rails, min(n.x, n.y));\n     \n    \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat map(vec3 p){\n    \n    vec2 pth = path(p.z);\n    \n    float sf = surfFunc(p); // Surface perturbation.\n\n    // The terrain base layer.\n    float ter = p.y - 3. + dot(sin(p*3.14159/18. - cos(p.yzx*3.14159/18.)), vec3(3)); // 6. smoothing factor.\n    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.\n\n    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.\n\n    p.xy -= pth; // Wrap the tunnel around the path.\n\n    float n = 1.5 - length(p.xy*vec2(.5, 1)); // The tunnel to bore through the rock.\n    n = smax(n + (.5 - sf)*1.5, ter + (.5 - sf)*3., 6.); // Smoothly boring the tunnel through the terrain.\n    n = smax(n, -max(abs(p.x) - 1.75, abs(p.y + 1.5) - 1.5), .5); // Clearing away the rock around the stairs.\n \n    // Object ID.\n    objID = step(n, st); // Either the physical path or the surrounds.\n    \n    return min(n, st)*.866; // Return the minimum hit point.\n \n}\n \n\n// Pavers. Standard grid stuff.\nfloat paver(vec2 p, float mortW){\n\t\n    \n    vec2 q = abs(fract(p + vec2(.5, .5)) - .5);\n    \n    float d = max(q.x, q.y) - .5;\n    \n    //float c = smoothstep(0., mortW, min(q.x, q.y));\n    float c = smoothstep(0., .02, abs(d) - mortW/3.);\n    //if (q.x<.05 || q.y<.05) c *= .5;\n\n    return c;\n\n    \n}\n\n\n// Surface bump function. Tiles are fiddly, but simple enough. Basically, the surface\n// normal is used to determine the 2D plane we wish to tile, then it's passed to the\n// tile function.\nfloat tiles( in vec3 p, in vec3 n,  float mortW){\n    \n    p.xy -= path(p.z);\n\n    n = abs(n);\n    \n    float c = 1.;\n    \n    if (n.x>0.5) {\n        \n        if(p.y<-1.35) return 1.;\n        p.xy = p.yz;\n\n    }\n    else if (n.y>0.5) {\n         \n       if(p.y>-1.35) p.x += sign(p.x)*.25;\n        \n        p.xy = p.xz;\n        \n    }\n    \n    return paver(p.xz, mortW);\n    \n}\n\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n\n\n    float c;\n    if(svObjID>.5 ) c = 1. - surfFunc(p*3.); // cellTile(p/8.*3.);\n    else c = tiles(p.xyz, n, .1);\n    \n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(8./iResolution.y, 0); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x*2.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<160; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 48; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .07, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .15, 1.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n\n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return smoothstep(.15, .5, tx); \n    \n}\n*/\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 f = fract(p); p -= f; f *= f*(3. - f*2.);  \n    \n    return dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(p, vec2(41, 289)))*43758.5453))*\n                vec2(1. - f.y, f.y), vec2(1. - f.x, f.x) );\n\n}\n\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec2 p){\n    \n    // Four layers of 3D noise.\n    return 0.5333*n2D( p ) + 0.2667*n2D( p*2.02 ) + 0.1333*n2D( p*4.03 ) + 0.0667*n2D( p*8.03 );\n\n}\n\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.0); // Sun strength.\n\tfloat horiz = pow(1.0-max(rd.y, 0.0), 3.)*.35; // Horizon strength.\n\t\n    //vec3 col = mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25*.5;\n    \n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon.\n\tcol = mix(col, vec3(1, .9, .7), horiz);\n    \n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.25*vec3(1, .7, .4)*pow(sun, 5.0);\n\tcol += 0.25*vec3(1, .8, .6)*pow(sun, 64.0);\n\tcol += 0.15*vec3(1, .9, .7)*max(pow(sun, 512.0), .25);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.04 - 0.02, 0., 1.);\n    \n    //return col;\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n    \n    float t = (5000. - ro.y)/rd.y; // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    //vec3 sc = vec3(uv.x, 0., uv.y);\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) col = mix( col, vec3(1, .9, .8), 0.35*smoothstep(0.4, 1.0, fbm(.0005*uv)* clamp(rd.y*5., 0., 1.)));\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n    // Object texture color, with some contract thrown in.\n    vec3 tx;\n    //tx = smoothstep(.05, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.5) {\n        tx = tex3D(iChannel0, p/2., n );\n        tx = smoothstep(-.1, .5, tx);\n        tx *= vec3(1, .6, .35); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.1, .6, surfFunc(p))*.6 + .4;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else {\n        vec2 pth = path(p.z);\n        tx = tex3D(iChannel0, (p - vec3(pth.xy - .5, .0)), n );\n        tx = smoothstep(-.15, .5, tx);\n        tx *= vec3(1.5, 1.0, .5)*.65 + .5; // Tinting the stairs.\n        tx *= tiles(p.xyz, n, .05)*.93 + .07;\n        \n        if(p.y - pth.y>-1.35) tx *= vec3(.64, .62, .6); // Rails.\n        \n        \n    }\n    \n    //tx *= bumpFunc(p.xyz, n);\n\n    \n    return tx;//pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        float edge = 0., crv = 1.;\n        vec3 sn = getNormal(sp, edge, crv);\n\n\n        float bf = .5;\n        if(svObjID<.5) bf = .01;\n\n        float edge2 = 0., crv2 = 1.; \n        //if(svObjID>.5)\n        sn = doBumpMap(sp, sn, bf/(1. + t/FAR*.125), edge2, crv2); \n\n        bf = .07;\n        \n        float txF = 1.;\n        if(svObjID<.5) {\n            bf = .04;\n            txF = 2.;\n        }\n        sn = doBumpMap(iChannel0, sp*txF, sn, bf);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.3)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 3./(1. + lDist*0.01 + lDist*lDist*0.00008);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec*1.);\n        \n        // Edges.\n        if(svObjID>.5) \n           sceneCol *= 1. - edge2*.6; // Bump mapped edging for the terrain only.     \n        \n        //if(svObjID>.5) \n        sceneCol *= 1. - edge*.8; // Geometry based edging.\n        \n        // Reflection. Not really suitable for this example.\n        //sceneCol += eMap(reflect(rd, sn), sn);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(10., FAR*.24, FAR*.52)*3.;\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/32.);\n    rd.yz *= r2(-sw.y/16.);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp);\n    \n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR); // t/FAR; \n\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n    // Sprinkles.\n    //sceneColor *= 1. + hash31(sp)*.1 - .05; \n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    /*\n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    uv = sin(uv*r2(3.14159/6.)*3.14159*iResolution.y/1.5)*.1 + 1.;\n    sceneColor *= uv.x*uv.y;\n    */\n    // Mild LCD overlay.\n    //vec2 rg = mix(mod(fragCoord, vec2(3))*sceneColor.xy, sceneColor.xy, .65);\n    //sceneColor = vec3(rg, sceneColor.z - mix(sceneColor.x - rg.x, sceneColor.y - rg.y, .65));\n    \n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}