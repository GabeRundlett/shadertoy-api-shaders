{
    "Shader": {
        "info": {
            "date": "1623647013",
            "description": "Test realistic bloom using texture lods",
            "flags": 32,
            "hasliked": 0,
            "id": "flS3WR",
            "likes": 6,
            "name": "bloom ploar caps bright round",
            "published": 3,
            "tags": [
                "2d",
                "blur",
                "filter",
                "bloom",
                "lod"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 308
        },
        "renderpass": [
            {
                "code": "// Fork of \"bloom ploar caps\" by firebreathz. https://shadertoy.com/view/ftS3WR\n// 2021-06-14 05:01:35\n\n// Fork of \"Lod bloom\" by luluco250. https://shadertoy.com/view/MlBcRV\n// 2021-06-14 04:34:05\n\n// Final blend\n\n#define BLOOM_INTENSITY 9.9\n#define BLOOM_STEPS 9\n#define SHOW_BLOOM 0\n\nconst vec2[] offsets = vec2[](\n    vec2(0.05, 0.075),\n    vec2(0.975, 0.05),\n    vec2(0.975, 0.55),\n    vec2(0.975, 0.875),\n    vec2(0.7, 0.95),\n    vec2(0.65, 0.7),\n    vec2(0.65, 0.5),\n    vec2(0.475, 0.65),\n    vec2(0.325, 0.65)\n);\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvec4 read_bloom(sampler2D sp, vec2 uv, float lod, vec2 center) {\n    uv = scale_uv(uv, vec2(1.0 / pow(2.0, lod)), center);\n    return texture(sp, uv);\n}\n\nvec4 get_bloom(sampler2D sp, vec2 uv, int steps) {\n    vec4 col = vec4(0.0);\n    \n    for (int i = 1; i <= steps; ++i)\n        col += read_bloom(sp, uv, float(i), offsets[i - 1]);\n    \n    return col / float(steps);\n}\n\nvec3 screen(vec3 a, vec3 b, float w) {\n    return mix(a, vec3(1.0) - (vec3(1.0) - a) * (vec3(1.0) - b), w);\n}\n\nvec3 tonemap(vec3 col) {\n    return col / (vec3(1.0) + col);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    \n    #if SHOW_BLOOM == -1\n    \n    color = texture(iChannel0, uv);\n    \n    #elif SHOW_BLOOM == 2\n    \n    color = texture(iChannel1, uv);\n    \n    #else\n    \n    vec4 bloom = get_bloom(iChannel1, uv, BLOOM_STEPS);\n    \n    #if SHOW_BLOOM == 1\n    \n    color = bloom;\n    \n    #else\n    \n    color = texture(iChannel0, uv);\n    \n    if (iMouse.z > 0.0)\n    \tcolor += (bloom * BLOOM_INTENSITY) * iMouse.x / iResolution.x;\n    else\n        color += bloom * BLOOM_INTENSITY;\n    \n    color.rgb = tonemap(color.rgb);\n    color.rgb *= 1.0 - smoothstep(0.0, 2.0, distance(uv, vec2(0.5)));\n    \n    //color.rgb = screen(color.rgb, bloom.rgb, BLOOM_INTENSITY);\n    \n    #endif\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.99;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,0.08) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(1.50,1.00,1.25);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.025,0.875,f);\n    col *= smoothstep(0.875,0.625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(1.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.02)*smoothstep(1.0,0.0,length(p*8.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Split source into lods\n\nconst vec2[] offsets = vec2[](\n    vec2(0.05, 0.075),\n    vec2(0.975, 0.05),\n    vec2(0.975, 0.55),\n    vec2(0.975, 0.875),\n    vec2(0.7, 0.95),\n    vec2(0.65, 0.7),\n    vec2(0.65, 0.5),\n    vec2(0.475, 0.65),\n    vec2(0.325, 0.65)\n);\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvoid draw(inout vec4 color, sampler2D sp, vec2 uv, float lod, vec2 center) {\n    uv = scale_uv(uv, vec2(pow(2.0, lod)), center);\n    \n    if (uv.x >= -0.1 && uv.x <= 1.1 && uv.y >= -0.1 && uv.y <= 1.1)\n        color += textureLod(sp, uv, lod);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    color = vec4(0.0);\n    \n    for (int i = 1; i < 10; ++i)\n        draw(color, iChannel0, uv, float(i), offsets[i - 1]);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Horizontal blur\n\n#define BLUR_SAMPLES 9\n#define pi 3.141592\n#define pow2(x) (x * x)\n\nfloat gaussian(float x, float sigma) {\n    return (1.0 / sqrt(2.0 * pi * pow2(sigma))) * exp(-(pow2(x) / (2.0 * pow2(sigma))));\n}\n\nvec4 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec4 col = vec4(0.0);\n    float accum, weight, offset;\n    \n    for (int i = -BLUR_SAMPLES / 2; i < BLUR_SAMPLES / 2; ++i) {\n        offset = float(i);\n        weight = gaussian(offset, sqrt(float(BLUR_SAMPLES)));\n        col += texture(sp, uv + scale * offset) * weight;\n        accum += weight;\n    }\n    \n    return col / accum;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = blur(iChannel0, uv, vec2(ps.x, 0.0));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Vertical blur\n\n#define BLUR_SAMPLES 9\n#define pi 3.141592\n#define pow2(x) (x * x)\n\nfloat gaussian(float x, float sigma) {\n    return (1.0 / sqrt(2.0 * pi * pow2(sigma))) * exp(-(pow2(x) / (2.0 * pow2(sigma))));\n}\n\nvec4 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec4 col = vec4(0.0);\n    float accum, weight, offset;\n    \n    for (int i = -BLUR_SAMPLES / 2; i < BLUR_SAMPLES / 2; ++i) {\n        offset = float(i);\n        weight = gaussian(offset, sqrt(float(BLUR_SAMPLES)));\n        col += texture(sp, uv + scale * offset) * weight;\n        accum += weight;\n    }\n    \n    return col / accum;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = blur(iChannel0, uv, vec2(0.0, ps.y));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}