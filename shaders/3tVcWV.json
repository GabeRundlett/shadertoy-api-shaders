{
    "Shader": {
        "info": {
            "date": "1611833206",
            "description": "The Goursat quartic surface, raytraced with reflections. Also a somewhat improved quartic solver (Lanczos method, with cubic solver from Numerical Recipes).",
            "flags": 48,
            "hasliked": 0,
            "id": "3tVcWV",
            "likes": 15,
            "name": "Mirrored Goursat Surface",
            "published": 3,
            "tags": [
                "reflection",
                "raytrace",
                "cubic",
                "quartic",
                "lanczos",
                "goursat"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Mirror Goursat Quartic Surface\n//\n// http://mathworld.wolfram.com/GoursatsSurface.html\n// https://www.mathcurve.com/surfaces/goursat/goursat.shtml\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting parameters\n// 'c': clip at z = 0\n// 'g': show grid\n// 'r': do rotation\n// 'm': mirror surface\n// 's': no reflections\n// 'p': plain colouring\n//\n// Quartic surfaces with octahedral symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos with\n// cubic solver from Numerical Recipes, plus some Newton-Raphson polishing.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, out vec3 res) {\n  assert(c != 0.0);\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),1.0/3.0);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(B,C,D,roots);\n  // And select the largest\n  float psi = roots[0];\n  if (nroots > 1 && roots[1] > psi) psi = roots[1];\n  if (nroots > 2 && roots[2] > psi) psi = roots[2];\n  // Give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    // Just one round usually sufficient\n    psi -= evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n  }\n  return psi;\n}\n\n// The Lanczos quartic method. See \"Applied Analysis\".\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n1 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n2 = quadratic(1.0,alpha-a,beta-b,res.zw); \n  if (n1 == 0) res.xy = res.zw;\n  return n1+n2;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to produce the least\n  // wild behaviour.\n  bool flip = abs(B/A) >= abs(D/E);\n  float c1,c2,c3,c4;\n  if (!flip) {\n    c1 = B/A; c2 = C/A; c3 = D/A; c4 = E/A;\n  } else {\n    // Solve for reciprocal\n    c1 = D/E; c2 = C/E; c3 = B/E; c4 = A/E;\n  }\n  nroots = lquartic(c1,c2,c3,c4,roots);\n  if (flip) {\n    // It can be advantageous to use the coefficients in the\n    // opposite order, thus solving for the reciprocal.\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n};\n\n// Equation: pp.pp + k(p.p)^2 + k'a^2(p.p) + k''a^4 = 0\n// Derivative: 4ppp + 4k(p.p)p + 2k'a^2p\n// Expansion with p => p+tr:\n// pp => (p+tr)(p+tr) = pp + 2tpr + t^2rr\n// pp.pp => (pp + 2tpr + t^2rr).(pp + 2tpr + t^2rr)\n//  = pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr \n// p.p  => (p+tr).(p+tr) = p.p + 2tp.r + t^2r.r = p.p + 2tp.r + t^2\n// (p.p)^2 = (p.p + 2tp.r + t^2)(p.p + 2tp.r + t^2) =\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 2(2t(p.p)(p.r) + (p.p)t^2 + 2t^3(p.r))\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 4t(p.p)(p.r) + 2(p.p)t^2 + 4t^3(p.r))\n// ie.\n// pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr +\n// k(p.p^2 + t4[(p.p)(p.r)] + t^2[4(p.r)^2 + 2(p.p)] + t^3[4(p.r)] + t^4) +\n// k'a^2(p.p + 2tp.r + t^2) +\n// k''a^4\n// collecting terms:\n// t^0: pp.pp +   k(p.p)^2 +             k'a^2(p.p) + k''a^4\n// t^1: 4pp.pr + 4k(p.p)(p.r) +         2k'a^2(p.r)\n// t^2: 6pp.rr +  k[4(p.r)^2 + 2(p.p)] + k'a^2\n// t^3: 4pr.rr + 4k(p.r)\n// t^4: rr.rr +   k\n\nint goursatsurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float k2 = surface.params[2];\n  float a = surface.params[3];\n  vec3 pp = p*p;\n  vec3 pr = p*r;\n  vec3 rr = r*r;\n  float p2 = dot(p,p);\n  float a2 = a*a;\n  float a4 = a2*a2;\n#if 0\n  float pdr = dot(p,r);\n  float A = dot(rr,rr) + k;\n  float B = 4.0*dot(pr,rr) + 4.0*k*pdr;\n  float C = 6.0*dot(pp,rr) +     k*(4.0*pdr*pdr + 2.0*p2) + k1*a2;\n  float D = 4.0*dot(pp,pr) + 4.0*k*(p2*pdr)           + 2.0*k1*a2*pdr;\n  float E = dot(pp,pp)         + k*p2*p2 + k1*a2*p2 + k2*a4;\n#else\n  // Check we have adjusted p so that p.r = 0!\n  assert(eq(dot(p,r),0.0));\n  assert(eq(dot(r,r),1.0));\n  float A =     dot(rr,rr) +     k;\n  float B = 4.0*dot(pr,rr);\n  float C = 6.0*dot(pp,rr) + 2.0*k*p2    + k1*a2;\n  float D = 4.0*dot(pp,pr);\n  float E =     dot(pp,pp) +     k*p2*p2 + k1*a2*p2 + k2*a4;\n#endif\n  return quartic(A,B,C,D,E,roots);\n}\n\nvec3 goursatnormal(Surface surface, vec3 p) {\n  // 4ppp + 4k(p.p)p + 2k'a^2p\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float a = surface.params[3];\n  return 4.0*p*p*p + 4.0*k*dot(p,p)*p + 2.0*k1*a*a*p;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  return goursatsurface(surface,p0,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  return goursatnormal(surface,p);\n}\n  \nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!key(CHAR_C) || p.z > 0.0) { // clip at z == 0\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  if (!key(CHAR_G)) basecolor *= gridline(p);\n  if (key(CHAR_P)) basecolor = vec3(0.8);\n  result.p = p; result.n = n; result.color = applylighting(basecolor,p,n,r);\n  return true;\n}\n\nSurface surface;\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float att = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // If we've hit the surface some distance from origin,\n    // stop reflecting.\n    if (dot(p,p) > 1000.0) break;\n    // Solve from closest point on ray to origin.\n    // This makes p.r = 0.\n    float tmin = 0.0;\n    tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(surface,p,r,-tmin,res)) break;\n    if (key(CHAR_P) || key(CHAR_S)) return res.color;\n    color += att*res.color;\n    att *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (key(CHAR_P)) return vec3(0.5);\n  if (key(CHAR_M)) return texture(iChannel1,r).xyz;  \n  return color + att*pow(abs(r),vec3(2));\n}\n\n// Interesting parameters from:\n// https://www.mathcurve.com/surfaces.gb/goursat/goursat.shtml\nconst vec4 goursatparams[] = \n  vec4[](\n    vec4(0,-1,0,1),\n    vec4(-1,-0.25,0.25,1),\n    vec4(-1,1,1,1),\n    vec4(0,-2,2,1),\n    vec4(-0.5,-1,0.5,1),\n    vec4(-0.5,1,-1.5,1),\n    vec4(-1,4,-6,1),\n    vec4(-1,1,1,1),\n    vec4(-1,2,-2,1),\n    vec4(-0.333,-0.666,0.666,1));\n\nconst int nparams = goursatparams.length();\n\nvoid init() {\n  float ttime = 0.1*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  vec4 params;\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nparams+1;\n  if (isurface == 0) {\n    params = mix(goursatparams[int(rtime)%nparams],\n                 goursatparams[int(rtime+1.0)%nparams],\n                 ttime);\n  } else {\n    params = goursatparams[isurface-1];\n  }\n  surface = Surface(params,vec3(0));\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  init();\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = normalize(vec3(uv, 2.0));\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color/(1.0+color),vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#define assert(x)\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}