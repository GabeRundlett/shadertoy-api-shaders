{
    "Shader": {
        "info": {
            "date": "1532087798",
            "description": "square to hex skewing, with rotation, with voronoi for a seamless mouse.\n//with a very symmetrical \"wiggly j shape\"\n\n//this is an attempt to generalize some wallpapewr tilings.",
            "flags": 0,
            "hasliked": 0,
            "id": "lltcR7",
            "likes": 1,
            "name": "hex wallpaper tiling skew",
            "published": 3,
            "tags": [
                "square",
                "barycentric",
                "hex",
                "symmetry",
                "skew",
                "wallpaper",
                "wallpapergroup",
                "skewconstant"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 613
        },
        "renderpass": [
            {
                "code": "\n\n//attempt at wallpaper-tiling generalization\n//the simplest one already exists in 3 shapes, which generalizes in a skew AND a rotation.\n//and this does not even cover rectangles.\n\n//need to learn more about barycentric ,  homogeneous2d stuff.\n\n//https://www.shadertoy.com/view/Xs2fRd\n//originally a 2d simplex illustration, but mostly liked for its skew() function\n\n//MirrorTest i a bit buggy attempt to extend into more symmetry, but the mirror gets skewed badly.\n//#define MirrorTest\n\nfloat F=0.36602540378;// sqrt(3.)*.5-.5\nfloat G=0.21132486540;//(sqrt(3.)*.5-.5)/sqrt(3.)= .5-(.5/sqrt(3.))\nfloat TAU=6.28318530718;\nfloat L=10.0;\n\n#define pi acos(-1.)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n#define mad(a,b,c) ((a)*(b)+(c))\n#define ab012(a,b) mad(vec3(0,1,2),b,a)\n#define c11(a,b) clamp(a/b,-1.,1.)*b\n\n//https://www.shadertoy.com/view/Xs2fRd\nvec2 skew(vec2 p){float f=(p.x+p.y)* F;return p+vec2(f,f);}\nvec2 unskew(vec2 q){float g=(q.x+q.y)* G;return q-vec2(g,g);}\n\n\n//generalized \"rainbow\" by ollj\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for: 0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;, for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\n\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\", range [-.159 ... 159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green) blue;try; p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n //;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds, sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n //;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*iResolution.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(iTime)//;g=.1//a 3rd domain as time for demoing, whould actually be constant\n //;c=gradVis(c,u,v)//a graph plotter, not included here.\n ;return c;}\n\nvec3 rainbowN11(vec2 u){return rainbowN(u,vec2(1),vec3(1));}\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5\n ;if(u.y<1.&&u.x>-1.)return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n //i do not like double &&,but at least its not ||\n //straight is more complex than curved part above:\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;vec2 p=.5*u.y*(b+c)-c\n //;p=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(p);}//delaying the length()nicely.\n\n\nfloat TinyDith(vec2 a){;if(fract(a.x*a.y)>.5)return 1.;return 0.;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){float td=TinyDith(u)//basic dithering of 2 complemenraty, usually alternating complemenraty colors, avoids a mixing to grey.\n ;u=u-.5*iResolution.xy; \n ;vec2 U=u\n ;vec2 m=iMouse.xy-.5*iResolution.xy; \n ;mat2 r=mat2(1)\n ;if(u.x>0.)r=r2(iTime*.1)\n ;u*=r\n ;m*=r\n ;float t=cos(iTime+pi)*.5+.5\n ;o=vec4(1)\n ;u/=164.;m/=164.\n ;if(U.y<0.\n ){u=mix(u,skew(u),t)//t*skew(u)+(1.-t)*u\n  ;m=mix(m,skew(m),t)\n ;}\n ;vec2 a=u-fract(u+.5)//fract,with offset\n ;     u=u-floor(u+.5)//floor,with offset\n ;     m=m-floor(m+.5)//floor,with offset \n #ifdef MirrorTest\n ;if(td>.5){ //additional symmetry is ghosted\n  ;if(u.x<.0)u.x=-u.x//works but is not super pretty (the mirror is skewed badly)\n  //;if(u.x<u.y)u=-u//works but is not pretty (more issues)\n  //;if(u.y<.0)u.y=-u.y//works but is is dumb and doesnt fo gell with a j-shape (more issues)\n ;}\n #endif\n \n ;vec2 k=vec2(1,4)+vec2(.5,2)*cs(iTime*8.+a.x*4.-a.y*sqrt(5.))*.5+.5//wiggly j-shape proportions tile dependent\n ;vec2 K=vec2(1,4)+vec2(.5,2)*cs(iTime*8.                    )*.5+.5//wiggly j-shape proportions\n //uniting both would require to calculate the above wiggle 9times, witzhin the O(n*n) loop below, not doing that\n \n ;float phi=sqrt(5.)*.5+.5\n ;o.xyz=rainbowN11((a+a.yx)*phi)//base tile color\n ;o.xyz-=smoothstep(.1,-.1,u.x-u.y)*u2(o.xyz)\n //if(u.x>u.y)\n //;if(u.x>u.y)o.xyz=1.-o.xyz\n //optionally complementary color over diagonal\n ;float d=0.\n ;for (float i=-1.;i<2.;i++){for (float j=-1.;j<2.;j++){//3x3 taps to be continuous over borders is only needed to read mouse over tile borders.\n ;vec2 a=u-m+vec2(i,j)\n ;if(U.y<0.)a=mix(a,unskew(a),t)\n ;a=r*a\n ;d+=smoothstep(.01,-.01,jj(a*19.,K)-.3)\n ;}}\n ;o.xyz+=d//white dot\n ;if(U.y<0.)u=mix(u,unskew(u),t)\n ;u=r*u\n ;if(jj((u-r*vec2(.3,0))*19.,k)<.3)o=vec4(0,0,0,1)//black dots\n ;U=abs(U)\n ;o=smoothstep(.5,-.5,min(U.x,U.y)-1.)*(vec4(.5,.5,.5,1.)-o)+o\n  ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}