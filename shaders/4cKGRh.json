{
    "Shader": {
        "info": {
            "date": "1712402666",
            "description": "Simple raymarched möbius band with interlaced spheres, shaded with image based lighting.\n\nwith reactive lights to music",
            "flags": 32,
            "hasliked": 0,
            "id": "4cKGRh",
            "likes": 5,
            "name": "Fork Möbius bal firebreath 620",
            "published": 3,
            "tags": [
                "raymarching",
                "domainrepetition",
                "imagebasedlighting",
                "moebius"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 211
        },
        "renderpass": [
            {
                "code": "float pi = 3.141592;\n\nvec2 r(vec2 v,float y)\n{\n    return cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n \nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nfloat somestep(float t)\n{\n    return pow(t, 4.0);\n}\n\nvec3 smin(vec3 a, vec3 b)\n{\n    if (a.x < b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 smax(vec3 a, vec3 b)\n{\n\tif (a.x > b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 sinv(vec3 a)\n{\n\treturn vec3(-a.x, a.y, a.z);    \n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n//repeat around y axis n times\nvoid rp(inout vec3 p, float n) {\n\tfloat w = 2.0*pi/n;\n\tfloat a = atan(p.z, p.x);\n\tfloat r = length(p.xz);\n\ta = mod(a+pi*.5, w)+pi-pi/n;\n\tp.xz = r*vec2(cos(a),sin(a));\n}\n\nvec3 moebius(vec3 p, vec3 q)\n{\n  float a = atan(p.z,p.x);\n  vec2 p2 = vec2(length(p.xz),p.y);\n  p2.x -= q.z;\n  p2 = r(p2, a*0.5);\n  vec2 p3 = r(p2, pi/4.0);\n  vec2 tc = vec2(p3.y,a);\n  float d = abs(p2.y)-q.x;\n  d = max(d,abs(p2.x)-q.y);\n  return vec3(d, tc);\n}\n \nvec3 dualmoebius(vec3 p)\n{\n\tfloat bandSize = 1.5;\n\tfloat radius = 5.0;\n\tfloat bandThickness = 0.75;\n\treturn smax(moebius(p, vec3(bandSize, bandThickness, radius)), sinv(moebius(p, vec3(bandSize - bandThickness, bandThickness+0.1, radius))));\n}\n \nvec3 sphere(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    vec2 tc = asin(n.xz)/pi + 0.5;\n\treturn vec3(length(p) - r, tc * 2.0);\n}\n\nvec3 spheres(vec3 p)\n{\n\trp(p, 12.0);\n\tp.x += 5.0;\n\treturn sphere(p, 0.75);\t\n}\n\nvec3 f( vec3 p )\n{\n\tvec2 mouse = vec2(sin(iTime), cos(iTime));//iMouse.xy / iResolution.xy;\n\t//p.xz = r(p.xz, mouse.x);\n\tp.yz = r(p.yz, 0.1 * iTime);\n    \n    vec3 q = p;\n\tq.xz = r(q.xz, 0.5 * iTime);\n    \n\treturn smin(sphere(p, 3.0), smin(spheres(q), dualmoebius(q)));\n}\n\nvec4 getcolor(vec3 hit, vec3 ray, vec3 normal, float t, vec3 d) \n{\n    vec4 background = vec4(texture(iChannel0, ray).xyz, 0.0);\n    if( t < 26.0 )\n    {\n        // material\n        float fresnel_pow = 2.0;\n        float fresnel_bias = 0.125;\n        float color_intensity = 1.5;\n        float roughness_bias = 1.5;\n        float roughness_coverage = 0.2;\n        float shininess = 0.6;\n        \n        vec3 color_mod = (0.5+0.5*texture(iChannel1, d.yz).rgb) * color_intensity;\n                \n        // IBL\n        vec3 ibl_diffuse = textureBlured(iChannel0,normal);\n        \n        // fresnel\n        float fresnel = fresnel_bias + (1.0 - fresnel_bias) * max(1.0 - dot(normal,-ray), 0.0);\n        fresnel = pow(fresnel,fresnel_pow);\n        \n        // surface roughness\n        float rough = (1.0 - roughness_bias) + roughness_bias * length(texture(iChannel2, d.yz * 0.1).rgb);\n        rough = 1.0 - ((1.0-rough) * smoothstep(0.4, 0.6, length(ibl_diffuse)));\n        rough *= min(1.0, pow(length(color_mod), 2.0));\n        \n        vec4 foreground = vec4(((1.0 - roughness_coverage) + roughness_coverage * rough) * ibl_diffuse * color_mod, max(0.0, min(1.0, shininess * fresnel * rough)));\n        return mix(foreground, background, smoothstep(0.0, 0.005, dot(normal, ray)));\n    } \n    else \n    {   \n        return background;\n    }\n}\n\n// ao\nfloat ao(vec3 v, vec3 n) \n{\n    const int ao_iterations = 10;\n    const float ao_step = 0.2;\n    const float ao_scale = 0.75;\n    \n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n    \n\tfor (int i = 0; i < ao_iterations; i++)\n    {\n\t\tsum += (len - f(v + n * len).x) * att;\t\t\n\t\tlen += ao_step;\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn 1.0 - max(sum * ao_scale, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = vec3(0);\n    \n    vec3 q = vec3((fragCoord.xy / iResolution.xy - 0.5), 1.0); \n    q.x *= iResolution.x / iResolution.y;\n    vec3 p = vec3(0, 0.0, -10.0);\n    q = normalize(q);\n\n    p.xz = r(p.xz, 0.05*iTime);\n    q.xz = r(q.xz, 0.05*iTime);\n\n    const int reflectionCount = 3;\n    const int raymarchingSteps = 80;\n    vec3 colors[reflectionCount];\n    float factors[reflectionCount];\n    int reflections = 0;\n    for (int iter = 0; iter < reflectionCount; ++iter)\n    {\n        float t=0.;\n        vec3 d = vec3(0);\n        float steps = 0.0;\n        for (int tt=0; tt < raymarchingSteps; ++tt )\n        {\n            d = f(p+q*t);\n            t += d.x * 0.95;\n            if( !(t<=26.0)||d.x<=0.000001)\n            {\n                break;\n            }\n            steps = float(tt);\n        }\n\n        vec3 hit = p+q*t;\n\n        vec2 e = vec2(0.001, 0.00);\n        vec3 normal= vec3( f(hit + e.xyy).x - f(hit - e.xyy).x, f(hit + e.yxy).x - f(hit - e.yxy).x, f(hit + e.yyx).x - f(hit - e.yyx).x);\n        normal= normalize(normal);\n        \n        vec4 color = getcolor(hit, q, normal, t, d);\n        colors[iter] = color.rgb * (1.0 - color.w) * ao(hit, normal);\n        factors[iter] = color.w;\n        if (t >= 26.0)\n            break;\n\n        ++reflections;\n        q = reflect(q, normal);\n        p = hit + q * 0.001;   \n    }\n\n    float factor = 1.0;\n    for (int i = 0; i < reflectionCount; ++i)\n    {\n        fragColor.xyz += factor * colors[i];\n        factor *= factors[i] * 1.5;\n\n        if (i >= reflections)\n            break;        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of \"Fork Vinyl Visu firebreath 917\" by firebreathz. https://shadertoy.com/view/clKGD3\n// 2023-05-22 19:50:36\n\n#define BARS 30.\n\n#define PI 3.14159265359\n\n// rotation transform\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// circle distance\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance function of half of an ark\n// parameters: inner radius, outer radius, angle\nfloat sdArk(vec2 p, float ir, float or, float a) {\n    \n    // add outer circle\n    float d = sdCircle(p, or);\n        \n    // substract inner circle\n    d = opS(d, sdCircle(p, ir));\n    \n    // rotate with angle\n    tRotate(p, -a * PI / 4.);\n    \n    // clip the top\n    d = opS(d, -p.y);\n    \n    // add circle to the top\n    d = opU(d, sdCircle(p - vec2((or + ir) / 1., 0.), (or - ir) / 1.));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n    // I wanted it to look good on my phone vertically :P\n    if (iResolution.x > iResolution.y) uv.x *= iResolution.x / iResolution.y; else uv.y *= iResolution.y / iResolution.x;\n    \n    // little white padding\n    uv *= 1.05;\n    \n    // add circles\n    float d = sdCircle(uv, 1.);\n    d = opS(d, sdCircle(uv, .15));\n    d = opU(d, sdCircle(uv, .04));\n    \n    // calculate position of the bars\n    float barsStart = .20;\n    float barsEnd = .90;\n    float barId = floor((length(uv) -barsStart) / (barsEnd - barsStart) * BARS);\n    \n    // only go forward if we're in a bar\n    if (barId >= 0. && barId < BARS) {\n        \n        float barWidth = (barsEnd - barsStart) / BARS;\n        float barStart = barsStart + barWidth * (barId + .06);\n        float barAngel = texture(iChannel0, vec2(0.6 - barId / BARS, .01)).x * .9;\n\n        // add a little rotation to completely ruin the beautiful symmetry\n        tRotate(uv, -barAngel * .9 * sin(barId + iTime));\n        \n        // mirror everything\n    \tuv = abs(uv);\n        \n        // add the bars\n        d = opS(d, sdArk(uv, barStart, barStart + barWidth / 2., barAngel));\n    }\n    \n    // use the slope to render the distance with antialiasing\n    float w = min(fwidth(d), .01);\n\tfragColor = vec4(vec3(smoothstep(-w, w, d)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define WAVES 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 3.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}