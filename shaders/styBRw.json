{
    "Shader": {
        "info": {
            "date": "1664225566",
            "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "styBRw",
            "likes": 3,
            "name": "1efficient poisson distribution",
            "published": 3,
            "tags": [
                "glsl",
                "bug"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 207
        },
        "renderpass": [
            {
                "code": "// DEBUG sub-part1 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n\n// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y > 0. ) \n        if ( U.x < 0. )                               // --- top left: brute force draw Npix*d Uniform points \n            for( float k=Z; k < d; k++ )              // at 640x360 , d=1% : 2304 dots\n                D(k,1.);\n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}