{
    "Shader": {
        "info": {
            "date": "1686057041",
            "description": "based on \"An introduction to Shader Art Coding\" by kishimisu: \nhttps://www.youtube.com/watch?v=f4s1h2YETNY",
            "flags": 0,
            "hasliked": 0,
            "id": "cltSDS",
            "likes": 7,
            "name": "Neon Hexagons",
            "published": 3,
            "tags": [
                "hexagons",
                "neon"
            ],
            "usePreview": 0,
            "username": "osnajanos",
            "viewed": 387
        },
        "renderpass": [
            {
                "code": "// based on \"An introduction to Shader Art Coding\" by kishimisu: \n// https://www.youtube.com/watch?v=f4s1h2YETNY\n\n\n\n// ==========================================================================================\n// Utility & math\n\n// Normalize pixel coordinates (XY to UV).\nvec2 get_uv(in vec2 position)\n{\n    return (position * 2.0 - iResolution.xy) / iResolution.y;\n}\n// Map value from [min1, max1] to [min2, max2]\nfloat map(in float value, in float min1, in float max1, in float min2, in float max2) \n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n// Map value in [min, max] to [0,1]\nfloat map_01(in float value, in float min, in float max)\n{\n    return map(value, min, max, 0.0, 1.0);\n}\n// Map triginometric function value to [min, max]\nfloat map_tri(in float value, in float min, in float max)\n{\n    return map(value, -1.0, 1.0, min, max);\n}\n// Map triginometric function value to [0, 1]\nfloat map_tri_01(in float value)\n{\n    return map_tri(value, 0.0, 1.0);\n}\n// SDF for a hexagon with position p and radius r, from https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon(in vec2 p, in float r)\n{\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n// Returns the current position between two beats as a float between 0 and 1 with smoothing.\nfloat beat(in float bpm)\n{\n    return smoothstep(0.5, 1.0, sqrt(1.0 - mod(iTime, 60.0 / bpm)));\n}\n// Sample a BPM synced oscillator.\nfloat beat_osc(in float bpm, in float min, in float max, in float speed, in float offset)\n{\n    const float two_pi = 2.0 * 3.14159265;\n    return map_tri(cos(offset * two_pi + speed * iTime * bpm / 60.0 * two_pi), min, max);\n}\n\n// ==========================================================================================\n// Color palettes, see https://iquilezles.org/articles/palettes/\n\n// Sample a color gradient with parameters (a, b, c, d) at position t.\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n// Sample a neon palette at position t.\nvec3 palette_neon(in float t)\n{\n    return palette(t, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.263, 0.416, 0.557));\n}\n// Sample a spectrum palette at position t.\nvec3 palette_spectrum(in float t)\n{\n    return palette(t, vec3(0.5), vec3(0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.2, 0.25));\n}\n// Sample from multiple palettes at position t and add colors with mix ratio p.\nvec3 mix_palettes(in float t, in float p)\n{\n    float p1 = p;\n    float p2 = 1.0 - p;\n    return p1 * palette_neon(t) + p2 * palette_spectrum(t);\n}\n\n// ==========================================================================================\n// Main\n\n// Creates a fractal hexagon pattern that sweeps through color gradients.\n// Basically kishimisus algorithm (see video) with many control parameters.\nvec3 hexagons(\n    in vec2 position,\n    in float scale,\n    in float density,\n    in float lineWidth,\n    in float iterations,\n    in float offset,\n    in float colorMix\n)\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = get_uv(position);\n    vec2 uv0 = uv;\n    for (float i = 0.0; i < iterations; i++) {\n        uv = fract(uv * scale) - 0.5;\n        float d0 = sdHexagon(uv0, 1.0);\n        float d = sdHexagon(uv, 1.0);\n        d = sin(d * density + offset) / density;\n        d = abs(d);\n        d = (0.0025 * lineWidth) / d;\n        d = smoothstep(0.0, 0.3, d);\n\n        vec3 c = mix_palettes(d0 + offset, colorMix);\n        color += c * d;\n    }\n    return color;\n}\n\n// Create interesting layers of the hexagon pattern synced to a given BPM.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float bpm = 174. / 2. ;\n    vec3 color = vec3(0.0);\n    vec3 layerBackground = hexagons(\n        fragCoord,\n        beat_osc(bpm, 2.95, 3.05, 1.0 / 16.0, 0.0),\n        beat_osc(bpm, 12.0, 15.0, 1.0 / 16.0, 0.1),\n        3.0,\n        2.0,\n        -iTime * 0.125,\n        beat_osc(bpm, 0.5, 1.0, 1.0 / 8.0, 0.0)\n    );\n    vec3 layerBackgroundMask = hexagons(\n        fragCoord,\n        beat_osc(bpm, 1.0, 2.0, 0.0, 0.0),\n        5.0,\n        4.0,\n        1.25,\n        -iTime * 0.25,\n        beat_osc(bpm, 0.0, 1.0, 0.5, 0.0)\n    );\n    vec3 layerMid = hexagons(\n        fragCoord,\n        1.5,\n        beat_osc(bpm, 17.5, 18.0, 0.25, 0.0),\n        0.5,\n        1.0,\n        -iTime * 0.5,\n        beat_osc(bpm, 0.0, 1.0, 0.125, 0.0)\n    );\n    vec3 LayerForeground = hexagons(\n        fragCoord,\n        beat_osc(bpm, 0.6, 0.7, 1.0 / 32.0, 0.0),\n        beat_osc(bpm, 12.0, 16.0, 1.0 / 64., 0.0),\n        2.0,\n        2.0,\n        -iTime * 0.25,\n        beat_osc(bpm, 0.0, 1.0, 1.0 / 32., 0.0)\n    );\n    color += layerBackground * layerBackgroundMask;\n    color += layerMid * beat(bpm) * 0.5;\n    color += LayerForeground * beat(bpm);\n\n    fragColor.xyz = color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}