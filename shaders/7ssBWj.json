{
    "Shader": {
        "info": {
            "date": "1645872744",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "7ssBWj",
            "likes": 2,
            "name": "spqr: blackle gated vol light",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 270
        },
        "renderpass": [
            {
                "code": "\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat sph (vec3 p, float r) {\n  return length(p) -r;\n}\nfloat cyl (vec2 p,float r) {\n  return length(p) - r;\n}\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nfloat box(vec3 p, float s ) {\n    p = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n\n}\n\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n\nfloat map (vec3 p) {\n//geo\n    float domain = 1.;\n\n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n    if (  rando *.65< thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        float u = box(p, vec3(.4));\n      \n        return u;\n        \n    } else {\n        //return length(p)-1.;\n        float u = box(p, vec3(.4));\n       \n        return u;\n    }\n   \n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\n\nfloat intersect(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad = 0.;\n      break;\n   \n    } \n   \n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\nvec3 vollight ( vec3 lightpos, vec3 s, vec3 r, vec2 uv, float limit) {\n\n  float rand=rnd(uv);\n  \n  \n  const int volsteps=200; //50\n  float voldist = 25.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand ;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>limit) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = intersect(lp, lv, ldistvol, 10, 0.01);\n    atcol += .1/(0.01+(pow(ldistvol,1.))) * shadvol;\n   \n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n  return atcol;\n}\n\nvec3 tune ( float t) {\n  vec3 p = vec3(0);\n  \n  float n = 1.;\n  \n  for ( float i=0.; i < 5.; i++) {\n      p.x += sin(t * n)/n;\n      p.y += sin((t + 11.)* n)/n;\n      \n      n *= 1.4;\n   \n     \n  }\n \n  return p;\n  \n}\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  float tt = iTime * 1.;\n  vec3 jump = vec3(1) * tick(iTime*.1)*14.;\n \n  vec3 s = vec3(10.,3.2,7.1)*iTime*.08 + jump;\n  \n  vec3 arm = vec3(17,0,0);\n  arm.xz *= rot(sin(iTime* .19));\n  arm.yz *= rot(sin(iTime*.23));\n  arm.yx *= rot(sin(iTime*.28));\n    \n  vec3 t = s + arm;\n\n\n  vec3 tensor = vec3(6);\n  \n  tensor *= sin(tt);\n  \n  \n  tensor.xz *= rot(tt);\n  tensor.yz *= rot(tt * .83);\n  tensor.xy *= rot(tt * .71);\n  \n  \n  tensor += t;\n  \n  \n  vec3 probe = tensor;\n\n  \n \n  \n  \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,-1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n\n \n\n  \n  // march\n  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 1000.0;\n  float z;\n  bool hit = false;\n  for( z=0.; z<1000.; ++z) {\n  \n    float d=map(p);\n    if(d<0.01) { hit = true; break;}\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n    \n  }\n  \n  vec3 hue = vec3(.1,.1,.2);\n  \n  vec3 col = hue;\n  //float ao = pow(1. - z/500.,1.);\n  //col *= ao;\n \n  \n  vec3 light = normalize(vec3(1));\n  vec3 n = norm(p);\n\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.) * 10.;\n  col += spec * .1;\n  float diff = max(0., dot(n,light)*.5 +.5);\n  col *= diff;\n  \n  \n  vec3 n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n  vec3 n1 = norm(p, vec2(0.0, 2.03E-2) );\n  #define saturate(a) (clamp((a),0.,1.))\n float edge = saturate(length(n1-n2)/0.1);\n  if ( edge > 0.01) {\n      col = vec3(0);\n  }\n  \n  \n    \n  if (! hit){\n      col = vec3(0);\n   \n  }\n\n\n  vec3 vcol = vollight(probe, s , r, uv, dd);\n  col += vcol*.53;\n\n\n\n  \n  fragColor = vec4(col, 1);\n}\n/*\n   p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n\n*/\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}