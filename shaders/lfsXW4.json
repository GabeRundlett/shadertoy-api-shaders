{
    "Shader": {
        "info": {
            "date": "1705341751",
            "description": "Yeah this turned out pretty terrible, expensive too, I could probably do some optimizations but I will let someone else\nMaybe later I will turn this into a simple room and swap the ray-marching for purely ray-tracing, then we could crank the samples up",
            "flags": 40,
            "hasliked": 0,
            "id": "lfsXW4",
            "likes": 2,
            "name": "Path-Traced Sound",
            "published": 3,
            "tags": [
                "light",
                "globalillumination",
                "nee",
                "transport"
            ],
            "usePreview": 1,
            "username": "Zi7ar21",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n\n    fragColor.rgb *= 1.0;\n\n    fragColor.rgb = tanh(fragColor.rgb);\n\n    fragColor.rgb = pow(max(fragColor.rgb,0.),vec3(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// PI\n#define     PI 3.1415926535897932384626433832795028841971693993751058209749445923\n#define INV_PI 0.3183098861837906715377675267450287240689192914809128974953346881\n\n// 2 * PI\n#define     TAU 6.2831853071795864769252867665590057683943387987502116419498891846\n#define INV_TAU 0.1591549430918953357688837633725143620344596457404564487476673441\n\n#define     UNIT_SPHERE_SURFACE_AREA 12.5663706143591729538505735331180115367886775975004232838997783692\n#define INV_UNIT_SPHERE_SURFACE_AREA  0.0795774715459476678844418816862571810172298228702282243738336720\n\n// https://github.com/loicvdb/VDB-frags/blob/main/Include/Color-Management.frag\nconst mat3 linear2acescg = mat3( 0.613117812906440, 0.069934082307513, 0.020462992637737, 0.341181995855625, 0.918103037508582, 0.106768663382511, 0.045787344282337, 0.011932775530201, 0.872715910619442);\nconst mat3 acescg2linear = mat3( 1.704887331049501,-0.129520935348888,-0.024127059936902,-0.624157274479026, 1.138399326040076,-0.124620612286390,-0.080886773895704,-0.008779241755018, 1.148822109913262);\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v) {\n    v = 0x0019660Du * v + 0x3C6EF35Fu;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    return v;\n}\n\nfloat urand1(inout uvec4 v) {\n    v = pcg4d(v);\n    return float(v.x) / float(~0u);\n}\n\nvec2 urand2(inout uvec4 v) {\n    v = pcg4d(v);\n    return vec2(v.xy) / float(~0u);\n}\n\nvec3 urand3(inout uvec4 v) {\n    v = pcg4d(v);\n    return vec3(v.xyz) / float(~0u);\n}\n\nvec4 urand4(inout uvec4 v) {\n    v = pcg4d(v);\n    return vec4(v) / float(~0u);\n}\n\n//inverse error function\nfloat ErfInv(float x) {\n   float lnx = log((1.0 - x)*(1.0 + x));\n   float tt1 = 4.3308 + 0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1 + sqrt(tt1*tt1 - tt2)));\n}\n\nfloat nrand(inout uvec4 ns)\n{\n    return ErfInv(urand1(ns)*2.0 - 1.0);\n}\n\nvec2 nrand2(float sigma, vec2 mean, inout uvec4 ns) {\n    vec2 Z = urand2(ns);\n    return mean + sigma * sqrt(-2.0*log(Z.x   )) * vec2(cos(TAU * Z.y), sin(TAU * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean, inout uvec4 ns) {\n    vec4 Z = urand4(ns);\n    return mean + sigma * sqrt(-2.0*log(Z.xxy )) * vec3(cos(TAU * Z.z), sin(TAU * Z.z),cos(TAU * Z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean, inout uvec4 ns) {\n    vec4 Z = urand4(ns);\n    return mean + sigma * sqrt(-2.0*log(Z.xxyy)) * vec4(cos(TAU * Z.z), sin(TAU * Z.z),cos(TAU * Z.w),sin(TAU * Z.w));\n}\n\nvec3 udir3(inout uvec4 ns) {\n    vec2 rng = urand2(ns);\n    vec2 r = vec2(TAU*rng.x, acos(2.0*rng.y-1.0));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//\n// psrdnoise2.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned and slightly stretched in\n// the y direction to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer period\n// in x and any even integer period in y. Odd periods may be specified\n// for y, but then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along z in 3-D\n// noise. The rotating gradients in conjunction with the analytic\n// derivatives allow for \"flow noise\" effects as presented by Ken\n// Perlin and Fabrice Neyret.\n//\n\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// \"vec2 x\" is the point (x,y) to evaluate,\n// \"vec2 period\" is the desired periods along x and y, and\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\n// The \"float\" return value is the noise value, and\n// the \"out vec2 gradient\" argument returns the x,y partial derivatives.\n//\n// Setting either period to 0.0 or a negative value will skip the wrapping\n// along that dimension. Setting both periods to 0.0 makes the function\n// execute about 15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function\n// by 10-15%.\n//\n// The rotation by alpha uses one single addition. Unlike the 3-D version\n// of psrdnoise(), setting alpha == 0.0 gives no speedup.\n//\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\n\t// Transform to simplex space (axis-aligned hexagonal grid)\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t// Determine which simplex we're in, with i0 being the \"base\"\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t// o1 is the offset in simplex space to the second corner\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t// Enumerate the remaining simplex corners\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t// Transform corners back to texture space\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t// Compute vectors from v to each of the simplex corners\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\n\t// Wrap to periods, if desired\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t// Transform back to simplex space and fix rounding errors\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { // Shortcut if neither x nor y periods are specified\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t// Compute one pseudo-random hash value for each corner\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t// Pick a pseudo-random angle and add the desired rotation\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t// Reorganize for dot products below\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t// Radial decay with distance from each simplex corner\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t// The value of the linear ramp from each of the corners\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t// Multiply by the radial decay and sum up the noise value\n\tfloat n = dot(w4, gdotx);\n\n\t// Compute the first order partial derivatives\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t// Scale the return value to fit nicely into the range [-1,1]\n\treturn 10.9 * n;\n}\n\n/* */\nconst float BPM = 120.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\nconst float TUNING = 440.0;\nconst int MIDIOFFSET = 69;\n\n//const float TAU = 6.28318530;\n\nconst int REVERB_SAMPLES = 512;\nconst float WETNESS = 0.5;\n\n// MIDI note to frequency formula\nfloat noteFreq(int note) {\n\treturn TUNING * exp2(float(note - MIDIOFFSET) / 12.0);\n}\n\n// From https://www.shadertoy.com/view/clXSR7\nfloat waveSaw(float freq, float time) {\n    return fract(freq * time + 0.5) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Impulse for convolution, this will be sampled NUM_SAMPLES times\nvec2 impulse(float time) {\n    time *= iSampleRate;\n    return hash22(vec2(time * 452.3, time * 274.6)) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash11(float(si)), hash11(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float bandwidth) {\n    return sin(TAU * freq * fract(time)) * noise(time * bandwidth);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\n// Sliding pitch sine wave, used for bass drop and kick\nfloat drop(float time, float df, float dftime, float freq) {\n    return sin(TAU * (freq * time - df * dftime * exp(-time / dftime)));\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    float body = drop(time, 512.0, 0.01, 60.0) * smoothstep(0.3, 0.0, time);\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body * 2.0 + click * 1.5;\n}\n\nvec2 hats(float time) {\n    float falloff = (cos(time * TAU * 0.25 / SPB) + 2.5) * 8.0;\n    vec2 noise = hash22(vec2(time * iSampleRate, time * iSampleRate * 123.4)) * 2.0 - 1.0;\n    float volume = exp(-falloff * mod(time, SPB / 3.0));\n    return noise * volume;\n}\n\n// No optimization here, not feeling like it today\nfloat leadSynth(float time) {\n    const int notes[] = int[](\n        64,54,57,\n        64,54,57,\n        64,54,57,\n        62,52,57,\n        61,54,57,\n        61,54,57,\n        61,54,57,\n        59,57,52\n    );\n    float beatTime = 1.5 * time / SPB;\n    int note = notes[int(abs(beatTime)) % notes.length()];\n    float volume = step(fract(beatTime), 0.5 + sin(time * TAU * 0.125 / SPB) * 0.05);\n    return waveSaw(noteFreq(note), time) * volume;\n}\n\nfloat leadBass(float time) {\n    const int notes[] = int[](\n        38,38,38,\n        38,38,50,\n        38,38,38,\n        40,40,52,\n        42,42,42,\n        42,54,42,\n        42,42,54,\n        37,49,40\n    );\n    float beatTime = 1.5 * time / SPB;\n    int bass = notes[int(abs(beatTime)) % notes.length()];\n    float volume = step(fract(beatTime - 0.5), 0.4 + cos(time * TAU * 0.125 / SPB) * 0.1);\n    return waveSaw(noteFreq(bass), time) * volume;\n}\n\nstruct Song {\n    vec2 leads;\n    vec2 drums;\n    vec2 bass;\n    vec2 reverb;\n    float sidechain;\n};\n\nSong getSong(float time, int reverb) {\n    Song song;\n    song.reverb = vec2(0.0);\n    /*\n    for (int i = 0; i < reverb; i++) {\n        float timeOffset = float(i) / iSampleRate;\n        \n        // Butcher the settings every 2nd time for variety\n        bool variety = mod(time - timeOffset, SPB * 64.0) > SPB * 32.0;\n        float offsetScale = variety ? 0.5 : 1.2;\n        float timeScale = variety ? 2.0 : 1.0;\n        \n        // Convolution reverb doesn't have a random time offset, but it sounds better with it\n        timeOffset += hash11(timeOffset * 126.7) * offsetScale;\n        \n        song.reverb += leadSynth(time * timeScale - timeOffset) * impulse(timeOffset);\n    }\n    */\n    song.reverb *= 0.105;\n    \n    song.leads = vec2(leadSynth(time));\n    song.bass = vec2(leadBass(time) * 1.3);\n    song.drums = hats(time) * 0.7 + kick(mod(time, SPB)) * 0.8;\n    song.sidechain = 0.3 + min(1.0, mod(time, SPB) * 6.0) * 0.7;\n    \n    return song;\n}\n/* */\n\n#define MAX_DEPTH 3\n\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc,rd);\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot(qc,qc);\n    if(h < 0.0) return vec2(-1.0); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h);\n}\n\n/* */\n// https://iquilezles.org/articles/mandelbulb\nfloat mandelbulb( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n\n\tfor(int i = 0; i < 1; i++)\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\n\t\tif(m > 64.0 || dot(p,p) > 4.6) break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    float d = 0.25*log(m)*sqrt(m)/dz;\n    return (isnan(d)||isinf(d)||(d!=d)) ? 1.0 : d;\n}\n/* */\n\nfloat map(vec3 pos) {\n    vec4 trap;\n    //return min(length(pos) - 1.0, pos.y + 1.0);\n    return min(mandelbulb(pos,trap), pos.y + 1.0);\n}\n\nvec3 calcNorm(vec3 x) {\n    const float k = 0.00001;\n\n    return normalize(vec3(\n    map(x+k*vec3(1,0,0))-map(x-k*vec3(1,0,0)),\n    map(x+k*vec3(0,1,0))-map(x-k*vec3(0,1,0)),\n    map(x+k*vec3(0,0,1))-map(x-k*vec3(0,0,1))));;\n\n    /*\n    vec3 normal = normalize(vec3(\n    map(x+k*vec3(1,0,0))-map(x-k*vec3(1,0,0)),\n    map(x+k*vec3(0,1,0))-map(x-k*vec3(0,1,0)),\n    map(x+k*vec3(0,0,1))-map(x-k*vec3(0,0,1))));\n\n    return (any(isnan(normal))||any(isinf(normal))||(!any(equal(normal,normal)))) ? vec3(0.0, 1.0, 0.0) : normal;\n    */\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n\n    for(int i = 0; i < 256; i++) {\n        vec3 pos = ro + t * rd;\n\n        if(pos.x*pos.x > 9.0 || pos.y*pos.y > 1.0 || pos.z*pos.z > 9.0) {\n            t = 0.9e9;\n\n            break;\n        }\n\n        float dist = map(pos);\n\n        t += dist;\n\n        if(dist < 0.01) break;\n    }\n\n    return vec2(t > 100.0 ? -1.0 : t, 1e9);\n}\n\nfloat pdf(vec3 normal, vec3 direction) {\n    // multiply by tau = multiply by 2 and divide by unit sphere surface area\n    return INV_TAU * max(dot(normal, direction), 0.001);\n}\n\nvec3 cosineWeightedHemisphere(vec3 n, inout uvec4 ns) {\n    vec2 r = urand2(ns);\n    vec3  uu = normalize(cross(n, abs(n.y) > 0.5 ? vec3(1,0,0) : vec3(0,1,0)));\n    vec3  vv = cross(uu, n);\n    float ra = sqrt(r.y);\n    float rx = ra*cos(TAU*r.x); \n    float ry = ra*sin(TAU*r.x);\n    float rz = sqrt(1.0-r.y);\n    vec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 brdf(vec3 albedo, vec3 normal, vec3 inDirection, vec3 outDirection) {\n    return INV_TAU * albedo;\n}\n\nvec3 pointNEE(vec3 ro, vec3 normal, vec3 lightPos, vec3 lightCol) {\n    vec3 neesampDir = lightPos - ro;\n\n    float r2 = dot(neesampDir,neesampDir);\n    float r1 = sqrt(r2);\n    neesampDir /= r1;\n\n    float neegeometricFactor = max(dot(normal, neesampDir), 0.0);\n\n    vec2 neeray = rayMarch(ro, neesampDir);\n\n    return ((neeray.x < 0.0) || (neeray.x > r1  && neeray.x > 0.0)) ? ((lightCol*neegeometricFactor)/r2) : vec3(0);\n}\n\nvec3 pathTrace(in vec3 ro, in vec3 rd, inout uvec4 ns) {\n    vec3 rayPos = ro;\n    vec3 rayDir = rd;\n\n    vec3 att = vec3(1);\n    vec3 rad = vec3(0);\n\n    for(int depth = 0; depth < MAX_DEPTH; depth++) {\n        //vec2 t = sphIntersect(rayPos, rayDir, vec3(0.0, 0.0, 0.0), 1.0);\n        vec2 t = rayMarch(rayPos, rayDir);\n\n        if(t.x < 0.0 || t.y < t.x) {\n            //rad += att * pow(linear2acescg*texture(iChannel0, rayDir).rgb,vec3(2.2));\n            //rad += att * pow(linear2acescg*(depth>0?texture(iChannel0, rayDir).rgb:vec3(0.4,0.4,0.4)),vec3(2.2));\n            //rad += att * (linear2acescg*vec3(1))*(dot(rayDir,normalize(vec3(1,0,-1))) > sqrt(0.5) ? 1.0 : 0.0);\n            //rad += att;\n            //rad += linear2acescg*vec3(0.200);\n            return rad;\n        }\n\n        rayPos += t.x*rayDir;\n\n        //vec3 normal = normalize(rayPos);\n        vec3 normal = calcNorm(rayPos);\n\n        //vec3 albedo = vec3(0.800, 0.800, 0.800);\n        float checker = floor(2.0*fract(rayPos.x))+floor(2.0*fract(rayPos.z)) != 1.0 ? 0.8 : 0.2;\n        vec3 albedo = linear2acescg*((rayPos.y > -0.99) ? (rayPos.x > 0.0 ? vec3(1.0,0.5,0.0) : vec3(0.0,0.5,1.0)) : vec3(1.0)*checker);\n        //if(rayPos.x*rayPos.x < 0.1*0.1) rad += 1.0 * att * linear2acescg*vec3(0.5, 1.0, 1.0);\n        //albedo = vec3(1.0);\n\n        rayPos += 0.01*normal;\n\n        vec3 sampDir = cosineWeightedHemisphere(normal, ns);\n\n        float geometricFactor = max(dot(normal, sampDir), 0.0);\n\n        //att *= geometricFactor * brdf(albedo, normal, rayDir, sampDir) / pdf(normal, sampDir);\n        att *= albedo;\n\n        vec3 lightPos;\n        lightPos = vec3( 1.5, -0.9,  1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n        lightPos = vec3(-1.5, -0.9,  1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n        lightPos = vec3( 1.5, -0.9, -1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n        lightPos = vec3(-1.5, -0.9, -1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n\n        rayDir = sampDir;\n        //rayDir = udir3(ns);\n    }\n\n    return vec3(0.000, 0.000, 0.000);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    uvec4 ns = uvec4(fragCoord, iFrame, 42069);\n\n    //vec2 uv = ((fragCoord)-(0.5*iResolution.xy))/(0.5*iResolution.y);\n    //vec2 uv = ((fragCoord+(urand2(ns)-0.5))-(0.5*iResolution.xy))/(0.5*iResolution.y);\n    vec2 uv = (nrand2(0.5, fragCoord, ns)-(0.5*iResolution.xy))/(0.5*iResolution.y);\n\n    //uv *= 0.5;\n    float th = PI*0.0;\n    float c = cos(th), s = sin(th);\n    mat2 rm = mat2(c,s,-s,c);\n    uv = rm*uv;\n\n    vec3 ro = vec3(sin(iTime), 0.0,  2.0);\n    vec3 rd = vec3(uv.x, uv.y, -1.0);\n\n    rd = normalize(rd);\n    rd.x *= 1.0;\n\n    th = PI*0.0;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    rd = vec3(rm*rd.xz,rd.y).xzy;\n    th = -PI*0.0;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    rd = vec3(rm*rd.yz,rd.x).zxy;\n\n    fragColor.rgb = pathTrace(ro, rd, ns);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame != 0 ? texelFetch(iChannel1, ivec2(fragCoord), 0) : vec4(0);\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n\n    fragColor.rgb = acescg2linear*fragColor.rgb;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SPEED_OF_SOUND 300.0\n\nvec3 lightPosS = vec3(0.0, -0.5, 1.5);\n#define ONLY_REFLECTIONS\n#define NUM_SAMPLES 16\n#define REFLECTIVENESS 0.9\n\nvec2 audio(float time) {\n    Song song = getSong(time, REVERB_SAMPLES);\n\n    vec2 dry = (song.leads + song.bass) * song.sidechain + song.drums;\n\n    return dry;\n}\n\n/*\nvec3 pointNEE(vec3 ro, vec3 normal, vec3 lightPos, vec3 lightCol) {\n    vec3 neesampDir = lightPos - ro;\n\n    float r2 = dot(neesampDir,neesampDir);\n    float r1 = sqrt(r2);\n    neesampDir /= r1;\n\n    float neegeometricFactor = max(dot(normal, neesampDir), 0.0);\n\n    vec2 neeray = rayMarch(ro, neesampDir);\n\n    return ((neeray.x < 0.0) || (neeray.x > r1  && neeray.x > 0.0)) ? ((lightCol*neegeometricFactor)/r2) : vec3(0);\n}\n*/\n\nvec3 soundNEE(vec3 ro, vec3 normal, vec3 lightPos, vec3 lightCol, float time, float ph) {\n    vec3 neesampDir = lightPos - ro;\n\n    float r2 = dot(neesampDir,neesampDir);\n    float r1 = sqrt(r2);\n    neesampDir /= r1;\n\n    float neegeometricFactor = max(dot(normal, neesampDir), 0.0);\n\n    vec2 neeray = rayMarch(ro, neesampDir);\n\n    lightCol = vec3(audio(time + ((ph+neeray.x)/SPEED_OF_SOUND)), 0.);\n\n    return ((neeray.x < 0.0) || (neeray.x > r1  && neeray.x > 0.0)) ? ((lightCol*neegeometricFactor)/r2) : vec3(0);\n}\n\nvec2 soundTrace(in vec3 ro, in vec3 rd, float time, inout uvec4 ns) {\n    vec3 rayPos = ro;\n    vec3 rayDir = rd;\n\n    float ph = 0.0;\n    vec2 att = vec2(1);\n    vec2 rad = vec2(0);\n\n    for(int depth = min(int(time),0); depth < 16; depth++) {\n        //vec2 t = sphIntersect(rayPos, rayDir, vec3(0.0, 0.0, 0.0), 1.0);\n        vec2 t = rayMarch(rayPos, rayDir);\n\n        if(t.x < 0.0 || t.y < t.x) {\n            //rad += att * pow(linear2acescg*texture(iChannel0, rayDir).rgb,vec3(2.2));\n            //rad += att * pow(linear2acescg*(depth>0?texture(iChannel0, rayDir).rgb:vec3(0.4,0.4,0.4)),vec3(2.2));\n            //rad += att * (linear2acescg*vec3(1))*(dot(rayDir,normalize(vec3(1,0,-1))) > sqrt(0.5) ? 1.0 : 0.0);\n            //rad += att;\n            //rad += linear2acescg*vec3(0.200);\n            return rad;\n        }\n\n        ph += t.x;\n\n        rayPos += t.x*rayDir;\n\n        //vec3 normal = normalize(rayPos);\n        vec3 normal = calcNorm(rayPos);\n\n        //vec3 albedo = vec3(0.800, 0.800, 0.800);\n        //float checker = floor(2.0*fract(rayPos.x))+floor(2.0*fract(rayPos.z)) != 1.0 ? 0.8 : 0.2;\n        //vec3 albedo = linear2acescg*((rayPos.y > -0.998) ? (rayPos.x > 0.0 ? vec3(1.0,0.5,0.0) : vec3(0.0,0.5,1.0)) : vec3(1.0)*checker);\n        //if(rayPos.x*rayPos.x < 0.1*0.1) rad += 1.0 * att * linear2acescg*vec3(0.5, 1.0, 1.0);\n        //albedo = vec3(1.0);\n\n        rayPos += 0.01*normal;\n\n        vec3 sampDir = cosineWeightedHemisphere(normal, ns);\n\n        float geometricFactor = max(dot(normal, sampDir), 0.0);\n\n        //att *= geometricFactor * brdf(albedo, normal, rayDir, sampDir) / pdf(normal, sampDir);\n        //att *= albedo;\n        att *= REFLECTIVENESS;\n\n        vec3 lightPos;\n        lightPos = lightPosS;\n        rad += att * soundNEE(rayPos, normal, lightPos, vec3(1), time, ph).xy;\n        rayDir = sampDir;\n        //rayDir = udir3(ns);\n    }\n\n    //return vec2(0.000, 0.000);\n    return rad;\n}\n\nfloat traceSoundL(float time, inout uvec4 ns) {\n\n    float th = PI*0.2;\n    float c = cos(th), s = sin(th);\n    mat2 rm = mat2(c,s,-s,c);\n    //uv = rm*uv;\n\n    vec3 ro = vec3(sin(time)-0.1, 1.0,  2.0);\n    //vec3 rd = vec3(uv.x, uv.y, -1.0);\n\n    //rd = normalize(rd);\n\n    th = PI*0.25;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    //rd = vec3(rm*rd.xz,rd.y).xzy;\n    th = -PI*0.25;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    //rd = vec3(rm*rd.xy,rd.z).xyz;\n\n    vec2 sound = vec2(0);\n\n    const int num_samp = NUM_SAMPLES;\n\n    for(int i = 0; i < num_samp; i++) {\n        vec3 rd = udir3(ns);\n        rd = normalize(nrand3(1.0, vec3(-0.5,0.0,-0.5), ns));\n        sound += soundTrace(ro, rd, time+(nrand(ns)/float(iSampleRate)), ns);\n    }\n    \n    sound /= float(num_samp);\n    #ifndef ONLY_REFLECTIONS\n    vec3 lightPos = lightPosS;\n    vec3 lightCol;\n    float ph = 0.0;\n\n    vec3 neesampDir = lightPos - ro;\n\n    float r2 = dot(neesampDir,neesampDir);\n    float r1 = sqrt(r2);\n    neesampDir /= r1;\n\n    vec2 neeray = rayMarch(ro, neesampDir);\n\n    lightCol = vec3(audio(time+(nrand(ns)/float(iSampleRate)) + ((ph+neeray.x)/SPEED_OF_SOUND)), 0.);\n\n    sound += 0.1*(((neeray.x < 0.0) || (neeray.x > r1  && neeray.x > 0.0)) ? ((lightCol)/r2) : vec3(0)).xy;\n        #endif\n     return sound.x;\n}\n\nfloat traceSoundR(float time, inout uvec4 ns) {\n\n    float th = PI*0.2;\n    float c = cos(th), s = sin(th);\n    mat2 rm = mat2(c,s,-s,c);\n    //uv = rm*uv;\n\n    vec3 ro = vec3(sin(time)+0.1, 0.0,  2.0);\n    //vec3 rd = vec3(uv.x, uv.y, -1.0);\n\n    //rd = normalize(rd);\n\n    th = PI*0.25;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    //rd = vec3(rm*rd.xz,rd.y).xzy;\n    th = -PI*0.25;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    //rd = vec3(rm*rd.xy,rd.z).xyz;\n\n    vec2 sound = vec2(0);\n\n    const int num_samp = NUM_SAMPLES;\n\n    for(int i = 0; i < num_samp; i++) {\n        vec3 rd = udir3(ns);\n        //rd.x = abs(rd.x);\n        rd = normalize(nrand3(1.0, vec3(0.5,0.0,-0.5), ns));\n        sound += soundTrace(ro, rd, time+(nrand(ns)/float(iSampleRate)), ns);\n    }\n    \n    sound /= float(num_samp);\n    #ifndef ONLY_REFLECTIONS\n    vec3 lightPos = lightPosS;\n    vec3 lightCol;\n    float ph = 0.0;\n\n    vec3 neesampDir = lightPos - ro;\n\n    float r2 = dot(neesampDir,neesampDir);\n    float r1 = sqrt(r2);\n    neesampDir /= r1;\n\n    vec2 neeray = rayMarch(ro, neesampDir);\n\n    lightCol = vec3(audio(time+(nrand(ns)/float(iSampleRate)) + ((ph+neeray.x)/SPEED_OF_SOUND)), 0.);\n\n    sound += 0.1*(((neeray.x < 0.0) || (neeray.x > r1  && neeray.x > 0.0)) ? ((lightCol)/r2) : vec3(0)).xy;\n    #endif\n     return sound.x;\n}\n\nvec2 mainSound(int samp, float time) {\n    uvec4 ns = uvec4(samp, 420, 69, 1337);\n\n    return 0.1*vec2(traceSoundL(time, ns),traceSoundR(time, ns));\n    //return 0.1*audio(time);\n\n    vec2 grad;\n\n    float o0 = psrdnoise(vec2(100.0*time, 0.0+time), vec2(0), 0.0, grad);\n    float o1 = psrdnoise(vec2(200.0*time, 0.0+time), vec2(0), 1.0, grad);\n    float o2 = psrdnoise(vec2(400.0*time, 0.0+time), vec2(0), 3.0, grad);\n    float o3 = psrdnoise(vec2(800.0*time, 0.0+time), vec2(0), 2.5, grad);\n    //return vec2(texture(iChannel0,vec2(300.0*(time/256.0),floor(time/256.0)/256.0)).r-0.5);\n\n    return 0.066*vec2(0.5*o0+0.25*o1+0.125*o2+0.0625*o3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}