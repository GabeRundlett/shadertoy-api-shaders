{
    "Shader": {
        "info": {
            "date": "1639731276",
            "description": "Three of the most popular invertible azimuthal projections, for equal-area, equidistance and conformant mappings to and from the disc, including various invertible disc <-> square mappings",
            "flags": 0,
            "hasliked": 0,
            "id": "stdXDS",
            "likes": 18,
            "name": "Azimuthal Projections",
            "published": 3,
            "tags": [
                "projection",
                "area",
                "spherical",
                "equal",
                "arcmap"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 595
        },
        "renderpass": [
            {
                "code": "\n// if defined, demonstrate the inverse mapping \n//#define SHOW_INVERSE\n\n// if defined, adjusts the latitude so that equal spaced points on the map\n// are equal spaced on the sphere; if not defined, the latitude will map\n// exactly to the radius.\n#define FIX_EQUAL_AREA\n\n// if defined, adjusts the latitude so that crossing angles are preserved\n// this excludes the equidistant or equal-area properties.\n//#define FIX_CONFORMAL\n\n// if defined, stretches the map to cover the entire UV square; various\n// modes are available below, of which the default provides an equiareal\n// mapping.\n//#define SQUARIFY\n\n// if defined, shows an environment map instead of a XYZ color gradient\n// for inverse mode, demonstrates texture mapping\n#define SHOW_CUBEMAP\n\n// if defined, shows latitude/longitude lines\n#define SHOW_FLOW_LINES\n\n// if defined, shows the latitude as cos(theta) instead of theta\n//#define SHOW_COS_THETA\n\n// if defined, shows a UV tesselation of quadliterals, and the proportional\n// difference between the quadliteral area and the expected average size (2/NÂ²)\n// if FIX_EQUAL_AREA is defined, the proportions will be ideal.\n//#define SHOW_SOLID_ANGLE\n\n// if not defined, computes a more accurate solid angle from cosines,\n// though the precision of this method is terrible and is only relevant\n// for rough tesselations anyway.\n#define USE_TRIANGLE_AREA\n\n// subdivisions per quadrant\n#if defined(SHOW_SOLID_ANGLE)||defined(SHOW_INVERSE)\n#undef SHOW_FLOW_LINES\n// solid angle subdivisions\nconst float subdivisions = 32.0;\n#else\n// flow line subdivisions\nconst float subdivisions = 16.0;\n#endif\n\n// thesis related functions\n//////////////////////////////////////////////////////////\n\n//#define TEST_EQUIAREAL\n//#define TEST_INVERTIBLE\n#ifdef TEST_INVERTIBLE\n#undef SHOW_CUBEMAP\n#endif\n\n// some of the square<->disc conversion functions are from\n// https://arxiv.org/abs/1509.06344\n// https://jcgt.org/published/0005/02/01/\n// area normalization after\n// Stratified Sampling of 2-Manifolds, James Arvo\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.3412&rep=rep1&type=pdf\n\n// approximate inverse of f(x) = x - sin(x)\n// used by chord mapping\nfloat inverse_diff_sinx_x(float y) {\n    // newton's method\n    float y0 = mod(y, radians(360.0));\n    float x = y0 - sign(y0 - radians(180.0));\n    // higher resolutions might require more iterations\n    for (int i = 0; i < 4; ++i) { \n        float f_x = x - sin(x) - y0;\n        float ff_x = 1.0 - cos(x);\n        x = x - f_x / ff_x;\n    }\n    return (y == 0.0)?y:(x + y - y0);\n}\n\nvec2 inv_shirley_chiu(vec2 p) {\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    float r = length(p);\n    float a = atan(p.y, p.x) / radians(360.0) - 0.125;\n    float px = abs(fract(a) - 0.5);\n    float py = abs(fract(a - 0.25) - 0.5);\n    return (4.0 * r) * vec2(px - py, px + py - 0.5);\n}\n\nvec2 shirley_chiu(vec2 p) {\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    bool is_h = (abs(p.x) > abs(p.y));\n    vec2 o = is_h?p:p.yx;\n    float r = o.x;\n    float h = o.y/r - 1.0;\n    float phi = radians(45.0)*(1.0 + ((r == 0.0)?0.0:(is_h?h:-h)));\n    return vec2(cos(phi),sin(phi))*r;\n}\n\n// map a square [-1..1]x[-1..1] to a disc of radius 1\nvec2 square_disc(vec2 p) {\n#if 0\n    // Elliptical Grid Mapping (Philip Nowell)\n    // http://mathproofs.blogspot.com/2005/07/mapping-square-to-circle.html\n    p = p*sqrt(1.0 - p.yx*p.yx/2.0);\n    return p;\n#elif 0\n    // FG-Squircular Mapping (Fernandez Guasti squircle)\n    vec2 pp = p*p;\n    float L = pp.x + pp.y;\n    p = p*sqrt((L - pp.x * pp.y)/L);    \n    return p;\n#elif 0\n    // polar equi-areal\n    float r = sqrt((p.x+1.0)/2.0);\n    float phi = p.y*radians(180.0);\n    return r*vec2(cos(phi),sin(phi));\n#elif 0\n    // chord mapping, equi-areal\n    float a = (1.0 - abs(p.y))*radians(180.0); // A*2\n    float theta = inverse_diff_sinx_x(a)/2.0; // theta/2\n    p.y = cos(theta)*sign(p.y);\n    p.x = p.x * sin(theta);\n    return p;\n#elif 0\n    // half-concentric chord mapping, equi-areal\n    p = vec2(p.y + p.x, p.x - p.y)*0.5;\n\n    float h1 = 1.0 - abs(p.y);\n    p.x = (h1 == 0.0)?0.0:(p.x / h1);\n\n    float a = h1*h1*radians(180.0); // A*2\n    float theta = inverse_diff_sinx_x(a)/2.0; // theta/2\n    p.y = cos(theta)*sign(p.y);\n    p.x = p.x * sin(theta);\n\n    p = vec2(p.y + p.x, p.x - p.y)*sqrt(0.5);\n    return p;\n#elif 0\n    // L1 elliptical grid mapping, area-normalized\n    vec2 s = sign(p);\n    p = abs(p);\n    \n    // warp parameters\n    float c0 = 1.0/2.0*sqrt(-8.0*p.x + 9.0);\n    p = vec2(\n        3.0/2.0 - c0,\n        1.0/2.0 + c0 - sqrt(5.0/2.0 - 2.0*p.x - c0*(2.0*p.y - 1.0)));\n    // map\n    p = p*(1.0 - p.yx/2.0);\n    \n    p = p * s;\n    \n    p = vec2(p.y + p.x, p.y - p.x);\n    p = shirley_chiu(p);    \n    return p;\n#elif 1\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    return shirley_chiu(p);\n#else\n    // Stretching\n    return p/length(p)*max(abs(p.x),abs(p.y));\n#endif\n}\n\n// map a disc of radius 1 to a square [-1..1]x[-1..1]\nvec2 disc_square(vec2 p) {\n#if 0\n    // Elliptical Grid Mapping (Philip Nowell)\n    // http://mathproofs.blogspot.com/2005/07/mapping-square-to-circle.html\n    vec2 pp = p*p;\n    float z1 = pp.x - pp.y;\n    vec2 z = 2.0 + vec2(z1,-z1);\n    vec2 w = 2.0 * sqrt(2.0) * p;\n    return (sqrt(z + w) - sqrt(z - w))/2.0;\n#elif 0\n    // FG-Squircular Mapping (Fernandez Guasti squircle)\n    vec2 pp = p*p;\n    float L = pp.x + pp.y;\n    return sqrt(0.5)*sign(p)/abs(p.yx)* sqrt(L - sqrt(L*(L - 4.0*pp.x*pp.y)));\n#elif 0\n    // polar equi-areal\n    float r = dot(p,p);\n    float phi = atan(p.y,p.x);\n    return vec2(r*2.0-1.0, phi/radians(180.0));\n#elif 0\n    // chord mapping, equi-areal\n    float c = sqrt(1.0 - p.y*p.y); // half chord\n    float a = asin(c) - c*abs(p.y);\n    p.x /= c;\n    p.y = (1.0 - a/radians(90.0))*sign(p.y);\n    return p;\n#elif 0\n    // half-concentric chord mapping, equi-areal\n    p = vec2(p.y + p.x, p.x - p.y)*sqrt(0.5);\n    float c = sqrt(1.0 - p.y*p.y);\n    float a = asin(c) - c*abs(p.y);\n    float h1 = sqrt(a/radians(90.0));\n    p.y = (1.0 - h1)*sign(p.y);\n    p.x = (c == 0.0)?0.0:(p.x * h1 / c);\n    p = vec2(p.y + p.x, p.x - p.y);    \n    return p;\n#elif 0\n    // L1 elliptical grid mapping, area-normalized\n    p = inv_shirley_chiu(p);\n    p = vec2(p.x - p.y, p.x + p.y)/2.0;\n    vec2 s = sign(p);\n    p = abs(p);\n    p = 1.0/2.0*p - 1.0/2.0*p.yx - 1.0/2.0*sqrt(p*p - 2.0*(p + 2.0)*p.yx + p.yx*p.yx - 4.0*p + 4.0) + 1.0;\n    p = vec2(\n        3.0/2.0*p.x - 1.0/2.0*p.x*p.x,\n        (2.0*(p.x - 2.0)*p.y + p.y*p.y)/(2.0*p.x - 3.0));    \n    p = p * s;\n    return p;\n#elif 1\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    return inv_shirley_chiu(p);\n#else\n    // Stretching\n    return p/max(abs(p.x),abs(p.y))*length(p);\n#endif\n}\n\nvec3 conformal_normal(vec2 uv) {\n    // Stereographic map projection\n    float rr = dot(uv,uv);\n    float sin_a_div_r = 2.0/(rr + 1.0);\n    float cos_a = (1.0 - rr)*0.5*sin_a_div_r;\n    return vec3(uv*sin_a_div_r, cos_a);\n}\n\nvec2 conformal_disc(vec3 n) {\n    // Stereographic map projection\n    return n.xy/(n.z + 1.0);\n}\n\nvec3 equalarea_normal(vec2 uv) {\n    // lambert azimuthal equal-area projection\n    float rr = dot(uv,uv);\n    float cos_a = 1.0 - rr;\n    float sin_a_div_r = sqrt(2.0 - rr);\n    return vec3(uv*sin_a_div_r, cos_a);\n}\n\nvec2 equalarea_disc(vec3 n) {\n    // lambert azimuthal equal-area projection\n    return n.xy/sqrt(n.z + 1.0);\n}\n\nvec3 equidistant_normal(vec2 uv) {\n    // azimuthal equidistant projection\n    float r = length(uv);\n    float a = r*radians(90.0);\n    return vec3(((r==0.0)?vec2(0.0):(uv/r*sin(a))), cos(a));\n}\n\nvec2 equidistant_disc(vec3 n) {\n    // azimuthal equidistant projection\n    float a = acos(n.z);\n    float r = a/radians(90.0);\n    return n.xy/sin(a)*r;\n}\n\n// arcmap coordinates to normal\nvec3 arcmap_normal(vec2 uv) {\n#ifdef SQUARIFY\n    uv = square_disc(uv);\n#endif\n#ifdef FIX_CONFORMAL\n    return conformal_normal(uv);\n#elif defined(FIX_EQUAL_AREA)\n    return equalarea_normal(uv);\n#else\n    return equidistant_normal(uv);\n#endif        \n}\n\n// normal to arcmap coordinates\nvec2 normal_arcmap(vec3 n) {\n    vec2 uv;\n#ifdef FIX_CONFORMAL\n    uv = conformal_disc(n);\n#elif defined(FIX_EQUAL_AREA)\n    uv = equalarea_disc(n);\n#else\n    uv = equidistant_disc(n);\n#endif  \n#ifdef SQUARIFY\n    return disc_square(uv);\n#else\n    return uv;\n#endif\n}\n\n// visualization\n//////////////////////////////////////////////////////////\n\nfloat triangle_area(vec3 A, vec3 B, vec3 C) {\n    return length(cross(B - A, C - A)) / 2.0;\n}\n\nvec2 nanglebasis (vec3 a, vec3 b) {\n    float ab = dot(a, b);\n    return vec2(ab, sqrt(1.0 - ab * ab));\n}\n\nfloat simplex_solid_angle (vec2 u, vec2 v, vec2 w) {\n    float A =\n            acos((u.x - v.x * w.x) / (v.y * w.y))\n            + acos((v.x - w.x * u.x) / (w.y * u.y))\n            + acos((w.x - u.x * v.x) / (u.y * v.y))\n            - radians(180.0);\n    return (A != A)?0.0:A;\n}\n\nfloat pyramid_points_solid_angle (vec3 A, vec3 B, vec3 C, vec3 D) {\n#ifdef USE_TRIANGLE_AREA\n    return triangle_area(A, B, C) + triangle_area(C, D, A);\n#else\n    vec2 ab = nanglebasis(A, B);\n    vec2 ac = nanglebasis(A, C);\n    vec2 da = nanglebasis(A, D);\n    vec2 bc = nanglebasis(B, C);\n    vec2 cd = nanglebasis(C, D);\n    return simplex_solid_angle(bc, ac, ab) + simplex_solid_angle(da, ac, cd);\n#endif\n}\n\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, s*p.x - c*p.y);\n}\n\nvec3 stereographic_sphere(vec2 uv) {\n    vec3 n = vec3(uv, sqrt(1.0 - dot(uv,uv)));\n    float t = iTime*0.1;\n    n.yz = rotate(n.yz, radians(sin(t*0.25*radians(360.0))*45.0));    \n    n.xz = rotate(n.xz, t*radians(360.0));    \n    return n;\n}\n\n//////////////////////////////////////////////////////////\n\n// for inverse mapping\nvec3 transfer_color(vec2 q) {\n    q = q*0.5 + 0.5;\n#ifdef SHOW_CUBEMAP\n    return textureLod(iChannel1, q*2.0, 0.0).rgb;\n#elif 1\n    ivec2 p = ivec2(q*subdivisions) & 1;\n    return vec3(p.x^p.y);\n#else\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q, 0.0);\n#endif\n}\n\nvec3 transfer_color(vec3 p) {\n#ifdef SHOW_CUBEMAP\n#ifndef TEST_EQUIAREAL\n    p.xz = rotate(p.xz, iTime*0.5);\n#endif\n    return textureLod(iChannel0, p, 0.0).xyz;\n#elif defined(SHOW_INVERSE)\n    vec2 q = normal_arcmap(p);\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q*0.5 + 0.5, 0.0);\n#else\n    return p*0.5 + 0.5;\n#endif\n}\n\nfloat flow_lines(vec3 q) {\n#ifndef TEST_EQUIAREAL\n    q.xz = rotate(q.xz, radians(90.0) + iTime*0.5);\n#endif\n    float a = atan(q.y, q.x);\n#ifdef SHOW_COS_THETA\n    float r = q.z*radians(90.0);\n#else\n    float r = acos(q.z);\n#endif\n    float A = subdivisions;\n    return sin(a*A)*sin(r*A);\n}\n\nfloat arcmap_flow_lines(vec2 p) {\n    return flow_lines(arcmap_normal(p));\n}\n\nbool in_range(vec2 p) {\n#ifdef SQUARIFY\n    return max(abs(p.x),abs(p.y)) <= 1.0;\n#else\n    return length(p) <= 1.0;\n#endif\n}\n\nvec3 solid_angle_color(vec3 p00, vec3 p10, vec3 p01, vec3 p11) {\n#ifdef SQUARIFY    \n    // ideal solid angle: pi / (2*subdivisionsÂ²)\n    float isa = radians(180.0) / (2.0 * (subdivisions * subdivisions));\n#else\n    // ideal solid angle: 2 / (subdivisionsÂ²)\n    float isa = 2.0 / (subdivisions * subdivisions);\n#endif\n    float sa1 = pyramid_points_solid_angle(p00,p10,p11,p01);\n    float sa2 = pyramid_points_solid_angle(p10,p00,p01,p11);\n    float sa = (uv.x*uv.y < 0.0)?sa1:sa2;\n#if 1\n    sa = abs(sa/isa-1.0);\n#else\n    sa = abs(log2(sa/isa));\n#endif\n    return plasma(clamp(sa,0.0,1.0));\n}\n\nvoid paint_arcmap() {\n    set_line_width_px(1.2);\n    \n    vec2 uv = get_origin();\n    #ifdef TEST_INVERTIBLE\n    vec2 p = normal_arcmap(arcmap_normal(uv));\n    #else\n    vec3 p = arcmap_normal(uv);\n    #endif\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = arcmap_normal(uv + w.xx);\n    vec3 p10 = arcmap_normal(uv + w.yx);\n    vec3 p01 = arcmap_normal(uv + w.xy);\n    vec3 p11 = arcmap_normal(uv + w.yy);\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif\n#ifdef SQUARIFY\n    rectangle(-1.0,-1.0,2.0,2.0);\n#else\n    circle(0.0, 0.0, 1.0);\n#endif\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    if (in_range(get_origin())) {\n        graph2D(arcmap_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_inverse_arcmap() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());  \n    float z = n.z;\n    n.z = abs(n.z);\n    vec2 uv = normal_arcmap(n);  \n    if (z < 0.0) {\n        uv.x = -uv.x;\n    }\n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();\n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid paint() {\n    set_source_rgb(vec3(0.2));\n    clear();\n\n#if defined(SHOW_INVERSE)\n    paint_inverse_arcmap();\n#else\n    paint_arcmap();\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}