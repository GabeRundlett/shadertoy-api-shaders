{
    "Shader": {
        "info": {
            "date": "1623254715",
            "description": "Sphere in a box or a box in sphere ?\n\nInspired by Nathan Riley\nhttps://dribbble.com/shots/10879124-Morphing-Geometry",
            "flags": 0,
            "hasliked": 0,
            "id": "slj3RR",
            "likes": 7,
            "name": "Fork Sphere in  poluchka 510",
            "published": 3,
            "tags": [
                "raytracing",
                "refraction",
                "sphere",
                "box",
                "diffraction",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "poluchka",
            "viewed": 374
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define GAMMA 0\n\nstruct objDec\n{\n    float r;\n    float s;\n    mat3  m;\n};\n    \n    \nobjDec inner, outter;\n\nconst float offset = 4.;\n\n        \nbool intersectObjFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    ro = ro + rd * offset;\n    rd = -rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = -roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = offset - d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectObjFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectSceneFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, outter);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, inner);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\nbool intersectSceneFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, inner);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, outter);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\n\n\n#define MAX_BOUNCES 4\n#define ABSORB\t\tvec3(0, 0, 0)\n\nvec3 Render(in vec3 ro, in vec3 rd, in float dist, float cref)\n{\n    float sgn = 1.;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.99;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tn;\n        float \td;\n        bool\tinter;\n        if(sgn > 0.)\n        {\n            inter = intersectSceneFromOutside(ro, rd, dist, d, n);\n        }\n        else\n        {\n            inter = intersectSceneFromInside(ro, rd, dist, d, n);\n        }\n        \n        if(!inter)\n        {\n            col += rel * getSkyColor(rd);\n            return col;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * d);\n        vec3 p = ro + rd * d;\n        //n *= sgn;\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime * 0.95;\n    float v = (cos(t) + 1.) * 0.5;\n    \n    outter.r = v * 0.75 + 0.1;\n    outter.s   = (1.-v) * 0.75;\n    outter.m = fromEuler(vec3(t * 0.9 + 0.2,  t * 0.6 + 1.2, t * 0.5 + 0.9));\n    inner.r  = (1.-v) * 0.35 + 0.1;\n    inner.s\t   = v * 0.35;\n    inner.m = fromEuler(vec3(t * 0.8 + 1.5,  t * 0.4 + 0.7, t * 0.7 + 2.3));\n\n  \n\tvec3 tot = vec3(0.0);   \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + radians(180.);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col;\n        col.r = Render(ro, rd, 12.,0.67).r;\n        col.g = Render(ro, rd, 12.,0.7).g;\n        col.b = Render(ro, rd, 12.,0.73).b;\n        \n      \ttot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// my modified round intersection from https://www.shadertoy.com/view/wsyyWw\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.;\n}\n\n// intersect a ray with a rounded box\n// https://iquilezles.org/articles/intersectors\n// Modified to support bigger radius, probably more optimal solution, but was too lazy and nor as good as IQ :(\n// I kept the -1 for no collision paradigm even if I hate it (Make code more complex), but I prefered to stay compatible with IQ interface.\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    \n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n  \n  \t// fat edges\n    float d;\n    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);\n    t = d > 0. ? d : 1e20;\n    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n    \n}\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}