{
    "Shader": {
        "info": {
            "date": "1620408566",
            "description": "ran across [url=https://stackoverflow.com/a/26127012]this[/url] and wanted to try it out.\nsky from @Gijs's [url=https://www.shadertoy.com/view/7dSSzy]Basic : Less Simple Atmosphere[/url].",
            "flags": 32,
            "hasliked": 0,
            "id": "ssjXWm",
            "likes": 15,
            "name": "fibonacci sphere",
            "published": 3,
            "tags": [
                "fibonacci"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 978
        },
        "renderpass": [
            {
                "code": "// sky from @Gijs's [url=https://www.shadertoy.com/view/7dSSzy]Basic : Less Simple Atmosphere[/url].\n\n// Fork of \"mirascope\" by elenzil. https://shadertoy.com/view/NdjXzw\n// 2021-05-07 16:22:59\n\n\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nbool gDemoView  = false;\nconst bool gDebugView = false;\nmat2 gSceneRot  = mat2(1.0, 0.0, 0.0, 1.0);\nconst float gutter = 0.175;\nconst float gutterInv = 1.0 - gutter;\n\n// positive for cross-eyed, make negative for wall-eyed viewing.\nconst float stereoSeparation = 0.4;\n\nstruct pol3 {\n    float rho;\n    float tht;\n    float phi;\n};\n\npol3 sphericalFromCartesian(in vec3 cartesian) {\n    pol3 ret;\n\n    ret.tht = atan(cartesian.z, cartesian.x);\n    ret.phi = acos(dot(normalize(cartesian), vec3(0.0, 1.0, 0.0))) - PI/2.0;\n    ret.rho = length(cartesian);\n\n    return ret;\n}\n\nfloat maxPart(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\n//--------------------------------------------------------------------------------\n\n// direction to the light\nvec3 gLightDirection = normalize(vec3(-1.0, 2.0, 0.5));\n\n//--------------------------------------------------------------------------------\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(-pos.y, 0.0)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, gLightDirection),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d) * transmittance(l);\n    float f = 1.0 - d.y / gLightDirection.y;\n    float l2 = atmosphereDepth(p, gLightDirection);\n    vec3 sk = simple_sun(gLightDirection) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return sun + sk;\n}\n\n//--------------------------------------------------------------------------------\n\n// I forget the location, but this pattern is from IQ.\n\nvec2 opUnion(in vec2 q1, in vec2 q2) {\n    return q1.x < q2.x ? q1 : q2;\n}\n\nvec2 opSubtraction(in vec2 q1, in vec2 q2) {\n    return -q1.x > q2.x ? vec2(-q1.x, q1.y) : q2;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n// swap args from stock subtraction().\nvec2 opMinus( in vec2 q1, in vec2 q2 ) { return opSubtraction(q2, q1); }\n\n//--------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz) - r;\n}\n\nfloat sdSlab(in vec3 p, float r) {\n    return abs(p.y) - r;\n}\n\nfloat sdCappedCylinderPrecomputedQ(vec2 q, float h, float r)\n{\n  vec2 d = abs(q) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCrateBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    \n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        // 3 roots\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    \n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat sdSphere( in vec3 pos, in float r ) {\n    return length(pos) - r;\n}\n\n\nfloat sdMiraScope(in vec3 pos, in float separation, in float thickness, in float holeRadius) {\n    // convert pos to 2D by revolving it around Y\n    vec2 p = vec2(length(pos.xz), pos.y);\n\n    // an up and down facing parabola, a little apart\n    float sdTop = sdParabola(vec2(p.x, p.y + separation),  0.5);\n    float sdBot = sdParabola(vec2(p.x, p.y - separation), -0.5);\n\n    // intersected\n    float sdMira = max(sdTop, sdBot);\n\n    // onioned\n    sdMira = abs(sdMira) - thickness;\n\n    // slice off the top so we can see inside!\n    // sdMira = max(sdMira, p.y - separation * 0.9);\n    \n    // cut a hole in the top so we can see inside!\n    // this has somewhat less visibility into the interior compared to slicing,\n    // but avoids long thin wedges.\n    sdMira = opSubtraction(sdCappedCylinderPrecomputedQ(vec2(p.x, p.y - separation + thickness), holeRadius, separation * 0.2 + thickness * 3.0), sdMira);\n\n    return sdMira;\n}\n\n\nfloat sdGridOfSpheres(in vec3 pos) {\n    float num = 3.0;\n    float lim = 0.3;\n    float rad = 0.75 * lim / (num - 1.0);\n     \n    pos.y -= lim + rad - 0.4;\n    \n    float step = (lim * 2.0) / (num - 1.0);\n    \n    float d = 1e9;\n    \n    vec3 c = vec3(0.0);\n    \n    for (c.x = -lim; c.x <= lim; c.x += step) {\n    for (c.y = -lim; c.y <= lim; c.y += step) {\n    for (c.z = -lim; c.z <= lim; c.z += step) {\n        d = min(d, sdSphere(pos - c, rad));\n    }}}\n    return d;\n}\n\n/*\nfrom https://stackoverflow.com/a/26127012\ndef fibonacci_sphere(samples=1):\n\n    points = []\n    phi = math.pi * (3. - math.sqrt(5.))  # golden angle in radians\n\n    for i in range(samples):\n        y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n        radius = math.sqrt(1 - y * y)  # radius at y\n\n        theta = phi * i  # golden angle increment\n\n        x = math.cos(theta) * radius\n        z = math.sin(theta) * radius\n\n        points.append((x, y, z))\n\n    return points\n*/\nfloat sdFibSphere(in vec3 pos, in float rad1, in float rad2) {\n\n    float d = 1e9;\n    \n    // early-out.\n    // this approach to bounding volume destroys exactness of SDF.\n    // discussion in https://www.shadertoy.com/view/ssBXRG\n    float sdBounds = abs(sdSphere(pos, rad1)) - rad2;\n    if (sdBounds > rad2 * 0.2) {\n        return sdBounds;\n    }\n\n    // golden angle\n    const float phi = 3.14159265359 * (3.0 - sqrt(5.0));\n    \n    const float num           = 50.0;\n    const float num_minus_one = num - 1.0;\n    \n    for (float n = 0.0; n < num; ++n) {\n        // y goes from 1 to -1\n        float y = 1.0 - (n / num_minus_one * 2.0);\n        \n        // radius at y\n        float radius = sqrt(1.0 - y * y);\n        \n        // shrink the ones near the top\n        float rad2Fac = smoothstep(1.0, 0.0, abs(y)) * 0.4 + 0.6;\n        \n        float theta = phi * n;\n        \n        float x = cos(theta) * radius;\n        float z = sin(theta) * radius;\n        \n        d = min(d, sdSphere(pos - vec3(x, y, z) * rad1, rad2 * rad2Fac));\n    }\n    \n    return d;\n}\n    \n\nfloat sdTheMainAttraction(in vec3 pos) {\n    return sdFibSphere(pos, 0.6, 0.1);\n}\n\n//-----------------------------------------------------------------------\n\n\n// set up scene position of stuff once per pixel\nconst float gBevels        = 0.01;\n\nvec3  gCamPos;\nvec3  gPosMain;\nvec3  gTablePos;\nfloat gTableRad;\nfloat gTableThick;\nfloat gTableHoleRad;\n\nvoid configMap() {\n \n    gPosMain      = vec3(0.0, 0.3, 0.0);\n    \n    gTablePos     = vec3(0.0, -0.4, 0.0);\n    \n    float tableMod = smoothstep(1.0, -2.0, gCamPos.y - gTablePos.y);\n    gTableRad     = 0.9;\n    gTableThick   = 0.01 + 0.6 * tableMod;\n    gTablePos.y   += 0.6 * tableMod;\n    gTableHoleRad = (gTableRad - gBevels * 2.0) * tableMod;\n}\n\n// return.x = distance\n// return.y = material\nvec2 map(in vec3 p) {\n\n\n    p.xz *= gSceneRot;\n\n    vec2 Q  = vec2(1e9, 0.0);\n    const float modSize = 0.3;\n    vec3 p1 = vec3(p.x, mod(p.y + modSize / 2.0, modSize) - modSize / 2.0, p.z);\n\n    \n    // table\n    Q = opUnion(Q, vec2(sdCappedCylinder(p    -       gTablePos, gTableRad, gTableThick), 3.0));    \n    Q = opMinus(Q, vec2(sdCylinder(p, gTableHoleRad), 3.0));\n    Q = opMinus(Q, vec2(sdSlab(p1, 0.05), 3.0));\n    Q.x -= gBevels;\n    \n    Q = opUnion(Q, vec2(sdTheMainAttraction(p - gPosMain), 1.0));\n    Q = opUnion(Q, vec2(sdSphere(p - gPosMain, 0.2), 3.0));\n\n\n    return Q;\n}\n\nconst float closeEps = 0.001;\n\nvec2 march(in vec3 ro, in vec3 rd) {\n    const int maxSteps = 100;\n\n    vec2 Q = vec2(1e9);\n\n    vec3 p = ro;\n    float t = 0.0;\n    for (int n = 1; n <= maxSteps; ++n) {\n        Q = map(ro + rd * t);\n        float closeEnoughEps = (n == maxSteps ? 0.2 : closeEps);\n        if (Q.x < closeEnoughEps) {\n            return vec2(t, Q.y);\n        }\n        t += Q.x;\n        if (t > 200.0) {\n            return vec2(t, Q.y);\n        }\n    }\n    return vec2(t, Q.y);\n}\n\n\n// IQ: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.002;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map(p + e*h).x;\n    }\n    return normalize(n);\n}\n\n\nfloat calcDiffuseAmount(in vec3 p, in vec3 n) {\n    return clamp(dot(n, gLightDirection), 0.0, 1.0);\n}\n\nconst float AOFactorMin = 0.5;\nconst float AOFactorMax = 1.0;\nfloat calcAOFactor(in vec3 p, in vec3 n) {\n    const float sampleDist = 0.03;\n    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist).x);\n    return mix(AOFactorMin, AOFactorMax, (dist));\n}\n\nfloat calcShadowLight(in vec3 p) {\n    float t = march(p, gLightDirection).x;\n    return t > 40.0 ? 1.0 : 0.0;\n}\n\nvec3 dirToRGB(in vec3 rd) {\n    float tht = atan(rd.z, rd.x);\n    float phi = acos(dot(normalize(rd), vec3(0.0, 1.0, 0.0)));\n    vec3 col = rd * 0.5 + 0.5;\n    col *= smoothstep(0.002, -0.002, sin(tht       * 4.0)) * -0.3 + 1.0;\n    col *= smoothstep(0.002, -0.002, sin(phi * 2.0 * 4.0)) * -0.3 + 1.0;\n    col = mix(col, col / max(col.r, max(col.g, col.b)), 0.2);\n    return col;\n}\n\nvec3 dirToRGB2(in vec3 rd) {\n    vec3 col = rd * 0.5 + 0.5;\n    return col;\n}\n\nvec3 sky(in vec3 rd) {\n    vec3 col = dirToRGB(rd);\n//  col = normalize(col);\n    col = col * 0.3;\n    vec3 ss = simple_sky(vec3(0.0, -0.3, 0.0), vec3(rd.x, rd.y, rd.z));\n    col = mix(col, ss, 0.5);    \n    col *= smoothstep(-0.01, 0.01, rd.y + 0.03) * 0.5 + 0.5;\n    return col;\n}\n\nvec3 getAlbedo(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1) {\n        vec3 rgb = dirToRGB2(normalize(pCrt - gPosMain));\n       rgb /= length(rgb);\n        return rgb;\n    }\n    else if (material == 3) {\n        return vec3(0.2);\n    }\n    else {\n        return vec3(1e9, 0.0, 1e9);\n    }\n}\n\nvec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1) {\n        return vec3(0.2);\n    }\n    else if (material == 2) {\n        return vec3(0.0);\n    }\n    else if (material == 3) {\n        return vec3(0.2);\n    }\n    else {\n        return vec3(0.0, 1e9, 0.0);\n    }\n}\n\nvec3 getEmissive(in int material, in vec3 pCrt, in pol3 pPol) {\n    return vec3(0.0);\n}\n\n\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 rgb = vec3(0.0);\n\n    int bouncesLeft = 4;\n\n    vec3 contributionLeft = vec3(1.0);\n\n    while (bouncesLeft >= 0 && maxPart(contributionLeft) > 0.001) {\n        bouncesLeft -= 1;\n        vec2 q = march(ro, rd);\n        vec3 p = ro + q.x * rd;\n        if (length(p) > 150.0) {\n            rgb += sky(rd) * contributionLeft;\n            break;\n        }\n\n        vec3 normal = calcNormal(p);\n\n        vec3 ptCrt = p;\n        ptCrt.xz *= gSceneRot;\n        pol3 ptSph = sphericalFromCartesian(ptCrt);\n\n        int material = int(q.y);\n\n        float incomingLight = 1.0;\n        incomingLight = min(incomingLight, calcDiffuseAmount(p, normal));\n        if (incomingLight > 0.0) {\n            incomingLight = min(incomingLight, calcShadowLight(p + normal * closeEps * 2.0));\n        }\n        float ambient = 0.2 * calcAOFactor(p, normal);\n        incomingLight += ambient;\n\n        float fres = 0.4 + 0.8 * clamp(pow(1.0 - abs(dot(rd, normal) - 0.1), 2.0), 0.0, 1.0);\n        \n        fres = 1.0;\n\n        vec3 reflectivity = fres * getReflectivity(material, ptCrt, ptSph);\n        vec3 diffuse = incomingLight * getAlbedo(material, ptCrt, ptSph);\n        vec3 emissive = getEmissive(material, ptCrt, ptSph);\n        \n        rgb += diffuse * (1.0 - reflectivity) * contributionLeft;\n        rgb += emissive * contributionLeft;\n        contributionLeft *= reflectivity;\n          \n        ro = p + normal * 0.05;\n        rd = reflect(rd, normal);\n    }\n\n    return rgb;\n}\n\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    vec4 persistedInfo = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    bool stereo = iMouse.x < iResolution.x * gutter && iMouse.y > iResolution.y * gutterInv;\n    bool leftEye = XY.x > iResolution.x / 2.0;\n    \n    vec2 Res = iResolution.xy;\n    Res.x   *= stereo ? 0.5 : 1.0;\n    XY.x    -= (stereo && leftEye) ? iResolution.x / 2.0 : 0.0;\n\n    setupCoords(Res, 4.2);\n    setupTime(iTime);\n    vec2  uv        = worldFromScreen(XY);\n    vec2  ms        = persistedInfo.xy / iResolution.xy * 2.0 - 1.0;\n    float smoothEps = gWorldFromScreenFac * 2.0;\n\n    // look-from and look-to points\n    // right-handed system where x is right, y is up, z is forward.\n    float t = gTime * 0.23;\n    vec3 trgPt = vec3(0.0, 0.1, 0.0);\n    \n    float camTht = -ms.x * PI * 1.25;\n    float camPhi = ms.y;\n    \n    bool defaultView = stereo;\n //   gDebugView      = !defaultView && (length(iMouse.xy) < iResolution.x * gutter);\n    if (gDebugView) {\n        camTht = sin(iTime * 0.10) * 0.1;\n        camPhi = sin(iTime * 0.12) * 0.1;\n    }\n    else if (defaultView) {\n        camPhi = -20.0 * DEG2RAD;\n    }\n    \n    mat2 camThtRot2 = rot2(camTht);\n    mat2 camPhiRot2 = rot2(camPhi);\n    \n    gDemoView = gDebugView || iMouse.x > iResolution.x * gutterInv;\n    \n    gSceneRot = rot2(gTime * PI * 2.0 / 30.0);\n    // anchor the light to the camera\n    gLightDirection.xz *= -camThtRot2;\n\n    \n    vec3 camPt = vec3(0.0, 0.0, -1.0);\n    camPt.yz *= camPhiRot2;\n    camPt.xz *= camThtRot2;\n    camPt *= gDebugView ? 1.7 : 4.0;\n    \n    // camera's forward, right, and up vectors. right-handed.\n    vec3 camFw = normalize(trgPt - camPt);\n    vec3 camRt = normalize(cross(camFw, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = cross(camRt, camFw);\n    \n    if (stereo) {\n        camPt += camRt * (leftEye ? -1.0 : 1.0) * stereoSeparation / 2.0;\n        camFw = normalize(trgPt - camPt);\n        camRt = normalize(cross(camFw, vec3(0.0, 1.0, 0.0)));\n        camUp = cross(camRt, camFw);\n    }\n    \n    gCamPos = camPt;\n    configMap();\n\n    // ray origin and direction\n    vec3 ro    = camPt;\n    vec3 rd    = normalize(camFw + uv.x * camRt + uv.y * camUp);\n\n    vec3 rgb = render(ro, rd);\n\n    // Vignette from Ippokratis https://www.shadertoy.com/view/lsKSWR\n\tvec2 pq = XY / Res;   \n    pq *=  1.0 - pq.yx;    \n    float vig = pq.x*pq.y * 200.0;    \n    vig = pow(vig, 0.15);\n    rgb *= vig;\n\n    rgb = sqrt(rgb);\n\n    RGBA = vec4(rgb, 1.0);\n}\n\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    if (iFrame < 1) {\n        RGBA = vec4(iResolution.x/2.0, iResolution.y/3.0, -1e9, 0.0);\n        return;\n    }\n\n    ivec2 IJ = ivec2(XY);\n    \n    if (IJ != ivec2(0)) {\n        RGBA = vec4(0.0);\n        return;\n    }\n\n    // data.xy = use this as mouse point, other buffers.\n    // data.zw = actual last mouse position, if mouse was down. else -1e9.\n \n    vec4 data = texelFetch(iChannel0, IJ, 0);\n     \n     \n    bool prevMouseDown = data.z   >  0.0;\n    bool currMouseDown = iMouse.z >  0.0;\n     \n    vec2 prevMp = prevMouseDown ? data.zw : iMouse.xy;\n    data.xy += iMouse.xy - prevMp;\n    data.y = clamp(data.y, iResolution.y * -0.25, iResolution.y * 1.25);\n    data.zw = currMouseDown ? iMouse.xy : vec2(-1.0);\n     \n    \n    RGBA = data;\n}\n\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-05 18:18:15\n\nconst float PI      = 3.14159265359;\nconst float TAO     = PI * 2.0;\nconst float DEG2RAD = TAO / 360.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n\n// to prevent loop-unrolling\n#define ZERO (min(0, int(iFrame)))\n\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}