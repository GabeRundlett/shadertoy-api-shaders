{
    "Shader": {
        "info": {
            "date": "1726781339",
            "description": "thought i'd give the new \"o1-preview\" LLM a shadertoy trial.\nsee source code for the prompt used.",
            "flags": 0,
            "hasliked": 0,
            "id": "4XlyWs",
            "likes": 8,
            "name": "cgpt o1-preview test",
            "published": 3,
            "tags": [
                "llm",
                "genai",
                "o1"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 102
        },
        "renderpass": [
            {
                "code": "/*\n\nChatGPT o1-preview.\n\n* Started New Session\n* Used the following prompt:\n    write me a fully functional shadertoy shader rendering a fancy throne.\n    the throne should be made out of glass.\n    the throne should be standing on an infinite checkerboard plane.\n    the plane should fade out towards the horizon.\n    there should be a photo-realistic sky.\n    there should be shadows.\n    the camera should be slightly above the throne, \n    and should be orbiting the throne slowly.\n    It should take about 30 seconds to complete one full orbit.\n    if the user clicks the mouse the orbiting should stop\n    and the camera is controlled by the mouse instead.\n    remember than in glsl2, functions must be defined above their first use.\n    also, you do not need to declare uniforms.\n    remember that there can be no recursion in glsl2.\n\n\n* everything below here is verbatim output.\n\n*/\n\n\n\n// Throne Shader - Shadertoy\n\n// Distance functions\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Scene distance function with material IDs\nfloat map(vec3 p, out int materialID)\n{\n    // Throne components\n    float seat = sdBox(p - vec3(0.0, 1.0, 0.0), vec3(1.0, 0.1, 1.0));\n    float backrest = sdBox(p - vec3(0.0, 2.0, -0.9), vec3(1.0, 1.0, 0.1));\n    float leg1 = sdCylinder(p - vec3(0.9, 0.5, 0.9), 0.5, 0.1);\n    float leg2 = sdCylinder(p - vec3(-0.9, 0.5, 0.9), 0.5, 0.1);\n    float leg3 = sdCylinder(p - vec3(0.9, 0.5, -0.9), 0.5, 0.1);\n    float leg4 = sdCylinder(p - vec3(-0.9, 0.5, -0.9), 0.5, 0.1);\n\n    // Combine throne components\n    float throneDist = min(seat, backrest);\n    throneDist = min(throneDist, leg1);\n    throneDist = min(throneDist, leg2);\n    throneDist = min(throneDist, leg3);\n    throneDist = min(throneDist, leg4);\n\n    // Floor\n    float floorDist = p.y;\n\n    // Compare distances\n    if (throneDist < floorDist)\n    {\n        materialID = 1; // Glass throne\n        return throneDist;\n    }\n    else\n    {\n        materialID = 2; // Floor\n        return floorDist;\n    }\n}\n\n// Calculate normal at point p\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.001;\n    vec2 e = vec2(1.0, -1.0) * eps;\n    int unused;\n    return normalize(\n        e.xyy * map(p + e.xyy, unused) +\n        e.yyx * map(p + e.yyx, unused) +\n        e.yxy * map(p + e.yxy, unused) +\n        e.xxx * map(p + e.xxx, unused));\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, out int materialID)\n{\n    float t = 0.0;\n    const float MAX_DIST = 100.0;\n    const int MAX_STEPS = 100;\n    const float SURF_DIST = 0.001;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float dist = map(p, materialID);\n        if(dist < SURF_DIST)\n        {\n            return t;\n        }\n        t += dist;\n        if(t >= MAX_DIST)\n        {\n            break;\n        }\n    }\n    return -1.0;\n}\n\n// Soft shadow function\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float res = 1.0;\n    float t = tmin;\n    int unused;\n    for(int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t, unused);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(res < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Sky color function\nvec3 getSkyColor(vec3 rd)\n{\n    float t = 0.5 * (rd.y + 1.0);\n    return mix(vec3(0.6, 0.8, 1.0), vec3(1.0, 1.0, 1.0), t);\n}\n\n// Main rendering function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera\n    vec3 ro; // Ray origin\n    vec3 rd; // Ray direction\n    vec3 camTarget = vec3(0.0, 1.0, 0.0);\n\n    float radius = 5.0;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    if (iMouse.z > 0.0)\n    {\n        // Mouse is pressed, use mouse to control camera\n        float mx = (iMouse.x / iResolution.x - 0.5) * 2.0 * 3.1415926535;\n        float my = (iMouse.y / iResolution.y - 0.5) * 3.1415926535 * 0.25; // Limit vertical angle\n\n        ro = camTarget + radius * vec3(cos(my) * sin(mx), sin(my), cos(my) * cos(mx));\n    }\n    else\n    {\n        // Orbiting camera\n        float time = iTime;\n        float angle = time * (2.0 * 3.1415926535 / 30.0); // 30 seconds per orbit\n\n        ro = camTarget + radius * vec3(sin(angle), 2.0, cos(angle));\n    }\n\n    // Camera matrix\n    vec3 cw = normalize(camTarget - ro); // Forward\n    vec3 cu = normalize(cross(cw, up));  // Right\n    vec3 cv = cross(cu, cw);             // Up\n\n    rd = normalize(uv.x * cu + uv.y * cv + 1.5 * cw); // Adjust FOV by changing 1.5\n\n    // Ray marching\n    int materialID;\n    float t = rayMarch(ro, rd, materialID);\n\n    vec3 col;\n    if(t > 0.0)\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n\n        // Lighting\n        vec3 lightPos = vec3(5.0, 5.0, 5.0);\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        // Shadows\n        float shadow = softShadow(p + normal * 0.001, lightDir, 0.01, 10.0);\n\n        // Ambient occlusion (simplified)\n        float ambient = 0.2;\n\n        if(materialID == 1)\n        {\n            // Glass throne\n            // Refraction and reflection\n            float eta = 1.0 / 1.5; // Glass refractive index\n            vec3 refracted = refract(rd, normal, eta);\n            vec3 reflected = reflect(rd, normal);\n\n            // Fresnel term\n            float fresnel = pow(1.0 - max(dot(-rd, normal), 0.0), 3.0);\n\n            // Trace refracted ray\n            int dummyID;\n            float tRefract = rayMarch(p + refracted * 0.01, refracted, dummyID);\n            vec3 refractColor = vec3(0.0);\n            if(tRefract > 0.0)\n            {\n                vec3 pRefract = p + refracted * tRefract;\n                refractColor = vec3(1.0); // Assume white color for refracted objects\n            }\n            else\n            {\n                refractColor = getSkyColor(refracted);\n            }\n\n            // Trace reflected ray\n            float tReflect = rayMarch(p + reflected * 0.01, reflected, dummyID);\n            vec3 reflectColor = vec3(0.0);\n            if(tReflect > 0.0)\n            {\n                vec3 pReflect = p + reflected * tReflect;\n                reflectColor = vec3(1.0); // Assume white color for reflected objects\n            }\n            else\n            {\n                reflectColor = getSkyColor(reflected);\n            }\n\n            col = mix(refractColor, reflectColor, fresnel);\n        }\n        else if(materialID == 2)\n        {\n            // Floor (checkerboard)\n            float checker = mod(floor(p.x) + floor(p.z), 2.0);\n            col = mix(vec3(0.2), vec3(0.8), checker);\n            // Fade floor towards horizon\n            float fade = exp(-0.02 * t);\n            col = mix(getSkyColor(rd), col, fade);\n            col *= (ambient + diff * shadow);\n        }\n    }\n    else\n    {\n        // Sky\n        col = getSkyColor(rd);\n    }\n\n    // Apply gamma correction\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}