{
    "Shader": {
        "info": {
            "date": "1662881933",
            "description": "random distribution of points with density d = 1% * mouse.y\n\ntop left:     Npix*d points,    pos =  Uniform(window)\ntop right:   Npix*d/64 points,  pos = Uniform(cells = 64 subwindows )\nbottom right: Poisson(Npix*d/64)  points per cell  ( as for Worley )\n",
            "flags": 0,
            "hasliked": 0,
            "id": "NtcfDn",
            "likes": 8,
            "name": "0efficient poisson distribution",
            "published": 3,
            "tags": [
                "poisson",
                "points",
                "uniform"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define sqrt(x) sqrt(max(x, 0.))\n#define log(x)  log(clamp(x,1e-9,1.)) // debug crash <><><>\n\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y > 0. ) \n        if ( U.x < 0. )                               // --- top left: brute force draw Npix*d Uniform points \n            for( float k=Z; k < d; k++ )              // at 640x360 , d=1% : 2304 dots\n                D(k,1.);\n        else {\n            I = floor( U *= 8. ); U = fract(U);       // --- top right:draw Npix*d/64 Uniform points per cell \n            for( float k=Z; k < d/64.; k++ )          // at 640x360 , d=1% : 36 dots ( per cell )\n                D(k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n    else   if ( U.x > 0. ) {\n            I = floor( U *= 8. ); U = fract(U);       // --- bottom right: accurate draw Poisson(Npix*d/64) points per cell\n            if (H2(I).x==0.) { O=vec4(1,0,0,1); return; };  // debug crash <><><>\n            d = Poisson(d/64., H2(I)) -.5;  \n         // if( isnan(d) || isinf(d) ) { O=vec4(1,0,0,1); return; }; d = min(d,1000.); // debug crash <><><>\n            for( float k=Z; k < d; k++ )\n                D( k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}