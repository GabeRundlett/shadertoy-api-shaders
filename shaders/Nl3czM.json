{
    "Shader": {
        "info": {
            "date": "1659464505",
            "description": "potato  t",
            "flags": 32,
            "hasliked": 0,
            "id": "Nl3czM",
            "likes": 32,
            "name": "Day 957",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 630
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 956\" by jeyko. https://shadertoy.com/view/7l3yz4\n// 2022-08-02 07:37:58\n\n// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    vec2 oU = U;\n    C *= 0.;\n    \n    float sc = 1./(1.+ max(5.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.1);\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    vec2 id;\n    quantid(nuv,vec2(0.0+ 0.04*hash11(floor(iTime*5. + 2000.)),0.001 + 0.04*hash11(floor(iTime*10.))),id);\n    \n    //float db = sdBox(nuv,vec2(0.5,0.4 -  float(lightMode==0.)*float(fract(iTime*0.125)<0.5)*0.1));\n    float db = sdBox(nuv,-vec2( - 0.3 - 0.1*hash11(floor(iTime*10. + 2000.)) -  float(lightMode)));\n    \n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    vec4 d = Td(uv);\n    \n    \n    \n    if(db > 0.){\n        d.xyz *= 0.;\n    }\n    //vec2 st = 0.4/R.xy + 0.1*sin(iTime)*float(hash11(floor(iTime)) < 1. && lightMode == 0.);\n    vec2 st = (140.4 + 0.*float(hash11(floor(iTime*2.)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    int cmp = 0;\n    float l = \n        Tb(uv + vec2(st.x,0))[cmp]-(Tb(uv - vec2(st.x,0)))[cmp] +\n        Tb(uv + vec2(0,st.y))[cmp]-(Tb(uv - vec2(0,st.y)))[cmp] +\n        Tb(uv + vec2(st.xy))[cmp]-(Tb(uv - vec2(st.xy)))[cmp] +\n        Tb(uv + vec2(st.x,-st.y))[cmp]-(Tb(uv - vec2(st.x,-st.y)))[cmp]\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n\n\n    C += b;\n    \n    \n    //C = mix(C,1.-C,abs(l));\n    \n    // britney\n    \n    C += d;\n    C = clamp(C,0.,1.);\n    \n    C = mix(C,d,d.z);\n    \n    //C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.01;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        if(mod(id.y+iTime,2.) == 0.){\n            if(r.y < 0.){\n                if(r.x < 0.9)\n                    d = abs(d) - 0.0004;\n                \n                C = mix(C,vec4(1),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.1){\n                C = mix(C,vec4(1),1.);\n                \n            }\n               \n        }\n         \n    }\n    \n    {\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.004;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(iTime*1.5 + ra*1.));\n        \n        \n        if((id.y) > 14. && abs(id.x) < 13. && sin(iTime + sin(r.y*3.)*4.)> 0.){\n            C = vec4(1);\n            if(r.y < 0.4){\n                int cidx = int(r.x*4.*4.);\n                vec3 c = palAppleII[cidx];\n                \n                c = rgb2hsv(c);\n                c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n        \n                C.xyz = c;\n                \n            }\n               \n        }\n\n         \n    }    \n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    \n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    float e = float(enva(iTime)>0.4);\n\n    if(e == 0. && fract(iTime*0.3) < 0.5){\n        if(uv.x < 0.)\n            C = mix(C,1.-C,smoothstep(1./min(R.x,R.y),0.,abs(db) - 0.001 - 0.4*e));\n    \n    }else {\n        C = mix(C,1.-C,smoothstep(1./min(R.x,R.y),0.,abs(db) - 0.04 - 0.4*e));\n    \n    }\n    \n    C = max(C,vec4(0.01));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n//float eeeeeeeeeeee;\n\n//#define iTime (iTime + floor(gl_FragCoord.y/200.)*0.4*)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n\n    //ro = vec3(,4,0) + 0.004;\n    lookAt += 0.1*sin(t*vec3(1,0.8,0.9));\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,0,-2);\n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    ro.yz *= rot(sin(t)*0.4);\n    \n    ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    \n    ro.xz *= rot((t + sin(t*1.4))*0.6);\n    ro.xz *= rot(m.x/r.x);\n    ro.yz *= rot(m.y/r.x);\n    return ro;\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 8.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5*vec4(1,1.5,1,1);\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n#define quant(v,a) floor(v/a)*a\n#define quantid(v,a,id)  id = floor(v/a);v = floor(v/a)*a; \n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// raymarch\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat map(vec3 p){\n    vec3 op = p;\n    p.y += (iTime + sin(iTime))*0.4;\n    \n    if(lightMode == 0.)\n        p.xz *= rot(p.z + sin(iTime + p.z)*4.);\n    else\n        p.xz *= rot(p.y + sin(iTime + p.y)*3.);\n    \n    \n    float d = 10e5;\n    \n    float its = 2.;\n    for(float i = 0.; i < its; i++){\n        vec3 lp = p - vec3(cos(i/its*pi*2.),0,sin(i/its*pi*2.))*sin(iTime+i + sin(iTime + i))*1.;\n        \n        \n        if(lightMode == 1.)\n            d = min(d,dot(lp.xz,lp.xz));\n        else\n            d = min(d,length(lp.xz));\n    }\n    \n    return d + sin(p.y + iTime)*0.3*noise(p*2.*vec3(1.,0.1,4) + vec3(iTime + sin(iTime),0,0))*0.4 + smoothstep(2.,3.,abs(op.y));\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n    //uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    //vec2 t = 1./R.xy;\n    //vec4 l = vec4(\n    //    luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n    //    luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    //);\n    //l = abs(l);\n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    \n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    for(float i = 0.; i < 140.; i++){\n        float d = map(p);\n        \n        if(d < 0.01){\n            hit = true;\n            break;\n        } else if(t > 4.5){\n            break;\n        }\n        d *= 0.2;\n        \n        p = ro + rd * (t += d);\n    }\n    if(hit == false){\n        t = 1000.;\n    } \n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    \n    \n    if(hit){\n        if(fract(iTime*0.2) < 0.5){\n            C.x = sin(p.x*20.);\n        }else{\n            float md = 0.7;\n            if(lightMode == 1.)\n                C.x = floor(fract(p.y*20.)/md)*md;\n            else\n                C.x = sin(length(abs(p)/dot(p,p))*200.);\n        }\n    }\n    else \n        C.x = 0.;\n    //C.z = 0.;\n    \n    C.y = l;\n    C.z = t;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// dither\n\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(iTime*0.1) < 0.5)))).x;\n    \n    \n    float quant = 1.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    s = vec4(s.x);\n    \n    \n    \n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        vec3 palCHsv = rgb2hsv(palC);\n        palCHsv.b += sin(iTime*(2. + float(fract(iTime*0.2)>0.8)*20.) + float(i))*3.;\n        float localSimilarity = dot(palCHsv.b, Chsv.b);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    \n    C = vec4(hit.xyzx);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ui\n\n \nvec4 n14(float f){ return hash41(f); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char += floor(hash11(idx)*200.);\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),5.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 3. - hash11(idx + 20.)*2.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 1. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    \n    float z = Ta(U/R.xy).z;\n    z = z*=0.25;\n    \n    uv = (U - 0.5*R.xy)/min(R.y,R.x);\n    \n    vec3 ro = getRo(iTime, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n    float rep = fract(iTime*0.15) < 0.25 ? 0.04 : 1./min(R.y,R.x);\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,iTime);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    C -= C;\n    {\n        \n        vec2 lastDotPos = vec2(0);\n        float lastDD = 10e5;\n        for(float i = 0.; i < 210. - lightMode*200. ; i++){\n            vec3 dotPos = max(hash31(i + 20.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            \n            float r = hash11(i);\n            \n            float d;\n            \n            if(r < 0.8){\n            lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n                d = max(\n                    min(abs(lp.x),abs(lp.y)),\n                    sdBox(lp,vec2(0.02,0.01))\n                ) - 0.001 - 0.00*pow(abs(sin(i + iTime)),5.);\n                d = max(d,-sdBox(lp,vec2(0.01)));\n            } else {\n                d = sdBox(lp,vec2(0.001,0.04));\n            }\n            if(projPos.z < z)\n                C += smoothstep( 1./R.x, 0. , d);\n        }        \n        for(float i = 0.; i < 30.; i++){\n            vec3 dotPos = max(hash31(i + 120.),0.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*4.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            \n            {\n                lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                 if(i<30.){\n                    float dd = length(lp) - 0.001 - 0.01*sin(i + iTime + sin(iTime + i));\n\n                    if(r.y > 0.5)\n                        d = abs(dd) - 0.001 ;\n                    else\n                        d = (dd) - 0.001 ;\n\n                    //if(lightMode == 0.){\n\n                       float l = sdSegment(uv,projPos.xy,lastDotPos.xy)-0.004*(sin(i + iTime*2.));\n                       if(mod(idd,2.) == 0.)\n                           l = 10e5;\n                       d = min(d,max(max(l,-dd),-lastDD));\n                    //}\n\n                    lastDD = dd;\n\n                } else {\n                    // epic lines\n                    //if(lightMode == 0.)\n                        continue;\n                    d = length(lp.y) - 0.004 ;\n                }\n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            \n            if(projPos.z < z)\n                C += smoothstep( 1./R.x, 0. , d);\n        }\n        \n        // lines-text\n        for(float i = 0.; i < 340.\n            - 100.*float(fract(iTime*2.5) < 0.5) \n            - 100.*float(fract(iTime*.25) > 0.5) \n            + float(fract(iTime*0.1) < 0.5)*300.;\n            i++){\n            \n            vec3 dotPos = max(hash31(i + 420.),0.);\n            dotPos = dotPos*2. - 1.;\n            dotPos *= 0.6*float(fract(iTime*0.1) > 0.1);\n            vec3 projPos = lookAtMat*dotPos;\n            projPos.xy /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            \n            float d;\n            \n            vec2 r = hash21(i);\n            \n            float td;\n            {\n                //lp *= rot(iTime + i + sin(iTime*2. + i));\n            \n                float sz = 0.01 + 0.01*sin(i + iTime + sin(iTime + i));\n                float dd = length(lp) - sz;\n                \n                if(r.y > 0.5)\n                    d = abs(dd) - 0.001 ;\n                else\n                    d = (dd) - 0.001 ;\n\n\n                vec2 uiPos = (0.5+hash21(i + 20.)*0.5)*2. - 1.;\n                \n                //uiPos *= 0.5;\n                \n                uiPos = mix(projPos.xy + uiPos*0.5 ,projPos.xy,0.5);\n                \n                float imp = smoothstep(0.4,0.5,abs(projPos.y) + abs(projPos.x)*0.5);\n                //imp += max(sin(i + iTime + sin(i + iTime)),0.);\n                \n                imp = mix(imp,100.,max(-sz*200.,0.));\n                //if(sz < 0.)\n                //    imp *= 1000.;\n                \n                \n                //imp += 1.;\n                float l = sdSegment(uv,projPos.xy,uiPos.xy)-0.001 + imp;\n                \n                \n                {\n                    float sc = 4. + sin(i)*1.;\n                    \n                    sc += 20.*imp;\n                    \n                    if(imp > 0.9)\n                        sc *= 1000.;\n                    vec2 tp = uv - uiPos;\n                    \n                    \n                    tp *= sc;\n                    //uv *= 2.;\n                    \n                    td = text(tp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.5, true, i);\n                    \n                    //td = abs(td);\n                    \n                    \n                \n                }\n                \n                \n                //if(mod(idd,2.) == 0.)\n                //    l = 10e5;\n                d = min(d,max(l,-dd));\n\n\n                lastDD = dd;\n\n               \n            }\n            \n            lastDotPos = projPos.xy;\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n                       \n            if(projPos.z < z && mod(idd,4.) != 0.){\n                C += smoothstep( 1./R.x, 0. , d);\n            \n                C = mix(C,vec4(1),smoothstep(0.5*0.04*(1.-step(0.01,td)),0.,td - 0. * float(i<9. && sc > 5.)));\n            }\n        }\n        // epic text\n        /*\n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n \n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            if(projPos.z < z)\n                C = mix(C,vec4(1),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            \n        }*/\n\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n\n   U = oU;\n    sc = 1. + 15.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(iTime) + 200.)*1.8;\n   u *= 0.9 - hash11(floor(iTime))*0.1;\n   u*=0.51 + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 7.;\n   \n\n    //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && fract(iTime) < 0.2 && sin(iTime) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       float dith = texture(iChannel2,oU.xy/vec2(textureSize(iChannel1,0).xy*(4 + 0*int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n        float quant = 3.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n        \n        britney.xyz = rgb2hsv(britney.xyz);\n        britney.xyz = hsv2rgbSmooth(britney.xyz*vec3(110.9,0.5,0.5) + vec3(1. + iTime,0.2,0.)).xyz;\n        C = britney;\n       C -= 1.- britney;\n       C.w = 1.;\n   } else {\n       C.w = 0.;\n   }\n   \n   \n    \n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}