{
    "Shader": {
        "info": {
            "date": "1669102567",
            "description": "Reproduction of Charlie Deck (@BigBlueBoo)'s post here:\nhttps://bigblueboo.tumblr.com/post/77072352738\n\nI think the optical illusion effect is really strong in this very clever animation.\n*mouse x to zoom*",
            "flags": 0,
            "hasliked": 0,
            "id": "csfSRS",
            "likes": 17,
            "name": "Bending Squares (432 chars)",
            "published": 3,
            "tags": [
                "illusion",
                "codegolf",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Reproduction of Charlie Deck (@BigBlueBoo)'s post here:\n//     https://bigblueboo.tumblr.com/post/77072352738\n\n// I think the optical illusion effect is really strong in this very clever animation.\n// I couldn't find one on Shadertoy so hopefully Mr. Deck approves.  I tried to golf\n// this, as usual, but futher contributions are welcome.\n\n// I recommend experimenting with the scale (currently the 9. * in the lastest version\n// on the first line inside the loop). A good choice might be: .1*iMouse.x. It seems like\n// the scale of the image has a huge effect on the intensity of the optical illusion.\n// Especially when going full screen it helps to increase the scale value above 9.\n\n// Adding mouse control to FabriceNeyret2's version: 432 chars\n//*\n#define P .13 - abs( .6* smoothstep(1.25, .75, abs( mod(t,4.) - vec2(2,1) -.25 ) )  + .2  - fract(u) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = (3.*iMouse.x/R.x + 1.) * 9. * ( U - R/2. ) / R.y,\n         v = abs(u),\n         V = mod( u += .5 , 2.) - 1., \n         B = min(v,v.y) - .5,\n         t = iTime * .2 \n           + vec2( u.y > 1. && u.x > 1. || u.y < 0. && u.x < 0. )\n           + ( B.x<0. ?   u.y > 1. ? 1. \n                        : u.x > 1. ? 2. \n                        : u.y < 0. ? 3. \n                      : 0. : 0.),\n         a = P; \n    t += B.x<0. ? 1. : 2.;\n    t = V * V.y * max( min(a,a.y), min(P,P.y) );\n    O = vec4( max(v.x,v.y) > .5 ? smoothstep(-.8,.8, t/fwidth(t) ).x : 0. );\n}\n/**/\n\n// From FabriceNeyret2, with direct AA: 416 chars!\n/*\n#define P -.13 + abs( .6* smoothstep(1.25, .75, abs( mod(t,4.) - vec2(2,1) -.25 ) )  + .2  - fract(u) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 t,a,R = iResolution.xy,\n         u = 9. * ( U - R/2. ) / R.y,\n         v = abs(u),\n         V = mod( u += .5 , 2.) - 1.; \n\n    bool B = min(v.x,v.y) < .5;\n    t = iTime * .4 \n        + vec2( u.y > 1. && u.x > 1. || u.y < 0. && u.x < 0. )\n        + ( B ?   u.y > 1. ? 1. \n                : u.x > 1. ? 2. \n                : u.y < 0. ? 3. \n              : 0. : 0.);\n    a = P; \n    t += B ? 1. : 2.;\n    t = V * V.y * min( max(a.x,a.y), max(P.x,P.y) );\n    O = vec4(max(v.x,v.y) > .5 ? smoothstep(.8,-.8, t/fwidth(t) ).x : 0.);\n}\n/**/\n\n// From FabriceNeyret2, with motion blur and soft focus: 469 chars!\n/*\n#define P  ( g = .6* smoothstep(0., .5, mod(t,4.) - vec4(0,1,2,3) ),    \\\n             abs( g.yx - g.wz + .2  - fract(u) )  - .13                 \\\n           )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 u,v,V,a,R = iResolution.xy;\n    vec4 t,g;\n    O *= 0.;\n    for(int i = 0; i < 40; ++i)\n    {\n        v = abs( u = 9. * ( U -R/2. + vec2(i+i & 2, i & 2) -1. ) / R.y );\n        V = mod( u += .5 , 2.) - 1.; \n        bool  B = min(v.x,v.y) < .5 ;\n        t = iTime * .4 + vec4(i/4) /250.\n            + vec4( u.y > 1. && u.x > 1. || u.y < 0. && u.x < 0. )\n            + ( B ?   u.y > 1. ? 1. \n                    : u.x > 1. ? 2. \n                    : u.y < 0. ? 3. \n                  : 0. : 0.);\n        a = P; \n        t += B ? 1. : 2.;\n        max(v.x,v.y) > .5 &&  V.x * V.y * min( max(a.x,a.y), max(P.x,P.y) ) < 0.\n          ? O+= .025 : O;\n    }\n}\n/**/\n\n// Couldn't resist adding aa and motion blur, back up to 583 chars :D\n/*\n#define p(t) (g = smoothstep(f, f + .125, vec4(fract(t))), vec2(g.y - g.w, g.x - g.z) * .6 + .2)\n#define b(v) abs((v).x) < .13 && abs((v).y) < .13\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec4 R = iResolution.xyyy, f = vec4(0, 1, 2, 3) * .25, g, a;\n    O *= 0.;\n    for(int i = 0; i < 40; ++i)\n    {\n        vec2 u = 4.5 * (U + vec2((i & 1) * 2 - 1, (i & 2) - 1) - .5 * R.xy) / R.y + .25,\n            v = abs(u - .25) - .25;\n        float t = iTime * .1 + float(i / 4) * .001 + (u.y > .5 && u.x > .5 || u.y < 0. && u.x < 0. ? .25 : 0.) +\n            (v.x < .0 || v.y < .0 ? u.y > .5 ? .25 : u.x > .5 ? .5 : u.y < .0 ? .75 : 0. : 0.);\n        u = fract(u);\n        a = vec4((u.x < .5) ^^ (u.y < .5));\n        u = fract(u * 2.);\n\n        if (b(u - p(t)) || b(u - p(v.x < .0 || v.y < .0 ? .25 + t : .5 + t))) a = 1.-a;\n        a = v.x < .0 && v.y < .0 ? vec4(0) : a; // clear center square\n        O += a * .025;\n    }\n}\n/**/\n\n// My golfing attempt, before aa and motion blur: 498 chars\n/*\n#define p(t) (g = smoothstep(f, f + .125, vec4(fract(t))), vec2(g.y - g.w, g.x - g.z) * .6 + .2)\n#define b(v) abs((v).x) < .13 && abs((v).y) < .13\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec4 R = iResolution.xyyy, f = vec4(0, 1, 2, 3) * .25, g;\n    u = 4.5 * (u - .5 * R.xy) / R.y + .25;\n    vec2 v = abs(u - .25) - .25;\n    float t = iTime * .1 + (u.y > .5 && u.x > .5 || u.y < 0. && u.x < 0. ? .25 : 0.) +\n        (v.x < .0 || v.y < .0 ? u.y > .5 ? .25 : u.x > .5 ? .5 : u.y < .0 ? .75 : 0. : 0.);\n    u = fract(u);\n    O = vec4((u.x < .5) ^^ (u.y < .5));\n    u = fract(u * 2.);\n\n    if (b(u - p(t)) || b(u - p(v.x < .0 || v.y < .0 ? .25 + t : .5 + t))) O = 1.-O;\n    O = v.x < .0 && v.y < .0 ? vec4(0) : O; // clear center square\n}\n/**/\n\n// Original: 775 chars\n/*\nvec2 path(float t)\n{\n    vec4 v = smoothstep(vec4(0, 1, 2, 3) * .25, vec4(0, 1, 2, 3) * .25 + .125, vec4(fract(t)));\n    return (vec2(v.y - v.w, v.x - v.z) + .5) * .6 - .1;\n}\n\nvec4 aaImage( vec2 u, float t )\n{\n    u = 4.5*((u - .5*iResolution.xy) / iResolution.y + .055);\n    float dt = .5;\n    if (u.y > 0. && u.y < .5 || u.x > 0. && u.x < .5)\n    {\n        if (u.y > .5) t += .25;\n        else if (u.y < .0) t += .75;\n        else if (u.x > .5) t += .5;\n        else if (u.x > 0.) return vec4(0);\n        dt = .25;\n    }\n    if (u.y > .5 && u.x > .5 || u.y < 0. && u.x < 0.) t += .25;\n    u = fract(u);\n    vec4 O = vec4((u.x < .5) ^^ (u.y < .5));\n    u = fract(u * 2.);\n    \n    vec2 p = path(t);\n    if (abs(u.x - p.x) < .13 && abs(u.y - p.y) < .13) O = 1.-O;\n    p = path(t + dt);\n    if (abs(u.x - p.x) < .13 && abs(u.y - p.y) < .13) O = 1.-O;\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 d = vec2(1, -1);\n    O *= 0.;\n    for (float i = 0.; i < 10.; ++i)\n    {\n        float t = iTime * .1 + i * .001;\n\n        O += (aaImage(u + d.xx, t) + aaImage(u + d.xy, t) + aaImage(u + d.yx, t) + aaImage(u + d.yy, t)) * .025;\n    }\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}