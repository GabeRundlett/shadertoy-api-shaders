{
    "Shader": {
        "info": {
            "date": "1694025036",
            "description": "Modeling a character using ray marching\nUse the mouse to move the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "DlBfDW",
            "likes": 16,
            "name": "AiAi (Super Monkey Ball)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "ball",
                "monkey",
                "gaming"
            ],
            "usePreview": 0,
            "username": "pikachuchujelly",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "#define HUGE 1000000.0\n#define PI 3.14159\n\nvec3 ballPos;\nvec3 lightDir = normalize(vec3(1,2,-2));\n\n// computes the ray direction of a screen pixel\nvec3 perspectiveRay(vec2 pixel)\n{\n    float x = -1.0 + 2.0*(pixel.x / iResolution.x);\n    float y = 1.0;\n    float z = -1.0 + 2.0*(pixel.y / iResolution.y);\n    x *= iResolution.x / iResolution.y;\n    return normalize(vec3(x,y,z));\n}\n\nvec3 rotateYaw(vec3 v, float angle)\n{\n    return vec3(\n        v.x*cos(angle) - v.y*sin(angle),\n        v.y*cos(angle) + v.x*sin(angle),\n        v.z);\n}\n\nvec3 rotatePitch(vec3 v, float angle)\n{\n    return vec3(\n        v.x,\n        v.y*cos(angle) - v.z*sin(angle),\n        v.z*cos(angle) + v.y*sin(angle));\n}\n\nvec3 rotatePitchAbout(vec3 v, vec3 about, float angle)\n{\n    return rotatePitch(v - about, angle) + about;\n}\n\nvec3 rotateYawAbout(vec3 v, vec3 about, float angle)\n{\n    return rotateYaw(v - about, angle) + about;\n}\n\nfloat calcLight(vec3 normal, vec3 rd, float shininess)\n{\n    float ambient  = 0.3;\n    float diffuse  = max(dot(-lightDir,normal), 0.0);\n    float specular = max(dot(-lightDir,reflect(rd, normal)), 0.0);\n    specular *= specular*specular*specular*specular*specular*specular*specular*specular;\n    return ambient + diffuse + specular * shininess;\n}\n\nfloat raycastFloor(vec3 ro, vec3 rd, out vec2 hit)\n{\n    if (rd.z >= 0.0)\n        return HUGE;\n    float t = -ro.z / rd.z;\n    if (t < 0.0)\n        return HUGE;\n    hit = vec2(ro.x+rd.x*t, ro.y+rd.y*t);\n    return t;\n}\n\nfloat raycastSphere(vec3 ro, vec3 rd, vec3 center, float radius, out vec3 normal)\n{\n    vec3 sc = center;  // sphere center\n    float sr = radius;  // sphere radius\n\n    // Imagine a plane that is perpendicular to the ray and intersects the sphere's center.\n    // ts is the distance along the ray to that plane.\n    float ts = dot(sc-ro, rd);\n    if (ts < 0.0)\n        return HUGE;\n    // distance squared between point at ts and the sphere center\n    float r2 = (dot(sc-ro,sc-ro) - ts*ts);\n    if (r2 > sr*sr)\n        return HUGE;\n    float t = ts - sqrt(sr*sr - r2);  // distance along ray to where it intersects the sphere\n    vec3 hit = ro + rd * t;\n    normal = normalize(hit-sc);\n    return t;\n}\n\n// like raycastSphere, but intersects with the far surface of the sphere\nfloat raycastSphereInner(vec3 ro, vec3 rd, vec3 center, float radius, out vec3 normal)\n{\n    vec3 sc = center;  // sphere center\n    float sr = radius;  // sphere radius\n\n    // Imagine a plane that is perpendicular to the ray and intersects the sphere's center.\n    // ts is the distance along the ray to that plane.\n    float ts = dot(sc-ro, rd);\n    if (ts < 0.0)\n        return HUGE;\n    // distance squared between point at ts and the sphere center\n    float r2 = (dot(sc-ro,sc-ro) - ts*ts);\n    if (r2 > sr*sr)\n        return HUGE;\n    float t = ts + sqrt(sr*sr - r2);  // distance along ray to where it intersects the sphere\n    vec3 hit = ro + rd * t;\n    normal = normalize(sc-hit);\n    return t;\n}\n\n// Returns true or false to select the pattern for the floor position\nbool checker(vec2 floorPos)\n{\n    return mod(floor(floorPos.x) + floor(floorPos.y), 2.0) < 1.0;\n}\n\nfloat sphereSdf(vec3 pos, vec3 sphereCenter, float radius)\n{\n    return distance(pos, sphereCenter) - radius;\n}\n\n// Credit to Inigo Quilez for the SDF functions (https://iquilezles.org/articles/distfunctions/)\n\n// slow...\nfloat ellipsoidSdf(vec3 pos, vec3 center, vec3 radius)\n{\n    vec3 p = pos - center;\n    float k0 = length(p/radius);\n    float k1 = length(p/(radius*radius));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat cylinderSdf(vec3 pos, vec3 center, float height, float radius)\n{\n    vec3 p = pos - center;\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(radius,height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat roundConeSdf(vec3 pos, vec3 center, float r1, float r2, float h)\n{\n    vec3 p = pos - center;\n    // sampling independent computations (only depend on shape)\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n\n    // sampling dependant computations\n    vec2 q = vec2( length(p.xy), p.z );\n    float k = dot(q,vec2(-b,a));\n    if( k<0.0 ) return length(q) - r1;\n    if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat capsuleSdf(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 p = pos;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n/*\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n*/\n\n// The built-in 2-argument atan function is incredibly slow (at least on my Intel HD 3000).\n// The single argument version is much faster.\nfloat atan_fast(float a, float b)\n{\n    float result = atan(a / b);\n    if (b < 0.0)\n        result += PI;\n    return result;\n}\n\n// samples a 2D x,y position and returns a value between 0 and 1\nfloat spiral(vec2 pos)\n{\n\tfloat radius = length(pos);\n\tfloat angle = /*atan*/atan_fast(pos.y, pos.x) + PI*0.75;\n    float x = radius * 4.0 - angle;\n    // make it like a wave with sharp peaks\n    x = fract(x / (2.0*PI));\n    return 1.0 + 4.0 * x * (x - 1.0);\n}\n\nfloat animLimbAngle(void)\n{\n    return sin(iTime * 3.0 * PI);\n}\n\nfloat animEars(void)\n{\n    float t = fract(iTime / 3.0) * 3.0;\n    t *= 50.0;\n    if (t >= 4.0 * PI)\n        t = 0.0;\n    return sin(t);\n}\n\nfloat animBlink(void)\n{\n    const float blinkSpeed = 0.1;\n    const float frequency = 3.5;\n    float t = fract(iTime / frequency) * frequency;\n\n    return 2.0 * max((blinkSpeed-abs(t-blinkSpeed))/blinkSpeed, 0.0);\n}\n/*\nvec3 mirrored(vec3 v)\n{\n    return vec3(abs(v.x),v.y,v.z);\n}\n*/\n/*\nfloat cylinderSdf(vec3 pos, vec3 center, float height, float radius)\n{\n    vec3 p = pos - center;\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(radius,height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n*/\n\nfloat xzdiscSdf(vec3 pos, vec3 center, float radius, float s)\n{\n    radius -= s;\n    vec3 p = pos - center;\n    //float height = 0.5;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(radius,0.0);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - s;\n}\n\nfloat globalSdf(vec3 pos, out vec3 color)\n{\n    pos.y -= ballPos.y;\n    pos.z -= 2.0;\n\n    vec3 bodyColor  = vec3(0.3, 0.2, 0.1);\n    vec3 skinColor  = vec3(0.8, 0.7, 0.6);\n    vec3 shirtColor = vec3(0.8, 0.4, 0.2);\n    vec3 eyeColor   = vec3(0.1, 0.1, 0.1);\n    vec3 white      = vec3(1.0, 1.0, 1.0);\n\n    color = bodyColor;\n\n    vec3 ear      = vec3(5.0,  0.0, 14.0);\n    vec3 shoulder = vec3(1.5,  0.0, 10.0);\n    vec3 elbow    = vec3(3.5,  0.0,  8.0);\n    vec3 hand     = vec3(4.5, -1.0,  6.0);\n    vec3 hip      = vec3(2.0,  0.0,  4.0);\n    vec3 knee     = vec3(2.1, -0.5,  2.0);\n    vec3 ankle    = vec3(2.2,  0.0,  0.0);\n    vec3 toes     = vec3(2.2, -2.0, -0.5);\n\n    // Animate limbs\n    float angle = animLimbAngle();\n    pos.x += angle * 0.25;  // make body shake a little bit\n    if (pos.x < 0.0)\n        angle = -angle;  // cheap trick to make the two sides animate opposite from each other\n    elbow = rotatePitchAbout(elbow, shoulder, angle);\n    hand = rotatePitchAbout(hand, shoulder, angle);\n    knee = rotatePitchAbout(knee, hip, -angle);\n    ankle = rotatePitchAbout(ankle, hip, -angle);\n    toes = rotatePitchAbout(toes, hip, -angle);\n    // Animate ears\n    ear = rotateYawAbout(ear, vec3(2,0,14), animEars() * 0.15);\n    // Animate blinking\n    float blink = animBlink();\n\n    vec3 posMirrored = vec3(abs(pos.x), pos.y, pos.z);\n\n    float d = HUGE;\n\n    // head\n    float dHead = cylinderSdf(pos, vec3(0, 0, 15), 1.0, 0.8) - 2.0;\n    dHead = opSmoothUnion(dHead, ellipsoidSdf(pos, vec3(0, -1, 12.5), vec3(2.5, 2.0, 1.0)), 2.0);\n    // hair tuft\n    float dTuft = opSmoothUnion(\n        sphereSdf(pos, vec3(0, -1.5, 18.2), 0.5),\n        capsuleSdf(pos, vec3(0, 0, 18.5), vec3(0, 1, 19), 0.0),\n        2.5);\n    dHead = min(dHead, dTuft);\n    //dHead = HUGE;\n    d = min(d, dHead);\n    // ears\n    float dEar = xzdiscSdf(posMirrored, ear, 2.5, 0.5);\n    if (dEar < 0.1 && posMirrored.y < ear.y)\n    {\n        // Cut out the swirl in the iear\n        // Doing this breaks the SDF a bit, but it approximates the look very well.\n        dEar += 0.5 * spiral(ear.xz - posMirrored.xz);\n    }\n    //dEar = HUGE;\n    d = min(d, dEar);\n    // body\n    float dBody = roundConeSdf(pos, vec3(0,0,6.5), 3.2, 2.2, 3.0);\n    //dBody = HUGE;\n    d = min(d, dBody);\n    // arms\n    float dArm = min(\n        capsuleSdf(posMirrored, shoulder, elbow, 0.5),\n        capsuleSdf(posMirrored, elbow, hand, 0.5));\n    //dArm = HUGE;\n    d = min(d, dArm);\n    // legs\n    float dLeg = min(\n        capsuleSdf(posMirrored, hip, knee, 0.6),\n        capsuleSdf(posMirrored, knee, ankle, 0.6));\n    //dLeg = HUGE;\n    d = min(d, dLeg);\n    // hands\n    float dHand = sphereSdf(posMirrored, hand, 1.0);\n    //dHand = HUGE;\n    d = min(d, dHand);\n    // feet\n    float dFoot = sphereSdf(posMirrored, ankle, 1.0);\n    dFoot = opSmoothUnion(dFoot, capsuleSdf(posMirrored, toes - vec3(0.5,0,0), toes + vec3(0.5,0,0), 0.5), 2.0);\n    //dFoot = HUGE;\n    d = min(d, dFoot);\n\n    // colors\n    if (dHead <= d && pos.y < -1.0)\n    {\n        if (pos.y < -1.0)\n        {\n            vec3 eye = vec3(1.2 * sign(pos.x), -2.0, 14.7);\n            vec3 dist = pos - eye;\n            dist.z *= 0.6;\n            if (pos.z <= eye.z + 1.0 - blink\n             && dist.x*dist.x + dist.z*dist.z < 0.25 && abs(dist.z)*2.0 > -dist.x)\n                color = eyeColor;\n            // mouth\n            else if (pos.z < 13.3 && abs(pos.x*pos.x*pos.x*pos.x*0.5*0.5*0.5*0.5 - pos.x*pos.x*0.5*0.5 - pos.z + 13.0) < 0.1)\n                color = vec3(0.2, 0.2, 0.2);\n            else if (pos.z < 15.0 || distance(pos, eye) < 2.2)\n                color = skinColor;\n        }\n    }\n    if (dEar <= d)\n    {\n        if (pos.y < ear.y + 0.1)\n            color = skinColor;\n    }\n    if (dBody <= d)\n    {\n        if (pos.z > 6.5)\n        {\n            color = shirtColor;\n            // letter A\n            vec2 letter = posMirrored.xz;\n            letter.y = (letter.y - 8.0) / 2.0;\n            if (pos.y < 0.0\n             && letter.y >= 0.0 && letter.y <= 1.0\n             && letter.x < 1.2 - letter.y)\n            {\n                if ((letter.x > 0.6 - letter.y)\n                 || (letter.y >= 0.2 && letter.y <= 0.4))\n                color = white;\n            }\n        }\n        // random trick I found by accident to color the butt\n        else if (pos.y > 0.0 && dEar + 0.3 < dHead)\n            color = skinColor;\n    }\n    if (dArm <= d)\n    {\n        if (distance(posMirrored, shoulder) < 2.5)\n            color = shirtColor;\n    }\n    if (dHand <= d || dFoot <= d)\n        color = skinColor;\n    return d;\n}\n\nvec3 calcNormal(vec3 pos, float d)\n{\n    float epsilon = 0.001;\n    vec3 dummy;\n    vec3 v = vec3(\n        globalSdf(pos - vec3(epsilon, 0.0, 0.0), dummy),\n        globalSdf(pos - vec3(0.0, epsilon, 0.0), dummy),\n        globalSdf(pos - vec3(0.0, 0.0, epsilon), dummy));\n    return normalize(d - v);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // ball motion\n    ballPos = vec3(0.0, -40.0*iTime, 12.0);\n    float ballRadius = 40.0/PI;\n\n    // camera motion\n    float yaw = -iTime * 0.25;\n    float pitch = -0.6;\n    if (iMouse.z > 0.0)\n    {\n        yaw = 3.0 * (iMouse.x - abs(iMouse.z)) / iResolution.x;\n        pitch = 3.0 * (iMouse.y - abs(iMouse.w)) / iResolution.y;\n        pitch = clamp(pitch, -3.14159/2.0, 0.0);\n    }\n\n    // ray origin\n    vec3 ro = vec3(0,-20,0);\n    ro = rotatePitch(ro, pitch);\n    ro = rotateYaw(ro, yaw);\n    ro.y += ballPos.y;\n    ro.z += ballPos.z;\n    // ray direction\n    vec3 rd = perspectiveRay(fragCoord);\n    rd = rotatePitch(rd, pitch);\n    rd = rotateYaw(rd, yaw);\n    rd = normalize(rd);\n\n    vec3 normal;\n\n    vec3 sky = mix(vec3(1,1,1),rd.z > 0.0 ? vec3(0,0,1) /*sky*/ : vec3(0,0.5,0) /*land*/,abs(rd.z));\n    vec3 color = sky;\n    float tBall;\n\n    // draw floor\n    vec2 floorPos;\n    float tFloor;\n    if ((tFloor = raycastFloor(ro, rd, floorPos)) < HUGE && abs(floorPos.x) < 60.0)\n    {\n        vec2 uv = fract(floorPos / 10.0);\n        color = checker(floorPos / 10.0) ? vec3(0.2, 0.4, 0.2) : vec3(0.3, 0.6, 0.3);\n        color *= 0.6 + texture(iChannel0, uv).r * 0.4;\n\n        float light;\n        if (raycastSphere(vec3(floorPos, 0.0), -lightDir, ballPos, ballRadius, normal) < HUGE)\n            light = 0.5;  // ball shadow\n        else\n            light = calcLight(vec3(0, 0, 1), rd, 0.3);\n\n        color *= light;\n\n        // fade out with sky to avoid aliasing artifacts\n        float fadeStart = 200.0;\n        float fadeEnd = 400.0;\n        color = mix(color, sky, clamp((tFloor-fadeStart)/(fadeEnd-fadeStart),0.0,1.0));\n\n    }\n    // draw ball inner surface\n    if ((tBall = raycastSphereInner(ro, rd, ballPos, ballRadius-0.3, normal)) < HUGE)\n    {\n        float light = calcLight(normal, rd, 0.8);\n        normal = rotatePitch(normal, ballPos.y/ballRadius);\n        vec3 ballColor = normal.z > 0.0 ? vec3(1.0,0.2,0.2) : vec3(0.8);\n        color = mix(color, ballColor * light, 0.5);\n    }\n\n    // Ray-march the monkey. Since the monkey is always inside the ball, we only need to do this if the ray actually touches the ball.\n    if (tBall < HUGE)\n    {\n        float t = 0.0;\n        for (int i = 0; i < 30; i++)\n        {\n            vec3 pos = ro + rd * t;\n            vec3 objColor;\n            float d = globalSdf(pos, objColor);\n            if (d < 0.1)\n            {\n                if (tFloor < t)\n                    break;\n                color = objColor;\n                vec3 normal = calcNormal(pos, d);\n                color *= calcLight(normal, rd, 0.5);\n                break;\n            }\n            t += d;\n            if (t > 30.0)\n                break;\n        }\n    }\n\n    // draw ball outer surface\n    if (raycastSphere(ro, rd, ballPos, ballRadius, normal) < HUGE)\n    {\n        float light = calcLight(normal, rd, 0.8);\n        normal = rotatePitch(normal, ballPos.y/ballRadius);\n        vec3 ballColor = normal.z < 0.0 ? vec3(1.0,0.2,0.2) : vec3(0.8);\n        color = mix(color, ballColor * light, 0.5);\n    }\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}