{
    "Shader": {
        "info": {
            "date": "1519575121",
            "description": "Hyperbolic honeycombs using the Wythoff construction.\n\nSee code for explanation, controls etc.\n\nWork in progress & much room for optimization & other improvement.",
            "flags": 48,
            "hasliked": 0,
            "id": "XddyR2",
            "likes": 37,
            "name": "Hyperbolic Honeycombs",
            "published": 3,
            "tags": [
                "raymarch",
                "honeycomb",
                "inversion",
                "hyperbolic",
                "wythoff"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 2273
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018.\n//\n// H3 honeycombs using the Wythoff construction.\n//\n// Construct a hyperbolic tetrahedron, one vertex at origin\n// three planar faces, one spherical face (opposite the origin).\n// Honeycomb is constructed by placing an edge between a\n// vertex of the tetrahedron and its reflection in the\n// opposite face. It's also possible to see all 6 edges\n// of the tetrahedron.\n//\n// The honeycomb is constructed in the Poincar√© ball model,\n// but can also be displayed using the upper half space model.\n//\n// In the ball model, moving the viewpoint to the centre of the ball\n// should give a perspectivally correct view of the honeycomb.\n//\n// Currently just one animation, a periodic hyperbolic translation.\n//\n// There's no support at the moment for drawing faces or having more\n// than one active mirror.\n//\n// Mouse drag & Up/Down Arrow control view\n//\n// t: change tetrahedron\n// e: change edge displayed\n// v: change centred vertex\n// r: show fundamental region\n// h: show half-space\n// s: slice ball at z = 0\n// c: centre ball view\n// d: rotation\n// a: animation\n// f: use more folding steps\n// l: change line width\n// x: show t,e,v parameters graphically\n//\n////////////////////////////////////////////////////////////////////////////////\n\n//#define DEBUG\n#define VERSION __VERSION__\n\nbool slice = false;\nbool halfspace = false;\nbool animate = false;\nbool centre = false;\nbool gradient = true;\nbool region = false;\nbool dorotate = true;\nbool showparams = false;\n\nbool interior = true;\n\n// Default params show dodecahedral (5,3,4) honeycomb\nint pqr = 1;       // Index of tetrahedron to use\nint edge = 3;      // The edge to draw (in normal style)\nint centrevertex = 1;\nfloat clipsphere = 1.0;  // Radius of clipping sphere, 0.0 is no clip\nint ilwidth = 2; // index of line width\nfloat lwidth0; // actual line width\n\n#if !defined DEBUG\n#define assert(x) 0\n#else\n// A point with an assertion failure is red (so here\n// most failures are global so the entire screen is\n// red). Could use colours to indicate which assertion\n// has failed.\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n#endif\n\n// The angles for the Goursat Tetrahedron\n//\n//                 P Q R\n// These are for: o-o-o-o\n\nconst int maxPQR = 15;\nvec3 getPQR(int i) {\n  // This should use a vec3 array\n  float P,Q,R;\n  assert(i < maxPQR);\n  //The regular compact honeycombs\n  if (i == 0) { P = 3.0; Q = 5.0; R = 3.0; }\n  else if (i == 1) { P = 4.0; Q = 3.0; R = 5.0; }\n  else if (i == 2) { P = 5.0; Q = 3.0; R = 5.0; }\n\n  // One ideal point\n  else if (i == 3) { P = 3.0; Q = 4.0; R = 4.0; }\n  else if (i == 4) { P = 3.0; Q = 3.0; R = 6.0; }\n  else if (i == 5) { P = 4.0; Q = 3.0; R = 6.0; }\n  else if (i == 6) { P = 5.0; Q = 3.0; R = 6.0; }\n\n  // Two ideal points\n  else if (i == 7) { P = 6.0; Q = 3.0; R = 6.0; }\n  else if (i == 8) { P = 4.0; Q = 4.0; R = 4.0; }\n  else if (i == 9) { P = 3.0; Q = 6.0; R = 3.0; }\n\n  // Various non-regular angles\n  else if (i == 10) { P = 5.0; Q = 3.0; R = 7.0; }\n  else if (i == 11) { P = 6.0; Q = 3.0; R = 11.0; }\n  else if (i == 12) { P = 2.0; Q = 3.0; R = 7.0; }\n  else if (i == 13) { P = 3.0; Q = 3.0; R = 7.0; }\n  else if (i == 14) { P = 5.0, Q = 5.0; R = 5.0; }\n  else assert(false);\n  return vec3(P,Q,R);\n}\n\nfloat getlinewidth(int i) {\n    // WebGL 1.0 compliant line width function\n    if (i == 0) return 0.01;\n    if (i == 1) return 0.025;\n    if (i == 2) return 0.05;\n    return 0.1;\n}\n\nconst float PI =  3.141592654;\nconst float TWOPI =  2.0*PI;\n\n#if defined DEBUG\n// Dihedral angle between two faces with normals n,m\n// Assume the normals are pointing in\nfloat dihedral(vec3 n, vec3 m) {\n  return PI - acos(dot(n,m));\n}\n\n// The dihedral angle between a plane and a spherical face.\n// If d is the perp. distance to plane, and\n// s the sphere radius, then angle is acos(d/s)\nfloat dihedral(vec3 n, vec3 C, float s) {\n  return acos(dot(C,n)/s);\n}\n\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n#endif\n\n// r is line vector, intersect with sphere (C,s)\nvec3 intersect(vec3 r, vec3 C, float s2) {\n  // |tr-C| = s\n  // (tr-C).(tr-C) = s^2\n  float a = dot(r,r);\n  float b = dot(r,C);\n  float c = dot(C,C) - s2;\n  float disc = b*b-a*c;\n  if (disc < 0.0) {\n    disc = 0.0;\n  }\n  float t = (b - sqrt(disc))/a;\n  vec3 p = t*r;\n  return p;\n}\n\n// Invert p in sphere (C,s2)\nvec3 invert(vec3 p, vec3 C, float s2) {\n  p -= C;\n  p *= s2/dot(p,p);\n  p += C;\n  return p;\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\n// Distance of p from circle centre p, in plane n, radius r\n// This is basically \"distance to a torus\".\nfloat circledistance(vec3 p, vec3 c, vec3 n, float r) {\n  p -= c;                            // Move to circle frame\n  float d0 = dot(p,n);               // Distance to plane\n  float d1 = sqrt(dot(p,p) - d0*d0); // Distance from origin in plane\n  d1 -= r;\n  return sqrt(d0*d0+d1*d1);\n}\n\n// Distance to hyperbolic line through a and b\n// Much can be precomputed\nfloat hsegment(vec3 p, vec3 a, vec3 b) {\n  vec3 m = 0.5*(a+b); // Midpoint\n  vec3 n = normalize(a-b); // Normal to bisecting plane\n  // Centre of circle must be on plane n through m\n  // Also must be on plane of a,b\n  vec3 r = normalize(cross(a,b));\n  vec3 s = normalize(cross(n,r)); // Intersection\n  assert(eq(distance(m+s,a),distance(m+s,b)));\n  // c = m+ts, want |c-a| + 1 = |c|\n  // c.c - 2c.a + a.a + 1 = c.c\n  // c.a = 0.5*(a.a + 1), c = m+ts\n  // (m+ts).a = 0.5(a.a + 1)\n  // ts.a = 0.5*(a.a + 1) - m.a\n  // t = (0.5*(a.a + 1) - m.a)/(s.a)\n  float t = (0.5*(dot(a,a)+1.0) - dot(m,a))/dot(s,a);\n  vec3 c = m + t*s;\n  float radius = sqrt(dot(c-a,c-a));\n  assert(eq(dot(c,c),dot(c-a,c-a) + 1.0));\n  assert(eq(dot(c,c),dot(c-b,c-b) + 1.0));\n  // Can precompute up to here\n  return circledistance(p,c,r,radius);\n}\n\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (halfspace) {\n    p.yz = rotate(p.yz, -0.6);\n  }\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    if (centre) t *= 0.3;\n    if (!halfspace) p.yz = rotate(p.yz,t*0.125);\n    p.zx = rotate(p.zx,t * 0.2);\n  }\n  return p;\n}\n\nvec3 A,B,C,D;   // Face planes or sphere centre for D\nfloat S,S2; // Radius (squared) of sphere D\nvec3 a,b,c,d,e; // Vertices of tetrahedron plus 'centre' point\n\n// We can use a faster fold for method 1\n#define TMETHOD 1\nvoid init(vec3 PQR) {\n  float P = PQR[0], Q = PQR[1], R = PQR[2];\n  // Construct the Goursat tetrahedron. One vertex is at origin,\n  // with adjacent faces A,B,C (Euclidean) planes. The face opposite\n  // the origin is spherical with centre D, radius S.\n  // Edge from d = vec3(0) to d inverted in D,s\n  // is a (Euclidean) straight line & therefore easy to draw.\n  // d can't be an ideal point.\n  // We have 2 ways of doing this:\n#if TMETHOD == 0\n  {\n    // A general construction: find 3 planes with dihedral angle p,q,r\n    // A = vec3(0,0,1)\n    // B = vec3(0,sin(p),cos(p))\n    // C = (x,y,z)\n    // A.C = cos(q)\n    // B.C = cos(r)\n    // |C| = 1\n    // Now find circle D, radius 1 with dihedral s,t,u with A,B,C:\n    // Using dihedral function as above (assuming s = 1)\n    // A.D = cos(s)\n    // B.D = cos(t)\n    // C.D = cos(u)\n    // Just a linear system mat3(A,B,C)*D = cos(vec3(s,t,u));\n    // so invert matrix (or could just use Cramer).\n#if 1\n    // p,q,r,s,t,u = AB,BC,CA,AD,BD,CD\n    //  P Q R\n    // o-o-o-o\n    // A B D C\n    float p = PI/P, q = PI/2.0, r = PI/2.0;\n    float s = PI/2.0, t = PI/Q, u = PI/R;\n#else\n    // This also works with non-linear Dynkin diagrams:\n    //  A p B\n    //  o---o\n    // s|   |r\n    //  o---o\n    //  D u C\n    // Be careful to get these in the right order\n    float p = PI/3.0, q = PI/2.0, r = PI/4.0; // AB,AC,BC\n    float s = PI/5.0, t = PI/2.0, u = PI/3.0; // AD,BD,CD\n#endif\n    A = vec3(0,0,1);\n    B = vec3(0,sin(p),-cos(p));\n    float z = -cos(q);\n    float y = -(cos(r)-cos(p)*cos(q))/sin(p);\n    float x = sqrt(1.0-y*y-z*z);\n    C = vec3(x,y,z);\n    assert(eq(length(A),1.0));\n    assert(eq(length(B),1.0));\n    assert(eq(length(C),1.0));\n    assert(eq(dihedral(A,B),p));\n    assert(eq(dihedral(A,C),q));\n    assert(eq(dihedral(B,C),r));\n    // Note reverse multiplication\n    // Saves taking the transpose\n    mat3 m = inverse(mat3(A,B,C));\n    D = vec3(cos(s),cos(t),cos(u))*m;\n    S = 1.0;\n    assert(eq(dihedral(A,D,S),s));\n    assert(eq(dihedral(B,D,S),t));\n    assert(eq(dihedral(C,D,S),u));\n  }\n#elif TMETHOD == 1\n  {\n    //                 A B D C\n    // 3rd method, for o-o-o-o only - note order!\n    // Note that d/D is not an end point\n    // so end points can be ideal.\n    // Uses x = 0 and z = 0 as planes, so can use\n    // a more efficient fold: p.xz -> abs(p.xz)\n    float p = PI/P, q = PI/Q, r = PI/R;\n    // The planes\n    A = vec3(0,0,1);\n    B = vec3(0,sin(p),-cos(p));\n    C = vec3(1,0,0);\n\n    // The sphere of inversion\n    S = 1.0/cos(r);\n    float k = S*cos(q)/sin(p);\n    D = vec3(1,k,0);\n    assert(eq(length(A),1.0));\n    assert(eq(length(B),1.0));\n    assert(eq(length(C),1.0));\n    assert(eq(dihedral(A,B),p));\n    assert(eq(dihedral(A,C),PI/2.0));\n    assert(eq(dihedral(B,C),PI/2.0));\n    assert(eq(dihedral(A,D,S),PI/2.0));\n    assert(eq(dihedral(B,D,S),q));\n    assert(eq(dihedral(C,D,S),r));\n  }\n#else\n#error TMETHOD undefined\n#endif\n  // Compute radius of the resulting sphere\n  // for the tetrahedron\n  float ss = sqrt(dot(D,D)-S*S);\n  // and rescale to give radius = 1.0\n  D /= ss; S /= ss;\n  S2 = S*S;\n\n  // Find coordinates of tetrahedron vertices\n  // a,b,c,d opposite A,B,C,D\n  // d is origin, other points all on sphere D\n  // ie. |t-D| = S\n\n  a = intersect(cross(C,B),D,S2);\n  b = intersect(cross(A,C),D,S2);\n  c = intersect(cross(B,A),D,S2);\n  d = vec3(0);\n  // A point vaguely in the interior. Should do this\n  // properly with e equidistant from each side.\n  e = 0.25*(a+b+c+d);\n}\n\nvec3 fold(vec3 p, float t, inout float scale) {\n  // This is bit hacky, but fold is the innermost loop\n  // Maybe a macro for nfolds too?\n  for (int i = 0; i < 32; i++) {\n    // Need to think about this\n    if (t*scale > 100.0) break;\n#if TMETHOD == 1\n    p.xz = abs(p.xz);\n#else\n    // A is always (0,0,1) so can just use abs\n    p.z = abs(p.z);\n    float c = min(0.0,dot(p,C));\n    p -= 2.0*c*C;\n#endif\n    float b = min(0.0,dot(p,B));\n    p -= 2.0*b*B;\n    p -= D;\n    float k = max(1.0,S2/dot(p,p));\n    p *= k;\n    scale *= k;\n    p += D;\n    // It seems to be worth checking when we are done\n    // and breaking out early if so.\n#if TMETHOD == 1\n    if (b == 0.0 && k == 1.0) break;\n#else\n    if (b == 0.0 && c == 0.0 && k == 1.0) break;\n#endif\n  }\n  return p;\n}\n\n// Precompute edge data here. An edge is either the arc of\n// a circle with given radius, centre and plane normal\nfloat arcradius = 0.0;\nvec3 arccentre, arcplane;\n// Or it's a straight line between these points\nvec3 vertex0, vertex1;\n\nvoid initedge(int edge) {\n  if (edge == 0) {\n    // Single edge, a straight line from centre point, d\n    // to its inversion in the opposite (spherical) side D.\n    vertex0 = d;\n    vertex1 = invert(d,D,S2);\n  } else {\n    // Single edge from any vertex to its reflection/inversion.\n    vec3 q = a; vec3 Q = A;\n    if (edge == 2) {\n      q = b; Q = B;    }\n    if (edge == 3) {\n      q = c; Q = C;\n    }\n    if (length(cross(q,Q)) < 1e-4) {\n      // If q and Q are parallel, then the perpendicular from q to Q\n      // is a straight line and and a simpler approach can be used.\n      vertex0 = q;\n      vertex1 = reflect(q,Q);\n    } else {\n      // Want a circular arc from q perpendicular to plane Q\n      vec3 r = normalize(q - dot(q,Q)*Q); // q projected onto Q\n      assert(eq(dot(r,Q),0.0));\n      // Centre of circle c is on line through r, ie. c = t*r\n      // Since centre is on plane Q (which goes through origin)\n      // arc from a must be orthogonal\n      // Ensure that circle is a hyperbolic line:\n      // c  = tr, |c| is distance from origin\n      // s is radius = |q-c], s^2 = (q-c).(q-c) = q.q - 2q.c + c.c\n      // |c|^2 = s^2+1 // hyperbolic, subst for s^2\n      // c.c = q.q - 2q.c + c.c + 1, so\n      // 2q.c = q.q + 1 and c = tr\n      // t = (q.q + 1)/(2q.r)\n      float t = 0.5*(dot(q,q)+1.0)/dot(q,r);\n      arccentre = t*r;\n      arcradius = sqrt(dot(q-arccentre,q-arccentre));\n      // Check we've got it right\n      assert(eq(dot(arccentre,arccentre),1.0+arcradius*arcradius));\n      // The plane of the circle, or the direction of the axis of rotation\n      arcplane = normalize(cross(q,r));\n    }\n  }\n}\n\nfloat eval0(vec3 p, float t) {\n  // As we fold and invert, keep track of the change in local\n  // scale here. This will be used to adjust the distance\n  // estimator appropriately. This makes DE work nicely at\n  // small scales but can still go wrong over larger distances.\n  float scale = 1.0;\n  if (halfspace) {\n    // Map from halfspace to sphere by inversion in\n    // sphere centre y = -1, radius 1. This actually\n    // takes unit sphere to y = -0.5.\n    p.y += 1.0;\n    float k = 1.0/dot(p,p);\n    p *= k;\n    scale *= k;\n    p.y -= 1.0;\n  }\n  if (centrevertex != 0) {\n    // Translate (or rather, reflect) so one of the other vertices\n    // (a,b,c) (or any other point) is at the centre.\n    // This won't work if the vertex is an ideal point!\n    vec3 q = a;\n    if (centrevertex == 2) q = b;\n    else if (centrevertex == 3) q = c;\n    // If q is ideal this won't go well.\n    assert(length(q) < 0.999);\n    vec3 K = invert(q,vec3(0),1.0);\n    assert(eq(length(invert(q,K,dot(K,K)-1.0)),0.0));\n    p -= K;\n    float k = (dot(K,K)-1.0)/dot(p,p);\n    scale *= k;\n    p *= k;\n    p += K;\n  }\n  if (animate) {\n    // Just a periodic translation at the moment.\n    // x0 is edge of inversion circle, s0 is radius\n    // General rule: (x0+s0)^2 = s0^2 + 1 (Pythagoras)\n    // So: x0^2 + 2*x0*s0 + s0^2 = s0^2 + 1\n    // So: s0 = (1-x0^2)/(2*x0)\n    float t = 0.1*iTime;\n    float x0 = 0.5*sin(t)+0.01;\n    float s0 = 0.5*(1.0-x0*x0)/x0;\n    p.x -= x0 + s0;\n    float k = s0*s0/dot(p,p);\n    scale *= k;\n    p *= k;\n    p.x += x0 + s0;\n  }\n\n  p = fold(p,t,scale);\n\n  // p is now in the fundamental tetrahedron and we can\n  // draw our scene. Distances, eg. line widths need to\n  // be scaled appropriately for the ball model, this\n  // is just ds = 1/(1-r^2)\n  float localscale = 1.0-dot(p,p);\n  float k = 1e8;\n  float lwidth = localscale*lwidth0;\n  if (region) {\n    // Draw the 6 edges of the fundamental region\n    k = min(k,segment(p,d,a)-lwidth);\n    k = min(k,segment(p,d,b)-lwidth);\n    k = min(k,segment(p,d,c)-lwidth);\n    // distance to hyperbolic line for next 3\n    k = min(k,hsegment(p,a,b)-lwidth);\n    k = min(k,hsegment(p,b,c)-lwidth);\n    k = min(k,hsegment(p,c,a)-lwidth);\n#if 0\n  // This needs to work better\n  } else if (omnitruncated) {\n    // An approximation to having the region point\n    // at centre of tetrahedron.\n    vec3 q = e;\n    vec3 a0 = reflect(q,A);\n    vec3 b0 = reflect(q,B);\n    vec3 c0 = reflect(q,C);\n    vec3 d0 = invert(q,D,S2);\n    k = min(k,segment(p,q,a0)-lwidth);\n    k = min(k,segment(p,q,b0)-lwidth);\n    k = min(k,segment(p,q,c0)-lwidth);\n    k = min(k,segment(p,q,d0)-lwidth);\n#endif\n  } else {\n    if (arcradius == 0.0) {\n      // Straight (euclidean) line\n      k = min(k,segment(p,vertex0,vertex1)-lwidth);\n    } else {\n      // Edge is arc of circle\n      k = min(k,circledistance(p,arccentre,arcplane,arcradius)-lwidth);\n    }\n  }\n  float h = k/scale;\n  return h;\n}\n\nfloat eval(vec3 p,float t) {\n  float h = eval0(p,t);\n  if (halfspace) {\n    // halfspace actually begins y = -0.5;\n    float d = 0.5+p.y;\n    h = interior ? min(h,d) : max(h,-d);\n  } else {\n    // ball view\n    float d = length(p) - clipsphere;\n    h = interior ? min(h,-d) : max(h,d);\n    if (slice) h = max(h,p.z);\n  }\n  return h;\n}\n\nint teval(vec3 p, float t) {\n  float d = eval0(p,t);\n  int type = 0;\n  if (halfspace) {\n    // halfspace actually begins y = -0.5;\n    float d1 = 0.5+p.y;\n    if (interior && d1 < d) type = 1;\n  } else {\n    // ball view\n    float d1 = length(p) - 1.0;\n    if (interior && -d1 < d) type = 1;\n  }\n  return type;\n}\n \n// Need to pass in a scale parameter here, fixed step\n// is too small for large objects\n vec3 calcNormal(vec3 p, float t) {\n  vec2 e = vec2(0.001*t, 0.0);\n  return normalize(vec3(eval(p + e.xyy,t) - eval(p - e.xyy,t),\n                        eval(p + e.yxy,t) - eval(p - e.yxy,t),\n                        eval(p + e.yyx,t) - eval(p - e.yyx,t)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  float maxd = length(ro) + (halfspace ? 10.0 : 1.0);\n  const float precis = 0.0002;\n  float t = 0.0;\n  float res = 1e8;\n  // For the ball model, start close in\n  if (!halfspace) t = max(0.0,length(ro)-1.0);\n  for (int i = 0; i < 200; i++) {\n    vec3 p = ro + rd * t;\n    float h = eval(p,t);\n    h *= 0.5; // Fudge factor\n    // Maximum step size reduces overshooting artefacts when stepping\n    // in from a distance.\n    if (halfspace) h = min(h,1.0);\n    //else h = min(h,0.1);\n    t += h;\n    if (h < precis) return t;\n    if (t > maxd) break;\n  }\n  return 1e8;\n}\n\nvec3 getcolor(vec3 p, vec3 n, int type) {\n  if (type == 1) return 0.5*vec3(1,1,0);\n  return 0.5+0.5*abs(n); //vec3(1);\n}\n\n#if VERSION < 300\n// Need texelFetch for keys to work\n#define texelFetch(a,b,c) (vec4(0))\n#endif\n \nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_L = 76;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool keypress(int key) {\n  return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\nvoid initkeys() {\n  animate = keypress(CHAR_A);\n  centre = keypress(CHAR_C);\n  dorotate = !keypress(CHAR_D);\n  edge = keycount(CHAR_E)%4;\n  gradient = !keypress(CHAR_G);\n  halfspace = keypress(CHAR_H);\n  ilwidth = (1+keycount(CHAR_L))%4;\n  //omnitruncated = keypress(CHAR_O);\n  region = keypress(CHAR_R);\n  slice = keypress(CHAR_S);\n  pqr = keycount(CHAR_T)%maxPQR;\n  centrevertex = keycount(CHAR_V)%4;\n  showparams = keypress(CHAR_X);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  initkeys();\n#if defined TEST\n  pqr = 3;\n  halfspace = true;\n  region = true;\n  ilwidth = 0;\n#endif\n  init(getPQR(pqr));\n  initedge(edge);\n  lwidth0 = getlinewidth(ilwidth);\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec3 col = vec3(0,0,0.1*(1.0-p.y));\n  vec3 ro = vec3(0, 0, 2.5);\n  if (centre) ro = vec3(0);\n  if (halfspace) ro *= 2.0;\n  vec3 rd = normalize(vec3(p, -3.0));\n  vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n  ro = transform(ro);\n#if VERSION >= 300\n  ro *= 0.1*float(3+keycount(KEY_DOWN)-keycount(KEY_UP));\n#else\n  ro *= 0.3;\n#endif\n  rd = transform(rd);\n  li = transform(li);\n\n  interior = halfspace ? ro.y > -0.5 : dot(ro,ro) < 1.0;\n  float k = march(ro,rd);\n  if (k < 1e8) {\n    vec3 pos = ro + k*rd;\n    vec3 n = calcNormal(pos,k);\n    int type = teval(pos,k);\n    col = 0.3+0.7*getcolor(pos,n,type);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col *= diffuse;\n    if (gradient) {\n      col *= 1.0-0.2*smoothstep(0.0,1.0,length(pos));\n    }\n  }\n  col = pow(col, vec3(0.4545));\n#if defined DEBUG\n  if (alert) col = vec3(1,0,0);\n#endif\n  if (showparams) {\n    int N = maxPQR + 10;\n    vec2 xy = float(N)*fragCoord.xy/iResolution.x;\n    xy.x -= 0.5;\n    float gridx = round(xy.x);\n    if (distance(xy, vec2(gridx,1.0)) < 0.3) {\n      int i = int(gridx);\n      if (i == pqr ||\n          i == maxPQR+1+edge ||\n          i == maxPQR + 6 + centrevertex) {\n        col = vec3(0,1,0);\n      } else if (i != maxPQR && i != maxPQR+5) {\n        col = vec3(1,1,0);\n      }\n    }\n  }\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}