{
    "Shader": {
        "info": {
            "date": "1715479028",
            "description": "Visualize Rain World Tiles! Read the comments in the code to understand how to use this. Or watch this https://www.youtube.com/watch?v=MoX6hXQZVMw\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XcKSzK",
            "likes": 2,
            "name": "Rain World Tile Visualizer",
            "published": 3,
            "tags": [
                "visualizer",
                "tiles",
                "rainworld",
                "rainworld"
            ],
            "usePreview": 1,
            "username": "LudoCrypt",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "// Creative Commons Attribution ShareAlike 4.0\n// https://creativecommons.org/licenses/by-sa/4.0/\n\n// Hello! Let me explain how to use this before we begin. First, you're gonna need an extension for firefox/chrome\n// that lets you use custom textures. Just look up 'shadertoy custom textures' itll be there.\n\n// Drag the tile you want to visualize into iChannel0\n// Drag the palette texture you want to use into iChannel1\n// If you don't know where palettes are, they're in StreamingAssets/palettes\n\n// Next, copy over the data from the init into the variables below.\n// But 'repeatLSize' is not in the init. I need it there because of implementation specifics,\n// but just put that as the number of numbers in repeatL, or the number of layers in the image\n// ie '1,1,4,3,1' is 5\n\n// For tiles with random values, they will cycle every second. Feel free to pause if you want to view a specific one.\n\n// Not all tiles will work with this visualizer, for example, asian signs or those similar will most certainly break.\n\n// There are also some variables to do with visualization specifics, mainly parallax\n// But you can also change 'layer' to see the colors as if they were further back.\n\n// Do note that I actually have no idea how palettes work and if this does not reflect 100% ingame, sorry!\n\nconst ivec2 sz = ivec2(\n\n// Size\n7,4\n\n);\n\nconst int repeatLSize = \n\n// This is important:\n// This is how many layers there are, excluding repeats\n// ie '1,1,4,3,1' is 5\n5\n\n;\n\nconst int repeatL[repeatLSize] = int[repeatLSize](\n\n// Repeat Layers\n1, 4, 1, 3, 1\n\n);\n\nconst int bfTiles =\n\n// Buffer Tiles\n1\n\n;\n\nconst int rnd =\n\n// Random Tiles\n1\n\n;\n\nbool effectColor =\n\n// Effect Color A/B tag\nfalse\n\n;\n\n// What 'Layer' this is on\nconst int layer = 1;\n\n// Parallax Depth Strength (ie further back moves more) ((tho the higher this is, the less it moves))\nconst float depthScale = 50.0;\n\n// Parallax Mouse Strength (ie how strong to scale based on where the mouse is) ((tho the higher this is, the less it moves))\nconst float cameraTiltScale = 1.0;\n\n#define rlsz vec2(float(sz.x) + 2.0 * float(bfTiles), float(sz.y) + 2.0 * float(bfTiles))\n\n#define sublayer ((layer - 1) * 10)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 size = textureSize(iChannel0, 0);\n    float topOffset = 1.0 / float(size.y);\n    int idealHeight = 1 + (sz.y + (2 * bfTiles)) * repeatLSize * 20;\n    float previewOffset = float(size.y - idealHeight) / float(size.y);\n    float layerHeight = (20.0 * rlsz.y) / float(size.y);\n    float verticalOffset = (rlsz.y * topOffset) * 20.0;\n    float normalHeight = (rlsz.y * 20.0) / float(size.y);\n    \n    float ar = iResolution.x / iResolution.y;\n    float pieceAr = float(sz.x) / float(sz.y);\n    \n    vec2 uvScale = vec2(ar / pieceAr / float(rnd), normalHeight);\n    if (ar / pieceAr < 1.0) {\n        uvScale = vec2(1.0 / float(rnd), normalHeight / (ar / pieceAr));\n    }\n    \n    if (effectColor) {\n        uvScale.x /= 2.0;\n    }\n    \n    vec2 uv = (fragCoord / iResolution.xy) * uvScale;\n    vec2 mouse = ((iMouse.xy / iResolution.xy) - vec2(0.5)) * uvScale;\n\n    if (ar / pieceAr < 1.0) {\n\t\tuv.y -= (uvScale.y / 2.0) - (layerHeight / 2.0);\n\t} else {\n\t\tuv.x -= (uvScale.x / 2.0) - (((20.0 * rlsz.x) / float(size.x)) / 2.0);\n\t}\n    \n    \n    int r = int(mod(floor(iTime), float(rnd)));\n    float curRand = float(r) * ((20.0 * rlsz.x) / float(size.x));\n    uv.x += curRand;\n    \n    float bottomBound = previewOffset;\n    bool hit = false;\n    int curDepth = 0;\n    for (int i = 0; i < repeatLSize; i++) {\n        for (int j = 0; j < repeatL[repeatLSize - i - 1]; j++) {\n            vec2 tileSample = vec2(uv.x, uv.y + previewOffset + layerHeight * float(i));\n            vec2 mouseOffset = mouse / vec2(cameraTiltScale, cameraTiltScale);\n            vec2 depthOffset = vec2((float(repeatLSize - curDepth) / depthScale), (float(repeatLSize - curDepth) / depthScale)) / vec2(float(rnd), 1.0);\n            vec2 samplePos = tileSample + mouseOffset * depthOffset * pieceAr;\n            vec3 col = texture(iChannel0, samplePos).xyz;\n            \n            if (samplePos.y <= bottomBound || samplePos.y >= (bottomBound + layerHeight) || samplePos.y < 0.0 || samplePos.x < curRand || samplePos.x > ((effectColor ? 0.5 : 1.0) / float(rnd) + curRand) || samplePos.y > 1.0) {\n                curDepth++;\n                continue;\n            }\n            \n            if (col != vec3(1.0)) {\n                vec3 paltex = texture(iChannel1, vec2(float(curDepth + sublayer) / 32.0, (((col.x) + (col.y * 2.0) + (col.z * 3.0)) / 16.0) + (1.0 / 8.0))).xyz;\n                \n                fragColor = vec4(paltex, 1.0);\n                hit = true;\n            }\n            curDepth++;\n        }\n        bottomBound += layerHeight;\n    }\n    \n    if (hit) {\n        return;\n    }\n\n    \n    vec3 bkg = 0.5 + 0.5 * cos(iTime + (fragCoord / iResolution.xy).xyx + vec3(0, 2, 4)) / 5.0;\n    fragColor = vec4(bkg, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}