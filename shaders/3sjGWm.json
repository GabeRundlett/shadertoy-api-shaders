{
    "Shader": {
        "info": {
            "date": "1549036612",
            "description": "field of orbs, for testing a depth of field effect",
            "flags": 32,
            "hasliked": 0,
            "id": "3sjGWm",
            "likes": 7,
            "name": "field of orbs, depth of field",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "raytrace",
                "orb",
                "field",
                "of"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n//Buffer A - Raytraced field of multi colored orbs, outputs world depth in W component\n//Image - Screenspace depth of field effect\n\n#define focusDistance 0.\n#define focusMinRange 5.\n#define focusMaxRange 20.\n\n#define dofBlurIter 8.\n#define dofBlurStep 2.\n#define dofBlurRange 3.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 sum = texture(iChannel0,uv);\n\tfloat tdst = sum.w,\n\tblur = clamp((abs(tdst-focusDistance)-focusMinRange)/(focusMaxRange-focusMinRange),0.,1.)*(dofBlurIter+.99),\n\tfblur = fract(blur);\n\tint blurAmount = -int(blur),\n\t\tpblurAmount = -blurAmount,\n\t\tblurLen = pblurAmount+1;\n\tsum = vec4(sum.xyz,1)*max(0.,1.+float(pblurAmount));\n\tfor (int x = blurAmount; x < blurLen; x++) {\n\t\tfor (int y = blurAmount; y < blurLen; y++) {\n\t\t\tvec2 off = vec2(x,y)*dofBlurStep;\n\t\t\tvec4 samp = texture(iChannel0,uv+off/iResolution.xy);\n            samp = vec4(samp.xyz,1)*clamp((abs(samp.w-focusDistance)-focusMinRange)/(focusMaxRange-focusMinRange),0.,1.);\n\t\t\tif (max(abs(x),abs(y)) == pblurAmount) samp *= fblur;\n\t\t\tsum += samp;\n\t\t}\n\t}\n\tfragColor = sum/max(sum.w,1e-1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define EPSILON 1e-1\n#define NORMAL_PRECISION 2e-2\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nfloat distf(vec3 p) {\n\tvec3 sp;\n\tsp.y = p.y-1.;\n\tsp.xz = mod(abs(p.xz),4.)-2.;\n\treturn min(p.y,length(sp)-1.);\n}\n\nvec3 normf(vec3 p, float bd) {\n\treturn normalize(vec3(distf(p+vec3(NORMAL_PRECISION,0,0))-bd,\n\t\t\t\t\t\t  distf(p+vec3(0,NORMAL_PRECISION,0))-bd,\n\t\t\t\t\t\t  distf(p+vec3(0,0,NORMAL_PRECISION))-bd));\n}\n\n#define time iTime\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//initial ray parameters\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x;\n\tvec4 hsh = hash(uv.xyyx*vec4(1,1,.3,.3));\n\tvec3 rp = vec3(100.,3.+sin(time*.2+2.)*2.,time), orp = rp,\n\t\trd = normalize(vec3(uv+(hsh.xy-.5)/iResolution.xy,1.));\n\trp += rd*hsh.z*1.0;\n\t\n\t//raytracing\n\tfor (int i = 0; i < 64; i++) {\n\t\tfloat dst = distf(rp);\n\t\tif (dst < EPSILON) break;\n\t\trp += rd*dst;\n\t}\n\t\n\tfloat bdst = distf(rp),\n\t\trdst = length(rp-orp);\n\tif (bdst < EPSILON) {\n\t\tvec3 nrm = normf(rp,bdst);\n\t\tfloat sv = 0.;\n\t\t\n\t\t//ambient occlusion\n\t\tfloat asum = 0., as = .1;\n\t\tvec3 arp = rp+nrm*.1;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfloat adst = distf(arp);\n\t\t\tasum += (max(0.,as-adst)/as)*max(0.,1.-as);\n\t\t\tarp += nrm*adst;\n\t\t\tas += adst;\n\t\t}\n\t\tsv += 1.-asum*.3;\n\t\t\n\t\tsv *= max(0.,1.-rdst/40.);//fog\n\t\t\n\t\tvec3 col;\n\t\tif (rp.y < EPSILON) col = vec3(1.);\n\t\telse col = pow(hash(floor(abs(rp.xz)/4.).xyyx*vec4(.1234,.124,.323,.332)).xyz,vec3(2.2));\n\t\tfragColor = vec4(col*sv,rdst);\n\t} else {\n\t\tfragColor = vec4(vec3(max(0.,rd.y)),rdst);//background\n\t}\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}