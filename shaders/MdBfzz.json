{
    "Shader": {
        "info": {
            "date": "1499803720",
            "description": "\"I... I shall consume. \nConsume... Consume everything.\"\n\nMore SDF learning.",
            "flags": 32,
            "hasliked": 0,
            "id": "MdBfzz",
            "likes": 9,
            "name": "I Shall Consume",
            "published": 3,
            "tags": [
                "moon",
                "mask",
                "zelda",
                "majora"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 895
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * --------------------------------\n * - General\n * --------------------------------\n *\n * Rendering of the Moon from The Legend of Zelda: Majora's Mask.\n *\n * Implemented with four buffers:\n *\n *     (A) Rendering of the Moon.\n *     (B) Rendering of the Clocktown sillhouette.\n *     (C) Fireball that periodically appears around the Moon.\n *     (D) Sky background gradient with Majora's Mask.\n *\n * Each buffer contains more implementation information and gives attribution\n * to other shaders used.\n *\n * --------------------------------\n * - Improvements\n * --------------------------------\n *\n * While overall I am fairly happy with the result, there are several areas that\n * can (and hopefully will be) improved:\n *\n *     (1) Appearance of the nose. Currently, in my opinion, the worst part of\n *         the entire shader. Moon needs some plastic surgery and some nostrils added.\n *\n *     (2) Mouth movement. The Moon doesn't have a jaw, so it makes opening and\n *         closing of the mouth awkward at best.\n *\n *     (3) Add Giants. I toyed with adding the Giants to hold up the Moon, but was\n *         unable to produce any that I was happy with. It would also provide a reason\n *         for /why/ the Moon is just hanging out above Clocktown.\n */\n\n#define EnableShakeBlur    // Enables a blur effect during camera shake\n#define MIX(x, y) mix(x.rgb, y.rgb, y.a)\n\n//------------------------------------------------------------------------------------------\n// Misc\n//------------------------------------------------------------------------------------------\n\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nfloat TimeRatio()\n{\n\t// 3 seconds inactive (0), 3 seconds ramp up, 3 seconds active (1), 3 seconds ramp down\n    float mt = mod(iTime + 2.0, 12.0);\n\treturn StepValue(mt, 3.0, StepValue(mt, 10.0, mix(1.0, 0.0, (mt - 9.0) / 3.0), mix(0.0, 1.0, min(1.0, (mt - 3.0) / 3.0))), 0.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\n// Source (3Dfx): https://www.shadertoy.com/view/4dGXW1\nvec4 SampleAA(sampler2D s, in vec2 uv)\n{\n    vec2 r = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 o = vec2(0.11218413712, 0.33528304367) * r;\n    \n    return (texture(s, uv + vec2(-o.x,  o.y)) +\n            texture(s, uv + vec2( o.y,  o.x)) +\n            texture(s, uv + vec2( o.x, -o.y)) +\n            texture(s, uv + vec2(-o.y, -o.x))) * 0.25;\n}\n\nvec2 CameraShake(vec2 origin)\n{\n    vec2 offset = vec2(0.0025, 0.00035);\n    return (origin + (sin(iTime * 50.0) * offset * TimeRatio()));\n}\n\nfloat Vignette(in vec2 uv)\n{\n    return 0.2 + (0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2));\n}\n\nvec3 Render(vec2 coord)\n{\n    vec2 uv = CameraShake(coord / iResolution.xy);\n    \n    vec4 moon      = SampleAA(iChannel0, uv);\n    vec4 clocktown = texture(iChannel1, uv);\n    vec4 fireball  = texture(iChannel2, uv) * 1.25;\n    vec4 sky       = texture(iChannel3, uv);\n    \n    return MIX(MIX(MIX(sky, moon), clocktown), fireball) * Vignette(uv);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nconst vec2 BlurPoints[4] = vec2[](\n    vec2(-0.1,  0.4),\n    vec2( 0.4,  0.1),\n    vec2( 0.1, -0.4),\n    vec2(-0.4, -0.1));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef EnableShakeBlur\n    float tr = TimeRatio();\n    \n    if(tr > 0.0)\n    {\n        // Apply a cheap blur during shaking\n        for(int i = 0; i < 4; ++i)\n        {\n            fragColor.rgb += Render(fragCoord + BlurPoints[i] * (TimeRatio() * 2.5));\n        }\n\n        fragColor.rgb *= 0.25;\n    }\n    else\n#endif\n    {\n        fragColor.rgb = Render(fragCoord);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * --------------------------------\n * - The Moon\n * --------------------------------\n *\n * The Moon is formed from a basic sphere SDF which has been carved and molded\n * by several other basic shapes (primarily capsules and rounded boxes).\n *\n * A displacement map (iChannel0) was applied to the base sphere to give the appearance of\n * craters on it's surface. \n *\n * The following steps are taken to form the shape of the moon:\n *\n *     (1) Sphere SDF\n *     (2) Subtract the eye sockets (formed using capsules)\n *     (3) Smooth union the eyes onto the sockets (eyes are spheres)\n *     (4) Smooth union the nose onto the sphere (nose is a disp. mapped rounded box)\n *     (5) Subtract the mouth from the sphere (mouth is a rounded box)\n *     (6) Union the repeated tooth SDF into the mouth (tooth is a rounded box)\n *\n * There are four different materials used for the Moon:\n *\n *     (1) Surface: The surface of the moon is a dark gray and is lighted using PBR formulas.\n *         Both a direct analytical and an ambient environment map (iChannel3) light is applied.\n *\n *     (2) Eye: A red-to-yellow gradient is applied to the spheres for the base color. The \n *         pupils are black and look slightly away from each other. This gives the characteristic\n *         unfocused look of the eyes seen in the game. The eye is purely the albedo color\n *         and no lighting or shadowing is applied due to it's emissive qualities.\n *\n *     (3) Socket: Used for both the eye sockets and the inside of the mouth. Simply a dark, but\n *         not-quite-black, albedo color. Again, no lighting or shadowing applied. The Moon within\n *         the game has unnaturally dark eye sockets that is more than just mere shadow.\n *\n *     (4) Teeth: A pure gray with lighting and shadowing applied. The relative darkness of the \n *         surface, and the near-black of the mouth interior, make the teeth look lighter than\n *         they really are.\n *\n * --------------------------------\n * - Sources\n * --------------------------------\n * \n * - Lighting\n *\n * The lighting applied to the Moon is based off of:\n *\n *     'PBR Lighting Demo/Reference' - ssell\n *     https://www.shadertoy.com/view/MsXBzl\n *\n * - Displacement Map\n *\n * The displacement mapped sphere and rounded boxes are from:\n *\n *     'Raymarched Surface Displacement' - Hamneggs\n *     https://www.shadertoy.com/view/4dj3Dw\n *\n * - Basic SDF Formulas\n *\n *     'Modelling with Distance Functions' - iq\n *     https://iquilezles.org/articles/distfunctions\n */\n\n#define SSAA\n\n// Optional head tilting/looking down movement. Not sure how I feel about it...\n#define HEAD_TILT 1.0\n//#define HEAD_TILT TimeRatio()\n\n#define Epsilon               0.001\n#define NearClip              Epsilon\n#define FarClip               20.0\n#define IBLSteps              16.0\n#define MarchSteps            100\n#define ShadowSteps           10\n#define SoftShadowFactor      128.0\n#define SoftShadowOffset      0.3\n#define BumpFactor            0.055\n#define TexScaleFactor        0.55\n\n#define PI                    3.14159\n#define ONE_OVER_PI           0.31831\n#define ONE_OVER_TWO_PI       0.15915\n\n#define MAT_Surface           1.0\n#define MAT_Eye               2.0\n#define MAT_Socket            3.0\n#define MAT_Teeth             4.0\n\n#define AssignM(x,y) hit.material = StepValue(Epsilon, x, y, hit.material);\n#define IsM(x) (hit.material <= x + Epsilon)\n#define RGB(r, g, b) (vec3(float(r), float(g), float(b)) * 0.0039)\n\nconst vec3 EyeYellow = RGB(224, 208, 16);\nconst vec3 EyeOrange = RGB(255, 25, 0);\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\n// if(a > b) { return ra; } else { return rb; }\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nvec3 StepValue3(float a, float b, vec3 ra, vec3 rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nfloat Subtraction(float a, float b)\n{\n    return max(-a, b);\n}\n\nvec3 Translate(in vec3 p, in vec3 v)\n{\n    return (p - v);\n}\n\nvec3 Repeat(in vec3 p, in vec3 s)\n{\n    return (mod(p, s) - (s * 0.5));   \n}\n\nfloat SUnion(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\nvec3 RotX(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z));\n}\n\nvec3 RotY(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3((c * p.x) + (s * p.z), p.y, (-s * p.x) + (c * p.z));\n}\n\nfloat TimeRatio()\n{\n\t// 3 seconds inactive (0), 3 seconds ramp up, 3 seconds active (1), 3 seconds ramp down\n    float mt = mod(iTime + 2.0, 12.0);\n\treturn StepValue(mt, 3.0, StepValue(mt, 10.0, mix(1.0, 0.0, (mt - 9.0) / 3.0), mix(0.0, 1.0, min(1.0, (mt - 3.0) / 3.0))), 0.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n  \tvec3  surfPos;\n    vec3  surfNorm;\n    float material;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// Displacement Mapped Sampling\n//------------------------------------------------------------------------------------------\n\nvec4 Tex3D(in vec3 p, in vec3 n, sampler2D s)\n{\n    // Use textureLod instead of texture (as in https://www.shadertoy.com/view/4dj3Dw)\n    // to prevent Windows Firefox from crying/crashing.\n    return textureLod(s, p.yz, 0.0) * abs(n.x) + \n           textureLod(s, p.xz, 0.0) * abs(n.y) + \n           textureLod(s, p.xy, 0.0) * abs(n.z);\n}\n\nfloat DispSphere(vec3 samplePos, float r)\n{\n\tfloat bump = 0.0;\n    \n\tif(length(samplePos) < r + BumpFactor)\n    {\n\t\tbump = Tex3D(samplePos * TexScaleFactor, normalize(samplePos), iChannel0).r * BumpFactor;\n\t}\n    \n\treturn length(samplePos) - r + bump;\n}\n\nfloat DispBox(vec3 samplePos, vec3 boxDim, float r)\n{\t\n\tvec3 normal;\n\tfloat bump = 0.0;\n    \n\tif(length(samplePos) < length(boxDim))\n\t{\n \t\tbump = Tex3D(samplePos * TexScaleFactor * TexScaleFactor, normal, iChannel0).r * BumpFactor;\n\t}\n    \n\tvec3 d = abs(samplePos) - boxDim;\n\treturn (min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0)) + bump - r);\n}\n\n//------------------------------------------------------------------------------------------\n// SDF Functions\n//------------------------------------------------------------------------------------------\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCone(vec3 p, vec2 c)\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat SDF_Eye(vec3 p)\n{\n    // Do both left and right eye in a single call using sign(p.x)\n\treturn length(Translate(p, vec3(0.4 * sign(p.x), 0.15, 0.8))) - 0.105;\n}\n\nfloat SDF_EyeSocket(vec3 p)\n{\n    float m  = sign(p.x);              // We are either sampling the left or right socket based on p.x\n    float r  = 0.06 + abs(p.x) * 0.5;  // Socket size increases as we move along x\n    float xa = 0.25 * m;\n    float xb = 0.4 * m;\n    \n    return sdCapsule(p, vec3(xa, 0.2, 1.0), vec3(xb, 0.25, 1.0), r);\n}\n\nfloat SDF_Nose(vec3 p)\n{ \n    float nose = DispBox(\n        RotY(RotX(Translate(p, vec3(0.0, 0.35, 0.7)), PI * 0.25), PI * 0.25),\n        vec3(0.115, 0.485, 0.115), \n        0.05 - (p.y) * 0.1);\n    \n    return nose;\n}\n\nfloat SDF_Mouth(vec3 p)\n{\n    // Increase the size of the mouth over time\n    float yoff = 0.035 * clamp(TimeRatio() * 4.0, 0.0, 1.0) * 2.0;\n    \n    return udRoundBox(\n        // Rotate box so that it cuts into the moon correctly\n        RotX(Translate(p, vec3(0.0, -0.275, 0.9 - abs(p.x) * 0.175)), PI * 0.15),\n        // Increase the vertical size of mouth\n        vec3(0.3, 0.02 + yoff, 0.1),\n        // The radius increases as we move along x and y\n        0.05 + abs(p.x) * 0.75 * mix(0.0, 1.0, clamp(abs(p.y) / 3.5, 0.0, 1.0)));\n}\n\nfloat SDF_Teeth(vec3 p, float mouthSDF)\n{\n    // Slide the teeth up/down as the mouth opens...\n    float yoff = 0.045 * clamp(TimeRatio() * 4.0, 0.0, 1.0) * 2.0;\n    \n    // Repeat the teeth. Pull them back slightly as they get away from x=0.0\n    vec3 tp = Translate(p, vec3(0.0, -0.275, 0.925 - abs(p.x) * 0.35));\n    tp = Repeat(tp, vec3(0.165, 0.15 + yoff, 0.0));\n    \n    // The vertical gap between teeth is at y=-0.275\n    // This sharpens the teeth slightly as they near the space between rows.\n    float r = mix(1.0, 0.0, clamp(abs(p.y + 0.275) / 0.5, 0.0, 1.0)) * 0.085;\n    \n    float teeth = udRoundBox(\n        tp,\n        vec3(\n            0.12 - r, \n            0.0425, \n            0.025),\n        0.02);\n    \n    return max(mouthSDF, teeth);\n}\n\nfloat SDF_MoonBody(vec3 p)\n{\n    return DispSphere(p, 1.0);\n}\n\nfloat SDF_Moon(vec3 point, inout RayHit hit)\n{\n    float sdf = FarClip;\n    \n    point = RotX(point, PI * -0.15 * HEAD_TILT);\n    \n    float moonSDF    = SDF_MoonBody(point);\n    float eyesSDF    = SDF_Eye(point);\n    float socketsSDF = SDF_EyeSocket(point);\n    float noseSDF    = SDF_Nose(point);\n    float mouthSDF   = SDF_Mouth(point);\n    float teethSDF   = SDF_Teeth(point, mouthSDF);\n    \n    // If we have intersected either sockets/mouth AND have hit the moon (we are in a cut out)\n    AssignM(min(socketsSDF, mouthSDF) + moonSDF * 2.0, MAT_Socket);\n    AssignM(eyesSDF, MAT_Eye);\n    AssignM(teethSDF, MAT_Teeth);\n    \n    sdf = Subtraction(socketsSDF, moonSDF);\n    sdf = SUnion(sdf, eyesSDF, 0.05);\n    sdf = SUnion(sdf, noseSDF, 0.05);\n    sdf = Subtraction(mouthSDF, sdf);\n    sdf = min(sdf, teethSDF);\n    \n    return sdf;\n}\n\nfloat Scene_SDF(vec3 point, inout RayHit hit)\n{\n    return SDF_Moon(point, hit);\n}\n\nvec3 Scene_Normal(vec3 p)\n{\n    RayHit hit;\n    \n    float e = Epsilon;\n    \n\treturn clamp(normalize(vec3(\n        (Scene_SDF(vec3(p.x + e, p.y, p.z), hit) - Scene_SDF(vec3(p.x - e, p.y, p.z), hit)),\n        (Scene_SDF(vec3(p.x, p.y + e, p.z), hit) - Scene_SDF(vec3(p.x, p.y - e, p.z), hit)),\n        (Scene_SDF(vec3(p.x, p.y, p.z + e), hit) - Scene_SDF(vec3(p.x, p.y, p.z - e), hit)))), -1.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Light Structures and Functions\n//------------------------------------------------------------------------------------------\n\nvec3 SampleEnvironment(in vec3 r)\n{\n    return texture(iChannel3, r).rgb;\n}\n\nfloat CalcNDF(in vec3 n,in vec3 h, in float r)\n{\n    float a = (r * r);\n    return (a / (PI * pow((pow(dot(n, h), 2.0) * (a - 1.0) + 1.0), 2.0)));\n}\n\nfloat CalcAtten(in vec3 n, in vec3 v, in float k)\n{\n    float d = max(dot(n, v), 0.0);\n \treturn (d / ((d * (1.0 - k)) + k));\n}\n\nfloat CalcAttenAnalytical(in vec3 n, in vec3 l, in vec3 v, in float r)\n{\n    float k = pow((r + 1.0), 2.0) * 0.125;\n    \n    float la = CalcAtten(n, l, k);\n    float va = CalcAtten(n, v, k);\n    \n    return (la * va);\n}\n\nfloat CalcAttenIBL(in float r, in float nol, in float nov)\n{\n    float k = pow(r, 2.0) * 0.5;\n    \n    float la = (nol / ((nol * (1.0 - k)) + k));\n    float va = (nov / ((nov * (1.0 - k)) + k));\n    \n    return (la * va);\n}\n\nvec3 CalcFresnel(in vec3 n, in vec3 v,in vec3 f0)\n{\n\tfloat d = max(dot(n, v), 0.0); \n    float p = ((-5.55473 * d) - 6.98316) * d;\n        \n    return f0 + ((1.0 - f0) * pow(1.0 - d, 5.0));\n}\n\nvec3 CalcDiffuse(in vec3 a)\n{ \n    return (a * ONE_OVER_PI);\n}\n\nvec3 CalcSpecularAnalytical(in vec3 n, in vec3 l, in vec3 v, in vec3 f0, inout vec3 f1, in float r)\n{\n    f1 = CalcFresnel(n, v, f0);\n    return ((f1 * CalcNDF(n, normalize(l + v), r) * CalcAttenAnalytical(n, l, v, r)) / (4.0 * dot(n, l) * dot(n, v)));\n}\n        \nvec2 Hammersley(float i, float n)\n{   \n    uint b = uint(i);\n    \n    b = (b << 16u) | (b >> 16u);\n    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);\n    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);\n    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);\n    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);\n    \n    float r = float(b) * 2.3283064365386963e-10;\n    \n    return vec2((i / n), r);\n} \n\nvec3 ImportanceSample(in vec2 xi, in float r, in vec3 n)\n{\n\tfloat a = (r * r);\n    \n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));\n    \n    vec3 H = vec3((sinTheta * cos(phi)), (sinTheta * sin(phi)), cosTheta);\n    \n    vec3 upVector = StepValue3(0.999, n.z, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    vec3 tangentX = normalize(cross(upVector, n));\n    vec3 tangentY = cross(n, tangentX);\n    \n    return ((tangentX * H.x) + (tangentY * H.y) + (n * H.z));\n}\n\nvec3 CalcSpecularIBL(in vec3 n, in vec3 v, in vec3 f0, inout vec3 f1, in float r)\n{\n    vec3 totalSpec = vec3(0.0);\n    vec3 toSurfaceCenter = reflect(-v, n);\n    \n    for(float i = 0.0; i < IBLSteps; ++i)\n    {\n    \tvec2 xi = Hammersley(i, IBLSteps);\n        vec3 H  = ImportanceSample(xi, r, n);\n        vec3 L  = (2.0 * dot(v, H) * H) - v;\n        \n        float NoV = clamp(dot(n, v), 0.0, 1.0);\n        float NoL = clamp(dot(n, L), 0.0, 1.0);\n        float NoH = clamp(dot(n, H), 0.0, 1.0);\n        float VoH = clamp(dot(v, H), 0.0, 1.0);\n        \n        if(NoL > 0.0)\n        {\n            vec3 color = SampleEnvironment(L);\n            \n            float geoAtten = CalcAttenIBL(r, NoL, NoV);\n            vec3  fresnel  = CalcFresnel(n, v, f0);\n            \n            f1 += fresnel;\n            totalSpec += (color * fresnel * geoAtten * VoH) / (NoH * NoV);\n        }\n    }\n    \n    f1 /= IBLSteps;\n    \n    return (totalSpec / IBLSteps);\n}\n\nvec3 CalculateLightingAnalytical(in vec3 n, in vec3 l, in vec3 v, in vec3 a, in float r, in float m)\n{\n    vec3 f0 = mix(vec3(0.04), a, m);\n    vec3 ks = vec3(0.0);\n    vec3 d  = CalcDiffuse(a);\n    vec3 s  = CalcSpecularAnalytical(n, l, v, f0, ks, r);\n    vec3 kd = (1.0 - ks);\n    \n    return ((kd * d) + s) * clamp(dot(n, l), 0.0, 1.0);\n}\n\nvec3 CalculateLightingIBL(in vec3 n, in vec3 v, in vec3 a, in float r, in float m)\n{\n    vec3 f0 = mix(vec3(0.04), a, m);\n    vec3 ks = vec3(0.0);\n    vec3 d  = CalcDiffuse(a);\n    vec3 s  = CalcSpecularIBL(n, v, f0, ks, r);\n    vec3 kd = (1.0 - ks);\n    \n    return ((kd * d) + s);\n}\n\nfloat CalculateShadow(vec3 surfPos, vec3 lightOrigin)\n{\n    RayHit hit;\n    \n    float result   = 1.0;\n    vec3  lightRay = normalize(surfPos - lightOrigin);\n    int   steps    = 0;\n    \n    for(float depth = NearClip; (depth < (FarClip - Epsilon)) && (steps < ShadowSteps); ++steps)\n    {\n    \tvec3  point = (lightOrigin + (lightRay * depth));\n        float sdf   = Scene_SDF(point, hit);\n        \n        if(sdf < Epsilon)\n        {\n            return 0.0;\n        }\n        \n        result = min(result, (SoftShadowFactor * sdf) / depth);\n        \n        depth += sdf;\n    }\n    \n    return result;\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\nRayHit RaymarchScene(in Ray ray)\n{\n    RayHit hit;\n    \n    hit.hit      = false;\n    hit.material = 0.0;\n    \n    float sdf   = FarClip;\n    int   steps = 0;\n    \n    for(float depth = NearClip; (depth < FarClip) && (steps < MarchSteps); ++steps)\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos, hit);\n        \n        if(sdf < Epsilon)\n        {\n            hit.hit      = true;\n            hit.surfPos  = pos;\n            hit.surfNorm = Scene_Normal(pos);\n            \n            return hit;\n        }\n        \n        depth += sdf;\n    }\n    \n    return hit;\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\nvec3 Material_Apply(in RayHit hit, vec3 toView)\n{\n    vec3  albedo    = vec3(0.3);\n    float roughness = 0.75;\n    float metallic  = 0.0;\n    float timeRatio = TimeRatio();\n    \n    if(IsM(MAT_Surface))\n    {\n        albedo = albedo;\n    }\n    else if(IsM(MAT_Eye))\n    {\n        // Point in space the eyes are looking at. \n        // The Y/Z are the same, but the X is different to give the vacant, unfocused look\n        vec3 lookAt = normalize(vec3(sign(hit.surfPos.x) * 0.55, -1.25 * HEAD_TILT, 5.0) - hit.surfPos);\n        \n        float angle = dot(hit.surfNorm, lookAt);\n        \n        albedo = mix(EyeOrange * 1.25, EyeYellow, abs(angle));      // Base eye color\n     \talbedo = albedo * step(angle, 0.995);                       // Pupil\n        \n        // The eyes are a fake emissive, and thus are not affected by the general scene lighting\n        return albedo * (0.25 + 0.65 * (timeRatio * 1.5));\n    }\n    else if(IsM(MAT_Socket))\n    {\n        albedo = vec3(0.01);\n        return albedo;\n    }\n    else if(IsM(MAT_Teeth))\n    {\n        albedo = vec3(0.5);\n        roughness = 0.2;\n    }\n    \n    vec3 lightDir    = normalize(vec3(0.0, 1.0, 0.15));\n    vec3 lightOrigin = hit.surfPos + (lightDir * (FarClip + SoftShadowOffset));\n    \n    vec3 direct  = CalculateLightingAnalytical(hit.surfNorm, lightDir, toView, albedo, roughness, metallic);\n    vec3 ambient = CalculateLightingIBL(hit.surfNorm, toView, albedo, roughness, metallic);\n    \n    float shadow = CalculateShadow(hit.surfPos, lightOrigin);\n    \n    vec3 lighting = max(vec3(0.05), (shadow * direct * RGB(215, 175, 255) * 1.5) + (ambient * 0.55));\n    \n    return lighting * max(1.0, (timeRatio + 0.3));\n}\n\nvec4 Render(vec2 fragCoord, Camera camera)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    vec4 final = vec4(0.0);\n    \n    Ray ray = Camera_GetRay(camera, uv);\n    RayHit rayHit = RaymarchScene(ray);\n    \n    if(rayHit.hit)\n    {\n        final.rgb = Material_Apply(rayHit, normalize(camera.origin - rayHit.surfPos));\n        final.a = 1.0;\n    }\n   \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nconst vec2 AAPoints[4] = vec2[](\n    vec2(-0.1,  0.4),\n    vec2( 0.4,  0.1),\n    vec2( 0.1, -0.4),\n    vec2(-0.4, -0.1));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera camera = Camera_LookAt(vec3(1.0, -1.0, 5.0), vec3(0.0, -0.5, 0.0));\n    \n#ifdef SSAA\n    fragColor = Render(fragCoord + AAPoints[0], camera);\n    \n    if(fragColor.a > (1.0 - Epsilon))\n    {\n        for(int i = 1; i < 4; ++i)\n        {\n            fragColor += Render(fragCoord + AAPoints[i], camera);\n        }\n\n        fragColor *= 0.25;\n    }\n#else\n    fragColor = Render(fragCoord, camera);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * --------------------------------\n * - Clocktown Silhouette\n * --------------------------------\n *\n * A 2D sillhouette of Clocktown made from 3D SDF values.\n *\n * --------------------------------\n * - Sources\n * --------------------------------\n *\n * No particular external shaders were referenced in this buffer.\n */\n\n#define Epsilon               0.001\n#define NearClip              Epsilon\n#define FarClip               20.0\n\n#define PI                    3.14159\n#define ONE_OVER_PI           0.31831\n#define ONE_OVER_TWO_PI       0.15915\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\n// if(a > b) { return ra; } else { return rb; }\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nvec3 RotY(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3((c * p.x) + (s * p.z), p.y, (-s * p.x) + (c * p.z));\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n  \tvec3  surfPos;\n    vec3  surfNorm;\n    float material;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// SDF Functions\n//------------------------------------------------------------------------------------------\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat SDF_Clocktown(vec3 point)\n{\n    float sdf = FarClip;\n    \n    vec3 rp = RotY(point, PI * 0.5);\n    \n    float groundSDF     = length(point - vec3(0.0, -19.15, 0.0)) - 17.0;\n    float towerBaseSDF  = udRoundBox(rp - vec3(0.0, -1.9, 0.0), vec3(0.075, 0.5, 0.075), 0.01);\n    float towerBallSDF  = length(point - vec3(0.0, -1.31, 0.0)) - 0.095;\n    float towerClockSDF = length(point - vec3(0.0, -1.525, 0.0)) - 0.125;\n    float towerSDF      = min(towerBaseSDF, min(towerClockSDF, towerBallSDF));\n    float wallsSDF      = udRoundBox(rp - vec3(0.0, -2.2, 0.0), vec3(0.1, 0.5, 0.85), 0.005);\n    \n    sdf = min(wallsSDF, min(towerSDF, groundSDF));\n    \n    return sdf;\n}\n\nfloat Scene_SDF(vec3 point, inout RayHit hit)\n{\n    return min(FarClip, SDF_Clocktown(point));\n}\n\nvec3 Scene_Normal(vec3 p)\n{\n    RayHit hit;\n    \n    float e = Epsilon;\n    \n\treturn clamp(normalize(vec3(\n        (Scene_SDF(vec3(p.x + e, p.y, p.z), hit) - Scene_SDF(vec3(p.x - e, p.y, p.z), hit)),\n        (Scene_SDF(vec3(p.x, p.y + e, p.z), hit) - Scene_SDF(vec3(p.x, p.y - e, p.z), hit)),\n        (Scene_SDF(vec3(p.x, p.y, p.z + e), hit) - Scene_SDF(vec3(p.x, p.y, p.z - e), hit)))), -1.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\nRayHit RaymarchScene(in Ray ray)\n{\n    RayHit hit;\n    \n    hit.hit      = false;\n    hit.material = 0.0;\n    \n    float sdf = FarClip;\n    \n    for(float depth = NearClip; depth < FarClip; )\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos, hit);\n        \n        if(sdf < Epsilon)\n        {\n            hit.hit      = true;\n            hit.surfPos  = pos;\n            hit.surfNorm = Scene_Normal(pos);\n            \n            return hit;\n        }\n        \n        depth += sdf;\n    }\n    \n    return hit;\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\nfloat Render(vec2 fragCoord, Camera camera)\n{\n    float final = 0.0f;\n    \n    Ray ray = Camera_GetRay(camera, (fragCoord.xy / iResolution.xy));\n    RayHit rayHit = RaymarchScene(ray);\n    \n    if(rayHit.hit)\n    {\n        final = 1.0f;\n    }\n   \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera camera = Camera_LookAt(vec3(0.0, -1.0, 5.0), vec3(0.0, -0.5, 0.0));\n    fragColor = vec4(vec3(0.0039, 0.0039, 0.0196), Render(fragCoord, camera));\n}\n\n// Ugly giants below\n\n/*const vec3 LegPoints[3] = vec3[](\n    vec3(-1.0, -1.11, 0.0), \n    vec3(-0.8, -1.5, 0.0), \n    vec3(-1.1, -2.0, 0.0));\n\nconst vec3 ArmPoints[3] = vec3[](\n    vec3(-1.0, -1.11, 0.0),\n    vec3(-0.7, -1.0, 0.0),\n    vec3(-0.6, -0.7, 0.0));\n\nfloat SDF_Giants(vec3 point)\n{\n    float sdf = FarClip;\n    \n    float upperLegsR = saturate(length(point - LegPoints[0]) / length(LegPoints[1] - LegPoints[0]));\n\tfloat lowerLegsR = saturate(length(point - LegPoints[1]) / length(LegPoints[2] - LegPoints[1]));\n    \n    float head = length(point - vec3(-1.0, -1.11, 0.0)) - 0.175;\n    \n    float legs = min(sdCapsule(point, LegPoints[0], LegPoints[1], mix(0.075, 0.05, upperLegsR)),\n                     sdCapsule(point, LegPoints[1], LegPoints[2], mix(0.05, 0.025, lowerLegsR)));\n    \n    float arms = min(sdCapsule(point, ArmPoints[0], ArmPoints[1], 0.05),\n                     sdCapsule(point, ArmPoints[1], ArmPoints[2], 0.04));\n    \n    \n    sdf = min(head, min(arms, legs));\n    \n    return sdf;\n}*/",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * --------------------------------\n * - Fireball\n * --------------------------------\n *\n * This buffer was adapted from:\n *\n *     'Hot Shower' - Kali\n *     https://www.shadertoy.com/view/4lf3Rj\n *\n * There are some key difference though, including:\n *\n *     (1) Use of Simplex Noise instead of the 'kaliset'. The kaliset\n *         produced too much of a dusty/particle appearance whereas\n *         the fireball needed to look more like flames.\n *\n *     (2) Adaptive step size. The original has a hardcoded step size value\n *         which produces circular artifacts at low step counts. To achieve\n *         a smooth appearance, excessively high steps counts (300+) were needed.\n *         These high step counts destroyed full-screen performance even on my 980 GTX Ti.\n *         Instead, the step size is based on the distance to the sphere (or\n *         if the ray does not intersect the sphere, then the FarClip). The\n *         resulting flame intensity is also scaled accordingly.\n *         So improved performance AND improved visuals. Win-win.\n *\n *     (3) The effect needed to diminish as it moves upward, whereas\n *         the original had a conservation of particles.\n *\n *     (4) Affect only a portion of the total buffer, as the effect occurs\n *         only on and immediately around the Moon.\n *\n * --------------------------------\n * - Other Sources\n * --------------------------------\n *\n * The Simplex Noise implementation is from:\n *\n *     'Simplex Noise Demo' - ssell\n *     https://www.shadertoy.com/view/MslBzf\n *\n * The hash is of course:\n *\n *     'Hash without Sine' - Dave_Hoskins\n *     https://www.shadertoy.com/view/4djSRW\n */\n\n#define Epsilon   0.001\n#define NearClip  Epsilon\n#define FarClip   3.0\n#define GlowDist  0.15       // Size of the bottom glow effect\n#define Glow      2.0        // Intensity of the bottom glow effect\n#define Steps     50.0       // Number of noise volume samples\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nfloat TimeRatio()\n{\n\t// 3 seconds inactive (0), 3 seconds ramp up, 3 seconds active (1), 3 seconds ramp down\n    float mt = mod(iTime + 2.0, 12.0);\n\treturn StepValue(mt, 3.0, StepValue(mt, 10.0, mix(1.0, 0.0, (mt - 9.0) / 3.0), mix(0.0, 1.0, min(1.0, (mt - 3.0) / 3.0))), 0.0);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat SimplexNoiseRaw(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat SimplexNoise(\n    vec3  pos,\n    float octaves,\n    float scale,\n    float persistence)\n{\n    float final        = 0.0;\n    float amplitude    = 1.0;\n    float maxAmplitude = 0.0;\n    \n    for(float i = 0.0; i < octaves; ++i)\n    {\n        final        += SimplexNoiseRaw(pos * scale) * amplitude;\n        scale        *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude    *= persistence;\n    }\n    \n    return (final / maxAmplitude);\n}\n\n\nfloat Noise(vec3 p)\n{\n    return max(0.0, (SimplexNoise(p, 3.0, 2.0, 0.75) * 1.2) - 0.2);\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarch\n//------------------------------------------------------------------------------------------\n\nfloat Scene_SDF(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat RaymarchScene(in Ray ray, inout float nearest)\n{\n    float sdf = FarClip;\n    \n    vec3 o = (ray.origin) + (ray.direction * 2.0);\n    \n    for(float depth = NearClip; depth < FarClip; )\n    {\n    \tvec3 pos = o + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos);\n        nearest = min(sdf, nearest);\n        \n        if(sdf < Epsilon)\n        {\n            return depth;\n        }\n        \n        depth += sdf;\n    }\n    \n    return FarClip;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------------------------------\n    // Build UVs and Camera\n    //--------------------------------\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    Camera camera = Camera_LookAt(vec3(1.0, -1.0, 5.0), vec3(0.0, -0.5, 0.0));\n    Ray ray = Camera_GetRay(camera, (fragCoord.xy / iResolution.xy));\n    \n    //--------------------------------\n    // Initialize values and/or early exit\n    //--------------------------------\n    \n    float intensity      = 0.0;\n    float depth          = 0.0;\n    float nearest        = FarClip;\n    float dToSphere      = RaymarchScene(ray, nearest);    // Initial scene raymarch to determine if we hit the sphere.\n    float stepSize       = dToSphere / Steps;              // To see the circular artifacts, replace with '= FarClip / Steps;'\n    float intensityScale = (stepSize / (FarClip / Steps));\n    \n    // Early exit if we do not come with 0.18 units of the sphere/moon\n    if(nearest > 0.18)\n    {\n        fragColor.a = 0.0;\n        return;\n    }\n    \n    //--------------------------------\n    // Sample the noise volume\n    //--------------------------------\n    \n    vec3 o = (ray.origin) + (ray.direction * 2.0);\n    \n    for(float i = 0.0; i < Steps; ++i)\n    {\n        vec3 p = o + (ray.direction * depth);\n        \n        if(Scene_SDF(p) < Epsilon)\n        {\n            depth += stepSize;\n            break;\n        }\n        else\n        {\n            float d = max(0.0, GlowDist - max(0.0, length(p) - 1.0) / 1.0) / GlowDist;\n            float x = max(0.2, -p.y * 2.0);\n\n            p -= d * normalize(p) * 0.5;\n            p += vec3(0.0, -iTime * 0.95, 0.0);\n            \n        \tintensity += (Noise(p) + (d * Glow * x)) * intensityScale;\n            depth += stepSize;\n        }\n    }\n    \n    //--------------------------------\n    // Mix the final color based on intensity and distance to source\n    //--------------------------------\n    \n    // Mix base color from bright to dark moving upwards\n    fragColor.rgb = mix(vec3(1.0, 0.5, 0.0), vec3(1.35, 1.2, 0.0), clamp((0.5 - uv.y) / 0.5, 0.0, 1.0));\n    \n    // Average the sampled steps (and darken as we move further away)\n    fragColor.a   = (intensity / Steps) * mix(0.5, 0.0, clamp(nearest / 0.175, 0.0, 1.0));\n    \n    // Increase brightness according to the time step we are in\n\tfragColor.a  *= (TimeRatio() * 7.5) * 0.5;\n    \n    // Increase transparency as we move upwards\n    fragColor.a  *= 1.0 - uv.y * 0.1;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * --------------------------------\n * - Background\n * --------------------------------\n *\n * Simple purple gradient background with an added Majora's Mask mask.\n * The mask might be too much, but I kind of like it. I tried to make\n * it subtle but not completely invisible at the same time.\n *\n * The full line code is probably excessive for the spikes, but it was\n * the easiest approach as I just had to pull it from a draft shader. \n *\n * --------------------------------\n * - Sources\n * --------------------------------\n *\n * The heart shape is adapted from:\n *\n *     'Heart - 2D' - iq\n *     https://www.shadertoy.com/view/XsfGRn\n */\n\n//------------------------------------------------------------------------------------------\n// Line Drawing Functions\n//------------------------------------------------------------------------------------------\n\n// Returns: (Distance to Line, % Along Line [0.0, 1.0])\nvec2 DistToLine2(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float frac = clamp((dot(pa, ba) / dot(ba, ba)), 0.0, 1.0);\n    \n    return vec2(length(pa - (ba * frac)), frac);\n}\n\nfloat Sharpen(float dist, float thickness)\n{\n    float r = (1.0 / min(iResolution.x, iResolution.y));\n    return smoothstep(r, -r, dist - thickness);\n}\n\n// Draws a line from A to B that tapers in thickness from T0 to T1\nfloat LineTaper(vec2 uv, vec2 a, vec2 b, float t0, float t1)\n{\n    vec2 d = DistToLine2(uv, a, b);\n    return Sharpen(d.x, mix(t0, t1, d.y));\n}\n\n//------------------------------------------------------------------------------------------\n// Background Drawing\n//------------------------------------------------------------------------------------------\n\nfloat Heart(vec2 uv)\n{\n    uv -= vec2(0.0, 0.25);\n    uv *= 0.8;\n    \n    uv.y = -0.1 - (uv.y * 1.3) + (abs(uv.x) * (1.0-abs(uv.x)));\n    \n    float r = length(uv);\n    float m = (1.0 / min(iResolution.x, iResolution.y));\n    \n    return mix(step(r, 1.0), 0.0, smoothstep(m, -m, 0.45 - r));\n}\n\nfloat Spikes(vec2 uv)\n{\n\tfloat t0 = 0.1;\n    float t1 = 0.005;\n    \n    float xmirror = sign(uv.x);   // Mirror across the y-axis to draw 2 spikes per call\n    \n    float top  = LineTaper(uv, vec2(0.3 * xmirror, 0.6), vec2(0.325 * xmirror, 0.95), t0, t1);\n    float side = max(max(LineTaper(uv, vec2(0.4 * xmirror, 0.3), vec2(0.8  * xmirror, 0.175), t0, t1),\n                         LineTaper(uv, vec2(0.3 * xmirror, 0.2), vec2(0.75 * xmirror, 0.0), t0, t1)),\n                     max(LineTaper(uv, vec2(0.2 * xmirror, 0.1), vec2(0.6  * xmirror, -0.125), t0, t1),\n                         LineTaper(uv, vec2(0.1 * xmirror, 0.0), vec2(0.45 * xmirror, -0.3), t0, t1)));\n    \n    return max(top, side);\n}\n\nvec3 Majora(vec2 uv, vec3 background, float scale)\n{\n    uv *= scale;\n    \n    float majora = max(Heart(uv), Spikes(uv));        // Majora is just a heart + spikes\n    vec3 color = background - (vec3(0.01) * majora);  // Subtract the Majora shape from background\n    \n    return color;\n}\n\nvec3 Background(vec2 uv)\n{\n    return mix(vec3(0.04706, 0.01176, 0.15686), vec3(0.03137, 0.00784, 0.09804), uv.y);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    fragColor.rgb = Majora(uv - vec2(0.0, -0.125), Background(uv), 0.85);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}