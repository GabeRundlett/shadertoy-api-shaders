{
    "Shader": {
        "info": {
            "date": "1725726762",
            "description": "Play with smooth min sdf functions and try reciprocals. It is different.\nFew options are fully associative.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "lfjBDd",
            "likes": 5,
            "name": "Smooth min Dancer",
            "published": 3,
            "tags": [
                "sdf",
                "smooth",
                "minimum"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 116
        },
        "renderpass": [
            {
                "code": "/*\nPlaying with smooth minimum functions ...\nFew are fully associative.\n\nLeft is original (Dancer2_0)\nMiddle is my reciprocal method (Dancer2_recip)\nRight is an exponential method (Dancer2_exp)\n\nI did not come across a mention of reciprocals.\nIt is not very smooth but offers a controllable effect with few artifacts.\nAs you might expect, a thickness parameter less than the source object causes it to disappear.\nIt may be closer to an SDF scaling function.\nNormal epsilon had to be reduced a little.\n\nMy control of the exponential smooth minimum is different.\nI wanted to vary from 0 to a full effect.\nAt low effect, component SDF boundaries are enlarged and\nthere are artifacts and marching requires adjacent objects to work.\nThe dancers are spaced far apart so some of the artifacts can be observed.\nHit Rewind button to see.\n\nI have yet to try circular and https://www.shadertoy.com/view/ld2GRz\nRef: https://iquilezles.org/articles/smin/\n\n*/\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define min3(A,B,C) min(A,min(B,C))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\nmat3 MAT3xy(float ANG) { return mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 ); }\n\n// *********************************************************************************\n\nstruct DAN {\n    float luarm, ruarm;   // spread arms apart 0-3 radians\n    float lelbow, relbow; // bend elbows 0-3 radians\n    float lshoulder, rshoulder; // raise arms in front 0-3 radians\n    //float lrota, rrota; // upper arm rotation -1 - 1 radians\n    float lknee, rknee;  // bend knees 0-3 radians\n    float luleg, ruleg;  // spread legs apart 0-1.5 radians\n    float lhip, rhip;    // raise legs in front 0-3 radians\n    float spin;\n    float leanl, leanf;\n    float hop;\n    // results\n    vec3 _head, _hips; // body\n    vec3 _lshoulder,_lelbow, _lhand;\n    vec3 _rshoulder, _relbow, _rhand;\n    vec3 _lknee, _lhip, _lfoot;\n    vec3 _rknee, _rhip, _rfoot;\n    float _bottom;\n};\n\n#define DANIni(D) \\\n  D.luarm=0.; D.lelbow=0.; D.ruarm=0.; D.relbow=0.; D.luleg=0.; D.lknee=0.; D.ruleg=0.; D.rknee=0.; \\\n  D.lshoulder=0.; D.rshoulder=0.; D.lhip=0.; D.rhip=0.; \\\n  D.spin=0.; D.leanl=0.; D.leanf=0.; D.hop=0.; \\\n  /* D.lrota=0.; D.rrota=0.; */\n\n// alternative to .5-.5*cos(P)\n//float tri(float i) {  return 1. - abs( fract(i)*2. - 1. ); }\n//#define cosp(P) SS(tri((P))) \n\n#define MOVE(FLD,P,L,H) FLD=((.5-.5*cos(P))*((H)-(L))+(L));\n#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) );\n#define STDY(FLD,VAL) FLD = (VAL);\n\n// *********************************************************************************\n\nDAN Jill;\n\nvoid animJill() {\n    DANIni(Jill);\n    //HOP( Jill, 15., 40., fract(iTime*2.) )\n    MOVE(Jill.lelbow,iTime*1.,.2,1.);\n    MOVE(Jill.relbow,iTime*2.,.1,1.);\n    MOVE(Jill.lshoulder,iTime*-2.,0.,2.2);\n    MOVE(Jill.rshoulder,iTime*-1.,0.,1.8);\n    MOVE(Jill.luarm,iTime*1.,0.,.5);\n    MOVE(Jill.ruarm,iTime*3.,0.,1.5);\n    MOVE(Jill.rhip,iTime*5.,0.,1.);\n    MOVE(Jill.rknee,iTime*-7.,0.,1.);\n    MOVE(Jill.ruleg,iTime*3.,0.,1.);\n    STDY( Jill.luleg, -.075 );\n    STDY( Jill.spin, -iTime );\n    MOVE(Jill.leanf,iTime*1.5,-.5,.5);\n}\n\n// -----------------------------------------------------------------------------\n\n#define DSZ 20.\n\nvoid CompDancer(inout DAN m) {\n    m._hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf) * MAT3xz( m.spin ) /* * MAT3xy(m.leanl) */;\n    m._head = m._hips + vec3(0,.33,0)*DSZ * rott;\n\n    vec3 shoulders = mix( m._hips, m._head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    m._lshoulder = shoulders - vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder ) * MAT3xy( m.luarm ) * rott;\n    m._lelbow = m._lshoulder + vec3(0,-.14,0)*DSZ * rott;\n    rott = MAT3zy( -m.lelbow ) * rott;\n    m._lhand = m._lelbow + vec3(0,-.14,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    m._rshoulder = shoulders + vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder ) * MAT3xy( -m.ruarm ) * rott;\n    m._relbow = m._rshoulder + vec3(0,-.14,0)*DSZ * rott;\n    rott = MAT3zy( -m.relbow ) * rott;\n    m._rhand = m._relbow + vec3(0,-.14,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    m._lhip = m._hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  MAT3xy( m.luleg - m.leanl ) * MAT3zy( -m.lhip -  m.leanf ) * rott;\n    m._lknee = m._lhip + vec3(0,-.18,0)*DSZ * rott;\n    // rott = MAT3zy( m.lknee ) * rott; // not used by Jill\n    m._lfoot = m._lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    m._rhip = m._hips + vec3(.025,0,0)*DSZ * rott;\n    rott = MAT3xy( -m.ruleg - m.leanl ) * MAT3zy( -m.rhip  - m.leanf ) * rott;\n    m._rknee = m._rhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.rknee ) * rott;\n    m._rfoot = m._rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    m._bottom = min3( m._lfoot.y, m._rfoot.y, m._hips.y-.035*DSZ/3. ) - m.hop;\n\n}\n\n/*\n// circular geometrical  - https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0/(1.0-sqrt(0.5));\n    return max(k,min(a,b)) -\n           length(max(k-vec2(a,b),0.0));\n}\n\np = min( Dn )\nq = sumsq( max( 0 , k' - Dn ) )\n\nres = max( k', p ) - sqrt( q )\n\n*/\n\n/* IQ, of course.\nhttps://www.shadertoy.com/view/ld2GRz\nfloat sdMetaBalls( vec3 pos )\n{\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat dmin = 1e20;\n\t\t\n\tfloat h = 1.0; // track Lipschitz constant\n\t\n\tfor( int i=0; i<numballs; i++ )\n\t{\n\t\t// bounding sphere for ball\n        float db = length( blobs[i].xyz - pos );\n        if( db < blobs[i].w )\n    \t{\n    \t\tfloat x = db/blobs[i].w;\n    \t\tp += 1.0 - x*x*x*(x*(x*6.0-15.0)+10.0);\n\t    \tm += 1.0;\n    \t\th = max( h, 0.5333*blobs[i].w );\n\t    }\n\t    else // bouncing sphere distance\n\t    {\n    \t\tdmin = min( dmin, db - blobs[i].w );\n    \t}\n\t}\n    float d = dmin + 0.1;\n\t\n\tif( m>0.5 )\n\t{\n\t\tfloat th = 0.2;\n\t\td = h*(th-p);\n\t}\n\t\n\treturn d;\n}\n\n\n*/\n\n//#define iTime 23.\n//#define iTime 0.\n\n#define SPD 5.\n\nint mode;\n\nfloat Dancer2_0(vec3 pt,DAN m) {\n    pt.y += m._bottom;\n    float dist = 1e24;\n    float tmp;\n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); if ( tmp < dist ) dist = tmp;\n    ADD(m._head,m._hips,.035)\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return dist;\n}\n\nfloat Dancer2_recip(vec3 pt,DAN m) {\n    pt.y += m._bottom;\n    float dist = 0.;\n    float tmp;\n#undef ADD    \n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); \\\n dist += 1. / max( 1e-10, (tmp)+.6-mod(iTime/SPD,4.) );\n    ADD(m._head,m._hips,.035)\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return 1. / dist;\n}\n\nfloat Dancer2_exp(vec3 pt,DAN m) {\n    pt.y += m._bottom;\n    float dist = 0.;\n    float tmp;\n    float smth = 1.;\n    float ctrl = (4./(mod(iTime/SPD,4.)+.001));\n#undef ADD    \n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); \\\n dist += exp2( -( tmp * ctrl ) / smth);\n    ADD(m._head,m._hips,.035)\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return ( - smth - log2(dist) ) / ctrl;\n}\n\n// Terrain -------------------------------------\n\nfloat rndd(vec2 pt) {\n  pt += vec2(13.43544,31.2434);\n  return fract( sin(mod(pt.x*pt.y,TAU)) * 89.367456 );\n}\n\n// smooth step S curve\nfloat SS(float C) { return ((C)*(C)*(3.-2.*(C))); }\n\nfloat height(vec2 pt) { // 0-1\n    vec2 f = floor(pt);\n    vec2 r = fract(pt);\n    vec2 o = vec2(1,0);\n    float xf = SS(r.x);\n    return mix(\n       mix( rndd(f), rndd(f+o), xf ), // mid points of x edges\n       mix( rndd(f+o.yx), rndd(f+o.xx), xf ),\n       SS(r.y) );\n}\n\nfloat height2(vec3 pt) { return pt.y /*- height(pt.xz*.03)*10.*/ - pt.z*.3 + 5.; }\n\nfloat texture(vec2 pt) { return .5 + height(pt*50.)*.5; }\n\n// Map --------------------------------------------------------------\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.; \n    T( Dancer2_0( (pt-vec3(-40,-5,0)), Jill ) )\n    T( Dancer2_recip( (pt-vec3(0,-5,0)), Jill ) )\n    T( Dancer2_exp( (pt-vec3(40,-5,0)), Jill ) )\n    clr = 3.;\n    T( height2(pt) )\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .01 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float EPSILON = .0001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(EPSILON, 0., 0.)).x, \n        Dist(pt-vec3( 0.,EPSILON, 0.)).x, \n        Dist(pt-vec3( 0., 0.,EPSILON)).x );\n    return normalize( norm );\n}\n\n// --------------- main ------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    animJill();\n    CompDancer(Jill);\n\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv *= .5; // field of view\n    vec3 cam = vec3( 0., 10., -64.);\n    //vec3 cam = vec3( 0.+sin(iTime*.3)*5., 10.+cos(iTime*.2)*3., -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n\n    vec4 hit = March( cam, camdir );\n\n    vec3 Light = vec3( 60., 30, -60 );\n    //vec3 Light = vec3( sin(iTime)*40., 30, -30 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec4 shadow = March( hit.xyz+dir*.4, dir );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = .3 + .7*difu;\n    if ( shadow.z > -10. ) difu = .2;\n    \n    #define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    O = color4(hit.w*.4);\n    \n    // ground pattern\n    if ( hit.w == 3. ) O = mix(O,vec4(0,.3,0,1),clamp(texture(hit.xz*.1),0.,1.));\n    \n    O *= difu;\n    \n    // sky pattern\n    //if ( hit.w >= 90. ) O = vec4(.2,.4,.8,1.);\n    if ( hit.w >= 90. ) O=mix(vec4(.2,.4,.8,1.),vec4(1),clamp(height(U*vec2(.01,.1))*10.-9.,0.,1.));\n    \n    O = sqrt(O);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}