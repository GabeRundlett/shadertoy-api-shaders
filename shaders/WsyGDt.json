{
    "Shader": {
        "info": {
            "date": "1571170352",
            "description": "Raymarching Refresher 2\n\nTODO:\n\n- More interesting scene\n- Ia calculated\n- Many materials\n- Soft/hard shadows\n- Reflections\n- Background\n- Texturing (ambient, diffuse, specular maps?)\n- Bump mapping\n- Refractions\n- AO",
            "flags": 33,
            "hasliked": 0,
            "id": "WsyGDt",
            "likes": 0,
            "name": "Raymarching Refresher 2",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "kaoD",
            "viewed": 259
        },
        "renderpass": [
            {
                "code": "struct Sphere {\n    vec3 p;\n    float r;\n};\n    \nstruct Phong {\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nstruct Light {\n    vec3 p;\n    Phong phong;\n};\n    \nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\n// Raymarching config\nconst float HIT_DIST = .001;\nconst float MAX_DIST = 100.;\nconst int MAX_ITERS = 100;\n\n// Normals config\nconst float NORMAL_E = .001;\n\n// Scene config\nconst Sphere SPHERE1 = Sphere(vec3(.9, 0, -3), 1.);\nconst Sphere SPHERE2 = Sphere(vec3(-.5, 0, -3), 1.);\nconst Light LIGHT1 = Light(\n    vec3(1, 1, -1),\n    Phong(vec3(1, .3, .3), vec3(.3, 1, .3))\n);\nconst Material MATERIAL1 = Material(\n    vec3(0),\n    vec3(.7),\n    vec3(1),\n    40.\n);\n\n// Camera config\nconst vec3 RD = vec3(0, 0, -1);\nconst vec3 RO = vec3(0, 0, 0);\nconst float ZOOM = 1.;\n\n// Coordinate system config\nconst vec3 UP = vec3(0, 1, 0);\n\n////\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nfloat opSmoothU(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\nfloat sdScene(vec3 p) {\n    return opSmoothU(\n        sdSphere(SPHERE1.p - p, SPHERE1.r * sin(iTime + 1.)/4. + .75),\n        sdSphere(SPHERE2.p - p, SPHERE2.r * sin(iTime)/4. + .75),\n        1.\n    );\n}\n\nvec3 getNormal(vec3 p) {\n    const vec2 k = vec2(1, -1);\n    \n    return normalize(\n        k.xyy * sdScene(p + k.xyy * NORMAL_E) +\n        k.yxy * sdScene(p + k.yxy * NORMAL_E) +\n        k.yyx * sdScene(p + k.yyx * NORMAL_E) +\n        k.xxx * sdScene(p + k.xxx * NORMAL_E)\n    );\n}\n\nvec3 getNormal2(vec3 p) {\n    const vec2 e = vec2(NORMAL_E, 0);\n    \n    return normalize(vec3(\n        sdScene(p + e.xyy),\n        sdScene(p + e.yxy),\n        sdScene(p + e.yyx)\n    )) / NORMAL_E;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0;; i++) {\n        vec3 p = ro + rd*d;\n        \n        float sd = sdScene(p);\n        \n        if (sd <= HIT_DIST) {\n            return d;\n        }\n        \n        d += sd;\n        \n        if (d > MAX_DIST || i - 1 == MAX_ITERS) {\n            return MAX_DIST;\n        }\n    }\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 rd) {\n    vec3 f = rd;\n    vec3 r = cross(UP, f);\n    vec3 u = cross(f, r);\n    \n    return normalize(rd*ZOOM + r*uv.x + u*uv.y);\n}\n\nvec3 getLightPhong(vec3 rd, vec3 p, vec3 n, Light light, Material material) {\n    vec3 ld = normalize(light.p - p);\n    vec3 rr = normalize(reflect(-ld, n));\n    \n    return (\n        material.diffuse * light.phong.diffuse * max(dot(ld, n), 0.) +\n        material.specular * light.phong.specular * pow(max(dot(rd, rr), 0.), material.shininess)\n    );\n}\n\nvec3 getPhong(vec3 ro, vec3 p) {\n    vec3 rd = normalize(ro - p);\n    vec3 n = getNormal(p);\n    \n    const vec3 Ia = vec3(1.);\n    \n    return MATERIAL1.ambient * Ia + getLightPhong(rd, p, n, LIGHT1, MATERIAL1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    \n    if (iResolution.x > iResolution.y) {\n        uv.x *= iResolution.x/iResolution.y;\n    } else {\n        uv.y *= iResolution.y/iResolution.x;\n    }\n\n    vec3 rd = getRayDir(uv, RO, RD);\n    float d = rayMarch(RO, rd);\n    vec3 p = RO + rd*d;\n        \n    vec3 col;\n    \n    if (d == MAX_DIST) {\n        col = vec3(0);\n    } else {\n        col = vec3(getPhong(RO, p));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOrig, in vec3 rayDir ) {\n    float d = rayMarch(rayOrig, rayDir);\n    vec3 p = rayOrig + rayDir*d;\n\n    vec3 col;\n\n    if (d == MAX_DIST) {\n        col = vec3(texture(iChannel2, fragCoord/iResolution.xy));\n    } else {\n        col = vec3(getPhong(rayOrig, p));\n    }\n\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}