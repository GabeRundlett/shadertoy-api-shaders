{
    "Shader": {
        "info": {
            "date": "1693166036",
            "description": "This is a 3D representation of a hydrogen atom wave function. Feel free to play with quantum numbers (n, l, m) to change the wave function and get interesting shapes.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlXfRj",
            "likes": 3,
            "name": "Hydrogen Atom Wave Function",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "physics",
                "quantum",
                "atom",
                "wavefunction",
                "hydrogen"
            ],
            "usePreview": 0,
            "username": "David654",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "/*\nAuthor: David Lapidus\n*/\n\n#define N 8                      // [1; âˆž];\n#define L 4                      // [0; N - 1];\n#define M -1                     // [-L; L]\n#define AXIS_SECTION_TYPE 2      // 0 -> None; 1 -> X-Axis; 2 -> Y-Axis; 3 -> Z-Axis\n#define COLOR_SCHEME 2\n#define FOV 60.0\n#define MAX_DIST 128.0\n#define MAX_STEPS 256\n#define ANTIALIASING 0           // Does not work properly with axis section at the moment\n#define ZOOM 1.0\n#define MANUAL_CAMERA 0\n\nconst float PI = 3.1415926;\nconst float E = 2.7182818;\nconst float BOHR_RADIUS = 0.005291772; // Increasing/decreasing this parameter may change the level of detail\nconst float REDUCED_PLANCK_CONSTANT = 1.054571817e-34;\n\nconst float EPSILON = 0.001;\n\nvec3 rotateX(in vec3 v, in float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(1, 0, 0, 0, cos, -sin, 0, sin, cos);\n}\n\nvec3 rotateY(in vec3 v, in float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, 0, sin, 0, 1, 0, -sin, 0, cos);\n}\n\nvec3 rotateZ(in vec3 v, in float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, -sin, 0, sin, cos, 0, 0, 0, 1);\n}\n\nvec3 mouseControl(in vec3 p)\n{\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    p = rotateX(p, -m.y * PI * 0.5 - 1.5);\n    p = rotateZ(p, -m.x * 2.0 * PI + PI);\n\n    return p;\n}\n\nvec3 CMRmap(in float t) // https://www.shadertoy.com/view/Nd3fR2\n{\n    const vec3 c0 = vec3(-0.046981,0.001239,0.005501);\n    const vec3 c1 = vec3(4.080583,1.192717,3.049337);\n    const vec3 c2 = vec3(-38.877409,1.524425,20.200215);\n    const vec3 c3 = vec3(189.038452,-32.746447,-140.774611);\n    const vec3 c4 = vec3(-382.197327,95.587531,270.024592);\n    const vec3 c5 = vec3(339.891791,-100.379096,-212.471161);\n    const vec3 c6 = vec3(-110.928480,35.828481,60.985694);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nstruct ComplexNumber\n{\n    float Re;\n    float Im;\n};\n\nfloat absoluteValueOfComplexNumber(ComplexNumber c)\n{\n    return sqrt(pow(c.Re, 2.0) + pow(c.Im, 2.0));\n}\n\nComplexNumber multiplyByScalar(ComplexNumber c, float a)\n{\n    return ComplexNumber(c.Re * a, c.Im * a);\n}\n\nComplexNumber multiplyByComplexNumber(ComplexNumber c, ComplexNumber a)\n{\n    return ComplexNumber(c.Re * a.Re - c.Im * a.Im, c.Re * a.Im + c.Im * a.Re);\n}\n\nfloat factorial(int a)\n{\n    float result = 1.0;\n\n    for(int i = 1; i <= a; i++)\n    {\n        result *= float(i);\n    }\n\n    return result;\n}\n\nfloat calculateAssociatedLegendrePolynomial(int l, int m, float x)\n{\n    float cos = cos(x);\n    float powM = m % 2 == 0 ? 1.0 : -1.0;\n    float p1 = powM / (exp2(float(l)) * factorial(l)) * pow(1.0 - cos * cos, float(m) / 2.0);\n    \n    int order = l + m;\n    float derivative = 0.0;\n\n    for(int i = 0; i <= l; i++)\n    {\n        float powI = i % 2 == 0 ? 1.0 : -1.0;\n        float a = factorial(l) / (factorial(i) * factorial(l - i)) * powI;\n        float power = 2.0 * float(l - i);\n\n        for(int j = 0; j < order; j++)\n        {\n            a *= power;\n            power--;\n        }\n\n        float cosSign = sign(cos) * (int(power) % 2 == 0 ? 1.0 : -1.0);\n        derivative += a * pow(abs(cos), power) * cosSign;\n    }\n    \n    return p1 * derivative;\n    \n    // Precalculated Associated Legendre Polynomials\n    /*float sin = sin(x);\n    float cos = cos(x);\n\n    float p = 0.0;\n\n    // https://en.wikipedia.org/wiki/Associated_Legendre_polynomials\n    if(l == 0 && m == 0)\n    {\n        p = 1.0;\n    }\n    else if(l == 1 && m == 0)\n    {\n        p = cos;\n    }\n    else if(l == 1 && abs(m) == 1)\n    {\n        p = -sin * (m > 0 ? 1.0 : -0.5);\n    }\n    else if(l == 2 && abs(m) == 0)\n    {\n        p = 0.5 * (3.0 * cos * cos - 1.0);\n    }\n    else if(l == 2 && abs(m) == 1)\n    {\n        p = -3.0 * sin * cos * (m > 0 ? 1.0 : -1.0 / 6.0);\n    }\n    else if(l == 2 && abs(m) == 2)\n    {\n        p = 3.0 * sin * sin * (m > 0 ? 1.0 : 1.0 / 24.0);\n    }\n    else if(l == 3 && abs(m) == 0)\n    {\n        p = 0.5 * cos * (5.0 * cos * cos - 3.0);\n    }\n    else if(l == 3 && abs(m) == 1)\n    {\n        p = -1.5 * (5.0 * cos * cos - 1.0) * sin * (m > 0 ? 1.0 : -1.0 / 12.0);\n    }\n    else if(l == 3 && abs(m) == 2)\n    {\n        p = 15.0 * cos * sin * sin * (m > 0 ? 1.0 : 1.0 / 120.0);\n    }\n    else if(l == 3 && abs(m) == 3)\n    {\n        p = -15.0 * sin * sin * sin * (m > 0 ? 1.0 : -1.0 / 720.0);\n    }\n    else if(l == 4 && abs(m) == 0)\n    {\n        p = 1.0 / 8.0 * (35.0 * pow(cos, 4.0) - 30.0 * pow(cos, 2.0) + 3.0);\n    }\n    else if(l == 4 && abs(m) == 1)\n    {\n        p = -2.5 * (7.0 * pow(cos, 3.0) - 3.0 * cos) * sqrt(1.0 - pow(cos, 2.0)) * (m > 0 ? 1.0 : -1.0 / 20.0);\n    }\n    else if(l == 4 && abs(m) == 2)\n    {\n        p = 7.5 * (7.0 * pow(cos, 2.0) - 1.0) * (1.0 - pow(cos, 2.0)) * (m > 0 ? 1.0 : 1.0 / 360.0);\n    }\n    else if(l == 4 && abs(m) == 3)\n    {\n        p = -105.0 * cos * pow(1.0 - pow(cos, 2.0), 1.5) * (m > 0 ? 1.0 : -1.0 / 5040.0);\n    }\n    else if(l == 4 && abs(m) == 4)\n    {\n        p = 105.0 * pow(1.0 - pow(cos, 2.0), 2.0) * (m > 0 ? 1.0 : 1.0 / 40320.0);\n    }\n\n    return p;**/\n}\n\nComplexNumber calculateSphericalHarmonics(int l, int m, float theta, float phi)\n{\n    float a = sqrt((2.0 * float(l) + 1.0) * factorial(l - m) / (4.0 * PI * factorial(l + m)));\n    float P = calculateAssociatedLegendrePolynomial(l, m, theta);\n    ComplexNumber phaseFactor = ComplexNumber(cos(float(m) * phi), sin(float(m) * phi));\n    phaseFactor = multiplyByScalar(phaseFactor, a * P);\n    return phaseFactor;\n}\n\nfloat calculateAssociatedLaguerrePolynomial(int r, int s, float x)\n{\n    float sum = 0.0;\n\n    for(int q = 0; q <= s; q++)\n    {\n        float f = q % 2 == 0 ? 1.0 : -1.0;\n        sum += f * pow(factorial(s + r), 2.0) * pow(x, float(q)) / (factorial(s - q) * factorial(r + q) * factorial(q));\n    }\n\n    return sum;\n}\n\nfloat calculateRadialFunction(int n, int l, float r)\n{\n    float a = sqrt(pow(2.0 / float(n) / BOHR_RADIUS, 3.0) * factorial(n - l - 1) / (2.0 * float(n) * pow(factorial(n + l), 3.0)));\n    float b = pow(2.0 * r / float(n) / BOHR_RADIUS, float(l)) * exp(-r / float(n) / BOHR_RADIUS);\n    float c = calculateAssociatedLaguerrePolynomial(2 * l + 1, n - l - 1, 2.0 * r / float(n) / BOHR_RADIUS);\n\n    return a * b * c;\n}\n\nComplexNumber calculateWaveFunction(int n, int l, int m, float r, float theta, float phi)\n{\n    float radialFunction = calculateRadialFunction(n, l, r);\n    ComplexNumber sphericalHarmonics = calculateSphericalHarmonics(l, m, theta, phi);\n\n    float E = -13.606 / pow(float(n), 2.0);\n    float phaseFactor = E * iTime / REDUCED_PLANCK_CONSTANT;\n    ComplexNumber phase = ComplexNumber(cos(phaseFactor), -sin(phaseFactor));\n\n    //return multiplyByComplexNumber(multiplyByScalar(sphericalHarmonics, radialFunction), phase);\n    return multiplyByScalar(sphericalHarmonics, radialFunction);\n}\n\nvec3 createAtom(vec3 p)\n{\n    if(MANUAL_CAMERA == 0)\n    {\n        p = rotateX(p, PI / 2.0);\n        p = rotateZ(p, -iTime);\n    }\n    else if(MANUAL_CAMERA == 1)\n    {\n        p = mouseControl(p);\n    }\n\n    float r = length(p);\n    float theta = acos(p.z / r);\n    float phi = atan(p.y, p.x);\n\n    ComplexNumber waveFunction = calculateWaveFunction(N, L, M, r, theta, phi);\n    ComplexNumber sphericalHarmonics = calculateSphericalHarmonics(L, M, theta, phi);\n    float wF = absoluteValueOfComplexNumber(waveFunction);\n    float atomDist = length(p) - wF;\n    //atomDist = min(atomDist, 0.0);\n\n    // Cross-section Slice\n    if(AXIS_SECTION_TYPE == 1) atomDist = max(min(atomDist, MAX_DIST), p.x);\n    else if(AXIS_SECTION_TYPE == 2) atomDist = max(min(atomDist, MAX_DIST), p.y);\n    else if(AXIS_SECTION_TYPE == 3) atomDist = max(min(atomDist, MAX_DIST), p.z);\n\n    vec3 atom = vec3(atomDist, wF, sphericalHarmonics.Im); //absoluteValueOfComplexNumber(sphericalHarmonics)\n\n    return atom;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(createAtom(p).x) - vec3(createAtom(p - e.xyy).x, createAtom(p - e.yxy).x, createAtom(p - e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{\n    float res = 1.0;\n    float dist = EPSILON;\n    float lightSize = 0.03;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 hit = createAtom(p + lightPos * dist);\n\n        res = min(res, hit.x / (dist * lightSize));\n        dist += hit.x;\n\n        if(hit.x < EPSILON || dist > 60.0)\n        {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat getAmbientOcclusion(vec3 p, vec3 normal)\n{\n    float occ = 0.0;\n    float weight = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        float len = 0.01 + 0.02 * float(i * i);\n        float dist = createAtom(p + normal * len).x;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\nvec3 HSLToRGB(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 blackbody(float i) \n{\n    float T = 1400. + 1400.*i; // Temperature range (in Kelvin).\n    vec3 l = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    l = pow(l,vec3(5.0)) * (exp(1.43876719683e5/(T*l))-1.0);\n    return 1.0-exp(-5e8/l); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\nvec3 getLight(vec3 p, vec3 rd, float waveFunction, float sphericalHarmonics, vec3 lightPos)\n{\n    vec3 finalCol = vec3(0, 0, 0);\n    vec3 v = -rd;\n    vec3 n = getNormal(p);\n\n    float r = length(p);\n    float theta = acos(p.z / r);\n    float phi = atan(p.y, p.x);\n\n    vec3 col = vec3(0);\n\n    // Color Schemes\n    if(COLOR_SCHEME == 0)\n    {\n        // Single color\n        col = vec3(1, 0, 0);\n    }\n    else if(COLOR_SCHEME == 1)\n    {\n        // Wave Function 1\n        col = vec3(clamp(waveFunction, 0.0, 1.0), 0, 0);\n    }\n    else if(COLOR_SCHEME == 2)\n    {\n        // // Wave Function 2\n        col = CMRmap(clamp(waveFunction * 0.9, 0.0, 1.0));\n    }\n    else if(COLOR_SCHEME == 3)\n    {\n        // Spherical Harmonics\n        col = normalize(HSLToRGB(vec3(sphericalHarmonics, 1, theta)));\n    }\n    else if(COLOR_SCHEME == 4)\n    {\n        col = blackbody(waveFunction);\n    }\n\n    vec3 l = normalize(lightPos - p);\n    vec3 R = reflect(-l, n);\n    vec3 H = normalize(l + v);\n\n    vec3 ambient = col * 0.1;\n    vec3 diffuse = col * clamp(dot(l, n), 0.0, 1.0);\n    vec3 specColor = vec3(0.1);\n    vec3 specular = specColor * pow(clamp(dot(R, v), 0.0, 1.0), 128.0);\n\n    // Soft Shadows\n    //float shadow = getSoftShadow(p + n * 0.02, lightPos);\n\n    // Ambient occlusion\n    float occ = getAmbientOcclusion(p, n);\n\n    // Reflections\n    vec3 back = 0.05 * col * clamp(dot(n, -l), 0.0, 1.0);\n\n    finalCol = (ambient + back) * occ + (diffuse + specular * occ);\n\n    return finalCol;\n}\n\nvec4[2] rayMarch(vec3 ro, vec3 rd, vec3 lightPos)\n{\n    vec3 hit;\n    vec3 object;\n    vec3 oh = vec3(0);\n    vec4 tmp = vec4(0);\n    float waveFunction;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // Raymarching\n        vec3 p = ro + object.x * rd;\n        hit = createAtom(p);\n\n        float px = 2.0 / iResolution.y;\n        float th1 = px * object.x;\n        th1 *= 1.5;\n\n        object.x += hit.x * 0.085;\n        object.y = hit.y;\n        object.z = hit.z;\n        int index = int(object.y) - 1;\n\n        if(hit.x < 0.0 || object.x > float(MAX_DIST))\n        {\n            break;\n        }\n\n        // Antialiasing\n        if(ANTIALIASING == 1)\n        {\n            if(abs(hit.x) < th1)\n            {\n                break;\n            }\n\n            float th2 = px * object.x * 20.0;\n            \n            if((abs(hit.x) < th2 && hit.x > oh.x))\n            {\n                float lalp = 1.0 - (hit.x - th1) / (th2 - th1);\n                vec3 lcol = getLight(p, rd, object.y, object.z, lightPos);\n                tmp.xyz += (1.0 - tmp.w) * lalp * lcol;\n                tmp.w += (1.0 - tmp.w) * lalp;\n                \n                if(tmp.w > 0.99)\n                {\n                    break;\n                }\n            }\n            \n            oh = hit;\n        }\n    }\n\n    vec4[2] res = vec4[](vec4(object, 0), tmp);\n    return res;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 position = vec3(0.0, 0.0, -3.0 + ZOOM);\n\n    vec3 ro = position;\n\n    float invTanFOV = 1.0 / (tan(FOV / 2.0 * PI / 180.0));\n    vec3 rd = normalize(vec3(uv, invTanFOV));\n\n    vec3 lightPos = vec3(0, 100, -100);\n\n    vec4 object[2] = rayMarch(ro, rd, lightPos);\n    vec3 col;\n\n    if(object[0].x < float(MAX_DIST))\n    {\n        vec3 p = ro + object[0].x * rd;\n\n        col = getLight(p, rd, object[0].y, object[0].z, lightPos);\n    }\n    else\n    {\n        col = vec3(0); // Background color\n    }\n\n    if(ANTIALIASING == 1)\n    {\n        vec4 tmp = object[1];\n        col = mix(col, tmp.xyz / (0.001 + tmp.w), tmp.w);\n    }\n\n    return col;\n}\n\nvec2 getUV(in vec2 offset, in vec2 fragCoord)\n{\n    return (2.0 * fragCoord.xy + offset - iResolution.xy) / iResolution.y;\n}\n\n// MSAAx1 (default)\nvec3 renderAAx1(in vec2 fragCoord)\n{\n    return render(getUV(vec2(0), fragCoord));\n}\n\n// MSAAx2 (slow)\nvec3 renderAAx2(in vec2 fragCoord)\n{\n    float bxy = float(int(fragCoord.x + fragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.33 * nbxy, 0.), fragCoord)) + render(getUV(vec2(0.33 * bxy, 0.66), fragCoord)));\n    return colAA / 2.0;\n}\n\n// MSAAx3 (slower)\nvec3 renderAAx3(in vec2 fragCoord)\n{\n    float bxy = float(int(fragCoord.x + fragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.66 * nbxy, 0.), fragCoord)) + render(getUV(vec2(0.66 * bxy, 0.66), fragCoord)) + render(getUV(vec2(0.33, 0.33), fragCoord)));\n    return colAA / 3.0;\n}\n\n// MSAAx4 (the slowest)\nvec3 renderAAx4(in vec2 fragCoord)\n{\n    vec4 e = vec4(0.125, -0.125, 0.375, -0.375);\n    vec3 colAA = render(getUV(e.xz, fragCoord)) + render(getUV(e.yw, fragCoord)) + render(getUV(e.wx, fragCoord)) + render(getUV(e.zy, fragCoord));\n    return colAA /= 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = renderAAx1(fragCoord);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}