{
    "Shader": {
        "info": {
            "date": "1599935236",
            "description": "Textured rectangular area light based on Unreal Engine's most representative point method.",
            "flags": 32,
            "hasliked": 0,
            "id": "wlSfW1",
            "likes": 47,
            "name": "Textured Rectangular Area Light",
            "published": 3,
            "tags": [
                "brdf",
                "arealight",
                "ibl",
                "fresnel",
                "schlick",
                "pbr",
                "ggx",
                "ndf"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 1727
        },
        "renderpass": [
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A small experimental follow up to my area lights shader (https://www.shadertoy.com/view/3dsBD4)\n* with a textured rectangular area light. See Buffer A for more details.\n*\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = textureLod(iChannel0, uv, 0.).rgb;\n    // for yucky color banding artifacts\n    col += hash12(fragCoord * iResolution.xy + vec2(iFrame)) * .003;\n    fragColor = vec4(pow(col, vec3(.4545)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* Helper functions and macros used for the rectangular area light in the mainImage buffer.\n*\n*/\n\n#define saturate(x) clamp(x, 0., 1.)\n#define dot2(x) dot(x, x)\n\n// Comment/uncomment these for different material settings\n#define FLOOR_DISPLACEMENT\n#define FLOOR_ROUGHNESS\n#define LIGHT_TEXTURE\n\n#define EPS .0002\n#define SMOL_EPS .0000002\n\n#define PI 3.1415926535\n#define TWO_PI 6.283185307\n#define PI_INV .3183098861\n\n#define RECT_LIGHT_RADIUS 1.25\n#define RECT_LIGHT_COLOR vec3(.6, .3, .15)\n#define RECT_LIGHT_INTENSITY 32.\n\nconst vec3 cameraPosition = vec3(0., 10., 25.);\nconst float cameraFar = 100.;\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n    \nstruct Rect\n{\n\tvec3 center, a, b, c, d; \n\tvec3 up, right, front;\n    vec2 halfSize;\n};\n    \nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1. / float(0xffffffffU));\n}\n\nmat3 rotY(float a)\n{\n\treturn mat3(cos(a), 0., sin(a),\n                \t0., 1., \t0.,\n               -sin(a), 0., cos(a));\n}\n\nmat3 rotX(float a)\n{\n\treturn mat3(1., \t0., \t 0.,\n                0., cos(a), -sin(a),\n                0., sin(a),  cos(a));\n}\n\nvec3 rotateYX(vec3 a, vec2 rot)\n{\n\treturn rotX(rot.y) * rotY(rot.x) * a;\n}\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay getCameraRay(vec2 uv)\n{\n    vec3 origin = cameraPosition;\n    vec3 target = vec3(0., 1., 0.);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, 2.5));\n    return Ray(origin, direction);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A small experimental follow up to my area lights shader (https://www.shadertoy.com/view/3dsBD4)\n* with a textured rectangular area light. The diffuse component of the light is based on the 5 sample\n* solid angle technique from the frostbite engine[1], and the specular technique is based on the most\n* representative point method from unreal engine[2]. For specular, a point on the rectangular light source\n* is calculated using the reflection vector originating from the shaded point. That point on the rectangle\n* is the new light vector using which normal pbr shading calculations are done. \n*\n* [1] Real Shading in Unreal Engine 4 -\n* (https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)\n* [2] Moving Frostbite to Physically Based Rendering 3.0 -\n* (https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf)\n*\n*/\n\nRect rect;\n\nvec2 sdUnion(vec2 a, vec2 b)\n{\n \treturn a.x < b.x ? a : b;  \n}\n\nvoid initRect(vec2 rot)\n{\n    rect.up = rotateYX(vec3(0., 1., 0.), rot);\n    rect.right = rotateYX(vec3(1., 0., 0.), rot);;\n    rect.front = normalize(cross(rect.right, rect.up));\n    rect.halfSize = vec2(5., 3.);\n    \n    rect.center = vec3(0., 5., 0.);\n    \n    rect.a = rect.center + rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.b = rect.center - rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.c = rect.center - rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n    rect.d = rect.center + rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n}\n\nfloat sdPlane(vec3 pos, float height)\n{\n\tfloat plane = pos.y - height;\n#ifdef FLOOR_DISPLACEMENT\n    return plane - textureLod(iChannel0, pos.xz * .02, 0.).r * .01;   \n#else\n    return plane;\n#endif\n}\n\nfloat sdPlaneNoDisplacement(vec3 pos, float height)\n{\n\treturn pos.y - height;\n}\n\nfloat sdRect(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross(ba, ad);\n\n    return sqrt(\n        (sign(dot(cross(ba, nor), pa)) +\n         sign(dot(cross(cb, nor), pb)) +\n         sign(dot(cross(dc, nor), pc)) +\n         sign(dot(cross(ad, nor), pd)) < 3.)\n\n        ?\n\n        min(min(min(\n\t\tdot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa),\n\t\tdot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)),\n\t\tdot2(dc * clamp(dot(dc, pc) / dot2(dc), 0., 1.) - pc)),\n\t\tdot2(ad * clamp(dot(ad, pd) / dot2(ad), 0., 1.) - pd))\n        \n        :\n        \n        dot(nor, pa) * dot(nor, pa) / dot2(nor) \n    );\n}\n\nvec2 sdScene(vec3 pos)\n{\n\tvec2 result = vec2(sdPlaneNoDisplacement(pos, -.75), 2.);\n    \n    result = sdUnion(result, vec2(sdRect(pos, rect.a, rect.b, rect.c, rect.d), 0.));\n    \n    return result;\n}\n\nvec2 sdSceneNormal(vec3 pos)\n{\n\treturn vec2(sdPlane(pos, -.75), 1.);\n}\n\nvec3 calculateNormal(vec3 pos)\n{\n\tvec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(sdSceneNormal(pos + eps.xyy).x, \n                          sdSceneNormal(pos + eps.yxy).x, \n                          sdSceneNormal(pos + eps.yyx).x) \n                     - sdSceneNormal(pos).x);\n}\n\nvec2 rayMarch(Ray ray)\n{\n\tfloat dist = 0.;\n    vec2 result = vec2(-1.);\n    for(int i = 0; i < 128; ++i)\n    {  \n        result = sdScene(ray.origin + ray.direction * dist);\n        if (result.x < EPS * dist || dist >= cameraFar) break;\n        dist += result.x;\n    }\n\n    if (dist >= cameraFar) result.y = -1.;\n    return vec2(dist, result.y);\n}\n\nfloat ndfTrowbridgeReitzRect(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alpha4 = alpha2 * alpha2;\n    float alphaPrime3 = alphaPrime * alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t \t(alpha2 * alphaPrime3)\n    \t/ /*-------------------------------------------------*/\n        \t  \t(pow(NdotH2 * (alpha2 - 1.) + 1., 2.));      \n}\n\n// Schlick-Beckmann GGX approximation used for smith's method\nfloat geometrySchlickGGX(float NdotX, float k)\n{\n    return \n        \t\t\t\t\tNdotX\n    \t/ /*----------------------------------------*/\n    \t  \t  max(NdotX * (1. - k) + k, SMOL_EPS);\n}\n\nfloat geometrySmith(float NdotV, float NdotL, float roughness)\n{\n \tfloat roughnessplusone = roughness + 1.;\n    float k = roughnessplusone * roughnessplusone / 8.;\n    \n    return geometrySchlickGGX(NdotV, k) * geometrySchlickGGX(NdotL, k);\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 fresnelSchlick(vec3 F0, float dotProd)\n{\n    return F0 + (1. - F0) * pow(1. - dotProd, 5.);\n}\n\nfloat rectSolidAngle(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n    vec3 v0 = p0 - p;\n    vec3 v1 = p1 - p;\n    vec3 v2 = p2 - p;\n    vec3 v3 = p3 - p;\n    \n    vec3 n0 = normalize(cross(v0, v1));\n    vec3 n1 = normalize(cross(v1, v2));\n    vec3 n2 = normalize(cross(v2, v3));\n    vec3 n3 = normalize(cross(v3, v0));\n    \n    float g0 = acos(dot(-n0, n1));\n\tfloat g1 = acos(dot(-n1, n2));\n\tfloat g2 = acos(dot(-n2, n3));\n\tfloat g3 = acos(dot(-n3, n0));\n    \n    return g0 + g1 + g2 + g3 - TWO_PI;\n}\n\nvec3 rayPlaneIntersect(Ray ray)\n{\n   return ray.origin + ray.direction * (dot(rect.front, rect.center - ray.origin)\n                                      / dot(rect.front, ray.direction));\n}\n\nvec4 rectLight(vec3 p, vec3 n, vec3 v, vec3 r, float NdotV, float roughness,\n              vec3 f0, out vec3 fresnel, out vec3 diffCol, out vec3 specCol)\n{\n  \n    vec4 result = vec4(0.);\n    // ensure the points are wound counter-clockwise (only debug)\n    float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);\n    if (windingCheck > 0.)\n\t\treturn result;\n    \n    float solidAngle = rectSolidAngle(p, rect.a, rect.b, rect.c, rect.d);\n    \n    // diffuse\n    result.w = solidAngle * .2 * (\n        saturate(dot(normalize(rect.a - p), n)) +\n        saturate(dot(normalize(rect.b - p), n)) +\n        saturate(dot(normalize(rect.c - p), n)) +\n        saturate(dot(normalize(rect.d - p), n)) +\n        saturate(dot(normalize(rect.center - p), n)));   \n    \n    Ray rectRay = Ray(p, r);\n    \n    // calculate point on the rectangle surface/edge based on the ray originating from the shaded point\n    vec3 planePointCenter = rayPlaneIntersect(rectRay) - rect.center;\n    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), \n                               dot(planePointCenter, rect.up));\n    //vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);\n    vec2 c = clamp(planePointProj, -rect.halfSize, rect.halfSize);\n    vec3 L = rect.center + rect.right * c.x + rect.up * c.y;\n#ifdef LIGHT_TEXTURE\n    // calculate light uv\n    vec3 L0 = L - rect.c;\n    vec2 luv = vec2(dot(rect.right, L0), dot(rect.up, L0)) / (rect.halfSize * 2.);\n#endif\n    L -= p;\n    \n    vec3 l = normalize(L);\n    vec3 h = normalize(l + v);\n    float lightDist = length(L);\n    \n    float NdotH = max(0., dot(n, h));\n    float VdotH = dot(v, h);\n    \n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (RECT_LIGHT_RADIUS / (2. * lightDist)));\n    \n#ifdef LIGHT_TEXTURE\n    // calculate approx light diffuse and specular colors (super experimental :p) \n    diffCol = pow(textureLod(iChannel1, luv, pow(exp(lightDist + .5), 2.)).rgb, vec3(2.2));\n    specCol = pow(textureLod(iChannel1, luv, exp(lightDist * alpha + .5) + 1.).rgb, vec3(2.2));\n#endif\n    \n    result.xyz += geometrySmith(NdotV, result.w, roughness) \n        * ndfTrowbridgeReitzRect(NdotH, alpha, alphaPrime)\n        * fresnelSchlick(f0, VdotH);\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blueNoise = texelFetch(iChannel1,\n\t\t\t\t\t\t(iFrame * ivec2(113, 127)) & 63, 0).rg;\n    vec2 uv = (2. * (fragCoord + blueNoise) - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    float t = iTime * .5;\n    \n    vec3 col = vec3(0.);\n     \n    vec2 rot = m * TWO_PI;    \n    initRect(rot);\n    \n    Ray ray = getCameraRay(uv);\n    vec2 marchResult = rayMarch(ray);\n    vec3 position = ray.origin + ray.direction * marchResult.x;\n    vec3 normal = calculateNormal(position);\n    vec3 viewDirection = -ray.direction;\n    vec3 reflectDirection = reflect(ray.direction, normal);\n    \n    float NdotV = max(dot(normal, viewDirection), 0.);\n    \n    vec3 rectFresnel = vec3(0.);\n\tvec3 rLightDiff = vec3(0.); // light diffuse color\n    vec3 rLightSpec = vec3(0.); // light specular color\n    float rectRoughness = .08;\n    float rectMetalness = .25;\n\tif (marchResult.y > -1.)\n    {\n\t\tif (marchResult.y > 1.)\n        {\n            vec3 albedo = pow(textureLod(iChannel0, position.xz * .04, 0.).rgb, vec3(2.2));\n#ifdef FLOOR_ROUGHNESS\n            rectRoughness += albedo.r * .64;\n#endif\n            vec3 F0 = mix(vec3(.05), vec3(1.), rectMetalness);\n            vec4 rLight = rectLight(position, normal, viewDirection,\n\t\t\t\t\treflectDirection, NdotV, rectRoughness, F0, rectFresnel, rLightDiff, rLightSpec);\n            vec3 kD = 1. - rectFresnel;\n            kD *= 1. - rectMetalness;\n#ifdef LIGHT_TEXTURE\n        \tcol += (albedo * kD * rLightDiff + rLight.xyz * rLightSpec) * rLight.w * \n                RECT_LIGHT_INTENSITY;\n#else\n            col += (albedo * kD * PI_INV + rLight.xyz) * rLight.w * \n                RECT_LIGHT_INTENSITY * RECT_LIGHT_COLOR;\n#endif\n        }\n        else\n        {\n#ifdef LIGHT_TEXTURE\n            vec3 rectOrigin = position - rect.c;\n        \tvec2 rectUv = vec2(dot(rect.right, rectOrigin), dot(rect.up, rectOrigin)) / (rect.halfSize * 2.);\n            col += pow(textureLod(iChannel1, rectUv, 0.).rgb, vec3(2.2)) * RECT_LIGHT_INTENSITY;\n#else\n            col += RECT_LIGHT_COLOR * RECT_LIGHT_INTENSITY;\n#endif\n        }\n    }\n    \n    col = mix(col, vec3(.005, .0003, .0002), // brown-ish fog color\n               \t\tclamp(1. - exp(-marchResult.x * .08), 0., 1.));\n    \n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(iChannel0, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(iChannel1, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}