{
    "Shader": {
        "info": {
            "date": "1535650315",
            "description": "Path-tracer rendering of a scene focused through a ball",
            "flags": 32,
            "hasliked": 0,
            "id": "ltKyzD",
            "likes": 7,
            "name": "Glass Ball Photography",
            "published": 3,
            "tags": [
                "pathtracer"
            ],
            "usePreview": 1,
            "username": "Mrfixit13",
            "viewed": 702
        },
        "renderpass": [
            {
                "code": "float A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\n    \nvec3 W = vec3(1120.0);\n\nvec3 uncharted2ToneMapping(vec3 x){\n\t\n\t\t\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 color = texture(iChannel0,fragCoord.xy / iResolution.xy).rgb;\n    \n    vec3 curr = uncharted2ToneMapping(color.xyz*2.0);\n\tvec3 whiteScale = 1.0/uncharted2ToneMapping(W); \n\tvec3 mapped = curr*whiteScale;\n\t\n\tmapped = pow(mapped, vec3(1.0 / 2.2));\n    \n\tfragColor =  vec4(mapped,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define EMISSIVE 0\n#define DIELECTRIC 1\n#define METALIC 2\n#define GLASS 3\n#define TEST 10\n\n\n\n\nfloat skyIntensity = 0.5;//night = 0.05 day = 2.0\nfloat aperature = 0.1;//controls the amount of defocusing my changing the radius of the \"aperature\" values above 0.2 are high and 0 disables the effect\nint pathsPerFrame = 5;//the number of paths traced per pixle per frame\nint maxDepth = 20;//max number of ray bounces per path\nfloat t_max = 4294967296.0;\nfloat t_min = 0.0039;\n\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    int type;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n    vec3 attenuation;\n    vec3 radiance;\n    float rand;\n    float t;\n    bool done;\n};\n    \n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    Material mat;\n};\n    \nstruct Hit\n{\n  vec3 normal;\n  float t;\n  bool hit;\n  Material mat;\n};\n    \n    \nconst vec3 pos = vec3(0.0,0.0,-5.0);\n//the objects in the scene\n//Sphere sphere0 = Sphere(vec3(1000.0,1000.0,0.25),100.0,Material(vec3(1.0,0.8,0.7)*1000.0,0.0,0));//chnages sphere light ot be more sun like\nSphere sphere0 = Sphere(vec3(0.0,-0.25,0.25)+pos,0.25,Material(vec3(0.1,0.3,0.9)*20.0,0.0,EMISSIVE));\nSphere sphere1 = Sphere(vec3(1.0,0.0,0.40)+pos,0.5,Material(vec3(0.05),0.05,DIELECTRIC));\nSphere sphere2 = Sphere(vec3(-1.0,0.0,0.4)+pos,0.5,Material(vec3(0.9,0.2,0.05),0.3,DIELECTRIC));\nSphere sphere3 = Sphere(vec3(0.51,0.0,-0.5)+pos,0.5,Material(vec3(1.0,0.766,0.336),0.05,METALIC));\nSphere sphere4 = Sphere(vec3(-0.51,0.0,-0.5)+pos,0.5,Material(vec3(0.913, 0.921, 0.925),0.7,METALIC));\nSphere sphere5 = Sphere(vec3(0.0,-100.5,0.0)+pos,100.0,Material(vec3(0.5),0.5,DIELECTRIC));\n//Sphere sphere6 = Sphere(vec3(0.55,-0.4,0.6)+pos,0.1,Material(vec3(0.0),0.0,GLASS));\nSphere sphere6 = Sphere(vec3(0,-0.1,0.0),0.45,Material(vec3(0.0),0.0,GLASS));\nSphere sphere7 = Sphere(vec3(0,-0.0,0.0),4.0,Material(vec3(0.0),0.1,GLASS));\n\nSphere sphereBounding0 = Sphere(vec3(0.0,0,0.0)+pos,2.0,Material(vec3(0.0),1.0,EMISSIVE));\n\n    \n//the randomization code was found on a forum about generating random numbers in glsl    \n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }    \n    \n//from raytracing in one weekend\nvec3 randv(float n)\n{\n\tvec3 v = 2.0*vec3(random(n+1.0),random(n+2.0),random(n+3.0))-1.0;\n    \n    do{ \n        v = 2.0*vec3(random(v.x),random(v.y),random(v.z))-1.0;     \n    }while(length(v) >= 1.0);\n    \n    return v;\n}\n\n\nvec3 backgroundColor(vec3 dir){\n    vec3 unit_dir = normalize(dir);\n    float t = 0.5*(unit_dir.y+1.0);\n    return pow(texture(iChannel1,dir).rgb,vec3(2.2))*10.1;\n    return ((1.0-t)*vec3(1.0)+t*vec3(0.5,0.7,1.0))*skyIntensity;\n}\n\n\nHit traceSphere(Ray ray,Sphere sphere)\n{\n   \tfloat a = dot(ray.direction,ray.direction);\n    float b = dot(ray.direction,ray.origin-sphere.center)*2.0;\n    float c = dot(ray.origin-sphere.center,ray.origin-sphere.center)-sphere.radius*sphere.radius;\n    float d = b*b-4.0*a*c;\n    Hit hit;\n    \n    if(d >= 0.0)\n    {\n        hit.t = (-b-sqrt(d))/(2.0*a);\n      \tif(hit.t < t_max && hit.t > t_min)\n        {\n        \thit.normal = normalize((ray.origin+ray.direction*hit.t)-sphere.center);\n        \thit.mat = sphere.mat;\n        \thit.hit = true;\n        \treturn hit;\n       }\n        \n        hit.t = (-b+sqrt(d))/(2.0*a);\n        if(hit.t < t_max && hit.t > t_min)\n        {\n        \thit.normal = normalize((ray.origin+ray.direction*hit.t)-sphere.center);\n        \thit.mat = sphere.mat;\n        \thit.hit = true;\n        \treturn hit;\n        }\n    }\n    \n\thit.hit = false;\n\treturn hit;   \n}\n\nHit compareHit(Hit hit, Hit newHit)\n{\n    if(newHit.hit)\n    \tif(newHit.t < hit.t )return newHit;\n        \n   \treturn hit;\n}\n\nHit traceScene(Ray ray)\n{\n    Hit hit;\n    hit.t = t_max;\n   \n\n    hit = compareHit(hit,traceSphere(ray,sphere0));\n    hit = compareHit(hit,traceSphere(ray,sphere1));\n    hit = compareHit(hit,traceSphere(ray,sphere2));\n    hit = compareHit(hit,traceSphere(ray,sphere3));\n    hit = compareHit(hit,traceSphere(ray,sphere4));\n  \thit = compareHit(hit,traceSphere(ray,sphere6));\n    //hit = compareHit(hit,traceSphere(ray,sphere7));\n   \n    \n    hit = compareHit(hit,traceSphere(ray,sphere5));\n   \n\n    return hit;   \n}\n\nfloat schlick(float cosine,float ref_idx)\n{\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow((1.0-cosine),5.0);\n}\n\nstruct Refracted{\n    bool did;\n    vec3 direction;\n};\n\nRefracted refract0(vec3 v,vec3 n, float ni_nt)\n{\n    Refracted ref;\n    v = normalize(v);\n    float dt = dot(v,n);\n    float disc = 1.0-ni_nt*ni_nt*(1.0-dt*dt);\n    if(disc > 0.0){\n        ref.direction = ni_nt*(v-n*dt)-n*sqrt(disc);\n        ref.did = true;\n    }\n    else ref.did = false;\n    \n    return ref;\n    \t\n}\n\nRay castRay(Ray ray)\n{\n    Hit hit = traceScene(ray);\n    ray.t = hit.t;\n    float roughness = hit.mat.roughness*hit.mat.roughness;\n    \n    if(hit.hit)\n    {     \n        ray.radiance = vec3(0.0);\n        ray.rand = random(ray.rand);   \n        \n        if(hit.mat.type == DIELECTRIC)\n        {     \n            float ref_idx = 1.45;\n            float cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);\n            float schlick = schlick(cosine,ref_idx);\n            \n            if(ray.rand > schlick)\n            {   \t\t\n        \t\tray.attenuation = ray.attenuation*hit.mat.albedo;\n        \t\tray.origin = ray.t*ray.direction+ray.origin;\n\t\t\t\tray.direction = normalize(hit.normal+randv(ray.rand));  \t\t\t    \t\n            }\n            else\n            {\n                ray.attenuation = ray.attenuation*vec3(1.0);\n        \t\tray.origin = ray.t*ray.direction+ray.origin;\n\t\t\t\tray.direction = normalize(reflect(ray.direction,hit.normal)+randv(ray.rand)*roughness);\n                ray.done = dot(ray.direction,hit.normal)<=0.0;\n            }         \n            return ray;\n        }\n        \n        else if(hit.mat.type == METALIC)\n        {\n            //float ref_idx = 1.5;\n\t\t\t//float cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);\n            //float schlick = schlick(cosine,ref_idx)-schlick(1.0,ref_idx);\n            \n            ray.attenuation = ray.attenuation*hit.mat.albedo;\n        \tray.origin = ray.t*ray.direction+ray.origin;\n\t\t\tray.direction = normalize(reflect(ray.direction,hit.normal)+randv(ray.rand)*roughness);\n            ray.done = dot(ray.direction,hit.normal)<=0.0;\n            \n            return ray;\n        }\n        \n        //The glass code is from raytracing in a weekend\n        //is still have trouble wrapping my head around the finer details of refraction\n        else if(hit.mat.type == GLASS)\n        {        \n            float ref_idx = 1.5;\n            float cosine;\n            \n            float ni_nt;\n            \n            vec3 normal;\n            \n            if(dot(ray.direction,hit.normal) > 0.0)\n            {\n\t\t\t\tnormal = -hit.normal;\n               \tni_nt = ref_idx;\n                cosine = ref_idx*dot(ray.direction,hit.normal)/length(ray.direction);\n            }\n            else\n            {\n                normal = hit.normal;\n                ni_nt = 1.0/ref_idx;\n                cosine = -dot(ray.direction,hit.normal)/length(ray.direction);\n            }\n            \n            float schlick0;\n            Refracted ref = refract0(ray.direction,normal,ni_nt);\n            \n            if(ref.did)\n            {\n                schlick0 = schlick(cosine,ref_idx);\n            }\n            else\n            {  \n                schlick0 = 1.0;\n            }\n            \n            \n           \tif(ray.rand > schlick0)\n            {  \n                ray.origin = ray.t*ray.direction+ray.origin;\n                ray.direction = normalize(ref.direction);  \t\t    \t\n            }\n            else\n            {\n                ray.attenuation = ray.attenuation*vec3(1.0);\n        \t\tray.origin = ray.t*ray.direction+ray.origin;\n\t\t\t\tray.direction = normalize(reflect(ray.direction,hit.normal));  \n\n            }\n            \n            return ray;\n        }\n        \n        \n        else if(hit.mat.type == EMISSIVE)\n        {                        \n        \tfloat ref_idx = 1.5;\n\t\t\tfloat cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);\n            float schlick = schlick(cosine,ref_idx);\n            \n            if(ray.rand > schlick)\n            {   \t\n                ray.radiance = hit.mat.albedo; \t\t\t    \t\n            }\n            else\n            {\n                ray.attenuation = ray.attenuation*vec3(1.0);\n        \t\tray.origin = ray.t*ray.direction+ray.origin;\n\t\t\t\tray.direction = normalize(reflect(ray.direction,hit.normal)+randv(ray.rand)*hit.mat.roughness);\n                \n                //return ray;\n            }     \n        }\n        \n        else if(hit.mat.type == TEST)\n        {                        \n        \tfloat ref_idx = 1.5;\n\t\t\tfloat cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);\n            float schlick = schlick(cosine,ref_idx)-schlick(1.0,ref_idx);\n            \n \t\n           \tray.radiance = vec3(schlick); \t\t\t    \t   \n        }  \n    }\n    \n    else\n    {\n       ray.radiance = backgroundColor(ray.direction);\n    }\n    \n    ray.done = true;\n    return ray;   \n}  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (vec2(-1.0)+2.0*(fragCoord.xy / iResolution.xy)) * vec2(iResolution.x/iResolution.y,1.0);\n    \n    vec2 mouse = (iMouse.xy/iResolution.xy*2.0-vec2(1.0))*vec2(iResolution.x/iResolution.y,1.0)*2.0;\n    mouse.y = max(mouse.y,-0.5);\n    \n    mat3 rot = mat3(vec3(sin(mouse.x+3.14159/2.0),0,sin(mouse.x)),\n                    vec3(0,1,0),\n                    vec3(sin(mouse.x+3.14159),0,sin(mouse.x+3.14159/2.0)));\n    \n    \n    vec4 previous_color =texture(iChannel0,(fragCoord.xy / iResolution.xy));\n  \n    vec3 color = vec3(0.0); \n    \n    \n    float focal = (iMouse.y/iResolution.y)*0.0+2.5;\n    \n    Ray ray;\n    \n    //int maxDepth = min(int(floor(iTime/2.0)),20);\n    \n    for(int path = 0; path < pathsPerFrame; path++)\n    {\n        vec2 offset0 =randv(random(vec4(uv,iFrame,path))).xy*aperature;\n        vec2 offset1 = (2.0*vec2(random(vec4(uv,path,iFrame)),random(vec4(uv,path+pathsPerFrame,iFrame)))-1.0)/iResolution.xy*vec2(iResolution.x/iResolution.y,1.0);\n              \n        \n        //ray.direction = rot*normalize(vec3(uv-offset0+offset1,-focal));\n        ray.direction = rot*normalize(vec3(uv*focal/2.5-offset0+offset1,-focal));//uncomment to changes focal plane without zoom\n    \tray.origin = rot*vec3(offset0+offset1,3);\n    \tray.attenuation = vec3(1.0);\n    \tray.rand = random(vec4(uv,path,iTime));\n   \t\tray.done = false;\n  \t\n    \tfor(int depth = 0; depth < maxDepth && !ray.done ;depth++)\n    \t{\n    \t   ray = castRay(ray);\n    \t}\n    \t\n\t\tcolor += ray.radiance*ray.attenuation;\n    }\n    \n    color/=float(pathsPerFrame);\n    \n             \n   \tfloat temp = previous_color.w+1.0;\n    \n    if(iMouse.z > 0.0 )temp = 1.0;   \n    \n    float mixf = 1.0/temp;\n\t\n\tfragColor =  vec4(mix(color,previous_color.rgb,1.0-mixf),temp) ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}