{
    "Shader": {
        "info": {
            "date": "1565716861",
            "description": "A simple raytracing example with lighting (diffusion and specular) and shadows.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlXXzB",
            "likes": 4,
            "name": "Spheres raytracing (tutorial)",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Megus",
            "viewed": 1438
        },
        "renderpass": [
            {
                "code": "#define COUNT 5\n#define SIZE 4\n\n#define LIGHT_POWER 80.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\nvec4 spheres[] = vec4[COUNT * SIZE](\n    // Spheres: center and radius, color, movement speed, movement amplitude\n    // Light source\n    vec4(-7.5, 0., 31., 0.1), vec4(1., 1., 1., 1.),\n    vec4(2., 1., 0, 0), vec4(0, 2., 0, 0),\n    // 1\n    vec4(-4., 0., 39., 2), vec4(.2, .9, .2, 1.),\n    vec4(1., 1.1, 2., 0), vec4(2, 3, 5.1, 0),\n    // 2\n    vec4(3., 0., 42., 3.), vec4(.9, .4, .5, 1.),\n    vec4(1.3, 1.7, 1.5, 0), vec4(1, 4, 5.1, 0),\n    // 3\n    vec4(2, -1., 43., 1.5), vec4(.2, .3, 1., 1.),\n    vec4(2., 1., 2., 0), vec4(7, 1, 7, 0),\n    // \"Floor\"\n    vec4(0, -800006, 0, 800000), vec4(1.7, 1.0, .7, 1),\n    vec4(0, 0, 0, 0), vec4(0, 0, 0, 0)\n);\n\n// Calculate a moving sphere center\nvec3 sphereCenter(int sphere) {\n    vec4 sD = spheres[sphere * SIZE];\n    vec4 sS = spheres[sphere * SIZE + 2];\n    vec4 sA = spheres[sphere * SIZE + 3];\n    vec3 c = vec3(\n        sD.x + sin(iTime * sS.x) * sA.x,\n        sD.y + sin(iTime * sS.y) * sA.y,\n        sD.z + cos(iTime * sS.z) * sA.z);\n    return c;    \n}\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n    int sphere = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < COUNT; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        vec3 c = sphereCenter(i);\n        float r = spheres[i * SIZE].w;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                sphere = i;\n                d = sd;\n            }\n        }\n    }\n    return sphere;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int sphere = findIntersection(camO, camL, -1, d);\n    \n    if (sphere == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = spheres[1].xyz;\n\n    if (sphere == 0) {\n        // It's a light source, don't need to shade it\n        return lightColor;\n    }\n    \n    vec3 lightPoint = sphereCenter(0);\n    \n    // Sphere color\n    vec3 sColor = spheres[sphere * SIZE + 1].xyz;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sphereCenter(sphere));\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint);\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, sphere, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy != 0) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, 0);\n    vec3 camL = normalize(vec3(uv.x, uv.y, 7));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}