{
    "Shader": {
        "info": {
            "date": "1666875554",
            "description": "Submitted to JFIG 2022 Shadertoy competition.\n\nDon't look too closely to the source, it is full of dirty hacks to meet the deadline ;-)",
            "flags": 8,
            "hasliked": 0,
            "id": "mdfGDX",
            "likes": 2,
            "name": "[ConcoursJFIG2022] Cyclide",
            "published": 3,
            "tags": [
                "concoursjfig2022demosoundretrosynth"
            ],
            "usePreview": 1,
            "username": "T_Rex",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "\n// ------------------------------------------------------------------------------\n// Text drawing routines\n// ------------------------------------------------------------------------------\n// From FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n\n//=== original link for citation: https://www.shadertoy.com/view/llySRh\n\n// --- printing chars, integers and floats ---------------------------\n// --- access to the image of ascii code c\n\n// 2 implementations.\n// Use #if 1 for extensive text use (with no appearance change)\n//           Also correct the windows bug ( light framing of chars. )\n\n#if 1 // immediate draw. (allows for superimposition and appearance change).\n\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.), dFdy(p/16.) );\n  // variants:\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n#  define draw_char() vec4(0)  // stub the final call function is used\n\n#else // Deferred draw (call draw_char() ). Run and compiles faster.\n      //     First only determine the valid char id at cur pixel \n      //     then call the draw char once at the end.\n\nint char_id = -1; vec2 char_pos; \nvec4 char(vec2 p, int c) {\n    //if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n#endif\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n, float l) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = l-1.0; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n// --- chars\nint CAPS=0;\n\n\nvec3 tri_draw_text(vec2 uv)\n{\n    vec4 O = vec4(0);\n    \n    vec2 U = (uv - vec2(0.46, .45)) * 10.;\n    \n    caps;\n    CHR_L CHR_A spc;\n    CHR_C CHR_Y CHR_C CHR_L CHR_I CHR_D CHR_E spc;\n    CHR_B CHR_O CHR_R CHR_D CHR_E CHR_L CHR_A CHR_I CHR_S CHR_E;\n        \n    O += draw_char();\n    \n    return O.xxx;\n}\n\n\nvec3 tri_step_09(vec2 uv, float aspect, float t)\n{\n    vec2 orgUV = uv;\n    //orgUV.y /= aspect;\n    orgUV.x *= aspect;\n    \n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom in\n    uv *= 2.3;\n    \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(0.1, 2., place(t, 0., time_fade));\n    \n    vec2 center_circles = vec2(-.8, 0.);\n    \n    //col += lighting_effect(uv, vec2(0.1, 0.3), r_inner_lighting, r_outer_lighting, aspect);\n    col += drawCircles_light(uv, radius_each, center_circles, radius_all, t);\n    col *= drawCircles(uv, radius_each, center_circles, radius_all, t);\n    \n    // fade to white at the very end\n    //col = mix(col, vec3(1.), place(t, .4, .6));\n    \n    col += tri_draw_text(orgUV);\n    \n    return col;\n}\n\n\nvec4 scene_0_trilogy(in vec2 uv, float aspect, float t)\n{\n    float time = t * 1.1;\n\n    vec3 col = vec3(0);\n    \n    if (time < 0.3) {\n        col = tri_step_01(uv, aspect, time);\n    } else if (time < 1.3) {\n        // duration 1\n        col = tri_step_02(uv, aspect, time - 0.3);\n    } else if (time < 2.4) {\n        // duration 1.1\n        col = tri_step_03(uv, aspect, time - 1.3);\n    } else if (time < 3.4) {\n        // duration 1\n        col = tri_step_04(uv, aspect, time - 2.4);\n    } else if (time < 3.5) {\n        // duration .1\n        // Black\n    } else if (time < 4.6) {\n        // duration 1.1\n        col = tri_step_05(uv, aspect, time - 3.5);\n    } else if (time < 5.6) {\n        // duration 1\n        // TODO\n        col = tri_step_04(uv, aspect, time - 4.6);\n    } else if (time < 6.7) {\n        // duration 1.1\n        col = tri_step_07(uv, aspect, time - 5.6);\n    } else if (time < 7.7) {\n        // duration 1\n        // TODO\n        col = tri_step_04(uv, aspect, time - 6.7);\n    } else if (time < 9.5) {\n        col = tri_step_09(uv, aspect, time);\n    } else if (time < 13.) {\n        col = tri_step_09(uv, aspect, 9.5);\n    }\n    \n    //col = tri_step_09(uv, aspect, 9.5);\n    \n    return vec4(col,1.0);\n}\n\n\n\nvec4 scene_msg(in vec2 fragCoord, float t)\n{\n    vec4 fragColor = vec4(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec4 O = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U = (uv - vec2(0.27, .8)) * 10.;\n    caps CHR_W CHR_A CHR_R CHR_N CHR_I CHR_N CHR_G;\n    \n    U = (uv - vec2(0.15, .65)) * 15.;\n    CHR_T low CHR_H CHR_I CHR_S spc\n    CHR_S CHR_H CHR_A CHR_D CHR_E CHR_R spc;\n    CHR_H CHR_A CHR_S spc;\n    CHR_A;\n    \n    U = (uv - vec2(0.28, .55)) * 15.;\n    CHR_S CHR_O CHR_U CHR_N CHR_D CHR_T CHR_R CHR_A CHR_C CHR_K;\n    \n    U = (uv - vec2(0.05, .4)) * 15.;\n    caps CHR_E low CHR_N CHR_S CHR_U CHR_R CHR_E spc;\n    CHR_T CHR_O spc;\n    CHR_R CHR_E CHR_S CHR_T CHR_A CHR_R CHR_T spc;\n    CHR_I CHR_T spc;\n    CHR_F CHR_R CHR_O CHR_M;\n    \n    U = (uv - vec2(0.05, .3)) * 15.;\n    CHR_T CHR_H CHR_E spc;\n    CHR_B CHR_E CHR_G CHR_I CHR_N CHR_I CHR_N CHR_G spc;\n    CHR_F CHR_O CHR_R spc;\n    CHR_T CHR_H CHR_E spc;\n    CHR_B CHR_E CHR_S CHR_T;\n    \n    U = (uv - vec2(0.28, .2)) * 15.;\n    CHR_E CHR_X CHR_P CHR_E CHR_R CHR_I CHR_E CHR_N CHR_C CHR_E;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    if (uv.y > .8){\n        fragColor.gb = vec2(0.);\n    }\n    \n    return fragColor;\n}\n\n\nvec3 scene_3d_cyclide_alone(vec2 uv, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    // set up translation\n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    float c = 2.;\n    \n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    // affect color\n    if (distanceToSdf <= 1e-2 ) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec3 albedo = vec3(1.);\n                \n        fragColor = pow(vec3(info.normal.xxx * albedo), vec3(1./2.2));\n    } else {\n        fragColor = vec3(0.0f);\n    }\n    \n    return clamp(fragColor, vec3(0.), vec3(1.));\n}\n\n\nvec4 scene_ika_1(vec2 uv, float aspect, float t)\n{\n    vec3 color = vec3(0.);\n    \n    vec2 oUV = uv;\n\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n    \n    float end_1 =  3.9 / TEMPO_IKARUGA;\n    float end_2 =  6.9 / TEMPO_IKARUGA;\n    float end_3 = 15.2 / TEMPO_IKARUGA;\n    float end_4 = 21.2 / TEMPO_IKARUGA;\n    float end_5 = 28.0 / TEMPO_IKARUGA;\n    \n    vec2 c_black = vec2(0.0, 0.);\n    float r_black = .15;\n    \n    vec2 c_light = vec2(0., 0.);\n    float r0_light = .1;\n    float r1_light = 10.;\n    \n    float r0_light_e = .3;\n    float r1_light_e = 1.4;\n    \n    vec2 c_black_e = vec2(0.16, 0.);\n    vec2 c_light_e = vec2(0.6, 0.);\n    \n    if (t < end_1) {\n        // Translate black circle\n        float a = pow(place(t, 0., end_1), .3);\n        c_black = mix(vec2(-3., 0.), c_black, a);\n        r_black = mix(2., r_black, a);\n    } else if (t < end_2) {\n        // Reduce light size\n        float a = pow(place(t, end_1, end_2), .3);\n        r0_light = mix(r0_light, r0_light_e, a);\n        r1_light = mix(r1_light, r1_light_e, a);\n    } else if (t < end_3) {\n        // Translate light\n        float a = place(t, end_2, end_3);\n        r0_light = r0_light_e;\n        r1_light = r1_light_e;\n        c_black = mix(c_black, c_black_e, a);\n        c_light = mix(c_light, c_light_e, a);\n    } else /*if (t < end_4)*/ {\n        r0_light = r0_light_e;\n        r1_light = r1_light_e;\n        c_black = c_black_e;\n        c_light = c_light_e;\n    }\n    \n    // Some image space blending\n    color = lighting_effect(uv, c_light, r0_light, r1_light);\n    color.rgb *= drawCircle(uv, c_black, r_black);\n    \n    vec3 c2 = vec3(0.);\n    if (t > end_3) {\n        vec3 c2;\n        c2 = drawCircle(uv, c_black, r_black) > 0.5 ? vec3(.5) : vec3(0.);\n        c2 += lighting_effect(uv, c_light, r0_light, r1_light);\n        float a = min(place(t, end_3, end_4), 1.);\n        color = mix(color, c2, a);\n        \n    } \n    \n    if (t > end_4) {\n        float a = min(place(t, end_4, end_5), 1.);\n        color = mix(color, scene_3d_cyclide_alone(oUV, aspect, t - end_4), a);\n    }\n    \n    return vec4(color, 1.);\n}\n\n\nvec3 scene_3d_cyclide_tex(vec2 uv, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    // set up translation\n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    // Camera rotation management\n    /*vec4 q_permanent   = GET_PERMANENT_QUAT;\n    vec4 q_interactive = GET_INTERACTIVE_QUAT;\n    \n    vec4 q = mul_quat(q_interactive, q_permanent);\n    mat3 rot_mat = quat_to_rot(q);*/\n    //toWorld = mat4(rot_mat) * toWorld;\n    /*\n    rayOrg = rot_mat * rayOrg;\n    rayDir = normalize(rot_mat * rayDir);\n    */\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, normalize(rayDir));\n    \n    float cmin = 0.15f;\n    float cmax = 2.0f;\n    float c = cmax;\n    \n    if (t > 6. / TEMPO_IKARUGA && t < 11. / TEMPO_IKARUGA) {\n        float a = t - 5. / TEMPO_IKARUGA;\n        float a2 = (sin(TEMPO_IKARUGA * 3. * 3.14 * a / 4.) * .5 + .5);\n        c = mix(cmin, cmax, a2);\n    } \n    \n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    // affect color\n    if (distanceToSdf <= 1e-2 ) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec2 c_uv = info.uv;\n        vec3 albedo = vec3(1.);\n        \n        //albedo = vec3(mod(cyclide_uv, 1.), 1.);\n        //*\n        if (t < 1. / TEMPO_IKARUGA) {\n            albedo = vec3(1.);\n        } else if (t < 2. / TEMPO_IKARUGA) {\n            albedo = vec3(c_uv, 1.);\n        } else if (t < 3. / TEMPO_IKARUGA) {\n            albedo = checkerboard(c_uv, 8., 18.) ? vec3(1.) : vec3(mod(8. * c_uv, 1.), 0.);\n        } else if (t < 4. / TEMPO_IKARUGA) {\n            albedo = grid(c_uv* vec2(1, 8)) < 0.1 ? vec3(0., 0.3, 1.) : vec3(1.);\n        } else /*if (t < 5. / TEMPO_IKARUGA) */{\n            albedo = !checkerboard(c_uv, 8., 18.) ? vec3(1.) : vec3(1., 0., 0.);\n        }\n        //*/\n        \n        fragColor = vec3(info.normal.xxx * albedo);\n        fragColor = clamp(fragColor, vec3(0.), vec3(1.));\n    } else {\n        fragColor = vec3(0.0f);\n    }\n    \n    return pow(fragColor, vec3(1./2.2));\n}\n\n\nvec4 scene_ika_2(vec2 uv, float aspect, float t)\n{\n    vec3 col = vec3(0.);\n        \n    col = scene_3d_cyclide_tex(uv, aspect, t);\n    \n    return vec4(col, 1.);\n}\n\n\nvec4 scene_3d_cyclide_transition(vec2 uv, float aspect, float t) \n{\n    vec3 fragColor = vec3(0.);\n    \n    float end_1 =         8. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 5. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 13. / TEMPO_IKARUGA;\n    float end_4 = end_3 + 2. / TEMPO_IKARUGA;\n    \n    float end_5 = end_4 + 2. / TEMPO_IKARUGA;\n    float end_6 = end_5 + 2. / TEMPO_IKARUGA;\n\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    float c_cyclide = 2.;\n    \n    vec3 rayOrg       = vec3(2., 0., 0.);\n    vec3 rayOrg_final = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    vec4 q = quat_from_angle_axis(0., vec3(1., 0., 0));\n    vec4 q_final = quat_from_angle_axis(.5 * M_PI, vec3(1., 0., 0));\n    \n    vec3 light_dir = vec3(1., 0., 0.);\n    // WOW This is ugly... I know sorry :-*\n    if (t < end_1) {\n        float a = place(t, 0., end_1);\n        //q = mul_quat(a * q_final, q);\n        q = mix(q, q_final, a);\n        //\n    } else if (t < end_2) {\n        float a = place(t, end_1, end_2);\n        q = q_final;\n        rayOrg = mix(rayOrg, rayOrg_final, a);\n    } else if (t < end_3) {\n        float a = cos(2. * M_PI * place(t, end_2, end_3)) * .5 + .5;\n        vec4 q_trans = quat_from_angle_axis(4. * M_PI * a, vec3(0., 1., 0.));\n        q = q_final;\n        q = mul_quat(q, q_trans);\n        rayOrg = rayOrg_final;\n    } else {\n        q = q_final;\n        rayOrg = rayOrg_final;\n    }\n    \n    float a = sin(t) * .5 + .5;\n    \n    mat3 rot_mat = quat_to_rot(q);\n    \n    light_dir = rot_mat * light_dir;\n    rayOrg = rot_mat * rayOrg;\n    rayDir = normalize(rot_mat * rayDir);\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    \n    Hit_rec rec;\n    \n    vec3 shading = vec3(0.);\n    if (t < end_5) {\n        if (hit_cyclide(2., frame, ray, rec)) {\n            vec3 albedo = !checkerboard(rec.uv, 8., 18.) ? vec3(1.) : vec3(1., 0., 0.);\n\n            if (t > end_3) {\n                float a = min(place(t, end_3, end_4), 1.);\n                albedo = mix(albedo, rec.normal, a);\n            }\n\n            shading = dot(rec.normal, light_dir) * albedo;\n        }\n    }\n    \n    if (t > end_4 && t < end_5) {\n        float a = min(place(t, end_4, end_5), 1.);\n        vec3 c2 = trace_ray(c_cyclide, frame, ray, 1);\n        shading = mix(shading, c2, a);\n    } else if (t >= end_5){\n        float a = min(place(t, end_5, end_6), 1.);\n\n        vec3 c1 = trace_ray(c_cyclide, frame, ray, 1);\n        vec3 c2 = trace_ray(c_cyclide, frame, ray, 2);\n\n        shading = mix(c1, c2, a);\n    }\n    \n    return vec4(pow(shading, vec3(1./2.2)), 1.);\n}\n\n\nvec4 draw_scene_3d_cyclide_rt(\n    in mat4 toWorld,\n    in float c,\n    in vec4 q_pov,\n    in vec3 rayOrg,\n    in vec3 rayDir) \n{\n    Frame frame = Frame(toWorld, inverse(toWorld));\n\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    rayOrg = rot_pov_mat * rayOrg;\n    rayDir = normalize(rot_pov_mat * rayDir);\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    \n    return vec4(pow(trace_ray(c, frame, ray, 2), vec3(1./2.2)), 1.);\n}\n\n\nvec4 draw_scene_3d_cyclide_sky(\n    in mat4 toWorld,\n    in float c,\n    in vec4 q_pov,\n    in vec3 rayOrg,\n    in vec3 rayDir,\n    in vec2 fragCoord,\n    in float t1)\n    \n{\n    vec4 fragColor = vec4(0.);\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n\n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 256u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    // skylight\n    //float t1 = iTime;\n    float lengthT = 10.;\n    float tt = fract(t1 / (2.*lengthT)) * lengthT;\n    float x1 = exp(- (tt - lengthT/2.)*(tt - lengthT/2.) / 12.);\n\n    float lengthP = 2.;\n    float tp = fract(t1 / (2.*lengthP)) * lengthP;\n    float x2 = exp(- (tp - lengthP/2.)*(tp - lengthP/2.) / 12.);\n\n    float sunTheta = clamp(x1 * 3.14/2., 0.001, 3.14/2. - 0.001); //(1. - iMouse.y / iResolution.y) * 3.14/2.; \n    float sunPhi   = clamp(fract(.5*t1 / lengthT) * 2.*3.14, 0.01, 2.*3.14); //3.14 + iMouse.x / iResolution.x * 2.*3.14;\n\n    vec3 sunPos = vec3(\n        sin(sunTheta) * cos(sunPhi), \n        cos(sunTheta), \n        sin(sunTheta) * sin(sunPhi)\n    );\n    \n    // affect color\n    if (distanceToSdf <= 1e-2) {\n        uint randomSeed = BayerMatrixCoefficient(\n            uint(fragCoord.x) & 255u,\n            uint(fragCoord.y) & 255u,\n            8u\n        );\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec3 V = normalize(vec3(4, 0, 0) - ray.origin);\n        vec3 L = vec3(1, 0, 0);\n        float s = sign(dot(info.normal, V));\n        vec3 T = s * info.tangent;\n        vec3 B = s * info.bitangent;\n        vec3 N = s * info.normal;\n        vec2 R = vec2(0.5, 0.1);\n        R = texture(iChannel2, info.uv).rg * 0.2;\n        float fr = Brdf_GGX(T, B, N, L, V, R);\n        vec3 Lo = vec3(0);\n        \n        // IS\n        uint sampleCount = 64u;\n        for (uint sampleID = 0u; sampleID < sampleCount; ++sampleID) {\n            float u1 = Urng(randomSeed);\n            float u2 = Urng(randomSeed);\n            Sample s = Sample_GGX(vec2(u1, u2), T, B, N, V, R);\n                           \n            Lo += clamp(skyColor_hack(s.direction.yzx, sunPos), 0., 1.);\n        }\n        \n        fragColor.rgb = Lo / float(sampleCount);\n\n    } else {\n        fragColor.rgb = skyColor_hack(ray.direction.yzx, sunPos);\n    }\n        \n    return fragColor;\n\n}\n\n\nvec4 scene_3d_cyclide_rt(vec2 uv, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 2.;\n    \n    vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    float end_1 =         5. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 5. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 12./ TEMPO_IKARUGA;\n    \n    vec4 q_pov = quat_from_angle_axis(M_PI/2., vec3(1., 0., 0));\n    \n    if (t < end_1) {\n        float a = cos(2. * M_PI * place(t, 0., end_1)) * .5 + .5;\n        vec4 q_trans = quat_from_angle_axis(2.*M_PI * a, vec3(0., 1., 0.));        \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n    } else if (t < end_2) {\n        float a = place(t, end_1, end_2);\n        vec4 q_pov_t = quat_from_angle_axis(2.*M_PI * a, vec3(0., 0., 1.));\n        q_pov = mul_quat(q_pov_t, q_pov);\n    } else if (t < end_3) {\n        float a = cos(6. * M_PI * place(t, end_2, end_3))* .5 + .5;\n        c = mix(1.25, c, a);\n    }\n    Frame frame = Frame(toWorld, inverse(toWorld));\n\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    rayOrg = rot_pov_mat * rayOrg;\n    rayDir = normalize(rot_pov_mat * rayDir);\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    \n    return vec4(pow(trace_ray(c, frame, ray, 2), vec3(1./2.2)), 1.);    \n}\n\n\nvec4 scene_cyclide_3d_sky(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 2.f;\n    \n    vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    vec4 q_pov = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    \n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n    \n    float end_1 = 6. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 2. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 3. / TEMPO_IKARUGA;\n    float end_4 = end_3 + 6. / TEMPO_IKARUGA;\n    \n    vec3 rayOrg_end = vec3(2., 0., 0.);\n\n    if (t < end_1) {\n        // We rotate the Dupin cyclide\n        float a = sin(2. * M_PI * place(t, 0., end_1)) * .5 + .5;\n\n        vec4 q_trans = quat_from_angle_axis(2.*M_PI * a, vec3(0., 0., 1.));        \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n    } else if (t < end_2) {\n        //float a = sin(2. * 2. * M_PI * place(t, end_1, end_2)) * .5 + .5;\n        //c = mix(2., 0.1, a);\n        float a = place(t, end_1, end_2);\n        rayOrg = mix(rayOrg, rayOrg_end, a);\n        //vec4 q_trans = quat_from_angle_axis(M_PI * a, vec3(0., 1., 0.));\n    } else if (t < end_3) {\n        float a = place(t, end_2, end_3);\n        \n        vec4 q_trans = quat_from_angle_axis(M_PI * a, vec3(0., 1., 0.));        \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n        \n        rayOrg = rayOrg_end;\n    } else {\n        float a = min(place(t, end_3, end_4), 1.);\n        vec4 q_trans = quat_from_angle_axis(-M_PI, vec3(0., 1., 0.)); \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n        \n        rayOrg = rayOrg_end;\n        c = mix(c, 0.8, a);\n    }\n\n    return draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        q_pov,\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        iTime * 2.\n    );\n}\n\n\n\nvec4 scene_cyclide_3d_sky_2(vec2 uv, in vec2 fragCoord, float aspect, float a)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 0.8;\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    vec4 q_pov = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    \n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n    float end_1 = 6. / TEMPO_IKARUGA;\n    \n    /*\n    float end_2 = end_1 + 2. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 3. / TEMPO_IKARUGA;\n    float end_4 = end_3 + 6. / TEMPO_IKARUGA;*/\n\n    vec4 q_trans = quat_from_angle_axis(-M_PI, vec3(0., 1., 0.)); \n    mat3 rot_mat = quat_to_rot(q_trans);\n    toWorld = mat4(rot_mat * mat3(toWorld));\n\n    //if (t < end_1) {\n         //float a = sin(M_PI/2. * place(t, 0., end_1)) * .5 + .5;\n\n        //float a = place(t, 0., end_1);\n        \n        vec4 q = quat_from_angle_axis(a * -M_PI/2., vec3(1., 0., 0.));\n        mat3 r = quat_to_rot(q);\n    \n        toWorld = mat4(r * mat3(toWorld));\n    /*\n    } else {\n        vec4 q = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0.));\n        mat3 r = quat_to_rot(q);\n    \n        toWorld = mat4(r * mat3(toWorld));\n    }*/\n    // return vec4(1.);\n\n    return draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        q_pov,\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        iTime * 2.\n    );\n}\n\nvec4 scene_3d_cyclide_rt_to_sky(vec2 uv, in vec2 fragCoord, float aspect, float a)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 2.;\n        \n    vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);    \n    vec4 q_pov = quat_from_angle_axis(M_PI/2., vec3(1., 0., 0));\n            \n    // From vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec4 rt = draw_scene_3d_cyclide_rt(\n        toWorld,\n        c,\n        q_pov,\n        rayOrg,\n        normalize(rayDir)\n    );\n\n    rt = clamp(rt, vec4(0.), vec4(1.));\n\n    q_pov = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n    vec4 sk = draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        quat_from_angle_axis(0., vec3(1., 0., 0.)),\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        0.\n    );\n\n    sk = clamp(sk, vec4(0.), vec4(1.));\n\n    return mix(rt, sk, a);\n}\n\n\n//\n\n\n\nvec4 draw_scene_3d_cyclide_tex_end(\n    in mat4 toWorld, \n    in float c,\n    in vec3 rayOrg,\n    in vec3 rayDir,\n    in vec2 fragCoord)\n{\n    vec3 fragColor = vec3(0.);\n    /*\n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    // Camera rotation management\n    vec4 q_permanent   = GET_PERMANENT_QUAT;\n    vec4 q_interactive = GET_INTERACTIVE_QUAT;\n    \n    vec4 q = mul_quat(q_interactive, q_permanent);\n    mat3 rot_mat = quat_to_rot(q);\n    //toWorld = mat4(rot_mat) * toWorld;\n    \n    rayOrg = rot_mat * rayOrg;\n    rayDir = normalize(rot_mat * rayDir);\n    */\n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir); \n    \n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    \n    // affect color\n    if (distanceToSdf <= 1e-2 ) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec2 c_uv = info.uv;\n        vec3 albedo = vec3(1.);\n        \n        if (grid(c_uv* vec2(1, 8)) < 0.1) {\n            albedo = vec3(0., 0.3, 1.);\n        }\n        \n        fragColor = vec3(info.normal.xxx * albedo);\n        fragColor = abs(fragColor);//, vec3(0.), vec3(1.));\n    } else {\n        fragColor = vec3(0.0f);\n    }\n    \n    return vec4(pow(fragColor, vec3(1./2.2)), 1.);\n}\n\n\nvec4 scene_3d_cyclide_sky_to_end(vec2 uv, in vec2 fragCoord, float aspect, float a)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = .8;\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);    \n    vec4 q_pov = quat_from_angle_axis(0., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n    vec4 sk = draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        quat_from_angle_axis(0., vec3(1., 0., 0.)),\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        0.\n    );\n\n    sk = clamp(sk, vec4(0.), vec4(1.));\n    \n    vec4 en = draw_scene_3d_cyclide_tex_end(\n        toWorld,\n        c,\n        //quat_from_angle_axis(0., vec3(1., 0., 0.)),\n        rayOrg,\n        normalize(rayDir),\n        fragCoord\n        );\n        \n    return mix(sk, en, a);\n}\n\n\n\nvec4 scene_ika_6(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    float end_1 = 1.5 / TEMPO_IKARUGA;\n    \n    vec4 fragColor = vec4(0.);\n    \n    if (t < end_1) {\n        float a = place(t, 0., end_1);\n        fragColor = scene_3d_cyclide_rt_to_sky(uv, fragCoord, aspect, a);\n    } else {\n        fragColor = scene_cyclide_3d_sky(uv, fragCoord, aspect, t - end_1);\n    }\n    \n    return fragColor;\n}\n\n\nvec4 scene_ika_7(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    vec4 fragColor = vec4(0.);\n    \n    float end_1 =         6. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 6. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 6. / TEMPO_IKARUGA;\n    \n    if (t < end_1) {\n        float a = place(t, 0., end_1);//sin(M_PI/2. * place(t, 0., end_1)) * .5 + .5;\n        fragColor = scene_cyclide_3d_sky_2(uv, fragCoord, aspect, a);\n    } else if (t < end_2) {\n        float a = place(t, end_1, end_2);\n        fragColor = scene_3d_cyclide_sky_to_end(uv, fragCoord, aspect, a);\n    } else if (t < end_3) {\n        float a = place(t, end_2, end_3);\n        \n        uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n        mat4 toWorld = transpose(mat4(\n            0,-2, 0, 0,\n            2, 0, 0, 0,\n            0, 0, 2, 0,\n            0, 0, 0, 1\n        ));\n\n        float c = mix(.8, 2., a);\n        vec3 rayOrg = vec3(2., 0., 0.);\n        vec3 rayDir = vec3(-1., uv);    \n        vec4 q_pov = quat_from_angle_axis(0., vec3(1., 0., 0));\n        mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n        toWorld = mat4(rot_pov_mat * mat3(toWorld));\n        \n        fragColor = draw_scene_3d_cyclide_tex_end(\n            toWorld,\n            c,\n            //quat_from_angle_axis(0., vec3(1., 0., 0.)),\n            rayOrg,\n            normalize(rayDir),\n            fragCoord\n            );\n    }\n    \n    \n    return fragColor;\n}\n\n\n\nvec4 ending_1(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n    U = (uv - vec2(0.4, .7)) * 15.;\n    CHR_D CHR_E CHR_M CHR_O spc CHR_B CHR_Y;\n        \n    U = (uv - vec2(0.25, .5)) * 8.;\n    CHR_T CHR_R CHR_E CHR_X spc CHR_C CHR_R CHR_E CHR_W \n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\n\nvec4 ending_2(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n\n    U = (uv - vec2(0.16, .72)) * 8.;\n    CHR_S CHR_C CHR_E CHR_N CHR_E spc CHR_O CHR_N CHR_E \n\n    U = (uv - vec2(0.18, .6)) * 15.;    \n    CHR_M CHR_U CHR_S CHR_I CHR_C spc CHR_I CHR_N CHR_S CHR_P CHR_I CHR_R CHR_E CHR_D spc CHR_B CHR_Y \n    \n    U = (uv - vec2(0.1, .3)) * 15.;\n    CHR_L CHR_A spc CHR_T CHR_R CHR_I CHR_L CHR_O CHR_G CHR_I CHR_E spc CHR_D CHR_U spc CHR_S CHR_A CHR_M CHR_E CHR_D CHR_I \n    U = (uv - vec2(0.22, .22)) * 15.;\n    CHR_O CHR_P CHR_E CHR_N CHR_I CHR_N CHR_G spc CHR_T CHR_H CHR_E CHR_M CHR_E;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\nvec4 ending_3(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n\n    U = (uv - vec2(0.14, .72)) * 8.;\n    CHR_M CHR_A CHR_I CHR_N spc CHR_S CHR_C CHR_E CHR_N CHR_E;\n\n    U = (uv - vec2(0.18, .6)) * 15.;    \n    CHR_M CHR_U CHR_S CHR_I CHR_C spc CHR_I CHR_N CHR_S CHR_P CHR_I CHR_R CHR_E CHR_D spc CHR_B CHR_Y;\n    \n    U = (uv - vec2(0.32, .3)) * 15.;\n    CHR_I CHR_K CHR_A CHR_R CHR_U CHR_G CHR_A;\n    \n    U = (uv - vec2(0.22, .22)) * 15.;\n    CHR_H CHR_I CHR_R CHR_O CHR_S CHR_H CHR_I spc CHR_I CHR_U CHR_C CHR_H CHR_I;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\n\nvec4 ending_4(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n\n    U = (uv - vec2(0.26, .72)) * 8.;\n    CHR_T CHR_H CHR_A CHR_N CHR_K CHR_S;\n    \n    U = (uv - vec2(0.34, .5)) * 8.;    \n    CHR_F CHR_O CHR_R;\n    \n    U = (uv - vec2(0.2, .3)) * 8.;\n    CHR_W CHR_A CHR_T CHR_C CHR_H CHR_I CHR_N CHR_G;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\n\n\nvec4 scene_end(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    vec4 fragColor = vec4(0.);\n    \n    vec2 org_uv = uv;\n    \n    float end_1 =         2.;\n    float end_2 = end_1 + 5.;\n    float end_3 = end_2 + 5.;\n    float end_4 = end_3 + 5.;\n    \n    float a = min(1., place(t, 0., end_1));\n\n    float s = mix(1., 2., a);\n    \n    uv = vec2(1.)-uv;\n    uv /= mix(1.,.5, a);\n    uv = vec2(1.)-uv;\n    \n    if (uv.x > 0. && uv.y > 0.) {\n        uv = mod(uv, vec2(1.));\n        uv = s * (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n        mat4 toWorld = transpose(mat4(\n            0,-2, 0, 0,\n            2, 0, 0, 0,\n            0, 0, 2, 0,\n            0, 0, 0, 1\n        ));\n\n        float c = 2.;\n        \n        if (t > end_1) {\n            float a_c = .5 * cos(t - end_1) + .5;\n            c = mix(.5, 2., a_c);\n        }\n        \n        vec3 rayOrg = vec3(2., 0., 0.);\n        vec3 rayDir = vec3(-1., uv);    \n        vec4 q_pov = quat_from_angle_axis(0., vec3(1., 0., 0));\n        mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n        toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n        fragColor = draw_scene_3d_cyclide_tex_end(\n            toWorld,\n            c,\n            //quat_from_angle_axis(0., vec3(1., 0., 0.)),\n            rayOrg,\n            normalize(rayDir),\n            fragCoord\n            );\n            \n         //fragColor = vec4(1.);\n    }\n    \n    vec2 t_uv = org_uv;\n    t_uv.x *= 2.;\n\n    if (t_uv.x < 1.) {\n\n        float screen_fade = .1;\n\n        vec4 ending_screen = vec4(0.);\n        float a = 0.;\n\n        if (t > end_1 && t < end_2) {\n            a = min(1., place(t, end_1, end_1 + screen_fade));\n            ending_screen = ending_1(t_uv, aspect/2.);\n        } else if (t < end_3) {\n            a = min(1., place(t, end_2, end_2 + screen_fade));\n            ending_screen = ending_2(t_uv, aspect/2.);\n        } else if (t < end_4) {\n            a = min(1., place(t, end_3, end_3 + screen_fade));\n            ending_screen = ending_3(t_uv, aspect/2.);\n        } else {\n            a = min(1., place(t, end_4, end_4 + screen_fade));\n            ending_screen = ending_4(t_uv, aspect/2.);\n        }\n    \n        fragColor = mix(fragColor, ending_screen, a);\n    }\n    \n    return fragColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    if (time < END_MSG) {\n        fragColor = scene_msg(fragCoord, time);\n    } else if (time < END_TRILOGY) {\n        fragColor = scene_0_trilogy(uv, aspect, time - END_MSG);\n    } else if (time < END_IKA_1) {\n        fragColor = scene_ika_1(uv, aspect, time - END_TRILOGY);        \n    } else if (time < END_IKA_2) {\n        fragColor = scene_ika_2(uv, aspect, time - END_IKA_1);\n    } else if (time < END_IKA_3) {\n        fragColor = scene_3d_cyclide_transition(uv, aspect, time - END_IKA_2);\n    } else if (time < END_IKA_5 /* 4 & 5 share the same scene */) {\n        fragColor = scene_3d_cyclide_rt(uv, aspect, time - END_IKA_3);\n    } else if (time < END_IKA_6) {\n        fragColor = scene_ika_6(uv, fragCoord, aspect, time - END_IKA_5);\n    } else if (time < END_IKA_7) {\n        fragColor = scene_ika_7(uv, fragCoord, aspect, time - END_IKA_6);\n        //fragColor = scene_cyclide_3d_sky(uv, fragCoord, aspect, time - (END_IKA_5 + 4. / TEMPO_IKARUGA));\n    } else {\n        fragColor = scene_end(uv, fragCoord, aspect, time - END_IKA_7);\n    }\n    \n    \n    //fragColor = scene_3d_cyclide_rt(uv, aspect, time);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TEMPO_IKARUGA 2.5\n\n#define END_MSG      3.\n#define END_TRILOGY (END_MSG + 10.)\n#define END_IKA_1   (END_TRILOGY + 29. / TEMPO_IKARUGA)\n#define END_IKA_2   (END_IKA_1 + 12. / TEMPO_IKARUGA)\n#define END_IKA_3   (END_IKA_2 + 36. / TEMPO_IKARUGA)\n#define END_IKA_4   (END_IKA_3 + 10. / TEMPO_IKARUGA)\n#define END_IKA_5   (END_IKA_4 + 12. / TEMPO_IKARUGA)\n#define END_IKA_6   (END_IKA_5 + 18. / TEMPO_IKARUGA)\n#define END_IKA_7   (END_IKA_6 + 18. / TEMPO_IKARUGA)\n\n#define T_MIN 1e-2\n#define M_PI 3.14159265358979323846\n\n/*\n// ----------------------------------------------------------------------------\n// Retrieve various status states \n// ----------------------------------------------------------------------------\n// We use Buffer A to store misc. info about the camera / mouse position...\n// We expect iChannel0 to have BufferA binded.\n\n#define MOUSE_P            ivec2(0, 0)\n#define INTERACTIVE_VIEW_P ivec2(0, 1)\n#define PERMANENT_VIEW_P   ivec2(1, 0)\n\n#define GET_PREV_MOUSE_STATE (texelFetch(iChannel0, MOUSE_P, 0))\n#define GET_INTERACTIVE_QUAT (texelFetch(iChannel0, INTERACTIVE_VIEW_P, 0))\n#define GET_PERMANENT_QUAT   (texelFetch(iChannel0, PERMANENT_VIEW_P, 0))\n*/\n\n// ----------------------------------------------------------------------------\n// Data structures\n// ----------------------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\nstruct Frame\n{\n    mat4 toWorld;\n    mat4 toStd; // = inverse(toWorld)\n};\n\n\nstruct Hit_rec \n{\n  vec3 position;\n  vec3 normal;\n  float dist;\n  int diff;\n  vec2 uv;\n};\n\nstruct SurfaceInfo {\n    vec2 uv;\n    vec3 tangent, bitangent, normal;\n};\n\n\nstruct Triangle \n{\n    vec3 a, b, c;\n    vec2 uv_a, uv_b, uv_c;\n   \tint diff;\n};\n\nstruct Sample\n{\n    vec3 direction;\n    float pdf;\n};\n\n\nstruct Light\n{\n    vec3 position;\n    vec3 power;\n};\n\n\n// ----------------------------------------------------------------------------\n// Utility functions\n// ----------------------------------------------------------------------------\n\nvec3 inv(vec3 x) \n{\n    return x / dot(x, x);\n}\n\n\nvec3 CyclideToCylinder(vec3 p, float c)\n{\n    return inv(p) - vec3(c, 0, 0);\n}\n\n\nvec3 CylinderToCyclide(vec3 q, float c)\n{\n    return inv(q + vec3(c, 0, 0));\n}\n\n\n// dithering\nuint Dilate(uint x) {\n    x = (x | (x << 8)) & 0x00FF00FFu;\n    x = (x | (x << 4)) & 0x0F0F0F0Fu;\n    x = (x | (x << 2)) & 0x33333333u;\n    x = (x | (x << 1)) & 0x55555555u;\n\n    return x;\n}\n\nuint BitReverse(uint x)\n{\n    x = ((x & 0x55555555u) <<  1u) | ((x & 0xAAAAAAAAu) >>  1u);\n    x = ((x & 0x33333333u) <<  2u) | ((x & 0xCCCCCCCCu) >>  2u);\n    x = ((x & 0x0F0F0F0Fu) <<  4u) | ((x & 0xF0F0F0F0u) >>  4u);\n    x = ((x & 0x00FF00FFu) <<  8u) | ((x & 0xFF00FF00u) >>  8u);\n    x = ((x & 0x0000FFFFu) << 16u) | ((x & 0xFFFF0000u) >> 16u);\n\n    return x;\n}\n\nuint BayerMatrixCoefficient(uint i, uint j, uint matrixSize)\n{\n    uint x = i ^ j;\n    uint y = j;\n    uint z = Dilate(x) | (Dilate(y) << 1);\n    uint b = BitReverse(z) >> (32u - (matrixSize << 1u));\n\n    return b;\n}\n\nfloat BayerMatrixCoefficient_Float(uint i, uint j, uint matrixSize)\n{\n    uint coeff = BayerMatrixCoefficient(i, j, matrixSize); \n    return float(coeff) * exp2(-float(matrixSize << 1u));\n}\n\n/*\n// Projects a point from screen space to a sphere.\n// This routine is used for the arcball camera.\nvec3 project_point(vec2 p, vec2 wh)\n{\n    float width = wh.x;\n    float height = wh.y;\n    \n    float scale = min(width, height) - 1.;\n    float px = (2. * p.x - width + 1.) / scale;\n    float py = (-2. * p.y + height - 1.) / scale;\n    \n    float len_sqr = px * px + py * py;\n    \n    float pz = 0.;\n    \n    if (len_sqr <= .5) {\n        pz = sqrt(1. - len_sqr);\n    } else {\n        pz = .5f / sqrt(len_sqr);\n    }\n    \n    return normalize(vec3(pz, px, py));\n}\n*/\n\n\nbool checkerboard(in vec2 uv, float cols, float lines)\n{\n    uv = vec2(cols, lines) * uv;\n    \n    return (mod(uv.x + floor(mod(uv.y, 2.0)), 2.0) < 1.0);\n}\n\n/*\n// ---------------------------------------\n// Tetrakis Sampler\nfloat TetrakisStd(vec2 P)\n{\n    const uint res = 6u;\n    const uint mask = ~(~0u << res);\n    uvec2 Q = uvec2(float(1u << res) * P);\n    bvec2 b1 = equal(Q, uvec2(0u));\n    bvec2 b2 = equal(Q, uvec2(mask));\n    \n    return float(Q.x == Q.y || Q.x == Q.y + 1u|| Q.x + 1u == Q.y || any(b1) || any(b2));\n}\n\n\nfloat Tetrakis(vec2 P)\n{\n    // mirrored repeat sampler\n    return td(P);\n    vec2 Q = fract(P / 2.0);\n    Q = 1.0f - abs(2.0f * Q - 1.0f);\n    \n    // evaluate the function\n    return TetrakisStd(Q);\n}\n//*/\n\n\nfloat t_grid(vec2 uv)\n{\n    float d = 2e-2;\n\n    return \n        step(abs(uv.x), d) \n      + step(abs(uv.y), d) \n      + step(abs(uv.x - uv.y), 1.5 * d)\n      + step(abs(1. - uv.x), d)\n      + step(abs(1. - uv.y), d);\n}\n\n\nfloat ts_grid(vec2 uv)\n{\n    float d = 2e-2;\n    float st = d / 4.;\n    return \n        smoothstep(abs(uv.x), abs(uv.x) + st, d)\n      + smoothstep(abs(uv.y), abs(uv.y) + st, d)\n      + smoothstep(abs(uv.x - uv.y), abs(uv.x - uv.y) + 2. * 1.5 * st, 1.5 * d)\n      + smoothstep(abs(1. - uv.x), abs(1. - uv.x + st), d)\n      + smoothstep(abs(1. - uv.y), abs(1. - uv.y + st), d);\n}\n\n\nfloat grid(vec2 uv)\n{\n    uv = fract(uv/2.);\n    uv = 2.*uv-1.;\n    return t_grid(abs(uv));\n}\n\n\nfloat place(float x, float a, float b)\n{\n    return (x - a) / (b - a);\n}\n\n\n// URNG\nfloat Urng(inout uint seed)\n{\n    // LCG values from Numerical Recipes\n    seed = 1664525u * seed + 1013904223u;\n    \n    return float(seed) / float(~0u);\n}\n\n\n// -----------------------------------------------------------------------------\n// GGX BSDF\n// specular reflection\nvec3 Reflect(vec3 wi, vec3 wm)\n{\n    return 2.0f * dot(wi, wm) * wm - wi;\n}\n\n\n// microfacet brdf\nfloat Ndf_Std_GGX(vec3 wm)\n{\n    if (wm.z > 0.0f) {\n        return 1.0f / M_PI;\n    }\n\n    return 0.0f;\n}\n\n\nfloat Ndf_GGX(vec3 wm, vec2 r)\n{\n    vec3 mStd = vec3(wm.x / r.x, wm.y / r.y, wm.z);\n    float nrmSqr = dot(mStd, mStd);\n    float nrmSqrSqr = nrmSqr * nrmSqr;\n    vec3 wmStd = mStd * inversesqrt(nrmSqr);\n\n    return Ndf_Std_GGX(wmStd) / (r.x * r.y * nrmSqrSqr);\n}\n\n\nfloat Sigma_Std_GGX(vec3 wi)\n{\n    return (1.0f + wi.z) / 2.0f;\n}\n\n\nfloat Sigma_GGX(vec3 wi, vec2 r)\n{\n    vec3 iStd = vec3(wi.x * r.x, wi.y * r.y, wi.z);\n    float nrm = inversesqrt(dot(iStd, iStd));\n    vec3 wiStd = iStd * nrm;\n\n    return Sigma_Std_GGX(wiStd) / nrm;\n}\n\n\nfloat Gc_GGX(vec3 wo, vec3 wi, vec2 r)\n{\n    if (wi.z > 0.0f && wo.z > 0.0f) {\n        float sigmaI = Sigma_GGX( wi, r);\n        float sigmaO = Sigma_GGX(-wo, r);\n        float tmp1 = wi.z * sigmaO;\n        float tmp2 = wo.z * sigmaI;\n\n        return tmp2 / (tmp1 + tmp2);\n    } else {\n        return 0.0f;\n    }\n}\n\n\nfloat PhaseFunction_GGX(vec3 wi, vec3 wo, vec2 r)\n{\n    vec3 wh = normalize(wi + wo);\n\n    return Ndf_GGX(wh, r) / (4.0f * Sigma_GGX(wi, r));\n}\n\nfloat PhaseFunction_GGX(\n    vec3 T,\n    vec3 B,\n    vec3 N,\n    vec3 L,\n    vec3 V,\n    vec2 R\n) {\n    mat3 TBN = transpose(mat3(T, B, N));\n    vec3 wi = normalize(TBN * V);\n    vec3 wo = normalize(TBN * L);\n\n    return PhaseFunction_GGX(wi, wo, R);\n}\n\n\nfloat Brdf_GGX(vec3 wi, vec3 wo, vec2 r)\n{\n    return PhaseFunction_GGX(wi, wo, r) * Gc_GGX(wo, wi, r);\n}\n\n\nfloat Brdf_GGX(\n    vec3 T,\n    vec3 B,\n    vec3 N,\n    vec3 L,\n    vec3 V,\n    vec2 R)\n{\n    mat3 TBN = transpose(mat3(T, B, N));\n    vec3 wi = normalize(TBN * V);\n    vec3 wo = normalize(TBN * L);\n\n    return Brdf_GGX(wi, wo, R);\n}\n\n\nvec3 ggxSampleImpl(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)\n{\n    // Section 3.2: transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n    // Section 4.1: orthonormal basis (with special case if cross product is zero)\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0.0f ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1,0,0);\n    vec3 T2 = cross(Vh, T1);\n    // Section 4.2: parameterization of the projected area\n    float r = sqrt(U1);\n    float phi = 2.0 * M_PI * U2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    // Section 4.3: reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n    // Section 3.4: transforming the normal back to the ellipsoid configuration\n    return normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z)));\n}\n\n\nvec3 SampleNormal_GGX(vec2 u, vec3 wi, vec2 r)\n{\n    return ggxSampleImpl(wi, r.x, r.y, u.x, u.y);\n}\n\n\nvec3 Sample_GGX(vec2 u, vec3 wi, vec2 r)\n{\n    vec3 wm = SampleNormal_GGX(u, wi, r);\n\n    return Reflect(wi, wm);\n}\n\n\nSample Sample_GGX(\n    vec2 u,\n    vec3 T,\n    vec3 B,\n    vec3 N,\n    vec3 V,\n    vec2 R)\n{\n    mat3 iTBN = mat3(T, B, N);\n    mat3 TBN = transpose(iTBN);\n    vec3 wi = normalize(TBN * V);\n    vec3 wm = SampleNormal_GGX(u, wi, R);\n    vec3 wo = Reflect(wi, wm);\n\n    return Sample(iTBN * wo, Gc_GGX(wo, wi, R));\n}\n\n// ------------------------------------------------------------------------------\n// Quaternion operations\n// ------------------------------------------------------------------------------\n\nvec4 quat_from_angle_axis(in float angle, in vec3 axis)\n{\n    float a = angle / 2.;\n    \n    return vec4(sin(a) * axis, cos(a));\n}\n\n\nvec4 mul_quat(in vec4 q1, in vec4 q2)\n{\n    vec4 res;\n    \n    res.xyz = cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz;\n    res.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n    \n    return res;\n}\n\n\nmat3 quat_to_rot(in vec4 quat) \n{    \n    float ii = quat[0]*quat[0];\n    float ij = quat[0]*quat[1];\n    float ik = quat[0]*quat[2];\n\n    float jj = quat[1]*quat[1];\n    float jk = quat[1]*quat[2];\n\n    float kk = quat[2]*quat[2];\n\n    float ir = quat[0]*quat[3];\n    float jr = quat[1]*quat[3];\n    float kr = quat[2]*quat[3];\n\n    return mat3(\n        1. - 2.*(jj + kk), 2.*(ij - kr)     , 2.*(ik + jr),\n        2.*(ij + kr)     , 1. - 2.*(ii + kk), 2.*(jk - ir),\n        2.*(ik - jr)     , 2.*(jk + ir)     , 1. - 2.*(ii + jj)\n    );\n}\n\n\n// ----------------------------------------------------------------------------\n// Materials\n// ----------------------------------------------------------------------------\n\n#define DIFF_GREEN        0\n#define DIFF_YELLOW       1\n#define DIFF_CHECKERBOARD 2\n#define DBG_NORMAL        3\n\n\nvec3 eval_diffuse(in Hit_rec rec) {\n    switch (rec.diff) {\n        case DIFF_GREEN:  return vec3(0.0, 0.8, 0.0);\n        case DIFF_YELLOW: return vec3(0.8, 0.8, 0.0);\n        case DIFF_CHECKERBOARD:\n            if (checkerboard(rec.uv, 20., 20.)) {\n                return vec3(.8, 0., 0.);\n            } else {\n                return vec3(.8);\n            }\n        case DBG_NORMAL: return rec.normal;\n        default: return vec3(0.);\n    }\n}\n\n\n// ------------------------------------------------------------------------------\n// SDF routines\n// ------------------------------------------------------------------------------\n\nfloat DistanceToCylinderStd(in vec3 p)\n{\n    return sqrt(dot(p.xy, p.xy)) - 1.0f;\n}\n\n\nfloat DistanceToCyclideStd(in vec3 p, float c)\n{\n    vec3 pInv = inv(p);\n    vec3 pInvStd = pInv - vec3(c, 0, 0);\n    float rInv = DistanceToCylinderStd(pInvStd);\n    vec3 qInv = pInv - normalize(vec3(pInvStd.xy, 0.0f) - vec3(c, 0, 0)) * rInv;   \n    vec3 q = inv(qInv);\n    \n    return min(distance(p, q), distance(p, vec3(0)));\n}\n\n\n// ---------------------------------------\n// sdf routines with frames\nfloat DistanceToCyclide(in Ray ray, float c, in Frame frame)\n{\n    vec4 oStd = frame.toStd * vec4(ray.origin, 1.0f);\n    vec4 dStd = frame.toStd * vec4(ray.direction, 0.0f);\n    float distanceStd = DistanceToCyclideStd(oStd.xyz, c);\n    vec4 o = frame.toWorld * (oStd + dStd * distanceStd);\n    \n    return distance(ray.origin, o.xyz);\n}\n\n\n// ---------------------------------------\n// Cyclide HitInfo\nSurfaceInfo CyclideSurfaceInfoStd(in vec3 p, float c)\n{\n    const float eps = 1e-4f; \n    const float pi = 3.14159265359f;\n    vec3 q = CyclideToCylinder(p, c);\n    float phi = atan(q.y, q.x);\n    vec3 t = vec3(0.0f, 0.0f, 1.0f);\n    vec3 b = vec3(-sin(phi), cos(phi), 0.0f);\n    vec3 qb = q + b * eps;\n    vec3 qt = q + t * eps;\n    vec3 pb = CylinderToCyclide(qb, c);\n    vec3 pt = CylinderToCyclide(qt, c);\n    vec3 tangent = normalize(pt - p);\n    vec3 bitangent = normalize(pb - p);\n    vec3 normal = normalize(cross(tangent, bitangent));\n    float tmp = phi < 0.0 ? phi + 2.0f * pi : phi;\n    vec2 uv = vec2(q.z, tmp / (2.0f * pi));\n    \n    return SurfaceInfo(uv, tangent, bitangent, normal);    \n}\n\n\nSurfaceInfo CyclideSurfaceInfo(in vec3 hitPos, float c, in Frame frame)\n{\n    vec3 pStd = (frame.toStd * vec4(hitPos, 1.0f)).xyz;\n    SurfaceInfo info = CyclideSurfaceInfoStd(pStd, c);\n    \n    info.tangent = normalize((frame.toWorld * vec4(info.tangent, 0.0f)).xyz);\n    info.bitangent = normalize((frame.toWorld * vec4(info.bitangent, 0.0f)).xyz);\n    info.normal = normalize((transpose(frame.toStd) * vec4(info.normal, 0.0f)).xyz);\n    \n    return info;\n}\n\n\n// ------------------------------------------------------------------------------\n// Hit functions\n// ------------------------------------------------------------------------------\n\nbool hit_cyclide(in float c, in Frame frame, in Ray ray, out Hit_rec rec)\n{\n    float dist_cyclide = DistanceToCyclide(ray, c, frame);\n    vec3 start_pos = ray.origin;\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u;\n    \n    while (dist_cyclide > T_MIN && iterationID < maxIterationCount) {\n        ray.origin += ray.direction * dist_cyclide;\n        dist_cyclide = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    if (dist_cyclide <= T_MIN) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        rec.dist     = length(start_pos - ray.origin);\n        rec.position = ray.origin;\n        rec.normal   = info.normal;//cyclide_normal(ray, c, frame);\n        rec.diff     = DBG_NORMAL;\n        rec.uv       = info.uv;\n    }\n    \n    return dist_cyclide <= T_MIN;\n}\n\n\nbool hit_triangle(in Triangle t, in Ray r, out Hit_rec rec) \n{\n\tvec3 e1 = t.b - t.a;\n    vec3 e2 = t.c - t.a;\n    vec3 q = cross(r.direction, e2);\n    float a = dot(e1, q);\n    \n    // No hit found so far\n    rec.dist = -1.0;\n    \n    if (a < T_MIN) {\n        return false;\n    }\n    \n    float f = 1. / a;\n    vec3 s = r.origin - t.a;\n    float u = f * dot(s, q);\n    \n    if (u < 0. || u > 1.) {\n        return false;\n    }\n    \n    vec3 rt = cross(s, e1);\n    float v = f * dot(r.direction, rt);\n    \n    if (v < 0.0 || (u + v) > 1.0) {\n        return false;\n    }\n    \n    float w = (1. - u - v);\n\n    // Hit found\n    rec.dist     = f * dot(e2, rt);\n    rec.position = r.origin + rec.dist*r.direction;\n    rec.normal   = normalize(cross(e1, e2));\n    rec.diff = t.diff;\n    rec.uv = u * t.uv_b + v * t.uv_c + w * t.uv_a;\n    \n    return true;\n}\n\n\n// ----------------------------------------------------------------------------\n// Scene definition\n// ----------------------------------------------------------------------------\n\n// Lighting\n\nvec3 ambiant = vec3(0.01, 0.01, 0.05);\n\nconst int n_lights = 1;\n\nLight[1] lights = Light[](\n     Light(vec3(3., 4., 3.), vec3(15.))\n);\n\n\n// Geometry\n\nconst int n_triangles = 2;\n\nTriangle[2] triangles = Triangle[](\n    Triangle(\n        // Coords\n        vec3(-5., 0., -5.), \n        vec3(-5., 0.,  5.),\n        vec3( 5., 0., -5.),\n        // uv\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    ),\n    Triangle(\n        // Coords\n        vec3(-5., 0.,  5.),\n        vec3( 5., 0.,  5.), \n        vec3( 5., 0., -5.),\n        // uv\n        vec2(1, 0),\n        vec2(1, 1),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    )\n);\n\n\nbool hit(in float c_cyclide, in Frame frame_cyclide, in Ray r_in, inout Hit_rec rec) \n{\n    Hit_rec curr_rec;\n    rec.dist = -1.;\n    \n    bool hit_found = false;\n    \n    // Find closest sphere intersection\n    /*\n    for (int i = 0; i < n_spheres; i++) {\n        if (   hit_sphere(spheres[i], r_in, curr_rec) \n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }\n    }*/\n\n    // Find closest triangle intersection\n    //*\n    for (int i = 0; i < n_triangles; i++) {\n        if (   hit_triangle(triangles[i], r_in, curr_rec)\n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }  \n    }\n    //*/\n    // Cyclide raymarching :-]\n    if (hit_cyclide(c_cyclide, frame_cyclide, r_in, curr_rec)\n        && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n        rec = curr_rec;\n        hit_found = true;\n    }\n    \n    return hit_found;\n}\n\n\n// Trace ray and return the resulting contribution of this ray\nvec3 trace_ray(in float c_cyclide, in Frame frame_cyclide, in Ray r, in int n_bounces)\n{\n    Hit_rec rec;\n    \n    vec3 ret_col = vec3(0.);\n    vec3 attenuation = vec3(1.);\n    \n    for (int i = 0; i < n_bounces; i++) {\n        if (hit(c_cyclide, frame_cyclide, r, rec)) {\n            // get the diffuse color\n            vec3 diffuse = eval_diffuse(rec);\n                \n            for (int l = 0; l < n_lights; l++) {\n                vec3 light_dir = lights[i].position - rec.position;\n                float light_dist = length(light_dir);\n\n                light_dir = normalize(light_dir);\n\n                // check if in shade: launch a ray from the lightsource to the sphere\n                Ray shadow_ray = Ray(lights[i].position, -light_dir);\n\n                Hit_rec shadow_ray_rec;\n                hit(c_cyclide, frame_cyclide, shadow_ray, shadow_ray_rec);\n\n                if (shadow_ray_rec.dist > light_dist - 100.*T_MIN) {\n                    // BRDF: the geometry is directly light by the lightsource\n                    float lambert = max(0., dot(light_dir, rec.normal));\n                    vec3 light_power = lights[i].power / (light_dist * light_dist);\n                    ret_col += attenuation * diffuse * lambert * light_power;\n                }\n            }\n            \n            // Ambiant lighting, always affecting the hitpoint\n            ret_col += attenuation * ambiant * diffuse;\n            \n            // Generate the reflected ray\n            r.direction = normalize(reflect(r.direction, rec.normal)); \n            r.origin = rec.position + r.direction * 2. * T_MIN;\n            \n            // Compute the Fresnel term using Schlick's approximation\n            float n1 = 1.;\n            float n2 = 2.1;\n            float r0 = (n1 - n2)/(n1 + n2);\n            r0 = r0*r0;\n            float fresnel = r0 + (1. - r0) * pow(1. - dot(rec.normal, r.direction), 5.);\n            \n            attenuation *= fresnel;\n        } else {\n            // No hit found, use the background instead\n            ret_col += attenuation * ambiant;\n            break;\n        }\n    }\n    \n    return ret_col;\n}\n\n\n// ------------------------------------------------------------------------------\n// Text drawing routines\n// ------------------------------------------------------------------------------\n// From FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define nspc  U.x+=.5;\n#define spct  U.x-=.1;\n#define nspct  U.x+=.1;\n#define C(c) O+= char(U,64+CAPS+c); spc\n#define N(n) O+= pInt(U,float(n),log(float(n))/log(10.0)+1.0);\n#define TWO_DEG N(2) spc spct low C(80)\n\n\n#define CHR_A C(1)\n#define CHR_B C(2)\n#define CHR_C C(3)\n#define CHR_D C(4)\n#define CHR_E C(5)\n#define CHR_F C(6)\n#define CHR_G C(7)\n#define CHR_H C(8)\n#define CHR_I C(9)\n#define CHR_J C(10\n#define CHR_K C(11)\n#define CHR_L C(12)\n#define CHR_M C(13)\n#define CHR_N C(14)\n#define CHR_O C(15)\n#define CHR_P C(16)\n#define CHR_Q C(17)\n#define CHR_R C(18)\n#define CHR_S C(19)\n#define CHR_T C(20)\n#define CHR_U C(21)\n#define CHR_V C(22)\n#define CHR_W C(23)\n#define CHR_X C(24)\n#define CHR_Y C(25)\n#define CHR_Z C(26)\n\n\n// ------------------------------------------------------------------------------\n// Trilogie du samedi\n// ------------------------------------------------------------------------------\n\nfloat drawCircle(vec2 uv, vec2 c, float r) \n{\n    uv = uv - c;\n    \n    if (dot(uv, uv) < r*r) {\n        return 0.;\n    } else {\n        return 1.;\n    }\n}\n\n\nvec3 lighting_effect(vec2 uv, vec2 c, float r0, float r1)\n{\n    vec3 col = vec3(0.69, 0.79, 0.73);\n    uv = uv - c;\n    \n    float dist_center = dot(uv, uv);\n    \n    if (dist_center < r0*r0) {\n        return vec3(1.);\n    } else if (dist_center <= r1*r1) {\n        float a = place(dist_center, r0*r0, r1*r1);      \n        return pow(smoothstep(col, vec3(0) , vec3(a)), vec3(15.));\n    }\n    \n    return vec3(0);\n}\n\n\nfloat drawCircles(vec2 uv, float dist, vec2 c, float r, float t)\n{\n    float rot = t / 3.;\n    float theta_1 = -rot + 2.*M_PI/3.;\n    float theta_2 = -rot + 4.*M_PI/3.;\n    float theta_3 = -rot + 2.*M_PI;\n    \n    float ret = 1.;\n    \n    ret *= drawCircle(uv, dist * vec2(cos(theta_1), sin(theta_1)) + c, r/3.);\n    ret *= drawCircle(uv, dist * vec2(cos(theta_2), sin(theta_2)) + c, r/3.);\n    ret *= drawCircle(uv, dist * vec2(cos(theta_3), sin(theta_3)) + c, r/3.);\n    \n    return ret;\n}\n\n\nvec3 drawCircles_light(vec2 uv, float dist, vec2 c, float r, float t)\n{    \n    float rot = t / 3.;\n    float theta_1 = -rot + 2.*M_PI/3.;\n    float theta_2 = -rot + 4.*M_PI/3.;\n    float theta_3 = -rot + 2.*M_PI;\n    \n    vec3 ret = vec3(0);\n    \n    float r0 = r * .2;\n    float r1 = r * 1.;\n    \n    ret += lighting_effect(uv, dist * vec2(cos(theta_1), sin(theta_1)) + c, r0, r1);\n    ret += lighting_effect(uv, dist * vec2(cos(theta_2), sin(theta_2)) + c, r0, r1);\n    ret += lighting_effect(uv, dist * vec2(cos(theta_3), sin(theta_3)) + c, r0, r1);\n    \n    return ret;\n}\n\n\nvec3 tri_step_01(vec2 uv, float aspect, float t)\n{    \n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom out\n    uv *= 5.;\n    \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(1., 20., place(t, 0., time_fade));\n    \n    col += lighting_effect(uv, vec2(0), r_inner_lighting, r_outer_lighting);\n    \n    // Highly deformated one\n    col += lighting_effect(vec2(uv.x, 0.015 *uv.y), vec2(0), 0.01, .1);\n    \n    col *= drawCircles(uv, radius_each, vec2(0), radius_all, t);\n    \n    return col;\n}\n\n\nvec3 tri_step_02(vec2 uv, float aspect, float t)\n{    \n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n        \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(0.1, 2., place(t, 0., time_fade));\n    \n    col += lighting_effect(uv, vec2(0), r_inner_lighting, r_outer_lighting);\n    // Highly deformated one\n    col += lighting_effect(vec2(0.015 * uv.x, uv.y), vec2(0), 0.01, .1);\n    \n    col *= drawCircles(uv, radius_each, vec2(0), radius_all, t);\n    \n    // fade to white at the very end\n    col = mix(col, vec3(1.), place(t, .7, .95));\n    \n    return col;\n}\n\n\nvec3 tri_zoom(vec2 uv, float aspect, vec2 c_lighting, vec2 c_tri, float t) \n{\n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom in\n    uv *= .5;\n    \n    // translate\n    //uv.y += .4;\n    \n    float time_fade = 1.;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .8;\n    float radius_each = .4;\n    \n    float r_inner_lighting = 0.1;\n    \n    float a = clamp(2. * place(t, 0., time_fade), 0., 2.);\n    float r_outer_lighting = mix(0.5, 3., a < 1. ? a : 2. - a);\n    vec3 lighting = lighting_effect(uv, c_lighting, r_inner_lighting, r_outer_lighting);\n    \n    lighting *= sin(M_PI * place(t, 0., time_fade));\n    \n    col += lighting;\n    \n    col *= drawCircles(uv, radius_each, c_tri, radius_all, t);\n        \n    return col;\n}\n\n\nvec3 tri_step_03(vec2 uv, float aspect, float t) \n{\n    return tri_zoom(uv, aspect, vec2(-.2, .0), vec2(0, -.35), t);\n}\n\n\nvec3 tri_step_04(vec2 uv, float aspect, float t)\n{\n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom in\n    uv *= 2.;\n    \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(0.1, 2., place(t, 0., time_fade));\n    \n    col += lighting_effect(uv, vec2(0), r_inner_lighting, r_outer_lighting);\n    \n    col *= drawCircles(uv, radius_each, vec2(0.1, 0.3), radius_all, t);\n    \n    // fade to white at the very end\n    col = mix(col, vec3(1.), place(t, .4, .6));\n    \n    return col;\n}\n\n\nvec3 tri_step_05(vec2 uv, float aspect, float t)\n{\n    return tri_zoom(uv, aspect, vec2(.2, -.1), vec2(-0.3, .1), t);\n}\n\n\nvec3 tri_step_07(vec2 uv, float aspect, float t)\n{\n    return tri_zoom(uv, aspect, vec2(-.2, -.1), vec2(0.2, .2), t);\n}\n\n\n\n/*\n Skydome\n =======\n\n This is highly untested code... have to be done on time.\n\n It is taking the implementation of the analytical skylight and\n solar radiance models presented in the SIGGRAPH 2012 paper\n\n\n \"An Analytic Model for Full Spectral Sky-Dome Radiance\"\n\n and the 2013 IEEE CG&A paper\n\n \"Adding a Solar Radiance Function to the Hosek Skylight Model\"\n\n both by \n\n Lukas Hosek and Alexander Wilkie\n Charles University in Prague, Czech Republic\n\n\n It is using the albedo 0 and turbidity 1 coefficients from the\n code provided by the authors.\n\n You can get the code (3-clause BSD license) from there:\n https://cgg.mff.cuni.cz/projects/SkylightModelling/\n*/\n\nvec3 hosek_rgb[] = vec3[](\n    vec3(-1.099459e+000, -1.140530e+000, -1.372629e+000),\n    vec3(-1.335146e-001, -1.982747e-001, -4.905585e-001),\n    vec3(-4.083223e+000, -7.512730e+000, -4.100789e+001),\n    vec3(5.919603e+000, 8.403899e+000, 4.122169e+001),\n    vec3(-1.104166e-001, -5.699038e-002, -7.389360e-003),\n    vec3(1.600158e+000, 9.015907e-001, 4.839359e-001),\n    vec3(-1.326538e-006, 3.392161e-002, 6.474757e-003),\n    vec3(4.917807e+000, 4.772522e+000, 3.471755e+000),\n    vec3(5.127716e-001, 5.111184e-001, 5.092936e-001),\n    vec3(-1.169858e+000, -1.165117e+000, -1.523025e+000),\n    vec3(-1.832793e-001, -1.852955e-001, -6.497084e-001),\n    vec3(9.694744e-001, 2.963684e+000, 6.249857e+000),\n    vec3(9.495762e-002, -2.262274e+000, -5.662543e+000),\n    vec3(-4.738918e-002, -1.571683e-001, -1.908402e-002),\n    vec3(2.194171e-001, 6.339974e-001, 5.512810e-001),\n    vec3(1.095749e-001, 4.977879e-002, -2.181049e-005),\n    vec3(3.603604e+000, 7.243307e+000, 2.507663e+000),\n    vec3(3.815119e-001, 4.220053e-001, 4.339598e-001),\n    vec3(-9.665225e-001, -1.169936e+000, -1.035567e+000),\n    vec3(-1.403888e-001, -3.357429e-001, -7.478740e-002),\n    vec3(5.194457e+000, 1.911291e+000, 9.221030e-001),\n    vec3(-1.107607e+000, -2.391074e-001, -2.140047e+000),\n    vec3(-8.135181e-001, -4.791643e-001, -2.374146e-002),\n    vec3(4.969661e+000, 1.446113e+000, 3.795517e-001),\n    vec3(-2.300508e-001, -9.178108e-002, -1.769134e-002),\n    vec3(-2.489350e+000, -4.700239e+000, 7.479831e+000),\n    vec3(1.279158e+000, 8.096219e-001, 7.729303e-001),\n    vec3(-1.292508e+000, -1.060246e+000, -1.271086e+000),\n    vec3(-1.299552e-001, -1.051633e-001, -5.588190e-001),\n    vec3(-2.071404e+000, 5.013829e-001, 6.908023e-001),\n    vec3(-4.752482e-002, 2.832309e+000, 2.096832e+000),\n    vec3(1.215598e+000, -3.707855e-001, -2.453967e-001),\n    vec3(-1.904179e+000, 1.523131e+000, 1.410648e+000),\n    vec3(3.027985e-001, 9.163749e-002, 4.475036e-002),\n    vec3(8.707768e+000, 5.604183e+000, -4.719115e+000),\n    vec3(6.332446e-002, 7.208566e-001, 5.741186e-001),\n    vec3(-9.264666e-001, -1.089753e+000, -9.712598e-001),\n    vec3(-1.696780e-001, -2.382167e-001, -7.033926e-002),\n    vec3(4.574070e+000, 2.360312e+000, 9.167274e-001),\n    vec3(-4.232936e-001, -5.902562e+000, -9.502097e-001),\n    vec3(-7.575833e+000, -8.799894e+000, 3.004684e-001),\n    vec3(5.079755e+000, 1.377692e+000, 4.547054e-001),\n    vec3(-2.576343e-001, -6.131633e-002, -5.929017e-002),\n    vec3(-4.506805e+000, -1.415472e+000, 5.266196e+000),\n    vec3(6.908129e-001, 6.124057e-001, 7.204135e-001),\n    vec3(-1.139072e+000, -1.075481e+000, -1.087457e+000),\n    vec3(-1.796056e-001, -1.242391e-001, -1.888896e-001),\n    vec3(1.923311e+000, 1.425781e+000, 8.156686e-001),\n    vec3(6.788529e+000, 8.810319e+000, 3.101712e-001),\n    vec3(-2.364389e+000, -2.922646e+000, -2.155419e+000),\n    vec3(-1.064041e+000, 1.486520e+000, 1.422205e+000),\n    vec3(1.717010e-001, 3.270580e-002, 9.692261e-002),\n    vec3(1.534681e+000, 3.889783e+000, 3.122404e+000),\n    vec3(5.015810e-001, 4.999482e-001, 4.999430e-001));\n\n\nvec3 hosek_rad[] = vec3[](\n    vec3(1.962684e+000, 1.590330e+000, 9.926518e-001),\n    vec3(1.159831e+000, 1.355401e+000, 1.999494e+000),\n    vec3(4.450588e+000, 1.151412e+000, -4.136109e+000),\n    vec3(5.079633e+000, 1.359116e+001, 1.856270e+001),\n    vec3(4.437388e+000, 5.857714e+000, 1.351028e+001),\n    vec3(4.324573e+000, 8.090833e+000, 1.390238e+001));\n\n\nvoid getCoefs(float solar_elevation, out vec3 config[9]) \n{\n    solar_elevation = pow(solar_elevation / (3.14 / 2.0), (1.0 / 3.0));\n\n    // albedo 0 & turbidity 1\n    for (int i = 0; i < 9; i++) {\n        config[i] = pow(1.0-solar_elevation, 5.0) * hosek_rgb[i]  + \n            5.0  * pow(1.0-solar_elevation, 4.0) * solar_elevation * hosek_rgb[i+9] +\n            10.0*pow(1.0-solar_elevation, 3.0)*pow(solar_elevation, 2.0) * hosek_rgb[i+18] +\n            10.0*pow(1.0-solar_elevation, 2.0)*pow(solar_elevation, 3.0) * hosek_rgb[i+27] +\n            5.0*(1.0-solar_elevation)*pow(solar_elevation, 4.0) * hosek_rgb[i+36] +\n            pow(solar_elevation, 5.0)  * hosek_rgb[i+45];\n\n    }\n\n}\n\n\nvec3 getRad(float solar_elevation) \n{\n    solar_elevation = pow(solar_elevation / (3.14 / 2.0), (1.0 / 3.0));\n\n    // albedo 0 & turbidity 1\n    return \n        pow(1.0-solar_elevation, 5.0) * hosek_rad[0] +\n        5.0*pow(1.0-solar_elevation, 4.0)*solar_elevation * hosek_rad[1] +\n        10.0*pow(1.0-solar_elevation, 3.0)*pow(solar_elevation, 2.0) * hosek_rad[2] +\n        10.0*pow(1.0-solar_elevation, 2.0)*pow(solar_elevation, 3.0) * hosek_rad[3] +\n        5.0*(1.0-solar_elevation)*pow(solar_elevation, 4.0) * hosek_rad[4] +\n        pow(solar_elevation, 5.0) * hosek_rad[5];\n}\n\n\nvec3 radiance_rgb(float solar_elevation, float theta, float gamma)\n{\n    vec3 config[9];\n    getCoefs(solar_elevation, config);\n\n    vec3 rad = getRad(solar_elevation);\n\n    vec3 expM;\n    expM.r = exp(config[4].r * gamma);\n    expM.g = exp(config[4].g * gamma);\n    expM.b = exp(config[4].b * gamma);\n\n    float rayM = cos(gamma)*cos(gamma);\n\n    vec3 mieM = vec3(0.);\n    mieM.r = (1.0 + rayM) / pow((1.0 + config[8].r*config[8].r - 2.0*config[8].r*cos(gamma)), 1.5);\n    mieM.g = (1.0 + rayM) / pow((1.0 + config[8].g*config[8].g - 2.0*config[8].g*cos(gamma)), 1.5);\n    mieM.b = (1.0 + rayM) / pow((1.0 + config[8].b*config[8].b - 2.0*config[8].b*cos(gamma)), 1.5);\n\n    float zenith = sqrt(cos(theta));\n\n    return rad * (1.0 + config[0] * exp(config[1] / (cos(theta) + 0.01))) *\n        (config[2] + config[3] * expM + config[5] * rayM + config[6] * mieM + config[7] * zenith);\n}\n\n\nvec3 skyColor(in vec3 dir, in vec3 sunPos)\n{\n    // below horizon\n    dir.y = max(dir.y, 0.);\n    \n\tdir = normalize(dir);\n    float gamma = acos(dot(dir, sunPos));\n    float theta = acos(dir.y);\n    float elev = 3.14/2. - acos(sunPos.y);\n    \n    return radiance_rgb(elev, theta, gamma) / 10.;\n}\n\n\n// Add an effect for the ground to avoid hard transition\nvec3 skyColor_hack(in vec3 dir, in vec3 sunPos)\n{\n    if (dir.y < .01) {\n        // Bellow the horizon\n        vec3 sk1 = 0.34 * skyColor(vec3(dir.x, 0.01, dir.z), sunPos);\n        vec3 sk2 = skyColor(vec3(dir.x, -dir.y + 0.01, dir.z), sunPos);\n\n        float a =  clamp(place(-dir.y - 0.1, -.1, .1), 0.01, 1.);\n\n        return mix(sk1, sk2, 1. - a);\n    }\n    \n    return skyColor(dir, sunPos);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ----------------------\n// Basic sound synthetiser\n// ----------------------\n\n// https://mixbutton.com/mixing-articles/music-note-to-frequency-chart/\n\n#define C0\t16.35\n#define D0\t18.35\n#define E0\t20.60\n#define F0\t21.83\n#define G0\t24.50\n#define A0\t27.50\n#define B0\t30.87\n\n#define C1\t32.70\n#define D1\t36.71\n#define E1\t41.20\n#define F1\t43.65\n#define G1\t49.00\n#define A1\t55.00\n#define B1\t61.74\n\n#define C2\t65.41\n#define D2\t73.42\n#define E2\t82.41\n#define F2\t87.31\n#define G2\t98.00\n#define A2\t110.00\n#define B2\t123.47\n\n#define C3\t130.81\n#define D3\t146.83\n#define E3\t164.81\n#define F3\t174.61\n#define G3\t196.00\n#define A3\t220.00\n#define B3\t246.94\n\n#define C4 261.63\n#define D4 293.66\n#define E4 329.63\n#define F4 349.23\n#define G4 392.00\n#define A4 440.00\n#define B4 493.88\n\n#define C5 523.25\n#define D5 587.33\n#define E5 659.25\n#define F5 698.46\n#define G5 783.99\n#define A5 880.00\n#define B5 987.77\n\n#define C6 1046.50\n#define D6 1174.66\n#define E6 1318.51\n#define F6 1396.91\n#define G6 1567.98\n#define A6 1760.00\n#define B6 1975.53\n\n#define C7 2093.00\n#define D7 2349.32\n#define E7 2637.02\n#define F7 2793.83\n#define G7 3135.96\n#define A7 3520.00\n#define B7 3951.07\n\n#define C8 4186.01\n#define D8 4698.63\n#define E8 5274.04\n#define F8 5587.65\n#define G8 6271.93\n#define A8 7040.00\n#define B8 7902.13\n\n#define CS0\t17.32\n#define DS0\t19.45\n#define FS0\t23.12\n#define GS0\t25.96\n#define AS0\t29.14\n\n#define CS1 34.65\n#define DS1 38.89\n#define FS1 46.25\n#define GS1 51.91\n#define AS1 58.27\n\n#define CS2 69.30\n#define DS2 77.78\n#define FS2 92.50\n#define GS2 103.83\n#define AS2 116.54\n\n#define CS3 138.59\n#define DS3 155.56\n#define FS3 185.00\n#define GS3 207.65\n#define AS3 233.08\n\n#define CS4 277.18\n#define DS4 311.13\n#define FS4 369.99\n#define GS4 415.30\n#define AS4 466.16\n\n#define CS5 554.37\n#define DS5 622.25\n#define FS5 739.99\n#define GS5 830.61\n#define AS5 932.33\n\n#define CS6 1108.73\n#define DS6 1244.51\n#define FS6 1479.98\n#define GS6 1661.22\n#define AS6 1864.66\n\n#define CS7 2217.46\n#define DS7 2489.02\n#define FS7 2959.96\n#define GS7 3322.44\n#define AS7 3729.31\n\n#define CS8 4434.92\n#define DS8 4978.03\n#define FS8 5919.91\n#define GS8 6644.88\n#define AS8 7458.62\n\n\nfloat sawtooth(float f, float t)\n{\n    float v = t * f;\n    return v - floor(v);\n}\n\n\nfloat square(float f, float t)\n{\n    return sawtooth(f, t) < .5 ? 0. : 1.;\n}\n\n\nfloat triang(float f, float t)\n{\n    float v = 2. * sawtooth(f, t);\n    \n    return v < 1. ? v : 2. - v;\n}\n\n\nfloat sine(float f, float t)\n{\n    return (sin(6.2831 * f * t) + 1.) / 2.;\n}\n\n\nfloat noise(vec2 p)\n{\n    p = floor(p*2500.0)/2500.0;\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\n\n// -----\n// Instruments\n// -----\n\nstruct Note\n{\n    float start;\n    float len;\n    float freq;\n};\n\n\nfloat play_standard_note(Note note, float track_pos, float time)\n{   \n    float f = note.freq;// + m;\n    float sound = .8*sawtooth(note.freq, time) + .2*triang(note.freq, time);\n    //sound *= 0.6 * (sine(5., time) + 1.) / 2. + 0.4;\n    \n    // Amplitude modulation\n    float ampl_max     = 1.;\n    float ampl_sustain = .6;\n    float attack  = .05;\n    float decay   = .2;\n    float release = .2;\n    \n    float ampl = 0.;\n    \n    float curr_local_time = track_pos - note.start;\n    \n    if (curr_local_time > note.len) {\n        return 0.;\n    }\n    \n    \n    if (curr_local_time < attack) {\n        float alpha = place(curr_local_time, 0., attack);\n        ampl = mix(0., ampl_max, alpha);\n    } else if (curr_local_time < (attack + decay)) {\n        float alpha = place(curr_local_time, attack, attack + decay);\n        ampl = mix(ampl_max, ampl_sustain, alpha);\n    } else if (curr_local_time > (note.len - release)) {\n        float alpha = place(curr_local_time, note.len - release, note.len);\n        ampl = mix(ampl_sustain, 0., alpha);\n    } else {\n        ampl = ampl_sustain;\n    }\n    \n    return ampl * sound;\n}\n\n\nfloat play_bass_note(Note note, float track_pos, float time)\n{   \n    float sound = noise(vec2(note.freq * time));//triang(note.freq, time) + square(note.freq, time);\n    \n    // Amplitude modulation\n    float ampl = 1.;\n    float attack  = .01;\n    float decay   = .5;\n    float release = .05;\n    \n    float curr_local_time = track_pos - note.start;\n    \n    if (curr_local_time > note.len) {\n        return 0.;\n    }\n    \n    \n    if (curr_local_time < attack) {\n        float alpha = place(curr_local_time, 0., attack);\n        ampl = mix(0., ampl, alpha);\n    } else if (curr_local_time < (attack + decay)) {\n        float alpha = place(curr_local_time, attack, attack + decay);\n        ampl = mix( ampl, .1, alpha);\n    } else if (curr_local_time > (note.len - release)) {\n        float alpha = place(curr_local_time, note.len - release, note.len);\n        ampl = mix(.1, 0., alpha);\n    } else {\n        ampl = .1;\n    }\n    \n    return ampl * sound;\n}\n\n\n// ------\n// Melody\n// ------\n\n// -- TRILOGIE DU SAMEDI --\n\n#define N_NOTES_TRILOGY_HIGH 15\nNote[N_NOTES_TRILOGY_HIGH] score_trilogy_high = Note[](\n    Note(0.000000, 1.000000, G4),\n    Note(1.000000, 1.000000, G4),\n    Note(2.000000, 0.500000, G4),\n    Note(2.500000, 0.500000, AS4),\n    Note(3.000000, 1.000000, G4),\n    Note(4.000000, 1.000000, G4),\n    Note(5.000000, 0.500000, G4),\n    Note(5.500000, 0.500000, C5),\n    Note(6.000000, 1.000000, G4),\n    Note(7.000000, 1.000000, G4),\n    Note(8.000000, 0.500000, G4),\n    Note(8.500000, 0.500000, D5),\n    Note(9.000000, 0.500000, G4),\n    Note(9.500000, 0.500000, D4),\n    Note(10.000000, 1.000000, G4)\n);\n\n#define N_NOTES_TRILOGY_LOW 5\nNote[N_NOTES_TRILOGY_LOW] score_trilogy_low = Note[](\n    Note(0.000000, 3.000000, C2),\n    Note(3.000000, 3.000000, DS2),\n    Note(6.000000, 3.000000, G2),\n    Note(9.000000, 1.000000, D3),\n    Note(10.000000, 1.000000, G2)\n);\n\n#define N_NOTES_TRILOGY_P 4\nNote[N_NOTES_TRILOGY_P] score_trilogy_p = Note[](\n    Note(0.  , 1., 100.),\n    Note(3.  , 1., 100.),\n    Note(6.  , 1., 100.),\n    Note(9.  , 1., 100.)\n);\n\n\nvec2 play_trilogy(float time)\n{\n    vec2 sound = vec2(0);\n    \n    // Adjust tempo\n    float t = time * 1.4;\n    \n    for (int i = 0; i < N_NOTES_TRILOGY_HIGH; i++) {\n        if (score_trilogy_high[i].start <= t \n        && (score_trilogy_high[i].start + score_trilogy_high[i].len) >= t) {\n            //sound += .2 * vec2(sin(6.2831*score[i].freq*time));\n            sound += play_standard_note(score_trilogy_high[i], t, time);\n        }\n    }\n        \n    for (int i = 0; i < N_NOTES_TRILOGY_LOW; i++) {\n        if (score_trilogy_low[i].start <= t \n        && (score_trilogy_low[i].start + score_trilogy_low[i].len) >= t) {\n            sound += .8 * play_standard_note(score_trilogy_low[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_TRILOGY_P; i++) {\n        if (score_trilogy_p[i].start <= t \n        && (score_trilogy_p[i].start + score_trilogy_p[i].len) >= t) {\n            sound += play_bass_note(score_trilogy_p[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\n// -- HIKARUGA --\n\n\n#define N_NOTES_HIKARUGA_HIGH_1 23\nNote[N_NOTES_HIKARUGA_HIGH_1] score_ikaruga_high_1 = Note[](\n    Note(0.000000, 2.000000, C4),\n    Note(2.000000, 0.300000, C4),\n    Note(2.300000, 0.300000, C4),\n    Note(2.600000, 0.300000, C4),\n    Note(2.900000, 1.000000, B3),\n    Note(3.900000, 1.000000, G3),\n    Note(4.900000, 2.000000, E3),\n    Note(6.900000, 1.000000, E3),\n    Note(7.900000, 1.000000, G3),\n    Note(8.900000, 1.000000, E3),\n    Note(9.900000, 3.000000, A3),\n    Note(12.900000, 1.000000, A3),\n    Note(13.900000, 1.000000, B3),\n    Note(14.900000, 1.000000, C4),\n    Note(15.900000, 2.000000, C4),\n    Note(17.900000, 0.300000, B3),\n    Note(18.200000, 3.000000, A3),\n    Note(21.200000, 1.000000, A3),\n    Note(22.200000, 1.000000, B3),\n    Note(23.200000, 1.000000, C4),\n    Note(24.200000, 2.000000, B3),\n    Note(26.200000, 0.300000, E3),\n    Note(26.500000, 2.500000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_1 12\nNote[N_NOTES_HIKARUGA_LOW_1] score_ikaruga_low_1 = Note[](\n    Note(0.000000, 3.000000, F2),\n    Note(3.000000, 2.000000, E2),\n    Note(5.000000, 3.000000, C2),\n    Note(8.000000, 2.000000, E2),\n    Note(10.000000, 3.000000, D2),\n    Note(13.000000, 3.000000, F2),\n    Note(16.000000, 2.330000, E2),\n    Note(18.330000, 2.800000, DS2),\n    Note(21.200000, 3.000000, FS2),\n    Note(24.200000, 2.000000, GS2),\n    Note(26.200000, 0.330000, E2),\n    Note(26.500000, 2.500000, A3)\n);\n// DURATION 29.\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_2 9\nNote[N_NOTES_HIKARUGA_HIGH_2] score_ikaruga_high_2 = Note[](\n    Note(0., 1., A5),\n    Note(0., 1., C6), \n    Note(0., 1., E6),\n    Note(1., 1., A5),\n    Note(1., 1., C6),\n    Note(1., 1., E6),\n    Note(2., 1., A5),\n    Note(2., 1., C6),\n    Note(2., 1., E6)\n);\n\n#define N_NOTES_HIKARUGA_LOW_2 16\nNote[N_NOTES_HIKARUGA_LOW_2] score_ikaruga_low_2 = Note[](\n    Note(0.00, .25, A2),\n    Note(0.25, .25, E2),\n    Note(0.50, .25, A2),\n    Note(0.75, .25, C3),\n    Note(1.00, .25, A2),\n    Note(1.25, .25, E2),\n    Note(1.50, .25, A2),\n    Note(1.75, .25, C3),\n    Note(2.00, .25, A2),\n    Note(2.25, .25, E2),\n    Note(2.50, .25, A2),\n    Note(2.75, .25, C3),\n    Note(3.00, .25, A2),\n    Note(3.25, .25, E2),\n    Note(3.50, .25, A2),\n    Note(3.75, .25, C3)\n);\n// DURATION 12.\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_3 20\nNote[N_NOTES_HIKARUGA_HIGH_3] score_ikaruga_high_3 = Note[](\n    Note(0.000000, 1.000000, A3),\n    Note(1.000000, 2.000000, E4),\n    Note(3.000000, 1.000000, D4),\n    Note(4.000000, 1.000000, A3),\n    Note(5.000000, 2.000000, E4),\n    Note(7.000000, 1.000000, D4),\n    Note(8.000000, 1.000000, A3),\n    Note(9.000000, 1.000000, B3),\n    Note(10.000000, 0.500000, C4),\n    Note(10.500000, 2.500000, C4),\n    //////////////////////////////\n    Note(13.000000, 1.000000, A3),\n    Note(14.000000, 2.000000, E4),\n    Note(16.000000, 1.000000, D4),\n    Note(17.000000, 1.000000, A3),\n    Note(18.000000, 2.000000, E4),\n    Note(20.000000, 1.000000, D4),\n    Note(21.000000, 1.000000, G4),\n    Note(22.000000, 1.000000, B4),\n    Note(23.000000, 0.500000, A4),\n    Note(23.500000, 2.500000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_3 8\nNote[N_NOTES_HIKARUGA_LOW_3] score_ikaruga_low_3 = Note[](\n    Note(0.000000, 3.000000, A1),\n    Note(3.000000, 1.000000, D2),\n    Note(4.000000, 4.000000, C2),\n    Note(8.000000, 4.000000, A1),\n    /////////////////////////////\n    Note(13.000000, 3.000000, E2),\n    Note(16.000000, 2.000000, G2),\n    Note(18.000000, 4.000000, A2),\n    Note(22.000000, 4.000000, C3)\n);\n// DURATION 26\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_4 13\nNote[N_NOTES_HIKARUGA_HIGH_4] score_ikaruga_high_4 = Note[](\n    Note(0.000000, 0.500000, A3),\n    Note(0.500000, 0.500000, B3),\n    Note(1.000000, 0.500000, C4),\n    Note(1.500000, 0.500000, E4),\n    Note(2.000000, 1.000000, G4),\n    Note(3.000000, 0.500000, F4),\n    Note(3.500000, 0.500000, E4),\n    Note(4.000000, 1.000000, D4),\n    Note(5.000000, 1.000000, A3),\n    Note(6.000000, 0.500000, D4),\n    Note(6.500000, 0.500000, D4),\n    Note(7.000000, 1.000000, A3),\n    Note(8.000000, 1.000000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_4 7\nNote[N_NOTES_HIKARUGA_LOW_4] score_ikaruga_low_4 = Note[](\n    Note(0.000000, 1.000000, C2),\n    Note(1.000000, 1.000000, E2),\n    Note(2.000000, 1.000000, D2),\n    Note(3.000000, 1.000000, F2),\n    Note(4.000000, 2.000000, G2),\n    Note(6.000000, 2.000000, E2),\n    Note(8.000000, 2.000000, A2)\n);\n// DURATION 10\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_5 8\nNote[N_NOTES_HIKARUGA_HIGH_5] score_ikaruga_high_5 = Note[](\n    Note(0.000000, 1.000000, E4),\n    Note(1.000000, 0.500000, D4),\n    Note(1.500000, 0.500000, C4),\n    Note(2.000000, 1.000000, B3),\n    Note(3.000000, 2.000000, G3),\n    Note(5.000000, 0.500000, B3),\n    Note(5.500000, 1.500000, B3),\n    Note(7.000000, 3.000000, A3)\n);\n\n\n#define N_NOTES_HIKARUGA_LOW_5 4\nNote[N_NOTES_HIKARUGA_LOW_5] score_ikaruga_low_5 = Note[](\n    Note(0.000000, 2.000000, E2),\n    Note(2.000000, 3.000000, D2),\n    Note(5.000000, 2.000000, B2),\n    Note(7.000000, 3.000000, A2)\n);\n// DURATION 10\n\n\n#define N_NOTES_HIKARUGA_HIGH_6 24\nNote[N_NOTES_HIKARUGA_HIGH_6] score_ikaruga_high_6 = Note[](\n    Note(0.000000, 0.500000, A3),\n    Note(0.500000, 0.500000, B3),\n    Note(1.000000, 0.500000, C4),\n    Note(1.500000, 0.500000, E4),\n    Note(2.000000, 1.000000, A4),\n    Note(3.000000, 1.000000, A4),\n    Note(4.000000, 1.000000, G4),\n    Note(5.000000, 1.000000, F4),\n    Note(6.000000, 1.000000, E4),\n    Note(7.000000, 1.000000, A3),\n    Note(8.000000, 0.500000, A3),\n    Note(8.500000, 0.500000, B3),\n    Note(9.000000, 0.500000, C4),\n    Note(9.500000, 0.500000, E4),\n    Note(10.000000, 1.000000, A4),\n    Note(11.000000, 0.500000, B4),\n    Note(11.500000, 0.500000, C5),\n    Note(12.000000, 1.000000, B4),\n    Note(13.000000, 1.000000, A4),\n    Note(14.000000, 0.500000, B4),\n    Note(14.500000, 1.000000, A4),\n    Note(15.500000, 1.000000, G4),\n    Note(16.500000, 0.500000, F4),\n    Note(17.000000, 1.000000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_6 14\nNote[N_NOTES_HIKARUGA_LOW_6] score_ikaruga_low_6 = Note[](\n    Note(0.000000, 1.000000, F2),\n    Note(1.000000, 1.000000, E2),\n    Note(2.000000, 2.000000, F2),\n    Note(4.000000, 2.000000, E2),\n    Note(6.000000, 2.000000, A2),\n    Note(8.000000, 1.000000, F2),\n    Note(9.000000, 1.000000, E2),\n    Note(10.000000, 2.000000, F2),\n    Note(12.000000, 1.000000, E2),\n    Note(13.000000, 1.000000, A2),\n    Note(14.000000, 1.000000, B2),\n    Note(15.000000, 1.000000, A2),\n    Note(16.000000, 1.000000, B2),\n    Note(17.000000, 1.000000, A2)\n);\n// DURATION 18\n\n#define N_NOTES_HIKARUGA_HIGH_7 18\nNote[N_NOTES_HIKARUGA_HIGH_7] score_ikaruga_high_7 = Note[](\n    Note(0.000000, 1.000000, A3),\n    Note(1.000000, 2.000000, B3),\n    Note(3.000000, 1.000000, E3),\n    Note(4.000000, 2.000000, D4),\n    Note(6.000000, 0.500000, C4),\n    Note(6.500000, 0.500000, B3),\n    Note(7.000000, 1.000000, C4),\n    Note(8.000000, 1.000000, B3),\n    Note(9.000000, 1.000000, A3),\n    Note(10.000000, 2.000000, E3),\n    Note(12.000000, 1.000000, E3),\n    Note(13.000000, 1.000000, G3),\n    Note(14.000000, 0.500000, E3),\n    Note(14.500000, 0.500000, G3),\n    Note(15.000000, 0.500000, A3),\n    Note(15.500000, 0.500000, A3),\n    Note(16.000000, 1.000000, E3),\n    Note(17.000000, 1.000000, A3)\n);\n\n\n#define N_NOTES_HIKARUGA_LOW_7 9\nNote[N_NOTES_HIKARUGA_LOW_7] score_ikaruga_low_7 = Note[](\n    Note(0.000000, 2.000000, E2),\n    Note(2.000000, 2.000000, D2),\n    Note(4.000000, 2.000000, A2),\n    Note(6.000000, 2.000000, F2),\n    Note(8.000000, 2.000000, E2),\n    Note(10.000000, 2.000000, C2),\n    Note(12.000000, 2.000000, A1),\n    Note(14.000000, 2.000000, A2),\n    Note(16.000000, 2.000000, E2)\n);\n// Duration 18\n\n// Basically the same exact thing, shall be factorized in some way\n\nvec2 play_track_ikaruga_1(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_1; i++) {\n        if (score_ikaruga_high_1[i].start <= t \n        && (score_ikaruga_high_1[i].start + score_ikaruga_high_1[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_1[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_1; i++) {\n        if (score_ikaruga_low_1[i].start <= t \n        && (score_ikaruga_low_1[i].start + score_ikaruga_low_1[i].len) >= t) {\n            sound += .5 *  play_standard_note(score_ikaruga_low_1[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_2(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    // Loop = 4 times\n    t = mod(t, 4.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_2; i++) {\n        if (score_ikaruga_high_2[i].start <= t \n        && (score_ikaruga_high_2[i].start + score_ikaruga_high_2[i].len) >= t) {\n            sound += .3 * play_standard_note(score_ikaruga_high_2[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_2; i++) {\n        if (score_ikaruga_low_2[i].start <= t \n        && (score_ikaruga_low_2[i].start + score_ikaruga_low_2[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_2[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_3(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_3; i++) {\n        if (score_ikaruga_high_3[i].start <= t \n        && (score_ikaruga_high_3[i].start + score_ikaruga_high_3[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_3[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_3; i++) {\n        if (score_ikaruga_low_3[i].start <= t \n        && (score_ikaruga_low_3[i].start + score_ikaruga_low_3[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_3[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_4(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_4; i++) {\n        if (score_ikaruga_high_4[i].start <= t \n        && (score_ikaruga_high_4[i].start + score_ikaruga_high_4[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_4[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_4; i++) {\n        if (score_ikaruga_low_4[i].start <= t \n        && (score_ikaruga_low_4[i].start + score_ikaruga_low_4[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_4[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_5(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_5; i++) {\n        if (score_ikaruga_high_5[i].start <= t \n        && (score_ikaruga_high_5[i].start + score_ikaruga_high_5[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_5[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_5; i++) {\n        if (score_ikaruga_low_5[i].start <= t \n        && (score_ikaruga_low_5[i].start + score_ikaruga_low_5[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_5[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\n\nvec2 play_track_ikaruga_6(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_6; i++) {\n        if (score_ikaruga_high_6[i].start <= t \n        && (score_ikaruga_high_6[i].start + score_ikaruga_high_6[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_6[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_6; i++) {\n        if (score_ikaruga_low_6[i].start <= t \n        && (score_ikaruga_low_6[i].start + score_ikaruga_low_6[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_6[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_7(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_7; i++) {\n        if (score_ikaruga_high_7[i].start <= t \n        && (score_ikaruga_high_7[i].start + score_ikaruga_high_7[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_7[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_7; i++) {\n        if (score_ikaruga_low_7[i].start <= t \n        && (score_ikaruga_low_7[i].start + score_ikaruga_low_7[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_7[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_ikaruga(float time)\n{\n    vec2 sound = vec2(0);\n    \n    // Adjust tempo\n    float t = TEMPO_IKARUGA * time;\n    \n    float end_1 = 29.;\n    float end_2 = end_1 + 12.;\n    float end_3 = end_2 + 26.;\n    float end_4 = end_3 + 10.;\n    float end_5 = end_4 + 10.;\n    float end_6 = end_5 + 12.; // repeat 2\n    \n    // a new loop\n    float end_7 = end_6 + 18.;\n    float end_8 = end_7 + 18.;\n    \n    float end_9 = end_8 + 26.;\n    float end_10 = end_9 + 10.;\n    \n    if ( t < end_1) {\n        sound += play_track_ikaruga_1(time, t);\n    } else if (t < end_2) {\n        sound += play_track_ikaruga_2(time, t - end_1);\n    } else if (t < end_3) {\n        sound += play_track_ikaruga_3(time, t - end_2);\n    } else if (t < end_4) {\n        sound += play_track_ikaruga_4(time, t - end_3);\n    } else if (t < end_5) {\n        sound += play_track_ikaruga_5(time, t - end_4);\n    } else if (t < end_6) {\n        sound += play_track_ikaruga_2(time, t - end_5);\n    } else if (t < end_7) {\n        sound += play_track_ikaruga_6(time, t - end_6);\n    } else if (t < end_8) {\n        sound += play_track_ikaruga_7(time, t - end_7);\n    } else if (t < end_9) {\n        sound += play_track_ikaruga_3(time, t - end_8);\n    } else if (t < end_10) {\n        sound += play_track_ikaruga_4(time, t - end_9);\n    } else {\n        sound += play_track_ikaruga_5(time, t - end_10);\n    }\n    \n    return sound;\n}\n\n\nvec2 mainSound(int samp, float time)\n{\n    vec2 sound = vec2(0);\n    \n    if (time < END_MSG) {\n    \n    } else if (time < END_TRILOGY) {\n        sound += play_trilogy(time - END_MSG);\n    } else {\n        sound += play_ikaruga(time - END_TRILOGY);\n    }    \n    \n    return .5 * sound;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}