{
    "Shader": {
        "info": {
            "date": "1557693314",
            "description": "sdf, raymarching, geometry, regular deltahedra (and sphere)\npenner easing function\nAnti-aliasing and some SDF functions adapted from\nVaporwave Polyhedra by yx\nhttps://www.shadertoy.com/view/3d2XD1",
            "flags": 0,
            "hasliked": 0,
            "id": "ttsGWN",
            "likes": 3,
            "name": "Regular Deltahedra Family",
            "published": 3,
            "tags": [
                "sdf",
                "geometry",
                "deltahedra"
            ],
            "usePreview": 0,
            "username": "anneka",
            "viewed": 532
        },
        "renderpass": [
            {
                "code": "/*\n\tAnti-aliasing and some SDF functions adapted from\n\tVaporwave Polyhedra by yx\n\thttps://www.shadertoy.com/view/3d2XD1\n*/\n\n#define pi (acos(-1.))\n#define tau 6.28318530717958647692\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define NUM_SHAPES 4.\n\nconst float DURATION = .25;\nconst float REFLECTION_STRENGTH = 1.;\nconst float FRESNEL_STRENGTH = .5; // 0. - 1.\n\nconst float phi = (1.+sqrt(5.))*.5;\n\nvec3 BLUE = vec3(0., 0., 1.);\nvec3 WHITE = vec3(1.);\nvec3 RED = vec3(1., 0. ,0.);\nvec3 BLACK = vec3(0.);\nvec3 GREEN = vec3(0., 1., 0.);\n\nvec3 SKY_COLOR;\nvec3 SHAPE_COLOR;\nvec3 CAGE_COLOR;\n\nint mat;\nint matB;\nvec3[3] colorScheme1;\nvec3[3] colorScheme2;\nvec3[3] colorScheme3;\nvec3[3] colorScheme4;\n\n// Order is always [sky, shape, cage]\nvoid initColorSchemes() {\n    colorScheme1 = vec3[](BLUE, RED, WHITE);\n    colorScheme2 = vec3[](RED, WHITE, BLUE);\n    colorScheme3 = vec3[](GREEN, BLACK, WHITE);\n    colorScheme4 = vec3[](BLACK, WHITE, GREEN);\n}\n\nmat2 matRotation(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nvec3 lerpVecs(vec3 a, vec3 b, float amount) {\n  float x = mix(a.x, b.x, amount);\n  float y = mix(a.y, b.y, amount);\n  float z = mix(a.z, b.z, amount);\n  return vec3(x,y,z);\n}\n\nfloat easeInOutQuad (float time, float start, float end, float duration) {\n    if ((time/=duration/2.) < 1.) return end/2.*time*time + start;\n    return -end/2. * ((--time)*(time-2.) - 1.) + start;\n}\n\nfloat sdTetrahedron(vec3 p, float r) {\n    float x = abs(p.x+p.y)-p.z;\n    float y = abs(p.x-p.y)+p.z;\n    float m = max(x,y);\n    return (m-r)/sqrt(3.);\n}\n\nfloat sdOctahedron(vec3 p, float r) {\n    p = abs(p);\n    float m = p.x+p.y+p.z-r;\n    return m*0.57735027;\n}\n    \nfloat sdIcosahedron(vec3 pos, float r) { \n    vec3 p = pos;\n    p = abs(p/r);\n    \n    const float q = (sqrt(5.)+3.)/2.;\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(sqrt(3.)/3.);\n    \n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2.xyz)-n1.x;\n    return max(max(max(a,b),c)-n1.x,d)*r;\n}\n\nfloat sdDodecahedron(vec3 p, float r) {\n    p = abs(p);\n    p += phi*p.zxy;\n    return (max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.);\n}\n\n\nfloat sdRhombicTriacontahedron(vec3 p, float r)\n{\n    const float l = phi*2.;\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-r;   \n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat outerCage(vec3 p, float size) {\n    return max(\n        min(\n\t\t\tsdDodecahedron(p.zyx,1.03*size),\n\t\t\tsdIcosahedron(p,1.025*size)\n        ),\n\t\t-sdRhombicTriacontahedron(p,1.019*size)\n    );\n}\n\nfloat tetraCage(vec3 p, float size, float weight) {\n    float a = max(\n        -sdTetrahedron(p + vec3(0.,-weight,0.), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float b = max(\n        -sdTetrahedron(p + vec3(0.,weight,0.), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float c = max(\n         -sdTetrahedron(p + vec3(weight,0.,0.), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float d = max(\n         -sdTetrahedron(p + vec3(0.,0.,weight), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float n = max(b, a);\n    float o = max(c, d);\n        \n    return min(\n        max(\n            -sdTetrahedron(p + vec3(-weight, 0., 0.), size),\n            min(n,o)\n        ),\n        n\n    );\n}\n\nfloat octaCage(vec3 p, float size, float weight) {\n    return max(\n        max(\n            sdOctahedron(p, size+weight),\n            -sdTetrahedron(p, size)\n        ),\n        -sdTetrahedron(p*vec3(-1.), size)\n    );\n}\n\nfloat icoCage(vec3 p, float size, float weight) {\n    return max(\n\t\tsdIcosahedron(p,size*(1.+weight)),\n        -sdRhombicTriacontahedron(p,size)\n    );\n}\n\nfloat cage1(vec3 p, vec2 t) {\n    return min(\n        sdTorus(p, t*vec2(1., 2.)),\n        sdTorus(p.yxz, t*vec2(1., 2.))\n    );\n}\n\nfloat cage2(vec3 p, vec2 t) {\n    vec3 tetraP = p;\n    tetraP.xy *= matRotation(pi * 0.);\n    tetraP.xz *= matRotation(pi * -.25);\n\treturn tetraCage(tetraP, t.x, t.y);\n}\n\nfloat displacedCage2(vec3 p, float size, float width, float width2, float noise) {\n    float displacement = (sin(10.*noise*p.x+iTime)*sin(10.*noise*p.y+iTime)*sin(10.*noise*p.z+iTime)*.02);\n    return max(\n        cage2(p, vec2(size, width))+displacement,\n        cage2(p, vec2(size*1.001, width2))\n    );\n}\n\nfloat cage3(vec3 p, float size, float weight) {\n    return octaCage(p, size, weight);\n}\n\nfloat cage4(vec3 p, float size, float weight) {\n    return icoCage(p, size, weight);\n}\n\nvec2 makeShapes(vec3 pos, float multiplier) {\n    vec3 p = pos;\n    \n    vec2 pRot = vec2(iTime*.1,0)+1.0*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n        p.yz = cos(pRot.y)*p.yz + sin(pRot.y)*p.zy*vec2(1,-1);\n        p.xz = cos(pRot.x)*p.xz + sin(pRot.x)*p.zx*vec2(1,-1);\n    \n    float baseSize = .7 * multiplier;\n    float maxCageSize = baseSize * 2.;\n    float baseCageSize = baseSize * 1.01;\n    \n    float finalShape;\n    float finalCage;\n    \n    float sphere = (length(p)-baseSize);\n    float shape1 = sphere;\n    \n    vec3 tetraP = p;\n    tetraP.xy *= matRotation(pi * 0.);\n    tetraP.xz *= matRotation(pi * -.25);\n \tfloat shape2 = sdTetrahedron(tetraP, baseSize);\n    \n    float shape3 = sdOctahedron(p, baseSize*1.5);\n    \n    float shape4 = sdIcosahedron(p, baseSize);\n    \n    float timeBlock = mod(iTime*.5, NUM_SHAPES);\n    \n\n    float CAGE_DURATION = DURATION / 2.;\n    \n    float easedTime;\n    float cageSize;\n    float cageWidth;\n    \n    finalCage = cage1(p, vec2(5., -.1));\n    float noise = texture(iChannel0, (pos.xz*.5)+iTime*.1, 0.).r;\n    float minWidth = .000001*noise;\n \tfloat maxWidth1 = .025*noise;\n    \n    \n    if (timeBlock <= DURATION) {\n        easedTime = easeInOutQuad(timeBlock, 0., 1., DURATION);\n        SKY_COLOR = colorScheme1[0];\n        SHAPE_COLOR = mix(colorScheme4[1], colorScheme1[1], easedTime);\n        CAGE_COLOR =  colorScheme1[2];\n        finalShape = mix(shape1, shape2, easedTime);\n        \n         if (timeBlock >= CAGE_DURATION) {\n            float ease = easeInOutQuad(timeBlock-CAGE_DURATION, 0., 1., CAGE_DURATION);\n            cageSize = mix(\n                maxCageSize,\n                baseCageSize,\n                ease\n            );\n            cageWidth = mix(\n                0.01,\n                1.,\n                ease\n            );\n            finalCage = displacedCage2(p, cageSize, .04, cageWidth, noise);\n        }\n\n        \n    } else if (timeBlock <= 1.) {\n        finalShape = shape2;\n        finalCage = displacedCage2(p, baseCageSize, .04, 1., noise);\n        SKY_COLOR = colorScheme1[0];\n        SHAPE_COLOR = colorScheme1[1];\n        CAGE_COLOR = colorScheme1[2];\n        \n        if (timeBlock >= 1.-CAGE_DURATION) {\n            cageWidth = mix(\n                maxCageSize,\n                0.01,\n                easeInOutQuad(timeBlock-(1.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = displacedCage2(p, baseCageSize, .04, cageWidth, noise);\n        }\n        \n    } else if (timeBlock <= 1.+DURATION) {\n        easedTime = easeInOutQuad(timeBlock - 1., 0., 1., DURATION);\n        finalShape = mix(shape2, shape3, easedTime); \n        SKY_COLOR = colorScheme2[0];\n        SHAPE_COLOR = mix(colorScheme1[1], colorScheme2[1], easedTime);\n        CAGE_COLOR =  colorScheme2[2];\n        \n        if (timeBlock >= 1.+CAGE_DURATION) {\n            float ease = easeInOutQuad(timeBlock-(1.+CAGE_DURATION), 0., 1., CAGE_DURATION);\n            cageSize = mix(\n                maxCageSize*1.5,\n                baseCageSize*1.5,\n                ease\n            );\n            cageWidth = mix(\n                minWidth,\n                .075*noise,\n                ease\n            );\n            finalCage = cage3(p, cageSize, cageWidth);\n        }\n        \n    } else if (timeBlock <= 2.) {\n        finalShape = shape3;\n        finalCage = octaCage(p, baseCageSize*1.5, .075*noise);\n        SKY_COLOR = colorScheme2[0];\n        SHAPE_COLOR = colorScheme2[1];\n        CAGE_COLOR = colorScheme2[2];\n        \n        \n        if (timeBlock >= 2.-CAGE_DURATION) {\n            cageWidth = mix(\n                .075*noise,\n                minWidth,\n                easeInOutQuad(timeBlock-(2.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage3(p, baseCageSize*1.5, cageWidth);\n        }\n    } else if (timeBlock <= 2.+DURATION) {\n        easedTime = easeInOutQuad(timeBlock - 2., 0., 1., DURATION);\n        finalShape = mix(shape3, shape4, easedTime);\n        SKY_COLOR = colorScheme3[0];\n        SHAPE_COLOR = mix(colorScheme2[1], colorScheme3[1], easedTime);\n        CAGE_COLOR =  colorScheme3[2];\n        \n        \n        if (timeBlock >= 2.+CAGE_DURATION) {\n            float ease = easeInOutQuad(timeBlock-(2.+CAGE_DURATION), 0., 1., CAGE_DURATION);\n            cageSize = mix(\n                maxCageSize,\n                baseCageSize,\n                ease\n            );\n            cageWidth = mix(\n                minWidth,\n                .01*noise,\n                ease\n            );\n            finalCage = cage4(p, cageSize, cageWidth);\n        }\n        \n    } else if (timeBlock <= 3.) {\n        finalShape = shape4;\n        finalCage = cage4(p, baseCageSize, .01*noise);\n        SKY_COLOR = colorScheme3[0];\n        SHAPE_COLOR = colorScheme3[1];\n        CAGE_COLOR = colorScheme3[2];\n        \n        if (timeBlock >= 3.-CAGE_DURATION) {\n            cageWidth = mix(\n                .01*noise,\n                minWidth,\n                easeInOutQuad(timeBlock-(3.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage4(p, baseCageSize, cageWidth);\n        }\n        \n    } else if (timeBlock <= 3.+DURATION) { \n        easedTime = easeInOutQuad(timeBlock - 3., 0., 1., DURATION);\n        finalShape = mix(shape4, shape1, easedTime);\n        SKY_COLOR = colorScheme4[0];\n        SHAPE_COLOR = mix(colorScheme3[1], colorScheme4[1], easedTime);\n        CAGE_COLOR =  colorScheme4[2];\n        \n        if (timeBlock >= 3.+CAGE_DURATION) {\n            cageSize = mix(\n                maxCageSize,\n                baseCageSize,\n                easeInOutQuad(timeBlock-(3.+CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            cageWidth = mix(\n                minWidth,\n                maxWidth1,\n                easeInOutQuad(timeBlock-(3.+CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage1(p, vec2(cageSize, cageWidth));\n        }\n        \n    } else if (timeBlock <= 4.) {\n        finalShape = shape1;\n        finalCage = cage1(p, vec2(baseCageSize, maxWidth1));\n        SKY_COLOR = colorScheme4[0];\n        SHAPE_COLOR = colorScheme4[1];\n        CAGE_COLOR = colorScheme4[2];\n        \n        if (timeBlock >= 4.-CAGE_DURATION) {\n            cageWidth = mix(\n                maxWidth1,\n                minWidth,\n                easeInOutQuad(timeBlock-(4.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage1(p, vec2(baseCageSize, cageWidth));\n        }\n\n    }\n    \n    return vec2(finalShape, finalCage);\n}\n\nfloat scene(vec3 p) {      \n    vec3 cP = p;\n    \n    vec2 pRot = vec2(0,iTime*.2);\n    cP.yz = cos(pRot.y)*p.yz + sin(pRot.y)*p.zy*vec2(1,-1);\n    \n    float outerCage = outerCage(cP, 10.);\n    \n    vec2 shapes = makeShapes(p, 1.);\n    float shape = shapes.x;\n    \n    float cage = shapes.y;\n    \n    float scene = min(shape, cage);\n    scene = min(scene, outerCage);\n    scene = min(scene, shape*1.5); // Glossy warp\n    \n    float cageDistance = abs(scene - cage);\n    float outerCageDistance = abs(scene - outerCage);\n                        \n    if (cageDistance <= .001) {\n        mat = 1;\n    } else if (outerCageDistance <= .001) {\n        mat = 2;\n    } else {\n        mat = 0;\n    }\n\n    return scene;\n}\n\n\nvec3 trace(vec3 cam, vec3 dir) {    \n    float hasBounced = 0.;\n    float fresnel = 0.;\n    \n    vec3 accum = vec3(1.);\n    for(int bounce=0;bounce<2;++bounce) {\n        float t;\n        float k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (k < .001 || k > 10.)\n                break;\n        }\n\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n        \n        vec3 weightedReflection = lerpVecs(vec3(1.), accum, REFLECTION_STRENGTH);\n      \n        vec3 shapeSurfaceColor = mix(SKY_COLOR, SHAPE_COLOR*weightedReflection, hasBounced);\n        \n        if (k > 10.) {\n            return SKY_COLOR + shapeSurfaceColor;    \n        } \n        \n        else if (mat == 1) {\n            return CAGE_COLOR;\n        }\n        else if (mat == 2) {\n            return mix(SKY_COLOR, SHAPE_COLOR, hasBounced);\n        }\n        \n        else {\n            fresnel = min(.7,pow(max(0.,1.-dot(-dir,n)),5.))/(1. - FRESNEL_STRENGTH);\n            fresnel=mix(.04,1.,fresnel);\n            cam=h+n*.01;\n            dir=reflect(dir,n);\n            accum *= fresnel;\n            hasBounced = 1.;\n        }\n    }\n\n   \treturn SKY_COLOR;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    out_color=vec4(0);\n    initColorSchemes();\n    \n\t//Anti-aliasing\n    for(int i=0;i<4;++i){\n        vec2 offset=vec2(i/2,i%2)*.5/iResolution.y;\n    \n        vec3 cam = vec3((uv+offset)*3.,-5.);\n        vec3 dir = vec3(0,0,1);\n\t\t\n        out_color.rgb += trace(cam,dir);\n    }\n    out_color *= .25;\n    out_color *= 2.; // exposure\n\tout_color.rgb = pow(out_color.rgb,vec3(.65)); // gamma\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}