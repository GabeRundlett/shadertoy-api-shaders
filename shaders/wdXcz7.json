{
    "Shader": {
        "info": {
            "date": "1584486812",
            "description": "Inspired by https://www.facebook.com/pages/category/Artist/FrenerDesign-1884642275082005/",
            "flags": 1,
            "hasliked": 0,
            "id": "wdXcz7",
            "likes": 10,
            "name": "wavy sphere",
            "published": 3,
            "tags": [
                "reflexion",
                "sphere",
                "fog",
                "reproduction",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "xjorma",
            "viewed": 9843
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define NO_UNROLL_ZERO min(0, iFrame)\n\nconst float period = 10.;\nconst float scale = 5.;\n\nfloat alt(vec3 p)\n{\n    return (sin(p.x / period) + sin(p.z / period)) * scale;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 p)\n{\n    vec3 v = vec3(3,22,3);\n    vec3 i = floor((p + v / 2.) / v );\n    vec3 o = vec3(0, alt(i), 0);\n    vec3 q = mod(p + o + v / 2., v) - v / 2.0;\n    float r = step(abs(i.y), 1.5);\n    return sdSphere(q, r * 1.1);\n}\n\n\n#define EPS  0.001\n\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)\n{\n    t = 0.;\n    d = 0.;\n    vec3 cp = ro;\n    for(int i=0;i<200;++i)\n    {\n        d = map(cp);\n        t += d;\n        cp = ro+rd*t;\n        if (d < .001 || d > maxd || abs(cp.y) > 35.)\n            break;\n    }\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 c1 = mix(vec3(0.), vec3(0,0,1), (sign(rd.y) + 1.) / 2.); \n    vec3 c2 = mix(vec3(1), c1, abs(rd.y));\n    return c2; \n}\n\nvec3 lastRecur(vec3 ro,vec3 rd)\n{\n    return getSkyColor(rd);\n}\n\n#define GEN_RENDER(NAME,DIST,RECUR) \t\t\t\t\t\t\t\t\t\t\\\nvec3 NAME(vec3 ro,vec3 rd)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    float\tt,d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    rayMarch(ro, rd, t, d, DIST);\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = ro + rd * t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 n = calcNormal(p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    if (d < .001)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\t\t\t\t\t\\\n        vec3 d = mix(vec3(1), vec3(0.82, 0.45, 0.20), fresnel);\t\t\t\t\\\n        vec3 ref = reflect(rd, n);\t\t\t\t\t\t\t\t\t\t\t\\\n        color = d * RECUR(p + ref * 0.4 , ref);\t\t\t\t\t\t\t\t\\\n        color = applyFog(color, t / DIST, getSkyColor(rd));\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        color = getSkyColor(rd);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\nGEN_RENDER(render4,  1., lastRecur)\nGEN_RENDER(render3,  1., render4)\nGEN_RENDER(render2,  1., render3)\nGEN_RENDER(render1, 15., render2)\nGEN_RENDER(render , 50., render1)\n    \nmat3 buildLookAtMatrix( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    mat3 ma = buildLookAtMatrix(vec3(0), vec3(0,1,-1));\n    \n\tro.y+=iTime;\n\t\n    fragColor = vec4(render(ma*ro/3.,ma*rd) ,1);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n = NO_UNROLL_ZERO; n < 4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        float theta\t= radians(30.);\n        float phi\t= radians(90.);\n        vec3 ro = 2.7*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3(0, -0.2, 0);\n        mat3 ca = buildLookAtMatrix( ro, ta );\n\t\t\n        vec3 rd =  ca*normalize(vec3(p,2.0));\n        \n        ro.z +=iTime*4.;\n        ro.x += 5.;  \n\n        \n        vec3 col = render(ro ,rd);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.3);\n    \n\tfragColor = vec4( pow(tot, vec3(1.5)), 1.0 );    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}