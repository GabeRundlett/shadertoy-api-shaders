{
    "Shader": {
        "info": {
            "date": "1621757546",
            "description": "q",
            "flags": 0,
            "hasliked": 0,
            "id": "7tf3RM",
            "likes": 2,
            "name": "Spherical Delinquency",
            "published": 3,
            "tags": [
                "q"
            ],
            "usePreview": 0,
            "username": "Fahrenheitrequited",
            "viewed": 279
        },
        "renderpass": [
            {
                "code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(round(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s = 1.;\n  for ( float i = 0.; i <5.; i++ ) {\n  \n    p.xy *= rot((t-i));\n    p.yz *= rot((t+i) * .7);\n    p = abs(p);\n    p -= s;\n    s *= 0.65;\n  }\n  return p;\n}\n\nfloat map(vec3 p) {\n\n /*\n  float r = sph(p, 4.);\n\n  float t1 = time;\n  vec3 q = vec3(0);\n  q += kifs(p + kifs(p)/4.);\n  q += kifs(p + kifs(p)/5.);\n  \n  \n  p = rep(p, vec3(0,15,15) * sin(surge(t1 * .17)));\n  float s = sph(p + vec3(8,0,0) , 2.);\n  \n  \n  float f1= cylcap(q,3.,.1);\n  float f2 = min(f1,s);\n  \n return f2;\n */\n  float t1 = time;\n  float t = tor(p + vec3(0,0,5), vec2(3.,1.));\n  \n  vec3 q = rep(p, vec3(20,20,0) * sin(surge(t1 * .17)));\n  float s = sph(q , 1.);\n  return min(s,t);\n \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = surge(iTime/1.);\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0.0,0.0,-20.);\n  s.xz *= rot(time);\n  s.yz *= rot(time * .83);\n  \n  \n  vec3 t=vec3(0,0,0);\n  s.xy *= rot(surge(time*1.));\n  s.xz *= rot(surge(time*1.) * .61);\n  s *= sin(surge(iTime)) * .5 + 0.9;\n  float t2 = time*0.5;\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  float dither=0.5+0.1*rand;\n  \n  for(float z=0.; z<100.; ++z) {\n    i = z;\n    d=map(p) *.5;\n    if(d<0.01) {\n      vec3 n = norm(p);\n      r = reflect(n,r);\n      d = 2.;\n      //break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n\n  vec3 col=vec3(0);\n  vec3 n = norm(p);\n  vec3 l =normalize(vec3(-0.2,0.2,0.5));\n  float t1=sin(time*0.2);\n  l.xz *= rot(t1);\n  l.xy *= rot(t1*3.2);\n  vec3 h = normalize(l-r);\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  float fog = pow(1.0-float(i)/100.0,2.0);\n  \n  \n  col = 1. - pow(vec3(i/300.),vec3(.8));\n  col *= fog ;\n  fragColor = vec4(col, 1);\n\n  //float aodist=0.7;\n  //float ao = getao(p,n,aodist*0.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n\n  //vec3 back = mix(vec3(0.7,0.2,0.1), vec3(1,0.7,0.2), pow(max(0.0,dot(r,l)),5.0));\n\n  //float diff = fbm(p*15.0);\n  //diff=abs(diff-0.3)*2;\n  //diff=pow(smoothstep(0.1,0.9,diff),5.0)*2.7+0.9;\n  \n  //col += max(0.0,dot(n,l)*0.5+0.5) * fog * ao * (vec3(1,0.7,0.3) + pow(max(0.0,dot(n,h)),20.0));\n  //col += vec3(0.7,0.2,0.1)*0.5*pow(n.y*0.5+0.5,3.0);\n  //col += sss * fog * back * vec3(1,0.2,0.2) * 1.5 * diff;\n  //col += 3.0*f*(-n.y*0.5+0.5)*fog;\n  \n  //float len = length(p-s);\n  //col += back * max(clamp(d,0.0,1.0), clamp(dot(p-s,p-s)/200.0,0.0,1.0));\n\n  //vec3 col2 = vec3(0);\n  //for(int j=1; j<PART_COUNT; ++j) {\n  //  float dist = float(j) * 0.2/r.z;\n  //  if(dist>len) break;\n  //  vec3 vp = vec3(s.x,s.y,0) + r*dist;\n  //  vp.xy *=rot(sin(vp.z*10.0+time*0.2));\n  //  \n  //  col2 += dots(vp, float(j)) * clamp(1.0-dist/float(PART_COUNT), 0.0,1.0);\n  //}\n  //col += col2 * back;\n\n  //col *= pow(clamp(1.2-length(uv),0.0,1.0)*1.3,1.7);\n  //col = vec3(rnd(uv));\n  \n  \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}