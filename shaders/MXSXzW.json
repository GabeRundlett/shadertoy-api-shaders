{
    "Shader": {
        "info": {
            "date": "1710311589",
            "description": "Blackbody luminance demo.\nThe image (on a monitor with specified absolute white point luminance) should have roughly the same luminance, in cd/m^2, as a real blackboby would, in representable range (up until ~1250K for ~300 cd/m^2 white point).",
            "flags": 0,
            "hasliked": 0,
            "id": "MXSXzW",
            "likes": 6,
            "name": "Luminance demo",
            "published": 3,
            "tags": [
                "luminance",
                "blackbody"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Demo of blackbody luminance, based on https://www.shadertoy.com/view/l3jSRh\n// with added colors.\n\n// NOTE: this demo intentionally does not have any tonemapping\n// whatsoever. On a monitor with the corresponding absolute\n// white point luminance, the image should have the same\n// luminance as the physical blackbody would, up until the\n// color clamps (~1250K for ~300 cd/m^2).\n\n// Absolute luminance of RGB(255,255,255) on typical\n// LCD monitor, according to Wikipedia.\n// You can change it to your monitor's, if you know it.\nconst float MonitorLuminance=300.0;\n\n//==============================================================================\n\n// Approximation for blackbody absolute luminance, in cd/m^2.\n// https://www.shadertoy.com/view/l3jSRh\n// Rel. error is <0.04 for T<256K (until underflow ~170K).\n// Rel. error is <5e-4 for T>256K (until overflow ~1e30K).\nfloat blackbody_total_luminance(float T)\n{\n    const float C=683.002; // Maximum luminous efficacy.\n    float x=log(T),y=1024.0/T;\n    if(T<256.0) return C*exp(-16557.0506+x*(+15585.1218+x*(-6918.70463+x*(+1858.90578+x*(-322.341988+x*(+35.6048787+x*(-2.29212750+x*(+0.0656990249))))))));\n    if(T<2048.0) return C*exp(+19.3258549+y*(-25.8361197+y*(+1.63839141+y*(+0.0757707576+y*(-0.315643557+y*(+0.153068314+y*(-0.0302079735+y*(+0.00215002985))))))));\n    if(T<16384.0) return C*exp(+20.5874065+y*(-58.4338879+y*(+392.571579+y*(-2745.02112+y*(+12055.5459+y*(-33443.8921+y*(+56821.4133+y*(-53890.0151+y*(+21825.7718)))))))));\n    return C*T*(+9514.94619+y*(-122873.383+y*(+532203.587+y*(-456.949553+y*(-6073587.31+y*(-1252576.52+y*(+130355899.0+y*(-335341032.0))))))));\n}\n\n// Approximation for blackbody chromaticity.\n// Different from the one on Wikipedia.\n// Max. abs. error <2.5e-4 for T>170.\n// Max. rel. error:\n//     x,y: <2.5e-4 for T>170,\n//     z: <0.25 for 170<T<1024, <0.004 for 1024<T<2500, <8e-4 for T>2500.\nvec2 blackbody_chromaticity(float T)\n{\n    T=clamp(T,1.0,1e9);\n    float t=T/(1632.0+T);\n    float x=(+0.735388173+t*(-4.98326072+t*(+16.3629202+t*(-21.1374688+t*(+10.2859046)))))/(+1.0+t*(-6.72810897+t*(+21.4195077+t*(-24.2040756+t*(+6.16976301+t*(+7.61012828))))));\n    float z=exp((+1.0+t*(-9.60951289+t*(+35.5138144+t*(-45.3483273+t*(+20.8037838)))))/(t*(-0.351159785+t*(+2.96923045+t*(-9.92069253+t*(+11.4933281+t*(-7.86410267)))))));\n    return vec2(x,1.0-x-z);\n}\n\n//==============================================================================\n\nvec3 xyY2XYZ(vec3 v)\n{\n    return (v.z/v.y)*vec3(v.xy,1.0-v.x-v.y);\n}\n\nvec3 blackbody_XYZ(float T)\n{\n    return xyY2XYZ(vec3(blackbody_chromaticity(T),blackbody_total_luminance(T)));\n}\n\n//==============================================================================\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd(vec3 v) {ivec3 c=ivec3(v); return float(hash(uint(c.x+(c.y<<11)+(c.z<<22))))/float(-1u);}\n\nfloat vnoise(vec3 v)\n{\n    vec3 i=vec3(floor(v)),e=vec3(0,1,0);\n    v=smoothstep(0.0,1.0,v-i);\n    return mix(mix(mix(rnd(i+e.xxx),rnd(i+e.yxx),v.x),\n                   mix(rnd(i+e.xyx),rnd(i+e.yyx),v.x),v.y),\n               mix(mix(rnd(i+e.xxy),rnd(i+e.yxy),v.x),\n                   mix(rnd(i+e.xyy),rnd(i+e.yyy),v.x),v.y),v.z);\n}\n\nfloat fbm(int n,float a,float b,vec3 v)\n{\n    float ret=0.0,w=1.0;\n    for(int i=0;i<n;++i)\n    {\n        ret+=w*vnoise(v);\n        w*=a;v*=b;\n    }\n    return ret;\n}\n\n//==============================================================================\n\nvec3 xyz2rgb(vec3 xyz)\n{\n    return mat3( // WARNING: column-major.\n        +3.2404542, -0.9692660, +0.0556434,\n        -1.5371385, +1.8760108, -0.2040259,\n        -0.4985314, +0.0415560, +1.0572252)*xyz;\n}\n\nvec3 rgb2xyz(vec3 rgb)\n{\n    return mat3( // WARNING: column-major.\n        0.4124, 0.2126, 0.0193,\n        0.3576, 0.7152, 0.1192,\n        0.1805, 0.0722, 0.9505)*rgb;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float F=1.5;\n    float T=mix(875.0,1750.0,0.5+0.5*sin(0.25*iTime));\n    vec3 ro=vec3(0.0,2.0,2.5);\n    vec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,-F));\n    vec3 c=vec3(0.0,2.0,0.0);\n    float R=1.0;\n    // NOTE: luminance of 25 cd/m^2 corresponds to\n    // \"typical photographic scene at sunrise or sunset\"\n    // according https://en.wikipedia.org/wiki/Orders_of_magnitude_(illuminance)#Luminance\n    vec3 background=xyY2XYZ(vec3(0.256,0.256,25.0));\n    vec3 col=background;\n    if(rd.y<0.0)\n    {\n        vec3 r=ro+(-ro.y/rd.y)*rd,l=c-r;\n        col=background;\n        col+=0.75*blackbody_XYZ(T)/3.14159265358979*normalize(l).y*R*R/dot(l,l);\n        float g=fbm(8,0.75,2.0,0.5*r);\n        col*=0.75*exp(-0.25*g*g);\n    }\n    float p=dot(ro-c,rd),q=dot(ro-c,ro-c)-R*R,d=p*p-q;\n    if(d>0.0)\n    {\n        vec3 r=ro+(-p-sqrt(d))*rd;\n        r.xz*=mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n        float a=smoothstep(0.0,1.0,0.0625*d/R*iResolution.y);\n        float g=fbm(5,0.625,2.0,11.0*r);\n        T*=exp(-g*g/16.0);\n        col=mix(col,blackbody_XYZ(T),a);\n    }\n    col/=MonitorLuminance;\n    // If you *do* want tonemapping:\n    // col/=1.0+col;   // Component-wise Reinhard.\n    // col/=1.0+col.y; // Luminance-only Reinhard.\n    col=xyz2rgb(col);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}