{
    "Shader": {
        "info": {
            "date": "1696342407",
            "description": "Cool 2d raytraced lighting owo :3",
            "flags": 32,
            "hasliked": 0,
            "id": "DdVcRw",
            "likes": 17,
            "name": "2d raytraced lighting",
            "published": 3,
            "tags": [
                "2d",
                "raytracing",
                "raymarching",
                "lighting",
                "rainbow"
            ],
            "usePreview": 0,
            "username": "vainstains",
            "viewed": 521
        },
        "renderpass": [
            {
                "code": "// [Buffer A] : SDF texture\n// [Buffer B] : Accumulated raytraced image\n// [Image]    : Final image\n\n//   [Buffer A]\n//      |\n//      | +-------+\n//      | |       |\n//      V V       |\n//   [Buffer B]---+\n//       |\n//       V\n//    [Image]\n//\nvec2 pix(int x, int y)\n{\n    return vec2(x,y)/iResolution.xy;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 image = texture(iChannel0, uv);\n    fragColor = image / float(iFrame+1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ================\n// Pre-render SDF\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/(iResolution.y*2.0);\n    vec2 pos = uv*20.0;\n    vec2 dist = getDist(pos);\n    fragColor = vec4(pos, dist.x, dist.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ================\n// World Data\n// ================\n#define TYPE_CIRCLE 0.0\n#define TYPE_RECT 1.0\n#define WORLD_COUNT 7\n#define WORLD_LENGTH WORLD_COUNT*9\n\n// object: { type, pos, (data), color }\n// data: { radius, unused } or { halfWidth, halfHeight }\nconst float[] world = float[]\n(\n    TYPE_CIRCLE,   -4.0, 4.0,   0.25, 0.0,   11.0, 1.0, 1.0,  0.0,\n    TYPE_CIRCLE,   0.0, 4.0,   0.25, 0.0,   1.0, 11.0, 1.0,  0.0,\n    TYPE_CIRCLE,   4.0, 4.0,   0.25, 0.0,   1.0, 1.0, 11.0,  0.0,\n    TYPE_RECT,   0.0, -5.0,   90.0, 2.0,   0.0,0.0,0.0,  1.0,\n    TYPE_CIRCLE,   -4.0, -1.0,   1.5, 0.0,   0.0, 0.0, 0.0,  1.0,\n    TYPE_CIRCLE,   0.0, -1.0,   1.5, 0.0,   0.0, 0.0, 0.0,  1.0,\n    TYPE_CIRCLE,   4.0, -1.0,   1.5, 0.0,   0.0, 0.0, 0.0,  1.0\n);\nvec4 getMat(float index)\n{\n    int i = int(floor(index+0.1));\n    return vec4(world[i+5], world[i+6], world[i+7], world[i+8]);\n}\nvec2 getSceneDist(vec2 p)\n{\n    float d = 99999.0;\n    float index = 0.0;\n    for(int i = 0; i < WORLD_LENGTH; i += 9)\n    {\n        float d1 = d;\n        if (world[i] == TYPE_CIRCLE)\n        {\n            vec2 rpos = vec2(world[i+1], world[i+2]);\n            \n            d1 = length(p - rpos)-world[i+3];\n        }\n        if (world[i] == TYPE_RECT)\n        {\n            vec2 rpos = vec2(world[i+1], world[i+2]);\n            vec2 rel1 = (p-rpos);\n            float mul = 1.0;\n            if (abs(rel1.x) >= world[i+3] || abs(rel1.y) >= world[i+4])\n            {\n                rel1.x = min(abs(rel1.x), world[i+3]) * sign(rel1.x);\n                rel1.y = min(abs(rel1.y), world[i+4]) * sign(rel1.y);\n            }\n            else\n            {\n                mul = -1.0;\n                vec2 dir = vec2(abs(rel1.x), abs(rel1.y));\n                float a = float(world[i+3] > world[i+4]);\n                float diff = max(world[i+3], world[i+4])-min(world[i+3], world[i+4]);\n                dir.x -= diff * a;\n                dir.y -= diff * (1.0-a);\n                if (dir.x > dir.y)\n                {\n                    rel1.x = world[i+3] * sign(rel1.x);\n                }\n                else\n                {\n                    rel1.y = world[i+4] * sign(rel1.y);\n                }\n            }\n            d1 = mul * length(p - (rel1+rpos));\n        }\n        if (d1 < d)\n        {\n            d = d1;\n            index = float(i);\n        }\n    }\n    return vec2(d, index);\n}\nvec2 getDist(vec2 p)\n{\n    vec2 pos = p;\n    return getSceneDist(pos);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ================\n// Raymarch\n// ================\nvec2 posToUv(vec2 pos)\n{\n    return ((pos/10.0)*iResolution.y+iResolution.xy*0.5)/iResolution.xy;\n}\nvec2 uvToPos(vec2 uv)\n{\n    return ((uv*iResolution.xy)-iResolution.xy*0.5)/(iResolution.y*2.0)*20.0;\n}\nvec2 getNormal(vec2 p)\n{\n    return normalize(vec2(\n                texture(iChannel0, posToUv(p+vec2(0.01,0.0))).z-texture(iChannel0, posToUv(p+vec2(-0.01,0.0))).z,\n                texture(iChannel0, posToUv(p+vec2(0.0,0.01))).z-texture(iChannel0, posToUv(p+vec2(0.0,-0.01))).z\n    ));\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy+iTime-iDate.w*0.001,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 randDir(vec2 pos)\n{\n    float r = rand(pos)*3.14159*2.0;\n    return vec2(cos(r),sin(r));\n}\nvec3 march(vec2 pos, vec2 dir)\n{\n    float prePenetration = 1.0;\n    vec2 d = dir;\n    vec2 p = pos;\n    vec3 addative = vec3(0);\n    if (texture(iChannel0, posToUv(pos)).z < 0.0001)\n    {\n        float depth = -texture(iChannel0, posToUv(pos)).z;\n        vec4 mat = getMat(texture(iChannel0, posToUv(pos)).w);\n        p += getNormal(pos) * depth;\n        prePenetration = ((depth*10.0)*(depth*10.0)+5.0)/(length(mat.xyz)+1.0);\n        addative = mat.xyz+vec3(0.03);\n    }\n    float[] dists = float[](0.0,0.0,0.0,0.0);\n    vec3[] hitColors = vec3[](vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0));\n    int hits = 0;\n    for(int i = 0; i < 200; i++)\n    {\n        vec4 sdfSample = texture(iChannel0, posToUv(p));\n        p += normalize(d) * sdfSample.z;\n        dists[hits] += sdfSample.z;\n        \n        if (sdfSample.z < 0.001)\n        {\n            vec4 mat = getMat(sdfSample.w);\n            hitColors[hits] = mat.xyz;\n            vec2 rd = randDir(p);\n            vec2 nrm = getNormal(p);\n            vec2 n = mix(reflect(d, nrm), rd*sign(dot(nrm, rd)), mat.w);\n            d = n;\n            p += d * 0.002 + n * 0.002;\n            sdfSample = texture(iChannel0, posToUv(p));\n            hits++;\n            if (hits == 4)\n            {\n                break;\n            }\n        }\n    }\n    vec3 light = vec3(0);\n    for(int i = hits; i >= 0; i--)\n    {\n        light += hitColors[i] / (pow(dists[i]*0.1+2.0, 2.0)*0.1);\n    }\n    if (texture(iChannel0, posToUv(pos)).z > 0.03)\n        light *= 0.6;\n    if (texture(iChannel0, posToUv(pos)).z < 0.03)\n        light *= 2.0;\n    return light/prePenetration + addative;\n}\nvec3 getSample(vec2 pos)\n{\n   return march(pos, randDir(pos))*0.5+march(pos, randDir(pos+1.0))*0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prev = texture(iChannel1, uv);\n    // Time varying pixel color\n    vec4 sdfSample = texture(iChannel0, uv);\n    vec2 sdfPos = sdfSample.xy;\n    float sdfDst = sdfSample.z;\n    fragColor = prev + vec4(getSample(sdfPos + 0.02 * vec2(rand(uv)*2.0-1.0, rand(uv+1.0)*2.0-1.0)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}