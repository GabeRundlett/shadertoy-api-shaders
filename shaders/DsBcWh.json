{
    "Shader": {
        "info": {
            "date": "1688096441",
            "description": "Fork of https://www.shadertoy.com/view/MdXSWn by evilryu\n& Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n\nPlayed around with the visuals, added handheld camera animation + DoF",
            "flags": 32,
            "hasliked": 0,
            "id": "DsBcWh",
            "likes": 11,
            "name": "Unidentified Floating Object",
            "published": 3,
            "tags": [
                "julia",
                "zoom",
                "dof",
                "mandlebrot",
                "vhs",
                "handheld",
                "shaky"
            ],
            "usePreview": 0,
            "username": "granito",
            "viewed": 341
        },
        "renderpass": [
            {
                "code": "//Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n\n\n#define VHSRES vec2(540.0,320.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  #ifdef UseVHSEffect \n    vec2 uv = fragCoord.xy / iResolution.xy / iResolution.xy * VHSRES;\n    fragColor = texture( iChannel0, uv );\n  #else\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture( iChannel1, uv );\n  #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Options\n    // AA: increase to have AA but not sure its working properly\n        #define AA 0\n    // VHS Effect Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n        #define UseVHSEffect \n\n//-----------\n// Noises\n\n#define HASHSCALE 0.1031\n#define saturate(i) clamp(i,0.,1.)\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence, float rdm) \n{\n    float total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n    for(int i = 0; i < octaves; ++i) \n    {\n        total += perlinNoise1D((pos * frequency) + hash(rdm)) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total / maxValue;\n}\n\nvec3 fbmv3(float pos, int octaves, float persistence, float rdm) \n{\n    return  vec3(   fbm(pos, octaves, persistence, hash(rdm)) , fbm(pos, octaves, persistence, hash(rdm+321.23)) , fbm(pos, octaves, persistence, hash(rdm+797.313))   );\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//-----------\n// Animation\n\n#define starttime 4.\n#define ep 9.\n\nfloat mandelbulbevolution (float t)\n{\n    float ts = max(t - starttime,0.);\n    return pow(saturate(fract(ts/ep) * ep),4.) + floor(ts/ep);\n}\n\nfloat shockwave (float t)\n{\n    float ts = max(t - starttime,0.);\n    float localt = ts-1.02;\n    float amount = 1. - saturate(fract(localt/ep) * ep);\n    float bounce = sin(ts+15.*amount*amount*amount) * smoothstep(0.,1.,amount);\n    return bounce;\n}\n\nfloat mandelbulbrotation (float t)\n{\n    float ts = max(t - starttime,0.);\n    float amount = smoothstep(0.,1.,abs((1. - saturate(fract(ts/ep) * ep)) * 2. - 1.));\n    amount *= sin(abs(amount) * 7.);\n    return amount*0.01;\n}\n\n\n//-----------\n// Camera\n\n\n#define Pi 3.14159265359\n\n#define DoFClamping 1.0\n#define DoFSamples 16\n\n#define Aperture 0.05\n\nfloat ZoomAnim(float time)\n{\n    float fadein = smoothstep(0.,1.,(max(time,0.)*0.5)) * 0.5 + 0.5;\n    \n    return fadein * pow(fbm(time*.1, 5, .45, 71.59)*0.5+0.5,2.);\n}\n\nfloat FocalDistance (float time) \n{\n    return 0.85 + fbm(time*0.3, 3, .3, 66.33) * 0.2;\n}\n\n//-----------\n// Tonemapping\n\nlowp vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of https://www.shadertoy.com/view/MdXSWn Created by evilryu\n// \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z/r) + mandelbulbevolution(iTime)+iTime*0.05;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, mandelbulbrotation(iTime));\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<48; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n    pixel_size = 1.0/(iResolution.x * 4.0);\n    \n    vec3 bg = exp(uv.y-2.0)*vec3(0.4, 0.6, 1.0);\n\n            \n\t// camera\n    float zoomanimfactor = ZoomAnim(iTime);\n    float zoom =  1. + zoomanimfactor * 20.;\n    vec3 camposanim =  ( vec3(.05) * fbmv3(iTime*1., 5, .3, 321.77) + vec3(1.) * fbmv3(iTime*0.1, 3, .2, 95.31) );\n    \n    vec3 camtargetanim = ( vec3(.05) * fbmv3(iTime*1., 5, .3, 321.23) + vec3(6.) * fbmv3(iTime*0.3, 3, .2, 767.9) ) ;\n    \n \tvec3 ta = camtargetanim * zoomanimfactor * 0.1; \n\tvec3 ro = vec3(0., 0.9 , 3. ) + camposanim * 0.1 + shockwave(iTime) * vec3(0.,.02,0.);\n \tvec3 cf = normalize(ta-ro); \n    \n    float depth = 0.;\n    vec3 col;    \n    \n    for (int i=0; i<(AA+1); ++i) { \n    \n        // AA \n        vec2 v = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(v - iTime + float(i))))/float(0xffffffffU);\n        vec2 uvoffset = hash2(seed)-0.5;\n        \n        vec2 localuv = uv + (uvoffset / iResolution.xy * 1.2); \n    \n        vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n        vec3 cu = normalize(cross(cs,cf)); \n        vec3 rd = normalize(localuv.x*cs + localuv.y*cu + zoom*cf);  // transform from view to world\n        col = texture(iChannel0, rd).rgb; \n        vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n        vec3 sun = vec3(1., 0.8, 0.6); \n        vec3 skycolor = vec3(0.5, .7, 1.0); \n\n        float t=0.0;\n        vec3 p=ro; \n\n        vec3 res = intersect(ro, rd);\n        \n         if(res.x > 0.0){\n               p = ro + res.x * rd;\n               vec3 n=nor(p); \n               float shadow = softshadow(p, sundir, 20.0 );\n               float dif = max(0.0, dot(n, sundir)); \n               float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n               vec3 lin = sun * dif * shadow; \n               vec3 ambient = texture(iChannel0, n, 5.).rgb * 0.8;               \n               lin += ambient * 0.5;\n               res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n               vec3 tc0 = 0.5 + vec3(0.2,0.5,0.7) * sin(2.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0) + mandelbulbevolution(iTime+0.2) * 2.);\n               col = lin * ((dot(vec3(.3,.6,.1),tc0) * 0.4 + tc0 * 0.4) + 0.2);\n               col += spe * sun * shadow * 0.25; \n               depth = length(p);\n        } \n\n    }\n    if (depth < 0.) {\n        col /= float(AA);\n    }\n\n    // post\n \tfragColor = vec4(max(col.xyz, vec3(0.)), depth); \n }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//first DoF pass\n\n#define dir normalize(vec2(1.0, 1.0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float ApertureFinal = Aperture*ZoomAnim(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d, de;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        vec2 de = (fragCoord + d*iResolution.y*ApertureFinal)/iResolution.xy;\n        p = texture(iChannel0, de);\n        dr = min(abs(p.a-FocalDistance(iTime))/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*ApertureFinal + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//second DoF pass\n\n#define dir normalize(vec2(1.0, -1.0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float ApertureFinal = Aperture*ZoomAnim(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*ApertureFinal)/iResolution.xy);\n        dr = min(abs(p.a-FocalDistance(iTime))/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*ApertureFinal + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n\n       \n    fragColor = vec4(ACESFilm(col.rgb), 1. );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Fork of https://www.shadertoy.com/view/MdffD7 by FMS_Cat\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define VHSRES vec2(540.0,320.0)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n#define validuv(v) (abs(v.x-0.5)<0.5&&abs(v.y-0.5)<0.5)\n\nfloat v2random( vec2 uv ) {\n  return texture( iChannel1, mod( uv, vec2( 1.0 ) ) ).x;\n}\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\nvec3 rgb2yiq( vec3 rgb ) {\n  return mat3( 0.299, 0.596, 0.211, 0.587, -0.274, -0.523, 0.114, -0.322, 0.312 ) * rgb;\n}\n\nvec3 yiq2rgb( vec3 yiq ) {\n  return mat3( 1.000, 1.000, 1.000, 0.956, -0.272, -1.106, 0.621, -0.647, 1.703 ) * yiq;\n}\n\n#define SAMPLES 10\n\nvec3 vhsTex2D( vec2 uv, float rot ) {\n  if ( validuv( uv ) ) {\n    vec3 yiq = vec3( 0.0 );\n    for ( int i = 0; i < SAMPLES; i ++ ) {\n      yiq += (\n        rgb2yiq( texture( iChannel0, uv - vec2( float( i ), 0.0 ) / VHSRES ).xyz ) *\n        vec2( float( i ), float( SAMPLES - 1 - i ) ).yxx / float( SAMPLES - 1 )\n      ) / float( SAMPLES ) * 2.0;\n    }\n    if ( rot != 0.0 ) { yiq.yz = rotate2D( rot ) * yiq.yz; }\n    return yiq2rgb( yiq );\n  }\n  return vec3( 0.1, 0.1, 0.1 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec3 col = vec3( 0.0, 0.0, 0.0 );\n\n  #ifdef UseVHSEffect \n\n      vec2 uv = fragCoord.xy / VHSRES;\n      float time = iTime;\n\n      float tapeerror = shockwave(time+0.4) * 0.2 + 0.2;\n\n      vec2 uvn = uv;\n\n      // tape wave\n      uvn.x += ( v2random( vec2( uvn.y / 10.0, time / 10.0 ) / 1.0 ) - 0.5 ) / VHSRES.x * 1.0;\n      uvn.x += ( v2random( vec2( uvn.y, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 1.0;\n\n      // tape crease\n      float tcPhase = smoothstep( 0.9, 0.96, sin( uvn.y * 8.0 - ( time + 0.14 * v2random( time * vec2( 0.67, 0.59 ) ) ) * PI * 1.2 ) );\n      float tcNoise = smoothstep( 0.3, 1.0, v2random( vec2( uvn.y * 4.77, time ) ) );\n      float tc = tcPhase * tcNoise;\n      uvn.x = uvn.x - tc / VHSRES.x * 8.0;\n\n      // switching noise\n      float snPhase = smoothstep( 6.0 / VHSRES.y, 0.0, uvn.y );\n      uvn.y += snPhase * 0.3;\n      uvn.x += snPhase * ( ( v2random( vec2( uv.y * 100.0, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 24.0 );\n\n      // fetch\n      col = vhsTex2D( uvn, tcPhase * 0.2 + snPhase * 2.0 );\n      col = max(mix( col, vec3( dot(col, vec3(.3,.6,.1)) ), vec3(-2.) ), vec3(0.));\n      \n      // crease noise\n      float cn = tcNoise * ( 0.3 + 0.7 * tcPhase );\n      if ( 0.29 < cn ) {\n        vec2 uvt = ( uvn + V.yx * v2random( vec2( uvn.y, time ) ) ) * vec2( 0.1, 1.0 );\n        float n0 = v2random( uvt );\n        float n1 = v2random( uvt + V.yx / VHSRES.x );\n        if ( n1 < n0 ) {\n          col = mix( col, 2.0 * V.yyy, pow( n0, 10.0 ) );\n        }\n      }\n\n      // ac beat\n      col *= 1.0 + 0.1 * smoothstep( 0.4, 0.6, v2random( vec2( 0.0, 0.1 * ( uv.y + time * 0.2 ) ) / 10.0 ) );\n\n      // color noise\n      col *= 0.9 + 0.1 * texture( iChannel1, mod( uvn * vec2( 1.0, 1.0 ) + time * vec2( 5.97, 4.45 ), vec2( 1.0 ) ) ).xyz;\n      col = saturate( col );\n\n      // yiq\n      col = rgb2yiq( col );\n      col = vec3( 0.1, -0.1, 0.0 ) + vec3( 0.9, 1.1, 1.5 ) * col;\n      col = yiq2rgb( col );\n\n  #endif\n  \n  fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}