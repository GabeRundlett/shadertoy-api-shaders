{
    "Shader": {
        "info": {
            "date": "1562067123",
            "description": "is this what angels puke after grooming?\n\n(...enable SUBDIV2 if not on windows)\nalso check out [url=https://www.shaderoo.org/?shader=8ZWXLS]geometry[/url] version.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtfXzH",
            "likes": 24,
            "name": "angel hairball",
            "published": 3,
            "tags": [
                "sphere",
                "hair",
                "truchet",
                "pattern",
                "blonde"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 1488
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// angel hairball\n\n// sphere version of https://www.shadertoy.com/view/WlS3WV (originally insprired by some truchet doodles of Shane and BigWings)\n\n// maybe there's better ways to find the closest icosahedron triangle (getIcosaTri) ...anyone?\n\n#define DOF\n//#define SHOW_GRID\n//#define SHOW_FLOW\n#define SUBDIV1\n//#define SUBDIV2\n\n//again windows spoils the fun out of it... enable the SUBDIV2 define if on linux.\n//windows takes nearly minute to compile and sometimes even fails if SUBDIV2 is enabled\n//...this may however vary from system to system.\n\n\n// golden ratio - used for icosahedron\n#define G (.5+sqrt(5./4.))\n#define PI 3.141592653\n#define PI2 6.28318531\n\n#define XCHGV3(a,b) { vec3 d=a; a=b; b=d; }\n\n#define Res0 vec2(textureSize(iChannel0,0))\n\nconst mat2 IRot=mat2(0.809016994374947, 0.587785252292473, -0.587785252292473, 0.809016994374947);\n\n// get closest icosahedron triangle by geometric categorizion\n// using icosa symmetry, so dont have to check for every icosa point\nvoid getIcosaTri(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    float ph = atan(pos.y,pos.x);  ph=(ph<0.)?PI2+ph:ph;\n    \n    float dang=PI2/5.;\n    float seg=ph/dang;\n    float fseg=floor(seg);\n    \n    // 3 topmost points of segment + lower point of seg (p4t)\n    vec3 p1t=vec3(0,0,1.);\n    vec3 p2t=vec3(cos(fseg*dang-vec2(0,PI2/4.))*.894427190999916,.447213595499958);\n    vec3 p4t=vec3(IRot*p2t.xy,-p2t.z);\n    vec3 p3t=vec3(IRot*p4t.xy, p2t.z);\n\n    if (dot(pos,cross(p2t,p4t))<0. || dot(pos,cross(p4t,p3t))<0.) {\n        // xchg p2 and p3 (because bottom is mirrored in z)\n        p1t=vec3(0,0,-1.);\n        p3t=vec3((seg-fseg<.5)?p2t.xy*IRot:IRot*p2t.xy,-p2t.z);\n        p4t=vec3(IRot*p3t.xy,-p3t.z);\n        p2t=vec3(IRot*p4t.xy, p3t.z);\n    }\n\n    // mix top or below\n    bool top=(dot(pos,cross(p2t,p3t))>0.);\n   \tp1=p4t; p2=p3t; p3=p2t;\n    if(top){ p1=p1t; p2=p2t; p3=p3t; }\n}\n\nvoid getTriSubDiv(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    mat3 m = mat3((p2-p1)*.5,(p3-p1)*.5,p1);\n    vec3 q = inverse(m)*pos;\n    q/=q.z;\n    vec3 qf=floor(q);\n    float f=step(1.,q.x-qf.x+q.y-qf.y);\n    p1 = m*vec3( qf.xy+f,            1 );\n    p2 = m*vec3( qf.xy+vec2(1.-f,f), 1 );\n    p3 = m*vec3( qf.xy+vec2(f,1.-f), 1 );\n    p1=normalize(p1);\n    p2=normalize(p2);\n    p3=normalize(p3);\n}\n\nfloat tri01(float x)\n{\n    return abs(fract(x)-.5)*2.;\n}\n\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=textureLod(iChannel0,pos.xy,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.xz,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.zy,0.)*2.-1.;\n    return r;\n}\n\nvec4 getRand01Sph_old(vec3 pos)\n{\n    pos = normalize(pos);\n    vec2 res = vec2(textureSize(iChannel0,0));\n    vec2 texc=((pos.xy*123.+pos.z)*res+.5)/res;\n    return textureLod(iChannel0,texc+.1,0.); // add some number (.1) to tex coord here so some special 0-angles wont jump between texels\n}\n\n// trying some cubemapped noise due to some discontinuities on some systems...\nvec4 getRand01Sph(vec3 pos)\n{\n    vec3 apos=abs(pos);\n    if (apos.y>apos.z && apos.y>apos.x) pos=pos.zxy;\n    if (apos.x>apos.z && apos.x>apos.y) pos=pos.yzx;\n    vec2 texc = pos.xy/pos.z*.5+.5;\n    vec2 res = vec2(textureSize(iChannel0,0));\n    return texelFetch(iChannel0,ivec2((texc+1./512.)*64.),0);\n}\n\nfloat distSphere(vec3 pos, float r)\n{\n\treturn length(pos)-r;\n}\n\nfloat calcAngle(vec3 v1, vec3 v2)\n{\n    return acos(dot(v1,v2)/length(v1)/length(v2));\n}\n\n#define mixSq(a,b,f) mix(a,b,cos(f*PI)*.5+.5)\n\nfloat distCircleN(vec3 p, vec3 n, float r)\n{\n    return length(p-normalize(p-n*dot(n,p)/dot(n,n))*r);\n}\n\nfloat distCircleNn(vec3 p, vec3 n, float r)\n{\n    return length(p-normalize(p-n*dot(n,p))*r);\n}\n\nfloat distCircleNnAng(vec3 p, vec3 n, float r, inout float ang)\n{\n    vec3 pr=p-normalize(p-n*dot(n,p))*r;\n    float lpr=length(pr);\n    ang=acos(dot(pr,n)/lpr);\n    return lpr;\n}\n\nvec2 g_uv;\n\nfloat distTanCurveTor(vec3 pos, vec3 p1, vec3 p2, vec3 t1, vec3 t2, vec3 p0, float parity, float sc,inout vec2 uv)\n{\n    vec3 bx=p1-p0;\n    vec3 bz=normalize(p0);\n    vec3 by=normalize(cross(bz,bx));\n    bx = cross(by,bz);\n \n    vec3 c = p0+bz*(dot((p1+p2)*.5-p0,bz));\n    \n    vec3 d20  = p2-c;\n    float ddz = dot(d20,bz);\n    d20 -= bz*ddz;\n    d20 = normalize(d20);\n    /*vec3 d10  = p1-c;\n    float ddz2 = dot(d10,bz);\n    d10 -= bz*ddz2;\n    d10 = normalize(d10);*/\n    vec3 dpos = normalize(pos-dot(pos,bz)*bz);\n    \n    float ang   = abs(atan((dot(cross(bx,dpos),bz)),dot(bx,dpos)));\n    float ang12 = abs(atan((dot(cross(bx,d20), bz)),dot(bx,d20)));\n    \n    float fact = ang/ang12;\n    \n    float r1 = length(p1-c+bz*ddz);\n    float r2 = length(p2-c-bz*ddz);\n    float r  = mix(r1,r2,fact);\n    \n    float ampl = mix(dot(t1,p1),dot(t2,p2),fact);\n\n    float af=floor(ang12/PI2*6.+.5)*PI2/6./ang12;  // scale to next multifold of 60 degree\n    \n    vec3 npos=normalize(pos);\n    \n    float d=10000.;\n    #if 1\n\n    //vec3 pr=(pos-p0)*mat3(bx,by,bz);\n    //return distCircle(pr+vec3(0,0,1)*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.)),r);\n    //d = distCircleN(pos-p0+bz*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.)),p0,r);\n    \n    //vec3 z=normalize(pos);\n    pos+=bz*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.));\n    float zang=ang*sign(ampl)*af*6.*max(1.,floor((r1+r2)/sc*2.5))-iTime*3.;\n    float zang0=zang;\n    for(int i=min(iFrame,0);i<3;i++)\n    {\n        vec2 cs=.025*sc*vec2(.5,1)*cos(zang*vec2(2,1)+vec2(0,-PI2*.1666))*vec2(1,parity);\n        //vec3 dpos=cs.x*normalize(pos)+cs.y*normalize(p0-pos-dot(p0-pos,pos)*pos/dot(pos,pos));\n        vec3 dpos=cs.x*npos+cs.y*normalize(p0-dot(p0,npos)*npos);\n        float dold=d;\n        float aang;\n        d = min(d,distCircleNnAng(pos-c+dpos,bz,r,aang));\n        //if(d<dold) d+=.00035*(texture(iChannel0,vec2(.5,.08*rang)).x-.5);\n        if(d<dold) uv=fract(vec2(zang0,aang*2.)/PI2);\n        zang+=PI2*.66666;\n    }\n    \n    #else \n    \n    vec3 pr=(pos-c);\n    //pi=bz*(.55*r*r*ampl*sin(fact*PI2)+ddz*(1.-fact*2.));\n    vec3 p = vec3(cos(-ang-vec2(0,PI2/4.))*r,0);\n    p-=vec3(0,0,1)*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.));\n    p=mat3(bx,by,bz)*p;\n    float zang=ang*sign(ampl)*af*6.*max(1.,floor((r1+r2)/sc*2.5))-iTime*3.;\n    for(int i=0;i<3;i++)\n    {\n        vec2 cs=.025*sc*vec2(.5,1)*cos(zang*vec2(2,1)+vec2(0,-PI2*.1666))*vec2(1,parity);\n        vec3 dpos=cs.x*npos+cs.y*normalize(p0-dot(p0,npos)*npos);\n        d=min(d,length(p+dpos-pr));\n        zang+=PI2*.66666;\n    }\n    \n    //d=length(pr-p);\n    \n    #endif\n\n    //d+=cs.y;\n    \n    #ifdef SHOW_FLOW\n    if(ang<0.0) ang+=PI2;\n    float af=floor(ang12/PI2*6.+.5)*PI2/6./ang12;  // scale to next multifold of 60 degree\n    d+=.007*sin(ang*sign(ampl)*af*6.*floor((r1+r2)*8.)+iTime*3.);\n    #endif\n    \n    return d;    \n}\n\nfloat ndist(vec3 p, vec3 p1, vec3 p2)\n{\n    p-=p1;\n    p2-=p1;\n    return length(p-p2*dot(p,p2)/dot(p2,p2));\n}\n\n// distance to 3 curves in triangle\nfloat distTruchet(vec3 pos, vec3 p1, vec3 p2, vec3 p3, float r, inout vec2 uv_)\n{\n    float d = 10000.0;\n    float rnd =getRand01Sph(p1+p2+p3).x;\n    float rnd2=getRand01Sph(p1+p2+p3).y;\n    // random rotation of torus-start-edges\n    //if  (rnd>.33) { vec3 d=p1; p1=p2; p2=p3; p3=d; }\n    //if  (rnd>.66) { vec3 d=p1; p1=p2; p2=p3; p3=d; }\n    vec3 p1i=p1,p2i=p2,p3i=p3;\n    float s1=step(.333,rnd);\n    float s2=step(.666,rnd);\n    p1=mix(p1i,p2i,s1);\n    p2=mix(p2i,p3i,s1);\n    p3=mix(p3i,p1i,s1);\n    p1=mix(p1,p3i,s2);\n    p2=mix(p2,p1i,s2);\n    p3=mix(p3,p2i,s2);\n\n    //if(dot(cross(p2-p1,p3-p1),p1)>0.0) { vec3 dummy; dummy=p2; p2=p3; p3=dummy; }\n    \n    vec3 pos1, pos2, tan1, tan2;\n    float R0 = .25;\n    \n    float sc=exp2(floor(log2(length(p2-p1)/.7)+.5))*.6;\n    //sc=.5;\n    \n    vec2 uv;\n    float dold;\n    vec3 c;\n    c=p1;\n    pos1=normalize(mix(p1,p2,R0)); pos2=normalize(mix(p1,p3,R0));\n    tan1=-normalize(cross(pos1,p2-p1)+pos1*.25); tan2=-normalize(cross(pos2,p3-p1)+pos2*.25); \n    dold=d;\n\td=min(d,distTanCurveTor(pos,pos1,pos2,tan1,tan2,c,-1.,sc,uv));\n\tif(d<dold) uv_=uv;\n    \n    c=p1;\n    pos1=normalize(mix(p1,p2,1.-R0)); pos2=normalize(mix(p1,p3,1.-R0)); \n    tan1=-normalize(cross(pos1,p2-p1)-pos1*.25); tan2=-normalize(cross(pos2,p3-p1)-pos2*.25); \n    dold=d;\n\td=min(d,distTanCurveTor(pos,pos1,pos2,tan1,tan2,c,1.,sc,uv));\n\tif(d<dold) uv_=uv;\n    \n    c=.5*(p2+p3);\n    pos1=normalize(mix(p3,p2,R0)); pos2=normalize(mix(p2,p3,R0)); \n    tan1=normalize(cross(pos1,p3-p2)+pos1*.25); tan2=normalize(cross(pos2,p2-p3)+pos2*.25); \n    dold=d;\n\td=min(d,distTanCurveTor(pos,pos1,pos2,tan1,tan2,c,1.,sc,uv));\n\tif(d<dold) uv_=uv;\n\t\n    // trying to avoid overshooting on triangle boundaries\n    // by placing helper dist fields there with negative radius\n    float r0=r*1.03+.003;\n    #ifdef SHOW_GRID\n    r0*=.6;\n    #endif\n\td=min(d,distCircleN(pos,cross(p1,p2),1.)+r0);\n\td=min(d,distCircleN(pos,cross(p2,p3),1.)+r0);\n\td=min(d,distCircleN(pos,cross(p3,p1),1.)+r0);\n    \n    return d;\n}\n\n// final distance funtion\nfloat dist(vec3 pos)\n{\n    //pos+=.00015*getRand(pos*1.3).xyz*4.;\n    //pos+=.00006*getRand(pos*3.).xyz*4.;\n    //pos+=.00040*getRand(pos*.5).xyz*4.;\n    vec3 p1,p2,p3;\n    float d = 10000.;\n    vec2 uv;\n    \n    // sphere in the middle\n\t//d=min(d,distSphere(pos,.79));\n    \n    // start with an icosahedron subdivided once\n    getIcosaTri(pos, p1, p2, p3);\n    #ifdef SUBDIV1\n    getTriSubDiv(pos, p1, p2, p3);\n    #endif\n    float dold=d;\n    d=min(d,distTruchet(pos, p1,p2,p3,.008, uv)-.008);\n    if(d<dold) g_uv=uv;\n    \n    #ifdef SUBDIV2\n    float sc = 1.;\n    // subdivide again for another detail\n    getTriSubDiv(pos,p1,p2,p3);\n\tsc = 1./.93;\n\tdold=d;\n    d=min(d,distTruchet(pos*sc, p1,p2,p3,.003*sc, uv)/sc-.003);\n    if(d<dold) g_uv=uv;\n    #endif\n    \n    // subdivide again for another detail\n\t//getTriSubDiv(pos,p1,p2,p3);\n    //sc = 1./.93;\n    //d=min(d,distTruchet(pos*sc, p1,p2,p3,.02)/sc-.007);\n    \n    return d;\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.07) \n    \treturn vec4(0,0,0,1);\n    \n    float eps=0.003;\n    float bg=1.0;\n    float d=10000., dp;\n    for(int cnt=0;cnt<50;cnt++)\n    {\n        dp=d;\n        d = dist(pos);\n        pos+=d*.8*dir;\n        if(d<eps) break;\n    }\n    bg = (d<dp)?0.0:1.0;\n    vec3 n = getGrad(pos,eps*.1);\n    return vec4(n,bg); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nvec4 getMRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel0,coord+.003*iTime);\n    c+=texture(iChannel0,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel0,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel0,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    #ifndef SHADEROO\n    return texture(iChannel1,dir.xzy);\n    #else\n    dir=normalize(dir);\n    float azim = atan(dir.y,dir.x);\n    float thr  = .5*.5*(.7*sin(2.*azim*5.)+.3*sin(2.*azim*7.));\n    float thr2 = .5*.125*(.7*sin(2.*azim*13.)+.3*sin(2.*azim*27.));\n    float thr3 = .5*.05*(.7*sin(2.*azim*32.)+.3*sin(2.*azim*47.));\n    float br  = smoothstep(thr-.2, thr+.2, dir.z+.25);\n    float br2 = smoothstep(thr2-.2,thr2+.2,dir.z+.15);\n    float br3 = smoothstep(thr3-.2,thr3+.2,dir.z);\n    vec4 r1 = .5*(texture(iChannel0,dir.xy*.01)-texture(iChannel0,dir.xy*.017+.33));\n    vec3 skyCol=vec3(.9,1,1.1)+.5*(r1.xxx*.5+r1.xyz*.5);\n    //skyCol*=2.5;\n    vec4 r2 = .5*(texture(iChannel0,dir.xy*.1)-texture(iChannel0,dir.xy*.07-.33));\n    vec3 floorCol = vec3(.9,1.1,1.)*.8+.5*(r2.xxx*.7+r2.xyz*.3);\n    vec3 col=mix(floorCol.zyx,skyCol,br3);\n    col=mix(floorCol.yzx*.7,col,br2);\n    col=mix(floorCol.xyz*.7*.7,col,br);\n    vec3 r=texture(iChannel0,vec2(azim/PI2*.125,.5)).xyz;\n    col*= 1.-clamp(((r.xxx*.7+r.xzz*.3)*2.-1.)*clamp(1.-abs(dir.z*1.6),0.,1.),0.,1.);\n    return vec4(pow(col,vec3(1.6))*.8*vec3(1.1,1,.9)/**clamp(1.+dir.x*.3,.9,1.2)*/,1);\n    #endif\n}\n\nfloat zoomFunc(float t)\n{\n    float x=3.*clamp(3.*-cos(t*.3),-1.,1.);\n    return 2./(1.+exp(-x))+exp(-x*x)*3.*x-1.;\n    //atan()\n    //if (t<dt1) return ;\n    //return t*10.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-3.5,0);\n    #ifdef SHADEROO\n    pos.y*=1.-iMouseData.z/5000.;\n    #endif\n    if(iMouse.x<1.) pos.y*=(1.-.5*(.5+.5*sin(iTime*.1)));\n    // pixel view direction\n    vec3 dir = normalize(2.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    #ifdef DOF\n    vec2 poff=(texture(iChannel0,(fragCoord+vec2(iFrame*13,iFrame*7))/Res0).xy-.5)*.02;\n    pos.xz+=poff;\n    dir.xz-=poff*dir.y/(-pos.y-zoomFunc(iTime));\n    #endif\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=iTime*.3; th=.27*.3*iTime; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    vec3 pos0 = pos;\n    \n    g_uv=vec2(0);\n    \n    // march it...\n   \tvec4 n=march(pos,dir);\n    float bg=n.w;\n    vec2 uv=g_uv;\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    ao=clamp(ao,0.,1.);\n    // adjust contrast of ao\n    ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = (pos-pos0)-2.0*dot((pos-pos0),n.xyz)*n.xyz;\n    R = ((R*rz)*rx);\n    \n    vec3 c = vec3(.6,.5,.3);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*vec3(1,.4,.7)*.05;\n        ;\n    //  reflection of cubemap (slightly tilt reflection map to floor - rotX(-.8))\n    c += myenv(pos,rotX(-.8)*R,1.).xxx*.8;\n    \n    // apply ambient occlusion\n    c*=.6*ao+.4;\n    //c=vec3(.6*ao+.4);\n    \n    c.xyz*=.5+.5*texture(iChannel0,uv*vec2(1.-uv.x,1)*vec2(.1,.4)).xxx+.5*texture(iChannel0,uv*vec2(1.-uv.x,1)*vec2(.1,.2)).xxx;\n    \n    vec3 bgCol = mix(vec3(1.05,1.05,.95),vec3(.9,.95,1.),1.-length(sc));\n    bgCol=vec3(1);\n    //bgCol=myenv(vec3(0),dir,1.).xyz;\n    \n    // apply background\n    float aspect=iResolution.y/iResolution.x;\n    phi=atan(sc.y*aspect,sc.x);\n    float r = length(vec2(sc.y*aspect,sc.x));\n    c=mix(c,bgCol,bg);\n    \n    // add some depth fog\n\tc=mix(c,bgCol,clamp(dot(dir,pos)*.4,0.,1.));\n\t\n    // vignetting\n    vec2 sc2=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.1-1.*dot(sc2,sc2);\n    //vign-=dot(exp(-sin(fragCoord/iResolution.xy*3.14)*vec2(20,10)),vec2(1,1));\n    vign*=1.-.2*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n    vign*=1.-.2*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n\n\tfragColor = vec4(c*vign,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}