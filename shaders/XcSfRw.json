{
    "Shader": {
        "info": {
            "date": "1724759593",
            "description": "Simple test of piecewise C1 cubic interpolation of random points with random slopes",
            "flags": 0,
            "hasliked": 0,
            "id": "XcSfRw",
            "likes": 9,
            "name": "Random cubic hermite spline",
            "published": 3,
            "tags": [
                "spline",
                "quadratic",
                "periodic"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 96
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/Dd33zs for C2 cubic spline variant\nSee https://www.shadertoy.com/view/dd3Gzl for cubic cardinal spline variant\nSee https://www.shadertoy.com/view/cstGRs for akima spline variant\n*/\n\nconst vec3 dot_col = vec3(0);\nconst vec3 curve_col = vec3(0,1,0);\nconst vec3 bg_col = vec3(1);\n\nconst float dot_size = .01;\nconst float line_width = .003;\n\nconst float zoom = 2.;\n\nconst int num_splines = 16;\n\nfloat hash1(float v)\n{\n\tuint n = 1103515245u;\n\tuvec2 x = floatBitsToUint(vec2(v));\n\treturn 2.*(float(n * (((x = n * ((x >> 1) ^ x.yx)).y >> 3) ^ x.x)) / float(-1u))-1.;\n}\n\n// compute parameters of cubic polynomial with end points (0,a) (1,b) and slopes ma at 0, mb at 1\nvec4 compute_params(float a, float b, float ma, float mb){\n\treturn vec4(2.*a+ma-2.*b+mb,3.*b-mb-3.*a-2.*ma,ma,a);\n}\n\n// approximate distance to cubic curve between a and b\nfloat cubic_distance_approx(vec2 uv, float a, float b, vec4 params){\n    float t = (uv.x-a) / (b-a);\n\tfloat val = t * (t * (t * params.x + params.y) + params.z) + params.w;\n\tfloat diff = t * (t * 3. * params.x + 2. * params.y) + params.z;\n    diff /= b-a;\n\n\tif(uv.x > a && uv.x < b){\n\t\treturn abs(uv.y-val) / length(vec2(diff,1));\n\t}\n\telse{\n\t\treturn 1e38;\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2. / iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\n\tvec3 color = bg_col;\n\n\tfloat curve_dis = 1e38;\n\tfloat point_dis = 1e38;\n    \n    vec2 point, next_point;\n\n    // render splines and dots\n\tfor(int i=0;i<num_splines;i++){\n        float slope = hash1(float(33*i));\n        float next_slope = hash1(float(33*(i+1)));\n        point = vec2(2.*float(i)/float(num_splines)-1.,.3*hash1(float(i)));\n        next_point = vec2(2.*float(i+1)/float(num_splines)-1.,.3*hash1(float(i+1)));\n\n\t\tpoint_dis = min(point_dis, distance(uv,point)-dot_size);\n\n\t\tvec4 params = compute_params(point.y, next_point.y, slope, next_slope);\n\t\tcurve_dis = min(curve_dis, cubic_distance_approx(uv, point.x, next_point.x, params)-line_width);\n\t}\n    point_dis = min(point_dis, distance(uv,next_point)-dot_size);\n\n\tcolor = mix(curve_col, color, smoothstep(-border/2.,border/2.,curve_dis));\n\tcolor = mix(dot_col, color, smoothstep(-border/2.,border/2.,point_dis));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}