{
    "Shader": {
        "info": {
            "date": "1707417104",
            "description": "Green matter in space",
            "flags": 0,
            "hasliked": 0,
            "id": "lXl3D8",
            "likes": 7,
            "name": "Green Matter ",
            "published": 3,
            "tags": [
                "greenmatter"
            ],
            "usePreview": 0,
            "username": "EthanZappa",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "/*originals samewhere on https://glslsandbox.com */\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n vec2 surfacePosition;\n\n// #define time abs(sin(time*1e-7*abs(sin((mouse.x*2.0-1.0)+time*.021)))*time+121.0*sin(time*0.02))*0.1\n#define time ((time*0.1)+5.0)\n\n#define iterations 9\n#define formuparam2 0.679\n \n#define volsteps 8\n#define stepsize 0.190\n \n#define zoom 0.900\n#define tile   0.850\n#define speed2  0.10\n \n#define brightness 0.006\n#define darkmatter 0.14000\n#define distfading 0.60\n#define saturation 0.800\n\n\n#define transverseSpeed zoom*2.0\n#define cloud (0.11*sin(time))\n\n \nfloat triangle(float x, float a)\n{\n \n \nfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 1.5) ) ) - 1.0;\nreturn output2;\n}\n \n\nfloat field(in vec3 p) {\n\nfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\nfloat accum = 0.;\nfloat prev = 0.;\nfloat tw = 0.;\n\n\nfor (int i = 0; i < 6; ++i) {\nfloat mag = 1.-dot(p, p);\np = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.7 + 2.0), -1.1+0.3*cos(time*0.3));\n       \nfloat w = exp(-float(i) / 7.);\naccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\ntw += w;\nprev = mag;\n//if ( fract(time*100.0*sin(time*0.1)) > 0.499 ) break;\n}\nreturn max(0., 5. * accum / tw - .7);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 mouse =(iMouse.xy - .3*iResolution.xy)/iResolution.y;\n   vec2 resolution = iResolution.xy-0.5;\n   float time2 = iTime;\n      vec2 uv2 = fragCoord/iResolution.xy-0.5;\nvec2 uvs = uv2;// * resolution.xy / max(resolution.x, resolution.y);\nuvs *= 10.0/1.1*cos(time*1.5);\nuvs.x+=cos(iTime);\nuvs.y+= sin(iTime);\n\nuvs.x+=uvs.x-mouse.x*10.;\nuvs.y+= uvs.y-mouse.y*10.;\n               \n        float speed = speed2;\n        speed = 0.005 * cos(time2*0.02 + 3.1415926/4.0);\n         \n//speed = 0.0;\n\n\n    float formuparam = formuparam2;\n\n\n   \n//get coords and direction\n\nvec2 uv = uvs;\n\nfor ( float j = 0.0; j < 1.0; j += 1.0 ) {\nuv /= (j-dot(uv,uv))*sin(time*0.1+0.5*sin((time+j)*0.05));\nuv *= 1.0-length(uv)*0.3*tan(j+1.0);\nif ( sin(time*0.001)*(j+1.0) < 0.5 ) break;\n}\n\nuv *= 1.0 - dot( gl_FragCoord.xy / resolution.xy - mouse, gl_FragCoord.xy / resolution.xy - mouse )*0.3;\nuv /= 1.0 - length(uv);\n\n//mouse rotation\nfloat a_xz = 0.9;\nfloat a_yz = -.6;\nfloat a_xy = 0.9 + time*0.1;\n\n\nmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\n\nmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\n\nmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\n\nfloat v2 =1.0;\n\nvec3 dir=vec3(uv*zoom,1.);\n \nvec3 from=vec3(0.5, 0.5,0.5);\n\n                               \n        from.x -= 5.0*(mouse.x-0.5);\n        from.y -= 5.0*(mouse.y-0.5);\n               \n               \nvec3 forward = vec3(0.,0.,1.);\n               \n\nfrom.x += transverseSpeed*(1.0)*tan(0.01*time) + 0.001*time;\nfrom.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;\n\nfrom.z += 0.003*time;\n\n\ndir.xy*=rot_xy;\nforward.xy *= rot_xy;\n\ndir.xz*=rot_xz;\nforward.xz *= rot_xz;\n\n\ndir.yz*= rot_yz;\nforward.yz *= rot_yz;\n\n\n\nfrom.xy*=-rot_xy;\nfrom.xz*=rot_xz;\nfrom.yz*= rot_yz;\n\n\n//zoom\nfloat zooom = (time2-3311.)*speed;\nfrom += forward* zooom;\nfloat sampleShift = mod( zooom, stepsize );\n\nfloat zoffset = -sampleShift;\nsampleShift /= stepsize; // make from 0 to 1\n\n\n\n//volumetric rendering\nfloat s=.24;\nfloat s3 = s + stepsize/2.0;\nvec3 v=vec3(0.);\nfloat t3 = 1.0;\n\n\nvec3 backCol2 = vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\nvec3 p3=from+(s3+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\np2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold\np3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n\n#ifdef cloud\nt3 = field(p3);\n#endif\n\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np2=abs(p2)/dot(p2,p2)-formuparam;\n             p2.xy*=mat2(cos(iTime*0.05), cos(iTime*0.05),-tan(iTime*0.05), cos(iTime*0.05));\n\nfloat D = abs(length(p2)-pa); // absolute sum of average change\na += i > 10 ? max( 12., D) : D;\npa=length(p2);\n}\n\n\n//float dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\n//if (r>3) fade*=1.-dm; // dark matter, don't render near\n// brightens stuff up a bit\nfloat s1 = s+zoffset;\n// need closed form expression for this, now that we shift samples\nfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\n\n//t3 += fade;\n\nv+=fade;\n      //backCol2 -= fade;\n\n// fade out samples as they approach the camera\nif( r == 0 )\nfade *= (1. - (sampleShift));\n// fade in samples as they approach from the distance\nif( r == volsteps-1 )\nfade *= sampleShift;\nv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\nbackCol2 += mix(1.4, 122., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;\n\n\ns+=stepsize;\ns3 += stepsize;\n\n\n\n}\n     \nv=mix(vec3(length(v)),v,saturation); //color adjust\n\n\n\n\nvec4 forCol2 = vec4(v*.01,1.);\n\n#ifdef cloud\nbackCol2 *= cloud;\n#endif\n\nbackCol2.b *= 1.8;\n\nbackCol2.r *= 0.05;\n\nbackCol2.b = 0.5*mix(backCol2.g, backCol2.b, 0.8);\nbackCol2.g = 0.0;\n\nbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0));\n\nfragColor = clamp(forCol2 + vec4(backCol2, 1.0), 0.0, 0.5 ) * 2.0;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}