{
    "Shader": {
        "info": {
            "date": "1719348023",
            "description": "Reasonably accurate SDF of trefoil knot.\nhttps://en.wikipedia.org/wiki/Trefoil_knot\nMay benefit from further optimizations. I focused on keeping the code readable; hoping it will inspire others to try and turn parametric equations into SDF.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3tXW4",
            "likes": 22,
            "name": "Trefoil Knot SDF explained",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ruudhelderman",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "// \"Trefoil Knot SDF explained\"\n// https://www.shadertoy.com/view/M3tXW4\n// SDF by Ruud Helderman, June 2024 - MIT License\n// Raymarching, shading, camera forked from \"Raymarching Sample Code\" by gltracy\n// https://www.shadertoy.com/view/XsB3Rm\n\n// Antialiasing: see tab \"Common\"\n\n//------------------------------------------------------------------\n\n// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 9.0;\n\n// math\nconst float PI = 3.14159265359;\n\n//------------------------------------------------------------------\n// BEGIN SDF\n//------------------------------------------------------------------\n\n// Parametric equation of the Trefoil Knot.\n// https://en.wikipedia.org/wiki/Trefoil_knot\nvec3 pareq(in float t)\n{\n    return vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\n// First derivative of the parametric equation.\nvec3 pareq_derived(in float t)\n{\n    return vec3(\n        cos(t) + 4.0 * cos(2.0 * t),\n        -sin(t) + 4.0 * sin(2.0 * t),\n        -3.0 * cos(3.0 * t)\n    );\n}\n\n// Distance between (0, 0, 0) and a line through p with direction d.\nfloat distance_origin_line(in vec3 p, in vec3 d)\n{\n    return length(cross(p, p + normalize(d)));\n}\n\n// Distance between p and pareq(t).\n// The better the estimate of t is, the more accurate this distance will be.\nfloat distance_point_curve(in vec3 p, in float s, in float t)\n{\n    return distance_origin_line(p - s * pareq(t), pareq_derived(t));\n}\n\n// Very rough estimate of t, trying to get pareq(t) near p.\nfloat rough_inverse(in vec3 p)\n{\n    return 0.5 * atan(p.x, -p.y);\n}\n\n// pareq(t) does not orbit the center at constant angular velocity.\n// This makes rough_inverse(p) a pretty poor inverse of pareq(t).\n// Some displacement of t can make it much more accurate.\n// improve_inverse(t) SHOULD be the inverse function of rough_inverse(pareq(t))\n// but it's still just an approximation, based on this graph I made:\n// https://www.desmos.com/calculator/5sc4v7sjsd\nfloat improve_inverse(in vec3 p, in float s, in float t)\n{\n    // I have no idea why this works. But it does.\n    vec3 d = pareq_derived(t);\n    return -t - atan(-d.y, d.x);\n    \n    // Another approach. Brings some weird artifacts.\n    //for (int i = 0; i < 3; i++)  // the more iterations, the more accurate\n    //{\n    //    vec3 d = pareq_derived(t);\n    //    t += dot(d, p - s * pareq(t)) / dot(d, d);\n    //}\n    //return t;\n    \n    // Fourier series? Probably the fastest and the most accurate.\n    //return t + dot(vec3(-0.2565, 0.0335, -0.0037), sin(vec3(3, 6, 9) * t));\n}\n\n// SDF for Trefoil Knot.\n// s = scale (size of the shape)\n// r = radius (thickness of the wire)\nfloat sdTrefoilKnot(in vec3 p, in float s, in float r)\n{\n    float t = rough_inverse(p);\n    \n    // There are 2 points on the curve that match t; calculate both.\n    float d1 = distance_point_curve(p, s, improve_inverse(p, s, t));\n    float d2 = distance_point_curve(p, s, improve_inverse(p, s, t + PI));\n    \n    // Take whichever is closest to p.\n    return min(d1, d2) - r;\n}\n\n//------------------------------------------------------------------\n// END SDF\n//------------------------------------------------------------------\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n    return sdTrefoilKnot( p, 0.5, 0.3 );\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ref = reflect( dir, n );\n    \n    vec3 Ks = vec3( 0.5 );\n    vec3 Kd = vec3( 1.0 );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n\t\t\n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -30.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        \n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F );\n\t}\n\n    final += texture( iChannel0, ref ).rgb * fresnel( Ks, n, -dir );\n    \n\treturn final;\n}\n\n\nbool ray_vs_aabb(vec3 o, vec3 dir, vec3 bmin, vec3 bmax, inout vec2 e ) {\n    vec3 a = ( bmin - o ) / dir;\n    vec3 b = ( bmax - o ) / dir;\n    \n    vec3 s = min( a, b );\n    vec3 t = max( a, b );\n    \n    e.x = max( max( s.x, s.y ), max( s.z, e.x ) );\n    e.y = max( min( t.x, t.y ), max( t.z, e.y ) );\n    \n    return e.x < e.y;\n}\n\n// ray marching\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    float d = 10000.0;\n    float dt = 0.0;\n    for ( int i = 0; i < max_iterations; i++ ) {\n        vec3 v = o + dir * t;\n        d = dist_field( v );\n        if ( d < stop_threshold ) {\n            break;\n        }\n        dt = min( abs(d), 0.1 );\n        t += dt;\n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    if ( d >= stop_threshold ) {\n        return false;\n    }\n    \n    t -= dt;\n    for ( int i = 0; i < 4; i++ ) {\n        dt *= 0.5;\n        \n        vec3 v = o + dir * ( t + dt );\n        if ( dist_field( v ) >= stop_threshold ) {\n            t += dt;\n        }\n    }\n    \n    depth = t;\n    n = normalize( gradient( o + dir * t ) );\n    return true;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( PI - fov ) * 0.5 );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 0.25 * PI, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) + 2. + .2*iTime );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    float depth = clip_far;\n    vec3 n = vec3( 0.0 );\n\tif ( !ray_marching( eye, dir, depth, n ) ) {\n\t\tfragColor = texture( iChannel0, dir );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n    \n    vec3 color = shading( pos, n, dir, eye );\n\tfragColor = vec4( pow( color, vec3(1.0/1.2) ), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"postprocess existing shaders\" by FabriceNeyret2\n// https://www.shadertoy.com/view/NdyfRz\n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// Change to 1 for antialiasing; will reduce framerate\n#if 0\n\nconst int _N = 3;\n\n#define mainImage mainImage0(out vec4 O, vec2 U);            \\\nvoid mainImage(out vec4 O, vec2 U) {                         \\\n    vec4 o; mainImage0(O,U);                                 \\\n    if (fwidth(length(O)) > .01) {                           \\\n      for (int k=0; k<_N*_N; k+=k==_N*_N/2-1?2:1, O+=o)      \\\n        mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); \\\n      O /= float(_N*_N);                                     \\\n    }                                                        \\\n}                                                            \\\nvoid mainImage0\n\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}