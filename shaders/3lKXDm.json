{
    "Shader": {
        "info": {
            "date": "1603387697",
            "description": "just people escaping a room",
            "flags": 48,
            "hasliked": 0,
            "id": "3lKXDm",
            "likes": 16,
            "name": "Social Force Model",
            "published": 3,
            "tags": [
                "escape"
            ],
            "usePreview": 0,
            "username": "Txoka",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "/*\nbased on \nhttps://addi.ehu.es/handle/10810/38527\n(work of one of my ex-teachers)\n(which you wont understand because it\n\tis in a local language)\n\nACCELERATE THE SHADER:\n(function(){if(Effect.prototype.Paint.toString().length>1000){_Paint=Effect.prototype.Paint;} Effect.prototype.Paint = function(...args){for(var i=0; i<50;i++){_Paint.apply(this,args);}}})()\n*/\nvoid mainImage(out vec4 Q, in vec2 U){\n    vec2 uv=(U*2.-R.xy)/R.y;\n    Q=vec4(0);\n    \n    \n    #ifdef FOLLOW\n    Q.b+=point(uv,person_radius);\n    vec4 who=tf(ivec2(PERSON_TO_FOLLOW,0));\n    vec2 dir=normalize(who.zw);\n    #ifdef ROTATE\n    uv=vec2(dot(uv,dir.yx*vec2(-1,1)),dot(uv,dir));\n    #endif\n    uv+=who.xy;\n    #endif\n    \n    for(int i=0;i<N;i++){\n        #ifdef FOLLOW\n        if(i==PERSON_TO_FOLLOW)continue;\n        #endif\n        Q.r+=point(uv-tf(ivec2(i,0)).xy,person_radius);\n    }\n    \n    #ifdef FOLLOW\n    Q.r*=attention(who.zw,uv-who.xy);\n    #endif\n    Q=vec4(0,0,Q.b,0)+Q.r;\n    \n    \n    Q.r+=point(uv-objective,exit_size);\n    \n    float pix=1./R.y;\n    \n   \tfloat o=smoothstep(pix*3.,0.,obstacles(uv));\n    \n    \n    \n\tQ.rgb=mix(Q.rgb,vec3(.3,.3,.1),o);\n    //if(obstacles==0.)Q=vec4(.3,.3,.1,0);\n    //Q=texture(iChannel1,(U/R.y*float(N))/R.xy);\n    //Q=tf1(ivec2(U/R.y*float(N)));\n    #ifdef SEE_WALL_DISTANCES\n    Q*=0.4;\n    float d=obstacles(uv);\n    float c=clamp(sin(100.*d),0.,1.);\n    if(d<0.){\n        Q.r+=c;\n    }else{\n        Q.b+=c;\n    }\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define FOLLOW\n//#define ROTATE\nconst int PERSON_TO_FOLLOW=0;\n//#define AVOID_OBSTACLE\n//#define SEE_WALL_DISTANCES\n//#define RANDOMIZE_SPIRAL_INITIALIZATION\n\nfloat dot2(vec2 x){return dot(x,x);}\nfloat point(vec2 x,float r){return clamp(0.,1.,r*r/dot2(x));}\n\n#define R iResolution\n#define tf(id) texelFetch(iChannel0,id,0)\n#define tf1(id) texelFetch(iChannel1,id,0)\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec4 hash42(vec2 p){\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n#define key(id) texelFetch(iChannel2,ivec2(id,0),0).x>0.\nint kSpace=32;\n\nconst float eps=1e-4;\nconst float pi=4.*atan(1.);\nconst float golden_angle=(3.-sqrt(5.))*pi;\n\nfloat sphere(vec2 p,float r){return length(p)-r;}\nfloat box_(vec2 p,vec2 b){return length(max((abs(p)-b),0.));}\nfloat box(vec2 p, vec2 size){\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y),0.0)+length(max(d, 0.0));\n}\n\n//VARIABLES\nconst int N=288;\n\nfloat obstacles(vec2 p){\n    //return 1.;\n    float sph=sphere(p-vec2(0.8,0),0.09);\n    float box0=box(p-vec2(1.1,-0.55)\t,vec2(0.05,0.40));\n    float box1=box(p-vec2(-0.9,0)\t\t,vec2(0.05,0.95));\n    float box2=box(p-vec2(0.1,0.9)\t\t,vec2(1.05,0.05));\n    float box3=box(p-vec2(0.1,-0.9)\t\t,vec2(1.05,0.05));\n    float box4=box(p-vec2(1.1,0.55)\t\t,vec2(0.05,0.40));\n    \n    //float box5=box(p-vec2(0.8,0.)\t\t,vec2(0.01,0.35));\n    return min(box0,min(box1,min(box2,min(box3,min(box4,sph)))));\n}\n\nconst float dt=2e-2;\n\nconst vec2 objective=vec2(1.5,0);\n\nconst float alpha=0.5;\nconst float obj_vel=1.;\nconst float max_vel=2.;\n\nconst float exit_size=0.07;\nconst float person_mass=1.;\nconst float person_radius=0.01;\nconst float person_A=3.;\nconst float person_B=0.1;\nconst float person_k0=8000.;\nconst float person_k1=5000.;\nconst float person_A_wall=9.;\nconst float person_B_wall=0.05;\nconst float attention_lambda=0.1;\n\nfloat attention(vec2 vel,vec2 b){\n    //return 1.;\n    if(dot2(vel)==0.)return 1.;\n\treturn mix(dot(normalize(vel),normalize(b))*0.5+0.5,1.,attention_lambda);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 Q, in vec2 U){\n    if(int(U.y)==0&&int(U.x)<N){\n        ivec2 id=ivec2(U.x,0);\n        Q=tf(id);\n        if(!all(equal(Q,vec4(-100)))){\n            //Q.zw*=0.95;\n            \n            //DIRECTOR FORCE\n            vec2 r=normalize(objective-Q.xy);\n            vec2 a=(obj_vel*r-Q.zw)/alpha;\n            \n            \n            //PERSON INTERACTIONS\n            vec2 f_persons=vec2(0);\n            for(int i=0;i<N;i++)f_persons+=tf1(ivec2(i,id.x)).xy;\n            \n            \n            //OBSTACLES\n            float pix=1./R.y;\n            float d=obstacles(Q.xy);\n            vec2 dir=\n                vec2(obstacles(Q.xy+vec2(pix,0)),obstacles(Q.xy+vec2(0,pix)))-\n                vec2(obstacles(Q.xy-vec2(pix,0)),obstacles(Q.xy-vec2(0,pix)));\n            \n            float f_modulo=person_A_wall*exp((person_radius-d)/person_B_wall);\n            vec2 f_obstacles=vec2(0);\n            if(dot2(dir)!=0.){\n                dir=normalize(dir);\n                f_obstacles=dir*f_modulo;\n                \n                #ifdef AVOID_OBSTACLE\n                f_obstacles+=dir.yx*vec2(-1,1)*f_modulo;\n                #endif\n                //collision stuff\n            \tfloat collision=person_radius-d;\n        \t\tif(collision>0.){\n        \t\t\tf_obstacles+=person_k0*collision*dir;\n        \t\t\tf_obstacles+=person_k1*collision*Q.zw*dir.yx*vec2(-1,1);\n        \t\t}\n            }\n            \n            vec2 f=f_persons+f_obstacles;\n            \n\n        \tQ.zw+=(a+f/person_mass)*dt;\n            if(dot2(Q.zw*dt)>max_vel*max_vel)Q.zw=normalize(Q.zw)*max_vel;\n        \tQ.xy+=Q.zw*dt;\n            \n        \tif(dot2(Q.xy-objective)<exit_size*exit_size)Q=vec4(-100);\n        }\n        if(iFrame==0||key(kSpace)){\n        \t//Q=hash42(U+iTime)*2.-1.;\n            //Q.xy*=0.7;\n        \t//Q.zw*=0.4;\n            float a=floor(U.x)*golden_angle;\n            #ifdef RANDOMIZE_SPIRAL_INITIALIZATION\n            Q.xy=vec2(sin(a),cos(a))*sqrt(hash11(U.x+iTime))*0.7;\n            #else\n            Q.xy=vec2(sin(a),cos(a))*sqrt(floor(U.x)/float(N))*0.7;\n            #endif\n            Q.zw=(hash22(U+iTime)*2.-1.)*0.2;\n        }\n   \t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 Q, in vec2 U){\n    ivec2 id=ivec2(U);\n    \n    if(id.x<N&&id.y<N&&id.x!=id.y){\n        vec4 p0=tf(ivec2(id.y,0));\n        vec4 p1=tf(ivec2(id.x,0));\n        \n        float d=distance(p0.xy,p1.xy);\n        vec2 n=normalize(p0.xy-p1.xy);\n        vec2 f=vec2(0);\n        f=+person_A*exp((2.*person_radius-d)/person_B)*n;\n        \n        \n        f*=attention(p0.zw,p1.xy-p0.xy);\n        \n        \n        //no effect unless they collide\n        float collision=2.*person_radius-d;\n        if(collision>=0.){\n        \tf+=person_k0*collision*n;\n        \tf+=person_k1*collision*(p1.zw-p0.zw)*n.yx*vec2(-1,1);\n        }\n        \n        Q=vec4(f,0,0);\n        if(iFrame==0)Q=vec4(0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}