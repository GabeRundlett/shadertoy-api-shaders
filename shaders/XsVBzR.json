{
    "Shader": {
        "info": {
            "date": "1527492352",
            "description": "A small test of ideas from [url=https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-1-a-brief-and-incomplete-history-of-baked-lighting-representations/]MJP's spherical gaussians[/url] blog series.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsVBzR",
            "likes": 35,
            "name": "Spherical gaussians, pt1",
            "published": 3,
            "tags": [
                "raymarching",
                "convolution",
                "rendering",
                "gaussian",
                "integration",
                "sphericalgaussians"
            ],
            "usePreview": 0,
            "username": "mmerchante",
            "viewed": 1394
        },
        "renderpass": [
            {
                "code": "/* \n * Spherical gaussians test, pt.1\n * Just testing the math from MJP's blog series about Spherical Gaussians:\n * \n * https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-1-a-brief-and-incomplete-history-of-baked-lighting-representations/\n *\n * I plan on doing more fun stuff with this, so I didn't include the anisotropic gaussian evaluation yet.\n * Also, code is not optimized.\n */\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MAX_STEPS 100\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 20.0\n#define MIN_DISTANCE 1.0\n#define EPSILON .001\n#define EPSILON_NORMAL .001\n\n#define LIGHT_COUNT 10\n\nconst uint k = 1103515245U;\n\n// iq\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// ---------------------------------------------------------\n\n// All SG math taken from \n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\nstruct SG\n{\n    vec3 Amplitude;\n    vec3 Axis;\n    float Sharpness;\n};\n    \nvec3 EvaluateSG(in SG sg, in vec3 dir)\n{\n    float cosAngle = dot(dir, sg.Axis);\n    return sg.Amplitude * exp(sg.Sharpness * (cosAngle - 1.0f));\n}\n\nSG SGProduct(in SG x, in SG y)\n{\n    vec3 um = (x.Sharpness * x.Axis + y.Sharpness * y.Axis) / (x.Sharpness + y.Sharpness);\n    float umLength = length(um);\n    float lm = x.Sharpness + y.Sharpness;\n \n    SG res;\n    res.Axis = um * (1.0f / umLength);\n    res.Sharpness = lm * umLength;\n    res.Amplitude = x.Amplitude * y.Amplitude * exp(lm * (umLength - 1.0f));\n \n    return res;\n}\n\nvec3 SGIntegral(in SG sg)\n{\n    float expTerm = 1.0f - exp(-2.0f * sg.Sharpness);\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness) * expTerm;\n}\n \nvec3 ApproximateSGIntegral(in SG sg)\n{\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness);\n}\n\n// Equals to the integral of the product of two SGs\nvec3 SGInnerProduct(in SG x, in SG y)\n{\n    float umLength = length(x.Sharpness * x.Axis + y.Sharpness * y.Axis);\n    vec3 expo = exp(umLength - x.Sharpness - y.Sharpness) *x.Amplitude * y.Amplitude;\n    float other = 1.0f - exp(-2.0f * umLength);\n    return (2.0f * 3.141592 * expo * other) / umLength;\n}\n\nfloat SGSharpnessFromThreshold(in float amplitude, in float epsilon, in float cosTheta)\n{\n    return (log(epsilon) - log(amplitude)) / (cosTheta - 1.0f);\n}\n\nSG CosineLobeSG(in vec3 direction)\n{\n    SG cosineLobe;\n    cosineLobe.Axis = direction;\n    cosineLobe.Sharpness = 2.133f;\n    cosineLobe.Amplitude = vec3(1.17f);\n    return cosineLobe;\n}\n\nvec3 SGIrradianceInnerProduct(in SG lightingLobe, in vec3 normal)\n{\n    SG cosineLobe = CosineLobeSG(normal);\n    return max(SGInnerProduct(lightingLobe, cosineLobe), 0.0f);\n}\n\nvec3 SGIrradianceFitted(in SG lightingLobe, in vec3 normal)\n{\n    float muDotN = dot(lightingLobe.Axis, normal);\n    float lambda = lightingLobe.Sharpness;\n \n    float c0 = 0.36f;\n    float c1 = 1.0f / (4.0f * c0);\n \n    float eml = exp(-lambda);\n    float em2l = eml * eml;\n    float rl = 1.0 / lambda;\n \n    float scale = 1.0f + 2.0f * em2l - rl;\n    float bias  = (eml - em2l) * rl - em2l;\n \n    float x  = sqrt(1.0f - scale);\n    float x0 = c0 * muDotN;\n    float x1 = c1 * x;\n \n    float n = x0 + x1;\n \n    float y = clamp(muDotN, 0.0, 1.0);\n    \n    if(abs(x0) <= x1)\n        y = (n * n) / x;\n \n    float result = scale * y + bias; \n    return result * ApproximateSGIntegral(lightingLobe);\n}\n\nvec3 SGDiffuseInnerProduct(in SG lightingLobe, in vec3 normal, in vec3 albedo)\n{\n    vec3 brdf = albedo / 3.141592;\n    return SGIrradianceFitted(lightingLobe, normal) * brdf;\n}\n\nSG DistributionTermSG(in vec3 direction, in float roughness)\n{\n    SG distribution;\n    distribution.Axis = direction;\n    float m2 = roughness * roughness;\n    distribution.Sharpness = 2.0 / m2;\n    distribution.Amplitude = vec3(1.0f / (3.141592 * m2)); \n    return distribution;\n}\n\nSG WarpDistributionSG(in SG ndf, in vec3 view)\n{\n    SG warp; \n    warp.Axis = reflect(-view, ndf.Axis);\n    warp.Amplitude = ndf.Amplitude;\n    warp.Sharpness = ndf.Sharpness;\n    warp.Sharpness /= (4.0f * max(dot(ndf.Axis, view), 0.0001f)); \n    return warp;\n}\n\nfloat GGX_V1(in float m2, in float nDotX)\n{\n    return 1.0f / (nDotX + sqrt(m2 + (1.0 - m2) * nDotX * nDotX));\n}\n \nvec3 SpecularTermSGWarp(in SG light, in vec3 normal, in float roughness, in vec3 view, in vec3 specAlbedo)\n{\n    SG ndf = DistributionTermSG(normal, roughness);\n    SG warpedNDF = WarpDistributionSG(ndf, view);\n \n    vec3 result = SGInnerProduct(warpedNDF, light);\n \n    vec3 warpDir = warpedNDF.Axis;\n    float m2 = roughness * roughness;\n    \n    // I'm still not sure I understand this, it's obscuring a lot of the fresnel contribution :/\n    float nDotL = saturate(dot(normal, warpDir));\n    result *= nDotL;\n    \n    float nDotV = saturate(dot(normal, view));\n    vec3 h = normalize(warpedNDF.Axis + view);\n \n    result *= GGX_V1(m2, nDotL) * GGX_V1(m2, nDotV);\n    \n    float powTerm = pow((1.0f - saturate(dot(warpDir, h))), 5.0);\n    result *= specAlbedo + (1.0f - specAlbedo) * powTerm;\n    \n    return max(result, 0.0f);\n}\n// ---------------------------------------------------------\n\nSG GetLightSG(int seed)\n{\n    seed += 1;\n    vec3 r1 = hash(uvec3(seed * 7, seed * 19, seed * 53));\n    vec3 r2 = hash(uvec3(seed * 7 * 7, seed * 19 * 7, seed * 53 * 7));\n    \n    float theta = r1.x * 3.1415 * 2.0;\n    float heightCap = 5.0;\n    float height = mod((1.0 - r1.y * r1.y) * heightCap + iTime * .3, heightCap) - heightCap * .5;\n    vec3 p = vec3(cos(theta), height, sin(theta));\n    \n    float amp = smoothstep(0.0, .1, abs(abs(height) - heightCap * .5));\n    \n\tSG light;\n\tlight.Axis = normalize(p);\n    light.Sharpness = mix(3.5, 1000.0, r2.x * r2.z);\n    light.Amplitude = pow(vec3(2.5, 1.5, 1.05), vec3(2.2)) * amp * mix(.05, .3, r2.y * r2.y);\n    return light;\n}\n\nfloat sdf(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);\n\tfloat dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);\n\tfloat dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{    \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec3 c0 = texture(iChannel0, P.xy).rgb * Nb.z;\n    vec3 c1 = texture(iChannel0, P.yz).rgb * Nb.x;\n    vec3 c2 = texture(iChannel0, P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.sdf < EPSILON)\n    {\n        vec3 normal = sdfNormal(p, EPSILON_NORMAL);        \n        vec3 result = vec3(0.0);\n\n        vec3 tx = triplanar(p, normal);\n        \n        float roughness = .25;\n        vec3 diffuse = pow(vec3(.85, .15, .05), vec3(2.2)) * .3;// vec3(.9) * tx; \n        vec3 specular = pow(vec3(1.0, .9, .85), vec3(2.2)) * .5;\n        \n\t\tfor(int i = 0; i < LIGHT_COUNT; ++i)\n        {\n        \tSG lightSG = GetLightSG(i);\n            \n        \tresult += SGDiffuseInnerProduct(lightSG, normal, diffuse);    \n            result += SpecularTermSGWarp(lightSG, normal, roughness, -camera.direction, specular);\n        }\n        \n        return result;\n    }\n    else\n    {\n     \tvec3 background = vec3(0.0);\n        \n\t\tfor(int i = 0; i < LIGHT_COUNT; ++i)\n        {\n        \tSG lightSG = GetLightSG(i);    \n        \tbackground += EvaluateSG(lightSG, camera.direction);    \n        }\n        \n        return background;\n    }\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf(p);\n\n\t\toutData.totalDistance += outData.sdf;\n                \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    return outData;\n}\n\nvec3 filmic(vec3 x)\n{\n\treturn ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    \n    if(abs(uv.y) > .8)\n        return;\n    \n    Camera camera = GetCamera(uv, 0.35, iTime * .25);\n    Intersection isect = Raymarch(camera);\n    vec3 color = Render(camera, isect, uv);    \n        \n\tvec3 vignette = mix(vec3(1.0, .8, .96) * .1, vec3(1.3), (1.0 - smoothstep(.0, 2.1, length(uv))));\n    vignette *= vignette;\n\t\n    \n\tvec3 whiteScale = 1.0f / filmic(vec3(6.2f));\n    color.rgb = filmic(color.rgb * 24.0 * vignette);    \n    color.rgb = clamp(color.rgb * whiteScale, vec3(0.0), vec3(1.0));\n    color = pow(color, vec3(.45454));\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n\nCamera GetCamera(vec2 uv, float zoom, float time)\n{\n    float dist = 2.35 / zoom;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}