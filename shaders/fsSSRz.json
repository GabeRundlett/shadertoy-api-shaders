{
    "Shader": {
        "info": {
            "date": "1619522311",
            "description": "Practicing glow stuff.\n\nThanks to FMS_Cat youyube video \nhttps://www.youtube.com/watch?v=5XPsUUcTElc ",
            "flags": 0,
            "hasliked": 0,
            "id": "fsSSRz",
            "likes": 9,
            "name": "大龙猫 - Test Glow2",
            "published": 3,
            "tags": [
                "glow",
                "ghost"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(0.)))+min(max(q.x,max(q.y,q.z)),.0);\n  }\nfloat sdf(vec3 p){\n  vec3 pp=p;\n  p.xz *=rot(fGlobalTime*.3);\n  //p.xy*=rot(fGlobalTime*.2);\n  vec3 id = floor(p);\n\n  p = abs(p)-2.5;\n  p.xz *=rot(.785);\n  for(float i=0.;i<2.;i++){\n      p.xy = abs(p.xy)-vec2(.55,.75)*2.5;\n      p.xy *=1.2;\n      //p.xy = p.x <p.y ? p.xy:p.yx;\n      p.xz = p.x >p.z ? p.xz:p.zx;\n      //p.yz = p.y <p.z ? p.yz:p.zy;\n      p.xy *=rot(0.785*i);\n      \n  } \n  p*=.5;\n  //return length(abs(pp)-1.5)-1.;\n  \n  vec3 ppp= pp;\n  ppp.xz *=rot(.785*.4*clamp(sin(fGlobalTime*4.),-.5,.5));\n  ppp.yz *=rot(.785*.4*clamp(cos(fGlobalTime*4.),-.5,.5));\n  ppp.xy *=rot(3.1415*clamp(-cos(fGlobalTime*4.),-.5,.5) - 3.1415*clamp(sin(fGlobalTime*4.),-.5,.5));\n  ppp.z = fract(ppp.z);\n  ppp = abs(ppp)-.55;\n  //ppp = abs(ppp)-.25;\n\n  float zz = box(ppp,vec3(.1,.1,4.));\n  float q = length(pp)-2.1;\n  \n  q = min(q,zz);\n  return min(q,length(p)-(.5+sin(p.x*20.+fGlobalTime*5.)*.02-cos(p.z*25.+fGlobalTime*5.)*.03));\n}\n\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s)\nvec3 norm(vec3 p){\n  return normalize(q(nv.xyy)+\n                   q(nv.yxy)+\n                   q(nv.yyx)+\n                   q(nv.xxx)\n  );\n}\nvec3 pal(float t){\n  return vec3(.5)+vec3(.5)*cos(6.28*(1.*t+vec3(.0,.4,.6)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float accum=0.;\n  vec3 ro=vec3(0.,0.,-10.),rd=normalize(vec3(uv,1.)),rp=ro;\n  vec3 light= vec3(1.,2.,-3.);\n  vec3 col = vec3(length(uv)*.5);\n\tbool st = false;\n  for(float i=0.;i<=69.;i++){\n    float d = sdf(rp);\n    accum += exp(30.*-abs(d))/69.;\n    d = max(0.001+sin(fGlobalTime*4.+atan(rp.x,rp.z)*10.-length(uv)*8.)*.1+.1,abs(d));\n   \n    rp+=d*rd;\n    \n   \n  }\n   \n  col += accum*vec3(1.5,1.7,1.9);\n  \n  float qq = step(.5,sin(fGlobalTime)*.5+.5)*.3;\n  col = mix(vec3(.01),pal( .1+qq+accum),col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}