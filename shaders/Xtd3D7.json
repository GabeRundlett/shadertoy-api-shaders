{
    "Shader": {
        "info": {
            "date": "1484520092",
            "description": "Dancing shape factory!\nPlay with xMult, yMult and r to get different result.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xtd3D7",
            "likes": 6,
            "name": "Dancing shape factory",
            "published": 3,
            "tags": [
                "2d",
                "animation",
                "loop",
                "distancefunctions",
                "morph"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 654
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.14159265\n#define loopTime 3.5\n\nfloat xMult = 4.5;\nfloat yMult = 6.;\nfloat r = 0.04;\n\n// https://www.shadertoy.com/view/MstGRr\nfloat getBoxDist(vec2 p, vec2 size, float radius) {\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nvec2 rotateAroundPoint(vec2 p, vec2 c, float angle) {\n\tvec2 t = p - c;\n    vec2 rot = vec2(\n        cos(angle) * t.x - sin(angle) * t.y,\n        sin(angle) * t.x + cos(angle) * t.y\n    );\n\treturn c + rot;\n}\n\nvec2 squishAroundPoint(vec2 p, vec2 c, float squish) {\n\treturn (p - c) * vec2(1. / squish, squish) + c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    p.x *= aspectRatio;\n    vec2 center = vec2(0.5 * aspectRatio, 0.5);\n \n    float t = mod(iTime, loopTime) / loopTime;\n    float loopN = mod(iTime / loopTime + 2., 4.);\n\n    if (t > 0.8) { // zoom in\n        p = (p - center)*(1. - (t - 0.8) * 2.5) + center + vec2((t - 0.8) * 1.67, 0.0);\n    }\n\n    vec2 gridPoint = vec2(floor(p.x * xMult + 0.5)/xMult, floor(p.y * yMult + 0.5)/yMult);\n    \n    float morph = 0., squish = 1., angle = 0.;\n    \n    float xEven = mod(p.x * xMult + 0.5, 2.) > 1. ? 1. : 0.;\n    float yEven = mod(p.y * yMult + 0.5, 2.) > 1. ? 1. : 0.;\n \n    if (xEven * yEven > 0.5) { // main points\n        if (t < 0.1) {\n            squish = 1. + 0.4 * sin(t * M_PI * 10.);\n            morph = 1.;\n        } else if (t < 0.3) {\n            squish = 1. + 0.4 * sin((t - 0.1) * M_PI * 5. / 2.);\n            morph = 1. - sin((t - 0.1) * M_PI * 5. / 2.);\n        } else if (t < 0.4) {\n            squish = 1.4 - 0.6 * sin((t - 0.3) * M_PI * 5.);\n        } else if (t < 0.5) {\n            squish = 0.8 + 0.2 * sin((t - 0.4) * M_PI * 5.);\n        } else if (t < 0.56) {\n            angle = (0.56 - t) * 2.0;\n        } else if (t < 0.7) {\n            angle = mix(0., M_PI / 4., (t - 0.56) / 0.14);\n            r = mix(r, r * 0.7, (t - 0.56) / 0.14);\n        } else if (t < 0.8) {\n            r = mix(r * 0.7, r * 1.3, (t - 0.7) * 10.);\n            angle = M_PI / 4.;\n        } else if (t < 0.9) {\n            r = mix(r * 1.3, r * 0.75, (t - 0.8) * 10.);\n            angle = mix(M_PI / 4., 2.*M_PI + 3.*M_PI / 2., (t-0.8) * 10.);\n            morph = (t - 0.8) * 10.;\n        } else {\n            r = mix(r * 0.75, r * 0.5, (t - 0.9) * 10.);\n            angle = 2.*M_PI + 3.*M_PI / 2.;\n            morph = 1.;\n        }\n    } else { // hor - vert - diag\n        float tStart = yEven > 0.5 ? 0.2 :\n        \txEven > 0.5 ? 0.35 : 0.75;\n        morph = 1.;\n\n        if (t < tStart) r = 0.0;\n        else if (t < tStart + 0.05) r *= (t - tStart) * 6.;\n        else if (t < 0.9) r *= 0.3;\n        else r *= mix(0.3, 0.9, (t - 0.9) * 2.);\n    }\n      \n    p = squishAroundPoint(p, gridPoint, squish);\n    p = rotateAroundPoint(p, gridPoint, angle);\n        \n    float bDist = getBoxDist(p - gridPoint, vec2(r), 0.0);\n    float cDist = length(p - gridPoint) - r;\n    float d = mix(bDist, cDist, morph);\n    \n    float loopFillerMix = clamp((abs(loopN - 1.0 - 2.) - 0.9) * 10., 0., 1.); // [0, 1]\n    float edge = smoothstep(r / 6., r / 4., d);\n    float innerEdge = smoothstep(r / 160., r / 16., d + loopFillerMix * 0.1);\n    \n\tfragColor = vec4(mix(vec3(0), vec3(1), max(edge, (1. - innerEdge))), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}