{
    "Shader": {
        "info": {
            "date": "1609530884",
            "description": "Pascal's triangle in mod p.",
            "flags": 0,
            "hasliked": 0,
            "id": "tltcRj",
            "likes": 3,
            "name": "Pascal's triangle in mod p",
            "published": 3,
            "tags": [
                "gasket",
                "pascalstriangle"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst int ROWS = 200;\nconst int N_PRIMES = 4;\nconst int PRIMES[N_PRIMES] = int[](2, 3, 5, 7);\n\nconst int INVS_LENGTH = 7;\nint INVS[INVS_LENGTH];\n\n// 配色アイデア手帖 https://www.amazon.co.jp/dp/B07881DSZQ/\n// p.256-257 Black and Bright Color\nconst vec3 PALLET[9] = vec3[](\n    vec3(40.0, 0.0, 23.0) / 255.0,\n    vec3(225.0, 146.0, 188.0) / 255.0,\n    vec3(187.0, 174.0, 212.0) / 255.0,\n    vec3(171.0, 217.0, 203.0) / 255.0,\n    vec3(248.0, 245.0, 176.0) / 255.0,\n    vec3(195.0, 196.0, 196.0) / 255.0,\n    vec3(229.0, 66.0, 145.0) / 255.0,\n    vec3(231.0, 42.0, 84.0) / 255.0,\n    vec3(126.0, 56.0, 145.0) / 255.0\n);\n\nvoid initINVS(in int p) {\n    INVS[0] = 0;\n    for (int i = 1; i < p; i++) {\n        for (int k = 1; k < p; k++) {\n            if ((i * k) % p == 1) {\n                INVS[i] = k;\n                break;\n            }\n        }\n    }\n}\n\n// mantissa * p^exponent\nstruct PNum {\n    int mantissa;\n    int exponent;\n};\n\nPNum mul(in PNum a, in PNum b, in int p) {\n    PNum c;\n    c.mantissa = (a.mantissa * b.mantissa) % p;\n    c.exponent = a.exponent + b.exponent;\n    return c;\n}\n\nPNum div(in PNum a, in PNum b, in int p) {\n    PNum c;\n    c.mantissa = (a.mantissa * INVS[b.mantissa]) % p;\n    c.exponent = a.exponent - b.exponent;\n    return c;\n}\n\nPNum int2PNum(in int n, in int p) {\n    PNum c;\n    c.exponent = 0;\n    while (n % p == 0) {\n        n /= p;\n        c.exponent += 1;\n    }\n    c.mantissa = n % p;\n    return c;\n}\n\nint PNumCombo(in int n, in int k, in int p) {\n    PNum res = int2PNum(1, p);\n    for (int i = 0; i < k; i++) {\n        PNum c = int2PNum(n - i, p);\n        res = mul(res, c, p);\n        c = int2PNum(i + 1, p);\n        res = div(res, c, p);\n    }\n    return res.exponent == 0 ? res.mantissa : 0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int p = PRIMES[int(iTime) % N_PRIMES];\n    int rows = ROWS;\n    int columns = rows % 2 == 0 ? rows : rows + 1;\n\n    initINVS(p);\n    vec2 uv = fragCoord / iResolution.y;\n    float asp = iResolution.x / iResolution.y;\n    int n = int(float(rows) * (1.0 - uv.y));\n    int k = int(floor(((2.0 * uv - asp) * float(columns) + float(n + 1)) / 2.0));\n    if (0 <= k && k <= n) fragColor = vec4(PALLET[PNumCombo(n, k, p)], 1.0);\n    else fragColor = vec4(PALLET[0], 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}