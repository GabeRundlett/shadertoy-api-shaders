{
    "Shader": {
        "info": {
            "date": "1627927940",
            "description": "If you have experience in Anti-aliasing, please, take a look at this shader: https://www.shadertoy.com/view/slBXRG\nmaybe you would be able to help with AA. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7tBSzy",
            "likes": 3,
            "name": "Coordinate transformations:rotat",
            "published": 3,
            "tags": [
                "rotation",
                "coordinatetransformation"
            ],
            "usePreview": 0,
            "username": "modesty",
            "viewed": 252
        },
        "renderpass": [
            {
                "code": "// COORDINATE TRANSFORMATIONS: ROTATION\n// Lets to rotate the shapes.\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nfloat coordinateGrid(vec2 r) {\n    vec3 axesCol = vec3(0.0, 0.0, 1.0);\n    vec3 gridCol = vec3(0.5);\n    float ret = 0.0;\n    \n    // Draw grid lines\n    const float tickWidth = 0.1;\n    for(float i=-2.0; i<2.0; i+=tickWidth) {\n        // 'i' is the line coordinate\n        ret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n        ret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n    }\n    \n    // Draw the axes\n    ret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n    ret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n    \n    return ret;\n}\n\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n    return 1.0 - smoothstep(radius-0.005, radius+0.005, length(r-center));\n}\n\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n    float ret;\n    float d = 0.005;\n    ret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n    ret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n    ret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n    ret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.xy/iResolution.xy);\n    vec2 r = 2.0*vec2(fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    float xMax = iResolution.x/iResolution.y;\n    \n    vec3 bgCol = vec3(1.0);\n    vec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n    vec3 col2 = vec3(1.00, 0.329, 0.298);  // yellow\n    vec3 col3 = vec3(0.867, 0.910, 0.247); // red\n    \n    vec3 ret;\n    vec2 q;\n    float angle;\n    angle = 0.2*PI; // angle in radians(PI is 180 degrees);\n    \n    // q is the rotated coordinate system\n    q.x = cos(angle) * r.x + sin(angle) * r.y;\n    q.y = -sin(angle) * r.x + cos(angle) * r.y;\n    \n    ret = bgCol;\n    // draw the old and new coordinate system\n    \n    ret = mix(ret, col1, coordinateGrid(r) * 0.4);\n    ret = mix(ret, col2, coordinateGrid(q));\n    \n    // draw shapes in old coordinate system, r, and new coordinate system, q\n    ret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n    ret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n    ret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)));\n    ret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)));\n    // both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}