{
    "Shader": {
        "info": {
            "date": "1469433740",
            "description": "Messing with ray marching",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3GD8",
            "likes": 3,
            "name": "Ray marching snakes",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "run",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "// ray marching\nconst float max_iterations = 55.;\nconst float stop_threshold = 0.001;\nconst float grad_step = .1;\nconst float clip_far = 250.0;\nconst float p = 2.;\nconst float q = 5.;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nfloat steps;\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nvec3 torus_knot_pos(float time) {\n    float r = 6. + cos(time * q);\n    return vec3(r * cos(p * time),\n                r * sin(p * time),\n                -sin(q * time));\n}\n\nvec3 torus_knot_pos_x(float time) {\n    float r = 6. + cos(time * q);\n    return vec3(-sin(q * time),\n                r * cos(p * time),\n                r * sin(p * time));\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n    \n    vec3 pos01 = torus_knot_pos(mod(iTime, 2.*PI));\n    // object 0 : sphere\n\tfloat d0 = dist_sphere( pos  + pos01, 2. );\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos  + pos01, vec3( 1.4 + 0.3*sin(iTime) ) );\n    float final_value = max( d0, -d1 );\n    for (float i=0.; i<6.; i++) {\n        vec3 pos23 = torus_knot_pos(mod(iTime+i/4., 2.*PI));\n        // object 0 : sphere\n        float d2 = dist_sphere( pos  + pos23, 2. );\n        // object 1 : cube\n        float d3 = dist_box( pos  + pos23, vec3( 1.4 + 0.3*sin(iTime) ) );\n        final_value = smin(final_value, max(d2, -d3), 6.4);\n    }\n    \n    pos.x += 4.;\n    pos.y -= 4.;\n    \n    vec3 pos01_x = torus_knot_pos_x(mod(iTime-PI/2., 2.*PI));\n    // object 0 : sphere\n\tfloat d0_x = dist_sphere( pos  + pos01_x, 2. );\n\t// object 1 : cube\n\tfloat d1_x = dist_box( pos  + pos01_x, vec3( 1.4 + 0.3*sin(iTime) ) );\n    float final_value_x = max( d0_x, -d1_x );\n    for (float i=0.; i<6.; i++) {\n        vec3 pos23_x = torus_knot_pos_x(mod(iTime+i/4.-PI/2., 2.*PI));\n        // object 0 : sphere\n        float d2_x = dist_sphere( pos  + pos23_x, 2. );\n        // object 1 : cube\n        float d3_x = dist_box( pos  + pos23_x, vec3( 1.4 + 0.3*sin(iTime) ) );\n        final_value_x = smin(final_value_x, max(d2_x, -d3_x), 6.4);\n    }\n    \n    /*vec3 pos45 = torus_knot_pos(mod(iTime+2., 2.*PI));\n    // object 0 : sphere\n\tfloat d4 = dist_sphere( pos  + pos45, 2. );\n\t// object 1 : cube\n\tfloat d5 = dist_box( pos  + pos45, vec3( 1.4 + 0.3*sin(iTime) ) );*/\n\t\t\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn smin(final_value, final_value_x, 4.);\n    //return max(d2, -d3);\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end) {\n\tfloat depth = start;\n\tfor ( float i = 0.; i < max_iterations; i++ ) {\n        steps = i * 1.;\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background\n    vec2 uv = fragCoord/iResolution.xy;\n    float intensity = min(1., max(0.,1. * sin(uv.y * 100.) + (2. + sin(iTime * 4.) * 2.) * sin(uv.x * 100.)));\n    \n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 15.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( iTime * 0.1) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far);\n\tif ( depth >= clip_far ) {\n        float glow = min(max(0., (steps - 15.) * 0.08), 1.);\n\t\tfragColor = vec4( vec3(glow) + vec3(0.8, 0.8, 0.3) * intensity, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}