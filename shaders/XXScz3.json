{
    "Shader": {
        "info": {
            "date": "1727470038",
            "description": "Pathtracing raymarching shader done in MaterialMaker for a local demoscene event flyer\nUse your mouse! Takes a long time to compile! When changing resolution, you have to wait 256 frames\nFont converted to a shader from www.dafont.com/pt/vcr-osd-mono.font",
            "flags": 32,
            "hasliked": 0,
            "id": "XXScz3",
            "likes": 8,
            "name": "Momentum #17",
            "published": 3,
            "tags": [
                "font",
                "pathtracing",
                "materialmaker"
            ],
            "usePreview": 1,
            "username": "PauloFalcao",
            "viewed": 137
        },
        "renderpass": [
            {
                "code": "// Momentum #17\n//\n// By https://twitter.com/paulofalcao\n//\n// Takes a long time to compile! Use your mouse!\n//\n// Used in a flyer for a local demoscene event\n// https://x.com/paulofalcao/status/1837279790824386778\n//\n// When changing resolution, you have to wait 256 frames for font rendering\n//\n// Generated in Material Maker\n// The code is basically the generated code adapted to use buffer A as the font\n// No simplification or optimization\n//\n// Material Maker source here https://www.materialmaker.org/material?id=1018\n//\n// Font converted to a shader (buffer A) from www.dafont.com/pt/vcr-osd-mono.font\n// Shader to render the font here\n// https://www.shadertoy.com/view/4XByz3\n//\n// Font to SDF uses iq Signed Jump Flooding\n// https://www.shadertoy.com/view/4XlyW8\n//\n\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    color.xyz=ACESFilm(color.xyz/color.w);\n    fragColor = vec4(pow(color.xyz,vec3(1.0/2.2)), 1.0f);\n\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Mono font from www.dafont.com/pt/vcr-osd-mono.font\n//\n// Shader here https://www.shadertoy.com/view/4XjcRh\n// \n// Font to SDF uses iq Signed Jump Flooding\n// https://www.shadertoy.com/view/4XlyW8\n\nconst uint /* A */ _A[6] = uint[](0x03000000u, 0x1CE3F078u, 0x303C0F87u, 0x3FFFFF03u, 0x303C0F03u, 0x00000303u);\nconst uint /* B */ _B[6] = uint[](0x3FC00000u, 0x303C1FFEu, 0x3FEC1F03u, 0x303C1FFEu, 0x3FEC1F03u, 0x000003FCu);\nconst uint /* C */ _C[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x300C0300u, 0x300C0300u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* D */ _D[6] = uint[](0x3FC00000u, 0x303C1FFEu, 0x303C0F03u, 0x303C0F03u, 0x3FEC1F03u, 0x000003FCu);\nconst uint /* E */ _E[6] = uint[](0x3FF00000u, 0x300C03FFu, 0x3FCC0300u, 0x300C03FCu, 0x3FFC0300u, 0x000003FFu);\nconst uint /* F */ _F[6] = uint[](0x3FF00000u, 0x300C03FFu, 0x3FCC0300u, 0x300C03FCu, 0x300C0300u, 0x00000300u);\nconst uint /* G */ _G[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x31FC0300u, 0x303C0F1Fu, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* H */ _H[6] = uint[](0x30300000u, 0x303C0F03u, 0x3FFC0F03u, 0x303C0FFFu, 0x303C0F03u, 0x00000303u);\nconst uint /* I */ _I[6] = uint[](0x0FC00000u, 0x0300C0FCu, 0x0300C030u, 0x0300C030u, 0x0FC0C030u, 0x000000FCu);\nconst uint /* J */ _J[6] = uint[](0x03F00000u, 0x00C0303Fu, 0x00C0300Cu, 0x00C0300Cu, 0x1F8E730Cu, 0x000000F0u);\nconst uint /* K */ _K[6] = uint[](0x30300000u, 0x31CC3B07u, 0x3E0DC338u, 0x338DC3E0u, 0x307C3B1Cu, 0x00000303u);\nconst uint /* L */ _L[6] = uint[](0x30000000u, 0x300C0300u, 0x300C0300u, 0x300C0300u, 0x3FFC0300u, 0x000003FFu);\nconst uint /* M */ _M[6] = uint[](0x30300000u, 0x3CFE1F03u, 0x333DEFFFu, 0x303C0F33u, 0x303C0F03u, 0x00000303u);\nconst uint /* N */ _N[6] = uint[](0x30300000u, 0x383C0F03u, 0x373F8FC3u, 0x30FC7F3Bu, 0x303C0F07u, 0x00000303u);\nconst uint /* O */ _O[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* P */ _P[6] = uint[](0x3FC00000u, 0x303C1FFEu, 0x3FEC1F03u, 0x300C03FCu, 0x300C0300u, 0x00000300u);\nconst uint /* Q */ _Q[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x303C0F03u, 0x33BCCF03u, 0x1FFE3B1Fu, 0x000000F3u);\nconst uint /* R */ _R[6] = uint[](0x3FC00000u, 0x303C1FFEu, 0x3FEC1F03u, 0x338DC3FCu, 0x307C3B1Cu, 0x00000303u);\nconst uint /* S */ _S[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x1FCE0300u, 0x00301CFEu, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* T */ _T[6] = uint[](0x3FF00000u, 0x0300C3FFu, 0x0300C030u, 0x0300C030u, 0x0300C030u, 0x00000030u);\nconst uint /* U */ _U[6] = uint[](0x30300000u, 0x303C0F03u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* V */ _V[6] = uint[](0x30300000u, 0x303C0F03u, 0x303C0F03u, 0x387C0F03u, 0x0783F1CEu, 0x00000030u);\nconst uint /* W */ _W[6] = uint[](0x30300000u, 0x303C0F03u, 0x333C0F03u, 0x333CCF33u, 0x1FEFFF33u, 0x000000CCu);\nconst uint /* X */ _X[6] = uint[](0x30300000u, 0x387C0F03u, 0x0783F1CEu, 0x1CE3F078u, 0x303C0F87u, 0x00000303u);\nconst uint /* Y */ _Y[6] = uint[](0x30300000u, 0x303C0F03u, 0x1CEE1F03u, 0x0301E0FCu, 0x0300C030u, 0x00000030u);\nconst uint /* Z */ _Z[6] = uint[](0x3FF00000u, 0x00700FFFu, 0x0380700Eu, 0x1C038070u, 0x3FFC0380u, 0x000003FFu);\nconst uint /* a */ _a[6] = uint[](0x00000000u, 0x0FE3F000u, 0x0FB00C07u, 0x303E1DFFu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* b */ _b[6] = uint[](0x30000000u, 0x338C0300u, 0x3C7FBB7Cu, 0x383E0F83u, 0x37CFBBC7u, 0x00000338u);\nconst uint /* c */ _c[6] = uint[](0x00000000u, 0x0FC00000u, 0x303E1DFEu, 0x300C0300u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* d */ _d[6] = uint[](0x00300000u, 0x07300C03u, 0x38F77CFBu, 0x307C1F07u, 0x0FB77F8Fu, 0x00000073u);\nconst uint /* e */ _e[6] = uint[](0x00000000u, 0x0FC00000u, 0x303E1DFEu, 0x300FFBFFu, 0x1FEE1F00u, 0x000000FCu);\nconst uint /* f */ _f[6] = uint[](0x01E00000u, 0x1FE0C03Eu, 0x0300C1FEu, 0x0300C030u, 0x0300C030u, 0x00000030u);\nconst uint /* g */ _g[6] = uint[](0x00000000u, 0x1FE3F000u, 0x387C0F87u, 0x0033EDFFu, 0x1FE61C03u, 0x000000FCu);\nconst uint /* h */ _h[6] = uint[](0x30000000u, 0x338C0300u, 0x3C7FBB7Cu, 0x303C0F83u, 0x303C0F03u, 0x00000303u);\nconst uint /* i */ _i[6] = uint[](0x00000000u, 0x0000C030u, 0x0F03C000u, 0x0300C030u, 0x01C0E030u, 0x0000000Cu);\nconst uint /* j */ _j[6] = uint[](0x00C03000u, 0x03C00000u, 0x00C0303Cu, 0x00C0300Cu, 0x0F80700Cu, 0x000000F0u);\nconst uint /* k */ _k[6] = uint[](0x30000000u, 0x303C0300u, 0x31CC3B07u, 0x3F8DC338u, 0x307E3BDCu, 0x00000303u);\nconst uint /* l */ _l[6] = uint[](0x03000000u, 0x0300C030u, 0x0300C030u, 0x0300C030u, 0x0300C030u, 0x00000030u);\nconst uint /* m */ _m[6] = uint[](0x00000000u, 0x37C00000u, 0x333EDFFEu, 0x333CCF33u, 0x333CCF33u, 0x00000333u);\nconst uint /* n */ _n[6] = uint[](0x00000000u, 0x37C00000u, 0x303E1FFEu, 0x303C0F03u, 0x303C0F03u, 0x00000303u);\nconst uint /* o */ _o[6] = uint[](0x00000000u, 0x0FC00000u, 0x303E1DFEu, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* p */ _p[6] = uint[](0x00000000u, 0x3FEDF000u, 0x383E0FC7u, 0x3FEF1F83u, 0x300C037Cu, 0x00000300u);\nconst uint /* q */ _q[6] = uint[](0x00000000u, 0x1FF3EC00u, 0x307C1F8Fu, 0x1FFE3F07u, 0x00300CF7u, 0x00000003u);\nconst uint /* r */ _r[6] = uint[](0x00000000u, 0x33C00000u, 0x3C3F9F7Eu, 0x300C0380u, 0x300C0300u, 0x00000300u);\nconst uint /* s */ _s[6] = uint[](0x00000000u, 0x0FC00000u, 0x383E1DFEu, 0x01E1F1F0u, 0x1FEE1F07u, 0x000000FCu);\nconst uint /* t */ _t[6] = uint[](0x03000000u, 0x0FC0C030u, 0x0300C0FCu, 0x0300C030u, 0x01C0E030u, 0x0000000Cu);\nconst uint /* u */ _u[6] = uint[](0x00000000u, 0x30300000u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* v */ _v[6] = uint[](0x00000000u, 0x30300000u, 0x303C0F03u, 0x387C0F03u, 0x0783F1CEu, 0x00000030u);\nconst uint /* w */ _w[6] = uint[](0x00000000u, 0x30300000u, 0x303C0F03u, 0x333CCF33u, 0x1FEEDF33u, 0x000000CCu);\nconst uint /* x */ _x[6] = uint[](0x00000000u, 0x30300000u, 0x0FC73B87u, 0x0780C078u, 0x387738FCu, 0x00000303u);\nconst uint /* y */ _y[6] = uint[](0x00000000u, 0x303C0C00u, 0x30FC1F07u, 0x0F37EF9Fu, 0x0FE01C03u, 0x000000FCu);\nconst uint /* z */ _z[6] = uint[](0x00000000u, 0x3FF00000u, 0x00E01FFFu, 0x0700E01Cu, 0x3FF700E0u, 0x000003FFu);\nconst uint /* 0 */ _0[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x33BC7F0Fu, 0x3C3F8F73u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* 1 */ _1[6] = uint[](0x03000000u, 0x0F03C070u, 0x0300C030u, 0x0300C030u, 0x0FC0C030u, 0x000000FCu);\nconst uint /* 2 */ _2[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x0FE01C03u, 0x300E01FCu, 0x3FFC0300u, 0x000003FFu);\nconst uint /* 3 */ _3[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x03E01C03u, 0x00301C3Eu, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* 4 */ _4[6] = uint[](0x00C00000u, 0x07C0F01Cu, 0x38C730ECu, 0x3FFFFF0Cu, 0x00C0300Cu, 0x0000000Cu);\nconst uint /* 5 */ _5[6] = uint[](0x3FF00000u, 0x300C03FFu, 0x007FFBFCu, 0x00300C03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* 6 */ _6[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x3FCC0300u, 0x303C1FFEu, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* 7 */ _7[6] = uint[](0x3FF00000u, 0x00300FFFu, 0x01C03807u, 0x0300C038u, 0x0300C030u, 0x00000030u);\nconst uint /* 8 */ _8[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x1FEE1F03u, 0x303E1DFEu, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* 9 */ _9[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x1FFE0F03u, 0x00300CFFu, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* $ */ _dollar[6] = uint[](0x03000000u, 0x3B77F8FCu, 0x1FCEC333u, 0x3330DCFEu, 0x0FC7FBB7u, 0x00000030u);\nconst uint /* ¢ */ _cent[6] = uint[](0x03000000u, 0x1FE3F030u, 0x330CCFB7u, 0x3B7CCF30u, 0x0303F1FEu, 0x00000030u);\nconst uint /* € */ _euro[6] = uint[](0x0E31F83Cu, 0x3F0601C0u, 0x3F0603F0u, 0x180603F0u, 0x07E38DC0u, 0x0000003Cu);\nconst uint /* £ */ _sterling[6] = uint[](0x0E71F83Cu, 0x0C0300C3u, 0x0C0FF3FCu, 0x0C0300C0u, 0x3FF600C0u, 0x000003FFu);\nconst uint /* ¥ */ _yen[6] = uint[](0x18600000u, 0x0CC61986u, 0x0781E0CCu, 0x0307F830u, 0x0307F830u, 0x00000030u);\nconst uint /* + */ _plus[6] = uint[](0x00000000u, 0x0300C000u, 0x3FF0C030u, 0x0300C3FFu, 0x0000C030u, 0x00000000u);\nconst uint /* - */ _minus[6] = uint[](0x00000000u, 0x00000000u, 0x1FE00000u, 0x000001FEu, 0x00000000u, 0x00000000u);\nconst uint /* * */ _asterisk[6] = uint[](0x1320C000u, 0x0783F1B6u, 0x1326D8FCu, 0x00000030u, 0x00000000u, 0x00000000u);\nconst uint /* / */ _slash[6] = uint[](0x00300000u, 0x00700C03u, 0x0380700Eu, 0x1C038070u, 0x300C0380u, 0x00000300u);\nconst uint /* = */ _equal[6] = uint[](0x00000000u, 0x00000000u, 0x000FFFFFu, 0x3FFFFC00u, 0x00000000u, 0x00000000u);\nconst uint /* % */ _percent[6] = uint[](0x1C300000u, 0x367D8FE3u, 0x038773EEu, 0x1DF3B870u, 0x31FC6F9Bu, 0x0000030Eu);\nconst uint /* \" */ _quotedbl[6] = uint[](0x1CE00000u, 0x084739CEu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ' */ _quotesingle[6] = uint[](0x07000000u, 0x0201C070u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* # */ _numbersign[6] = uint[](0x00C00000u, 0x0FF33CCCu, 0x0CCF33FCu, 0x3FC3FCCFu, 0x0C0333CCu, 0x00000000u);\nconst uint /* @ */ _at[6] = uint[](0x00000000u, 0x303618FCu, 0x2D9B6669u, 0x276B6ED9u, 0x0FC61B00u, 0x00000000u);\nconst uint /* & */ _ampersand[6] = uint[](0x18C3E070u, 0x18C6318Cu, 0x1F03E0D8u, 0x31FCEFF0u, 0x1FFE3B0Eu, 0x000000FBu);\nconst uint /* _ */ _underscore[6] = uint[](0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x000003FFu);\nconst uint /* ( */ _parenleft[6] = uint[](0x0600C018u, 0x0C0300C0u, 0x0C0300C0u, 0x0C0300C0u, 0x030180C0u, 0x00000018u);\nconst uint /* ) */ _parenright[6] = uint[](0x0180C060u, 0x00C0300Cu, 0x00C0300Cu, 0x00C0300Cu, 0x0300600Cu, 0x00000060u);\nconst uint /* , */ _comma[6] = uint[](0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0600C030u, 0x000000C0u);\nconst uint /* . */ _period[6] = uint[](0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x06000000u, 0x00000060u);\nconst uint /* ; */ _semicolon[6] = uint[](0x00000000u, 0x06018000u, 0x00000000u, 0x00000000u, 0x0C018060u, 0x00000180u);\nconst uint /* : */ _colon[6] = uint[](0x00000000u, 0x06018000u, 0x00000000u, 0x00000000u, 0x00018060u, 0x00000000u);\nconst uint /* ¿ */ _questiondown[6] = uint[](0x03000000u, 0x00000030u, 0x0E01C030u, 0x300E01C0u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ? */ _question[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x00E01C03u, 0x0300E01Cu, 0x03000000u, 0x00000030u);\nconst uint /* ¡ */ _exclamdown[6] = uint[](0x01800000u, 0x00000018u, 0x01806018u, 0x01806018u, 0x01806018u, 0x00000018u);\nconst uint /* ! */ _exclam[6] = uint[](0x06000000u, 0x06018060u, 0x06018060u, 0x06018060u, 0x06000000u, 0x00000060u);\nconst uint /* \\ */ _backslash[6] = uint[](0x30000000u, 0x380C0300u, 0x070381C0u, 0x00E07038u, 0x00300C07u, 0x00000003u);\nconst uint /* | */ _bar[6] = uint[](0x0300C030u, 0x0300C030u, 0x0300C030u, 0x0300C030u, 0x0300C030u, 0x00000030u);\nconst uint /* { */ _braceleft[6] = uint[](0x03C0701Cu, 0x0300C030u, 0x0E038030u, 0x0300C030u, 0x01C0F030u, 0x0000001Cu);\nconst uint /* } */ _braceright[6] = uint[](0x0F0380E0u, 0x0300C030u, 0x01C07030u, 0x0300C030u, 0x0E03C030u, 0x000000E0u);\nconst uint /* < */ _less[6] = uint[](0x00E01800u, 0x0700E01Cu, 0x180700E0u, 0x070381C0u, 0x00E07038u, 0x00000006u);\nconst uint /* > */ _greater[6] = uint[](0x1C060000u, 0x0381C0E0u, 0x0060381Cu, 0x0380700Eu, 0x1C038070u, 0x00000180u);\nconst uint /* [ */ _bracketleft[6] = uint[](0x0601F87Eu, 0x06018060u, 0x06018060u, 0x06018060u, 0x07E18060u, 0x0000007Eu);\nconst uint /* ] */ _bracketright[6] = uint[](0x0187E1F8u, 0x01806018u, 0x01806018u, 0x01806018u, 0x1F806018u, 0x000001F8u);\nconst uint /* ` */ _grave[6] = uint[](0x0E000000u, 0x00006070u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ^ */ _asciicircum[6] = uint[](0x03000000u, 0x1CE3F078u, 0x00000387u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ~ */ _asciitilde[6] = uint[](0x00000000u, 0x00000000u, 0x1F338400u, 0x0008733Eu, 0x00000000u, 0x00000000u);\nconst uint /* © */ _copyright[6] = uint[](0x00000000u, 0x33B618FCu, 0x24190661u, 0x33B98641u, 0x0003F186u, 0x00000000u);\nconst uint /* ® */ _registered[6] = uint[](0x0FC00000u, 0x249DCD86u, 0x2499C649u, 0x0FC61B4Bu, 0x00000000u, 0x00000000u);\nconst uint /* ™ */ _trademark[6] = uint[](0x3F100000u, 0x0912549Bu, 0x00024491u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /*   */ _space[6] = uint[](0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ¦ */ _brokenbar[6] = uint[](0x0300C030u, 0x0300C030u, 0x00000030u, 0x0300C030u, 0x0300C030u, 0x00000030u);\nconst uint /* ¨ */ _dieresis[6] = uint[](0x0CC00000u, 0x000000CCu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ª */ _ordfeminine[6] = uint[](0x0F800000u, 0x0FC0318Cu, 0x18C4318Cu, 0x1FC000F4u, 0x000001FCu, 0x00000000u);\nconst uint /* « */ _guillemotleft[6] = uint[](0x00000000u, 0x02100000u, 0x18C31863u, 0x0C663318u, 0x00008463u, 0x00000000u);\nconst uint /* ° */ _degree[6] = uint[](0x0F000000u, 0x30CE71F8u, 0x1F8E730Cu, 0x000000F0u, 0x00000000u, 0x00000000u);\nconst uint /* ² */ _superscripttwo[6] = uint[](0x01836070u, 0x0C030070u, 0x000000F8u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ³ */ _superscriptthree[6] = uint[](0x01836070u, 0x0D806030u, 0x00000070u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ´ */ _acute[6] = uint[](0x01C00000u, 0x00018038u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ¹ */ _superscriptone[6] = uint[](0x0301C030u, 0x0300C030u, 0x00000078u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* º */ _ordmasculine[6] = uint[](0x07000000u, 0x18C630F8u, 0x0F86318Cu, 0x1FC00070u, 0x000001FCu, 0x00000000u);\nconst uint /* » */ _guillemotright[6] = uint[](0x00000000u, 0x21000000u, 0x0C663318u, 0x18C31863u, 0x00084318u, 0x00000000u);\nconst uint /* ¼ */ _onequarter[6] = uint[](0x184E1982u, 0x1986218Cu, 0x0600C3D0u, 0x08A33846u, 0x30247D9Au, 0x00000202u);\nconst uint /* ½ */ _onehalf[6] = uint[](0x184E1982u, 0x1986218Cu, 0x0600C3D0u, 0x08336C4Eu, 0x3184618Eu, 0x0000021Fu);\nconst uint /* ¾ */ _threequarters[6] = uint[](0x062D8DC1u, 0x36C190C6u, 0x030061C8u, 0x04A1B826u, 0x18227CDAu, 0x00000102u);\nconst uint /* À */ _Agrave[6] = uint[](0x0181C0E0u, 0x0780C000u, 0x387738FCu, 0x3FFC0F03u, 0x303C0FFFu, 0x00000303u);\nconst uint /* Á */ _Aacute[6] = uint[](0x0600E01Cu, 0x0780C000u, 0x387738FCu, 0x3FFC0F03u, 0x303C0FFFu, 0x00000303u);\nconst uint /* Â */ _Acircumflex[6] = uint[](0x0CC1E030u, 0x0780C000u, 0x387738FCu, 0x3FFC0F03u, 0x303C0FFFu, 0x00000303u);\nconst uint /* Ã */ _Atilde[6] = uint[](0x0983F064u, 0x0780C000u, 0x387738FCu, 0x3FFC0F03u, 0x303C0FFFu, 0x00000303u);\nconst uint /* Ä */ _Adieresis[6] = uint[](0x000330CCu, 0x0780C000u, 0x387738FCu, 0x3FFC0F03u, 0x303C0FFFu, 0x00000303u);\nconst uint /* Å */ _Aring[6] = uint[](0x04812030u, 0x0780C030u, 0x387738FCu, 0x3FFC0F03u, 0x303C0FFFu, 0x00000303u);\nconst uint /* Æ */ _AE[6] = uint[](0x03F07C00u, 0x1D83E078u, 0x31FC7D98u, 0x3F8FE318u, 0x31FC6318u, 0x0000031Fu);\nconst uint /* Ç */ _Ccedilla[6] = uint[](0x0FC00000u, 0x303E1DFEu, 0x300C0300u, 0x1FEE1F03u, 0x0700E0FCu, 0x000000E0u);\nconst uint /* È */ _Egrave[6] = uint[](0x0181C0E0u, 0x3FFFFC00u, 0x300C0300u, 0x300FF3FCu, 0x3FFC0300u, 0x000003FFu);\nconst uint /* É */ _Eacute[6] = uint[](0x0600E01Cu, 0x3FFFFC00u, 0x300C0300u, 0x300FF3FCu, 0x3FFC0300u, 0x000003FFu);\nconst uint /* Ê */ _Ecircumflex[6] = uint[](0x0CC1E030u, 0x3FFFFC00u, 0x300C0300u, 0x300FF3FCu, 0x3FFC0300u, 0x000003FFu);\nconst uint /* Ë */ _Edieresis[6] = uint[](0x000330CCu, 0x3FFFFC00u, 0x300C0300u, 0x300FF3FCu, 0x3FFC0300u, 0x000003FFu);\nconst uint /* Ì */ _Igrave[6] = uint[](0x0181C0E0u, 0x0FC3F000u, 0x0300C030u, 0x0300C030u, 0x0FC0C030u, 0x000000FCu);\nconst uint /* Í */ _Iacute[6] = uint[](0x0600E01Cu, 0x0FC3F000u, 0x0300C030u, 0x0300C030u, 0x0FC0C030u, 0x000000FCu);\nconst uint /* Î */ _Icircumflex[6] = uint[](0x0CC1E030u, 0x0FC3F000u, 0x0300C030u, 0x0300C030u, 0x0FC0C030u, 0x000000FCu);\nconst uint /* Ï */ _Idieresis[6] = uint[](0x000330CCu, 0x0FC3F000u, 0x0300C030u, 0x0300C030u, 0x0FC0C030u, 0x000000FCu);\nconst uint /* Ð */ _Eth[6] = uint[](0x1FC00000u, 0x18361DFEu, 0x3E360D83u, 0x18360FE3u, 0x1FE61D83u, 0x000001FCu);\nconst uint /* Ñ */ _Ntilde[6] = uint[](0x0983F064u, 0x303C0C00u, 0x3E3F0F83u, 0x31FCEF73u, 0x303C1F0Fu, 0x00000303u);\nconst uint /* Ò */ _Ograve[6] = uint[](0x0181C0E0u, 0x1FE3F000u, 0x303C0F87u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ó */ _Oacute[6] = uint[](0x0600E01Cu, 0x1FE3F000u, 0x303C0F87u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ô */ _Ocircumflex[6] = uint[](0x0CC1E030u, 0x1FE3F000u, 0x303C0F87u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Õ */ _Otilde[6] = uint[](0x0983F064u, 0x1FE3F000u, 0x303C0F87u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ö */ _Odieresis[6] = uint[](0x000330CCu, 0x1FE3F000u, 0x303C0F87u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ø */ _Oslash[6] = uint[](0x0FB00000u, 0x30FE39FFu, 0x333C6F1Bu, 0x363D8F33u, 0x3FE71FC3u, 0x0000037Cu);\nconst uint /* Ù */ _Ugrave[6] = uint[](0x0181C0E0u, 0x303C0C00u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ú */ _Uacute[6] = uint[](0x0600E01Cu, 0x303C0C00u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Û */ _Ucircumflex[6] = uint[](0x0CC1E030u, 0x303C0C00u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ü */ _Udieresis[6] = uint[](0x000330CCu, 0x303C0C00u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* Ý */ _Yacute[6] = uint[](0x0600E01Cu, 0x303C0C00u, 0x1CEE1F03u, 0x0301E0FCu, 0x0300C030u, 0x00000030u);\nconst uint /* Þ */ _Thorn[6] = uint[](0x300C0000u, 0x3FEFF300u, 0x303C0F07u, 0x3FEC1F03u, 0x300C03FCu, 0x00000300u);\nconst uint /* ß */ _germandbls[6] = uint[](0x3B87C0C0u, 0x318C6318u, 0x330CC330u, 0x30EC7338u, 0x37EC1B06u, 0x0000037Cu);\nconst uint /* à */ _agrave[6] = uint[](0x0E000000u, 0x00006070u, 0x0033F8FCu, 0x3877FCFBu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* á */ _aacute[6] = uint[](0x01C00000u, 0x00018038u, 0x0033F8FCu, 0x3877FCFBu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* â */ _acircumflex[6] = uint[](0x03000000u, 0x00033078u, 0x0033F8FCu, 0x3877FCFBu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* ã */ _atilde[6] = uint[](0x06400000u, 0x000260FCu, 0x0033F8FCu, 0x3877FCFBu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* ä */ _adieresis[6] = uint[](0x0CC00000u, 0x000000CCu, 0x0033F8FCu, 0x3877FCFBu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* å */ _aring[6] = uint[](0x03000000u, 0x03012048u, 0x0033F8FCu, 0x3877FCFBu, 0x1FFE1F03u, 0x000000FBu);\nconst uint /* æ */ _ae[6] = uint[](0x00000000u, 0x3CE00000u, 0x0330CFFFu, 0x330FFDFFu, 0x3FECC330u, 0x000001EEu);\nconst uint /* ç */ _ccedilla[6] = uint[](0x00000000u, 0x3877F8FCu, 0x300C0303u, 0x1FEE1F03u, 0x0700E0FCu, 0x000000E0u);\nconst uint /* è */ _egrave[6] = uint[](0x0E000000u, 0x00006070u, 0x3877F8FCu, 0x3FEFFF03u, 0x1FEE1F00u, 0x000000FCu);\nconst uint /* é */ _eacute[6] = uint[](0x01C00000u, 0x00018038u, 0x3877F8FCu, 0x3FEFFF03u, 0x1FEE1F00u, 0x000000FCu);\nconst uint /* ê */ _ecircumflex[6] = uint[](0x03000000u, 0x00033078u, 0x3877F8FCu, 0x3FEFFF03u, 0x1FEE1F00u, 0x000000FCu);\nconst uint /* ë */ _edieresis[6] = uint[](0x0CC00000u, 0x000000CCu, 0x3877F8FCu, 0x3FEFFF03u, 0x1FEE1F00u, 0x000000FCu);\nconst uint /* ì */ _igrave[6] = uint[](0x1C000000u, 0x0000C0E0u, 0x0F03C000u, 0x0300C030u, 0x01C0E030u, 0x0000000Cu);\nconst uint /* í */ _iacute[6] = uint[](0x01C00000u, 0x00018038u, 0x0F03C000u, 0x0300C030u, 0x01C0E030u, 0x0000000Cu);\nconst uint /* î */ _icircumflex[6] = uint[](0x06000000u, 0x000660F0u, 0x0F03C000u, 0x0300C030u, 0x01C0E030u, 0x0000000Cu);\nconst uint /* ï */ _idieresis[6] = uint[](0x19800000u, 0x00000198u, 0x0F03C000u, 0x0300C030u, 0x01C0E030u, 0x0000000Cu);\nconst uint /* ð */ _eth[6] = uint[](0x00601800u, 0x0061FC7Fu, 0x3867F8FEu, 0x306C1B06u, 0x1FCE3B06u, 0x000000F8u);\nconst uint /* ñ */ _ntilde[6] = uint[](0x06400000u, 0x000260FCu, 0x387FFB7Cu, 0x303C0F03u, 0x303C0F03u, 0x00000303u);\nconst uint /* ò */ _ograve[6] = uint[](0x0E000000u, 0x00006070u, 0x3877F8FCu, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ó */ _oacute[6] = uint[](0x01C00000u, 0x00018038u, 0x3877F8FCu, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ô */ _ocircumflex[6] = uint[](0x03000000u, 0x00033078u, 0x3877F8FCu, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* õ */ _otilde[6] = uint[](0x06400000u, 0x000260FCu, 0x3877F8FCu, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ö */ _odieresis[6] = uint[](0x0CC00000u, 0x000000CCu, 0x3877F8FCu, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ø */ _oslash[6] = uint[](0x00000000u, 0x0FB00000u, 0x30FE19FFu, 0x363CCF1Bu, 0x3FE61FC3u, 0x0000037Cu);\nconst uint /* ù */ _ugrave[6] = uint[](0x0E000000u, 0x00006070u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ú */ _uacute[6] = uint[](0x01C00000u, 0x00018038u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* û */ _ucircumflex[6] = uint[](0x03000000u, 0x00033078u, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ü */ _udieresis[6] = uint[](0x0CC00000u, 0x000000CCu, 0x303C0F03u, 0x303C0F03u, 0x1FEE1F03u, 0x000000FCu);\nconst uint /* ý */ _yacute[6] = uint[](0x01C00000u, 0x00018038u, 0x30FC1F03u, 0x0F37EF9Fu, 0x0FE01C03u, 0x000000FCu);\nconst uint /* þ */ _thorn[6] = uint[](0x00000000u, 0x33CC0300u, 0x303F1FFEu, 0x3C7C0F03u, 0x300CF3FEu, 0x00000300u);\nconst uint /* ÿ */ _ydieresis[6] = uint[](0x0CC00000u, 0x000000CCu, 0x30FC1F03u, 0x0F37EF9Fu, 0x0FE01C03u, 0x000000FCu);\nconst uint /* ‘ */ _quoteleft[6] = uint[](0x00400000u, 0x01C06008u, 0x0000701Cu, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ’ */ _quoteright[6] = uint[](0x0E000000u, 0x060380E0u, 0x00020040u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* “ */ _quotedblleft[6] = uint[](0x04200000u, 0x1CE63084u, 0x000739CEu, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* ” */ _quotedblright[6] = uint[](0x1CE00000u, 0x0C6739CEu, 0x00042084u, 0x00000000u, 0x00000000u, 0x00000000u);\nconst uint /* • */ _bullet[6] = uint[](0x00000000u, 0x00000000u, 0x0FC3F078u, 0x0001E0FCu, 0x00000000u, 0x00000000u);\nconst uint /* … */ _ellipsis[6] = uint[](0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x33300000u, 0x00000333u);\nconst uint /* ‹ */ _guilsinglleft[6] = uint[](0x00000000u, 0x00000000u, 0x03004000u, 0x18030060u, 0x030180C0u, 0x00000010u);\nconst uint /* › */ _guilsinglright[6] = uint[](0x00000000u, 0x00000000u, 0x0C020000u, 0x0180C060u, 0x0C018030u, 0x00000080u);\nconst uint /* ⁄ */ _fraction[6] = uint[](0x00300000u, 0x00700C03u, 0x0380700Eu, 0x1C038070u, 0x300C0380u, 0x00000300u);\nconst uint /* ₣ */ _franc[6] = uint[](0x1FF00000u, 0x180601FFu, 0x1FC60180u, 0x180601FCu, 0x180603E0u, 0x00000180u);\nconst uint /* ₤ */ _lira[6] = uint[](0x0E71F83Cu, 0x0C0300C3u, 0x0C0FF3FCu, 0x0C0FF3FCu, 0x3FF600C0u, 0x000003FFu);\nconst uint /* ₧ */ _peseta[6] = uint[](0x38000000u, 0x240902C0u, 0x25094240u, 0x214E56FFu, 0x21584617u, 0x00000217u);\nconst uint /* ► */ _triagrt[6] = uint[](0x00000000u, 0x1F0781C0u, 0x1FE7F1F8u, 0x1F87F1FEu, 0x1C0781F0u, 0x00000000u);\nconst uint /* ◄ */ _triaglf[6] = uint[](0x00000000u, 0x03E0780Eu, 0x1FE3F87Eu, 0x07E3F9FEu, 0x00E0783Eu, 0x00000000u);\nconst uint /* ▼ */ _triagdn[6] = uint[](0x00000000u, 0x3FFFFFFFu, 0x1FE7FBFFu, 0x0783F0FCu, 0x0300C078u, 0x00000000u);\nconst uint /* ▲ */ _triagup[6] = uint[](0x00000000u, 0x0780C030u, 0x0FC3F078u, 0x3FF7F9FEu, 0x3FFFFFFFu, 0x00000000u);\nconst uint /* ← */ _arrowleft[6] = uint[](0x00000000u, 0x0600C000u, 0x3FF600C0u, 0x0C0603FFu, 0x0000C060u, 0x00000000u);\nconst uint /* → */ _arrowright[6] = uint[](0x00000000u, 0x0180C000u, 0x3FF0180Cu, 0x00C01BFFu, 0x0000C018u, 0x00000000u);\nconst uint /* ↑ */ _arrowup[6] = uint[](0x00000000u, 0x0300C000u, 0x0CC1E078u, 0x186618CCu, 0x000C0F03u, 0x00000000u);\nconst uint /* ↓ */ _arrowdown[6] = uint[](0x00000000u, 0x303C0C00u, 0x0CC61986u, 0x0781E0CCu, 0x0000C030u, 0x00000000u);\nconst uint /* ↔ */ _arrowboth[6] = uint[](0x00000000u, 0x01000000u, 0x3FE07018u, 0x3FEFFFFFu, 0x0100601Cu, 0x00000000u);\n\nfloat F(float x, float y, float size,int position, uint[6] letter) {\n\n    x-=size*float(position)*0.855;\n    \n    if (x<0.0) return 0.;\n    if (y<0.0) return 0.;\n    \n    uint ux=uint(x*14.0*1.0/size);\n    uint uy=uint(y*14.0*1.0/size)+1u;\n    \n    if ( uy >= 17u) {\n        return 0.;\n    }\n    if ( ux >= 10u) {\n        return 0.;\n    }\n\n    uy=16u-uy;\n    uint lp = uy / 3u;\n    uint lpx = uy % 3u;\n    uint packedValue = letter[lp];\n    uint row_value = (packedValue >> (lpx * 10u)) & 0x3FFu;\n    \n    uint draw=row_value & (1u << (9u - ux));\n    return draw==0u?0.0:1.0;\n}\n\n\n\n//Code below adapted from from iq Signed Jump Flooding\n//https://www.shadertoy.com/view/4XlyW8\n\n// The MIT License\n// Copyright © 2024 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// some binary shape (0=inside, 1=outside)\nfloat shape( in vec2 uv ){\n    \n\n    uv+=vec2(1.32,0.2);\n  \n    uv.y/=iResolution.y/iResolution.x;\n    \n    uv.y/=2.0;\n    \n    float p = 0.0;\n    int i=0;\n    p+=F(uv.x,uv.y,0.40,i++,_M);\n    p+=F(uv.x,uv.y,0.40,i++,_O);\n    p+=F(uv.x,uv.y,0.40,i++,_M);\n    p+=F(uv.x,uv.y,0.40,i++,_E);\n    p+=F(uv.x,uv.y,0.40,i++,_N);\n    p+=F(uv.x,uv.y,0.40,i++,_T);\n    p+=F(uv.x,uv.y,0.40,i++,_U);\n    p+=F(uv.x,uv.y,0.40,i++,_M);\n    \n    return 1.0-p;\n}\n\n\n\n//------------------------------------------------------------------------------------------\n// 32 bit buffer layout. Each entry stores the closest point and some metadata:\n//\n// 00-14 : x coordinate, from 0 to 32,767\n// 15    : set (1=interior, 0=exterior)\n// 16-31 : y coordinate, from 0 to 65,534. Value FFFF is reserved to signal unresolved pixel\n//------------------------------------------------------------------------------------------\n\n// (x, y, set, resolved)\nivec4 unpack( uint d )\n{\n    uint x = d & 0x7fffu;\n    uint y = d >> 16;\n    uint s = d & 0x8000u;\n    uint r = (y==0xffffu)?0u:1u;\n    return ivec4(x,y,s,r);\n}\n\n// we only pack resolved pixels\nuint pack( ivec2 p, int s )\n{\n    return uint(p.x)|uint(s)|(uint(p.y)<<16);\n}\n\n// initialize buffer (d>=0 is the interior set, d<1 is the exterior set)\nuint init( float d ) \n{\n    return d<0.5 ? 0xffffffffu : 0xffff7fffu;\n}\n\n//------------------------------------------------------------------------------------------\n\n// this could be done in pure integer arithmetic if we had uin64_t available to us\nfloat dot2( in ivec2 x ) { return dot(vec2(x),vec2(x)); }\n\nint computeNumPasses( in ivec2 resolution )\n{\n    int dim = max( resolution.x, resolution.y );\n    \n    // would be easier if we could ise findMSB() from GLSL 4.0.\n    // but for now this will do (I want to stay in integer land)\n    #if 1\n        dim = max(dim-1,0);\n        int r = 0;\n        if( dim > 0xFFFF ) { dim >>= 16; r |= 16; }\n        if( dim > 0x00FF ) { dim >>=  8; r |=  8; }\n        if( dim > 0x000F ) { dim >>=  4; r |=  4; }\n        if( dim > 0x0003 ) { dim >>=  2; r |=  2; }\n        if( dim > 0x0001 ) { dim >>=  1; r |=  1; }\n        return r+1;\n    #else\n        if( dim>=32768 ) return 16;\n        if( dim>=16384 ) return 15;\n        if( dim>= 8192 ) return 14;\n        if( dim>= 4096 ) return 13;\n        if( dim>= 2048 ) return 12;\n        if( dim>= 1024 ) return 11;\n        if( dim>=  512 ) return 10;\n        if( dim>=  256 ) return  9;\n        if( dim>=  128 ) return  8;\n        if( dim>=   64 ) return  7;\n        if( dim>=   32 ) return  6;\n        if( dim>=   16 ) return  5;\n        if( dim>=    8 ) return  4;\n        if( dim>=    4 ) return  3;\n        if( dim>=    2 ) return  2;\n                         return  1;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame & 255;\n    \n    int numPasses = computeNumPasses( ivec2(iResolution.xy) );\n    \n    //---------------------------------------------------------------------------------\n    // First frame we mark the interior and exterior pixel sets\n    //---------------------------------------------------------------------------------\n    if( frame==0 )\n    {\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float d = shape(p);\n        \n        // initialize 32 bit buffer\n        fragColor.x = uintBitsToFloat(init(d));\n    }\n    //---------------------------------------------------------------------------------\n    // Next \"numPasses\" number of frames, perform one Jump Flood algorithm pass\n    //---------------------------------------------------------------------------------\n    else if( (frame>=1) && (frame<=numPasses) )\n    {\n        // read 32 bits from buffer\n        ivec2 p_pixl = ivec2(fragCoord);\n        uint p_data_packed = floatBitsToUint(texelFetch(iChannel0, p_pixl, 0).r);\n        ivec4 p_data = unpack(p_data_packed);\n        \n        // distance to closest known pixel on the complementary set (interior vs exterior)\n        float currdis = (p_data.w==1) ? dot2( p_pixl-p_data.xy ) : 1e20;\n        \n        int width = (1<<(numPasses-frame));\n\n        // pre-clip scan window (removes in-loop conditionals)\n        int minx = p_pixl.x-width < 0                    ? 0 : -1;\n        int miny = p_pixl.y-width < 0                    ? 0 : -1;\n        int maxx = p_pixl.x+width > int(iResolution.x)-1 ? 0 :  1;\n        int maxy = p_pixl.y+width > int(iResolution.y)-1 ? 0 :  1;\n        \n        for( int y=miny; y<=maxy; y++ )\n        for( int x=minx; x<=maxx; x++ )\n        {\n            // 1. gather a distant pixel\n            ivec2 q_offs = ivec2(x,y)*width;\n            ivec2 q_pixl = p_pixl + q_offs;\n            ivec4 q_data = unpack(floatBitsToUint(texelFetch(iChannel0,q_pixl,0).x));\n        \n            // 2. does it belong to the complementary set?\n            if( q_data.z != p_data.z ) \n            {\n                // if so, is it closer than the closest known pixel so far?\n                float dis = dot2(q_offs);\n                if( dis < currdis )\n                {\n                    // if so, update our record\n                    currdis = dis;\n                    p_data_packed = pack(q_pixl.xy,p_data.z);\n                }     \n           }\n           \n           // 3. or is it maybe an already resolved pixel?\n           else if( q_data.w==1 )\n           {\n                // if so, is its closest known pixel closer than the closest known pixel so far?\n                float dis = dot2(q_data.xy-p_pixl);\n                if( dis < currdis )\n                {\n                    // if so, update our record\n                    currdis = dis;\n                    p_data_packed = pack(q_data.xy,p_data.z);\n                }\n            }\n        }\n        \n        // write 32 bits to buffer\n        fragColor.r = uintBitsToFloat(p_data_packed);\n    }\n    //---------------------------------------------------------------------------------\n    // then copy content (because Shadertoy ping-pongs two textures per pass)\n    //---------------------------------------------------------------------------------\n    else if( frame==numPasses+1 )\n    {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n    //---------------------------------------------------------------------------------\n    // Rest of frames do nothing, we are done here\n    //---------------------------------------------------------------------------------\n    else\n    {\n        discard;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Momentum #17\n//\n// By https://twitter.com/paulofalcao\n//\n// Takes a long time to compile! Use your mouse!\n//\n// Used in a flyer for a local demoscene event\n// https://x.com/paulofalcao/status/1837279790824386778\n//\n// When changing resolution, you have to wait 256 frames for font rendering\n//\n// Generated in Material Maker\n// The code is basically the generated code adapted to use buffer A as the font\n// No simplification or optimization\n//\n// Material Maker source here https://www.materialmaker.org/material?id=1018\n//\n// Font converted to a shader (buffer A) from www.dafont.com/pt/vcr-osd-mono.font\n// Shader to render the font here\n// https://www.shadertoy.com/view/4XByz3\n//\n// Font to SDF uses iq Signed Jump Flooding\n// https://www.shadertoy.com/view/4XlyW8\n//\n\n\n/* Generated by Material Maker */\n\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nfloat box3d(vec3 uv, vec3 s) {\n\tvec3 q = abs(uv) - s;\n\treturn length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec2 sdf3d_smooth_union(vec2 d1, vec2 d2, float k) {\n\tfloat h = clamp(0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0);\n\treturn vec2(mix(d2.x, d1.x, h)-k*h*(1.0-h), mix(d2.y, d1.y, step(d1.x, d2.x)));\n}\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nvec2 sdf3dc_union(vec2 a, vec2 b) {\n\treturn vec2(min(a.x, b.x), mix(b.y, a.y, step(a.x, b.x)));\n}\n\nvec4 sdf3dc1_union(vec4 a, vec4 b) {\n\treturn vec4((a.w<b.w)?vec4(a):vec4(b));\n}\n\nfloat sdSmoothUnion( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//MATH\nconst float PI=3.14159265359;\nconst float TAU=6.28318530718;\n\nvoid pathtracing_Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint pathtracing_rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * uint(747796405) + uint(2891336453);\n    uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n    return (word >> uint(22)) ^ word;\n}\n\nfloat RandomFloat01(inout uint state){\n    uint r=pathtracing_rand_pcg(state);\n    r &= uint(0x007FFFFF);\n    r |= uint(0x3F800000);\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n// SAMPLING START\n\nvec3 pathtracing_constSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 pathtracing_cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=RandomFloat01(state);\n    float u2=RandomFloat01(state);\n    return normalize(n+pathtracing_constSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 pathtracing_SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=RandomFloat01(state);\n    float U2=RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    pathtracing_Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat pathtracing_schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\nconst float p_o2147865_CamX = 0.061000000;\nconst float p_o2147865_CamY = 0.317000000;\nconst float p_o2147865_CamZ = 0.152000000;\nconst float p_o2147865_LookAtX = 0.272000000;\nconst float p_o2147865_LookAtY = 0.677000000;\nconst float p_o2147865_LookAtZ = 0.314000000;\nconst float p_o2147865_CamD = 0.506000000;\nconst float p_o2147865_CamZoom = 5.250000000;\nconst float p_o2147865_MaxDistance = 7.850000000;\nconst vec4 p_o2148157_BaseColor = vec4(0.113328002, 0.113328002, 0.113328002, 1.000000000);\nconst float p_o2148157_Metallic = 0.000000000;\nconst float p_o2148157_Specular = 0.000000000;\nconst float p_o2148157_Roughness = 1.000000000;\nconst float p_o2148157_Emission = 0.000000000;\nconst float p_o2148157_Normal = 0.000000000;\nconst float p_o2148157_Alpha = 0.000000000;\nconst float p_o2148157_AmbientOcclusion = 0.000000000;\nconst float p_o2148157_scale = 1.000000000;\nconst float p_o2148157_TranlateX = 0.000000000;\nconst float p_o2148157_TranlateY = -1.000000000;\nconst float p_o2148157_TranlateZ = 0.000000000;\nconst float p_o2148157_RotateX = 0.000000000;\nconst float p_o2148157_RotateY = 0.000000000;\nconst float p_o2148157_RotateZ = 0.000000000;\nvec3 o2148157_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o2148157_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148157_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148157_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o2148157_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o2148157_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o2148157_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148157_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o2148154_k = 2.350000000;\nconst float p_o2148156_sx = 32.000000000;\nconst float p_o2148156_sy = 0.470000000;\nconst float p_o2148156_sz = 32.000000000;\nconst float p_o2148156_r = 0.010000000;\nconst float p_o2148153_x = 0.000000000;\nconst float p_o2148153_y = 0.000000000;\nconst float p_o2148153_z = -3.770000000;\nconst float p_o2148155_sx = 32.000000000;\nconst float p_o2148155_sy = 32.000000000;\nconst float p_o2148155_sz = 0.370000000;\nconst float p_o2148155_r = 0.010000000;\nfloat o2148157_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o2148156_0_1_sdf3d = box3d((p), vec3(p_o2148156_sx, p_o2148156_sy, p_o2148156_sz))-p_o2148156_r;\nfloat o2148155_0_1_sdf3d = box3d(((p)-vec3(p_o2148153_x, p_o2148153_y, p_o2148153_z)), vec3(p_o2148155_sx, p_o2148155_sy, p_o2148155_sz))-p_o2148155_r;\nvec2 o2148153_0_1_sdf3dc = vec2(o2148155_0_1_sdf3d, 0.0);\nvec2 o2148154_0_1_sdf3dc = sdf3d_smooth_union(vec2(o2148156_0_1_sdf3d, 0.0), o2148153_0_1_sdf3dc, p_o2148154_k);\n\nreturn (o2148154_0_1_sdf3dc).x;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o2148157(vec4 uv, float _seed_variation_) {\n    uv.xyz=rotate3d(uv.xyz-vec3(p_o2148157_TranlateX,p_o2148157_TranlateY,p_o2148157_TranlateZ),vec3(p_o2148157_RotateX,p_o2148157_RotateY,p_o2148157_RotateZ)*6.28318530718)/p_o2148157_scale;\n\tfloat sdf=o2148157_input_sdf3d(uv.xyz, _seed_variation_)*p_o2148157_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o2148157_AmbientOcclusion*o2148157_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o2148157_Alpha*o2148157_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o2148157_Normal*o2148157_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o2148157_Emission*o2148157_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o2148157_Roughness*o2148157_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o2148157_Specular*o2148157_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o2148157_Metallic*o2148157_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o2148157_BaseColor.rgb*o2148157_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const vec4 p_o2148168_BaseColor = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\nconst float p_o2148168_Metallic = 0.000000000;\nconst float p_o2148168_Specular = 0.500000000;\nconst float p_o2148168_Roughness = 0.000000000;\nconst float p_o2148168_Emission = 7.245000000;\nconst float p_o2148168_Normal = 0.000000000;\nconst float p_o2148168_Alpha = 0.000000000;\nconst float p_o2148168_AmbientOcclusion = 0.000000000;\nconst float p_o2148168_scale = 1.000000000;\nconst float p_o2148168_TranlateX = 0.000000000;\nconst float p_o2148168_TranlateY = 0.000000000;\nconst float p_o2148168_TranlateZ = 0.000000000;\nconst float p_o2148168_RotateX = 0.000000000;\nconst float p_o2148168_RotateY = 0.000000000;\nconst float p_o2148168_RotateZ = 0.000000000;\nvec3 o2148168_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o2148168_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148168_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148168_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o2148168_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o2148168_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o2148168_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148168_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o2148166_x = 0.000000000;\nconst float p_o2148166_y = 3.230000000;\nconst float p_o2148166_z = 0.000000000;\nconst float p_o2148167_sx = 0.890000000;\nconst float p_o2148167_sy = 0.050000000;\nconst float p_o2148167_sz = 0.810000000;\nconst float p_o2148167_r = 1.000000000;\nconst float p_o2148163_x = 2.950000000;\nconst float p_o2148163_y = 1.360000000;\nconst float p_o2148163_z = 1.360000000;\nconst float p_o2148165_ax = 0.000000000;\nconst float p_o2148165_ay = -39.000000000;\nconst float p_o2148165_az = 65.000000000;\nfloat o2148168_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o2148167_0_1_sdf3d = box3d(((p)-vec3(p_o2148166_x, p_o2148166_y, p_o2148166_z)), vec3(p_o2148167_sx, p_o2148167_sy, p_o2148167_sz))-p_o2148167_r;\nvec2 o2148166_0_1_sdf3dc = vec2(o2148167_0_1_sdf3d, 0.0);\nfloat o2148167_0_3_sdf3d = box3d(((rotate3d(((vec3(abs((p).x),(p).yz))-vec3(p_o2148163_x, p_o2148163_y, p_o2148163_z)), -vec3(p_o2148165_ax, p_o2148165_ay, p_o2148165_az)*0.01745329251))-vec3(p_o2148166_x, p_o2148166_y, p_o2148166_z)), vec3(p_o2148167_sx, p_o2148167_sy, p_o2148167_sz))-p_o2148167_r;\nvec2 o2148166_0_3_sdf3dc = vec2(o2148167_0_3_sdf3d, 0.0);\nvec2 o2148165_0_1_sdf3dc = o2148166_0_3_sdf3dc;\nvec2 o2148163_0_1_sdf3dc = o2148165_0_1_sdf3dc;\nfloat o2148162_0_1_sdf3d = (o2148163_0_1_sdf3dc).x;\nvec2 o2148164_0_1_sdf3dc = sdf3dc_union(o2148166_0_1_sdf3dc, vec2(o2148162_0_1_sdf3d, 0.0));\n\nreturn (o2148164_0_1_sdf3dc).x;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o2148168(vec4 uv, float _seed_variation_) {\n    uv.xyz=rotate3d(uv.xyz-vec3(p_o2148168_TranlateX,p_o2148168_TranlateY,p_o2148168_TranlateZ),vec3(p_o2148168_RotateX,p_o2148168_RotateY,p_o2148168_RotateZ)*6.28318530718)/p_o2148168_scale;\n\tfloat sdf=o2148168_input_sdf3d(uv.xyz, _seed_variation_)*p_o2148168_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o2148168_AmbientOcclusion*o2148168_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o2148168_Alpha*o2148168_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o2148168_Normal*o2148168_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o2148168_Emission*o2148168_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o2148168_Roughness*o2148168_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o2148168_Specular*o2148168_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o2148168_Metallic*o2148168_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o2148168_BaseColor.rgb*o2148168_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o2147871_input_in1(vec4 p, float _seed_variation_) {\nvec4 o2148157_0_1_v4v4 = PBRObjectMaker_o2148157((p), _seed_variation_);\nvec4 o2148168_0_1_v4v4 = PBRObjectMaker_o2148168((p), _seed_variation_);\nvec4 o2148161_0_1_v4v4 = sdf3dc1_union(o2148157_0_1_v4v4, o2148168_0_1_v4v4);\n\nreturn o2148161_0_1_v4v4;\n}\nconst float p_o2148236_edges = 0.003000000;\nconst float p_o2148236_f = 2.000000000;\nconst float p_o2148236_h = 0.000000000;\nconst float p_o2148235_scale = 0.245000000;\nconst float p_o2148235_TranslateX = 0.200000000;\nconst float p_o2148235_TranslateY = 0.660000000;\nconst float p_o2148235_TranslateZ = 0.138000000;\nconst float p_o2148235_RotateX = -7.336000000;\nconst float p_o2148235_RotateY = -87.344000000;\nconst float p_o2148235_RotateZ = -66.737000000;\nconst float p_o2148129_Correction = 0.000000000;\nconst vec4 p_o2148135_BaseColor = vec4(1.000000000, 1.000000000, 1.000000000, 1.000000000);\nconst float p_o2148135_Metallic = 0.716000000;\nconst float p_o2148135_Specular = 1.000000000;\nconst float p_o2148135_Roughness = 0.160000000;\nconst float p_o2148135_Emission = 0.000000000;\nconst float p_o2148135_scale = 4.838000000;\nconst float p_o2148135_TranlateX = -0.427000000;\nconst float p_o2148135_TranlateY = -0.035000000;\nconst float p_o2148135_TranlateZ = 0.090000000;\nconst float p_o2148135_RotateX = -81.416000000;\nconst float p_o2148135_RotateY = 175.644000000;\nconst float p_o2148135_RotateZ = 99.587000000;\nconst float p_o2148139_g_0_pos = 0.264573000;\nconst vec4 p_o2148139_g_0_col = vec4(1.000000000, 0.000000000, 0.000000000, 1.000000000);\nconst float p_o2148139_g_1_pos = 1.000000000;\nconst vec4 p_o2148139_g_1_col = vec4(1.000000000, 0.000000000, 0.750000000, 1.000000000);\nvec4 o2148139_g_gradient_fct(float x) {\n  if (x < p_o2148139_g_0_pos) {\n    return p_o2148139_g_0_col;\n  } else if (x < p_o2148139_g_1_pos) {\n    return mix(p_o2148139_g_0_col, p_o2148139_g_1_col, ((x-p_o2148139_g_0_pos)/(p_o2148139_g_1_pos-p_o2148139_g_0_pos)));\n  }\n  return p_o2148139_g_1_col;\n}\nvec3 o2148135_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec3 o2148139_0_1_tex3d = o2148139_g_gradient_fct(dot(vec3(((p)).x+0.5), vec3(1.0))/3.0).rgb;\n\nreturn o2148139_0_1_tex3d;\n}\nfloat o2148135_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148135_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148135_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o2148135_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nconst float p_o2168171_d = 0.070000000;\nconst float p_o2168163_sx = 0.460000000;\nconst float p_o2168163_sy = 0.450000000;\nconst float p_o2168163_sz = 0.370000000;\nconst float p_o2168163_r = 0.000000000;\n\n//font\nvec3 distanceToFont( in vec2 p ){\n\n    p.y=1.0-p.y;\n    p=p*iResolution.xy;\n    p.y*=1.2;\n    \n    uint b = floatBitsToUint(texelFetch(iChannel1, ivec2(p), 0).x);\n    uint x = b & 0x7fffu;\n    uint y = b >> 16;\n    uint s = b & 0x8000u;\n    \n    float d = length(p-vec2(x,y));\n    return vec3( (s==0u)?d:-d, x, y )/iResolution.x;\n}\n\n\n\nfloat o2148135_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o2168164_0 = distanceToFont(((vec2(((p).xz+vec2(0.5)).x,((p).xz+vec2(0.5)).y)) - vec2(0.0, 0.218750)) * vec2(1.0, 1.777778)).x;\nfloat o2168169_0_1_sdf2d = o2168164_0/2.0;\nvec2 o2168171_0_w = vec2(o2168169_0_1_sdf2d,abs((p).y)-p_o2168171_d);\nfloat o2168171_0_1_sdf3d = min(max(o2168171_0_w.x,o2168171_0_w.y),0.0)+length(max(o2168171_0_w,0.0));\nfloat o2168163_0_1_sdf3d = box3d((p), vec3(p_o2168163_sx, p_o2168163_sy, p_o2168163_sz))-p_o2168163_r;\nfloat o2168170_0_1_sdf3d = o2168163_0_1_sdf3d<0.1?max(o2168171_0_1_sdf3d,o2168163_0_1_sdf3d):o2168163_0_1_sdf3d;\n\nreturn o2168170_0_1_sdf3d;\n}\n\n\nvec4 PBRObjectMaker_o2148135(vec4 uv, float _seed_variation_) {\n    float mx=(iMouse.x/iResolution.x)*4.0;\n    float my=(iMouse.y/iResolution.y)*4.0;\n    uv.xyz=rotate3d(uv.xyz-vec3(p_o2148135_TranlateX,p_o2148135_TranlateY,p_o2148135_TranlateZ),vec3(p_o2148135_RotateX+mx*11.0,p_o2148135_RotateY+mx*9.0+mx*7.0,p_o2148135_RotateZ+my*8.0)*0.01745329251)/p_o2148135_scale;\n\tfloat sdf=o2148135_input_sdf3d(uv.xyz, _seed_variation_)*p_o2148135_scale;\n\t//13 - Emission\n\tif (uv.w>12.5&&uv.w<13.5) {\n\t\treturn vec4(p_o2148135_Emission*o2148135_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5&&uv.w<5.5) {\n\t\treturn vec4(p_o2148135_Roughness*clamp(o2148135_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o2148135_Specular*clamp(o2148135_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5&&uv.w<2.5) {\n\t\treturn vec4(p_o2148135_Metallic*clamp(o2148135_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o2148135_BaseColor.rgb*clamp(o2148135_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),vec3(0.0),vec3(1.0)),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o2148129_input_obj3d(vec4 p, float _seed_variation_) {\nvec4 o2148135_0_1_v4v4 = PBRObjectMaker_o2148135((p), _seed_variation_);\n\nreturn o2148135_0_1_v4v4;\n}\n\n\nconst float p_o2148127_smooth = 0.005000000;\nconst float p_o2148128_xyz = 0.822000000;\nconst float p_o2148128_x = 1.000000000;\nconst float p_o2148128_y = 1.000000000;\nconst float p_o2148128_z = 1.000000000;\nconst float p_o2148123_ax = 6.774000000;\nconst float p_o2148123_ay = -22.042000000;\nconst float p_o2148123_az = 32.464000000;\nconst float p_o2148122_x = 0.559000000;\nconst float p_o2148122_y = 1.078000000;\nconst float p_o2148122_z = 1.102000000;\n\n\n\nvec4 o2148129_input_trans3d(vec4 p, float _seed_variation_) {\nfloat mx=(iMouse.x/iResolution.x)*4.0;\nfloat my=(iMouse.y/iResolution.y)*4.0;\n\nvec4 o2148121_0_1_v4v4 = (vec4((vec4(rotate3d((vec4((vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).xyz/vec3(p_o2148128_x, p_o2148128_y, p_o2148128_z)/p_o2148128_xyz,(vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).w)).xyz, -vec3(p_o2148123_ax+sin(mx*1.1)*8.0, p_o2148123_ay+sin(mx*1.2)*8.0+sin(mx*1.5)*8.0, p_o2148123_az+sin(my*1.3)*8.0)*0.01745329251), (vec4((vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).xyz/vec3(p_o2148128_x, p_o2148128_y, p_o2148128_z)/p_o2148128_xyz,(vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).w)).w)).xyz-vec3(p_o2148122_x, p_o2148122_y, p_o2148122_z),(vec4(rotate3d((vec4((vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).xyz/vec3(p_o2148128_x, p_o2148128_y, p_o2148128_z)/p_o2148128_xyz,(vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).w)).xyz, -vec3(p_o2148123_ax, p_o2148123_ay, p_o2148123_az)*0.01745329251), (vec4((vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).xyz/vec3(p_o2148128_x, p_o2148128_y, p_o2148128_z)/p_o2148128_xyz,(vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).w)).w)).w));\nvec4 o2148122_0_1_v4v4 = o2148121_0_1_v4v4;\nvec4 o2148123_0_1_v4v4 = o2148122_0_1_v4v4;\nvec4 o_o2148128_0=o2148123_0_1_v4v4;vec4 o2148128_0_1_v4v4 = vec4(o_o2148128_0.xyz,(vec4(vec3((p).x,sqrt((p).yz*(p).yz+p_o2148127_smooth)),(p).w)).w/min(min(p_o2148128_x, p_o2148128_y), p_o2148128_z)/p_o2148128_xyz);\nvec4 o2148127_0_1_v4v4 = o2148128_0_1_v4v4;\n\nreturn o2148127_0_1_v4v4;\n}\n\nconst float p_o2148124_k = 0.07000000;\nfloat o2148129_input_custombool(vec2 uv, float _seed_variation_) {\nfloat o2148125_0_1_sdf2d = (uv).x;\nfloat o2148126_0_1_sdf2d = (uv).y;\nfloat o2148124_0_1_sdf2d = sdSmoothUnion(o2148125_0_1_sdf2d, o2148126_0_1_sdf2d, p_o2148124_k);\n\nreturn o2148124_0_1_sdf2d;\n}\n\nvec4 for_fold_o2148129(vec4 p,float mfsdftype, float _seed_variation_) {\n  for(int i=0;i<8;i++){\n    p=o2148129_input_trans3d(p, _seed_variation_);\n  }\n  vec4 o=o2148129_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  return vec4(o.xyz,o.w/p.w);\n}\n\nvec4 for_min_o2148129(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o2148129_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o2148129_input_trans3d(p, _seed_variation_);\n\td=o2148129_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\td.w=d.w/p.w;\n\tm=m.w<d.w?m:d;\n  }\n  return m;\n}\n\nvec4 for_custom_o2148129(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o2148129_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o2148129_input_trans3d(p, _seed_variation_);\n\td=o2148129_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\tfloat a=m.w;\n\tfloat b=d.w/p.w;\n\tfloat v=o2148129_input_custombool(vec2(a,b), _seed_variation_);\n    float e=0.001;\n\tvec2 n=normalize(vec2(o2148129_input_custombool(vec2(a+e,b), _seed_variation_)-o2148129_input_custombool(vec2(a-e,b), _seed_variation_),\n                          o2148129_input_custombool(vec2(a,b+e), _seed_variation_)-o2148129_input_custombool(vec2(a,b-e), _seed_variation_)));\t\t\t\t\n\tm=vec4(mix(m.xyz,d.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),v);\n  }\n  return vec4(m.xyz,m.w/(1.0+p_o2148129_Correction));\n}\nvec4 o2148236_input_mfsdfa(vec4 p, float _seed_variation_) {\nvec4 o2148129_0_1_v4v4 = for_custom_o2148129(vec4((vec4(rotate3d((p).xyz-vec3(p_o2148235_TranslateX,p_o2148235_TranslateY,p_o2148235_TranslateZ),vec3(p_o2148235_RotateX,p_o2148235_RotateY,p_o2148235_RotateZ)*0.01745329251)/p_o2148235_scale, (p).w)).xyz,1.0),(vec4(rotate3d((p).xyz-vec3(p_o2148235_TranslateX,p_o2148235_TranslateY,p_o2148235_TranslateZ),vec3(p_o2148235_RotateX,p_o2148235_RotateY,p_o2148235_RotateZ)*0.01745329251)/p_o2148235_scale, (p).w)).w, _seed_variation_);\nvec4 o_o2148235_0=o2148129_0_1_v4v4;\n\nvec4 o2148235_0_1_v4v4 = vec4(o_o2148235_0.xyz,o_o2148235_0.w*p_o2148235_scale);\n\nreturn o2148235_0_1_v4v4;\n}\nconst vec4 p_o2148240_BaseColor = vec4(1.000000000, 0.632812023, 0.000000000, 1.000000000);\nconst float p_o2148240_Metallic = 0.000000000;\nconst float p_o2148240_Specular = 1.000000000;\nconst float p_o2148240_Roughness = 0.000000000;\nconst float p_o2148240_Emission = 0.000000000;\nconst float p_o2148240_scale = 1.000000000;\nconst float p_o2148240_TranlateX = 0.000000000;\nconst float p_o2148240_TranlateY = 0.000000000;\nconst float p_o2148240_TranlateZ = 0.000000000;\nconst float p_o2148240_RotateX = 0.000000000;\nconst float p_o2148240_RotateY = 0.000000000;\nconst float p_o2148240_RotateZ = 0.000000000;\nvec3 o2148240_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o2148240_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148240_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2148240_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o2148240_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o2148240_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\nvec4 PBRObjectMaker_o2148240(vec4 uv, float _seed_variation_) {\n    uv.xyz=rotate3d(uv.xyz-vec3(p_o2148240_TranlateX,p_o2148240_TranlateY,p_o2148240_TranlateZ),vec3(p_o2148240_RotateX,p_o2148240_RotateY,p_o2148240_RotateZ)*0.01745329251)/p_o2148240_scale;\n\tfloat sdf=o2148240_input_sdf3d(uv.xyz, _seed_variation_)*p_o2148240_scale;\n\t//13 - Emission\n\tif (uv.w>12.5&&uv.w<13.5) {\n\t\treturn vec4(p_o2148240_Emission*o2148240_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5&&uv.w<5.5) {\n\t\treturn vec4(p_o2148240_Roughness*clamp(o2148240_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o2148240_Specular*clamp(o2148240_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5&&uv.w<2.5) {\n\t\treturn vec4(p_o2148240_Metallic*clamp(o2148240_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,1.0),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(p_o2148240_BaseColor.rgb*clamp(o2148240_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),vec3(0.0),vec3(1.0)),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o2148236_input_mfsdfb(vec4 p, float _seed_variation_) {\nvec4 o2148240_0_1_v4v4 = PBRObjectMaker_o2148240((p), _seed_variation_);\n\nreturn o2148240_0_1_v4v4;\n}\nfloat blursdf3d_o2148236(in vec3 p,in float b,float f, float _seed_variation_) {\n\tfloat a=0.0;\n\tfloat d=o2148236_input_mfsdfa(vec4(p,0.0), _seed_variation_).w;\n\tif (d<b*f){\n\t\tfor(int i=0;i<13;i++){\n\t        float y=1.0-2.0*(float(i)/float(13));\n\t        float r=sqrt(1.0-y*y);\n\t        float t=2.39996322973*float(i);\n\t\t\ta+=o2148236_input_mfsdfa(vec4(p+vec3(cos(t)*r,y,sin(t)*r)*b,0.0), _seed_variation_).w;\n\t\t}\n\t} else{\n\t\treturn d;\n\t}\n\treturn a/13.0;\n}vec4 o2147871_input_in2(vec4 p, float _seed_variation_) {\nfloat o2148236_0_sdfa=o2148236_input_mfsdfa(vec4((p).xyz,0.0), _seed_variation_).w;\nfloat o2148236_0_sdfb=blursdf3d_o2148236((p).xyz,p_o2148236_edges,1.01, _seed_variation_);\nfloat o2148236_0_sdfdiff=o2148236_0_sdfb-o2148236_0_sdfa+p_o2148236_h*0.1;\nvec4 o2148236_0_tex=vec4(mix(o2148236_input_mfsdfa((p), _seed_variation_).xyz,o2148236_input_mfsdfb((p), _seed_variation_).xyz,clamp(abs(o2148236_0_sdfdiff)*p_o2148236_f*100.0,0.0,1.0)),o2148236_0_sdfa);\n\nvec4 o2148236_0_1_v4v4 = o2148236_0_tex;\n\nreturn o2148236_0_1_v4v4;\n}\nvec4 o2147871_input_in3(vec4 p, float _seed_variation_) {\n\nreturn vec4(0.0,0.0,0.0,9999999.0);\n}\nvec4 o2147865_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o2147871_0_t = vec4(0.0,0.0,0.0,999999.0);\nvec4 o2147871_0_n;\n\n\no2147871_0_n=o2147871_input_in1((p), _seed_variation_);\nif (o2147871_0_n.w<o2147871_0_t.w){\no2147871_0_t=o2147871_0_n;\n}\n\no2147871_0_n=o2147871_input_in2((p), _seed_variation_);\nif (o2147871_0_n.w<o2147871_0_t.w){\no2147871_0_t=o2147871_0_n;\n}\n\no2147871_0_n=o2147871_input_in3((p), _seed_variation_);\nif (o2147871_0_n.w<o2147871_0_t.w){\no2147871_0_t=o2147871_0_n;\n}\nvec4 o2147871_0_1_v4v4 = o2147871_0_t;\n\nreturn o2147871_0_1_v4v4;\n}\n\n//tetrahedron normal by PauloFalcao\nvec3 normal_o2147865(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o2147865_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o2147865_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o2147865_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o2147865_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch_o2147865(in vec3 o,in vec3 v,out vec3 p,inout float d, float _seed_variation_) {\n  float s;\n  for(int i=0;i<128;i++){\n    p=o+v*d;\n    s=o2147865_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n    if (abs(s)<0.0001) break;\n    d+=s;\n    if (d>p_o2147865_MaxDistance) break;\n  } \n}\n\nvec3 pathtracing_o2147865(vec2 uv, uint rngState) {\n    float _seed_variation_=0.0;\n\n\tvec3 o=vec3(p_o2147865_CamX,p_o2147865_CamY,p_o2147865_CamZ)*p_o2147865_CamZoom; \n    vec3 t=vec3(p_o2147865_LookAtX,p_o2147865_LookAtY,p_o2147865_LookAtZ);\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(cx,c));\n\n\n    vec3 v=normalize(c*p_o2147865_CamD+cx*uv.x+cy*uv.y);\n\n    vec3 p;\n    float d=0.01;\n    vec3 rgb=vec3(1.0);\n    vec3 io=o;\n    int i;\n\n    for(i=0;i<3;i++){\n\n        raymarch_o2147865(io,v,p,d, _seed_variation_);\n\n        vec3 n=normal_o2147865(p, _seed_variation_);\n\n        //View direction to tangent space\n        vec3 ot;vec3 ob;pathtracing_Onb(n,ot,ob);\n        vec3 vt=vec3(dot(-v,ot),dot(-v,ob),dot(-v,n));\n\n        if (d<p_o2147865_MaxDistance){\t\n        //if (length(p-o)<p_o2147865_MaxDistance){\n        vec3 obj_Emission=o2147865_input_mfsdf(vec4(p,13.0), _seed_variation_).rgb;\n\n        if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n            rgb=obj_Emission*rgb;\n            break;\n        } else {\n            float s=RandomFloat01(rngState);\n\n            vec3 obj_BaseColor=o2147865_input_mfsdf(vec4(p,1.0), _seed_variation_).rgb; // 1 - BaseColor  (r,g,b,sdf)\n            float obj_Metallic=clamp(o2147865_input_mfsdf(vec4(p,2.0), _seed_variation_).x,0.0,1.0);   // 2 - Metallic   (v,0,0,sdf)\n            float obj_Specular=clamp(max(o2147865_input_mfsdf(vec4(p,4.0), _seed_variation_).x,obj_Metallic),0.0,1.0);   // 4 - Specular   (v,0,0,sdf)\n            float obj_Roughness=o2147865_input_mfsdf(vec4(p,5.0), _seed_variation_).x;  // 5 - Roughness  (v,0,0,sdf)\n\n            if (s>obj_Specular*obj_Specular*0.5){\n                rgb=(obj_BaseColor-obj_BaseColor*obj_Metallic)*rgb;\n                v=pathtracing_cosineSampleHemissphere(rngState,n);\n            } else {\n\n                float r2=obj_Roughness*obj_Roughness*0.5;\n                vec3 vndf=pathtracing_SampleGGXVNDF(rngState,vt,r2,r2);\n                vec3 nv=reflect(-vt,vndf);\n\n                //Sample direction back to camera space\n                nv=nv.x*ot+nv.y*ob+nv.z*n;\n\n                float FH=pathtracing_schlickWeight(dot(n,nv));\n                vec3 Cspec0=mix(vec3(obj_Specular*0.25),obj_BaseColor,obj_Metallic);\n                vec3 Fs=mix(Cspec0,vec3(1.0),FH);\n                rgb=Fs*rgb;\n\n                v=nv;\n            }\n            io=p;\n            d=0.01;\n        }\n        } else {\n            rgb=vec3(0.0);\n            break;\n        }\n    }//for(int i\n    if (i==3) rgb=vec3(0.0);//did not hit any light source\n\n    return rgb;\n\t\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\n    int frame = iFrame & 255;\n    if (frame<16) discard;\n    // Initialize random number generator state\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + \n                         uint(fragCoord.y) * uint(9277) + \n                         uint(iFrame) * uint(26699)) | uint(1);\n\n    // Calculate jittered pixel coordinates\n    vec2 xy = fragCoord + vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n\n    // Calculate UV coordinates\n    vec2 UV=(xy-iResolution.xy/2.0)/iResolution.y;\n    UV.y=-UV.y;\n\n    // Perform path tracing\n\n    vec3 rgb = pathtracing_o2147865(UV,rngState);\n\n    // Set fragment color based on mouse input\n    if (iMouse.z < 0.1) {\n        // Accumulate new sample with previous frame\n        fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy) + vec4(rgb, 1));\n    } else {\n        // Use only the current sample\n        fragColor = vec4(rgb, 1);\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}