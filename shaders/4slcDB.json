{
    "Shader": {
        "info": {
            "date": "1489702294",
            "description": "Combines a fir tree shader with a voronoi shader to take you on a helicopter ride with the forestry service over an endless lush northern type forest. Future work: add some hills, lakes, maybe roads.",
            "flags": 0,
            "hasliked": 0,
            "id": "4slcDB",
            "likes": 25,
            "name": "Land of Green Gold",
            "published": 3,
            "tags": [
                "voronoi",
                "tree",
                "forest",
                "fir"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 1513
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////\n// Land of Green Gold by Timo Kinnunen 2017\n//\n// Based on Fur Trees by eiffie\n// @ https://www.shadertoy.com/view/lts3zr\n//\n// Based on Faster Voronoi Edge Distance by tomkh\n// @ https://www.shadertoy.com/view/llG3zy\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define NO_DEBUG\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016\n\n// Based on https://www.shadertoy.com/view/ldl3W8 by Inigo Quilez\n// And his article: https://iquilezles.org/articles/voronoilines\n\n// This is based on Inigo Quilez's distance to egdes,\n// except I consider here faster variants:\n// * 3x3 scan at the cost of small inaccuracies\n// * 4x4 scan in the second pass that has no accuracy-loss to IQ's version\n// * 4x4 in both passes that is more accurate than original IQ's version\n//   (and still has less iterations 32=4*4*2 vs 34=3*3+5*5)\n\n// Original IQ's algorithm is flawed (mathematically incorrect)\n// i.e. for all possible hash functions, as in this counter-example:\n// https://www.shadertoy.com/view/4lKGRG\n\n// Basically in the original IQ's implementation,\n// he was storing closest cell \"mg\" in the first pass\n// and using it for the second pass.\n// If we want 3x3 scan in the second pass it is enough to continue search\n// from the same (current fragment) cell and limit search space\n// to only neighbouring cells (thus \"mg\" can be ignored).\n// In fact, searching around \"mg\" makes it worse (see my illustration below).\n// For 4x4 variant we have to set the center of search \n// based on which half of the current fragment cell we are in.\n// Note: \n//   The second pass scan area has nothing to do with the position\n//   of the closest point.\n//   Here is an illustration of my improved algorithm:\n//   http://ricedit.com/second_order_voronoi_03.png\n\n// Pick approximation level:\n//   0 = 3x3 scan for both passes (occasional issues, but the fastest)\n//   1 = 3x3 + 4x4 scan (good in most cases, if every cell has diameter < 1)\n//   2 = 4x4 scan for both passes (improved accuracy)\n//   3 = 3x3 + 5x5 scan (original IQ's)\n#define SECOND_PASS 0\n\n//#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\n// How freely are cell centers placed (must be <= 1.)\n#define PLACE_D .875\n\nvec2 hash2(vec2 p)\n{\n    #if 1\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = PLACE_D*(fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y))-.5)+.5;\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n}\nstruct VoronoiData {\n    float md;\n    vec2 mr;\n    vec2 mi;\n};\n#if SECOND_PASS == 0\n//---------------------------------------------------------------\n// Fastest version with 3x3 scan in the second pass\n//---------------------------------------------------------------\nVoronoiData voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mi = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) {// skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n        }\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n\n#elif SECOND_PASS == 1\n//---------------------------------------------------------------\n// Approximation with 4x4 scan in the second pass\n// Good enough in most cases\n//---------------------------------------------------------------\n\nVoronoiData voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mi = n + g;\n        }\n    }\n    \n    // Set center of search based on which half of the cell we are in,\n    // since 4x4 is not centered around \"n\".\n    vec2 mg = step(.5,f) - 1.;\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits two neighbours to the right/down\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=2; j++ )\n    for( int i=-1; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n#elif SECOND_PASS == 2\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n\nVoronoiData voronoi( in vec2 x )\n{\n#if 1\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n#else\n    vec2 n = floor(x - 1.5);\n    vec2 f = x - n;\n#endif\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mi = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n#else\n//---------------------------------------------------------------\n// Slowest with 5x5 scan in the second pass\n// Original Implementation by Inigo Quilez \n// as in https://www.shadertoy.com/view/ldl3W8\n//---------------------------------------------------------------\n\nVoronoiData voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    vec2 mi;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            mi = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return VoronoiData( md, mr, mi );\n}\n\n//---------------------------------------------------------------\n#endif\n\nvec3 plot( vec2 p, float ss )\n{\n    VoronoiData c = voronoi( p );\n    \n    // Colors:\n    vec3 interior = vec3(.3,.2,.2);\n    vec3 border = vec3(.5,.6,0);\n    vec3 point = vec3(.025,.025,.0125);\n    \n    float d = length(c.mr);\n    vec3 col =\n        mix(\n            mix(\n                interior*(.63-1.1*c.md),\n                border*.2+.25*c.md,\n                smoothstep(.22,.04,c.md)\n            ),\n            point,\n            smoothstep(.427,.05,d)\n        );\n    \n    return col;\n}\n\nvoid mainImage00( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n\n\n\n\n//attempting some distance estimated fur and shading with one extra DE calc\n#define AUTO_OVERSTEP\n\n#define time iTime\n#define size iResolution\n\n#define TAO 6.283\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvec2 kaleido(vec2 v, float power){return rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\nvec2 kaleido6(vec2 v){return rotate(v,floor(0.5+atan(v.x,-v.y)*0.95493)*1.0472);}\nvec2 kaleido12(vec2 v){return rotate(v,floor(0.5+atan(v.x,-v.y)*1.90986)*0.5236);}\nfloat rndStart(vec2 co){return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nvec3 mcol;//material color\nmat2 r45=mat2(0.7071,0.7071,-0.7071,0.7071);\nmat2 r30=mat2(0.866,0.5,-0.5,0.866);\nmat2 rtrn=mat2(0.9689,-0.2474,0.2474,0.9689);\n\nVoronoiData theVoro;\nfloat DE(in vec3 z0){\n    VoronoiData voro = voronoi( z0.xz );\n    theVoro = voro;\n    vec2 id = voro.mi;\n    z0.xz = voro.mr;\n\n\tfloat cyl=length(z0.xz);\n\tfloat d=100.0,dt=cyl+z0.y*0.025;\n    \n\tfor(int i=0;i<2;i++){\n\t\tvec3 z=z0;\n        z.xz=rotate(z.xz,id.x*2.+id.y*3.+float(i*2));\n\t\tz.y+=float(i)*(0.125+.0625*mod(id.x-id.y,2.0));\n\t\tfloat c=floor(z.y*4.0);\n\t\t//z.yz=rotate(z.yz,-z.z*0.79*(1.0+c*0.1));\n\t\tfloat bm=-z.y-2.0+cyl*0.01;\n\t\tz.y=mod(z.y,0.25)-0.05;\n\t\tif(i<=1)z.xz=z.xz*rtrn*float(i+i-1);\n\t\tz.xz=kaleido(z.xz,2.0-c);\n\t\tz.yz=rtrn*z.yz;\n\t\tbm=max(bm,-z.z+c*0.086);//0.065);\n\t\tdt=min(dt,max(max(abs(z.x),abs(z.y)),bm))-0.001-z.z*0.003;\n\t\tfloat c2=floor(z.z*16.0);\n\t\tz.z=mod(z.z,0.0625)-0.045;//0.049;\n\t\tz.xy=rotate(z.xy,c2*0.25);\n\t\tz.xy=kaleido12(z.xy);\n\t\tz.yz=z.yz*r30;\n\t\td=min(d,max(max(max(abs(z.x),abs(z.z)),-z.y-0.05+c*0.005),bm));\n\t}\n\tif(dt<d){\n\t\td=dt;\n\t\tmcol=vec3(0.5,0.1,0.0);\n\t}else{\n\t\tmcol=vec3(0.5,0.6,0.2);\n\t\t//mcol*=1.0+(-z0.y*0.5975)*abs(z0.x+z0.z)/cyl;\n\t}\n    mcol*=cyl + 0.5 + z0.y*0.5;//kind of what iq suggested\n\n\treturn max(0.0,max(d,max(z0.y,-z0.y-2.0)));\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat fog(float t){return exp(-t*0.02);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat zoom=2.0;\n    float px=2.0/(size.y*zoom);//find the pixel size\n    float ipx = 1.0/px;\n\tfloat tim=time;\n\n    #ifndef NO_DEBUG\n    float mark0 = fragCoord.x-iResolution.x*.5;\n    float mark1 = abs(mark0)-iResolution.x*.1875;\n    float mark2 = mark1-iResolution.x*.0625;\n    float mark3 = mark1-iResolution.x*.1250;\n    float mark4 = mark1-iResolution.x*.1875;\n    float mark5 = mark1-iResolution.x*.2500;\n\ttim += mark0>0.?30.:0.;\n    #endif\n\n    tim *= 0.3;\n\t//position camera\n\tvec3 ro=vec3(0.5*sin(tim*0.43),18.*(sin(tim*.4)+.975),tim*20.);\n\tvec3 rd=normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,zoom));\n\trd=lookat(vec3(-1.15*4.+8.*0.75*sin(tim),1.-1.5*sin(tim*.02),tim*20.+2.0)-ro,vec3(0.0,1.0,0.0))*rd;\n\t//ro=eye;rd=normalize(dir);\n\tvec3 ld=normalize(vec3(-0.4,0.75,-0.4));//direction to light\n\tvec3 bcol=1.0-clamp(vec3(rd.y,rd.y+0.1*exp(-abs(rd.y*15.0)),0.5*exp(-abs(rd.y*5.0))),0.,1.);//backcolor\n\t//march\n    \n\tfragColor=vec4(0,0,0,1);\n    \n\tfloat tG=abs((-2.0-ro.y)/rd.y);\n    float d;\n    float pd=10.0;\n    float os=0.0;\n    float steps=0.0;\n\tvec2 g=ro.xz+rd.xz*tG;\n    float noise = rndStart(fragCoord.xy);\n    const float rndBands = 1.;\n\tfloat t=floor(rndBands*DE(ro)*noise+.5)/rndBands;\n\tfloat MIN_DIST=px*0.1;\n    vec3 pos;\n\tvec4 col=vec4(0.0);//color accumulator\n\tfor(int i=0;i<78;i++){\n        pos = ro+rd*t;\n\t\td=DE(pos);\n\t\tfloat d1=max(d,px*t*0.5);\n#ifdef AUTO_OVERSTEP\n\t\tif(d1>os){\t\t//we have NOT stepped over anything\n\t\t\tif(t>tG)break;\n\t\t\tos=0.28*d1*d1/pd;//calc overstep based on ratio of this step to last\n\t\t\tsteps=d1+os;\t//add in the overstep\n\t\t\tpd=d1;\t//save this step length for next calc\n\t\t}else{\n\t\t\tsteps=-os;d1=1.0;pd=10.0;os=0.0;//remove ALL of overstep\n\t\t}\n#else\n\t\t\tsteps=d1;\n#endif\n\t\tif(d1<px*t){\n\t\t\tvec3 scol=mix(mcol,bcol,clamp(min(t*0.05,1.0),0.,1.));\n\t\t\tfloat d2=DE(pos+ld*px*t);\n\t\t\tfloat shad=1.4-0.5*clamp((d2/d)+1.,0.,10.);\n\t\t\tscol=scol*shad+vec3(0.02,0.05, -0.125)*(shad+1.5);\n            vec2 q = mod(pos.xz,2.0)-vec2(1.0);\n            scol *= clamp(length(q) + 0.8 + pos.y*0.5,0.,1.);\n\t\t\tfloat alpha=(1.0-col.w)*clamp(1.0-d1/(px*t),0.,1.);\n            //alpha=1.;\n\t\t\tcol+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n\t\t\tif(col.w>0.99)break;\n\t\t}\n\t\tt+=steps;\n\t}\n    \n\n    float treeMask = col.a;\n    float horizon = .5+.5*cos(radians(clamp(rd.y*12.*180.,-180.,180.)));\n    float attenFar = clamp(log(max(1.0,(1./30.)*mix(t,t-25.,horizon)))*2.5,0.,1.);//smoothstep(50.0,75.0,t);\n    float distantFog = (1.0-0.292*attenFar);\n    float onlyFog = fog(abs(t));\n    float fogNear=1.92-.325*col.w-col.w*onlyFog;\n    float farFog = 1.0-fogNear;\n    float treeMaskFar = 1.0-treeMask*clamp(fogNear*10.,0.,1.);\n    float horizonFog = pow(horizon*.99,16.)*treeMaskFar;\n    float groundCover = fogNear*(1.0-col.a)*distantFog;\n    vec4 groundCol = vec4(0,0,0,clamp(-64.0*rd.y,0.,1.));\n\t//color the ground \n\tif(groundCol.a>0.0){\n        vec3 gcol = plot(g,px);\n\t\tro+=rd*tG;\n\t\tfloat s=1.0,dst=0.1;\n\t\tt=DE(ro)*rndStart(fragCoord.xy);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfloat d=max(0.0,DE(ro+ld*t)*1.5)+0.05;\n\t\t\ts=min(s,3.0*d/t);\n\t\t\tt+=dst;\n            dst*=2.0;\n\t\t}\n\t\tgcol*=0.2+0.8*s;\n        //col.rgb+=clamp(gcol*fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n        //col.a+=(1.0-col.a)*clamp(fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n        groundCol.rgb+= clamp(gcol*groundCover,0.,1.);\n        groundCol.a+=(1.0-col.a)*clamp(groundCover,0.,1.);\n        //groundCol.rgb = clamp(gcol*fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n    }\n    float groundMask = (1.-col.a);\n    col+=groundCol*groundMask;\n    float skyMask = (1.-col.a);\n    //col.a+=(1.0-col.a)*clamp(fogNear*(1.0-col.a)*(1.0-0.292*attenFar),0.,1.);\n    col.rgb += clamp(bcol*skyMask,0.,1.);\n    //col.rgb = mix(col.rgb,bcol,attenFar);\n    //col.rgb = mix(col.rgb,bcol,attenFar*(1.0-col.a));\n    col.rgb = mix(col.rgb,bcol,horizonFog);\n    col.rgb += bcol*horizon*.5;\n    //col.rgb = mix(col.rgb,bcol,attenFar*(1.0-col.a)*(1.0-horizonFog)+horizonFog);\n    float noSkyMask = clamp(1.-onlyFog,0.,1.);\n    float groundedFog = clamp((fogNear-.8)*(treeMask+horizon*.5)*1.75,0.,1.)*.25;\n    col.rgb += bcol*(groundedFog);\n    \n\tfragColor=vec4(col.rgb,1.0);\n    #ifndef NO_DEBUG\n  \tfragColor.rgb=mark1>0.?vec3(0,0,1)*vec3(groundCover,groundMask,treeMaskFar):fragColor.rgb;\n  \tfragColor.rgb=mark2>0.?vec3(1,1,1)*vec3(attenFar,distantFog,farFog):fragColor.rgb;\n  \tfragColor.rgb=mark3>0.?vec3(0,1,0)*vec3(onlyFog,fogNear,treeMask):fragColor.rgb;\n  \tfragColor.rgb=mark4>0.?vec3(1,1,1)*vec3(horizon,horizonFog,skyMask):fragColor.rgb;\n  \tfragColor.rgb=mark5>0.?vec3(0,1,0)*vec3(noSkyMask,groundedFog,skyMask):fragColor.rgb;\n    #endif\n\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}