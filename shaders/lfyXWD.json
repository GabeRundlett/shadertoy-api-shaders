{
    "Shader": {
        "info": {
            "date": "1715177677",
            "description": "This is my first audio visualizer using the iChannel's input.\n\nPlease is someone knows how to make the start and end points of the edges waveform blend together, let me know! That would be awesome.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfyXWD",
            "likes": 1,
            "name": "Audio Visualizer Version Circle",
            "published": 3,
            "tags": [
                "circle",
                "audio",
                "visualizer",
                "hsv2rgb",
                "shaping"
            ],
            "usePreview": 0,
            "username": "spenceryonce",
            "viewed": 113
        },
        "renderpass": [
            {
                "code": "#define t iTime\n#define res iResolution.xy\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    float dist = length(uv); // Distance from center\n    float angle = atan(uv.y, uv.x); // Angle for waveform modulation\n\n    // Ensure angle wraps smoothly for UV mapping\n    float normalizedAngle = 0.5 + angle / (2.0 * 3.14159); // Mapping from -PI to PI to 0 to 1\n\n    vec2 waveUV = vec2(normalizedAngle, 0.0); // Bottom layer of the texture for waveform\n    float waveSample = texture(iChannel0, waveUV).r; // Getting the red channel\n\n    // Base radius and dynamic modulation for the edge\n    float baseRadius = 0.2 + 0.06 * sin(t); // Modulate base radius over time\n    float modulatedRadius = baseRadius + 0.2 * waveSample; // Modulation based on waveform sample\n\n    // Sampling the frequency data (top layer) for inside visuals\n    vec2 freqUV = vec2(normalizedAngle, 1.0); // Top layer of the texture for frequency\n    float freqSample = texture(iChannel0, freqUV).r; // Frequency data\n\n    // Convert frequency to a hue in the HSV color model\n    float hue = freqSample * 1.4; // Using full hue spectrum\n\n    // Convert HSV to RGB\n    vec3 color = hsv2rgb(vec3(hue, 1.0, 0.7)); // Saturated and bright colors\n\n    // Shaping functions inside the circle with smoothed color transitions\n    if (dist < modulatedRadius) {\n        float x = sin(dist * 20.0 - t * 5.0);\n        float y = cos(dist * 20.0 - t * 5.0);\n        vec3 smoothColor = (color + hsv2rgb(vec3(mod(hue + 10.0, 360.0), 1.0, 0.7)) + hsv2rgb(vec3(mod(hue - 10.0, 360.0), 1.0, 0.7))) / 3.0;\n        fragColor = vec4(smoothColor * 0.5 * (x + y + 2.0), 1.0);\n    } else if (abs(dist - modulatedRadius) < 0.005) {\n        fragColor = vec4(color, 1.0); // Edge of the circle\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}