{
    "Shader": {
        "info": {
            "date": "1555574014",
            "description": "some RequestForComments on compartibility\n\nfunctions known to be glES300 exclusive, trying to port to older versions:",
            "flags": 0,
            "hasliked": 0,
            "id": "3lf3z8",
            "likes": 5,
            "name": "__VERSION__ compatibility3",
            "published": 3,
            "tags": [
                "round",
                "modulo",
                "inverse",
                "trigonometry",
                "bitwise",
                "mobile",
                "tablet",
                "compatibility",
                "determinant",
                "cosh",
                "tanh",
                "version",
                "sinh",
                "trunc"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 523
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/3lf3z8\n\n//round,modulo,inverse,trigonometry,bitwise,determinant,cosh,tanh,version,compatibility,sinh,trunc,mobile,tablet\n\n//this shader triesto emulate webgl2 in webgl1\n//this has many shortcomings and issues.\n\n\n//i do not dare to test bitwise operands for now.\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 r=iResolution\n #if (__VERSION__ >=300)\n  ;int oo=4%6                 //es300 only, workarounds are tricky\n  ;float aa=intBitsToFloat(1) //es300 only, workarounds are tricky\n #endif\n ;bvec4 bb=bvec4(true,false,false,true)//es100\n ;vec4 m=iMouse\n ;o=moWebgl2test(iTime,u,iResolution,iMouse)*.5 //compatible integer modulo test\n ;u=fra(u)\n ;m.xy=fra(m.xy)\n ;float c=length(u-m.xy)\n ;vec2 d=vec2(round(u.x),trunc(u.x))\n ;d.x=length(vec2(d.x,u.y)-m.xy)\n ;d.y=length(vec2(d.y,u.y)-m.xy)\n ;float a=1./Aa\n ;c=1.-(a,-a,abs(c))\n ;d=1.-(a,-a,abs(d))\n ;o.xyz=max(o.xyz,vec3(c,d))\n ;o.xyz=max(o.xyz,testEs300trig(u,r))\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//[compatible v3]  //https://www.shadertoy.com/view/3lf3z8\n//proposed namespaces to make webgl2 code more backwards compatible to Webgl.\n//webGL_es300 emulation in webgl_es100 (is found from line 130 till line 200)\n//mpodulo-emulation workarounds follof after line 200.\n\n//turns out shadertoy does emulate a lot of gles300 in gles100\n//, but some things are arbitiarily skipped\n//determinant() transpose() and inverse() for some matrices is commented out\n//and SOME the trigonometry is missing here\n//, because its rarely needed and a LOT of code to parse.\n\n//pre-defined common canvas:\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define i0 int\n#define i1 ivec2\n#define i2 ivec3\n#define i3 ivec4\n#define vec1 float\n#define ivec1 int\n#define turm v0 t,v1 u,v2 r,v3 m //for prototypes and audiovisual fm synthesis (time,uv,resolution.xyz,mouse)\n\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//goldenRatio=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//phi = https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n\n//2d zoom\n#define viewZoom 5.\n#define fra(u)((u-.5*r.xy)*viewZoom/r.y)\n//divide by /Aa for hairline drawing and sharp smoothstep()\n#define Aa (min(r.x,r.y)/viewZoom)\n\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 ad(vec4 a){return dot(vec4(1),a);}vec1 ad(vec3 a){return dot(vec3(1),a);}vec1 ad(vec2 a){return a.x+a.y;}v0 ad(v0 a){return a;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//---monadic inequality bounds:\n#define BoundOr(a,b,c) (abs(b-.5*a)*2. c a)\n#define BoundAnd(a,b,c) (a c abs(b-.5*a)*2. ) \n//has usecase examples:\n//(0.<a&&a<b) === boundAnd(a,b,<) === boundOr (a,b,>=) === (0.>=a||a>=b)\n//(0.>a||a>b) === boundOr (a,b,>) === boundAnd(a,b,<=) === (0.<=a&&a<=b)\n//\n//above is useful to measure 2x as many bounds at once (culling context frame\n\n//below is useful to mix multiple cases (branchlessing)\n//side note, this is always worse than using branches, BUT STILL it sometimes helps you to find other ways to make an expression\n//, or to sort long branches differently\n//\n//unifying these 2 can be tricky.\n//\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//see: https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n////#define equalsA(a,b,c) mix(b,a,(sign(c)+sign(-c))*.5)//here you can NOT substitute sign(-c) for=sign(c),because that implies a [signed null]!\n//----------- mirror symmetry mirror==swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less  ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\nvec1 mx(vec1 a,vec1 b,vec1 c){return mix(a,vec1(b),c);}\nvec2 mx(vec2 a,vec1 b,vec2 c){return mix(a,vec2(b),c);}\nvec3 mx(vec3 a,vec1 b,vec3 c){return mix(a,vec3(b),c);}\nvec4 mx(vec4 a,vec1 b,vec4 c){return mix(a,vec4(b),c);}\n\n//---- worksafing\n//address space is limited, some asymptotic cases are undefined\n//they may have inconsistent outcomes (NaN handling) crash on runtime or cause fatal compiler error\n//  a/0.\n//sqrt(-1.)  == pow(-1.,.5)\n//log(0.)   log2(0.)\n//log(-1.)  log2(-1.)\n//pow(0.,0.)\n//mod(a,63.)\n//(-1%-2)     //integer modulo with negative inputs is a hot mess.\n#define zFar 16777216.\n//pow(2.,24)=16777216. is asserted to be a worksafe range, where type [32bit float] still maps to type [int]\n//BUT this ignores NaN and inf, and sign bit complements\n//nonetheless, if you want compatibility, that is, some bitwise operants in webglES100\n//main utility is a zBuffer, that QUICKLY gets compressed to 24 bit integer range.\n//16777216. is a significant limit (or half of that value)\n//replace all division with a wrapper, that optionally can be made worksafe\nv0 wdi(v0 a,v0 b){if(b==0.)return 0.;return a/b;}//type float of type independent worksave division\nv1 wdi(v1 a,v1 b){return a/b;}//actually not too sure how to best define this\nv2 wdi(v2 a,v2 b){return a/b;}//actually not too sure how to best define this\nv3 wdi(v3 a,v3 b){return a/b;}//actually not too sure how to best define this\ni0 wdi(i0 a,i0 b){if(b==0 )return 0 ;return a/b;}//type int   of type independent worksave division\ni1 wdi(i1 a,i1 b){return a/b;}//actually not too sure how to best define this\ni2 wdi(i2 a,i2 b){return a/b;}//actually not too sure how to best define this\ni3 wdi(i3 a,i3 b){return a/b;}//actually not too sure how to best define this\n//i sure can not mix(step()) the above\nmat2 wdi(mat2 a,mat2 b){return a/b;}\nmat2 wdi(mat2 a,vec1 b){return a/b;}\nmat3 wdi(mat3 a,mat3 b){return a/b;}\nmat3 wdi(mat3 a,vec1 b){return a/b;}\nmat4 wdi(mat4 a,mat4 b){return a/b;}\nmat4 wdi(mat4 a,vec1 b){return a/b;}\n//replace all sqrt()  with a wrapper, that optionally can be made worksafe\n#define wsq(a) sqrt(abs(a))\n//replace log() with a wrapper, that optionally can be made worksafe //is oblivious about log(0)\n#define wlo(c){return mx(log(abs(c)),zFar,step(c,0.));}\n//pow(0.,0.) is a bitch to worksafe! //todo.\n\n\n\n\n\n\n\n//WebGl runs in 2 main modes:\n//webgl , which usually means glES100, close to opengl1.0\n//webgl2, which usually means glES300, close to opengl3.0\n//__VERSION__ is runtime reserved namespace that points at a unique integer ID\n//functions known to be glES300 exclusive, trying to port to older versions:\n#if ( __VERSION__ < 300 )\n//this segment is oputdated\n//, see https://www.shadertoy.com/view/wlf3RB\n// for the most recent version (with mat3 inverse code)\n #define round(x) floor((x)+.5)\n #define trunc(x) round(abs(x))*sign(x)\n //round() and trunc() seem to be fine if trunc() is false, its likely a floor(). too.\n #define isnan(x) (!(x==x))\n //NaN is an implementation-mess anyways, \n //todo: isinf() exists in ES300, tricky to define for ES100, skipped for now\n //float isinf(float x)(return (abs(x)>=zFar);} //proposal\n #define sinh(x) (exp(x)-exp(-x))*.5\n #define cosh(x) (exp(x)+exp(-x))*.5\n #define tanh(x) ((exp(x)-exp(-x))/(exp(x)+exp(-x)))\n mat2 transpose(mat2 m){return mat2(m[0].x,m[1].x              ,m[0].y,m[1].y);}\n //mat3 transpose(mat3 m){return mat3(m[0].x,m[1].x,m[2].x       ,m[0].y,m[1].y,m[2].y       ,m[0].z,m[1].z,m[2].z);}\n //mat3 transpose(mat4 m){return mat4(m[0].x,m[1].x,m[2].x,m[3].x,m[0].y,m[1].y,m[2].y,m[3].y,m[0].z,m[1].z,m[2].z,m[3].z,m[0].w,m[1].w,m[2].w,m[3].w);}\n //above transpose() are untested\n //also, non-square-matrices have a transpose() function defined for them.\n //float determinant(mat2 m){return m[0][0]*m[1][1]-m[0][1]*m[1][0];}\n /*\n float determinant(mat3 m){\n mat2 a=mat2(m[1][1],m[1][2],m[2][1],m[2][2]) *m[0][0]\n       -mat2(m[0][1],m[0][2],m[2][1],m[2][2]) *m[1][0]\n       +mat2(m[0][1],m[0][2],m[1][1],m[1][2]) *m[2][0]\n       return determinant(a); //opengl mat is [column][row]\n :}  un tested   :  https://www.youtube.com/watch?v=eYjSu_xXUUQ\n/* \nfloat determinant(mat4 m\n ){float b00=m[0][0]*m[1][1]-m[0][1]*m[1][0],b01=m[0][0]*m[1][2]-m[0][2]*m[1][0]\n  ,b02=m[0][0]*m[1][3]-m[0][3]*m[1][0],b03=m[0][1]*m[1][2]-m[0][2]*m[1][1]\n  ,b04=m[0][1]*m[1][3]-m[0][3]*m[1][1],b05=m[0][2]*m[1][3]-m[0][3]*m[1][2]\n  ,b06=m[2][0]*m[3][1]-m[2][1]*m[3][0],b07=m[2][0]*m[3][2]-m[2][2]*m[3][0]\n  ,b08=m[2][0]*m[3][3]-m[2][3]*m[3][0],b09=m[2][1]*m[3][2]-m[2][2]*m[3][1]\n  ,b10=m[2][1]*m[3][3]-m[2][3]*m[3][1],b11=m[2][2]*m[3][3]-m[2][3]*m[3][2]\n  ;return b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;}\n/**/\n //mat2 inverse(mat2 m){return wdi(mat2(m[1][1],-m[0][1],-m[1][0],m[0][0]),determinant(m));}//mat2 det doesnt compress much\n //mat3 inerse(mat3 m) // missing function  \n/*\n mat4 inverse(mat4 m){float \n   i0 = m[1].y*m[2].z*m[3].w-m[1].y*m[2].w*m[3].z-m[2].y*m[1].z*m[3].w+m[2].y*m[1].w*m[3].z+m[3].y*m[1].z*m[2].w-m[3].y*m[1].w*m[2].z\n  ,i4 =-m[1].x*m[2].z*m[3].w+m[1].x*m[2].w*m[3].z+m[2].x*m[1].z*m[3].w-m[2].x*m[1].w*m[3].z-m[3].x*m[1].z*m[2].w+m[3].x*m[1].w*m[2].z\n  ,i8 = m[1].x*m[2].y*m[3].w-m[1].x*m[2].w*m[3].y-m[2].x*m[1].y*m[3].w+m[2].x*m[1].w*m[3].y+m[3].x*m[1].y*m[2].w-m[3].x*m[1].w*m[2].y\n  ,i12=-m[1].x*m[2].y*m[3].z+m[1].x*m[2].z*m[3].y+m[2].x*m[1].y*m[3].z-m[2].x*m[1].z*m[3].y-m[3].x*m[1].y*m[2].z+m[3].x*m[1].z*m[2].y\n  ,i1 =-m[0].y*m[2].z*m[3].w+m[0].y*m[2].w*m[3].z+m[2].y*m[0].z*m[3].w-m[2].y*m[0].w*m[3].z-m[3].y*m[0].z*m[2].w+m[3].y*m[0].w*m[2].z\n  ,i5 = m[0].x*m[2].z*m[3].w-m[0].x*m[2].w*m[3].z-m[2].x*m[0].z*m[3].w+m[2].x*m[0].w*m[3].z+m[3].x*m[0].z*m[2].w-m[3].x*m[0].w*m[2].z\n  ,i9 =-m[0].x*m[2].y*m[3].w+m[0].x*m[2].w*m[3].y+m[2].x*m[0].y*m[3].w-m[2].x*m[0].w*m[3].y-m[3].x*m[0].y*m[2].w+m[3].x*m[0].w*m[2].y\n  ,i13= m[0].x*m[2].y*m[3].z-m[0].x*m[2].z*m[3].y-m[2].x*m[0].y*m[3].z+m[2].x*m[0].z*m[3].y+m[3].x*m[0].y*m[2].z-m[3].x*m[0].z*m[2].y\n  ,i2 = m[0].y*m[1].z*m[3].w-m[0].y*m[1].w*m[3].z-m[1].y*m[0].z*m[3].w+m[1].y*m[0].w*m[3].z+m[3].y*m[0].z*m[1].w-m[3].y*m[0].w*m[1].z\n  ,i6 =-m[0].x*m[1].z*m[3].w+m[0].x*m[1].w*m[3].z+m[1].x*m[0].z*m[3].w-m[1].x*m[0].w*m[3].z-m[3].x*m[0].z*m[1].w+m[3].x*m[0].w*m[1].z\n  ,i10= m[0].x*m[1].y*m[3].w-m[0].x*m[1].w*m[3].y-m[1].x*m[0].y*m[3].w+m[1].x*m[0].w*m[3].y+m[3].x*m[0].y*m[1].w-m[3].x*m[0].w*m[1].y\n  ,i14=-m[0].x*m[1].y*m[3].z+m[0].x*m[1].z*m[3].y+m[1].x*m[0].y*m[3].z-m[1].x*m[0].z*m[3].y-m[3].x*m[0].y*m[1].z+m[3].x*m[0].z*m[1].y\n  ,i3 =-m[0].y*m[1].z*m[2].w+m[0].y*m[1].w*m[2].z+m[1].y*m[0].z*m[2].w-m[1].y*m[0].w*m[2].z-m[2].y*m[0].z*m[1].w+m[2].y*m[0].w*m[1].z\n  ,i7 = m[0].x*m[1].z*m[2].w-m[0].x*m[1].w*m[2].z-m[1].x*m[0].z*m[2].w+m[1].x*m[0].w*m[2].z+m[2].x*m[0].z*m[1].w-m[2].x*m[0].w*m[1].z\n  ,i11=-m[0].x*m[1].y*m[2].w+m[0].x*m[1].w*m[2].y+m[1].x*m[0].y*m[2].w-m[1].x*m[0].w*m[2].y-m[2].x*m[0].y*m[1].w+m[2].x*m[0].w*m[1].y\n  ,i15= m[0].x*m[1].y*m[2].z-m[0].x*m[1].z*m[2].y-m[1].x*m[0].y*m[2].z+m[1].x*m[0].z*m[2].y+m[2].x*m[0].y*m[1].z-m[2].x*m[0].z*m[1].y\n  ;return wdi(mat4(i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15)\n  ,(m[0].x*i0+m[0].y*i4+m[0].z*i8+m[0].w*i12));}//mat3 det compresses a bit more\n/**/ \n//detemrinant() and inverse() are cc-license from pilibs boilerplate of inogoQuilez (included in shadertoy, but only as javascript for webVR)\n#endif\n\n\n\n\n\n\n\n//below trig-functions are not in es300 and not in es100\n//but threy are somewhat common complementary-trig-functions\n//wdi() is worksafing against divisions by 0.\n//wlo() is worksaviong against logarythms of values <= 0\n#define coth(x) ((exp(x)+exp(-x))/(exp(x)-exp(-x)))\n//sech() is not defined for glES300, so its the same mess in all versions.\n#define sech(x) wdi(1.,cosh(x))\n#define atanh(x) .5*log(wdi(1.+x,1.-x))\n#define asinh(x) wlo(x+wsq(x*x+1.))\n#define asech(x) wlo((1.+wsq(1.-x*x))/x)\n#define acoth(x) .5*wlo((x+1.)/(x-1.))\n#define acosh(x) wlo(x+wsq(x*x-1.))\n#define acsch(x) wlo((1.+wsq(1.+x*x))/x)\n\nvec3 testEs300trig(vec2 u,vec3 r\n){vec4 c=vec4(sinh(u.x),cosh(u.x),tanh(u.x),coth(u.x)\n )-u.y\n ;float a=1./Aa\n ;c=smoothstep(a,-a,abs(c)-a)\n ;c.xy+=c.w\n ;return c.xyz;}\n\n\n//---- a much better modulo:\n\n\n\n//i found WAY too many shortcomings in the default mod() of ALL webgl versions\n//integer modulo is bad for negative inputs, just way too mabiguous\n//float modulo has significant precision issues, that are ambiguous for mod(a,63.)\n//for the sake of compatibility, this defines explicit bitwise and modulo operands:\n\nint   imod(int   a, int   b){return a-(      wdi(a,b) *b);}//explicit integer modulo \nfloat fmod(float a, float b){return a-(floor(wdi(a,b))*b);}//explicit float  modulo \n//above 2 definitions are a decent start, but not a perfect fit to [%] or mod() for very small or negative inputs.\n//logically     a%b = a-(a/b)*b\n//realistically a%b with negative [a] or negative [b] are literally unpredictable\n//because they are not strictly defined by opengl (there are 4 amboiguous cases)\n//this is already solved in more detail in another shader.\n\n//below goes into more detail and proposes a mo() function;\n//- that is very identical modulo in any environment\n//  to a point where it should make no difference what environment you emulate\n//- and that works with type int ant type float in the same way\n//  unlike the opengl modulo functions, which are just a hot mess\n// and that overlaps nicely with mod()\n//\n//admittingly far from perfrct, but a big step in a good direction.\n\n//mo(a,b) includes a pseudo-integer modulo [%] , that runs fine in opengl_es100, and uses the same mo(a,b) namespace for pseudo-float modulo()\n//[a] is a period that fractures [a]\n//it is [pseudo] as in\n//- for positive inputs, behaves identical to [mod(a,b)/b] or [float(int(a)%int(b)+.5)/b]\n//- for negative inputs, behaves better (continues the period into negative space) (works fine for negative intervals)\n//- is optionally well defined for b=0\n//- is unaffected for cases where you scale [a] and [b] by a [quadraticField] like; a*=[phi=1.61] b*=[phi=1.61]\n//- - that is, it behaves differently when irrational numbers scale it; it remains a constant period over x, regardness of any irrational scaling!\n//- - compare that with a less predictable yellow line, that fractures by phi-scalings and it only periodic over its .y domain.\n//mod(a,b)-.5=a%b=a-floor(b/a)*a is explicit type independent modulo in interval [b] (div before mult!)\n//we define arrays functions to be less type dependent and more aware of asymptotes\nv0 fl(v0 a     ){return floor(a)              ;}//type float of type independent floor()\ni0 fl(i0 a     ){return       a               ;}//type int   of type independent floor() (tautological namespace)\n#define   ne(a) -(a)                       //negation may be a different operand on different input types (eg complex numbers or chain rule structure)\n#define fmad(a,b,c) ((a)*(b)+(c))          //a lot of hardware is optimized for fmad()\n#define emod(a,b,c) fmad(ne(a),b,c)        //emod() is fmad() with negated [a]\n#define   mo(a,b)  (emod(fl(wdi(a,b)),b,a))//mo(a,b)=(a)-(fl((a)/(b))*(b)) //div before mult! fl() is only relevant for type float\n//note, you might need an offset of +.5 or -.5\n\n\n//thats it, use mo(a,b) instead of mod(a,b), and compare them\n//then replace mo(a,b) [a and b] with integers, and compare it with float(a%b)\n//we do all that in the code below, spoiler, there is a +.5 offset involved, and irrationalNumberScaling is always fun\n\n#define plusOffset \n//plusOffset is a bad idea , is a bad offset          , approaches/evades an asymptote poorly with a bad identity crysis\n#undef  plusOffset \n//no plusoofset is a good idea , is a more intuitive offset, faces an asymptote with consistency\n\n//#define ScalebyGolden \n//scale by golden ratios, stir up some shit\n\n//set what opengl version we want to try [100,300], will become pretentVersion=min(pretentVersion,__VERSION__)\n#define pretentVersion 300 \n\n//needed to compare with [%] which only exists if __VERSION__>=300\n//functions have a unique shape in them to tell you what function you execute (1 circle or 4 circles)\n#if (__VERSION__<pretentVersion)\n  //compileTime min(), modify pretentVersion, __VERSION__ is readOnly\n #undef pretentVersion\n #define pretentVersion __VERSION__\n#endif\n//to have a choice to run whatever you can run\n\n//moWebgl2test() tests mo()=[mod(a,b),floor(a%b+.5)] for [a>0,b>0] is opengl __VERSION__ independent (and float()-typecasting (type independent))\n//modulo with negative inputs must always be tested, most assertions are false assumptions here.\n//this section shows how pathethic  [a%b] performs for [a<0 || b<0] (left screen half, iMouse.x in left screen half)\n//this sectioncan demo how pathethic mod(a,b) erforms for [a==b==63.]\n#if (pretentVersion<300)\nv3 moWebgl2test(turm\n){//we run on Webgl1, the older version of webgl, that likely runs on most modern smartphones\n ;v0 a=63.    //do [a%b, mod(a,m)]\n ;a=u.x-r.x/2.//2d screenspace shows more than 1 [a] in 1 view, screenSpaceCenter sets a=0\n ;v0 b=3.    //period\n ;b=m.x-r.x/2.//mouse.x sets period, screenSpaceCenter==0\n #ifdef ScalebyGolden\n ;a*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue line is least affected\n ;b*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue line is least affected\n //;b*=sqrt(5.)*.5-.5//we can scale by Phi, but not by phi, phi is a terrible idea here, unless we also define plusOffset\n //;a*=sqrt(5.)*.5-.5//we can scale by Phi, but not by phi, phi is a terrible idea here, unless we also define plusOffset\n #endif\n ;//remove above line and be amazed how [mo(63.,63.) != mod(63.,63.) ] , even for b>0.\n ;//b=0.;asymptotic div0 test , uncommenting this line may cause a [compileTime parserError]:[div0 syntax error]\n #ifdef plusOffset\n ;v0 w=(mod(a,b)              )/b //pink   lines are shit,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=(v0( mo(  a,    b ))   )/b //purple lines are good\n ;v0 n=(v0(mo(i0(a),i0(b)))+.5)/b //yellow lines are good (except for the +.5 offset) and for negative values, well lets just do the [else]:\n #else\n //the -.5 offset is possibly a better choice in the long run?\n ;v0 w=(mod(a,b)           -.5)/b //pink   lines are shit\n ;v0 o=(v0(mo(   a,    b ))-.5)/b //purple lines are good\n ;v0 n=(v0(mo(i0(a),i0(b)))   )/b //yellow lines are good (well its the pointSymmetric mopdulo), offset a bit in negative a, accounting for [[year 0]]\n #endif \n ;u=fra(u)\n ;vec4 s=vec4(dd((u.xy)),w,o,n) // (dd((u.xy)) draws 1 circle to indicate opengl1\n ;s.x=sqrt(s.x)-.1\n ;s-=vec4(.2,u.yyy)\n ;v0 aA=1./(Aa)\n ;s=-(abs(s)-aA)//optional draw as lines\n ;s=step(-aA,s)\n ;//s=smoothstep(-aA,aA,s)//alternative smoothstep border.y\n ;s.xy+=s.w;s.xy*=.5\n ;s=s.yxzw\n ;return vec4(s.xyz,1);}\n#else\nv3 moWebgl2test(turm\n){//we run on Webgl2, the newer version of webgl, that may not be supported in hardware/settings\n ;v0 a=63.    //do [a%b, mod(a,m)]\n ;a=u.x-r.x/2.//2d screenspace shows more than 1 [a] in 1 view, screenSpaceCenter sets a=0\n ;v0 b=3.    //period\n ;b=m.x-r.x/2.//mouse.x sets period, screenSpaceCenter==0\n #ifdef ScalebyGolden\n ;a*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue/green lines are least affected\n ;b*=sqrt(5.)*.5+.5//plusOffset means we can scale by Phi, and only the blue/green lines are least affected\n //;b*=sqrt(5.)*.5-.5//we can scale by phi, only useful while we have NOT defined plusOffset\n //;a*=sqrt(5.)*.5-.5//we can scale by phi, only useful while we have NOT defined plusOffset\n #endif\n ;//b=0.;asymptotic div0 test , uncommenting this line may cause a [compileTime parserError]:[div0 syntax error]\n #ifdef plusOffset\n ;v0 w=mod(a,b)            /b //pink   lines are shit  ,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=v0((mo(a,b)))       /b //purple lines are good\n ;v0 n=(v0(i0(a)%i0(b))+.5)/b //yellow lines are shit\n #else\n ;v0 w=(   mod(a,b)    -.5)/b //pink   lines are shit  ,known to fail for mod(63.,63.),because people are idiots.\n ;v0 o=(v0((mo(a,b)))  -.5)/b //purple lines are good\n ;v0 n=(v0(i0(a)%i0(b))   )/b //yellow lines are shit\n #endif\n ;//n=((a)%(b))... haves so badly, you just should NEVER use it\n ;//- fails for negative inputs\n ;//- openGl_es300=webgl2 only, may be faster, but is likely nor worth because worst of all:\n ;//- shows a FATAL compiler error for [b==int(0.)] [compileTime parserError]:[div0 syntax error]\n ;//since we divide [w,o,n] with 0, we expect an asymptote for small b\n ;//- while this is interestring, lets not get too confused by it\n ;//n and w overlap nicely, except for negative inputs\n ;//o and w overlap nicely, for all cases\n ;//n and o overlap nicely, \n ;u=fra(u)\n ;vec4 s=vec4(dd(abs(u.xy)-.5),w,o,n) // (dd(abs(u.xy)-.5) draws 4 circles to indicate opengl2\n ;s.x=sqrt(s.x)-.1\n ;s-=vec4(.2,u.yyy)\n ;v0 aA=1./(Aa)\n ;s=-(abs(s)-aA)//optional draw as lines\n ;s=step(-aA,s)\n ;s=s.yxzw\n ;//s=smoothstep(-aA,aA,s)//alternative smoothstep border.y\n ;s.xy+=s.w;s.xy*=.5\n ;return vec4(s.xyz,1);}\n#endif\n\n\n\n\n//-----bitwise on glES100:\n//untested, currently in RequestForComments stage:\n\n//logic of bitwise operands on type float eems to be IDENTICAL/complement to [culling]-subroutines ?\n//(see bitXORm4() below)\n//bitWise AND  <-> min()\n//bitWise OR   <-> max()\n//in the long run [compatibility] is likely becoming a subset of [cull] (but not a subset of [CSG])\n//for large scale optimization/compatibility it all comes down to (frustrum) culling.\n//\n//csg (fuzzy logic) boolean is DIFFERENT; is best expressed with max(a,b)==-min(-a,-b)\n//eucliteanDistanctZOPoint here [adds +1 negation] to all logic, so [CSG] is the negative/complement of [cull]\n//quite common namespace of:  https://www.shadertoy.com/view/Xsc3WX\nfloat csgNEG(float x){return -x;}//{return csgN(x,x);}\nfloat csgAND(float a,float b){return max(a,b);}//AND=NOT(NAND(A,B))\nfloat csgN(float a,float b){return -max(a,b);}//NAND\nfloat csgOR (float a,float b){return -max(-a,-b);}//OR=NAND(NOT(A),NOT(B))\nfloat csgXOR(float a,float b){float o=-max(a,b);return -max(-max(a,o),-max(b,o));}\nfloat csgSUB(float a,float b){return -max(a,-b);}//SUB=AND(A,NOT(B))=NOT(NAND(A,NOT(B)))\n//XOR=NAND(NAND(A,NAND(A,B)),NAND(B,NAND(A,B)))\n\n//intBitsToFloat() uintBitsToFloat() (and their pseudo-inverses) are glES300 exclusive.\n//due to NaN ambiguity, they can only be pÃ¼seudo-inverse, and only bijectively address 30 of 32 bits.\n//getting half-decently substituting bitwise functions for type float is a tricky mess:\n//exp2(b) == pow(2.,b) is asserted to be true, where exp2() is likely faster AND more precise.\n\n//https://www.shadertoy.com/view/Mt2GWD | https://www.shadertoy.com/view/lsK3D1\n//return [0{{1] of bit b[0..23] from (whole number) float [a]=floor(A); //assert 23 bit base of ieee32bit float\nfloat getBit(float a,float b){return floor(mod(floor(a/exp2(floor(b))),2.));}\n//https://www.shadertoy.com/view/Xsc3WX\n//assert a=floor(A) b=floor(B), return [b]-th bit of [a], range [0||1]  domain of b is shifted to [-1..22], it includes a signBit as 24th bit!\nfloat getBit24(float a,float b){return getBit(a,clamp(b,-1.,22.));} //worksafe clamping\n//we can only get 24 base-bits (+1 sign bit) of a 32 bit float, getting 30 bit of it requires other (less compatible) command; intBitsToFloat()\n\n//mod() is not to be trusted:\n//float getBit0(float a){return floor(a/1.-floor(a*.5/1.)*2.);}\n//float getBit1(float a){return floor(a/2.-floor(a*.5/2.)*2.);}\n//float getBit2(float a){return floor(a/4.-floor(a*.5/4.)*2.);}\n//float getBit3(float a){return floor(a/8.-floor(a*.5/8.)*2.);}\n//above is 4 seperate bits explicitly, below is (up to) any 4 bits at once. \n//below getBits4() generalizes all the above \n//\n//a=floor(A); b=pow(2.,floor(vec4(B,C,D,E)))  //or less domains\n//return  range[0..1] of [A] after masking and shifting by single bit masks (B,C,D,E)\n#define getBits4(a,b) floor(((a)/(b))-(floor((a)*.5/(b))*2.))\n//works, because getBits4() returns a vector, that we can min() max() foreach domain!\n//bitAND(a,b,c) return a&b&(c.x+c.y+c.z+c.w)\n//return bitwise AND of 4bits of [a] and [b], masked by [c]\n//bitANDm4(float a,float b,vec4 c){c*=vec4(equal(getBits4(a,c),getBits4(b,c)));return c.x+c.y+c.z+c.w;}\nfloat bitAND(float a,float b,vec4 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=min(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z+c.w;}//AND is min()\nfloat bitAND(float a,float b,vec3 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=min(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z;}//AND is min()\nfloat bitAND(float a,float b,vec2 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=min(getBits4(a,c),getBits4(b,c));return c.x+c.y;}//AND is min()\nfloat bitAND(float a,float b,float c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){return c*min(getBits4(a,c),getBits4(b,c));}//AND is min()\n//bitOR(a,b,c) return (a|b)&(c.x+c.y+c.z+c.w)\n//return bitwise OR of 4bits of [a] and [b], masked by [c]\nfloat bitOR(float a,float b,vec4 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=max(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z+c.w;}//OR is max()\nfloat bitOR(float a,float b,vec3 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=max(getBits4(a,c),getBits4(b,c));return c.x+c.y+c.z;}//OR is max()\nfloat bitOR(float a,float b,vec2 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=max(getBits4(a,c),getBits4(b,c));return c.x+c.y;}//OR is max()\nfloat bitOR(float a,float b,float c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){return c*max(getBits4(a,c),getBits4(b,c));}//OR is max()\n//instead of notEqual, can use something like csgXOR(), except its complement!\n//bitXOR(a,b,c) return (a^b)&(c.x+c.y+c.z+c.w)\n//return bitwise XOR of 4bits of [a] and [b], masked by [c]\nfloat bitXOR(float a,float b,vec4 c//assert a=floor(A) b=floor(B) c=exp2(floor(C))\n){c*=vec4(notEqual(getBits4(a,c),getBits4(b,c)));return c.x+c.y+c.z+c.w;}\nfloat bitXOR(float a,float b,vec3 c\n){c*=vec3(notEqual(getBits4(a,c),getBits4(b,c)));return c.x+c.y+c.z;}\nfloat bitXOR(float a,float b,vec2 c\n){c*=vec2(notEqual(getBits4(a,c),getBits4(b,c)));return c.x+c.y;}\nfloat bitXOR(float a,float b,float c\n){return c*float(getBits4(a,c)!=getBits4(b,c));}\n//return bitwiseAND of [a] and [b], masked by 4 smallest bits==[15]==pow(2,4)-1\nfloat bitANDmask15(float a,float b//assert a=floor(A) b=floor(B)\n){return bitAND(a,b,vec4(1,2,4,8));}\n//return bitwiseAND of [a] and [b], masked by 8 smallest bits==[255]==pow(2,8)-1\nfloat bitANDmask255(float a,float b\n){return bitAND(a,b,vec4(1,2,4,8))+bitAND(a,b,vec4(1,2,4,8)*16.);}\n//return bitwiseAND of [a] and [b], masked by 16 smallest bits==[65535]==pow(2,16)-1\nfloat bitANDmask65535(float a,float b\n){return bitAND(a,b,vec4(1,2,4,8)     )+bitAND(a,b,vec4(1,2,4,8)*16.)\n         +bitAND(a,b,vec4(1,2,4,8)*256.)+bitAND(a,b,vec4(1,2,4,8)*4096.);}\n//return bitwiseAND of [a] and [b], masked by 24 smallest bits==[16777215]==pow(2,24)-1\nfloat bitANDmask16777215(float a,float b\n){return bitAND(a,b,vec4(1,2,4,8)        )+bitAND(a,b,vec4(1,2,4,8)*16.)\n         +bitAND(a,b,vec4(1,2,4,8)*256.  )+bitAND(a,b,vec4(1,2,4,8)*4096.)\n         +bitAND(a,b,vec4(1,2,4,8)*65536.)+bitAND(a,b,vec4(1,2,4,8)*1048576.);}\n//return bitwiseOR of [a] and [b], masked by 24 smallest bits==[16777215]==pow(2,24)-1\nfloat bitORmask16777215(float a,float b\n){return bitOR(a,b,vec4(1,2,4,8)      )+bitOR(a,b,vec4(1,2,4,8)*16.)\n         +bitOR(a,b,vec4(1,2,4,8)*256. )+bitOR(a,b,vec4(1,2,4,8)*4096.)\n         +bitOR(a,b,vec4(1,2,4,8)*65536.)+bitOR(a,b,vec4(1,2,4,8)*1048576.);}\n//return bitwiseXOR of [a] and [b], masked by 23 smallest bits==[8388607]==pow(2,23)-1\nfloat bitXORmask8388607(float a,float b\n){return bitXOR(a,b,vec4(1,2,4,8)      )+bitXOR(a,b,vec4(1,2,4,8)*16.)\n         +bitXOR(a,b,vec4(1,2,4,8)*256. )+bitXOR(a,b,vec4(1,2,4,8)*4096.)\n         +bitXOR(a,b,vec4(1,2,4,8)*65536.)+bitXOR(a,b,vec3(1,2,4)*1048576.);}\n         //note the last vec3() parameter lacks its *8\n\n\n\n//bitwise shift type float [x>>n], only shifts whole part; assert a=floor(x) n=floor(n)\n//float shiftsByN(float x,float n){return floor(x/pow(2.,n));}//dumb origin\n//when it comes to shifting/rotation (by negative values), some contexts have ambiguous definitions.\n//well, this definition uses exp2() it doesnt get more common than that?\n\nfloat shift(float x,float n){return x*exp2(n);}\n//a << b == a*exp2(b)\n//a >> b == a/exp2(b)\n//above 2 are precise, log2()|exp2() losslessly directly read mantissa|exponent\nfloat bitOp(float a,float b,float o//assert a,b,o=floor(a,b,0); a,b domains[0..1]; o domain[0..15]\n){return bitXORmask8388607((8./exp2(a))/exp2(2.*b),o);} //return (((8>>a)>>(2*b))&o;\n/**/\n//-----\n\n\n/*\n//test all\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 r=iResolution\n #if (__VERSION__ >=300)\n  ;int oo=4%6                 //es300 only, workarounds are tricky\n  ;float aa=intBitsToFloat(1) //es300 only, workarounds are tricky\n #endif\n ;bvec4 bb=bvec4(true,false,false,true)//es100\n ;vec4 m=iMouse\n ;o=moWebgl2test(iTime,u,iResolution,iMouse)*.5\n ;u=fra(u)\n ;m.xy=fra(m.xy)\n ;float c=length(u-m.xy)\n ;vec2 d=vec2(round(u.x),trunc(u.x))\n ;d.x=length(vec2(d.x,u.y)-m.xy)\n ;d.y=length(vec2(d.y,u.y)-m.xy)\n ;float a=1./Aa\n ;c=1.-(a,-a,abs(c))\n ;d=1.-(a,-a,abs(d))\n ;o.xyz=max(o.xyz,vec3(c,d))\n ;o.xyz=max(o.xyz,testEs300trig(u,r))\n ;}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}