{
    "Shader": {
        "info": {
            "date": "1595769350",
            "description": "hm",
            "flags": 0,
            "hasliked": 0,
            "id": "wl2yDt",
            "likes": 18,
            "name": "Cloth generator",
            "published": 3,
            "tags": [
                "hm"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 653
        },
        "renderpass": [
            {
                "code": "// Fork of \"Pseudo3D Fur\" by michael0884. https://shadertoy.com/view/tlBcRz\n// 2020-07-26 09:58:24\n\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define center R*0.5\n#define L 1.\n#define P 50.\n\n#define A 100.\n#define light_dir normalize(vec3(0.36,0.6,0.7))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p, out vec2 grad)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 pfs = sin(pf*PI);\n   \n   const vec2 a = vec2(0.,1.);\n   \n   float a00 = hash12(pi+a.xx);\n   float a01 = hash12(pi+a.xy);\n   float a10 = hash12(pi+a.yx);\n   float a11 = hash12(pi+a.yy);\n   \n   float x1 = mix(a00, a01, pfc.y);\n   float x2 = mix(a10, a11, pfc.y);\n   float y1 = mix(a00, a10, pfc.x);\n   float y2 = mix(a01, a11, pfc.x);\n    \n   grad = vec2((x2 - x1)*pfs.x, (y2 - y1)*pfs.y);\n   \n   return 0.5 + 0.5*mix(x1, x2, pfc.x);\n}\n\nvec4 dir(vec2 p, vec2 freq, float phase)\n{\n    float x = dot(p, freq) + phase;\n    return vec4(cos(x), sin(x), -freq.x*sin(x), freq.y*cos(x));\n}\n\nvec4 wind(vec2 p, float t)\n{\n    t*=5.;\n    \n    vec4 dx = 0.04*dir(p, vec2(-0.3, -0.5), 1.133*t)+\n              0.1*dir(p, vec2(0.1, 0.11), 0.431*t)+\n              0.2*dir(p, vec2(-0.12, 0.1), 0.256*t);\n    return 0.6*dx;\n}\n\nvec3 clothl(vec2 p, out vec2 GRAD)\n{\n    vec3 f = vec3(0.);\n    vec3 d = vec3(0., 0., 1.);\n    GRAD = vec2(0.);\n    for(int i = 0; i < 2; i++)\n    {\n        vec2 grad;\n        f += perlin(d.z*p + d.xy + vec2(i)*1e3, grad)*vec3(1.);\n        GRAD += d.z*grad;\n        d = vec3(d.x,d.y,0.3)*d + vec3(2.64, 1.5446, 0.);\n    }\n    return f;\n}\n\n#define cell_s 0.2\nvec3 cloth_pattern(vec2 pos, out vec3 normal)\n{\n    //create the weaving pattern\n    vec2 g1, g2;\n    const vec2 strand = vec2(0.02, 1.5); \n \tvec3 a = vec3(1.,.7,0.)*clothl(strand*pos, g1);\n    vec3 b = 1.2*vec3(1.,0.2,0.25)*clothl(strand.yx*pos, g2);\n    //checker modulation\n    float M = (2.*smoothstep(-0.5,0.5,sin(PI*pos.x*cell_s)) - 1.)*\n        \t  (2.*smoothstep(-0.5,0.5,sin(PI*pos.y*cell_s)) - 1.);\n    float Ma = smoothstep(-0.2,0.2,M);\n    normal = normalize(vec3(2.*mix(g1*strand, g2*strand.yx, Ma),1.));\n    return 3.*mix(a,b,Ma);\n}\n\nvec4 cloth(vec2 p)\n{\n    vec4 col = vec4(0.);\n    vec4 dx = wind(p*0.1, iTime);\n    //displacement normal\n    vec3 normal = normalize(vec3(-A*dx.zw, 1.));\n  \t//diceplacement\n    vec2 pos = p + A*dx.xy; \n    \n    //texture\n    vec3 c, N;\n    c = cloth_pattern(pos, N);\n    \n    //cloth normal modulation\n    normal = normalize(1.6*normal + N);\n    \n    // magic shading stuff\n\tfloat d = clamp(dot(normal, light_dir), 0., 1.);\n    float s = pow(d, 20.);\n    float B = 0.08*d + 0.05 + 0.2*s; //brightness\n    col = vec4(B*c,1.); //blend\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n   \t\n    fragColor = tanh(2.*cloth(0.5*fragCoord));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}