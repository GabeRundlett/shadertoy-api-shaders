{
    "Shader": {
        "info": {
            "date": "1718087677",
            "description": "\n/*originals  https://glslsandbox.com/e#60830.9 https://glslsandbox.com/e#53786.0\ncombination from many sources I’m just learning myself\n\nMIT LICENSE\n*/\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XXV3zt",
            "likes": 10,
            "name": "tube with words",
            "published": 3,
            "tags": [
                "text",
                "fractals",
                "cineshader",
                "cobination"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 320
        },
        "renderpass": [
            {
                "code": "\n/*sourses  https://glslsandbox.com/e#60830.9 https://glslsandbox.com/e#53786.0\ncombination from many sources I’m just learning myself\n\n\n\n\nMay everything be as good for you as it is for me! and life didn’t get worse no matter what we said or did.\nBut it only gets better and better!\nMIT LICENSE\n\n\n*/\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define time iTime\n#define resolution iResolution.xy\nconst float PI = 3.1415926;\n\nvec2  rot(vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn p*m;\n}\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p)\t;\n\tvec3 m = max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\n\n\nfloat hasira(vec3 p,vec3 s){\n\tvec2 q = abs(p.xy);\n\tvec2 m = max(s.xy-q.xy,vec2(0.0));\n\treturn length(max(q.xy-s.xy,0.0))-min(m.x,m.y);\n}\n\nfloat closs(vec3 p,vec3 s){\n\tfloat d1 = hasira(p,s);\n\tfloat d2 = hasira(p.yzx,s.yzx);\n\tfloat d3 = hasira(p.zxy,s.zxy);\n\treturn min(min(d1,d2),d3);\n}\n\nfloat menger (vec3 p,vec3 s){\n\tvec3 pm = p;\n\tfloat d1 = cube(p,vec3(100000.,100000.,10000.));\n\tfor(int i = 0;i<4; i++){\n\t\tfloat fi =3.0*float(i+4);\n\t\tif(i==0){\n\t\t\tfi =1.0;\n\t\t}\n\t\t\n\t\tfloat k = 2.0/fi;\n\t\tpm-=1.0*fi;\n\t\tpm = mod(pm,k)-0.5*k;\n\t\t\n\t\tfloat d2 = closs(pm,s/(3.0*fi));\n\t\td1 = max(d1,-d2);\n\t}\n\t\n\treturn d1;\n\t\n}\n\nfloat  nPrism(vec3 p,vec2 h,float n,float s){\n\tfloat np = PI*2./n;\n\tfloat r = atan(p.x,p.y);\n\tr = mod(r,np)-0.5*np;\n\tvec2 kp = length(p.xy)*vec2(cos(r),sin(r));\n\tvec3 kv = vec3(kp.x-h.x,abs(kp.y)-s*h.x*tan(0.5*np),abs(p.z)-h.y);\n\tfloat d = length(vec2(max(kv.x,0.0),max(kv.y,0.0)));\n\treturn length(vec2(d,max(kv.z,0.0)))-min(min(max(-kv.x,0.0),max(-kv.y,0.0)),max(-kv.z,0.0));\n}\n\nfloat dist (vec3 p){\n\t\n\t\n\n\tfloat k = 4.0;\n\tvec3 pm = p;\n\t\n\tfloat d = nPrism(pm,vec2(0.2,0.1),8.0,1.0);\n\tfloat dm = nPrism(pm,vec2(0.18,0.11),8.0,1.0);\n\tfloat da = max(d,-dm);\n\tfloat d1 = menger(p,vec3(1.0));\n\treturn d1;\n}\n\nfloat dist2 (vec3 p){\n\n\t\n\tfloat k = 1.0;\n\tvec3 pm = p;\n\n    float d = nPrism(pm,vec2(0.2,0.12),6.0,0.7);\n\tfloat dm = nPrism(pm,vec2(0.19,0.14),6.0,0.7);\n\tfloat da = max(d,-dm);\n\t\n\treturn da;\n}\nvec3 gn(vec3 p){\n\tvec2 e =vec2(0.001,0.0);\n\treturn normalize(vec3(\n\tdist(p+e.xyy)-dist(p-e.xyy),\n\tdist(p+e.yxy)-dist(p-e.yxy),\n\tdist(p+e.yyx)-dist(p-e.yyx)\n\t));\n}\nvec3 light(vec3 p,vec3 view){\n\tvec3 normal = gn(p);\n\tvec3 ld = normalize(vec3(cos(time*.0),sin(time*0.),-0.1));\n\tfloat NdotL = max(dot(ld,normal),0.0);\n\tvec3 R = normalize(ld+dot(view,normal)*2.0);\n\tfloat spec = pow(max(dot(view,R),0.0),10.0);\n\tvec3 em = vec3(0.1,0.5,0.1)*pow(abs(sin(p.x*3.0+time*1.)),20.0);\n\treturn clamp(vec3(NdotL+spec)+em,0.0,1.0);\n}\nvec2 uv2;\n\n\n\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 40 9  0\n |   \\ | /   |\n |    \\|/    |\n  _1002__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n#define n0 ddigit(0x22FF);\n#define n1 ddigit(0x0281);\n#define n2 ddigit(0x1177);\n#define n3 ddigit(0x11E7);\n#define n4 ddigit(0x5508);\n#define n5 ddigit(0x11EE);\n#define n6 ddigit(0x11FE);\n#define n7 ddigit(0x2206);\n#define n8 ddigit(0x11FF);\n#define n9 ddigit(0x11EF);\n\n#define A ddigit(0x119F);\n#define B ddigit(0x927E);\n#define C ddigit(0x007E);\n#define D ddigit(0x44E7);\n#define E ddigit(0x107E);\n#define F ddigit(0x101E);\n#define G ddigit(0x807E);\n#define H ddigit(0x1199);\n#define I ddigit(0x4466);\n#define J ddigit(0x4436);\n#define K ddigit(0x9218);\n#define L ddigit(0x0078);\n#define M ddigit(0x0A99);\n#define N ddigit(0x8899);\n#define O ddigit(0x00FF);\n#define P ddigit(0x111F);\n#define Q ddigit(0x80FF);\n#define R ddigit(0x911F);\n#define S ddigit(0x8866);\n#define T ddigit(0x4406);\n#define U ddigit(0x00F9);\n#define V ddigit(0x2218);\n#define W ddigit(0xA099);\n#define X ddigit(0xAA00);\n#define Y ddigit(0x4A00);\n#define Z ddigit(0x2266);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0);\n#define s_minus   ddigit(0x1100);\n#define s_plus    ddigit(0x5500);\n#define s_greater ddigit(0x2800);\n#define s_less    ddigit(0x8200);\n#define s_sqrt    ddigit(0x0C02);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv2 - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nfloat d = 1e6;\n\nvoid ddigit(int n)\n{\n\tfloat v = 1e6;\t\n\tvec2 cp = uv2 - ch_pos;\n\tif (n == 0)     v = min(v, dseg(vec2(-0.405*cos(iTime), -1.000), vec2(-0.500, -1.000)));\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063*sin(iTime)), vec2( 0.500,  0.937)));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500*sin(iTime), -0.063), vec2(-0.500, -0.938*cos(iTime))));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063*cos(iTime))));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063*cos(iTime),  0.063*sin(iTime)), vec2( 0.438*sin(iTime),  0.938)));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937*cos(iTime))));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063*sin(iTime)), vec2(-0.438,  0.938*sin(iTime))));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063*sin(iTime), -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000*cos(iTime), -0.938), vec2( 0.000, -0.063*cos(iTime))));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063*sin(iTime), -0.063), vec2( 0.438*sin(iTime), -0.938)));\n\tch_pos.x += (ch_space.x)*1.;\n\td = min(d, v);\n}\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (gl_FragCoord.xy * 2.0 - resolution) / resolution;\n\tp.y *= resolution.y/resolution.x;\n\tfloat kt =-time*0.0;\n\tfloat r = 0.1;\n\tvec3 ro = vec3(sin(kt),cos(kt)*r,10.0);\n\tvec3 ta =vec3(0.0,0.,0.);\n\tvec3 cdir = normalize(ta-ro);\n\tvec3 up = vec3(0.,1.,0.);\n\tvec3 side  = cross(cdir,up);\n\tup = cross(side,cdir);\n\tfloat fov =3.1;\n\tvec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n\tfloat t =0.0001;\n\tfloat d2 =0.0;\n\tfor(int i= 0;i<200;i++){\n\t\td2 = dist(ro+rd*t);\n\t\tt +=d2;\n\t}\n\tfloat tk =0.0;\n\tfloat dk = 0.0;\n\t\n\tvec3 bcol = vec3(1.1);\n\tvec3 col = light(ro+rd*t,rd);\n\tfloat far = 10.;\n\tfloat near = 1.0;\n\tif(tk<t){\n\t\t\n\t\t\t\n\t}\n\t\n\t\n\t\t\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv2 = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv2);\n\tuv2 *= 12.0 ;\n\n\n\tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv2.y*0.1,0.5,1.0));\n\n\tvec3 bg_color = vec3(_d*0.4, _d*0.2, _d*0.1);\n\tuv2.y+=1.0;\n\tch_pos = ch_start;\n\n                   _ _ _ W O R D S\n\t\t\t \n\t\t\n\tvec3 color = mix(ch_color, bg_color, 1.0- (0.08 / d*2.0));  // shading\n        \n        \n        \n\t\n\t\n\n\t\n\t\n\t\n    \tfragColor = vec4(color+col*ch_color, 1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}