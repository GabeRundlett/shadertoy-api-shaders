{
    "Shader": {
        "info": {
            "date": "1699637024",
            "description": "Collection of approximations of erf(x) and their error plots.\n25 functions currently.\n\nPlot is log-log: x is in [1e-7;1e+1], y is in [1e-8;1e-1].\n\nClick at the top to select a function (leftmost=time-reel).\nHold LMB to show plot of the relative error.",
            "flags": 0,
            "hasliked": 0,
            "id": "ml3yWj",
            "likes": 8,
            "name": "Approximations of erf(x)",
            "published": 3,
            "tags": [
                "function",
                "error",
                "erf",
                "errorfunction",
                "specialfunction"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Several approximations of error function (erf), and their\n// accuracy measurements in float32.\n\n// Functions are tested exhaustively on [-inf,+inf] range of float32 values,\n// using a C++ test program on x86, in IEEE-754 binary32 (-mfpmath=sse),\n// in the default (round-nearest-ties-even) rounding direction, without FMA,\n// using \"glibc 2.31-9\" versions of math functions.\n//\n// NOTE: the results do depend on the floating-point environment,\n// and library math functions, so e.g. the plots here may look different\n// in different GLSL implementations (see e.g. https://www.shadertoy.com/view/dttczs).\n//\n// Both absolute (Eabs) and relative (Erel) errors (maximum, i.e. inf-norm) are\n// reported. NOTE: subnormals (|x|<2^-126) are excluded from *relative*\n// error measurements, since results would probably be less useful\n// otherwise (e.g. erf(2^-149) incurs relative error ~0.114 simply due\n// to roundoff).\n//\n// Several properties (monotonicity, finite on [-inf;+inf], erf(0)=0,\n// erf(±inf)=±1, etc.) are reported (only when violated).\n//\n// Many of these approximations have very wrong asymptotic behaviour\n// for x->inf, actual asymptotic being\n//   1-erf(x)=erfc(x)=exp(-x^2)*(1/(sqrt(pi)*x)+O(x^-3))\n// This is hardly a concern, as float32(erf(x))=1 for x>4 (in default\n// rounding mode). It does matter more if you are approximating\n// erfc (float32(erfc(x))=0 for x>11 in default rounding mode).\n//\n// The plot is log-log: x is in [1e-7;1e+1], y is in [1e-8;1e-1].\n\n// The following have some nice lists of published approximations:\n//   https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n//   Roy M. Howard, 2022, ‘Arbitrarily Accurate Analytical Approximations for the Error Function’, arXiv:2012.04466\n\n// See also https://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\n// for *inverse* erf (useful for converting uniform random into normally distributed).\n// NOTE: analytical inverse also exists for several of the functions here.\n\n//==============================================================================\n// Several approximations from Abramowitz and Stegun.\n\n// f(x)=0   for |x|<2.14e-07\n// |f(x)|=1 for |x|>5.41\n// Eabs<4.7e-4\n// Erel=1 (<1.4e-2 for |x|>1e-3)\nfloat erf_as1(float x)\n{\n    float t=abs(x),y=1.0+t*(0.278393+t*(0.230389+t*(0.000972+t*0.078108))),y2=y*y,y4=y2*y2;\n    return sign(x)*(1.0-1.0/y4);\n}\n\n// f(x)=0   for |x|<1.26e-07\n// |f(x)|=1 for |x|>3.93\n// Eabs<2.19e-5\n// Erel=1 (<8.1e-4 for |x|>1e-3)\nfloat erf_as2(float x)\n{\n    float t=1.0/(1.0+0.47047*abs(x));\n    return sign(x)*(1.0-t*(0.3480242+t*(-0.0958798+t*0.7478556))*exp(-x*x));\n}\n\n// f(x)=0   for |x|<8.45e-7\n// |f(x)|=1 for |x|>3.94\n// Eabs<1.93e-6\n// Erel=1 (9.1e-4 for |x|>1e-3)\nfloat erf_as3(float x)\n{\n    float t=abs(x),y=1.0+t*(0.0705230784+t*(0.0422820123+t*(0.0092705272+t*(0.0001520143+t*(0.0002765672+t*0.0000430638)))));\n    float y2=y*y,y4=y2*y2,y8=y4*y4,y16=y8*y8;\n    return sign(x)*(1.0-1.0/y16);\n}\n\n// Non-monotonic (e.g. around x=-0.152124971).\n// f(x)=0   for |x|<1.81e-7\n// |f(x)|=1 for |x|>3.92\n// Eabs<6.63e-7\n// Erel=1 (<3.8e-4 for |x|>1e-3)\nfloat erf_as4(float x)\n{\n    float t=1.0/(1.0+0.3275911*abs(x));\n    return sign(x)*(1.0-t*(0.254829592+t*(-0.284496736+t*(1.421413741+t*(-1.453152027+t*1.061405429))))*exp(-x*x));\n}\n\n//==============================================================================\n// Several tanh-based approximations.\n// See e.g. Vedder, J. D., 1987, ‘Simple approximations for the error function and its inverse’, American Journal of Physics, vol. 55, pp. 762-763, doi: 10.1119/1.15018\n//\n// NOTE: atanh(erf(x))=C1*x+C3*x^3+C5*x^5+C7*x^7+O(x^9),\n// where\n//   C1=2/sqrt(pi)                                     ≈  1.1283791671\n//   C3=2*(4-pi)/(3*pi^(3/2))                          ≈  0.1027726033\n//   C5=(96-40*pi+3*pi^2)/(15*pi^(5/2))                ≈ -0.00020919464\n//   C7=(5760-3360*pi+532*pi^2-15*pi^3)/(315*pi^(7/2)) ≈ -0.00059012305\n//\n// NOTE: |tanh(x)-erf(x)|<0.082 for all x.\n//\n// See also:\n//   https://math.stackexchange.com/questions/4203484/simple-approximations-for-operatornameerfx\n//   https://math.stackexchange.com/questions/4794193/approximating-for-the-error-function-texterfx-through-an-hyperbolic-tange\n//   https://math.stackexchange.com/questions/4747631/a-better-approximation-of-0-5erfcx\n//\n// Both versions optimized for absolute and relative error are presented.\n\n// |f(x)|=1 for |x|>7.49\n// Eabs<1.9e-2\n// Erel<6.7e-2\nfloat erf_tanh1_abs(float x)\n{\n    // NOTE: truncating the constant to 1.2 yields\n    // slightly larger error (Eabs 0.01891...->0.01947...).\n    return tanh(1.203315375*x);\n}\n\n// |f(x)|=1 for |x|>7.76\n// Eabs<2.8e-2\n// Erel<3.0e-2\nfloat erf_tanh1_rel(float x)\n{\n    return tanh(1.161264952*x);\n}\n\n// NOTE: tanh(A*x+B*x^3) has a reasonably nice analytical inverse.\n// See Vedder's article for details.\n\n// NOTE: A*x+B*x^3 can be written as x*(A+B*x*x),\n// or as (B*x)*(A/B+x*x) which might be better on FMA-capable HW.\n\n// |f(x)|=1 for |x|>3.66\n// Eabs: 2.9e-4\n// Erel: 1.2e-3\nfloat erf_tanh3_abs(float x)\n{\n    return tanh(x*(1.129675826+x*x*0.099792702));\n}\n\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.5e-4\n// Erel<3.6e-4\nfloat erf_tanh3_rel(float x)\n{\n    return tanh(x*(1.128776206+x*x*0.100709669));\n}\n\n// Approximation from current https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.6e-4\n// Erel<4.7e-4\n// NOTE: tiny bit better Eabs than erf_tanh3_vedder_abs (but slightly worse Erel).\nfloat erf_tanh3_wiki(float x)\n{\n    // tanh((2/sqrt(pi))*(x+(11/123)*x^3))\n    return tanh(x*(1.12837923+0.100911958*(x*x)));\n}\n\n// Approximations from Vedder's publication.\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.6e-4\n// Erel<4.7e-4\nfloat erf_tanh3_vedder_abs(float x)\n{\n    // tanh((167/148)*x+(11/109)*x^3)\n    return tanh(x*(1.128378378+0.10091743119*(x*x)));\n}\n\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.9e-4\n// Erel<3.9e-4\nfloat erf_tanh3_vedder_rel(float x)\n{\n    // tanh((993/880)*x+(89/880)*x^3)\n    return tanh(x*(1.12840909+0.101136363*(x*x)));\n}\n\n// Non-monotonic at x=±1.91880643 (the only exceptions in float32).\n// |f(x)|=1 for |x|>3.92\n// Eabs<3.8e-5\n// Erel<2.1e-4\nfloat erf_tanh5_abs(float x)\n{\n    x=clamp(x,-4.0,+4.0);\n    float x2=x*x;\n    return tanh(x*(1.128143380+x2*(0.104081184+x2*-0.001786474)));\n}\n\n// Non-monotonic e.g. at x=-1.91638327\n// |f(x)|=1 for |x|>3.88\n// Eabs: 5.8e-5\n// Erel: 5.8e-5\nfloat erf_tanh5_rel(float x)\n{\n    x=clamp(x,-4.0,+4.0);\n    float x2=x*x;\n    return tanh(x*(1.128313934+x2*(0.103640769+x2*-0.001615140)));\n}\n\n// NOTE: tanh of 7th order polynomial does not seem to have much better\n// accuracy (Eabs ~3.0e-5). Neither does tanh(a*x*(1+b*x^2)/(1+c*x^2)) (Eabs ~6.4e-5).\n\n//==============================================================================\n// Approximation from\n// Winitzki, S., 2008, ‘A handy approximation for the error function and its inverse’\n// and several related ones.\n\n// Original version. Optimized for asymptotic behaviour.\n// Non-monotonic, e.g. at x=-3.29961586\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>4.0\n// Eabs: 3.3e-4\n// Erel=1 (<1.2e-2 for |x|>1e-3, <3.6e-4 using expm1)\nfloat erf_winitzki_orig(float x)\n{\n    // sgn(x)*sqrt(1-exp(-x^2*(4/pi+a*x^2)/(1+a*x^2)))\n    float a=0.14;\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.27323949+a*x2)/(1.0+a*x2)));\n}\n\n// Version optimized for absolute error.\n// Non-monotonic, e.g. at x=-3.30826592\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>4.01\n// Eabs<1.8e-4 (<1.1e-4 using expm1)\n// Erel=1 (<1.2e-2 for |x|>1e-3, <1.6e-4 using expm1)\nfloat erf_winitzki_abs(float x)\n{\n    float a=0.14783;\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.27323949+a*x2)/(1.0+a*x2)));\n}\n\n// Version optimized for relative error.\n// NOTE: in float32 this only really has better\n// relative error when using expm1.\n// Non-monotonic, e.g. at x=-3.21075726\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>4.01\n// Eabs<1.8e-4 (<1.3e-4 using expm1)\n// Erel=1 (<1.2e-2 for |x|>1e-3, <1.3e-4 using expm1)\nfloat erf_winitzki_rel(float x)\n{\n    float a=0.147;\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.27323949+a*x2)/(1.0+a*x2)));\n}\n\n//==============================================================================\n// Couple approximations by Alessandro Soranzo & Emanuela Epure.\n\n// Soranzo, A., & Epure, E., 2012, ‘Simply explicitly invertible approximations to 4 decimals of error function and normal cumulative distribution function’, arXiv:1201.1320v1.\n// Non-monotonic, e.g. at x=-3.622473\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using xepm1)\n// |f(x)|=1 for |x|>4.09\n// Eabs<1.8e-4 (<2.3e-5 using expm1)\n// Erel=1 (<1.2e-2 for |x|>1e-3, <1.3e-4 using expm1)\nfloat erf_soranzo1(float x)\n{\n    // Extension of Winitzki's approximation.\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.2735457+x2*0.1487936)/(1.0+x2*(0.1480931+x2*5.16e-4))));\n}\n\n// Alessandro Soranzo, Emanuela Epure, ‘Very simply explicitly invertible approximations of normal cumulative and normal quantile function’, Applied Mathematical Sciences, Vol. 8, 2014, no. 87, 4323-4341 http://dx.doi.org/10.12988/ams.2014.45338\n// f(x)=0   for |x|<1.13e-07\n// |f(x)|=1 for |x|>3.6\n// Eabs<2.6e-4\n// Erel=1 (<3.0e-3 |x|>1e-3)\nfloat erf_soranzo2(float x)\n{\n    // 2*(2**(-22**(1-41**(sqrt(2)*x/10))))-1\n    // NOTE: this approximation actually kind of\n    // works on (-inf;+inf), but has much worse error\n    // (Eabs ~1.6e-2) for negative arguments, and f(-inf)!=-1,\n    // so we use sgn(x)*f(abs(x)) instead.\n    return sign(x)*(exp2(1.0-pow(22.0,1.0-pow(41.0,(0.14142135623730950488*abs(x)))))-1.0);\n}\n\n//==============================================================================\n// Approximation by R. Menzel, and another related one.\n// NOTE: Vedder's article (in the same journal) references this.\n\n// Menzel, R., 1975, ‘Approximate closed form solution to the error function’, American Journal of Physics, vol. 43, pp. 366-367, doi: 10.1119/1.10085.\n// Menzel, R., 1975, ‘Erratum: Approximate closed form solution to the error function’, American Journal of Physics, vol. 43, p. 923, doi: 10.1119/1.10112.\n// f(x)=0   for |x|<1.5e-4 (for |x|<2.34e-23 using expm1)\n// |f(x)|=1 for |x|>3.69\n// Eabs<6.3e-3\n// Erel=1 (<1.2e-2 for |x|>1e-3, 7.1e-3 using expm1)\nfloat erf_menzel(float x)\n{\n    // sgn(x)*sqrt(1-exp((4/pi)*x^2))\n    return sign(x)*sqrt(1.0-exp(-1.27323954474*x*x));\n}\n\n// R.K. Bhaduri, B.K. Jennings: Note on the error function, Amer. J. Phys. 44 (1976), no. 6, 590 - 592.\n// Non-monotonic, e.g. at x=-1.98238456\n// f(x)=0   for |x|<1.5e-4\n// |f(x)|=1 for |x|>3.93\n// Eabs<7.5e-4\n// Erel=1 (<1.2e-2 for |x|>1e-3)\nfloat erf_bhaduri(float x)\n{\n    // sgn(x)*sqrt(1-exp(-(4/pi)*x^2)*(1+(8*x^4/pi)*(1/3-1/pi)))\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x,x4=x2*x2;\n    return sign(x)*sqrt(1.0f-exp(-1.27323954474*x2)*(1.0+0.03825689401807295256*x4));\n}\n\n//==============================================================================\n// Approximation from\n// Sandoval-Hernandez, M. A., Vazquez-Leal, H., Filobello-Nino, U. & Hernandez-Martinez, L., 2019, ‘New handy and accurate approximation for the Gaussian integrals with applications to science and engineering’, Open Mathematics, vol. 17, pp. 1774-1793, doi: 10.1515/math-2019-0131.\n\n// Non-monotonic, e.g. at x=-0.994693756\n// f(x)=0   for |x|<3.96e-8\n// |f(x)|=1 for |x|>3.45\n// Eabs<3.4e-5\n// Erel<1.7 (1.1e-4 for |x|>1e-3)\nfloat erf_sandoval_hernandez(float x)\n{\n    // NOTE: Erel for |x|>1e-3 is reduced to 9.0e-5\n    // with sgn(x)*f(abs(x)), but Eabs is ~same.\n    float x2=x*x;\n    return 2.0/(1.0+exp(x*(-2.25675833+x2*(-0.2055452066+x2*(0.0004183892806+x2*(0.00118024611+x2*-0.00012903668))))))-1.0;\n}\n\n//==============================================================================\n// Approximation from\n// Schöpf, H. M. & Supancic, P. H., 2014, ‘On Bürmann’s theorem and its application to problems of linear and nonlinear heat transfer and diffusion: Expanding a function in powers of its derivative’, The Mathematica Journal, vol. 16, pp. 1-44.\n\n// Non-monotonic, e.g. at x=-3.79021573\n// f(x)=0   for |x|<1.7e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>3.89\n// Eabs<3.5e-3\n// Erel=1 (<1.6e-2 for |x|>1e-3, <3.7e-3 using expm1)\nfloat erf_schopf(float x)\n{\n    x=clamp(x,-4.0,+4.0); // Result >1 for e.g. x=10 otherwise.\n    float y=exp(-x*x);\n    return sign(x)*1.1283791671*sqrt(1.0-y)*(0.88622692545+y*(0.155-y*0.042625));\n}\n\n//==============================================================================\n// Approximation from\n// Karagiannidis, G. K.; Lioumpas, A. S. (2007). \"An improved approximation for the Gaussian Q-function\". IEEE Communications Letters. 11 (8): 644–646. doi:10.1109/LCOMM.2007.070470. S2CID 4043576.\n\n// Non-monotonic, e.g. at x=-0.995896518\n// f(x)=0   for |x|<1.0e-3\n// |f(x)|=1 for |x|>3.91\n// Eabs<1.6e-2\n// Erel<14.0\nfloat erf_karagiannidis(float x)\n{\n    // erfc ~ (1-exp(-A*x))*exp(-x^2)/(B*sqrt(pi)*x), A=1.98, B=1.135\n    // NOTE: this approximation produces erfc(0)!=1.\n    float y=abs(x);\n    return y<1e-3? // Undefined at 0, and terrible near it.\n        0.0:\n        sign(x)*(1.0-(1.0-exp(-1.98*y))*exp(-x*x)/(2.01173512*y));\n}\n\n//==============================================================================\n// Approximation from\n// Numerical Recipes in Fortran 77: The Art of Scientific Computing (ISBN 0-521-43064-X), 1992, page 214, Cambridge University Press.\n\n// Non-monotonic, e.g. -0.950222135)=-0.82099247\n// f(x)=0   for |x|<1.19e-7\n// |f(x)|=1 for |x|>3.92\n// Eabs<4.9e-7\n// Erel=1 (<3.5e-4 for |x|>1e-3)\nfloat erf_nrf77(float x)\n{\n    float t=1.0/(1.0+0.5*abs(x));\n    return sign(x)*(1.0-t*exp(\n        -x*x-1.26551223\n        +t*(+1.00002368\n        +t*(+0.37409196\n        +t*(+0.09678418\n        +t*(-0.18628806\n        +t*(+0.27886807\n        +t*(-1.13520398\n        +t*(+1.48851587\n        +t*(-0.82215223\n        +t*(+0.17087277)))))))))));\n}\n\n//==============================================================================\n// What we will be using as a reference implementation.\n// Pretty lame, but it'll serve.\n// Accuracy: ~1.7 ulp.\n// Public domain, but please use something better, like\n// https://git.musl-libc.org/cgit/musl/tree/src/math/erff.c (~0.97 ulp)\n// or something, if you need an actually decent erf(float32).\nfloat erf_ref(float x)\n{\n    // Computed using Sollya.\n    x=clamp(x,-4.0,+4.0);\n    if(abs(x)<0.5)\n    {\n        float x2=x*x;\n        return x+\n              x*(+0.1283791065\n            +x2*(-0.3761229813\n            +x2*(+0.1127839386\n            +x2*(-2.6522522792e-2\n            +x2*(+4.3028555810e-3)))));\n    }\n    else\n    {\n        float y=abs(x);\n        // Weird summation order if for the sake of the monotonicity.\n        if(y<2.0) return sign(x)*(1.0-exp(\n            -y*y\n            +y*(-0.128787279\n            +y*( 0.364905298\n            +y*(-0.105986103\n            +y*( 2.334365435e-2\n            +y*(-3.360495903e-3\n            +y*( 2.324290981e-4\n            +y*  1.251965642e-7))))))\n            +(   4.685858949e-5-y)));\n        else return sign(x)*(1.0-exp(-y\n            +y*(-0.126425505\n            +y*(-0.640088737\n            +y*(-0.101832472\n            +y*(+2.179143392e-2\n            +y*(-3.201373387e-3\n            +y*(+2.837127831e-4\n            +y*(-1.134440117e-5)))))))));\n    }\n}\n\n//==============================================================================\n// Dispatcher.\n\nfloat f(int id,float x)\n{\n    switch(id)\n    {\n        case  0: return erf_ref(x);\n\n        case  1: return erf_as1(x);\n        case  2: return erf_as2(x);\n        case  3: return erf_as3(x);\n        case  4: return erf_as4(x);\n\n        case  5: return erf_tanh1_abs(x);\n        case  6: return erf_tanh1_rel(x);\n        case  7: return erf_tanh3_abs(x);\n        case  8: return erf_tanh3_rel(x);\n        case  9: return erf_tanh3_wiki(x);\n        case 10: return erf_tanh3_vedder_abs(x);\n        case 11: return erf_tanh3_vedder_rel(x);\n        case 12: return erf_tanh5_abs(x);\n        case 13: return erf_tanh5_rel(x);\n\n        case 14: return erf_winitzki_orig(x);\n        case 15: return erf_winitzki_abs(x);\n        case 16: return erf_winitzki_rel(x);\n\n        case 17: return erf_soranzo1(x);\n        case 18: return erf_soranzo2(x);\n\n        case 19: return erf_menzel(x);\n        case 20: return erf_bhaduri(x);\n\n        case 21: return erf_sandoval_hernandez(x);\n\n        case 22: return erf_schopf(x);\n\n        case 23: return erf_karagiannidis(x);\n\n        case 24: return erf_nrf77(x);\n#define NUM_FUNCTIONS 25\n    }\n    return 0.0;\n}\n\nfloat error(int id,float x,int rel)\n{\n    float y=f(id,x),z=erf_ref(x);\n    return rel==0?y-z:(y-z)/z;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 R=iResolution.xy;\n    vec2 xy=fragCoord/R;\n    vec3 col=vec3(0.8,0.75,0.7);\n    int id=int(floor(abs(iMouse.z/R.x)*float(NUM_FUNCTIONS)));\n    int rel=(iMouse.z>=0.0?1:0);\n    if(id==0) id=int(iTime)%(NUM_FUNCTIONS-1)+1;\n    float lx=mix(-7.0,+1.0,xy.x),x=pow(10.0,lx);\n    float ly=mix(-7.0,-1.0,xy.y),y=pow(10.0,ly);\n    float t,p;\n    // Render grid.\n    t=fract(lx);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    t=fract(ly);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    col=mix(col,vec3(0.0,1.0,0.0),0.5*exp(-1e4*lx*lx));\n    // Function selector.\n    if(xy.y>1.0-14.0/R.y) col=mix(col,vec3(0.25)+0.5*mod(floor(xy.x*float(NUM_FUNCTIONS)),2.0),0.5);\n    // Render error plot.\n    col=mix(\n        col,\n        vec3(0.25,0.5,0.75),\n        0.75*smoothstep(\n            -0.02*y,\n            +0.02*y,\n            abs(error(id,x,rel))-y));\n    // Print the function id.\n    int font[]=int[](0x01C0,0x4000,0x7B6F,0x4924,0x73E7,0x79E7,0x49ED,0x79CF,0x7BCF,0x4927,0x7BEF,0x79EF);\n    uint ix=uint(int(floor(0.25*(fragCoord.x-16.0))));\n    uint iy=uint(int(floor(0.25*(fragCoord.y-iResolution.y*0.875))));\n    if(ix<3u&&iy<5u) {if((font[uint(id)/10u%10u+2u]>>((4u-iy)*3u+ix)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    if(ix>=4u&&ix<7u&&iy<5u) {if((font[uint(id)%10u+2u]>>((4u-iy)*3u+ix-4u)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}