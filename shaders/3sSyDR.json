{
    "Shader": {
        "info": {
            "date": "1586381071",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "3sSyDR",
            "likes": 26,
            "name": "Day 111",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 574
        },
        "renderpass": [
            {
                "code": "// THIS IS LOGPOLAR MAPPING. THERE IS A REALLY NICE ARTICLE ON HOW TO DO IT. FUN STUFF.\n// https://www.osar.fr/notes/logspherical/\n\n// glow from here https://www.shadertoy.com/view/XlBSRz\n// pallete - inigo quilez\n// dither, ao - nusan\n// \n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 30.;\n    float scale = 0.00 + pow(dot(uvn,uvn),5.5)*0.4;\n    float chromAb = pow(length(uv - 0.5),2.9)*0.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    //fragColor = pow(fragColor, vec4(1. + dot(uvn,uvn))*1. );\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    fragColor *= 1. - dot(uvn*0.7,uvn*0.7)*1.;\n    fragColor = max(fragColor*1.1, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n\nvec3 glow = vec3(0);\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n}\t\n\n\nvec3 qG;\nvec2 idG;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e8);\n\n    vec3 q = p;\n    \n    float modD = 1.;\n    float reps = 10.;\n    \n    q = vec3(reps*atan(q.z,q.x)/tau ,log(length(q.xz)) ,q.y);\n    \n    //q.\n    \n    //q.z += length(p.xz)*0.6;\n    //q.z += exp(length(p.xz)*0.4)*0.1;\n    float h = exp(length(p.xz)*0.7)*0.2;\n    q.z -= h;\n    q.z += exp(-length(p.xz)*4.)*0.7;\n    //q.y *=  1. - exp(-length(p.xz)*5.)*6.4;\n    q.y *= reps/tau;\n    q.y += iTime;\n    \n    float id = floor(q.y);\n    //q *= 1.;\n    \n    q.x += iTime*0.4 + id*0.6 + q.y*0.1;\n    \n    //q.xy *= rot(0.1 + id);\n    idG = floor(q.xy/modD);\n    q.xy = pmod(q.xy, modD);\n    \n    qG = q;\n    \n    //q.xz = sin(q.xz);\n    float bW = 0.6;\n    \n    //float dB = length(q) - 0.3;\n    //for()\n    \n    q.xy *= rot(0.25*pi);\n    \n    float dB = sdBox(q, vec3(bW*2.,bW*2.,bW));\n    //dB = max(dB, -sdBox(q, vec3(0.1, bW*0.2,0.7)));\n    float s = 0.2*bW;\n    dB = min(dB, sdBox(q, vec3(bW*s, bW*s,bW*1.2)));\n    \n    s *= 2.;\n    \n    q.xy *= rot(0.5);\n    float dBb = sdBox(q, vec3(bW*s, bW*s,bW*1.1));\n    d = dmin(d,vec2(dBb, 1.) );\n    \n    \n    \n    d = dmin(d, vec2(dB, 2.));\n    \n    \n    s = 0.2*bW;\n    q.xy *= rot(0.5*pi);\n    float dC = sdBox(q, vec3(bW*s*1., bW*s*1.,bW*1.3));\n    d = dmin(d, vec2(dC, 3.));\n    \n    \n    \n    q = abs(q);\n    //q.xz -= 0.;\n    //q.yz *= rot(0.25*pi);\n    \n    q.z -= 0.4;\n    float dD = sdBox(q, vec3(bW*s*1., bW*s*1.,bW*20.5));\n    \n    \n    //glow += 0.8/(0.01 + dD*dD*20.)*pal(0., 0.9,vec3(0.9,0.4,0.8), 0.7,1.2);\n    p.y -= h;\n    glow += 1.8/(0.06 + dD*dD*200.)*sin(vec3(0.8,0.5,0.1) + vec3(0,-0. - length(p.xz)*0.1,0))*pow(abs(sin(iTime + idG.y)), 20.)* smoothstep(1.,0.,length(p.y)*0.6)* pow(smoothstep(0.,1.,length(p.xz)*4.2),7.); // pow(smoothstep(0.,1.,length(p.xz)*1.2),7.);\n    \n    dD = abs(dD) + 0.006 + smoothstep(0.,1.,length(p.y)*0.05);\n    d = dmin(d, vec2(dD, 3.));\n    //= dmin(d, vec2(length(p)- 0.1, 2.));\n    d.x *= 0.4;\n    \n    d.x *= exp(log(length(p.xz) + 0.1)/1.5);\n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d= vec2(10e8);\n\n    t = 0.; hit = false; p = ro;\n    \n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        d.x *= dith;\n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0.);\n    return normalize(\n    \tvec3(\n        \tmap(p + t.xyy).x - map(p - t.xyy).x,\n        \tmap(p + t.yxy).x - map(p - t.yxy).x,\n        \tmap(p + t.yyx).x - map(p - t.yyx).x\n        )\n    );\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv,uv)*0.1;\n    \n    vec3 col = vec3(0);\n    dith = mix(0.96,1.,texture(iChannel0, iResolution.x*(uv/256.)).x);\n    \n    vec3 ro = vec3(2.501,3,0.001);\n    vec3 lookAt = vec3(0.05);\n    \n    lookAt.xz += vec2(sin(iTime)*1.2,cos(iTime)*0.5)*0.4;\n\tvec3 rd = getRd(ro, lookAt, uv); \n    vec3 p;float t; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if(hit){\n    \tvec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n        \n        \n        #define AO(a) clamp(map(p + n*a).x/a,0.,1.)\n        float dnrd = max(dot(n, - rd),0.);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, normalize(l - rd)),0.), 20.);\n        float fres = pow(1.- dnrd, 5.);\n        \n    \t//col += (0.5 + n*0.5)*2.;\n        \n        vec3 q = qG;\n        \n        float modD = 0.1;\n        q = abs(q);\n        \n        q.xy *= rot(0.25*pi);\n        q.y -= 0.5;\n        \n        q = abs(q);\n        q.xy *= rot(0.25*pi);\n        q = abs(q);\n        q.x -= 0.5;\n        q.xy *= rot(-0.25*pi);\n        \n        \n        float ao = mix(0.4,AO(0.1)*AO(0.2)/0.26,smoothstep(0.,1.,length(p.xz)*1.));\n        //float ao = AO(0.2)*AO(0.4)*AO(0.3)/0.16;\n        //float ao = AO(0.2)*AO(2.4)*AO(0.8)/0.3*3.;\n        float idc = floor(max(q.x,q.y)/ modD + iTime*4.*0.25);\n        \n        \n        \n        if(d.y == 2. || d.y == 1.){\n            //col += pal(0.5,1., vec3(.7,0.1,-0.3),0.8,idc*1.5 + idG.y*0.5 + iTime*0.1);\n            col += pal(0.,0.9, vec3(.7,0.1,-0.3),0.8,idc*1.5 + length(p.xz)*1. + iTime*1.);\n\t\t\n\n            col = max(col, 0.);\n        } else if(d.y == 3.) {\n            //col += pal(0.5,1., vec3(.7,0.2,0.),0.8,idc*1.5 + idG.y*0.5);\n            col += 0.4*fres;\n\n            \n            \n            //col += shiftHue(col, 0.98).xyz;\n        }\n        //col += pal(0.5,0.5, vec3(.1,0.9,1.8),0.8,idc*1.5 );\n        if(d.y == 1.){\n        \t//col = sin(col*10.);\n        }\n        \n        \n        //col *= 0.2+ ao;\n        col *= ao*1.4;\n        \n        col *= smoothstep(0.,1.,length(p.xz)*1.);\n        \n        //q.xz\n        \n        //col += qG;\n        \n    \t    \n    }\n    \n    \n    col += glow*0.005;\n    \n    //col = pow(col, vec3(0.454545));\n\n    col = mix(col,vec3(0.06,0.02,0.05), smoothstep(0.,1.,t*0.04));\n    \n    //col *= 1. - dot(uv,uv)*0.7;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}