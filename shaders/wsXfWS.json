{
    "Shader": {
        "info": {
            "date": "1588957160",
            "description": "Inspired by:\nhttps://www.youtube.com/watch?v=qu04xLNrk94\nhttps://youtu.be/ovaZ-YlAjHY?list=PLIwiAebpd5CIEPbQua9XO3iodtZ4bjWa-&t=1373\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wsXfWS",
            "likes": 5,
            "name": "Euler Spoiler",
            "published": 3,
            "tags": [
                "euler",
                "numberphile",
                "spoiler"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "const vec4 background = vec4(.2, .2, .2, 1.);\n\n// generated with https://medialab.github.io/iwanthue/\n// ordered to minimize travelling salesman distance.\nconst vec3[11] colors = vec3[11](\n    vec3(115./255., 124./255., 208./255.),\n    vec3(89./255., 51./255., 151./255.),\n    vec3(74./255., 154./255., 93./255.),\n    vec3(104./255., 180./255., 61./255.),\n    vec3(155./255., 149./255., 52./255.),\n    vec3(208./255., 133./255., 59./255.),\n    vec3(221./255., 78./255., 67./255.),\n    vec3(147./255., 56./255., 41./255.),\n    vec3(189./255., 74./255., 124./255.),\n    vec3(200./255., 90./255., 197./255.),\n    \n    vec3(115./255., 124./255., 208./255.) // first one repeated\n);\n\nint[100] outer = int[100](\n    6,7,8,0,1,2,3,4,5,9,\n    1,4,7,5,2,0,9,6,8,3,\n    3,6,4,1,8,9,5,7,0,2,\n    5,3,0,7,9,4,6,8,2,1,\n    2,8,6,9,3,5,7,1,4,0,\n    7,5,9,2,4,6,0,3,1,8,\n    4,9,1,3,5,8,2,0,6,7,\n    9,0,2,4,7,1,8,5,3,6,\n    8,1,3,6,0,7,4,2,9,5,\n    0,2,5,8,6,3,1,9,7,4 );\n\nint[100] inner = int[100](\n    4,5,6,7,8,0,1,2,3,9,\n    7,9,3,6,1,4,2,0,8,5,\n    9,2,5,0,3,1,8,7,6,4,\n    1,4,8,2,0,7,6,5,9,3,\n    3,7,1,8,6,5,4,9,0,2,\n    6,0,7,5,4,3,9,8,2,1,\n    8,6,4,3,2,9,7,1,5,0,\n    5,3,2,1,9,6,0,4,7,8,\n    2,1,0,9,5,8,3,6,4,7,\n    0,8,9,4,7,2,5,3,1,6 );\n\nvec3 color_cycled(int i) {\n    i = (i + int(iTime)) % 10;\n\t// Here we assume colors has the first one repeated rather than doing the usual mod 10;\n    float t = fract(iTime);\n    t = mix(t, smoothstep(0., 1., t), .2);\n    return mix(colors[i], colors[i+1], t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // put things into a square\n    uv.x -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    uv.x += .5;\n    \n    if (uv.x < .0 || uv.x > 1.) {\n        fragColor = background;\n        return;\n    }\n    \n    // 10x10 grid.\n    vec2 grid = uv * 10.;\n    uv = fract(grid); \n    \n    // center-based coordinates\n    uv -= .5;\n    uv = abs(uv*2.);\n    \n    vec3 col = background.rgb;\n    \n    \n    if (max(uv.x, uv.y) < 0.50) col.rgb = color_cycled(outer[int(grid.x) + 10*int(grid.y)]);\n    if (max(uv.x, uv.y) < 0.25) col.rgb = color_cycled(inner[int(grid.x) + 10*int(grid.y)]);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}