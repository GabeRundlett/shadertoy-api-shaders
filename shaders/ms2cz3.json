{
    "Shader": {
        "info": {
            "date": "1688004241",
            "description": "The rays gets bent around a sphere to hide the stick figure until he jumps.",
            "flags": 0,
            "hasliked": 0,
            "id": "ms2cz3",
            "likes": 9,
            "name": "Stick Figure Cloaking",
            "published": 3,
            "tags": [
                "space",
                "warp",
                "hide",
                "cloaking"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 243
        },
        "renderpass": [
            {
                "code": "#define EPS 0.001\n\nvec2 Rotate(in vec2 p, in vec2 o, in float r) {\n    float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdSegment(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 o, in vec3 b) {\n    p = abs(p - o) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, max(p.y, p.z)));\n}\n\nfloat sdStickFigure(in vec3 p) {\n    // Sizes\n    float t = 0.1; // Thickness\n    float hs = 0.4; // Head size\n\n    // Limb rotations\n    float lsr = cos(iTime * 2.5) + 0.5; // Left shoulder rotation\n    float rsr = -0.25 - lsr; // Right shoulder rotation\n\n    float lar = cos(iTime * 2.5) + 2.0; // Left forearm rotation (a for forearm)\n    float rar = 4.0 - cos(iTime * 2.5 + 0.5); // Right forearm rotation\n\n    float ltr = 0.0; // Left thigh rotation\n    float rtr = 0.0; // Right thigh rotation\n\n    float lcr = 0.0; // Left shin (calf) rotation\n    float rcr = 0.0; // Right shin (calf) rotation\n\n    // Joint positions\n    vec2 np = vec2(0.0, 0.75) + sin(iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.1, 0.05); // Neck\n    vec2 bp = vec2(-0.15, -0.65) + sin(-iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.25, 0.1); // Hip\n    vec2 hp = bp + normalize(np - bp) * (length(np - bp) + hs); // Head\n\n    vec2 lep = vec2(-0.4, 0.0); // Left elbow\n    vec2 rep = vec2(0.4, 0.0); // Right elbow\n\n    vec2 lhp = vec2(-0.75, 0.7); // Left hand\n    vec2 rhp = vec2(0.75, 0.7); // Right hand\n\n    vec2 lfp = vec2(-0.25, -2.0) + sin(-iTime * 3.0 + vec2(1.57, 0.0)) * vec2(1.25, 0.4); // Left foot\n    vec2 rfp = vec2(0.5, -1.75) + sin(-iTime * 3.0 + 2.0 + vec2(1.57, 0.0)) * vec2(1.0, 0.4); // Right foot\n\n    vec2 lkp = (bp + lfp) * 0.5; lkp += normalize(lkp - bp).yx * vec2(-0.25, 0.25); // Left knee\n    vec2 rkp = (bp + rfp) * 0.5; rkp += normalize(rkp - bp).yx * vec2(-0.25, 0.25); // Right knee\n\n    // Arm rotations\n    lep = Rotate(lep, np, lsr); // Left shoulder rotation\n    rep = Rotate(rep, np, rsr); // Right shoulder rotation\n\n    lhp = Rotate(lhp, np, lsr); // Left forearm rotation (with elbow)\n    rhp = Rotate(rhp, np, rsr); // Right forearm rotation (with elbow)\n\n    lhp = Rotate(lhp, lep, lar); // Left forearm rotation (independent)\n    rhp = Rotate(rhp, rep, rar); // Right forearm rotation (independent)\n\n    // Leg rotations\n    lkp = Rotate(lkp, bp, ltr); // Left thigh rotation\n    rkp = Rotate(rkp, bp, rtr); // Right thigh rotation\n\n    lfp = Rotate(lfp, bp, ltr); // Left shin rotation (with thigh)\n    rfp = Rotate(rfp, bp, rtr); // Right shin rotation (with thigh)\n\n    lfp = Rotate(lfp, lkp, lcr); // Left shin rotation (independent)\n    rfp = Rotate(rfp, rkp, rcr); // Right shin rotation (independent)\n\n    return min(min(sdSegment(p, vec3( np, -t), vec3(lep, -t)),\n               min(sdSegment(p, vec3(lep, -t), vec3(lhp, -t)),\n               min(sdSegment(p, vec3( np,  t), vec3(rep,  t)),\n               min(sdSegment(p, vec3(rep,  t), vec3(rhp,  t)),\n               min(sdSegment(p, vec3( np,  0), vec3( bp,  0)),\n               min(sdSegment(p, vec3( bp, -t), vec3(lkp, -t)),\n               min(sdSegment(p, vec3(lkp, -t), vec3(lfp, -t)),\n               min(sdSegment(p, vec3( bp,  t), vec3(rkp,  t)),\n                   sdSegment(p, vec3(rkp,  t), vec3(rfp,  t)))))))))) - t,\n\n               sdSphere(p, vec3(hp, 0), hs));\n}\n\nvoid add(inout float dist, inout int nearest, in float obj, in int id) {\n    if (obj < dist) {\n        dist = obj;\n        nearest = id;\n    }\n}\n\nfloat mapUncloaked(in vec3 p, in vec3 pos, out int id) {\n    float sec = fract(max(0.0, mod(iTime, 2.0) - 1.0));\n    vec3 sp = p - pos - vec3(0.0, 24.0 * sec * (1.0 - sec), 0.0);\n    vec2 dir = normalize(vec2(2.0 * cos(2.0 * iTime), -sin(iTime)));\n    sp.xz *= mat2(dir, -dir.y, dir.x);\n    float d = sdStickFigure(sp);\n    id = 0;\n    add(d, id, p.y, 1);\n    add(d, id, sdSphere(p, vec3(5.0, 4.0, 3.0), 1.0), 2);\n    add(d, id, p.z + 7.0, 3);\n    add(d, id, sdBox(p, vec3(-8.0, 2.3, 0.0), vec3(1.0, 2.0, 0.5)) - 0.3, 4);\n    return d;\n}\n\nvec3 getNormalUncloaked(in vec3 p, in vec3 pos, in float d0) {\n    int id;\n    return normalize(vec3(\n        mapUncloaked(p + vec3(EPS, 0, 0), pos, id),\n        mapUncloaked(p + vec3(0, EPS, 0), pos, id),\n        mapUncloaked(p + vec3(0, 0, EPS), pos, id)\n    ) - d0);\n}\n\nfloat mapCloaked(in vec3 p, in vec3 pos, out int id) {\n    p += normalize(p - pos) * 2.5;\n    return mapUncloaked(p, pos, id) * 0.3;\n}\n\nvec3 getNormalCloaked(in vec3 p, in vec3 pos, in float d0) {\n    int id;\n    return normalize(vec3(\n        mapCloaked(p + vec3(EPS, 0, 0), pos, id),\n        mapCloaked(p + vec3(0, EPS, 0), pos, id),\n        mapCloaked(p + vec3(0, 0, EPS), pos, id)\n    ) - d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0, -0.25));\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 2.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec3 pos = vec3(3.0 * sin(2.0 * iTime), 2.25, 3.0 * cos(iTime));\n\n    float t = 0.0, d;\n    vec3 p;\n    int id;\n    bool hit;\n    for (int i = 0; i < 200; i++) {\n        p = ro + rd * t;\n        d = mapCloaked(p, pos, id);\n        if (abs(d) < EPS) {\n            hit = true;\n            break;\n        }\n\n        if (t > 25.0) break;\n        t += d;\n    }\n\n    fragColor = vec4(0);\n    if (hit) {\n        vec3 nor = getNormalCloaked(p, pos, d);\n        float shade = max(0.0, dot(nor, -rd));\n        vec3 color = vec3(0.8, 0.5, 0.0);\n        if (id == 1) color = vec3(0.0, 1.0, 0.0);\n        if (id == 2) color = vec3(0.0, 0.0, 1.0);\n        if (id == 3) color = vec3(1.0, 0.4, 0.25);\n        if (id == 4) color = vec3(1.0, 0.25, 1.0);\n        fragColor.rgb = color * shade;\n        vec2 st = p.yz;\n        vec3 an = abs(nor);\n        if (an.y > max(an.x, an.z)) st = p.xz;\n        if (an.z > max(an.x, an.y)) st = p.xy;\n        fragColor = mix(fragColor, texture(iChannel0, st * 0.5), 0.5);\n    }\n\n    t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        d = mapUncloaked(p, pos, id);\n        if (abs(d) < EPS) {\n            if (id == 0) fragColor.b += 0.4;\n            break;\n        }\n\n        if (t > 25.0) break;\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}