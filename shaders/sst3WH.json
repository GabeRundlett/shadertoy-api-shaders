{
    "Shader": {
        "info": {
            "date": "1629750378",
            "description": "Complex math goodies.",
            "flags": 0,
            "hasliked": 0,
            "id": "sst3WH",
            "likes": 25,
            "name": "Complex Math Utilities",
            "published": 3,
            "tags": [
                "math",
                "complex",
                "utilities"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "#define iTime (0.25 * iTime)\n\n// Complex function\nvec2 f(in Complex z) {\n    return casin(cmul(ctan(3.0 * z), cexp(iTime * i))) * 0.8;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Complex z = f((fragCoord - 0.5 * iResolution.xy) / iResolution.y);\n    fragColor = vec4(hue2rgb(carg(z) / tau + 0.5) * (1.0 - exp(-1.5 * cmod(z))), 1.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(fwidth(z.x) * 1.5, 0.0, abs(mod(z.x + 0.125, 0.25) - 0.125)));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(fwidth(z.y) * 1.5, 0.0, abs(mod(z.y + 0.125, 0.25) - 0.125)));\n    //fragColor.rgb = hue2rgb(fragCoord.x / iResolution.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Joke of the day:\n// Complex numbers are real.\n\n// Constants\n#define pi 3.14159265359     // Ratio between the circumference and diameter of a circle\n#define rho 1.57079632679    // π/2\n#define tau 6.28318530718    // 2π\n#define e 2.7182818284       // Euler's number\n#define i Complex(0.0, 1.0)  // Complex unit\n\n// Hue to RGB conversion (https://www.desmos.com/calculator/amac5m7utl)\nvec3 hue2rgb(in float hue) {\n    //return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    //return smoothstep(0.0, 1.0, abs(2.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0)) - 1.0)) * 1.2;\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// -------------------------- Complex math --------------------------\n#define Complex vec2\n#define re x\n#define im y\n\n// Miscellaneous\nfloat carg(in Complex z) { return atan(z.im, z.re); }\nfloat cmod(in Complex z) { return length(z); }\nComplex cconj(in Complex z) { return Complex(z.re, -z.im); }\n\n// Elementary operations (+, -, *, /)\nComplex cadd(in Complex z, in Complex w) { return z + w; }\nComplex cadd(in Complex z, in float w) { return Complex(z.re + w, z.im); }\nComplex cadd(in float z, in Complex w) { return Complex(z + w.re, w.im); }\n\nComplex csub(in Complex z, in Complex w) { return z - w; }\nComplex csub(in Complex z, in float w) { return Complex(z.re - w, z.im); }\nComplex csub(in float z, in Complex w) { return Complex(z - w.re, -w.im); }\n\nComplex cmul(in Complex z, in Complex w) { return mat2(z, -z.im, z.re) * w; }\nComplex cmul(in Complex z, in float w) { return z * w; }\nComplex cmul(in float z, in Complex w) { return z * w; }\n\nComplex cinv(in Complex z) { return Complex(z.re, -z.im) / dot(z, z); }\nComplex cdiv(in Complex z, in Complex w) { return cmul(z, cinv(w)); }\nComplex cdiv(in Complex z, in float w) { return z / w; }\nComplex cdiv(in float z, in Complex w) { return z * cinv(w); }\n\n// Exponentials\nComplex cexp(in Complex z) { return exp(z.re) * Complex(cos(z.im), sin(z.im)); }\nComplex clog(in Complex z) { return Complex(0.5 * log(dot(z, z)), carg(z)); }\n\n// Powers\nComplex cpow(in Complex z, in Complex w) { return cexp(cmul(clog(z), w)); }\nComplex cpow(in float z, in Complex w) { return cexp(log(z) * w); }\nComplex cpow(in Complex z, in float w) {\n    float a = carg(z) * w;\n    return Complex(cos(a), sin(a)) * pow(dot(z, z), 0.5 * w);\n}\n\nComplex csqr(in Complex z) { return Complex(z.re * z.re - z.im * z.im, 2.0 * z.re * z.im); }\nComplex csqrt(in Complex z) {\n    Complex c = 0.5 * Complex(cmod(z), z.re);\n    return Complex(sqrt(c.re + c.im), sign(z.im) * sqrt(c.re - c.im));\n}\n\n// Hyperbolic functions\nComplex csinh(in Complex z) { return Complex(sinh(z.re) * cos(z.im), cosh(z.re) * sin(z.im)); }\nComplex ccosh(in Complex z) { return Complex(cosh(z.re) * cos(z.im), sinh(z.re) * sin(z.im)); }\nComplex ctanh(in Complex z) {\n    vec4 c = vec4(sinh(z.re), cosh(z.re), sin(z.im), cos(z.im));\n    return cdiv(c.xy * c.wz, c.yx * c.wz);\n}\n\n// Inverse hyperbolic functions\nComplex casinh(in Complex z) { return clog(z + cpow(cadd(cmul(z, z), 1.0), 0.5)); }\nComplex cacosh(in Complex z) { return clog(z + cpow(csub(cmul(z, z), 1.0), 0.5)); }\nComplex catanh(in Complex z) { return 0.5 * clog(cdiv(cadd(1.0, z), csub(1.0, z))); }\n\n// Trigonometric functions\nComplex csin(in Complex z) { return csinh(z.yx).yx; }\nComplex ccos(in Complex z) { return ccosh(Complex(z.im, -z.re)); }\nComplex ctan(in Complex z) {\n    vec4 c = vec4(sin(z.re), cos(z.re), sinh(z.im), cosh(z.im));\n    return cdiv(c.xy * c.wz, Complex(c.y, -c.x) * c.wz);\n}\n\n// Inverse trigonometric functions\nComplex casin(in Complex z) { return casinh(z.yx).yx; }\nComplex cacos(in Complex z) { return csub(rho, casin(z)); }\nComplex catan(in Complex z) { return catanh(z.yx).yx; }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}