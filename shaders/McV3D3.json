{
    "Shader": {
        "info": {
            "date": "1713397734",
            "description": "Raytracing kata. Public domain.",
            "flags": 0,
            "hasliked": 0,
            "id": "McV3D3",
            "likes": 12,
            "name": "Halftone rift",
            "published": 3,
            "tags": [
                "reflection",
                "abstract",
                "halftone"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 171
        },
        "renderpass": [
            {
                "code": "// Raytracing kata. Public domain.\n\nvoid mainImage(out vec4 o, vec2 x) {\n    // t: Timers. Camera left/right, camera forward/back, texture animation.\n    vec3 t = iTime * vec3(.618, 1, 12),\n\n    // p,d: Camera position (= ray origin) and ray direction.\n    // Position is a horizontal Lissajous curve.\n    // Set up direction so that z=1, y=1..-1 and pixels are square, then normalize.\n    // (Normalizing now makes things easier later.)\n         p = vec3(1.5*cos(t.x), -.5, cos(t.y)-3.),\n         d = normalize(iResolution.xyy - vec3(x+x, 0));\n    \n    // o: The output color (rgbα, but α is ignored).\n    // At first, assume we hit the golden background walls.\n    o = vec4(4,3,2,0);\n \n    // There's a unit sphere at the origin. Does the ray hit it?\n    //   Parametric equation of a ray:  v = p + d*t where t>0\n    //   Implicit equation of a unit sphere:     dot(v,v) = 1\n    //   Intersect:                 dot(p + d*t, p + d*t) = 1\n    //             dot(p,p) + 2*dot(p,d*t) + dot(d*t,d*t) = 1\n    //             dot(p,p) + 2*dot(p,d)*t + dot(d,d)*t²  = 1  // dot(d,d)=1\n    //       (dot(p,p) - 1) + 2*dot(p,d)*t +          t²  = 0\n    //   Solve quadratic c+2bt+t²=0: t+,t- = -b ± sqrt(b²-c)\n    // If the discriminant b²-c < 0, we've missed the sphere.\n    // We're outside and behind the sphere, so we can take the smaller root t-.\n    float B = dot(p,d),\n          D = B*B - dot(p,p) + 1.;\n    if (D > 0.) {\n        // Move along the ray so that p is on the sphere.\n        // It's a unit sphere at the origin, so p is also the surface normal at that point.\n        p -= d * (B + sqrt(D));\n        \n        // Precompute cos(θ),\n        // where θ is the angle between the incoming direction and the surface normal.\n        D = dot(p,d);\n\n        // The sphere is a black dielectric with a colorful amber reflection.\n        // Use Schlick's approxiation of the Fresnel reflectance factor:\n        //   R(θ) = R0 + (1-R0) * (1-cos(θ))^5,\n        //   where R0 = 0.04 (reflectance at 0°: 0.04 is the usual for dielectrics),\n        //         θ = angle between outgoing direction and surface normal.\n        // Round (1-R0) to 1, nobody can see the difference.\n        o = vec4(8,4,0,0) * (.04 + pow(1.+D, 5.));\n        \n        // Reflected direction: d - 2*(project d onto the normal).\n        d -= 2.*D*p;\n    }\n    \n    // There are two walls in the background (x = 3 and x = -3).\n    // The ray always hits one of them (assuming it's not parallel).\n    //   Parametric equation of a ray: v = p + d*t where t>0\n    //   Implicit equation of a YZ-plane: v.x = c\n    //   Intersect:               p.x + d.x*t = c\n    //                                      t = (c - p.x) / d.x\n    // We want t>0, so (c - p.x) / d.x > 0.\n    //   Multiply by d.x and get two cases: c > p.x  when  d.x > 0,\n    //                                      c < p.x  when  d.x < 0.\n    // The camera is between the walls (-3 < p.x < 3),\n    // so if d.x > 0, we'll hit the right wall (x = 3),\n    // otherwise we'll hit the left wall (x = -3).\n\n    // Move along the ray so that p is on a wall.\n    p += d * ((3.*sign(d) - p) / d).x;\n    \n    // Animate the texture (move towards -Z).\n    B = (p + t).z;\n    \n    o = sqrt(o / dot(p,p) * clamp(2. + 32.*cos(8.*p.y)*sin(B+B) + 36.*sin(B/8.), 0., 4.));\n    // The texture is a fast YZ-halftone   ^^^^^^^^^^^^^^^^^^^^  with ^^^^^^^^^ slow Z waves.\n    //                 The multipliers ^^^^ are big to make edges ^^^^ sharper.\n    //              Balance light ^^ and darkness and clamp the texture to 0..4. ^^^^^^\n    // Apply ^^^^^^^^^^^^ object color and inverse square falloff.\n    //  ^^^^ Convert from linear to gamma color space (should be 1/2.2, but 1/2 is ok).\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}