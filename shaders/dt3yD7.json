{
    "Shader": {
        "info": {
            "date": "1699280476",
            "description": "any improvements/suggestions are welcome :)\n\npress alt+down if you go fullscreen",
            "flags": 32,
            "hasliked": 0,
            "id": "dt3yD7",
            "likes": 39,
            "name": "Big-Small Swap Automata",
            "published": 3,
            "tags": [
                "grid",
                "automata",
                "cellular",
                "cell",
                "cool",
                "ca",
                "shuffle"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "// Rough overview:\n// Buffer A swaps the positions of 3 cell types: off, small, big\n// with different protocols for each swap type:\n// off->small, off->big, small->off, big->off\n// (big cells comprise of 4 indexed cells which act as corners)\n\n// Image interprets buffer A data and draws moving circles\n\n// Values:\n// o.r: Color\n// o.g: 0=off, 1=small, 2,3,4,5=big corners\n// o.b: Direction index 0,1,2,3\n// o.a: Motion timer [0,1] range\n\n// Other variants you could try:\n// - 2x1 cells which rotate around an endpoint to move\n// - replace o.r with encoded start position, and restrict cell\n//   position to be within (or outside) neighbourhood of start pos\n// - allow cells to push each other, e.g. 1|1|0 -> 0|1|1\n// - rock paper scissors variant, i.e. 0,1,2,3 instead of on/off\n//   1 can do swaps with 0,2\n//   2 can do swaps with 1,3 etc. (motion timer maybe inapplicable)\n// - or have rps pushing, 1 pushes 2, 2 pushes 3, 3 pushes 1\n// - give each cell a lifetime, then have spawning conditions too\n// (these are really just ordinary CA + a motion timer)\n\n#define pi 3.14159\n//#define cell(d) texture(iChannel0, d/R+u)\n#define cell(d) texelFetch(iChannel0, ivec2(d+zoom*(px-.5*R)+.5*R), 0)\n\nvoid mainImage( out vec4 o, vec2 px )\n{\n    vec2 R = iResolution.xy;\n    float zoom = 29./R.y;\n    vec2 u = zoom * (px - .5*R)/R + .5;\n         \n    o = cell(0.);\n    \n    // Get cell direction and next cell along\n    vec2 dir = indexToDir(o.b);\n    vec4 c = cell(dir);\n    \n    // Magic equation that sorts out motion\n    // (I definitely understand how this works)\n    float m = smoothstep(.1, .9, o.a) - step(1., o.g);\n    vec2 p = m * dir;\n    \n    // Circle radius\n    float r = .5;\n    if (o.g > 1.) r = 1.;\n    \n    // Offset circle position for big cells\n    if      (o.g==2.) p += vec2( .5,  .5); // bl\n    else if (o.g==3.) p += vec2(-.5,  .5); // br\n    else if (o.g==4.) p += vec2( .5, -.5); // tl\n    else if (o.g==5.) p += vec2(-.5, -.5); // tr\n    else if (o.g==0. && o.a < 1. && c.g > 1.) {\n        r = 1.;\n        if      (c.g==2.) p += vec2( .5,  .5);\n        else if (c.g==3.) p += vec2(-.5,  .5);\n        else if (c.g==4.) p += vec2( .5, -.5);\n        else if (c.g==5.) p += vec2(-.5, -.5);\n    }\n    \n    // Oscillate radius with motion\n    r *= mix(.5+.5*o.r, 1., pow(4.*o.a*(1.-o.a), 32.));\n    \n    // Draw circle with color\n    vec2 f = fract(u * R) -.5 - p;\n    float s = smoothstep(0., .1, r-length(f));\n    float s2 = smoothstep(0., .1, r-length(f+vec2(.2)));\n\n    vec4 col = .6 + .4 * cos(2.*pi*(8.*o.r + 0.*o.a+vec4(0,4,5,0)/12.));\n    col = max(col, (.7-.5*col)*exp(-8.*abs(r-length(f+.1*r))))\n        - .4*exp(-7.*abs(r-length(f-.08*r)));\n        \n    o = pow(.02+s*col, vec4(1./1.7));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Debugging (set to 0 to disable)\n#define smallSwap 1\n#define bigSwap 1\n\n// Swap speed\n#define speed .016\n\nvec2 indexToDir(float i) {\n    if (i == 0.) return vec2(-1, 0); // l\n    if (i == 1.) return vec2( 0, 1); // t\n    if (i == 2.) return vec2( 1, 0); // r\n                 return vec2( 0,-1); // b\n}\n\nfloat dirToIndex(vec2 u) {\n    if (u == vec2(-1, 0)) return 0.; // l\n    if (u == vec2( 0, 1)) return 1.; // t\n    if (u == vec2( 1, 0)) return 2.; // r\n                          return 3.; // b\n}\n\n// From Fabrice\n// https://www.shadertoy.com/view/WttXWX\n#define hashi(x) triple32(x)\n#define hash(x)  ( float( hashi(floatBitsToUint(hash13(x))) ) / float( 0xffffffffU ) )\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Alternative checkNeighbour function\n/*\nbool checkNeighbour(vec4 o, vec4 c, vec2 u, vec2 dir) {\n    vec2 offset;\n    if (dir == vec2(-1, 0)) {\n        if      (c.g == 3.) offset = vec2(0, 1);\n        else if (c.g == 5.) offset = vec2(0, -1);\n    } \n    else if (dir == vec2(0, 1)) {\n        if      (c.g == 2.) offset = vec2(1, 0);\n        else if (c.g == 3.) offset = vec2(-1, 0);\n    } \n    else if (dir == vec2(1, 0)) {\n        if      (c.g == 2.) offset = vec2(0, 1);\n        else if (c.g == 4.) offset = vec2(0, -1);\n    } \n    else if (dir == vec2(0, -1)) {\n        if      (c.g == 4.) offset = vec2(1, 0);\n        else if (c.g == 5.) offset = vec2(-1, 0);\n    }\n    \n    vec4 n = cell(u+offset);\n    vec2 ndir = pickDir(o, u+offset);\n    \n    // Cell is off, not moving, has same direction\n    return n.g == 0. && n.a == 1. && ndir == dir;\n}\n//*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Values:\n// o.r: Color\n// o.g: 0=off, 1=small, 2,3,4,5=big corners\n// o.b: Direction index 0,1,2,3\n// o.a: Motion timer [0,1] range\n\n#define cell(u) texelFetch(iChannel0, ivec2(u), 0)\n\n// Big/small cells (o.g > 0.) generate an index \n// corresponding to a direction to swap cells\nfloat getIndex(vec2 u) {\n    return floor(4.*hash(vec3(u, float(iFrame))));\n}\n\n// The offset to bottom left corner in big cells\n// (return vec2(0) if bl or is not a big cell)\n// 4 5 \n// 2 3\nvec2 getBigOffset(vec4 o) {\n    if (o.g == 3.) return vec2(-1,  0); // br\n    if (o.g == 4.) return vec2( 0, -1); // tl\n    if (o.g == 5.) return vec2(-1, -1); // tr\n                   return vec2( 0,  0); // bl\n}\n\n// Big/small cells generate a random direction to swap in\nvec2 getDir(vec4 o, vec2 u) {\n    vec2 offset = getBigOffset(o);\n    return indexToDir(getIndex(u+offset));\n}\n\n// Off cells pick a direction based on their neighbouring cells\n// to resolve conflicts \n// i.e. if multiple cells want to swap with this one, pick one\nvec2 pickDir(vec4 o, vec2 u) {\n    // Check neighbours until we find a cell wanting to swap\n    // first check for big cells (clockwise)\n    // then small cells (anticlockwise)\n    vec2 sdir = vec2(0);\n    float baseIndex = getIndex(u);\n    for (float i; i < 4.; i++) {\n        vec2 dir = indexToDir(mod(baseIndex + i, 4.));\n        vec4 c = cell(u+dir);\n        vec2 cdir = getDir(o, u+dir);\n        \n        // Cell is on, not moving and wants to swap\n        if (c.g > 0. && c.a == 1. && dir == -cdir) {\n            // Cell is big, return direction index\n            if (c.g > 1.) return dir;\n                \n            // Cell is small, consider it\n            sdir = dir;      \n        }           \n    }\n    return sdir;\n}\n\n// Off cells check a neighbour cell's values so that\n// big/off swaps can occur (big cells swap with 2 off cells)\nbool checkNeighbour(vec4 o, vec4 c, vec2 u, vec2 dir) {\n    // Neighbour cell which big cell will also swap with\n    vec2 offset = (1.+2.*(dir+getBigOffset(c))) * mod(dir+1., 2.);\n    vec4 n = cell(u+offset);\n    vec2 ndir = pickDir(o, u+offset);\n    \n    // Cell is off, not moving, has same direction\n    return n.g == 0. && n.a == 1. && ndir == dir;\n}\n\nvoid swapOff(inout vec4 o, vec2 u) {    \n    vec2 dir = pickDir(o, u);        \n\n    // Another cell wants to swap\n    if (dir != vec2(0)) {\n        vec4 c = cell(u+dir); \n        vec2 cdir = getDir(c, u+dir);\n\n        // Swap directions align, and cell is not moving\n        if (dir == -cdir && c.a == 1.) {\n            // Swap with small cell\n            #if smallSwap == 1\n            if (c.g==1.) { \n                o.rg = c.rg; // Copy color and cell type\n                o.b = dirToIndex(cdir); // Store direction for Image tab\n                o.a = 0.; // Reset motion timer\n            }\n            #endif\n            \n            // Swap with big cell if neighbour wants to swap too\n            #if bigSwap == 1\n            if (c.g>1. && checkNeighbour(o,c,u,dir)) {\n                o.rg = c.rg; \n                o.b = dirToIndex(cdir); \n                o.a = 0.;\n            }\n            #endif\n        }\n    } \n}\n\nvoid swapSmall(inout vec4 o, vec2 u) {\n    #if smallSwap != 1\n        return;\n    #endif\n    \n    vec2 dir = getDir(o, u);\n    vec4 c = cell(u+dir);\n    \n    // Swap if cell is off, not moving, directions align\n    if (c.g == 0. && c.a == 1.) {\n        vec2 cdir = pickDir(c, u+dir);\n        if (dir == -cdir) {\n            o.g = 0.;\n            o.b = dirToIndex(dir);\n            o.a = 0.;\n        }\n    }\n}\n\nvoid swapBig(inout vec4 o, vec2 u) {\n    #if bigSwap != 1\n        return;\n    #endif\n    \n    // Bottom left pixel of big cell determines most swap logic\n    vec2 bl = u + getBigOffset(o);    \n    float index = getIndex(bl);\n    vec2 dir = indexToDir(index);\n    \n    // p1, p2 are the positions our big cell wants to move into\n    vec2 p1 = bl, p2 = bl;\n    if      (index == 0.) p1 += vec2(-1, 0), p2 += vec2(-1, 1); // l\n    else if (index == 1.) p1 += vec2( 0, 2), p2 += vec2( 1, 2); // t\n    else if (index == 2.) p1 += vec2( 2, 0), p2 += vec2( 2, 1); // r\n    else if (index == 3.) p1 += vec2( 0,-1), p2 += vec2( 1,-1); // b\n    \n    vec4   c1 = cell(p1),          c2 = cell(p2);\n    vec2 dir1 = pickDir(c1, p1), dir2 = pickDir(c2, p2);\n    \n    // Swap if both cells are:\n    // off, not moving, want to swap (directions align)\n    if (c1.g==0. && c1.a==1. && dir1==-dir &&\n        c2.g==0. && c2.a==1. && dir2==-dir) {            \n        vec4 c = cell(u+dir);\n        // m checks if cell will still be in big cell after swapping\n        // (by checking proximity to p1)\n        // e.g.: dir = (1, 0), \n        // 4 | 5 | 0 --> 0 | 4 | 5\n        // 2 | 3 | 0     0 | 2 | 3\n        // 5,3 -> 4,2 so stay in big cell\n        // 4,2 -> 0,0 so don't stay in big cell\n        float m = max(abs(u.x-p1.x), abs(u.y-p1.y));\n        if (m == 1.)\n            o.g = cell(u-dir).g;\n        else \n            o.g = 0.;  \n        o.b = dirToIndex(dir);\n        o.a = 0.;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    // Initialize\n    if (iFrame < 1) {\n        // Spawn big cells\n        vec2 f = floor(u/2.);\n        o.r = hash12(f);      // Color\n        o.g = step(.75, hash12(.1*f)); // Cell type\n        \n        // Spawn small cells (if no big cell)\n        if (o.g == 0.) { \n            o.r = hash12(u);     \n            o.g = step(.7, hash12(.1*u)); \n        } \n        // Set corner id for big cell\n        else { \n            vec2 m = mod(u, 2.)-.5;\n            if      (m == vec2(0, 0)) o.g = 2.; // bl\n            else if (m == vec2(1, 0)) o.g = 3.; // br\n            else if (m == vec2(0, 1)) o.g = 4.; // tl\n            else if (m == vec2(1, 1)) o.g = 5.; // tr            \n        }\n        o.b = 0.; // Direction index\n        o.a = 1.; // Motion timer\n    } \n    // Update\n    else {\n        o = cell(u);\n        \n        // Increment motion timer\n        if (o.a < 1.) { \n            float inc = speed * (.5+.5*o.r);\n            if (iMouse.z > 0.) inc = 1.;\n            o.a = min(1., o.a+inc);\n        }\n        // Swap cells\n        else {\n            if      (o.g == 0.) swapOff(o, u);  \n            else if (o.g == 1.) swapSmall(o, u);\n            else if (o.g > 1.)  swapBig(o, u); \n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}