{
    "Shader": {
        "info": {
            "date": "1569611196",
            "description": "He's so happy!!!\n\nHeavily influenced by watching part of iq's jumpy boi deconstruction",
            "flags": 0,
            "hasliked": 0,
            "id": "WstGDs",
            "likes": 15,
            "name": "Froge!!!!",
            "published": 3,
            "tags": [
                "raymarching",
                "playdough",
                "frog"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 1042
        },
        "renderpass": [
            {
                "code": "sdfRet frog(vec3 point)\n{\n    //body\n    float id = .0;\n    float dist = sphDist(point, sphere(vec3(.0,.05,.0), .25 ));\n    \n    //shoulders\n    dist = smin(dist, sphDist(point, sphere(vec3(.34,-.12,-.1), .08)), .2);\n    \n    ////lower body\n    dist = smin(dist, sphDist(point, sphere(vec3(.0,.02,.3), .1)), .3);\n    \n    ////thighs\n    dist = smin(dist, sphDist(point, sphere(vec3(.24,-.12, .34), .08)), .2);\n    \n    //head\n    dist = smin(dist, sphDist(point, sphere(vec3(.0,.04,-.25), .22)), .1);\n    \n    dist = max(-max(sdCapsule(point, vec3(-1.,-.04,-.5),vec3(1.,-.04,-.5),.1),point.y-.01),dist);\n    \n    //eyes\n    float distEyes = sphDist(point, sphere(vec3(.15,.11,-.3), .14));\n    \n    if(dist > distEyes) id = 2.0;\n    dist = min(dist,distEyes);\n    \n    //iris\n    float distIris = sphDist(point, sphere(vec3(.19,.11,-.32), .1));\n    if(dist > distIris) id = 3.0;\n    dist = min(dist,distIris);\n    \n    return sdfRet(dist, id);\n}\n\nsdfRet map(vec3 point)\n{\n    \n    point.z *=-1.0;\n    point = vec3(abs(point.x),point.y,point.z);\n    \n    sdfRet d = frog(point);\n    \n    //plane\n    float d2 = point.y+.2;\n    \n    sdfRet r = sdfRet(d2,1.0);\n    if(d.sdf < d2) r = d;\n    return r;\n}\n\n//from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*CLOSE_ENOUGH).sdf + \n                      k.yyx*map( p + k.yyx*CLOSE_ENOUGH).sdf + \n                      k.yxy*map( p + k.yxy*CLOSE_ENOUGH).sdf + \n                      k.xxx*map( p + k.xxx*CLOSE_ENOUGH).sdf );\n}\n\n\nfloat shadows(ray r)\n{\n    float dist = CLOSE_ENOUGH;\n    float returnval = 1.0;\n    \n\tfor(int i = 0; i < 100; i++)\n    {\n    \tvec3 rp = r.origin + r.direction *dist;\n        sdfRet ret = map(rp);\n        returnval = min(16.*ret.sdf/dist, returnval);\n        dist += ret.sdf;\n        if(dist > 20.0) break;\n    }\n    \n    return returnval;\n}\n\nvec3 lighting(vec3 point)\n{\n\tdirLight sun = dirLight(normalize(vec3(.5,.5, .2)), 1.0, vec3(1.0,.9,.8),.02);\n    dirLight horizon = dirLight(vec3(.0,1.,.0), .05, vec3(.3,.3,.8),.0);\n    dirLight bounce = dirLight(vec3(.0,-1.0,.0), .02, vec3(.1,.1,.6),.0);\n    \n    vec3 normal = calcNormal(point);\n    \n    ray shadowRay = ray(point+normal*CLOSE_ENOUGH,sun.direction);    \n    vec3 col = diffuse(normal,sun, shadows(shadowRay));\n    \n    col += diffuse(normal,horizon,1.0);\n    \n    col += diffuse(normal,bounce,1.0);\n    \n    return col;\n    \n}\n\nconst int aa = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 total = vec3(.0);\n    //MSAA\n    for(int i = 0; i <aa;i++)\n    for(int j = 0; j <aa;j++)\n    {\n    \t//offset the uv for MSAA\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\n    \tuv.x *= iResolution.x/iResolution.y;\n    \t\n    \tfloat mousex = 9.0*iMouse.x/iResolution.x;\n    \t\n        //camera calculations\n    \tvec3 target = vec3(.0,.0,.0);\n    \tvec3 rayOrigin = target + vec3(1.5*sin(mousex),.2,1.5*cos(mousex));\n    \tvec3 front = normalize(target - rayOrigin);\n    \tvec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    \tvec3 up = normalize(cross(right, front));\n    \tvec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    \tray currentRay = ray(rayOrigin, rayDir);\n    \t\n        //sky color\n    \tvec3 col = vec3(.4,.4,.9)-vec3(.4,.4,.9)*currentRay.direction.y;\n    \t\n        //raymarching\n    \tfloat dist = .0;\n    \tfor(int i = 0; i < 400; i++)\n    \t{\n            //point at which we'll sample distances\n    \t\tvec3 rayPoint = currentRay.origin + currentRay.direction *dist;\n    \t    \n            //sampling of distances\n            sdfRet ret = map(rayPoint);\n            \n            //smaller than our epsilon : hit!\n    \t    if(ret.sdf < CLOSE_ENOUGH)\n    \t    {\n    \t        col = lighting(rayPoint)*idtocol(ret.id);\n    \t        break;\n    \t    }\n    \t    if(dist > 20.0) break;\n    \t    dist += ret.sdf;\n    \t}\n     \n    \ttotal += col;\n    }\n    total /= float(aa*aa);\n    \n    // Output to screen\n    fragColor = vec4(pow(total,vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define CLOSE_ENOUGH .001\n\n// ----structs----\n\nstruct sdfRet\n{\n\tfloat sdf;\n    float id;\n};\n    \nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n  \nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct dirLight\n{\n\tvec3 direction;\n    float intensity;\n    vec3 color;\n    float ambient;\n};\n\n\n// ----distance functions----\n\n    \nfloat sphDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat smax( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n\n// ----lighting----\n\n\nvec3 diffuse(vec3 normal, dirLight l, float s)\n{\n\treturn max(dot(normal, l.direction)*l.intensity*s, l.ambient)*l.color;\n}\n\n\n\n    \nvec3 idtocol(float id)\n{\n    vec3 col = vec3(.2,.9,.2);\n    \n    if(id > .5) col = vec3(.1,.1,.6);\n    if(id > 1.5) col = vec3(1.0);\n    if(id > 2.5) col = vec3(.1);\n    \n    return col;\n}    ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}