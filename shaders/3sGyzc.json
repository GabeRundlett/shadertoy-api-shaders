{
    "Shader": {
        "info": {
            "date": "1603423024",
            "description": "SPH Fluid simulation.\nWork really well on my old PC with a NV 860, it's a 1fps on my phone. :(\nhttps://matthias-research.github.io/pages/publications/sca03.pdf",
            "flags": 48,
            "hasliked": 0,
            "id": "3sGyzc",
            "likes": 18,
            "name": "AutoWasher 2",
            "published": 3,
            "tags": [
                "physics",
                "sph",
                "fluids",
                "pbd"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 600
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define SMOOTH\t1\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nfloat smoothFilter(float d)\n{\n    float v = 2000. / iResolution.y;\n    return smoothstep(v, -v, d);\n}\n\nconst float k = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    p *= 1000.;\n    vec3 col = vec3(0);\n    \n    col = mix(col, vec3(1,0,0), smoothFilter(map(p, iTime)));\n   \n    #if SMOOTH \n        float sminAcc = 0.;\n        for(int i = 0; i < PartNum; i++)\n        {\n            vec2 pp = Load(i, CompPosition).xy;\n            sminAcc += exp2(-k *sdCircle( p - pp, KernelRadius ));\n        }\n    \tcol = mix(col, vec3(0,0,1), smoothFilter(-log2( sminAcc ) / k));\n    #else //SMOOTH\n    {\n        for(int i = 0; i < PartNum; i++)\n        {\n            vec2 pp = Load(i, CompPosition).xy;\n            col = mix(col, vec3(fract(Phi * float(i * 3)), fract(Phi * float(i * 3 + 1)), fract(Phi * float(i * 3 + 2))), smoothFilter(sdCircle(p - pp, KernelRadius)));\n        }        \n    }\n    #endif //SMOOTH\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst int PartNum\t\t= 512;\nconst int MaxCompPerRow\t= 256;\nconst float DeltaTime   = 0.0008;\nconst float Pi \t\t\t= radians(180.);\n\n\nconst vec2  ExtForce = vec2(0.f, 12000.*-9.8);\nconst float RestDensity = 1000.;\nconst float GasConst = 2000.;\nconst float KernelRadius = 16.;\nconst float PartMass = 65.;\nconst float Viscosity = 250.;\nconst float ColRestitution = 0.20f;\nconst float Poly6 = 315./(65.*Pi*pow(KernelRadius, 9.f));\nconst float SpikyGrad = -45./(Pi*pow(KernelRadius, 6.f));\nconst float ViscLap = 45./(Pi*pow(KernelRadius, 6.f));\n\n\n\nconst int CompPosition\t= 0;\nconst int CompVelocity\t= 1;\nconst int CompDensity\t= 2;\nconst int CompPresure\t= 3;\nconst int CompNum\t\t= 4;\n\n\nconst float Phi \t\t=  (sqrt(5.)*0.5 + 0.5);\n\n\n// https://iquilezles.org/articles/distfunctions2d\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nvec2 rotate(in vec2 v, in float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2  m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nfloat map(in vec2 p, in float t)\n{\n    p = rotate(p, 0.5)*1.12;\n    p = rotate(p, sin(t * 0.2) * 3.);\n    return sdStar5(p, 1.2 * 800., 0.6 ) - 0.1 * 800.;\n}\n\nvec2 normal( in vec2 p, in float t) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec2(map(p + h.xy, t) - map(p - h.xy, t),\n                           map(p + h.yx, t) - map(p - h.yx, t)));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute density & pressure Pass1\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n\n    if(iFrame < 2)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16. - vec2(0, 400.);\n        v = vec2(1);\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n    }\n    \n    // SPH Compute density & pressure\n    \n    float rho = 0.f;\n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r2 = dot(rij, rij);\n\n        if(r2 < KernelRadius * KernelRadius)\n        {\n            // this computation is symmetric\n            rho += PartMass * Poly6 * pow(KernelRadius * KernelRadius - r2, 3.);\n        }\n    }\n    float p = GasConst*(rho - RestDensity);\n    \n    \n     \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute forces, integration + collision pass1\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n    float\trho;\n    float\tp;\n\n    if(false)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16.;\n        v = vec2(1);\n        rho = 0.;\n        p = 0.;\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n        rho\t= Load(pixId, CompDensity).x;\n        p\t= Load(pixId, CompPresure).x;\n    }\n\n    // SPH Compute forces\n    \n\tvec2 f = ExtForce * rho;\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i == pixId)\n            continue;\n\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r = length(rij);\n\n        if(r < KernelRadius)\n        {\n            float partDensity = Load(i, CompDensity).x;\n            // pressureForce\n            f += normalize(-rij) * PartMass * (p + Load(i, CompPresure).x) / (2. * partDensity) * SpikyGrad * pow(KernelRadius-r, 2.);\n \t\t\t// viscosityForce\n            f += Viscosity * PartMass * (Load(i, CompVelocity).xy - v) / partDensity * ViscLap * (KernelRadius - r);\n        }\n    }\n    \n    if(iFrame > 2)\n    {\n        // SPH Integration\n        v += DeltaTime * f / rho;\n        x += DeltaTime * v;\n    }\n   \n    // enforce constraints\n    float d = map(x, iTime) + KernelRadius;\n    vec2  n = normal(x, iTime);\n    if(d > 0.)\n    {\n        x += -d * n;\n        v = reflect(v, n);\n        d = dot(v, n);\n        v -= n * d * ColRestitution;\n    }   \n    \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute density & pressure pass2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n\n    if(iFrame < 2)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16. - vec2(0, 400.);\n        v = vec2(1);\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n    }\n    \n    // SPH Compute density & pressure\n    \n    float rho = 0.f;\n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r2 = dot(rij, rij);\n\n        if(r2 < KernelRadius * KernelRadius)\n        {\n            // this computation is symmetric\n            rho += PartMass * Poly6 * pow(KernelRadius * KernelRadius - r2, 3.);\n        }\n    }\n    float p = GasConst*(rho - RestDensity);\n    \n    \n     \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute forces, integration + collision pass2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n    float\trho;\n    float\tp;\n\n    if(false)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16.;\n        v = vec2(1);\n        rho = 0.;\n        p = 0.;\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n        rho\t= Load(pixId, CompDensity).x;\n        p\t= Load(pixId, CompPresure).x;\n    }\n\n    // SPH Compute forces\n    \n\tvec2 f = ExtForce * rho;\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i == pixId)\n            continue;\n\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r = length(rij);\n\n        if(r < KernelRadius)\n        {\n            float partDensity = Load(i, CompDensity).x;\n            // pressureForce\n            f += normalize(-rij) * PartMass * (p + Load(i, CompPresure).x) / (2. * partDensity) * SpikyGrad * pow(KernelRadius-r, 2.);\n \t\t\t// viscosityForce\n            f += Viscosity * PartMass * (Load(i, CompVelocity).xy - v) / partDensity * ViscLap * (KernelRadius - r);\n        }\n    }\n    \n    if(iFrame > 2)\n    {\n        // SPH Integration\n        v += DeltaTime * f / rho;\n        x += DeltaTime * v;\n    }\n   \n    // enforce constraints\n    float d = map(x, iTime) + KernelRadius;\n    vec2  n = normal(x, iTime);\n    if(d > 0.)\n    {\n        x += -d * n;\n        v = reflect(v, n);\n        d = dot(v, n);\n        v -= n * d * ColRestitution;\n    }   \n    \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}