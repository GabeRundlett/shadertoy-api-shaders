{
    "Shader": {
        "info": {
            "date": "1526770120",
            "description": "Messing around on the weekend... very heavy still, but I like the demoscene-ish look. It started with wanting to play around with 4th order Chmutov Banchoff implicit surfaces... and this came out at the end. Some artefacts remain.",
            "flags": 0,
            "hasliked": 0,
            "id": "XscfW2",
            "likes": 6,
            "name": "wrecking Lipschitz",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "warping",
                "distortion",
                "shadows",
                "reflections"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 778
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"wrecking Lipschitz\" - going overboard with domain-distortions \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 96;\nconst float EPSILON = .0001;\nconst float STEP_SIZE = .4;\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float cy = cos (rad * p.y);\n    float sy = sin (rad * p.y);\n    mat2  my = mat2 (cy, -sy, sy, cy);\n    float cx = cos (rad * p.x);\n    float sx = sin (rad * p.x);\n    mat2  mx = mat2 (cx, -sx, sx, cx);\n    p = mix (vec3 (mx* p.zx, p.y), vec3 (my * p.xy, p.z), .15*cos (p.x));\n\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 6. + 4.*cos (2.*iTime);\n\tresult = .375 * sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n\n    return result;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float radius)\n{\n\treturn length (p) - radius;\n}\n\nfloat sdPlane (in vec3 p, in float height)\n{\n\treturn length (p.y - height);\n}\n\nfloat udBox (in vec3 p, in vec3 size, in float radius)\n{\n\treturn length (max (abs (p) - size, .0)) - radius;\n}\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n\tfloat s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat scene (in vec3 p)\n{\n    float ground = sdPlane (p, -2.);\n\n    vec2 offset = .5 * vec2 (cos (6.28+iTime), sin (6.28+iTime));\n    vec3 p2 = (p + vec3 (-offset.x, offset.y, -1.25));\n    opBend (p2, 45. * cos (.25*iTime));\n    p2.zx *= r2d (50.*iTime);\n    p2.xy *= r2d (-75.*iTime);\n    float dt = sdSphere (p2, .5);\n    float dp = displace (p2);\n    float ball2 = dt + dp;\n\n    p.xz *= r2d (20.*iTime);\n    p.zy *= r2d (-30.*iTime);\n    float x = p.x*.125;\n    float y = p.y*.125;\n    float z = p.z*.125;\n    float fourthOrderChmutovBanchoffSurface = 3. + 8.*(x*x*x*x + y*y*y*y + z*z*z*z) - 8.*(x*x + y*y + z*z);\n    fourthOrderChmutovBanchoffSurface *= .75;\n    ground = opCombine (ground, ball2, 2.5);\n    fourthOrderChmutovBanchoffSurface = opCombine (fourthOrderChmutovBanchoffSurface, ground, .5);\n\n    return fourthOrderChmutovBanchoffSurface;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    float d = scene (p);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd)\n{\n    float d = .0;\n    float t = .0;\n    for (int iter = 0; iter < MAX_ITER; ++iter) {\n        t = scene (ro + d * rd);\n        if (abs(t) < EPSILON*(1. + .125*t)) break;\n        d += t*STEP_SIZE;\n    }\n\n    return d;\n}\n\nfloat shadow (in vec3 p, in vec3 lpos)\n{\n    float distanceToLight = distance (lpos, p);\n    vec3 n = normal (p, distanceToLight*EPSILON);\n    vec3 ldir = normalize (lpos - p);\n    float distanceToObject = raymarch (p + .01 * n, ldir);\n    bool isShadowed = distanceToObject < distanceToLight;\n\n\treturn isShadowed ? .5 : 1.;\n}\n\nvec3 shade (in vec3 p, in vec3 n)\n{\n    vec3 lightPosition1 = vec3 (1.);\n    lightPosition1.xz *= r2d (60.*iTime);\n    vec3 l1 = normalize (lightPosition1 - p);\n    float d1 = distance (p, lightPosition1);\n    float lightIntensity1 = 5.;\n\n \tvec3 lightPosition2 = vec3 (1., 1.*cos (2.*iTime), 1.);\n    lightPosition2.xz *= r2d (20.*iTime);\n    vec3 l2 = normalize (lightPosition2 - p);\n    float d2 = distance (p, lightPosition2);\n    float lightIntensity2 = 3.;\n\n    vec3 diffuseColor1 = vec3 (.9, .8, .7);\n    vec3 diffuseColor2 = vec3 (.7, .8, .9);\n\n    vec3 finalColor1 = max (dot (n, l1), .0) * diffuseColor1 * lightIntensity1 / (d1*d1);\n    vec3 finalColor2 = max (dot (n, l2), .0) * diffuseColor2 * lightIntensity2 / (d2*d2);\n\n    return shadow (p, lightPosition1) * finalColor1 +\n           shadow (p, lightPosition2) * finalColor2;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalize and aspect-correct\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // create viewray\n    vec3 ro = vec3 (.0, .0, -2.);\n    vec3 rd = normalize (vec3 (uv, .0) - ro);\n\n    // primary/view ray\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.01);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (p, n);\n\n\t// secondary/reflection ray\n    vec3 refr = normalize (reflect (rd, n));\n    float refd = raymarch (p + .001*n, refr);\n    vec3 refp = p + refd * refr;\n    vec3 refn = normal (refp, EPSILON);\n    vec3 refc = shade (refp, refn);\n    col += .05*refc;\n\n    // fog, tint, tone-map, gamma-correct\n    col *= fog;\n    col *= vec3 (.95, .8, .75);\n    col = col / (1. + col);\n    col = sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}