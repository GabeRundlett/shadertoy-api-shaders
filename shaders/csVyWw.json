{
    "Shader": {
        "info": {
            "date": "1696572408",
            "description": "An upgrade to my previous shader Peppermint Waterfall, adding a follow cam, wooden shelves, more colors, better motion blur, and more.\n\n*mouse to interact*\n*shift to render shock directions*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "csVyWw",
            "likes": 37,
            "name": "Starlight Mint Cascade",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "simulation",
                "particles",
                "dynamics",
                "tracking",
                "physics"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 421
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Based on FabriceNeyret2's comment on Peppermint Waterfall (this shader's fork parent),\n//  with the idea to follow the particles as they fall, plus a few rendering upgrades. I\n//  figured it needed a new look to be worth of being its own shader, plus it needed more\n//  attention to detail to hold up to zooming in.\n//\n//  I don't know if \"starlight mint\" is exactly the right term for this kind of candy. I\n//  just found an image with google called \"assorted startlight mints\" in roughly these\n//  colors. I thought a few more colors would look nice so I went with it.\n//\n//  Adding the follow cam presented some interesting challenges. It became more important\n//  for the particles to interact well off-screen, so that as the camera moves down, the\n//  particles that come into view are already stacked nicely. But, the particle neighbor\n//  update in Peppermint Waterfall depends on sampling the render voronoi buffer. So I\n//  added a neighbors-of-neighbors search to the particle tracking to give it more power.\n//\n//  The construction of the scene is that the candies are essentially flat, existing only\n//  in the z equals zero plane. Their normals and shading are a purely 2.5D effect. This\n//  makes it easy to locate the particles needed for a ray in the 3D scene, for a\n//  reflection or a shadow, since you just need to compute the ray's z crossing point.\n//\n//  The bumpy reflective wood effect is borrowed from my previous shader:\n//\n//      Flowing Water 3D               https://shadertoy.com/view/clScRG\n//\n//  Which is in turn based on iq's:\n//\n//      Screen space bump mapping      https://shadertoy.com/view/ldSGzR\n//\n//  The motion blur on the candies was another area of improvement. In the previous shader\n//  I just sort of fudged something that looked kinda OK. This time I slowed down and did\n//  a study of this kind of motion blur on its own, which I'm releasing as a companion\n//  shader. See this shader for more explanation of the motion blur effect:\n//\n//      Analytic Radial Motion Blur    https://shadertoy.com/view/msGyzK\n//\n//  The camera follows candy zero...can you figure out which particle that is? Hint: it's\n//  red. An alternate way to reset the shader is to use the mouse input to kick that candy\n//  off the shelves. It's necessary to reset the shader once in a while (it does happen\n//  automatically) because the candies start to get more and more spaced out as the\n//  simulation runs. Unlike Peppermint Waterfall, all the candies are created at the\n//  beginning of the simulation in this one, so nothing is helping to keep them clumped\n//  together.\n//\n//  I struggled with the shadows more than I expected. When w is lower in calcSoftShadow,\n//  really bad banding artifacts develop on the shadows under the shelves, which of course\n//  now we zoom in on. I tried covering it up with noise, but that created other artifacts,\n//  so reducing the umbra ended up being the best option. If anyone knows of a better\n//  solution I'd be excited to hear about it.\n//\n//      *mouse to interact*\n//      *up/down arrows to control zoom*\n//      *shift to render shock directions*\n//      *space to reset*\n//\n//  Buffer A and B perform particle simulation. Only A updates the particle neighbors.\n//  Buffer C computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 LDIR = normalize(vec3(-10, 10, -1)); // light direction\nconst vec3 SHDIR = normalize(vec3(-1, 1, -4.5)); // shadow direction (not the same as the shadow direction)\nconst float THICK = .3; // how wide is the shelf\n\nvec3 marchScene(vec3 p, vec3 rd);\nvoid renderParticles(vec2 p, inout vec4 O);\nvoid renderScene(vec3 hit, vec3 ro, vec3 rd, vec3 ddx_rd, vec3 ddy_rd, inout vec4 O);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    fxGetState();\n    \n    vec2 p = g_State.zoom * (u - .5 * R.xy) / R.y;\n    O = vec4(0);\n\n    // render scene\n    vec3 rd = normalize(vec3(p - vec2(0, 1), 10));\n    vec3 ddx_rd = normalize(vec3(p + vec2(1, 0) / R.x - vec2(0, 1), 10));\n    vec3 ddy_rd = normalize(vec3(p + vec2(0, 1) / R.y - vec2(0, 1), 10));\n\n    vec3 ro = vec3(g_State.cam.x, 1. + g_State.cam.y, -10);\n    vec3 hit = marchScene(ro, rd);\n\n    if (hit.z > 0.) // don't render particles where blocked by a shelf\n        renderParticles(p, O);\n    \n    if (O.a < 1.) // only render shadows where it is not completely blocked by a particle\n        renderScene(hit, ro, rd, ddx_rd, ddy_rd, O);\n\n    O.rgb = pow((O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n\n// From iq's Extrusion and Revolution SDF\n// https://www.shadertoy.com/view/4lyfzw\nfloat opExtrusion(vec3 p, float sdf, float h)\n{\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n// 3D SDF of shelves/wall\nfloat mapScene(vec3 p)\n{\n    float d = opExtrusion(p, sdScene(p.xy, R), THICK);\n    return min(d, THICK - p.z - .1);\n}\n\n// normal of shelves/wall\nvec3 normScene(vec3 p)\n{\n    const vec2 e = vec2(.001, 0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\n// raymarch shelves/wall\nvec3 marchScene(vec3 p, vec3 rd)\n{\n    for (int i = 0; i < 100; ++i)\n    {\n        float d = mapScene(p);\n        if (d < .001) return p;\n        p += rd * d;\n    }\n    return p;\n}\n\n// 3D SDF of particles, for shadow render\nfloat mapParticles(vec3 p)\n{\n    uint id = fxGetClosest(ivec2((p.xy - g_State.cam) * R.y + .5 * R)).x;\n    float d = 1e6;\n    if (id < g_MaxParticles)\n    {\n        fxParticle v = fxGetParticle(id);\n\n        d = length(vec3(v.pos - p.xy, p.z)) - CANDY_R;\n    }\n\n    return d;\n}\n\n// From iq's Soft Shadow Variation\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float maxt, bool par)\n{\n\tfloat res = 1.;\n    float t = mint;\n    float ph = 1e10;\n    const float w = 50.;\n    \n    for (int i = 0; i < 32; i++)\n    {\n\t\tfloat h = mapScene(ro + rd * t);\n        if (par) h = min(h, mapParticles(ro + rd * t)); // only render particles into shadow if rendering background\n     \n        float y = i == 0 ? 0. : h*h/(2.*ph); \n        float d = sqrt(h * h - y * y);\n        \n        res = min(res, w * d / max(0., t - y));\n        ph = h;\n        t += h;\n\n        if (res < .0001 || t > maxt) break;\n    }\n    res = clamp(res, 0., 1.);\n    return res * res * (3. - 2. * res);\n}\n\n// from my Analytic Radial Motion Blur: https://shadertoy.com/view/msGyzK\n\n// analytic motion blur, adding up ramps\n// t - value being rendered\n// a - signal begin\n// b - signal end\n// m - blur amount\nfloat motionBlurAnalytic(float t, float a, float b, float m)\n{\n    float o = ceil(m);\n    \n    float r = 1.;\n    for (float s = -o; s <= o; ++s)\n        r += ramp(b - m, b + m, s + t) - ramp(a - m, a + m, s + t);\n    return r;\n}\n\n// color for a particle\nvec3 particleColor(uint id)\n{\n    switch (id % 5U)\n    {\n        case 0U:\n            return vec3(0.59,0.01,0.05);\n        case 1U:\n            return vec3(0.36,0.16,0.36);\n        case 2U:\n            return vec3(1.00,0.69,0.00);\n        case 3U:\n            return vec3(0.07,0.36,0.02);\n        case 4U:\n            return vec3(1.00,0.29,0.00);\n    }\n}\n\n// render a single particle\nvoid renderParticle(fxParticle p, vec2 u, uint id, inout vec4 O)\n{\n    float e = g_State.zoom / R.y;\n    vec2 del = u - p.pos + g_State.cam;\n    float d2 = length2(del);\n    if (d2 < sqr(CANDY_R + e))\n    {\n        float d = sqrt(d2);\n        float sp = (id & 2U) == 0U ? 1. : -1.; // spiral direction\n        float a = atan(del.y, del.x) + p.r + d / CANDY_R * sp; // stripe angle\n\n        vec3 col = particleColor(id);\n        float blur = abs(p.av) / (PI * 2.) + 15. * g_State.zoom / R.y;\n        float t = abs(mod(a / (2. * PI), .2) -  .1);\n        float m = motionBlurAnalytic(t, .01, .08, blur);\n        \n        col = mix(col, vec3(1), m); // stripes\n        col = mix(col, vec3(1), smoothstep(CANDY_R * .3 + e, 0., d)); // center\n        \n        if (keyDown(KEY_SHIFT)) // debug draw shock directions\n            col = sin(atan(abs(p.sd.y * .1), p.sd.x) + vec3(0, 11, 33)) * .5 + .5;\n\n        del *= smoothstep(CANDY_R * .6, CANDY_R, d); // make flat spot\n        vec3 n = normalize(vec3(del, CANDY_R - sqrt(del.x * del.x + del.y * del.y))); // compute normal\n\n        float sh = calcSoftshadow(vec3(u + g_State.cam, 0), SHDIR, .01, .25, false); // shadow\n        float diff = max(-.2, dot(n, LDIR)) * .4 + .2; // diffuse\n        col *= diff * (.5 * sh + .5); // shadows only darken diffuse\n        \n        vec3 re = reflect(LDIR, n); // reflected\n        vec3 rd = normalize(vec3(u, -1)); // ray dir\n        float spec = pow(max(0., dot(rd, re)), 8.) * sh; // specular\n\n        float alp = smoothstep(CANDY_R + e, CANDY_R - e, d); // alpha\n        if (alp > 1e-6)\n        {\n            O.rgb = mix(O.rgb, col + spec, alp / (alp + O.a)); // weighted average by alpha\n            O.a = max(O.a, alp);\n        }\n    }\n}\n\n// render all the closest particles, called from main render and also for wood reflection\nvoid renderParticles(vec2 p, inout vec4 O)\n{\n    uvec4 ids = fxGetClosest(ivec2(p * R.y + .5 * R));\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = ids[i];\n        if (id >= g_MaxParticles) break;\n        fxParticle v = fxGetParticle(id);\n        renderParticle(v, p, id, O);\n    }\n}\n\n// from iq's Screen space bump mapping: https://www.shadertoy.com/view/ldSGzR\nvec3 doBump(vec3 dpdx, vec3 dpdy, vec3 nor, \n            float dbdx, float dbdy,\n            float scale)\n{\n    vec3  u = cross(dpdy, nor);\n    vec3  v = cross(nor, dpdx);\n    float d = dot(dpdx, u);\n\t\n\tvec3 surfGrad = dbdx * u + dbdy*v;\n    return normalize(abs(d) * nor - sign(d) * scale * surfGrad);\n}\n\n// returns uv + material for the shelves/wall at a 3D position\nvec3 uvmScene(vec3 p, vec3 n, vec2 res)\n{\n    if (p.z > 0. && n.z < 0.) return vec3(p.xy, 0); // wall\n    vec2 u = p.xy;\n    u.y = mod(u.y, .8);\n    vec2 d1 = sdShelf(u.xy, res);\n    vec2 uv = p.xz;\n    u.y = mod(u.y - .4, .8);\n    u.x = -u.x;\n    vec2 d2 = sdShelf(u.xy, res);\n    if (n.z < -abs(n.x) && n.z < -abs(n.y))\n    {\n        if (d1.x < d2.x)\n        {\n            if (d1.y == 0.)\n                return vec3(p.xy * rot2(-.2), 1);\n            else\n                return vec3(p.yx, 1);\n        }\n        else\n        {\n            if (d2.y == 0.)\n                return vec3(p.xy * rot2(.2), 1);\n            else\n                return vec3(p.yx, 1);\n        }\n    }\n    \n    return vec3(uv, 1);\n}\n\nvoid renderScene(vec3 hit, vec3 ro, vec3 rd, vec3 ddx_rd, vec3 ddy_rd, inout vec4 O)\n{\n    // render scene\n    vec3 n = normScene(hit);\n    vec3 uvm = uvmScene(hit, n, R); // uv, material\n\n    vec3 col = vec3(1,.9,.81);\n    vec3 spec = vec3(0);\n    if (uvm.z != 0.)\n    {\n        // render wood\n        const float l = 0.;\n        vec3 mate = texture(iChannel2, uvm.xy, l).xyz;\n\n        vec3 ddx_pos = ro - ddx_rd * dot(ro - hit, n) / dot(ddx_rd, n);\n        vec3 ddy_pos = ro - ddy_rd * dot(ro - hit, n) / dot(ddy_rd, n);\n        vec3 dposdx = ddx_pos - hit;\n        vec3 dposdy = ddy_pos - hit;\n\n        float signal = dot(mate,vec3(.33));\n        vec2 uvx = uvmScene(ddx_pos, n, R).xy / iChannelResolution[2].xy;\n        vec2 uvy = uvmScene(ddy_pos, n, R).xy / iChannelResolution[2].xy;\n        float dsignaldx = dot(texture(iChannel2, uvx, l).xyz, vec3(.33)) - signal;\n        float dsignaldy = dot(texture(iChannel2, uvy, l).xyz, vec3(.33)) - signal;\n\n        n = doBump(dposdx, dposdy, n, dsignaldx, dsignaldy, .003);\n\n        if (hit.z < 0.) // add reflection if we hit the shelf in front of the candies\n        {\n            vec3 rfl = reflect(rd, n);\n            vec2 rfp = hit.xy - hit.z * rfl.xy / rfl.z; // z crossing\n            float fre = 1. - max(dot(n, -rd), 0.); // fresnel\n            fre = pow(fre, 8.);\n            vec4 P = vec4(1, 1, 1, 0);\n            renderParticles(rfp - g_State.cam, P); // render particles for reflection\n            spec = fre * P.rgb * P.a * .3;\n        }\n        col = mate * .4;\n    }\n    \n    float sh = calcSoftshadow(hit, SHDIR, .01, .5, true) * .2 + .3;\n    col = max(0., dot(n, LDIR) * .2 + .2) * vec3(sh) * col + spec * sh;\n    O.rgb = mix(col, O.rgb, O.a);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    particleMain(O, u);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    particleMain(O, u);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const uint IDEAL_MAX_PARTICLES = 1500U; // how many particles to create if there's enough room for them\nconst float CANDY_R = .015; // pappermint radius\nconst float PI = 3.141592653589793;\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 cam;   // camera pos\n    float zoom; // camera zoom\n    float res;  // tracks resolution changes\n    float att;  // timer to resume attract mode (automatic zoom)\n    float avgDt;\n} g_State;\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nvoid fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(0, 1), 0);\n    \n    g_State.cam = data0.xy;\n    g_State.zoom = data0.z;\n    g_State.res = data0.w;\n    g_State.att = data1.x;\n    g_State.avgDt = data1.y;\n}\n\nvec4 fxPutState(vec2 u)\n{\n    if (ivec2(u) == ivec2(0))\n        return vec4(g_State.cam, g_State.zoom, g_State.res);\n    else\n        return vec4(g_State.att, g_State.avgDt, 0, 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0) || ivec2(u) == ivec2(0, 1);\n}\n\n// returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS_VEL 4U\n#define SDAV 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(A, B) fxLocFromIDImpl(int(R.x), A, B)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2(index % width, index / width);\n}\n\nstruct fxParticle\n{\n    uvec4 nbs[4]; // neighbors\n    vec2 pos;     // position\n    vec2 vel;     // velocity\n    vec2 sd;      // shock direction\n    float r;      // rotation\n    float av;     // angular velocity\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDAV), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = floatBitsToUint(particleData0);\n    particle.nbs[1] = floatBitsToUint(particleData1);\n    particle.nbs[2] = floatBitsToUint(particleData2);\n    particle.nbs[3] = floatBitsToUint(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.sd = particleData5.xy;\n    particle.r = particleData5.z;\n    particle.av = particleData5.w;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SDAV:  \n        return vec4(p.sd, p.r, p.av);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\nfloat ramp(float a, float b, float t) { return clamp((t - a) / (b - a), 0., 1.); } // linear smoothstep\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// 2D SDF of walls\nvec2 sdShelf(vec2 p, vec2 res)\n{\n    float d1 = sdBox((p - vec2(-.12 * res.x / res.y,  .3)) * rot2(-.2), vec2(.6, .01));\n    float d2 = sdBox((p - vec2(-.45 * res.x / res.y,  .51)), vec2(.01, .1));\n    if (d1 < d2)\n        return vec2(d1, 0);\n    else\n        return vec2(d2, 1);\n}\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res)\n{\n    // slanted walls\n    p.y = mod(p.y, .8);\n    float d = sdShelf(p, res).x;\n    p.y = mod(p.y - .4, .8);\n    p.x = -p.x;\n    d = min(d, sdShelf(p, res).x);\n    \n    return d;\n}\n\n/// the outward normal of the scene at a point\nvec2 normScene(vec2 p, vec2 res)\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res); \n    float x0 = sdScene(p - d.xy, res); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res); \n    float y0 = sdScene(p - d.yx, res); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAV = vec2(0., -.003);  // gravity\nconst float COLLISION_STIFFNESS = .3; // how fast we correct position errors\nconst float BOUNDARY_ELAS = 1.5;      // elasticity of boundary\nconst float PARTICLE_ELAS = 1.;       // elasticity of particles\nconst float FRIC_COEF = .25;          // Coulomb friction coefficient\n\n// resolve velocity errors against another particle or the boundary\n//\n//  rv   - relative velocity\n//  n    - normal\n//  nav  - neighbor angular velocity\n//  elas - elasticity\n//  lv   - linear velocity\n//  av   - angular velocity\nvoid constraint(vec2 rv, vec2 n, float nav, float elas, inout vec2 lv, inout float av)\n{\n    vec2 t = vec2(n.y, -n.x); // tangent\n    float nv = dot(rv, -n); // normal velocity\n    float ni = elas * max(0., nv); // normal impulse\n    float tv = dot(rv, t) - (av + nav) * CANDY_R; // tangent velocity\n    float fi = clamp(tv, -ni * FRIC_COEF, ni * FRIC_COEF); // friction impulse\n\n    lv += ni * n - fi * t; // apply linear impulse\n    av += fi / CANDY_R;    // apply angular impulse\n}\n\n#define updateParticle(A, B, C) updateParticleImpl(iChannel0, R, iFrame, iMouse, A, B, C)\nvec4 updateParticleImpl(sampler2D par, vec2 res, int iFrame, vec4 iMouse, fxParticle p, uint id, uint dataType)\n{\n    if (iFrame == 0 || g_State.res != res.x * res.y)\n    {\n        vec3 h1 = hash3((id + uvec3(iFrame)) * uvec3(3, 6, 9)) - .5;\n        p.pos = vec2(h1.x, 4. * h1.y );\n        if (id == 0U) p.pos = vec2(0);\n        p.vel = vec2(0);\n        p.sd = vec2(0, 1);\n        p.r = 0.;\n        p.av = 0.;\n    }\n    else\n    {\n        p.vel = p.vel + GRAV * g_State.avgDt; // integrate velocity        \n        p.pos += p.vel; // integrate position\n        p.r += p.av; // integrate rotation\n        p.sd *= .5; // dissipate shock direction\n\n        vec2 imp = vec2(0); // collision linear impulse\n        vec2 nsd = p.sd; // new shock direction\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = p.pos - n.pos;\n                float d2 = length2(dp) + CANDY_R * 1e-4;\n\n                if (d2 < sqr(CANDY_R * 5.))\n                {\n                    nsd += n.sd; // diffuse shock direction\n                    \n                    if (d2 < sqr(CANDY_R * 2.))\n                    {\n                        vec2 dir = dp / sqrt(d2);\n\n                        // position correction (ignore if shock direction disagrees)\n                        if (dot(p.sd, dir) > -.2)\n                            p.pos = mix(p.pos, n.pos + 2. * CANDY_R * dir, COLLISION_STIFFNESS);\n                        \n                        constraint(p.vel - n.vel, dir, n.av, PARTICLE_ELAS, imp, p.av);\n                    }\n                }\n            }\n        }\n\n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd / sqrt(sd2), .9); // record new shock direction\n\n        if (dot(p.sd, imp) < -.2) // resist impulses against the shock direction\n            imp *= .5;\n\n        p.vel += imp; // apply collision impulse\n        \n        // handle mouse input\n        if (iMouse.z > 0.)\n        {\n            vec2 m = g_State.zoom * (iMouse.xy - .5 * res) / res.y + g_State.cam;\n            const float MOUSE_RANGE = .1;\n            if (distance(m, p.pos) < MOUSE_RANGE)\n            {\n                const float MOUSE_STRENGTH = .005;\n                p.vel += (p.pos - m) * MOUSE_STRENGTH;\n            }\n        }\n\n        // handle boundary\n        float ds = sdScene(p.pos, res);\n        if (ds < CANDY_R * 2.)\n        {\n            vec2 n = normScene(p.pos, res);\n            p.sd = n; // seed shock direction\n            \n            if (ds < CANDY_R) // collide with boundary\n            {\n                p.pos -= n * (ds - CANDY_R);\n                \n                constraint(p.vel, n, 0., BOUNDARY_ELAS, p.vel, p.av);\n            }            \n        }\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id >= g_MaxParticles || id == currentId || any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C) voronoiParticleImpl(iChannel0, iChannel1, R, iFrame, A, B, C)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, fxParticle p, uint id, uint dataType)\n{\n    uvec4 clo = uvec4(-1); // closest particles to screen pixel (if on screen)\n    ivec2 sp = ivec2((p.pos - g_State.cam) * res.y + .5 * res); // screen pixel address\n    if (all(lessThan(sp, ivec2(res))) && all(not(lessThan(sp, ivec2(0)))))\n        clo = fxGetClosestImpl(vor, sp);\n        \n    uvec4 bestIds = uvec4(-1);  // new closest particles\n    vec4 bestDists = vec4(1e6); // distances of new closest particles\n\n    if (iFrame > 0)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos); // re-sort previous frame's neighbors\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, clo[i], dataType, p.pos);  // check the screen-space voronoi\n            \n            fxParticle n = fxGetParticleImpl(par, uint(res.x), p.nbs[i][0]); // check the closest neighbors of each closest neighbor\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[0][0], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[1][0], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[2][0], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[3][0], dataType, p.pos);\n        }\n\n        // search randomly a few times too\n        uint iter = 8U;\n        for(uint k = 0U; k < iter; k++)\n        {\n            float h = hash3(uvec3(id + k, id * k, k * uint(iFrame))).x;\n            uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n            sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n        }\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n\n// PARTICLE MAIN\n\n#define particleMain(A, B) particleMainImpl(iChannel0, iChannel1, R, iFrame, iMouse, A, B)\nvoid particleMainImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, vec4 iMouse, out vec4 O, vec2 u)\n{\n    uvec2 ufc = uvec2(u);\n    \n    computeMaxParticlesImpl(res);\n    uint index = ufc.x + ufc.y * uint(res.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticleImpl(par, uint(res.x), id);\n    fxGetStateImpl(vor);\n    \n    if (dataType >= POS_VEL)\n        O = updateParticleImpl(par, res, iFrame, iMouse, p, id, dataType);\n    else\n        O = voronoiParticleImpl(par, vor, res, iFrame, p, id, dataType);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(vec2 u);\nvec4 updateState(vec2 u);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(u);\n    else\n        O = voronoiScreen(u);\n}\n\nvec4 updateState(vec2 u)\n{\n    if (iFrame == 0 || R.x * R.y != abs(g_State.res) || keyDown(KEY_SPACE))\n    {\n        g_State.cam = vec2(0);\n        g_State.zoom = 1.;\n        g_State.res = -R.x * R.y;\n        g_State.att = 0.;\n        g_State.avgDt = 1./60.;\n    }\n    else\n    {\n        g_State.res = abs(g_State.res); // track resolution changes\n        fxParticle p = fxGetParticle(0U);\n        \n        if (p.vel.y < -.6 * g_State.avgDt || p.pos.y < -20.) // reset if particle zero falls\n        {\n            g_State.res = -R.x * R.y;\n            g_State.cam = vec2(0);\n        }\n        else\n        {\n            vec2 c = p.pos; // track particle zero ...\n            c.x = mix(c.x, 0., g_State.zoom); // ... but keep the view centered when zoomed out\n            g_State.cam = mix(g_State.cam, c, .03); // blend to desired camera position\n        }\n        \n        g_State.avgDt = mix(g_State.avgDt, iTimeDelta, .05);\n        \n        // manual zoom\n        if (keyDown(KEY_UP))\n            g_State.zoom *= .99, g_State.att = 5.; \n        if (keyDown(KEY_DOWN))\n            g_State.zoom /= .99, g_State.att = 5.;\n            \n        // attract mode\n        g_State.att = max(0., g_State.att - iTimeDelta);\n        if (g_State.att == 0.)\n            g_State.zoom = mix(g_State.zoom, cos(iTime * .2) * .35 + .65, .02);\n        g_State.zoom = min(1., g_State.zoom);\n    }\n\n    return fxPutState(u);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u - g_State.cam), length2(v.pos - v.vel - u - g_State.cam));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort(new, dis, id, dis2);\n    }\n}\n\nvec4 voronoiScreen(vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n    fxGetState();\n    \n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        const float SEARCH_RANGE = 20.;\n        const int SEARCH_COUNT = 8;\n        for (int i = 0; i < SEARCH_COUNT; ++i)\n        {\n            vec3 h = hash3(uvec3(u, iFrame * 4 + i));\n            sortNbs(fxGetClosest(ivec2(u + vec2((h.xy - .5) * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        vec3 h = hash3(uvec3(u, iFrame * 4));\n        uint id = uint(h.z * float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}