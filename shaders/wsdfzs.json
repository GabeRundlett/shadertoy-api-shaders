{
    "Shader": {
        "info": {
            "date": "1643524685",
            "description": "projecting 2D SDF on ray intersected planes.   The mouse does stuff.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsdfzs",
            "likes": 12,
            "name": "Circles and Lines (kick)",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "kick",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "#define texture texture2D\n#define ut iTime\n#define kPI 3.14159265\n#define khPI 1.57079633\n#define k3qPI 4.71238898\n#define k2PI 6.2831853\n#define kPIi 0.3183089\n#define k2PIi 0.1591549\n#define f(x) fract(x)\n#define l(x) length(x)\n#define c(x,y,z) clamp(x,y,z)\n#define p(x,y) pow(x,y)\n#define r(x) f(sin(x)*100000.0)\n#define n(x) normalize(x)\n#define v3 vec3(0)\n#define S(a,b,x) smoothstep(a,b,x)\n#define SS(x) smoothstep(0.,1.,x)\n#define SC(x,a,b) (smoothstep(0.,1.,(x-a)/(b-a))*(b-a)+a)\n\nfloat smoothMin(float x, float min) {\n  float k = (1.-min);\n  return SS((x - min)/k)*k+min;\n}\nfloat notch(float t, float a, float b, float w ) {\n  return smoothstep(b, b+w, t) + 1. - smoothstep(a-w, a, t );\n}\n\n#define SMin(x,m) smoothMin(x,m)\n#define inf 1e20\n\n#define m vec2(iMouse.xy/iResolution.xy)\n#define m2 (vec2(iMouse.xy/iResolution)*2.-1.)\n#define md ((m - 0.5) * 2.)\n#define time iTime\n\nfloat SCALE = 2.;\nfloat cameraDistance = 1.;\nfloat lineWidth;\n\n#define fill(x,f) (1. - smoothstep(0.,lineWidth*(f),(x)))\n#define stroke(x,f) (1. - smoothstep(0.,lineWidth*(f),abs(x)))\n#define glow(x,f) (1. - pow(smoothstep(0.,(f)*lineWidth,abs(x)),0.2))\n#define aglow(x,f) (1. - (smoothstep(0.,(f)*lineWidth,abs(x))))\n#define fillGlow(x,f) (1. - pow(smoothstep(0.,(f)*lineWidth,(x)),0.2))\n\n// Misc Functions\n\nvoid pR(inout vec2 p,float a) {\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec3 pal(float t) {\n  vec3 a=vec3(0.5,0.5,0.5),\n  b=vec3(0.5),\n  c=vec3(1),d=vec3(0,0.33,0.67);\n\treturn a+b*cos(6.2318*(c*t+d));\n}\n\n// 2D Functions\n\nfloat angle( vec2 p, vec2 c ) {\n  vec2 cp = p-c;\n  float a = atan( cp.y, cp.x );\n  a = mod(a + k2PI, k2PI);\n  return a;\n}\n\nvec2 polar2cart( float theta, float r ) {\n  float c = cos(theta), s = sin(theta);\n  return vec2(c*r, s*r);\n}\n\n// distance to line segment\nfloat sdSegment2( vec2 p, vec2 a, vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// distance between points\nfloat sdPoint2( vec2 p1, vec2 p2 ) {\n  return length( p1 - p2 );\n}\n\nfloat sdCircle( vec2 p, vec2 c, float r ) {\n  vec2 q = p;//-c.xy;\n  q = q-c.xy;\n  float d = length(q);\n  d = d - r;\n  return d;\n}\n\n// 3D Functions\n\nfloat sdPlane( vec3 ro, vec3 rd, vec4 p ) {\n\treturn -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3  co = o - c;\n\tvec3  n = cross(u,v);\n  float t = -dot(n,co)/dot(d,n);\n  float r =  dot(u,co + d*t);\n  float s =  dot(v,co + d*t);\n  return vec3(t,s,r);\n}\n\n// Procedural Textures\n\nfloat chex(vec2 uv)\n{\n  vec2 w = fwidth(uv) + 0.01;\n  vec2 i = 2.0*(abs(f((uv-0.5*w)*0.5)-0.5)-abs(f((uv+0.5*w)*0.5)-0.5))/w;\n  return 0.5 - 0.5*i.x*i.y;\n}\n\n// Shape creators\n\nfloat R = 01.25;\n\nvec4 randomLine( int i ) {\n  float aa = r(float(i)+0.31)*112.9;\n  vec4 l = vec4(r(aa+1.),r(aa+2.1), r(aa+3.8), r(aa+6.7));\n  l = l * 4. - 2.;\n  l *= R;\n  return l;\n}\n\nvec3 randomCircle( int i ) {\n  float aa = r(float(i)*0.001+0.233)*(12.);\n  vec3 c = vec3(-1.+2.*r(aa+1.),-1.+2.*r(aa+2.1),r(aa+3.8)+0.2);\n  c *= R;\n  return c;\n}\n\n/*\n\n WWWWW  WWWWW  WWWWW  WW   W  WWWWW\n W      W      W      W W  W  W\n WWWWW  W      WWW    W  W W  WWW\n     W  W      W      W   WW  W\n WWWWW  WWWWW  WWWWW  W    W  WWWWW\n\n*/\n\nvec2 center1 = vec2(0,0);\nvec2 center2d = vec2(0,-2);\nmat3 plane = mat3(\n  vec3(-1,-1,-1),\n  normalize(vec3(1,0,0)),\n  normalize(vec3(0,1,0))\n);\n\nvec3 sprouts( vec2 p ) {\n  float xRatio = 0.125;\n  float yRatio = 1.1;\n  p = 4. - p;\n  p = polar2cart(p.x*k2PI*xRatio, p.y*yRatio);\n  p = polar2cart(p.y*k2PI*xRatio, p.x*yRatio);\n  p = polar2cart(p.x*k2PI*xRatio, p.y*yRatio);\n  p = polar2cart(p.y*k2PI*xRatio, p.x*yRatio);\n  float a;\n  a = angle(p, center1);\n  a = l(p);\n  float ta = time*0.125;\n  float c = 0.;\n  vec2 q = polar2cart( -ta*k2PI, sin(time)+1.);\n  a = fract(a * k2PIi + ta);\n  a = SS(abs(a*2.-1.));\n  c += a;\n  vec3 col = vec3(c);\n  return col;\n}\n\nvec3 screen( vec3 col1, vec3 col2 ) {\n  return 1. - (1.-col1)*(1.-col2);\n}\n\nvec2 paraline( vec2 a, vec2 b, float t ) {\n  return mix(a,b,t);\n}\n\nfloat slidingGlow( vec2 p, vec4 line, float t ) {\n  float color = 0.;\n  vec2 lp = paraline(line.xy, line.zw, t );\n  float dp;\n  dp = sdPoint2(p,lp);\n  float d = sdSegment2(p, line.xy, line.zw);\n  color += glow(d*dp, 20.);\n  return color;\n}\n\n// float linePoint( vec2 p, vec4 line, float t ) {\n//   float color = 0.;\n//   vec2 lp = paraline(line.xy, line.zw, t );\n//   pR(lp, sin(time*0.7)*line.y);\n//   float dp;\n//   vec2 q = lp - p;\n//   dp = dot(q,q);\n//   color += glow(dp, 20.);\n//   return color;\n// }\n\nfloat doCircle( vec2 p, vec3 c ) {\n  vec2 cp = p-c.xy;\n  float d = dot(cp,cp) - c.z;\n  return glow( d, 50. );\n  // return glow( sdCircle(p, c.xy, c.z), 30. );\n}\n\n#define NUM_CIRCS 8\n#define NUM_LINES 5\n\nvec3 doCircles( vec2 p ) {\n  vec3 color = vec3(0);\n  int i = 0;\n  float d; vec3 c; vec4 l;\n  for( int i=0; i < NUM_CIRCS; i++ ) {\n    c = randomCircle(i);\n    pR(c.xy,time*c.y);\n    c.z *= sin(time*c.z)*0.5+0.7;\n    color = screen(color,doCircle( p, c ) * pal(c.z));\n  }\n  return color;\n}\n\nvec3 doLines( vec2 p ) {\n  vec3 color = vec3(0);\n  float t = sin(time)*0.5+0.5;\n  vec4 l;\n  for( int i=0; i < NUM_LINES; i++ ) {\n    l = randomLine(i);\n    pR(l.xy, time*l.x);\n    pR(l.zw, -time*l.z*0.1);\n    color = screen(color,slidingGlow( p, l, t ) * pal(length(l.xz)));\n  }\n  return color;\n}\n\nvec3 get2dColor( vec2 p ) {\n  p -= center2d;\n  vec3 color = vec3(0);\n  color += doCircles(p);\n  color += doLines(p);\n  // color = screen(color,sprouts(p.yx)*(-0.4+0.5*sin(time*0.33)));\n  return color;\n}\n\nvec3 getRayColor( vec3 ro, vec3 rd ) {\n  vec3 color = vec3(0);\n\n  vec3 pi = intersectCoordSys(ro, rd, plane[0], plane[1], plane[2] );\n  if( pi.x > 0. ) color += get2dColor(pi.zy);\n  pi = intersectCoordSys(ro, rd, plane[0], plane[2].yxz, vec3(0,1,0) );\n  // if( pi.x > 0. ) color = screen(color,get2dColor(pi.yz));\n  if( pi.x > 0. ) color += get2dColor(pi.yz);\n  return color;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nstruct Ray {\n  vec3 ro;\n  vec3 rd;\n};\n\nmat3 camMatrix( vec3 ff ) {\n  ff = normalize(ff);\n  vec3 uu = normalize(cross(ff, vec3(0,1,0)));\n  vec3 vv = cross(uu, ff);\n  return mat3(uu,vv,ff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  pR(plane[2].yz,m.x*k2PI);\n\n  float minD = min(iResolution.x, iResolution.y);\n  lineWidth = (0.0013*SCALE*(600./minD));\n\n  vec2 cartesian = 2.*(fragCoord-iResolution.xy*0.5) / minD;\n  vec2 q = fragCoord/iResolution.xy;\n\n  vec3 target = vec3(0,0,0);\n  vec3 camera = vec3(0,0,1);\n  mat3 cmat = camMatrix(target-camera);\n  float le = 1.;\n  vec3 rd = normalize(vec3(cartesian,le) * cmat);\n\n  // vec3 col = get2dColor( cartesian );\n  vec3 col = getRayColor( camera, rd );\n\n  // dithering\n  col += (1.0/255.0)*hash3(cartesian.x+13.3214*cartesian.y);\n\n  // col *= 1. - texture(u_tex0, q).rgb *0.2;\n  fragColor = vec4(col,1);\n}\n\n// void main() {\n//   mainImage(gl_FragColor, gl_FragCoord.xy);\n//   if( gl_FragCoord.y < 10. ) { gl_FragColor=vec4(pal(gl_FragCoord.x/iResolution.x),1.); }\n// }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}