{
    "Shader": {
        "info": {
            "date": "1541345833",
            "description": "Basic raymarcher.\n\nYou can make the shapes yourself. If you want to fork it, go ahead. Please credit me when you do! :)",
            "flags": 0,
            "hasliked": 0,
            "id": "XtdBDX",
            "likes": 7,
            "name": "Simple raymarching robobo1221",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "shadow",
                "marching",
                "shadows",
                "specular",
                "reflections",
                "depth",
                "geometry",
                "robobo1221",
                "worldspace"
            ],
            "usePreview": 0,
            "username": "robobo1221",
            "viewed": 1085
        },
        "renderpass": [
            {
                "code": "// Basic raymarcher by Robobo1221\n\n#define DO_LIGHTING\n#define REFLECTION\n//#define FOG\n\n// Raymarcher options\nconst int marchSteps = 128;\nconst int refinements = 8;\nconst float farPlane = 10.0;\n\n// Reflection options\nconst int reflectionSteps = 16;\nconst int reflectionRefinements = 8;\nconst float reflectionRayLength = 10.0;\nconst int GlossySteps = 1;\nconst float roughness = 0.0;\nconst float specularF0 = 0.3;\n\n// Lighting options\nvec3 sunDir = normalize(vec3(1.25, 3.0, 4.0));\nconst vec3 sunColor = vec3(1.0);\nconst vec3 ambientColor = vec3(0.25, 0.5, 1.0) * sunColor;\n\nconst float PI \t\t= acos(-1.0);\nconst float TAU \t= PI * 2.0;\nconst float hPI \t= PI * 0.5;\nconst float rPI \t= 1.0 / PI;\nconst float rTAU \t= 1.0 / TAU;\n\nconst float PHI\t\t= sqrt(5.0) * 0.5 + 0.5;\nconst float rLOG2\t= 1.0 / log(2.0);\n\nconst float goldenAngle = TAU / PHI / PHI;\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define bayer32(a)  (bayer16(.5*(a))*.25+bayer2(a))\n#define bayer64(a)  (bayer32(.5*(a))*.25+bayer2(a))\n#define bayer128(a) (bayer64(.5*(a))*.25+bayer2(a))\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n\nmat3 rotate(){\n    vec2 rotationMouse = iMouse.xy / iResolution.xy;\n    \t rotationMouse.x = rotationMouse.x - 0.5;\n    \t rotationMouse.y = rotationMouse.y * 2.0 - 1.0;\n    \t rotationMouse *= vec2(TAU, hPI);\n    \n    mat3 rotatexz = rotationMatrix(vec3(0.0, 1.0, 0.0), rotationMouse.x);\n    mat3 rotatey = rotationMatrix(vec3(1.0, 0.0, 0.0), -rotationMouse.y);\n    \n    return rotatexz * rotatey;\n}\n\nvec3 transform(vec3 p){\n\tvec3 tp = p;\n    \n    tp.y += 1.5;\n    //tp.x += cos(iTime);\n    //tp.z += 2.5;\n    \n    return tp;\n}\n\nvoid calculateShape(vec3 p, out float os){\n    p = transform(p);\n    \n    float height = 1.0 - clamp(max(abs(p.x), abs(p.z - 3.5)), 0.0, 1.0);\n    //float noise = texture(iChannel0, p.xz * 0.5).x * 0.003;\n\n\tos = p.y - height * 2.0;\n}\n\nfloat calculateShape(vec3 p){\n\tfloat os = 0.0;\n    calculateShape(p, os);\n    \n    return os;\n}\n\nvec3 calculateNormal(vec3 p) {\n    const float delta = 0.01;\n    \n    return normalize(vec3(\n        calculateShape(vec3(p.x + delta, p.y, p.z)) - calculateShape(vec3(p.x - delta, p.y, p.z)),\n        calculateShape(vec3(p.x, p.y + delta, p.z)) - calculateShape(vec3(p.x, p.y - delta, p.z)),\n        calculateShape(vec3(p.x, p.y, p.z  + delta)) - calculateShape(vec3(p.x, p.y, p.z - delta))\n    ));\n}\n\nbool calculateRayHit(float os, float rayLength){\n\treturn rayLength > os * rayLength;\n}\n\nbool calculateRayHitInverse(float os, float rayLength){\n\treturn rayLength < os * rayLength;\n}\n\nfloat calculateShadow(vec3 p, vec3 dir, float dither){\n\tconst int steps = 32;\n    const float rayLength = 6.0 / float(steps);\n    \n    vec3 increment = dir * rayLength;\n    vec3 rayPosition = increment * dither + p;\n    \n    float os = 0.0;\n    \n    for (int i = 0; i < steps; ++i, rayPosition += increment){\n\t\tfloat rayLength = length(rayPosition);\n        calculateShape(rayPosition, os);\n        \n        if (calculateRayHit(os + 0.01, rayLength)) return 0.0;\n    }\n    return 1.0;\n}\n\nvec3 calculateReflectedPosition(vec3 p, vec3 dir, float dither, inout bool isRefHit){\n\tconst int steps = reflectionSteps;\n    const float rayLength = reflectionRayLength / float(steps);\n    \n    vec3 increment = dir * rayLength;\n    vec3 rayPosition = increment * dither + p;\n    \n    float os = 0.0;\n    \n    for (int i = 0; i < steps; ++i, rayPosition += increment){\n        isRefHit = true;\n        \n\t\tfloat rayLength = length(rayPosition);\n        calculateShape(rayPosition, os);\n        \n        if (calculateRayHit(os, rayLength)) break;\n        \n        isRefHit = false;\n    }\n    \n    if (!isRefHit) return rayPosition;\n    \n   \tconst float rRefinements = 1.0 / float(reflectionRefinements);\n    \n    increment = -increment * rRefinements;\n    rayPosition = increment * dither + rayPosition;    \n    \n    for (int i = 0; i < refinements; ++i, rayPosition += increment){  \n        float rayLength = length(rayPosition);\n        calculateShape(rayPosition, os);\n        \n        if (calculateRayHitInverse(os, rayLength)) break;\n    }\n    \n    return rayPosition;\n}\n\nvoid rayMarch(vec3 worldVector, out float depth, out vec3 rayPosition, inout bool isRayHit, float dither){    \n    const float rMarchSteps = 1.0 / float(marchSteps);\n    \n    float startDepth = 0.0;\n    float endDepth = farPlane;\n    \n    vec3 increment = (endDepth - startDepth) * worldVector * rMarchSteps;\n    rayPosition = increment * dither + startDepth * worldVector;    \n \n    float os = 0.0;\n    \n    depth = 0.0;\n    \n    for (int i = 0; i < marchSteps; ++i, rayPosition += increment){\n        isRayHit = true;\n        \n        float rayLength = length(rayPosition);\n        calculateShape(rayPosition, os);\n        \n        depth = rayLength;\n        \n        if (calculateRayHit(os, rayLength)) break;\n        \n        isRayHit = false;\n    }\n   \t\n    if (!isRayHit) return;\n    \n   \tconst float rRefinements = 1.0 / float(refinements);\n    \n    increment = -increment * rRefinements;\n    rayPosition = increment * dither + rayPosition;    \n    \n    for (int i = 0; i < refinements; ++i, rayPosition += increment){  \n        float rayLength = length(rayPosition);\n        calculateShape(rayPosition, os);\n        \n        depth = rayLength;\n        \n        if (calculateRayHitInverse(os, rayLength)) break;\n    }\n}\n\nvec3 getAlbedo(vec2 p){\n\treturn texture(iChannel1, p).rgb;\n}\n\nvec3 calculateSky(vec3 vec){\n    \n    float vDotL = distance(vec, sunDir);\n    vec3 sun = smoothstep(0.03, 0.026, vDotL) * sunColor * 10.0;\n    \n\t//return texture(iChannel2, vec).rgb;\n    return mix(ambientColor, sunColor, exp2(-abs(vec.y) * 5.0)) + sun;\n}\n\nfloat calculateFresnel(float vDotN, float f0){\n\treturn pow(1.0 - vDotN, 5.0) * (1.0 - f0) + f0;   \n}\n\nvec3 calculateFog(vec3 color, vec3 worldPosition){\n\t#ifndef FOG\n    \treturn color;\n    #endif\n    \n    float fogFactor = exp2(-length(worldPosition) * 0.25);\n    vec3 fog = mix(sunColor, ambientColor, sqrt(fogFactor));\n    \n   \treturn mix(fog, color, fogFactor);\n}\n\nvec3 calculateDirectLighting(vec3 diffuseColor, vec3 worldPosition, vec3 worldVector, vec3 worldNormal, float dither){\n    float shadow = calculateShadow(worldPosition, sunDir, dither);\n    float diffuse = clamp(dot(worldNormal, sunDir), 0.0, 1.0);\n          diffuse = sqrt(diffuse);\n    \n    vec3 totalLighting = sunColor * shadow * diffuse;\n    \t totalLighting += mix(sunColor, ambientColor, 0.75) * (1.0 / hPI);\n    \t totalLighting *= diffuseColor;\n    \n    return totalLighting;\n}\n\nvec3 hash3( vec2 p ){\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nvec3 calculateRoughSpecular(const float i, const float alpha2, const int steps) {\n\n    float x = (alpha2 * i) / (1.0 - i);\n    float y = i * float(steps) * 64.0 * 64.0 * goldenAngle;\n\n    float c = inversesqrt(x + 1.0);\n    float s = sqrt(x) * c;\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\nvec3 calculateSpecularLighting(vec3 color, vec3 diffuseColor, vec3 worldPosition, vec3 worldVector, vec3 worldNormal, float dither, vec2 texcoord){\n\tconst float alpha2 = roughness * roughness * roughness * roughness;\n    \n    #ifndef REFLECTION\n    \treturn color;\n    #endif\n    \n    bool isRefHit = false;\n    \n    const int specSteps = GlossySteps;\n    const float rSpecSteps = 1.0 / float(specSteps);\n    \n    vec3 c0 = cross(worldNormal, vec3(0.0, 0.0, 1.0));\n    vec3 c1 = cross(worldNormal, vec3(0.0, 1.0, 0.0));\n    \n    vec3 tangent = length(c0) > length(c1) ? c0 : c1;\n    \n    mat3 tbn = mat3(tangent, cross(worldNormal, tangent), worldNormal);\n    \n    float specularOffset = dither * rSpecSteps;\n    \n    vec3 total = vec3(0.0);\n    \n    for (int i = 0; i < specSteps; ++i) {\n    \n    vec3 offset = calculateRoughSpecular((float(i) + specularOffset) * rSpecSteps, alpha2, specSteps);\n    vec3 halfVector = tbn * offset;\n        \n    vec3 reflectedVector = normalize(halfVector * 2.0 * dot(-worldVector, halfVector) + worldVector);\n    vec3 reflectionPosition = calculateReflectedPosition(worldPosition, reflectedVector, dither, isRefHit);\n    vec3 transformedRefPos = transform(reflectionPosition);\n\n    vec3 reflectedNormal = calculateNormal(reflectionPosition);\n    vec3 reflectDiffuseColor = getAlbedo(transformedRefPos.xz);\n\n    vec3 totalReflection = calculateDirectLighting(reflectDiffuseColor, reflectionPosition, reflectedVector, reflectedNormal, dither);\n\t\t totalReflection = calculateFog(totalReflection, reflectionPosition);\n    \t totalReflection = !isRefHit ? calculateSky(reflectedVector) : totalReflection;\n    \n    total += totalReflection;\n    }\n    \n    total *= rSpecSteps;\n        \n    float vDotN = clamp(dot(-worldVector, worldNormal), 0.0, 1.0);\n    float fresnel = calculateFresnel(vDotN, specularF0);\n    \n    return color * (1.0 - fresnel) + total * fresnel;\n}\n\nvec3 calculateImage(vec3 diffuseColor, vec3 worldPosition, vec3 worldVector, vec3 worldNormal, float dither, bool isSky, vec2 texcoord){\n\tif (isSky) return calculateSky(worldVector);\n    vec3 color = vec3(0.0);\n    \n    vec3 directLighting = calculateDirectLighting(diffuseColor, worldPosition, worldVector, worldNormal, dither);\n    color = directLighting;\n    \n    vec3 specularLighting = calculateSpecularLighting(color, diffuseColor, worldPosition, worldVector, worldNormal, dither, texcoord);\n    color = specularLighting;\n    \n    color = calculateFog(color, worldPosition);\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float depth;\n    \n    vec2 texcoord = fragCoord/iResolution.xy;\n    vec3 worldVector = normalize(vec3(texcoord * 2.0 - 1.0, 1.0));\n    \n    if (iMouse.x > 1.0) {\n        mat3 rotationMat = rotate();\n        worldVector = rotationMat * worldVector;\n    }\n    \n    vec3 color = vec3(0.0);\n    vec3 rayPosition;\n    \n    bool isRayHit = false;\n    \n    float dither = bayer16(fragCoord.xy);\n    \n    rayMarch(worldVector, depth, rayPosition, isRayHit, dither);  \n   \tvec3 transformed = transform(rayPosition);\n    \n    bool isSky = !isRayHit;\n    \n    vec3 worldNormal = calculateNormal(rayPosition);\n    \n    #ifdef DO_LIGHTING\n    \t// iChannel1 is the albedo texture for the lighting\n    \tvec3 albedo = getAlbedo(transformed.xz);\n    \n        color = calculateImage(albedo, rayPosition, worldVector, worldNormal, dither, isSky, texcoord);\n    \n        color = pow(color, vec3(4.4));\n        color /= color + 1.0;\n        color = pow(color, vec3(1.0 / 4.4));\n    \n    #else\n\n        color = vec3(exp2(-(transformed.y - 1.75) * 0.4)) * (1.0 - exp2(-length(rayPosition) * 0.5));\n\t\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}