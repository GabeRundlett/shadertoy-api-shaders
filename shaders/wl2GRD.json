{
    "Shader": {
        "info": {
            "date": "1558722643",
            "description": "A fluctuating Mandelbulb that changes color and power.",
            "flags": 0,
            "hasliked": 0,
            "id": "wl2GRD",
            "likes": 2,
            "name": "Fluctuating Mandelbulb",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "shanedonburke",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "float MinimumDistance = 0.0001;\nint MaxRaySteps = 1000;\nint Iterations = 100;\nfloat Bailout = 50.0;\nfloat Power =9.0;\nvec3 camPos = vec3(0, 0, 0);\nfloat depth = 1.0;\n\nconst vec3 red = vec3(1.0, 0.4, 0.4);\nconst vec3 orange = vec3(0.4, 0.0, 1.0);\nconst vec3 violet = vec3(0.0, 1.0, 0.0);\n\nfloat fsample[3] = float[3](0.0, 0.5, 1.0);\nvec3 csample[3] = vec3[3](red, orange, violet);\n\nvec3 lightPos = vec3(0.0, 0.0, 0.0);\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst float lightPower = 3.0;\nconst vec3 ambientColor = vec3(0.1, 0.0, 0.0);\nconst vec3 diffuseColor = vec3(0.5, 0.0, 0.0);\nconst vec3 specColor = vec3(1.0, 1.0, 1.0);\nconst float shininess = 1.0;\nconst float screenGamma = 1.0; // Assume the monitor is calibrated to the sRGB color space\n\nfloat coeff1 = 0.0;\nfloat coeff2 = 0.5;\nfloat coeff3 = 1.0;\n\nfloat DE(in vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn min(0.5*log(r)*r/dr, 0.05);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 findNormal(vec3 pos) {\n    vec3 xDir = vec3(0.1, 0.0, 0.0);\n    vec3 yDir = vec3(0.0, 0.1, 0.0);\n    vec3 zDir = vec3(0.0, 0.0, 0.1);\n\tvec3 n = normalize(vec3(DE(pos+xDir)-DE(pos-xDir),\n\t\t                DE(pos+yDir)-DE(pos-yDir),\n\t\t                DE(pos+zDir)-DE(pos-zDir)));  \n    return n;\n}\n\nvec3 floatToRGB(float val) {\n    if (abs(val - fsample[0]) < 0.1) {\n        return val * csample[0];\n    } else if (val == fsample[1]) {\n        return csample[1];\n    } else if (val == fsample[2]) {\n        return csample[2];\n    } else {\n        vec3 rgb = (coeff1 * val * csample[0] + coeff2 * val * csample[1] + coeff3 * val * csample[2]) / 6.0;\n        if (val > 0.500035) {\n           // rgb = rgb - vec3(0.1, 0.1, 0.0) * 0.1;\n        }\n        return vec3(val, val, val) / 5.0;\n    }\n            \n}\n\nvec4 trace(vec3 from, vec3 direction, float minDist) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n    vec3 p;\n    float minDistance = minDist;\n    float distance = 10000000.0;\n    int count = 0;\n    for (steps=0; steps < MaxRaySteps; steps++) {\n            p = from + totalDistance * direction;\n            distance = DE(p);\n            totalDistance += distance;\n        \tif (distance > Bailout) break;\n            if (distance < minDistance) break;\n        }\n    \n    vec3 normal = findNormal(p);\n        vec3 lightDir = lightPos - p;\n    float lightDistance = length(lightDir);\n    \n    float lambertian = max(dot(lightDir,normal), 0.0);\n  \tfloat specular = 2.0;\n    \n    if(lambertian > 0.0) {\n\n        vec3 viewDir = normalize(from-p);\n\n        // this is blinn phong\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, shininess);\n\n  \t}\n    float val;\n    if (steps == MaxRaySteps) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n    \tval = (1.0 - float(steps) / float(MaxRaySteps));\n    }\n    val = pow(val*2.0, 0.0001) / 2.0;\n    vec3 colorLinear = floatToRGB(val) * lightPower / pow(lightDistance, 3.0);\n    colorLinear = colorLinear * val / 0.7;\n\n    return vec4(colorLinear, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Power = sin(iTime / 5.0) * 3.0 + 6.0;\n    coeff1 = sin(iTime / 2.5) / 2.0 + 1.0;\n    coeff2 = sin(iTime / 1.5) / 2.0 + 1.0;\n    coeff3 = sin(iTime / 3.5 + 2.0) / 2.0 + 1.0;\n\n\n    vec3 dir = rayDirection(50.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(-0.0, 0.0, 5.0);\n\tfragColor = trace(eye, dir, MinimumDistance);  \n    if (fragColor == vec4(0.0, 0.0, 0.0, 0.0)) {\n        fragColor = trace(eye / 2.7, dir, MinimumDistance);\n    }\n\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}