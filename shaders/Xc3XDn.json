{
    "Shader": {
        "info": {
            "date": "1713766524",
            "description": "display hh:mm:ss:ff based on system clock",
            "flags": 0,
            "hasliked": 0,
            "id": "Xc3XDn",
            "likes": 2,
            "name": "Sunset vibes",
            "published": 3,
            "tags": [
                "counter",
                "framecounter"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "// Fork of \"sunnydancingwobble\" by SwagLordLancalot. https://shadertoy.com/view/sd2fRt\n// 2024-04-22 06:14:21\n\n\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel1, p/256.0, -100. ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel1, p/256.0, -100. ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel1, p/256.0, -100. ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel1, p/256.0, -100. ).x;\n    return f/0.9375;\n}\n\nvec2 map (in vec3 p) {\n\tfloat mountains = 19. * fbm(p.xz*0.091);\n    float trees = -.35 * fbm(p.xz*10.);\n    float rocks = -.002 * fbm(p.xz*100.);\n    float result = p.y + mountains + trees; // + rocks;\n    \n    return vec2(result, 1.0);\n}\n\nvec3 mapColour (in vec3 pos, in vec3 nor) {    \n    float darken = (1.0 - 0.5 * length(normalize(pos)));\n\tvec3 tint = vec3(.7, .7, .6);\n    vec3 texture = texture( iChannel2, 0.006125*pos.xz, -100. ).xyz;\n    \n    return  texture * tint;\n}\n\nvec2 raymarch (in vec3 ro, in vec3 rd) {\n    vec2 h = vec2(0.001, 0.);\n    float t = 0.;\n    float tmax = 100.;\n    \n    for (int i = 0; i < 100; i++){\n        if (abs(h.x) < 0.001*t || t > tmax) break;\n        h = map(ro + t * rd);\n        t += 0.25 * h.x;\n    }\n    \n    if(t > tmax) h.y = -1.;\n    \n    return vec2(t, h.y);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {       \n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, maxt*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    // show more detail the closer we are to the object\n    vec3  eps = vec3(0.002 * t,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\n\nint bcd(int i) // 0 - 99\n{\n    return (i/10*6+i);\n}\n\nfloat digit(vec2 uv, int i)\n{\n    const float doff=12./16.;\n    \n    return texture(iChannel0,uv/16.+vec2(float(i)/16.,doff)).x;\n}\n\nvoid draw_digit(inout float c, vec2 uv, int i)\n{\n    if(abs(uv.x)<.5 && abs(uv.y) < .5)\n    {\n        c = max(c,digit(uv+.5,i));\n    }\n}\n\nvoid draw_bcd(inout float c, vec2 uv, int i)\n{\n    draw_digit(c, uv,(i&0xf0)>>16);\n    draw_digit(c, uv-vec2(.5,0),(i&0xf));\n}\n\n#define FRAME_RATE 50.\n\n\nfloat draw_time(vec2 uv, vec2 o, float size)\n{\n    float c = 0.;\n    uv=(uv-o)/size - vec2(.25,-.5);\n    \n    int hour = bcd(int(iDate.w/3600.));\n    int minute = bcd(int(mod(iDate.w,3600.)/60.));\n    int second = bcd(int(mod(iDate.w,60.)));\n    \n    int pal_frame = bcd(int(fract(iDate.w)*FRAME_RATE));\n\n    draw_bcd(c,uv,hour);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,minute);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,second);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,pal_frame);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    float osc = sin(time*2.);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv ;\n    vec2 vw = p - vec2(0.5+0.1*sin(time));\n    vec2 q = vw;\n    \n    vec2 sp = fragCoord/iResolution.xy;\n\tvec2 sq = sp - vec2(0.3,0.7);\n    vec2 q2 = sp - vec2(0.8,0.5);\n    vec3 colo = vec3(0); //mix( vec3(1.,0.3,0.3), vec3(0.3,0.6,.9), p.y );\n   \n    // palm 1\n    float r2 = 0.3 + 0.2*cos( atan((sq.y+q.y),(sq.x+q.x))*10.0 +20.*(sq.x+q.x)+2.*(sq.y+q.y) );\n    colo = vec3(smoothstep(r2,r2+0.01,length( sq + q - vec2(-0.2,-0.1))));\n    \n    r2 = 0.024; \n    r2 += 0.001*cos(100.*(sq.y+q.y));\n    r2 += exp(-40.*(sp.y+p.y));\n    float we = smoothstep(r2,r2,abs(-0.1+ sq.x -0.25*sin(2.*sq.y+q.y) ));\t// tronco\n    colo *= 1.-(1.-we)*(1.-smoothstep(0.,0.001,sq.y+q.y));\t// borra parte de arriba del tronco\n    \n    // palm 2\n    \n    q2.y += 0.02*(1.+osc);\n    r2 = 0.15 + 0.1*cos( atan(q2.y,q2.x)*8. +10.*(q2.x+q.x) +(q2.x-q.x));\n    colo *= smoothstep(r2,r2,length( q2 ));\n    \n    r2 = 0.008; \n    r2 += 0.0013*cos(250.*(q2.y));\n    r2 += exp(-80.*sp.y);\n    we = smoothstep(r2,r2+0.01,abs( q2.x  ));\t// tronco\n    colo *= 1.-(1.-we)*(1.-smoothstep(0.,0.01,q2.y));\t// borra parte de arriba del tronco\n    \n  \tvec2 qq = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0 * qq;\n    pp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\n    // camera\n\tfloat an1 = -6.2831*mo.x + iTime*.2; //0.2*iTime-6.2831*mo.x;\n\tfloat an2 = 0.8; //clamp( 0.8 + 0.6*sin(2.2+iTime*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 10.0*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1) ));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( pp.x*uu + pp.y*vv - 1.4*ww );\n\n    // raymarch\n    vec3 col2 =  vec3(0.);//texture( iChannel0, rd ).xyz;\n    vec2 march = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(0.9, 0.1, 0.9));\n    vec3 ambient = 5. * vec3(0.1, 0.15, 0.2);\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n    vec3 pos = ro + march.x * rd;\n    \n    // sky\n  {\n        // sky colour        \n        vec3 blueSky = vec3(0.3,.55,0.8);\n        vec3 redSky = vec3(0.8,0.8,0.6);\n        \n        vec3 sky = mix(blueSky, redSky, 1.5*pow(sundot, 8.));\n        \n        col2 =  sky*(1.0-0.8*rd.y);\n        \n        // stars\n        float s = texture( iChannel1, rd.xz * 1.25, -100. ).x;\n        s += texture( iChannel1, rd.xz* 4., -100. ).x;\n        \n        s = pow(s, 17.0) * 0.00005 * max(rd.y, -0.2) * pow((1. - max(sundot, 0.)), 2.); \n        if (s > .0)\n        {\n            vec3 backStars = vec3(s);\n            col2 += backStars;\n        }\n        \n        // sun\n        col2 += 0.1*vec3(0.9, 0.3, 0.9)*pow(sundot, 0.5);\n        col2 += 0.2*vec3(1., 0.7, 0.7)*pow(sundot, 1.);\n        col2 += 0.95*vec3(1.)*pow(sundot, 256.);\n        \n        // clouds\n        float cloudSpeed = 0.01;\n        float cloudFlux = 0.5;\n        \n        // layer 1\n        vec3 cloudColour = mix(vec3(1.0,0.95,1.0), 0.35*redSky,pow(sundot, 2.));\n        \n\t\tvec2 sc = cloudSpeed * 50.*iTime * ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n\t\tcol2 = mix( col2, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n        \n        // cloud layer 2\n        sc = cloudSpeed * 30.*iTime * ro.xz + rd.xz*(500.0-ro.y)/rd.y;\n\t\tcol2 = mix( col2, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0002*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n        \n        // horizon        \n        col2 = mix( col2, 0.9*vec3(0.9,0.75,0.8), pow( 1.-max(rd.y+0.1,0.0), 8.0));\n        \n        \n    }\n    // contrast\n\n    \n    // saturation (amplify colour, subtract grayscale)\n    float sat = 0.3;\n    col2 = col2 * (1. + sat) - sat*dot(col2, vec3(0.33));\n    \n    // vignette\n    col2 = pow(col2,vec3(2.3)) * (1.0 - dot(p, p) * 0.2);\n    \n   vec3 col =  vec3(0); //pow(col,vec3(0.6)); //pow(col2,vec3(4.)) + mix(vec3(1.0,0.0,1.0) , vec3(0.0,0.0,0.3) , sqrt(p.y) ) ;\n\n    r2 = 0.3 + 0.2*cos( atan((sq.y+q.y),(sq.x+q.x))*10.0 +20.*(sq.x+q.x)+2.*(sq.y+q.y) );\n    colo *= vec3(smoothstep(r2,r2+0.01,length( sq + q - vec2(-0.2,-0.1))));\n    \n    sq.x -= 0.34;\n    \n    r2 = 0.011; //+ 0.01*cos(10.*q.x);\n    r2 += 0.2 + 0.1*cos(atan(sq.y,5.0*sq.x)*20.0 + 10.0*sq.x + osc + 3.0*time);\n    r2 += exp(-50.*(sp.y));\n    colo *= smoothstep(r2,r2,length(sq));\t// borra parte de arriba del tronco\n    \n    r2 = 0.011;\n    r2 += 0.001*cos(200.*sq.y);\n    r2 += exp(-40.*(sp.y+p.y));\n    we = smoothstep(r2,r2+0.001,abs( sq.x + 0.05*sin(2.*sq.y)  ));\t// tronco\n    colo *= 1.-(1.-we)*(1.-smoothstep(r2,r2,sq.y));\t// borra parte de arriba del tronco\n \n \n    col =  col2 * colo + (1.-colo)*(1.-col2)*vec3(0.137,0.106,0.259)*sp.y;\n   \n\n   // Output to screen\n\n    fragColor = vec4(col,0.1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}