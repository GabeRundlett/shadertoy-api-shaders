{
    "Shader": {
        "info": {
            "date": "1611148077",
            "description": "Flying through f = sin x + sin y + sin z.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtKcWm",
            "likes": 9,
            "name": "3D Sinusoid",
            "published": 3,
            "tags": [
                "raymarch",
                "cube",
                "sin",
                "hsv"
            ],
            "usePreview": 0,
            "username": "darkeclipz",
            "viewed": 437
        },
        "renderpass": [
            {
                "code": "mat2 rotate(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co, si, -si, co);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 id = vec3(0);\nfloat map(in vec3 p) {\n    float scale = 40.;\n    p *= scale;\n    vec3 pmod = mod(p, 2.0) - 1.; \n    vec3 pint = p - pmod;\n    id = pint;\n    float period = 6.;\n    float t = (iTime + 9.24) * 2.;\n    float size = (sin(period*pint.x + t) \n               +  sin(period*pint.y + t) \n               +  sin(period*pint.z)) \n               * 0.5;\n    float roundness = 0.05;\n    pmod.xz *= rotate(size);\n    float sizeBox = size * 2. * (0.5 - roundness);\n    float box = sdBox(pmod, vec3(sizeBox)*.5) - roundness;\n    return box/scale;\n\n}\n\n#define MIN_MARCH_DIST 0.0001\n#define MAX_MARCH_DIST 40.\n#define MAX_MARCH_STEPS 60.\nfloat march(in vec3 ro, in vec3 rd) {\n    float t = 0.4, // don't render too close to camera\n          i = 0.;\n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if(abs(d) < MIN_MARCH_DIST)\n            break;\n        t += d;\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 shade(vec3 N, vec3 L, vec3 V, vec3 diffuse, vec3 specular) {\n    return diffuse * clamp(dot(L, N), 0., 1.)       // Lambertian Diffuse\n         + specular * brdf_ggx(N, V, L, 0.55, 0.1); // GGX Specular\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera\n    vec3 ro = vec3(0,0,-1.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    float time = (iTime + 9.24) * 0.1;\n    rd.zx *= rotate(time);\n    ro.z += time;\n    ro.y += time;\n    \n    // March\n    float t = march(ro, rd);\n    \n    // Shade\n    vec3 col = vec3(0);\n    if(t < MAX_MARCH_DIST) {\n        vec3 P = ro + t*rd;             \n        vec3 N = normal(P);                \n        vec3 V = normalize(ro - P); \n        vec3 ambient = vec3(.06);\n        vec3 diffuse = hsv2rgb(vec3(fract(length(id) / 80. + time * 0.2), 1., 1.));\n        vec3 specular = vec3(.9);      \n        vec3 tangent = cross(V, vec3(0,1,0));\n        col =       shade(N, normalize(ro-P+tangent*0.03), V, diffuse, specular)\n            + 0.3 * shade(N, normalize(P-ro+tangent*0.2), V, diffuse, specular)  \n            + ambient;                                               \n        col *= clamp(exp(-0.20*(t-0.2)), 0., 1.);                       \n    }\n    \n    fragColor = vec4(pow(col, vec3(2.2)),1.0); // Gamma correction\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}