{
    "Shader": {
        "info": {
            "date": "1522562347",
            "description": "Based on Dave_Hoskins 's [url=https://www.shadertoy.com/view/4d2Xzw]shader[/url] with fewer iterations needed (only 32 vs 150) by rotating the samples temporally; and applying a simple temporal antialiasing filter.",
            "flags": 32,
            "hasliked": 0,
            "id": "4dycRV",
            "likes": 11,
            "name": "Temporal Bokeh disc",
            "published": 3,
            "tags": [
                "2d",
                "blur",
                "bokeh",
                "temporal"
            ],
            "usePreview": 0,
            "username": "ming",
            "viewed": 1112
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Bokeh disc.\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The Golden Angle is (3.-sqrt(5.0))*PI radians, which doesn't precompiled for some reason.\n// The compiler is a dunce I tells-ya!!\n#define GOLDEN_ANGLE 2.39996\n\n#define ITERATIONS 32\n#define BOKEH_SIZE .6\n\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//-------------------------------------------------------------------------------------------\n#define W0 0.5545497\n#define W1 0.308517\n\n\n// as is this will start to show defects outside of\n// the interval [-2048, 2048]\nfloat hash(in vec2 c)\n{\n  float x = c.x*fract(c.x * W0);\n  float y = c.y*fract(c.y * W1);\n\n  // NOTICE: as is - if a sampling an integer lattice\n  // any zero input will cause a black line in that\n  // direction. \n  return fract(x*y);\n}\n\n\n//-------------------------------------------------------------------------------------------\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, vec2 fragCoord)\n{\n\tvec3 acc = vec3(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    \n    // rotate the initial vangle with time\n    float t = hash(fragCoord) / 8. + iTime / 16.;\n    mat2 rot2 = mat2(cos(t), sin(t), -sin(t), cos(t));\n    vangle = rot2 * vangle;\n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n\t    vangle = rot * vangle;\n        vec3 col = texture(tex, uv + (r-1.) * vangle).xyz; /// ... Sample the image\n        col = col * col *1.8; // ... Contrast it for better highlights - leave this out elsewhere.\n\t\tvec3 bokeh = pow(col, vec3(4));\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.x; //... with correct aspect ratio\n    \n    float time = mod(iTime*.2 +.25, 3.0);\n    \n\tfloat rad = BOKEH_SIZE - BOKEH_SIZE * cos(time * 6.283);\n    if (iMouse.w >= 1.0)\n    {\n    \trad = (iMouse.x/iResolution.x)*3.0;\n\n    }\n    \n    if (time < 1.0)\n    {        \n\t\tfragColor = vec4(Bokeh(iChannel0, uv, rad, fragCoord), 1.0);\n    }else\n    if (time < 2.0)\n    {\n        fragColor = vec4(Bokeh(iChannel1, uv, rad, fragCoord), 1.0);    \n    }else\n    {\n\t\tfragColor = vec4(Bokeh(iChannel2, uv, rad, fragCoord), 1.0);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// TAA Pass borrowed from Enscaoe Cube (https://www.shadertoy.com/view/4dSBDt)\n// Use Firefox to view it!!\n\n//#define NO_AA\n//#define NO_YCOCG\n#define SMOOTHNESS 0.9999\n\nivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n#ifndef NO_YCOCG\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n#else\n    return RGB;\n#endif\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n#ifndef NO_YCOCG\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n#else\n    return YCoCg;\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime*.2 +.25, 3.0);\n    \n\tfloat lod = ((cos(time * 6.283) * .5 + .5));\n    lod = 1. - pow(1. - lod, 2.);\n    lod *= 2.;\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, lod).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, lod).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, SMOOTHNESS)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}