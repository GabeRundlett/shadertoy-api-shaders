{
    "Shader": {
        "info": {
            "date": "1530103670",
            "description": "Click and drag to rotate.",
            "flags": 32,
            "hasliked": 0,
            "id": "XsKBzt",
            "likes": 19,
            "name": "Bumpy Earth",
            "published": 3,
            "tags": [
                "raymarching",
                "displacement",
                "texture",
                "earth",
                "bumpmapping",
                "image",
                "surface",
                "globe"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 985
        },
        "renderpass": [
            {
                "code": "#define EPSILON 1e-4\n\n#define PI 3.14159265359\n\nfloat bump(vec3 p) {\n    float lat = 90. - acos(p.y / length(p)) * 180./PI;\n    float lon = atan(p.x, p.z) * 180./PI;\n    vec2 uv = vec2(0.5 + lon/360., 0.5 + lat/180.);\n    vec4 c = texture(iChannel0, uv * vec2(144,72)/iResolution.xy);\n    float land = 1. - clamp(c.b - c.r + 3. * fbm(32. * uv), 0., 1.);\n    float height = land + 3. * c.r/0.31;\n    return height;\n}\n\nfloat earth(vec3 p) {\n    return min(length(p) - 1. - 0.02 * bump(p), 30. - length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float lat = 45. * sin(0.1 * (iTime + 46.));\n    float lon = 0.05 * (iTime + 46.) * 360.;\n    if (iMouse.z > 0.) {\n        lat = 90.  - 180. * iMouse.y/iResolution.y;\n        lon = 180. - 360. * iMouse.x/iResolution.x;\n    }\n    vec3 camPos = 2. * vec3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));\n    vec3 w = normalize(-camPos);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = normalize(cross(u, w));\n    mat3 camera = mat3(u, v, w);\n    vec3 rayDirection = camera * normalize(vec3(p.xy, 1.5));\n    float rayDistance = 0.;\n    vec3 hitPos;\n    for (int i = 0; i < 200; i++) {\n        hitPos = camPos + rayDirection * rayDistance;\n        float r = earth(hitPos);\n        if (abs(r) < EPSILON) break;\n        rayDistance += r;\n    }\n    float height = bump(hitPos);\n    if (height > 0.5) fragColor = vec4(1. - 0.1 * clamp(floor(1.5 * height), 0., 4.));\n    if (rayDistance > 5.) fragColor = 0.25 + 0.5 * fragColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// auto-generated by https://github.com/rkibria/img2shadertoy\nconst vec2 bitmap_size = vec2(160, 72);\nconst int[] palette = int[] ( 0x00010502, 0x00060a07, 0x000c100e, 0x00111412, 0x00151816, 0x00191b1a, 0x001e211f, 0x00252725, 0x002c2e2c, 0x002f3230, 0x00323533, 0x00363937, 0x003c3e3c, 0x00414442, 0x00515452, 0x00ffff00 );\nconst int[] rle = int[] ( 0xaaaaa907, 0x899999a9, 0x00889c89, 0x02999e98, 0x87aaaaaa, 0x888806ff, 0x56776677, 0x85668365, 0x55670577, 0x55443334, 0x77026684, 0x88867777, 0xa9009984, 0xbb84aa84, 0xaa84ab00, 0x89049986, 0x89998888, 0x0f00ff8c, 0x22151183, 0x66554322, 0x56677777, 0x12222224, 0x33443111, 0x66655544, 0x06888477, 0xbaaa9999, 0x84cbbbbb, 0x83dd00cc, 0xbbbb07cc, 0xaaaaabbb, 0x88839999, 0x77777805, 0x8c124256, 0x110024ff, 0x22221111, 0x76655533, 0x45677777, 0xff011223, 0x000fffff, 0x43221100, 0x98888765, 0xbaaa9888, 0x85cbbbbb, 0x0edd85cc, 0xbbbbbbcc, 0x899aaaaa, 0x67777888, 0x8ef14655, 0x210f09ff, 0x43322222, 0x56655555, 0x76126683, 0x000ff001, 0x1110ffff, 0x2111ffff, 0x99888765, 0xbb84a989, 0xbbbccb08, 0xaaaaaaab, 0xcc85bbbb, 0xaaabbb0b, 0x88899aaa, 0x56777788, 0x0fff9122, 0x66655421, 0x22345566, 0x33332222, 0x01211112, 0x5205ff87, 0x89999875, 0x19bb85a9, 0x99999aaa, 0xa8777888, 0xcccbbbba, 0xaabbbccc, 0x889aaaaa, 0x77788888, 0xff99f267, 0x22110f08, 0x21111f22, 0xff871353, 0x76532f09, 0xcccb9878, 0x839bbbcb, 0x78881799, 0x99864346, 0xbccbbbba, 0xaaaaa9ab, 0x8899999a, 0x67777888, 0xff9ef246, 0xf6510f02, 0x1f17ff89, 0x464443ff, 0x54443224, 0x98888766, 0x41f46788, 0xaaaa9986, 0x8388999a, 0x88890799, 0x66666777, 0xff9f3444, 0xff923f00, 0x33ff1f18, 0x56677643, 0x553fff13, 0x77777766, 0x65566667, 0x36777666, 0xffa31232, 0xff95f100, 0x87f04101, 0xf23207ff, 0xf1ffff11, 0xffa71222, 0xfffff100, 0xffbbffff, 0xcdf00f01, 0xce1100ff, 0xf12201ff, 0x2101ffcd, 0x00ffadf1, 0x01ff9e1f, 0xffae022f, 0xff9df100, 0xf0133f02, 0xf100ffa8, 0x4f02ffa2, 0xffa70001, 0xff850f00, 0xff9cf100, 0x00144f03, 0x01ffa6f0, 0xffa22000, 0x00231f03, 0x02ff8d00, 0x90f0211f, 0x000007ff, 0x0000ffff, 0xffa1f010, 0x01144f04, 0xff8cf000, 0x35441f02, 0x1001ff90, 0x00008401, 0x04ffa1f2, 0x00002a3f, 0x03ff8c11, 0xf174422f, 0x1001ff8f, 0x00008411, 0x04ffa2f1, 0x2100008d, 0x03ff8bf1, 0xf2543233, 0x0f00ff8e, 0x00031183, 0xa2f11100, 0x01d904ff, 0x8b211100, 0x334406ff, 0x0fff0133, 0x07ff8bf2, 0x1111110f, 0x01000012, 0xdc05ffa3, 0x21111003, 0x07ff8902, 0x2333441f, 0xf2ffff01, 0x0006ff8c, 0x00111100, 0xffa30010, 0x0013cd05, 0x89022211, 0x333f07ff, 0xff143223, 0xff8d13ff, 0x00100f04, 0xffa31000, 0x002cd506, 0x12121100, 0x3f07ff89, 0x11233344, 0x8e20ff01, 0x000103ff, 0xffa20ff0, 0x02bc6f07, 0x21011110, 0x07ff8921, 0x4433453f, 0x2fff1223, 0x0000ff8f, 0xbf08ffa4, 0x11110012, 0xf0112101, 0x1f05ff88, 0x34344345, 0x08ffb712, 0x00000058, 0x11101110, 0x05ff8811, 0x3232320f, 0xffb70245, 0x00831600, 0x10101003, 0x05ff8800, 0x3222221f, 0xff8c0343, 0xff85f000, 0xa1f33f01, 0x860500ff, 0x05ff8900, 0x52111110, 0xff8b1444, 0xffff1f08, 0xfffff1ff, 0xffa20143, 0x00830600, 0xff8bf000, 0x11111106, 0xf0164452, 0xf106ff8a, 0xf1f000ff, 0xffa410ff, 0x10114305, 0x8b000001, 0x111106ff, 0x14432111, 0x04ff8900, 0x10fff01f, 0x05ffa7f1, 0x1210044f, 0xff8bf010, 0x11111107, 0x11313222, 0x04ff88f0, 0x1ffff0f2, 0x04ffa7f1, 0x1120043f, 0x0bff88f0, 0x10f00000, 0x12211223, 0x01127511, 0xf107ff85, 0xf0ffffff, 0xa6f1ffff, 0x0f0204ff, 0x88000031, 0x111f0cff, 0x11101101, 0x21112111, 0x88124476, 0x830f00ff, 0xf00f01ff, 0x0f03ffa3, 0x8a0fffff, 0x111004ff, 0x84210110, 0xf1750211, 0x00ff842f, 0x00ff8301, 0x01ffa80f, 0xff8bf021, 0x01000f0d, 0x01110001, 0x11223210, 0x84f22062, 0xff1209ff, 0x000fffff, 0xf0ffff10, 0x3f02ffa2, 0xff8df022, 0x0010001b, 0x00111111, 0x21111221, 0xfff1225f, 0x111fffff, 0x1fffffff, 0xfffff101, 0x06ffa1f1, 0xf00f1732, 0x8a2fffff, 0x111017ff, 0x11311111, 0x10112111, 0x11125ff1, 0x1ffffff0, 0xffff1111, 0xffa52111, 0xfff16505, 0x8af0ffff, 0x100f19ff, 0x21110111, 0x11114311, 0x0124f110, 0xffff0000, 0xf0011110, 0xf023322f, 0x4f02ffa3, 0xff8ff167, 0x0010001b, 0x11223521, 0x1f100211, 0xf1001223, 0x11100fff, 0x5120f111, 0xf1010255, 0x05ffa0f3, 0xfff03471, 0xff8c0fff, 0x0111101a, 0x01112210, 0x21101100, 0x2fff0123, 0x01100122, 0x82110000, 0x11112477, 0x0106ffa0, 0xff001455, 0xff8d0fff, 0x11831200, 0x00000115, 0xf1122210, 0x15242651, 0xeed40000, 0x223cdbbd, 0x9ef01001, 0x2f1f07ff, 0x00012345, 0xff8df000, 0x11235219, 0x00f01100, 0x01220ff0, 0x22256700, 0xeec20064, 0x5ddeeeee, 0x9f000131, 0x312f08ff, 0x00012467, 0x8cf00000, 0x331f03ff, 0xff840023, 0x62012208, 0x88725235, 0xee83ed52, 0x02348d06, 0x10ffff00, 0x1f09ff9b, 0x35866423, 0x11000101, 0x01ff8e00, 0xff841221, 0x66111114, 0x65214256, 0xeeedeecc, 0x467adcde, 0x1fff0013, 0xff9a21ff, 0x76762109, 0x00113596, 0x8c011000, 0x121001ff, 0x0118ff83, 0x7545332f, 0x0001ff25, 0x3347dc62, 0x58dda993, 0xffff2444, 0xf0fffff0, 0x430aff99, 0x34877565, 0x00000111, 0xff8bf011, 0xf023211b, 0x22f01fff, 0x65f13ff0, 0x0000ff22, 0x249b8510, 0x33464342, 0x00234544, 0x0aff9c32, 0x56774440, 0x00011124, 0x8c110000, 0x110f1dff, 0x0122f1f2, 0x25fffff0, 0x000000f1, 0x76422110, 0x55444446, 0x00243334, 0x1fff1111, 0x200bff99, 0x12236631, 0x11010111, 0x8b001011, 0x100f1cff, 0x10003433, 0x000f0f02, 0x0000ffff, 0x32111100, 0x57776622, 0x01323344, 0x9af10010, 0x43310dff, 0x01112224, 0x10110011, 0x0fff1011, 0x0f1cff89, 0x11211000, 0x00000111, 0x100ff000, 0x22211100, 0x76477612, 0x12345446, 0x10011012, 0x2f0eff99, 0x11236435, 0x01110011, 0x11110000, 0xff890011, 0x8c0f0001, 0x01110e00, 0x75356430, 0x22233236, 0x11310122, 0x0eff98f0, 0x12254231, 0x00000111, 0x1100f000, 0x88f01111, 0x0ff003ff, 0x00880fff, 0x00841000, 0x4421200e, 0x23342212, 0x01211111, 0x11ffffff, 0xf000ff8f, 0x2f0eff83, 0x11122443, 0x00000111, 0x110ffff0, 0xff8af111, 0x0ffff004, 0x0086ff0f, 0x00851000, 0x1111110e, 0x22434431, 0xfff23332, 0xf110ffff, 0x0013ff8e, 0x1ffffff1, 0x11124433, 0x00111100, 0x0fffffff, 0x8cf10f00, 0x000103ff, 0x0085fff0, 0x00851000, 0x1101100e, 0x11122111, 0xf1211112, 0xf1ffffff, 0x0012ff8d, 0x75220301, 0x11343334, 0x11110000, 0xffffff00, 0xff83f10f, 0x88f33101, 0x113105ff, 0x0f000ff0, 0x10000083, 0x10000085, 0x01091185, 0x22334100, 0x1001f122, 0x1dff8bf2, 0x2211000f, 0x25543323, 0x11110111, 0xff000000, 0x110ffff0, 0x850fffff, 0xffffff18, 0xff84210f, 0x0f011102, 0x10000085, 0x11840085, 0x1000000c, 0x33334221, 0x01222211, 0xff87f010, 0xfff0001c, 0x0111100f, 0x00112211, 0x00111000, 0x01100000, 0x200ffff0, 0x741ffff1, 0xff884568, 0x87121f01, 0x84100000, 0x0c118400, 0x21410001, 0x10122342, 0x01121111, 0x1bff8a11, 0x22111110, 0x01001122, 0x000f0110, 0xf000fff0, 0xf1100ff0, 0x750fffff, 0x36669a98, 0x1f04ff87, 0xf0000111, 0x0017ff83, 0x0000f001, 0x11232100, 0x00000111, 0x01210141, 0x10000000, 0x93111011, 0x000f13ff, 0xf00fff00, 0xf1100000, 0x21ffffff, 0x7aaa9886, 0xff8df022, 0xffff0f03, 0x0900860f, 0x00000011, 0x00000f10, 0xff97f000, 0xff001009, 0x00f0ffff, 0x83f11100, 0x887406ff, 0x36899a99, 0x00ff8e12, 0x00ff83f1, 0x0100840f, 0xff9ff0f0, 0xf0ff0f13, 0x0f0ff0ff, 0x10ffff11, 0x88766332, 0x67788888, 0x00ff8f13, 0x04ff8401, 0x11000f0f, 0x10ffa3f0, 0x012fff0f, 0x22ff1321, 0x87776653, 0x34667778, 0x01ff8502, 0xff8f1110, 0xffa80000, 0x4344110e, 0x22101124, 0x35532222, 0x11111122, 0xffffffff );\n\nconst int rle_len_bytes = rle.length() << 2;\n\nint get_rle_byte( in int byte_index )\n{\n        int long_val = rle[ byte_index >> 2 ];\n        return ( long_val >> ( ( byte_index & 0x03 ) << 3 ) ) & 0xff;\n}\n\nint get_uncompr_byte( in int byte_index )\n{\n        int rle_index = 0;\n        int cur_byte_index = 0;\n        while( rle_index < rle_len_bytes )\n        {\n                int cur_rle_byte = get_rle_byte( rle_index );\n                bool is_sequence = int( cur_rle_byte & 0x80 ) == 0;\n                int count = ( cur_rle_byte & 0x7f ) + 1;\n\n                if( byte_index >= cur_byte_index && byte_index < cur_byte_index + count )\n                {\n                        if( is_sequence )\n                        {\n                                return get_rle_byte( rle_index + 1 + ( byte_index - cur_byte_index ) );\n                        }\n                        else\n                        {\n                                return get_rle_byte( rle_index + 1 );\n                        }\n                }\n                else\n                {\n                        if( is_sequence )\n                        {\n                                rle_index += count + 1;\n                                cur_byte_index += count;\n                        }\n                        else\n                        {\n                                rle_index += 2;\n                                cur_byte_index += count;\n                        }\n                }\n        }\n\n        return 0;\n}\n\n\nint getPaletteIndexXY( in ivec2 fetch_pos )\n{\n        int palette_index = 0;\n        if( fetch_pos.x >= 0 && fetch_pos.y >= 0\n                && fetch_pos.x < int( bitmap_size.x ) && fetch_pos.y < int( bitmap_size.y ) )\n        {\n                int uncompr_byte_index = fetch_pos.y * ( int( bitmap_size.x ) >> 1 )\n                        + ( fetch_pos.x >> 1);\n\n                int uncompr_byte = get_uncompr_byte( uncompr_byte_index );\n\n                int nibble_index = fetch_pos.x & 0x01;\n                palette_index = ( uncompr_byte >> ( nibble_index << 2 ) ) & 0xf;\n        }\n        return palette_index;\n}\n\n\nint getPaletteIndex( in vec2 uv )\n{\n        int palette_index = 0;\n        ivec2 fetch_pos = ivec2( uv * bitmap_size );\n        palette_index = getPaletteIndexXY( fetch_pos );\n        return palette_index;\n}\n\nvec4 getColorFromPalette( in int palette_index )\n{\n        int int_color = palette[ palette_index ];\n        return vec4( float( int_color & 0xff ) / 255.0,\n                                float( ( int_color >> 8 ) & 0xff) / 255.0,\n                                float( ( int_color >> 16 ) & 0xff) / 255.0,\n                                0 );\n}\n\nvec4 getBitmapColor( in vec2 uv )\n{\n        return getColorFromPalette( getPaletteIndex( uv ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / bitmap_size;\n    fragColor = getBitmapColor( uv );\n    if (fragCoord.y > 70. || fragCoord.x > 160.) fragColor = vec4(0,1,1,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// https://www.shadertoy.com/view/4tdSWr\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n        vec2 i = floor(p + (p.x+p.y)*K1);\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\n}\n\nfloat fbm(vec2 n) {\n        float total = 0.0, amplitude = 0.1;\n        for (int i = 0; i < 7; i++) {\n                total += noise(n) * amplitude;\n                n = m * n;\n                amplitude *= 0.4;\n        }\n        return total;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}