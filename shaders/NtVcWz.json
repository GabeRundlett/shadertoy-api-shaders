{
    "Shader": {
        "info": {
            "date": "1661276382",
            "description": "Minimalist assembly instructions for \"Controllable Machinery\"",
            "flags": 0,
            "hasliked": 0,
            "id": "NtVcWz",
            "likes": 19,
            "name": "Machinery Build",
            "published": 3,
            "tags": [
                "book",
                "album",
                "machine",
                "instructions"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "// \"Machinery Build\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Minimalist assembly instructions for \"Controllable Machinery\" (mouseable,\n  but no control capability)\n\n  No. 8 in \"Album\" series\n    \"Distance Field Guide\"       (WdcGWf)\n    \"Engine Album\"               (WsyGRK)\n    \"Chateaux..\"                 (Wtd3Df)\n    \"Live Assembly Instructions\" (WlcSD2)\n    \"Nautilus: The Book\"         (3lVSWw)\n    \"Book of Chopped Surfaces\"   (tdlcD7)\n    \"Sand Album\"                 (3slBRf)\n*/\n\n#define AA    0 // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\n\nvec4 wgObj;\nvec3 ltDirEx, ltDir, vnBlk, qHit, pgSize;\nvec2 qBlk;\nfloat dstFar, tCur, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage, tMov, angRot, bEdge,\n   tCyc, cnPos, hitBlk;\nint idObj, cState;\nconst int nPage = 10;\nbool isBw;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8, idCon = 9, idBlk = 10;\nconst float pi = 3.1415927;\nconst float nBlk = 13.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float aRot, \n   bool bev, float dMin)\n{\n  vec3 q;\n  float d, s;\n  q = p;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    q.xy = Rot2D (q.xy, aRot);\n    q.xy = Rot2D (q.xy, floor (nt * atan (q.y, - q.x) / (2. * pi) + 0.5) * 2. * pi / nt);\n    if (bev) q.xy *= 1.2 - 0.2 * q.z / wlThk;\n    s = q.x - 2. * clamp (1.5 * tWid + 0.5 * q.x * step (0., q.x) - abs (q.y), 0., tWid);\n    d = max (d, - rad - 0.95 * s);\n  }\n  return min (dMin, d);\n}\n\nvec4 BPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 5.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t / 5., bEdge, 0.);\n  } else if (t < 10.) {\n    a = 0.5 * pi * (t - 5.) / 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 15.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 10.) / 5., 1. + bEdge, 1.);\n  } else if (t < 17.5) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 15.) / 2.5);\n  } else {\n    t -= 17.5;\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, wlThk, tWid, nt, rad, gRat;\n  dMin = dstFar / 0.3;\n  gRat = 2.;\n  rad = 0.43;\n  wlThk = rad / 15.;\n  tWid = rad / 16.;\n  nt = 32.;\n  q = p - vec3 (0.1, 0., 1.);\n  dMin = GearWlDf ((q - vec3 (0., bEdge, 0.)).yzx, rad, wlThk, tWid, nt,\n     - angRot - 0.3 * pi / nt, false, dMin);\n  dMin = GearWlDf (- (q - vec3 (0., -0.21, 0.555)).zyx, rad / gRat, wlThk, tWid,\n     nt / gRat, - angRot * gRat, false, dMin);\n  rad = 0.3;\n  wlThk = rad / 7.;\n  tWid = rad / 10.;\n  nt = 20.;\n  q = p - vec3 (-1.05, -0.21, 1.3);\n  dMin = GearWlDf (- q, rad, wlThk, tWid, nt, angRot * gRat, true, dMin);\n  dMin = GearWlDf ((q - vec3 (0.85 * rad, 0., 0.85 * rad)).yzx,\n     rad, wlThk, tWid, nt, angRot * gRat + pi / nt, true, dMin);\n  rad = 0.32;\n  wlThk = rad / 15.;\n  tWid = rad / 12.;\n  nt = 24.;\n  q = p - vec3 (-1.05, -0.21, 0.6);\n  dMin = GearWlDf ((q - vec3 (0., 0., 0.1)), rad, wlThk, tWid, nt,\n     angRot * gRat + pi / nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, 0.1)), rad / gRat, wlThk, tWid, nt / gRat,\n     - angRot * gRat * gRat, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, -0.1)), rad, wlThk, tWid, nt,\n     - angRot * gRat * gRat - pi / nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., 0., -0.1)), rad / gRat, wlThk, tWid, nt / gRat,\n     angRot * gRat * gRat * gRat, false, dMin);\n  return dMin * 0.3;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  if (cState >= 1) {\n    q = p - vec3 (0., -1.2, 0.9);\n    d = PrRoundBoxDf (q, vec3 (1.7, 0.03, 1.5), 0.02);\n    DMIN (idBas);\n    q = p - wgObj.xyz;\n    d = PrRoundCylDf (q.xzy, wgObj.w, 0.02, 0.02);\n    DMIN (idCon);\n  }\n  if (cState >= 2) {\n    q = p - vec3 (0.65, -0.14, 1.);\n    q.x = abs (q.x) - 0.3;\n    d = PrRoundBoxDf (q, vec3 (0.01, 1.08, 0.06), 0.02);\n    q = p - vec3 (-0.05, -0.68, 0.);\n    q.xz = abs (q.xz) - vec2 (1., 0.2);\n    d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n    q = p - vec3 (-1.05, -0.14, 1.);\n    d = min (d, PrRoundBoxDf (q, vec3 (0.04, 1.08, 0.01), 0.02));\n    q = p - vec3 (-1.05, -0.68, 0.6);\n    q.z = abs (q.z) - 0.2;\n    d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n    q = p - vec3 (-0.33, -0.68, 1.555);\n    q.x = abs (q.x) - 0.3;\n    d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.55, 0.04), 0.02));\n    DMIN (idSup);\n    d = min (PrBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1)),\n       PrBoxDf (p - vec3 (-1.018, 0.98, 0.5), vec3 (0.1, 0.02, 0.5 - bEdge)));\n    DMIN (idPln);\n  }\n  if (cState >= 3) {\n    q = p - vec3 (0.65, bEdge, 1.);\n    d = PrCylDf (q.yzx, 0.04, 0.62);\n    q = p - vec3 (-0.36, -0.21, 1.555);\n    d = min (d, PrCylDf (q.yzx, 0.03, 0.51));\n    q = p - vec3 (-0.05, -0.21, 0.);\n    q.x -= 1.;\n    d = min (d, PrCylDf (q, 0.03, 0.27));\n    q.xz -= vec2 (-2., 0.14);\n    d = min (d, PrCylDf (q, 0.03, 0.4));\n    q.z -= 0.87;\n    d = min (d, PrCylDf (q, 0.03, 0.36));\n    q = p - vec3 (-1.05, -0.68, 0.6);\n    d = min (d, PrCylDf (q, 0.03, 0.25));\n    DMIN (idAx);\n  }\n  if (cState >= 4) {\n    q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n    r = length (q.yz);\n    q.yz = Rot2D (q.yz, - angRot);\n    a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n    q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) / 8.);\n    q.z = abs (q.z);\n    d = SmoothMax (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n       max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi / 32.),\n       cos (0.8 * 2. * pi / 32.))))), abs (q.x) - 0.02, 0.01);\n    DMIN (idWhl);\n  }\n  if (cState >= 6) {\n    q = p - vec3 (-0.05, -0.21, 0.);\n    q.x = abs (q.x) - 1.;\n    d = PrRoundCylDf (q, 0.18, 0.01, 0.11);\n    DMIN (idSpl);\n    d = SmoothMax (abs (PrCaps2Df ((p - vec3 (-0.05, -0.21, 0.)).yx, 0.2, 1.)) - 0.01,\n      abs (p.z) - 0.1, 0.02);\n    DMIN (idConv);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GearDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 GearNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GearDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * GearDf (p)) / (e.x * e.x));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k / nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      hitBlk = k;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 a4;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k / nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GearSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = GearDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 vn, col, q;\n  float dstObj, dstGear, dstBlk, sh, s, r, a;\n  int idObjT;\n  bool isNu;\n  isBw = (cState <= 8);\n  tCyc = 18.5;\n  bEdge = 0.08;\n  angRot = 0.1 * pi * tMov;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstGear = (cState >= 5) ? GearRay (ro, rd) : dstFar;\n  if (dstGear < min (dstObj, dstFar)) {\n    dstObj = dstGear;\n    idObj = idGr;\n  } else idObj = idObjT;\n  dstBlk = (cState >= 7) ? BlkHit (ro, rd) : dstFar;\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      dstObj = dstBlk;\n      ro += dstObj * rd;\n      idObj = idBlk;\n      vn = vnBlk;\n      col4 = vec4 (HsvToRgb (vec3 (hitBlk / nBlk, 1., 1.)), 0.2) *\n         (1. - 0.4 * step (0.8 * bEdge, Maxv2 (abs (qBlk))));\n    } else {\n      ro += dstObj * rd;\n      if (isBw) {\n        vn4 = (idObj == idGr) ? GearNfL (ro) : ObjNfL (ro);\n        vn = vn4.xyz;\n      } else {\n        vn = (idObj == idGr) ? GearNf (ro) : ObjNf (ro);\n      }\n      if (idObj == idWhl) {\n        col4 = vec4 (0.9, 0.7, 0.3, 0.2);\n        q = ro - vec3 (1.1 + bEdge + 0.03, bEdge, 1.);\n        r = length (q.yz);\n        q.yz = Rot2D (q.yz, - angRot);\n        a = fract (64. * atan (q.z, - q.y) / (2. * pi) + 0.5);\n        if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n        if (r > 0.92) col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n      } else if (idObj == idGr) {\n        col4 = vec4 (0.9, 0.8, 0.4, 0.2);\n      } else if (idObj == idSpl) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2) * (1. - 0.4 * step (abs (ro.z), 0.1));\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n      } else if (idObj == idPln) {\n        col4 = (abs (vn.y) > 0.99) ? vec4 (0.5, 0.6, 0.2, 0.05) : vec4 (0.7, 0.5, 0.4, 0.1);\n      } else if (idObj == idConv) {\n        q = ro - vec3 (-0.05, -0.21, 0.);\n        col4 = vec4 (0.8, 0.8, 0.4, 0.);\n        if (sign (vn.y) != sign (q.y)) {\n          if (abs (q.x) < 1. && abs (vn.y) > 0.5) col4 *= 1. - 0.1 * SmoothBump (0.45, 0.55, 0.03,\n           fract (10. * (q.x - sign (q.y) * mod (tMov, 20.) * 2.1 / 5.)));\n        } else col4 *= 0.8 + 0.2 * smoothstep (0., 0.01, abs (abs (q.z) - 0.07));\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.7, 0.5, 0.4, 0.1);\n      } else if (idObj == idBas) {\n        q = ro;\n        q.z -= 0.9;\n        if (Maxv2 (abs (q.xz) - vec2 (1.65, 1.45)) > 0.) {\n          col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n        } else {\n          col4 = vec4 (0.3, 0.5, 0.4, 0.);\n        }\n        col4 *= (0.5 + 0.5 * step (0., Maxv2 (abs (vec2 (q.x, q.z + 1.3)) - vec2 (0.4, 0.02)))) *\n           (0.7 + 0.3 * step (0., abs (PrCaps2Df (vec2 (q.z + 1.3, q.x), 0.08, 0.5)) - 0.01));\n      } else if (idObj == idCon) {\n        col4 = vec4 (0., 1., 1., 0.2);\n        if (length (ro.xz - wgObj.xz) < 0.6 * wgObj.w) col4 *= 0.8;\n      }\n    }\n    if (isBw) {\n      isNu = false;\n      if (cState == 1) isNu = (idObj == idBas || idObj == idCon);\n      else if (cState == 2) isNu = (idObj == idSup || idObj == idPln);\n      else if (cState == 3) isNu = (idObj == idAx);\n      else if (cState == 4) isNu = (idObj == idWhl);\n      else if (cState == 5) isNu = (idObj == idGr);\n      else if (cState == 6) isNu = (idObj == idConv || idObj == idSpl);\n      else if (cState == 7) isNu = (idObj == idBlk);\n      col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.8);\n      if (isNu) col.gb *= 0.3;\n      col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n         (0.4 + 0.6 * max (dot (vn, ltDir), 0.));\n    } else {\n      q = ro + 0.01 * ltDir;\n      sh = min (ObjSShadow (q, ltDir), GearSShadow (q, ltDir));\n      sh = 0.6 + 0.4 * min (sh, BlkHitSh (q, ltDir, 6.));\n      col = col4.rgb * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) +\n         0.9 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    }\n  } else col = isBw ? vec3 (0.8) : vec3 (0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac, spd;\n  cState = int (idPage);\n  az = 0.17 * pi;\n  el = -0.1 * pi;\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  spd = 1.;\n  tMov = (cState >= 8) ? spd * tCur : 0.;\n  cnPos = 0.5;\n  wgObj = vec4 (cnPos - 0.5, -1.12, -0.4, 0.08);\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.3, -12.);\n  ro.z += 0.9;\n  zmFac = 5.;\n  dstFar = 30.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  ltDir = vuMat * normalize (vec3 (-0.4, 0.6, -1.));\n  fCol = ShowScene (ro, rd);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExZeroPg (vec2 w)\n{\n  vec3 col;\n  float d;\n  col = vec3 (1.);\n  if (fract (tCur) < 0.9) {\n    w -= vec2 (1.05, -0.7);\n    d = min (length (max (abs (w) - vec2 (0.1, 0.002), 0.)),\n       length (max (abs (Rot2D (vec2 (w.x - 0.1, abs (w.y)), 0.2 * pi)) - vec2 (0.1, 0.002), 0.)));\n    col = mix (vec3 (0.3, 0.9, 0.3), col, smoothstep (0., 0.01, length (d)));\n  }\n  return col;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (2.7, 0.011, 1.9);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (fract (t / (tpCyc + tpWait)) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage));\n      c = vec3 (0.85, 0.85, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          if (idPage > 0.) {\n            isImg = true;\n            ExMain (col, w);\n          } else {\n            col4 = vec4 (ExZeroPg (w), 0.2);\n          }\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.95, 0.95, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = max (1.3 * tCur - 0.3, 0.);\n  az = 0.;\n  el = -0.5 * pi;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.y) > 0.42) {\n      tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n    } else if (abs (mPtr.x - 0.04) > 0.42) {\n      el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n    } else if (abs (mPtr.x - 0.04) < 0.33 && abs (mPtr.y) < 0.42) {\n      msAz = pi * clamp (3. * (mPtr.x - 0.04), -1., 1.);\n      msEl = pi * mPtr.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (2.7, 0., -20.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}