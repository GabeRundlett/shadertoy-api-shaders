{
    "Shader": {
        "info": {
            "date": "1628436242",
            "description": "renference: http://www.ppsloan.org/publications/StupidSH36.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2Xzd",
            "likes": 4,
            "name": "stupid SH test",
            "published": 3,
            "tags": [
                "3d",
                "sh",
                "raymatching"
            ],
            "usePreview": 0,
            "username": "WingStone",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "#define EPSLON 0.001\n#define SPEED 0.1\n\n#define UP_COLOR vec3(1.0, 0.0, 0.0)\n#define BOTTOM_COLOR vec3(0.0, 1.0, 0.0)\n#define RIGHT_COLOR vec3(0.0,0.0,1.0)\n#define LEFT_COLOR vec3(1.0, 0.0, 1.0)\n#define FRONT_COLOR vec3(1.0,1.0,0.0)\n#define BACK_COLOR vec3(0.0,1.0,1.0)\n\n\n//---------------------------------------------------------------------------------\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 n ) { return  k01; }\nfloat SH_1_0( in vec3 n ) { return -k02*n.y; }\nfloat SH_1_1( in vec3 n ) { return  k02*n.z; }\nfloat SH_1_2( in vec3 n ) { return -k02*n.x; }\nfloat SH_2_0( in vec3 n ) { return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 n ) { return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 n ) { return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 n ) { return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 n ) { return  k05*(n.x*n.x-n.y*n.y); }\nfloat SH_3_0( in vec3 n ) { return -k06*n.y*(3.0*n.x*n.x-n.y*n.y); }\nfloat SH_3_1( in vec3 n ) { return  k07*n.z*n.y*n.x; }\nfloat SH_3_2( in vec3 n ) { return -k08*n.y*(5.0*n.z*n.z-1.0); }\nfloat SH_3_3( in vec3 n ) { return  k09*n.z*(5.0*n.z*n.z-3.0); }\nfloat SH_3_4( in vec3 n ) { return -k08*n.x*(5.0*n.z*n.z-1.0); }\nfloat SH_3_5( in vec3 n ) { return  k10*n.z*(n.x*n.x-n.y*n.y); }\nfloat SH_3_6( in vec3 n ) { return -k06*n.x*(n.x*n.x-3.0*n.y*n.y); }\n\n\n//===========================Primitive==================================\n\n//default is signed\nfloat GetDistSphere(vec3 po, float r)\n{\n    return length(po) - r;\n}\n\n\nfloat GetDistPlane(vec3 po, vec3 nor, float len)\n{\n    return dot(po, nor) + len;\n}\n\n//====================Operation===================================\n\nvec2 OperateUnion(vec2 dist1, vec2 dist2)\n{\n    return dist1.x < dist2.x ? dist1 : dist2;\n}\n\n\n//==============================sh\nstruct SH\n{\n    vec3 sh0,sh1,sh2,sh3,sh4,sh5,sh6,sh7,sh8;\n};\n\nvoid EvalSHBasis(vec3 dir, vec3 col, inout SH sh)\n{\n    sh.sh0 += SH_0_0(dir)*col;\n    sh.sh1 += SH_1_0(dir)*col;\n    sh.sh2 += SH_1_1(dir)*col;\n    sh.sh3 += SH_1_2(dir)*col;\n    sh.sh4 += SH_2_0(dir)*col;\n    sh.sh5 += SH_2_1(dir)*col;\n    sh.sh6 += SH_2_2(dir)*col;\n    sh.sh7 += SH_2_3(dir)*col;\n    sh.sh8 += SH_2_4(dir)*col;\n}\nvoid SHMultiply(float t, inout SH sh)\n{\n    sh.sh0 *= t;\n    sh.sh1 *= t;\n    sh.sh2 *= t;\n    sh.sh3 *= t;\n    sh.sh4 *= t;\n    sh.sh5 *= t;\n    sh.sh6 *= t;\n    sh.sh7 *= t;\n    sh.sh8 *= t;\n}\n\nvec3 ShadeIrad(\n    vec4 vNormal,\n    vec4 cAr,\n    vec4 cAg,\n    vec4 cAb, \n    vec4 cBr,\n    vec4 cBg,\n    vec4 cBb,\n    vec4 cC)\n{ \n    vec3 x1, x2, x3;\n    \n    // Linear + constant polynomial terms\n    x1.r = dot(cAr,vNormal); \n    x1.g = dot(cAg,vNormal); \n    x1.b = dot(cAb,vNormal);              \n    \n    // 4 of the quadratic polynomials  \n    vec4 vB = vNormal.xyzz * vNormal.yzzx;  \n    x2.r = dot(cBr,vB);  \n    x2.g = dot(cBg,vB);     \n    x2.b = dot(cBb,vB);             \n    \n    // Final quadratic polynomial  \n    float vC = vNormal.x*vNormal.x - vNormal.y*vNormal.y;  \n    x3 = cC.rgb * vC; \n    return x1+x2+x3;  \n}\n\n//======================================================================\n\nvec2 GetDistAll(vec3 po)\n{\n    vec2 u = vec2(GetDistSphere(po, 1.0), 1.0);\n    \n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,-1.0, 0.0), 10.0), 2.0));//+y\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,1.0, 0.0), 10.0), 3.0));//-y\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(-1.0,0.0, 0.0), 10.0), 4.0));//+x\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(1.0,0.0, 0.0), 10.0), 5.0));//-x\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,0.0, -1.0), 10.0), 6.0));//+z\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,0.0, 1.0), 10.0), 7.0));//-z\n    \n    return u;\n\n}\n\nvec3 GetNormal(vec3 po)\n{\n    vec2 e = vec2(1.0, -1.0) * EPSLON * 0.1;\n    return normalize(e.xxx * GetDistAll(po + e.xxx).x\n                     + e.xyy * GetDistAll(po + e.xyy).x\n                     + e.yxy * GetDistAll(po + e.yxy).x\n                     + e.yyx * GetDistAll(po + e.yyx).x);\n}\n\nvec4 RayMatch(vec3 po, vec3 rayDr)\n{\n    float l = 0.0;\n    vec4 edgePo = vec4(0.0);\n    for(int i = 0; i < 64; i++)\n    {\n        vec2 dist = GetDistAll(po + l * rayDr);\n        if(dist.x < EPSLON)\n        {\n            edgePo.w = dist.y;\n            break;\n        }\n        if(l > 64.0)\n        {\n            edgePo.w = 0.0;\n            break;\n        }\n        l += dist.x;\n    }\n    edgePo += vec4(po + l * rayDr, 0.0);\n    return edgePo;\n}\n\nvec3 Render(vec4 edgePo, vec3 viewDir,\n    vec4 cAr,\n    vec4 cAg,\n    vec4 cAb, \n    vec4 cBr,\n    vec4 cBg,\n    vec4 cBb,\n    vec4 cC)\n{\n    if(edgePo.w < 1.5)\n    {\n        vec3 nor = GetNormal(edgePo.xyz);\n        vec3 col = ShadeIrad(vec4(nor,1.0),cAr,cAg,cAb,cBr,cBg,cBb,cC);\n        return clamp(col, 0.0, 1.0);\n    }\n    else if(edgePo.w < 2.5)\n    {    \n        return UP_COLOR;\n    }\n    else if(edgePo.w < 3.5)\n    {    \n        return BOTTOM_COLOR;\n    }\n    else if(edgePo.w < 4.5)\n    {    \n        return RIGHT_COLOR;\n    }\n    else if(edgePo.w < 5.5)\n    {    \n        return LEFT_COLOR;\n    }\n    else if(edgePo.w < 6.5)\n    {    \n        return FRONT_COLOR;\n    }\n    else if(edgePo.w < 7.5)\n    {    \n        return BACK_COLOR;\n    }\n}\n\n//==========================image\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n//===================================Main===================================\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inv_Reso = 1.0 / iResolution.xy;\n    \n    // SH\n    SH sh = SH(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n    EvalSHBasis(vec3(0.0, 1.0, 0.0), UP_COLOR, sh);\n    EvalSHBasis(vec3(0.0, -1.0, 0.0), BOTTOM_COLOR, sh);\n    EvalSHBasis(vec3(1.0, 0.0, 0.0), RIGHT_COLOR, sh);\n    EvalSHBasis(vec3(-1.0, .0, 0.0), LEFT_COLOR, sh);\n    EvalSHBasis(vec3(0.0, 0.0, 1.0), FRONT_COLOR, sh);\n    EvalSHBasis(vec3(0.0, 0.0, -1.0), BACK_COLOR, sh);\n    SHMultiply(4.0*3.1415926/6.0, sh);\n    \n    const float s_fSqrtPI = sqrt(3.1415926); \n    const float fC0 = 1.0f/(2.0f*s_fSqrtPI);\n    const float fC1 = sqrt(3.0f)/(3.0f*s_fSqrtPI); \n    const float fC2 = sqrt(15.0f)/(8.0f*s_fSqrtPI); \n    const float fC3 = sqrt(5.0f)/(16.0f*s_fSqrtPI); \n    const float fC4 = 0.5f*fC2; \n    \n    vec4 cAr = vec4(0.0);\n    vec4 cAg = vec4(0.0); \n    vec4 cAb = vec4(0.0); \n    vec4 cBr = vec4(0.0); \n    vec4 cBg = vec4(0.0); \n    vec4 cBb = vec4(0.0); \n    vec4 cC = vec4(0.0);\n    \n    cAr.x = -fC1*sh.sh3.x;\n    cAr.y = -fC1*sh.sh1.x;\n    cAr.z = fC1*sh.sh2.x;\n    cAr.w = fC0*sh.sh0.x - fC3*sh.sh6.x;\n    \n    cAg.x = -fC1*sh.sh3.y;\n    cAg.y = -fC1*sh.sh1.y;\n    cAg.z = fC1*sh.sh2.y;\n    cAg.w = fC0*sh.sh0.y - fC3*sh.sh6.y;  \n    \n    cAb.x = -fC1*sh.sh3.z;\n    cAb.y = -fC1*sh.sh1.z;\n    cAb.z = fC1*sh.sh2.z;\n    cAb.w = fC0*sh.sh0.z - fC3*sh.sh6.z;\n      \n    cBr.x = fC2*sh.sh4.x;\n    cBr.y = -fC2*sh.sh5.x;\n    cBr.z = 3.0*fC3*sh.sh6.x;\n    cBr.w = -fC2*sh.sh7.x;\n    \n    cBg.x = fC2*sh.sh4.y;\n    cBg.y = -fC2*sh.sh5.y;\n    cBg.z = 3.0*fC3*sh.sh6.y;\n    cBg.w = -fC2*sh.sh7.y;\n        \n    cBb.x = fC2*sh.sh4.z;\n    cBb.y = -fC2*sh.sh5.z;\n    cBb.z = 3.0*fC3*sh.sh6.z;\n    cBb.w = -fC2*sh.sh7.z;\n        \n    cC.x = fC4*sh.sh8.x;\n    cC.y = fC4*sh.sh8.y;\n    cC.z = fC4*sh.sh8.z;\n    cC.w = 1.0;\n    \n    // rendering\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy) * inv_Reso.y;\n    vec3 screenPo = vec3(uv, 1.5);\n    vec3 cameraPo = vec3(0.0, 0.0, 0.0);\n    cameraPo.z -= 9.0;\n    screenPo.z -= 9.0;\n    float s = sin(iTime);\n    float c = cos(iTime);\n    cameraPo.xz = mat2(c,-s,s,c)*cameraPo.xz;\n    screenPo.xz = mat2(c,-s,s,c)*screenPo.xz;\n    vec3 ray = normalize(screenPo - cameraPo);\n\n    vec4 objPo = RayMatch(cameraPo, ray);\n    vec3 col = Render(objPo, normalize(cameraPo - screenPo),cAr,cAg,cAb,cBr,cBg,cBb,cC);\n        \n    // image\n    col += InterleavedGradientNoise(uv)/225.0;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}