{
    "Shader": {
        "info": {
            "date": "1508388162",
            "description": "fork of \nhttps://www.shadertoy.com/view/lsSGRz\nlearning how they did it.",
            "flags": 0,
            "hasliked": 0,
            "id": "4l2yDh",
            "likes": 9,
            "name": "one way portal 2",
            "published": 3,
            "tags": [
                "4d",
                "portal",
                "bioshock"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 803
        },
        "renderpass": [
            {
                "code": "//sign 3d portal (one way) single pass 2\n//https://www.shadertoy.com/view/lsSGRz\n\n//was a bit messy, cleaned it up a lot.\n\n//one lazy thing here is that it uses n states, buffers\n//so it just assumes that it will pass the portal only once per cycle\n// at the same spots on he cycle.\n\n//turns few things make an objectID gBuffer more complicated\n//than a portal.\n//the main problem is measuring a distance gradient trough a portal\n//basically doublles the number of measures\n//OR\n//you first trace the portal, use it as a bounding volume (leaf portal duh)\n//and stop parching ON the portal, which adds a trace and +1 step.\n// the trace is kinda done heuristically anyways\n// , where it suffers lipschitz issies.\n// so, this needs an explicit portal tracer as primary BVH.\n\n//todo, needs tracer BV\n//to know when a ray passes the portal and when not!\n//i tried stuff, and mostly made it worse than better\n\n//spin speed of portal around vertical axis.\n#define portalSpinZ iTime*2.\n\n//smaller steps or simpler geometry for better continuity.\n//makes portal a circle.\n//#define doGoodLipschitz\n\n//the lazy lipschitz adjustment\n#define understepRm .5\n\n#define zFar  400.\n#define iterRm 180\n\n#define SPECULAR\n\n//this is shitty occlusion, in a dicsontinuous set, poorly cotained.\n#define iterShadow 1\n\n//.x is radius .y is thickness of portal \"wall\"\n\n#define portalRing vec2(22.,1.)\n//#define portalRing vec2(22.,152./iResolution.y)\n//hairlined /iResolution\n//because it is a curved thing with bad lipschitz\n\n\n//glow completely fails along the portal discontinuity\n//well, glow is always good ad shwing bad lipschits\n//, so it stays as a debugger.\n//#define GLOW 1\n// Increase for bigger glow effect (which also gets a little bugged...)!\n#define GLOW_AMOUNT 9.*portalRing.x/understepRm\n//clearly glow was an attempt at hiding discontinuities\n\n//i tried to fix some continuity cases trough the portal\n//and made it worse, introcused more discontinuities than it removed.\n#define TheHartdWay\n\n/*\ntodo, this could use bool;if linesegment intersets portal surface,\n//even with sign check (portal normal)\n\n//portal surface is defined by;\ncenter, radius, normal\n\nif (line intersetcs plane)\n- this is bool, because parallel case is common\n- if (intersection distance < line segment length)\n- - if (intersection point is inside circle)\n- - - portal direction resolve\n- - - lets say a portal is a delta_world, but with sign\n- - - still need to resolve direction of portal with portal normal\n- - - should be sign of dot of directions!\n*/\n\n\n\n/*\nportal gun is one way portals!\na portal bun places 2 one-way portals in 2 different locales.\none way portalsd have some inherent backfacing-problems.\n2-way portals do not have that!\n\nlets assume a portal gun places 2 2-way portals.\nthe front side of one portal\n connects to the back side of the other portal\n\nsuch doubly-linked portals may change worlds OR locales OR both!\nthey likely only have a deltaPos and deltaRotation\n, linking 2 places in the same \"world\"\n\nwell, actually. \"world\" is just a \"lcale\" parameter.\n*/\n\n/*\nintersecting portal problem:\n- includes partially intersecting and coplanar portals)\n- excludes portal velocity movement sum problems.\n\nwhen a ray hits one portal, it must stop ON the portal\n- (problem of rounding errors here)\non that point it must intersect with all other portals.\n- the [order of portals] is relevant here, resolves catch22 things.\n*/\n\n//Find distance to intersection of plane along ray\n\n/*\n\n//plane tracing functions could possibly result in higher recision\n// but for now I doubt it much of a difference\n\n//return signed distance of u to plane (n,d)\n//[u]=point to measure plane distance to\n//[n]=plane normal, length set to 1.\n//[m]=plane distance to vec3(0)\nfloat dPlane(vec3 u,vec3 n,float m){return dot(u,n)+m;}\n\n\n\n\nfloat ass(vec3 n,float m,vec3 u,vec3 t)\n{float e=dot(n,t)\n;if(e==.0)return .0;//ray is parallel to plane\n;float d=-(dot(n,u+m)/e)\n;if(d<length(t))return .0;//plane is too far away\n;u+=t*e;//u is intersection point\n;return 1.;    \n}\n\n//return direction of intersection of ray with plane\n// 0= no intersection\n//+1= intersecting from positive space\n//-1= intersection from negative space\nfloat ass2(vec3 u,vec3 t,vec3 n,float m){\n float d0=sign(dot(u  ,n)+m);\n float d1=sign(dot(u+t,n)+m);  \n if (d0!=d1)return d0;//return intersection direction.\n return .0;}//no intersection\n\n\n*/\n\n//[n]PlaneNormal\n//[m]PlaneDistance (badly explained, distance to what)\n//[u]RayOrigin\n//[t]RayDirection\n//return distacne from origin to intersection.\nfloat gPRxZ(vec3 n,float m,vec3 u,vec3 t){\n    return -(dot(n,u+m)/dot(n,t));}\n\n//curDist, curMat , dist,mat\nvec2 fUnionMat(vec2 dm,vec2 en){return mix(dm,en,step(en.x,dm.x));}\n\nfloat boxR(vec3 p,vec3 b)\n{return length(max(abs(p)-b,.0));}\n\nfloat pTorus(vec3 p, vec2 t)\n{vec2 q=vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n\n\n//return polar of carthesian input; carthesian to polar: returned .x=distance to vec2(0); .y=angle in radians\nvec2 c2p(vec2 c){return vec2(length(c),atan(c.y,c.x));}\n//return carthesian of polar input; polar to carthesian: p.x=distance to vec2(0); p.y=angle in radians\nvec2 p2c(vec2 p){return vec2(p.x*cos(p.y),p.x*sin(p.y));}\n//lame simple rotation\nmat2 r2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\n//polar deformation to \"star shape\" (with bad lipschitz)\nvec2 wobble(vec2 u){\n#ifdef doGoodLipschitz\n ;return u;\n#endif\n ;u=c2p(u);\n ;float a=cos((u.y+iTime)*13.)*2.\n ;float b=cos((u.y+iTime)* 5.)*3.\n ;u.x+=mix(a,b,sin(iTime)*.5+.5)\n;return p2c(u);}\n\n\n\nfloat pTorus2(vec3 p, vec2 t){\n p.xy*=r2(portalSpinZ);//we spin locally.\n p.xz=wobble(p.xz);//we deform the gradient into a \"star shape\"\n return pTorus(p,t);}\n\n\n\nfloat gdo(float w, vec3 p, inout float m)\n{vec2 dm=vec2(16.+p.z,1)\n;if (w==0.\n){dm=fUnionMat(dm,vec2(length(p+vec3(24,22,4))-11.,4.))\n ;dm=fUnionMat(dm,vec2(boxR(  p+vec3(6,-35,4),vec3(4,4,11)),4.))\n ;dm=fUnionMat(dm,vec2(boxR( p+vec3(19,-15,0),vec3(4,4,15)),4.))\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3(-12,20,12),vec3(7     )),4.))\n;}else{dm.y=2.\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3( 15,35, 6),vec3(4,12,9 )),5.))\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3(-10,35,10),vec3(15,3,5 )),5.))\n ;dm=fUnionMat(dm,vec2(boxR(p+vec3( 15,-35,6),vec3(12,6,15)),5.))\n;}\n;dm.x-=1.\n;m=dm.y;\n;return dm.x;\n}\n//above is only occluding things\n//below also includes non-occluding things \n//fullbright light sources of the same color do not occlude another.\nfloat gd(float w, vec3 p, inout float m)\n{vec2 dm=vec2(16.+p.z,1)\n;dm.x=gdo(w,p,m);\n;dm.y=m\n;dm=dm=fUnionMat(dm,vec2(pTorus2(p,portalRing),3.));\n;m=dm.y;\n;return dm.x;}\n\nvec3 dg(float w, vec3 p){const vec2 e=vec2(.01,0)\n;float m;return normalize(vec3( \n(gd(w,p-e.xyy,m)-gd(w,p+e.xyy,m)),\n(gd(w,p-e.yxy,m)-gd(w,p+e.yxy,m)),\n(gd(w,p-e.yyx,m)-gd(w,p+e.yyx,m))));}\n\n\n//main problem of this one is that it changes \"worlds\"\n// AFTER calculating step distance!\n//[u]=CameraPosition (consant within this raymarcher)\n//[t]=rayDirection\n//[v]=traversed point alnog ray\n//[r]=distance along ray\n//[e]=last step length\nbool changeWorlds(vec3 u,vec3 t,vec3 v,float r,inout float e){\n    ;t.xy*=r2(portalSpinZ)      \n    ;u.xy*=r2(portalSpinZ)   \n    ;v.xy*=r2(portalSpinZ)//rotare portal over time around .z axis\n    \n    ;return\nlength(wobble(v.xz))<portalRing.x//intersection is inside portal-shape\n     &&\n        (v.xy).y>.0 &&\n        (u+t*(r+e)).y<.0;}\n\n\n\n\n//[n]PlaneNormal\n//[u]RayOrigin\n//[t]RayDirection\n//return distacne from origin to intersection.\nfloat gPRxZ(vec3 n,vec3 u,vec3 t){\n    return -(dot(n,u)/dot(n,t));}\nfloat gPRxZ(vec2 n,vec2 u,vec2 t){\n    return -(dot(n,u)/dot(n,t));}\n//second life wiki geometric\n//\n//calculate intersection of ray from [a] to [m.xy] \n//and plane with notmal [n] and distance [d]to vec2(0)\n//from there move AWAY from [a]\n//, in the direction of the surface normal, by [c]\n//return that point \"BEHIND\" the intersection point.\nvec3 pointBehindBound(vec3 n,float d,vec3 a,vec3 b,float c){\n n=normalize(n);//save\n vec3 i=a+(b-a)*gPRxZ(n,a+n*d,(b-a));\n i-=n*sign(dot(a,n)+d)*c;//stop a little bit behind the plane.\n //i+=normalize(b-a)*c;//same, but point is on ray [m]\n return i;}\nvec2 pointBehindBound(vec2 n,float d,vec4 m,float c){\n n=normalize(n);//save\n vec2 i=m.zw+(m.xy-m.zw)*gPRxZ(n,m.zw+n*d,(m.xy-m.zw));\n i-=n*sign(dot(m.zw,n)+d)*c;//stop a little bit behind the plane.\n //i+=normalize(m.xy-m.zw)*c;//same, but point is on ray [m]\n return i;}\n//this is intended tor teleporters\n//, where 4 permutations of \"normal\" and \"distance\" are relevant.\n/*\nexample use:\n vec2 planeNormal=normalize(vec2(1,5));\n float planeDist=-1.;   \n c.g=dot(u,planeNormal)-1.+planeDist;//draw signed boundary\n vec2 intersect=pointBehindBound(planeNormal,planeDist,m,.5);\n c.b=length(u-intersect)-.5;//draw blue around \"intersect\"\n*/\n\n\n\n//oh wow, whos idea is it to make a raymarcher routine with a portal\n//that accumulates a distance to a camera\n//wehen the portal makes that distance all but eulidean!\n//\n//get world,rayOrigin,rayDirection\n//r.x distance gets a birt skewed when passing portals.\n//u is the real ray position to be returned\n\n\n#ifdef TheHartdWay\n\n//get world,rayOrigin,rayDirection\nvec4 raymarch(float w,inout vec3 u,inout vec3 t)\n{vec4 r=vec4(0,0,w,1000.)//return vec4(distance,materialId,world,glow)\n;vec3 v;//we need u for a final return on t!\n//;vec3 x=u;\n;bool bb=false;\n;for(int i=0;i<iterRm;i++\n){\n ;if(!bb)v=u+t*r.x//move v along ray. //can not be delayed (easily)\n ;float e=gd(r.z,v,r.y)*understepRm\n #ifdef GLOW\n  ;if(r.y==3.)r.w=min(r.w,e)\n #endif\n ;bb=changeWorlds(u,t,v,r.x,e);\n ;if(bb\n ){\n\n  ;v=pointBehindBound(vec3(vec2(0,-1)*r2(-portalSpinZ),0),.0,v,v-t,\n                      .001\n                     //5.1\n                    //  iMouse.x*10./iResolution.x-5.  \n                     );\n  //e= makes t somehow worse:\n  //;e=gd(r.z,v,r.y)*understepRm;//needs new measure on other side of portal!\n  ;if(gd(r.z,v,r.y)*understepRm<-.1)break;\n   // e=.0001;\n        ;r.z=mod(r.z+1.,2.);//swap worlds\n ;}\n r.x+=e\n;}\n;t*=r.x\n;u+=t\n;r.y=mix(0.,r.y,step(r.y,zFar))//seems to have no effect\n;return vec4(r.x,r.y,r.z,r.w);}\n\n#else\n\nvec4 raymarch(float w,inout vec3 u,inout vec3 t)\n{vec4 r=vec4(0,0,w,1000.)//return vec4(distance,materialId,world,glow)\n;for(int i=0;i<iterRm;i++\n){\n ;vec3 v=u+t*r.x//vector from [cameraOrigin] to [point]\n ;float e=gd(r.z,v,r.y)*understepRm\n #ifdef GLOW\n  ;if(r.y==3.)r.w=min(r.w,e)\n #endif \n ;if(changeWorlds(u,t,v,r.x,e)){\n   r.z=mod(r.z+1.,2.)//swap worlds\n ;}    \n ;r.x+=e\n;}\n;t*=r.x\n;u+=t\n;r.y=mix(0.,r.y,step(r.y,zFar))//seems to have no effect\n;return vec4(r.x,r.y,r.z,r.w);}\n\n#endif\n\n\n#if iterShadow>0\n//yeah, this shadow function is pretty defunct.\n//world,lightsource,lightDirection\nfloat shadow(float world, vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < iterShadow; i++) {\n\t\tfloat m;\n        float h = gd(world, from + increment * t,m);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, 4.0 * h / t);\n        t += 1.4;\n    }\n    return res;}\n#endif\n\n#define sat(a) clamp(a,0.,1.)\n#define u5(a) ((a)*.5+.5)\n\nvec3 getPixel(float w,vec3 u,vec3 t){\n;vec4 c=raymarch(w,u,t);\n;vec3 n = dg(c.z,u)\n;vec3 lightPos = -normalize(u + vec3(0,0,-4))\n;float dif = u5(max(.0,dot(n,-lightPos)))\n,s= \n#if iterShadow>0\n u5(shadow(c.z, u,lightPos))\n#else\n 1.\n#endif\n,spe=.0\n#ifdef SPECULAR\n ;if (dot(n,-lightPos)>.0)spe=pow(max(.0,dot(reflect(-lightPos,n),normalize(-t))),5.)\n#endif\n//gBuffer materialId resolve\n;vec3 m=vec3(0)\n;if(c.y==1.\n){m=mix(vec3(1,.1,.2),vec3(1,.3,.6),sin(u.x)*sin(u.y))\n  *sat((100.-length(u.xy))/100.);\n}else if(c.y==2.\n){m=mix(vec3(.1,.2,1),vec3(.5,.5,1),sin(u.x))\n *sat((100.-length(u.xy))/100.);\n}else if(c.y==3.)m=vec3(1,1,1)\n;else if(c.y==4.)m=(fract(u.x/3.0)<.5?vec3(1,.1,.2):vec3(1,.3,.6))\n;else if(c.y==5.)m=(fract(u.x/3.0)<.5?vec3(.1,.4,1):vec3(.4,.6,1))\t\n;return mix(vec3(0,1,0),(m*dif+vec3(spe))*s, sat(c.w/GLOW_AMOUNT));\n;}\n\n//basic most intuitive \"look at\" camera\"\n//[u]=relative ScreenPosition.xy range [-1..1] u=vec2(0) is central\n//[t]=camera looking direction=Target-CamPosition\nvec3 camLookAt(vec2 u,vec3 t){t=normalize(t)\n;vec3 o=normalize(cross(t,vec3(0,0,1)));\n;vec3 l=normalize(cross(o,t));//2times normalize(cross()) is slow.\n;return normalize(u.x*o+u.y*l+2.5*t );}\n\nvoid mainImage( out vec4 o, in vec2 p){o=vec4(0);//for compatibility\n;p=p.xy/iResolution.xy\n;p=-1.0+2.0*p\n;p.x*=-iResolution.x/iResolution.y\n//;vec2 mo=iMouse.xy/iResolution.xy;\n\n;float d=50.,tim=iTime*.5\n;vec3 t=vec3(cos(tim)*8.\n            ,sin(tim+2.)*12.,4.)//cam target\n;vec3 u=vec3(50.+cos(tim)*d\n                ,sin(tim)*d*1.5,4.);//cam position\n;t=camLookAt(p,t-u);\n//aw man, the transition between worlds is a scripted timer.\n;float w;\n;if(cos(-iTime/4.)>.0)w=.0;else w=1.\n;o=vec4(getPixel(w,u,t),1);}\n \n/*\non \"4d\"\n-\nthe \"w\" parameter is basically a 4th dimension\n, here it is a boolean (for implicity) \n  but it could be generalized to a float.\nThan it would be an \"ease in\" to how 4d space works\n and how i4d space can be used to simulate portals.\n-\neg: rotations in 4d are double-quaterions=octonions.\njust like you measure the distance to two 3d gradients (double 3d space)\n, when they overlap, due to a portal that connects them.\neeg: 4d rotations are not necessarily coplanar\n, 4d rotations are more likely fibrations around a torus surface.\n-\neg: the camera moves in 1 circle trough 4d space\n, which is 2 overlapping circles in 3d space.\nthis is actually a problem for root solving polinomials of degree higher than 5.\n- - you must do 2 full rotations to return to your origina position.\n- - this ambiguity makes it impossibly \n- -  to analytically solve polynomials of degree higher than 4\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}