{
    "Shader": {
        "info": {
            "date": "1550834631",
            "description": "Roll the ball through the solved maze (see source)",
            "flags": 32,
            "hasliked": 0,
            "id": "tdfXRM",
            "likes": 16,
            "name": "Maze Ball Solved",
            "published": 3,
            "tags": [
                "interactive",
                "dynamics",
                "maze",
                "puzzle"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "// \"Maze Ball Solved\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Roll the ball through the solved maze.\n  Drag small red ring to control tilt angles (vary automatically until\n  first click); click yellow ring for new random maze; otherwise mouse\n  controls view angle.\n  Only partial solution shown when controlling tilt.\n  Based on \"Maze Ball\" and \"Maze Solver\".\n*/\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nmat3 QToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec3 ltDir, qHit, bSize, vnBall;\nvec2 gSize, aTilt, ballPos, cEn, cEx;\nfloat dstFar, tCur, autoRot, nStep, growLim, pathLen;\nint idObj;\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 q)\n{\n  vec2 ut, e;\n  float dw, s;\n  ut = q * gSize;\n  s = Loadv4 (floor (ut)).x;\n  dw = WallDst (ut, s);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (ut) - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\nfloat HtMaze (vec2 q)\n{\n  return 1. - smoothstep (0.15, 0.4, ValMaze (q));\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, b;\n  float dMin, d, h;\n  dMin = dstFar;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.zy = Rot2D (q.zy, aTilt.y);\n  h = 0.5 * bSize.y * HtMaze (0.5 * q.xz / bSize.xz + 0.5);\n  b = bSize;\n  b.xz *= (1. - 0.9 / gSize);\n  q.y -= h;\n  b.y += h;\n  d = 0.6 * length (max (abs (q) - b, 0.));\n  DMINQ (1);\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  d = max (PrBoxDf (q, bSize + vec3 (0., bSize.y, 0.)),\n     - PrBox2Df (q.xz, b.xz + vec2 (0.01)));\n  DMINQ (2);\n  q = p;\n  d = max (PrBoxDf (q, bSize + vec3 (bSize.x - b.x, bSize.y, bSize.z - b.z)),\n     - PrBox2Df (q.xz, bSize.xz + vec2 (0.01)));\n  DMINQ (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallRay (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  float b, d, w, dMin, rad;\n  ro.xy = Rot2D (ro.xy, aTilt.x);\n  ro.zy = Rot2D (ro.zy, aTilt.y);\n  rd.xy = Rot2D (rd.xy, aTilt.x);\n  rd.zy = Rot2D (rd.zy, aTilt.y);\n  dMin = dstFar;\n  rad = 0.25;\n  u = ro - vec3 (ballPos.x, rad + 0.6 * bSize.y, ballPos.y);\n  b = dot (rd, u);\n  w = b * b - dot (u, u) + rad * rad;\n  if (w >= 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dMin) {\n      dMin = d;\n      vnBall = (u + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nfloat BallChqr (vec3 vn)\n{\n  vec3 u;\n  u = QToRMat (vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw)) * vn;\n  return step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 ut, utb, h;\n  float dstObj, dstBall, nw;\n  dstBall = BallRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstBall < dstObj) {\n      vn = vnBall;\n      col4.rgb = mix (vec3 (1., 0., 1.), vec3 (0., 1., 1.), BallChqr (vn));\n      col4.a = 0.3;\n    } else if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        if (qHit.y > 0.) {\n          ut = qHit.xz / bSize.xz;\n          col4 = mix (vec4 (0.8, 0.8, 0.6, 0.3), vec4 (0.3, 0.5, 0.1, 0.1) *\n             (0.8 + 0.2 * Fbm2 (64. * qHit.xz)), step (0.33, ValMaze (0.5 * ut + 0.5)));\n          utb = 0.5 * gSize * (ut + 1.);\n          h = cEn + vec2 (0.6, 1.);\n          col4.rgb = mix (((length (ballPos + 0.5 * gSize - h) < 0.5) ?\n             vec3 (1., 0., 0.) : vec3 (0., 0., 1.)), col4.rgb,\n             smoothstep (0.15, 0.18, length (utb - h)));\n          h = cEx + vec2 (1.4, 1.);\n          col4.rgb = mix (((length (ballPos + 0.5 * gSize - h) < 0.5) ?\n             vec3 (1., 0., 0.) : vec3 (0., 0., 1.)), col4.rgb,\n             smoothstep (0.15, 0.18, length (utb - h)));\n          if (nStep > 5. * growLim || pathLen > 0.) {\n            nw = floor (Loadv4 (floor (mod (utb - 0.5, gSize))).y / 32.);\n            if (nw > 0.) col4.rgb = mix ((mod (nw / max (pathLen, 1.) - 0.2 * tCur, 1.) < 0.1) ?\n               vec3 (1., 0., 0.) : ((dot (abs (aTilt), vec2 (1.)) < 0.01 || autoRot == 1.) ?\n               vec3 (1., 0.8, 0.) : col4.rgb), col4.rgb, smoothstep (0.12, 0.15,\n               length (abs (fract (utb + 0.5) - 0.5))));\n          }\n          col4.rgb *= 0.8 + 0.2 * smoothstep (0.25, 0.3, length (0.5 * gSize * ut - ballPos));\n        } else col4 = vec4 (0.4, 0.3, 0.3, 0.);\n      } else if (idObj == 2 || idObj == 3) {\n        if (qHit.y > 1.49 * bSize.y) col4 = vec4 (0.5, 0.2, 0.1, 0.2) * (0.5 +\n           0.5 * Fbm2 (((abs (qHit.x) < abs (qHit.z)) ? vec2 (2., 8.) : vec2 (8., 2.)) * qHit.xz));\n        else if (idObj == 2 && length (qHit.zy) < 0.8 * bSize.y ||\n           idObj == 3 && length (qHit.xy) < 0.8 * bSize.y) col4 = vec4 (1., 0.9, 0., 0.3);\n        else col4 = 0.7 * vec4 (0.5, 0.2, 0.1, 0.2);\n      }\n    }\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col, wgBxC;\n  vec2 canvas, uv, um, us, ut, ca, sa;\n  float asp, tFrac, f, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).zw;\n  nStep = Loadv4 (vec2 (1., 0.)).z;\n  stDat = Loadv4 (vec2 (3., 0.));\n  aTilt = clamp (stDat.zw, -0.25, 0.25);\n  cEn = Loadv4 (vec2 (3., 1.)).zw;\n  cEx = Loadv4 (vec2 (4., 1.)).zw;\n  stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n  growLim = stDat.z;\n  pathLen = stDat.w;\n  bSize = vec3 (0.5 * gSize.x, 0.15, 0.5 * gSize.y);\n  ballPos = Loadv4 (vec2 (4., 0.)).zw;\n  autoRot = Loadv4 (vec2 (2., 1.)).w;\n  tFrac = Loadv4 (vec2 (2., 0.)).z;\n  stDat = Loadv4 (vec2 (0., 1.));\n  ca = cos (stDat.zw);\n  sa = sin (stDat.zw);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0.001, -0.03, -3.) * length (bSize.xz);\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 4.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  um = vec2 (0.4, 0.3) * vec2 (asp, 1.);\n  us = uv - 2. * um;\n  ut = abs (us) - vec2 (0.25);\n  if (max (ut.x, ut.y) < 0.) {\n    if (min (abs (ut.x), abs (ut.y)) < 0.015) col = vec3 (0., 0.7, 0.);\n    else {\n      f = length (0.5 * us - (1./2.) * aTilt) - 0.02;\n      col = mix (mix (vec3 (1., 0.1, 0.1), vec3 (0.1, 0.1, 1.),\n         step (0.005, abs (f))), vec3 (0.1, 0.1, 0.4), step (0., f));\n    }\n  }\n  wgBxC = vec3 (0.48 * asp, -0.46, 0.022);\n  if (abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y < 2.) col = vec3 (1., 1., 0.7);\n  ut = uv - vec2 (-0.85, 0.8) * vec2 (asp, 1.);\n  f = length (ut) - 0.1;\n  if (f < 0.) col = mix (mix (vec3 (0.2, 0.8, 0.2), vec3 (0.8, 0.2, 0.2),\n     step (0.5 * (atan (- ut.x, - ut.y) / pi + 1.), tFrac)),\n     vec3 (0.4, 0.8, 0.4), step (0.02, abs (f + 0.03)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Maze Ball Solved\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec4 ballQt;\nvec2 gSize, aTilt, ballPos, ballVel;\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat HtMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  p += 0.5 * gSize;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return max (1. - 4. * dw, 0.);\n}\n\nvoid Step ()\n{\n  float s, v;\n  s = 0.25;\n  ballVel -= 0.2 * sign (ballVel) *\n      vec2 (HtMaze (ballPos + vec2 (s * sign (ballVel.x), 0.)),\n            HtMaze (ballPos + vec2 (0., s * sign (ballVel.y))));\n  ballVel += 0.005 * aTilt - 0.03 * ballVel;\n  if (length (ballVel) > 0.1) ballVel *= 0.1 / length (ballVel);\n  ballPos += ballVel;\n  if (abs (ballPos.x) > 0.5 * gSize.x - 0.7) {\n    ballPos.x = (0.5 * gSize.x - 0.71) * sign (ballPos.x);\n    ballVel = vec2 (0.);\n  }\n  v = length (ballVel);\n  if (v > 0.) ballQt = normalize (QtMul (ballQt,\n     RotToQt (normalize (vec3 (- ballVel.y, 0., ballVel.x)), v / 0.25)));\n}\n         \nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, fVal, cb, cbi, cbf;\n  vec3 wgBxC;\n  vec2 canvas, iFrag, um, ud, ev[4], cEn, cEx;\n  float tCur, nStep, growLim, autoRot, tGame, tBgn, ai, ar, nw, nwn, nb, dir,\n     az, el, asp, pathLen;\n  int wgSel, wgReg, kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = vec2 (14.);\n  if (fragCoord.x >= gSize.x || fragCoord.y >= gSize.y) discard;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 5);\n  aTilt = vec2 (0.);\n  autoRot = 1.;\n  tGame = 60.;\n  if (! init) {\n    stDat = Loadv4 (vec2 (0., 1.));\n    el = stDat.z;\n    az = stDat.w;\n    autoRot = Loadv4 (vec2 (2., 1.)).w;\n    mPtrP = vec4 (Loadv4 (vec2 (1., 1.)).zw, Loadv4 (vec2 (2., 1.)).z, 0.);\n    wgSel = int (Loadv4 (vec2 (1., 0.)).w);\n  }\n  wgBxC = vec3 (0.48 * asp, -0.46, 0.022);\n  if (mPtr.z > 0.) {\n    um = vec2 (0.4, 0.3) * vec2 (asp, 1.);\n    ud = mPtr.xy * vec2 (asp, 1.) - um;\n    if (max (abs (ud.x), abs (ud.y)) < 0.13 || wgSel == 0) {\n      if (wgSel == 0) {\n        aTilt = 2. * ud;\n        autoRot = 0.;\n      }\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) init = true;\n    } else if (wgReg < 0) {\n      az = 2. * pi * mPtr.x;\n      el = clamp (-0.35 * pi + 0.7 * pi * mPtr.y, -0.5 * pi, 0.5 * pi);\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  ev[0] = vec2 (0., 1.);\n  ev[1] = vec2 (1., 0.);\n  ev[2] = vec2 (0., -1.);\n  ev[3] = vec2 (-1., 0.);\n  cbf = vec4 (1., 2., 4., 8.);\n  if (! init) {\n    nStep = Loadv4 (vec2 (1., 0.)).z;\n    init = (mod (nStep + 1., 12000.) == 0.);\n  }\n  if (init) {\n    mPtrP = mPtr;\n    az = 0.;\n    el = -0.35 * pi;\n    autoRot = 1.;\n    nStep = 0.;\n    pathLen = 0.;\n    growLim = 2. * max (gSize.x, gSize.y);\n    tBgn = tCur;\n    ar = -1.;\n    cEn = vec2 (0., 1.);\n    cEx = gSize - vec2 (2., 3.);\n    if (iFrag.y == 0. && iFrag.x < gSize.x - 1.) ar = 1.;\n    else if (iFrag.x == gSize.x - 1. && iFrag.y < gSize.y - 1.) ar = 0.;\n    else if (iFrag.y == gSize.y - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize.y - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize.x / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize.x / 4.)) ar = 0.;\n    }\n    ballPos = cEn + vec2 (-0.5 * gSize.x + 0.8, -0.5 * gSize.y + 1.);\n    ballVel = vec2 (0.);\n    ballQt = vec4 (0., 0., 0., 1.);\n    fVal.x = ar;\n  } else {\n    tBgn = Loadv4 (vec2 (2., 0.)).w;\n    cEn = Loadv4 (vec2 (3., 1.)).zw;\n    cEx = Loadv4 (vec2 (4., 1.)).zw;\n    stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    ++ nStep;\n    ar = fVal.x;\n    if (nStep < growLim && ar < 0.) {\n      ai = floor (4. * Hashfv2 (iFrag + tCur));\n      if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n        if (iFrag.y == 1.) {\n          if (ai == 2.) ai = 0.;\n        } else if (iFrag.y == gSize.y - 2.) {\n          if (ai == 0.) ai = 2.;\n        } else if (iFrag.x == 1.) {\n          if (ai == 3.) ai = 1.;\n        } else if (iFrag.x == gSize.x - 2.) {\n          if (ai == 1.) ai = 3.;\n        }\n      }\n      if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n         ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n    }\n    fVal.x = ar;\n    if (nStep < growLim) fVal.y = (iFrag.x <= gSize.x - 2. && \n       iFrag.y <= gSize.y - 2.) ? -1. : 0.;\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (iFrag.x <= gSize.x - 2. && iFrag.y <= gSize.y - 2.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 5. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag.x == cEn.x && iFrag.y == cEn.y) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32. * 1.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n    if (iFrag.y == 0. && iFrag.x <= 7.) {\n      ballPos = Loadv4 (vec2 (4., 0.)).zw;\n      ballVel = Loadv4 (vec2 (5., 0.)).zw;\n      ballQt = vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw);\n      if (autoRot > 0.) aTilt = 0.15 * sin (0.1 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n      if (nStep > growLim) Step ();\n    }\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = gSize;\n    else if (iFrag.x == 1.) fVal.zw = vec2 (nStep, float (wgSel));\n    else if (iFrag.x == 2.) fVal.zw = vec2 ((tCur - tBgn) / tGame, tBgn);\n    else if (iFrag.x == 3.) fVal.zw = aTilt;\n    else if (iFrag.x == 4.) fVal.zw = ballPos;\n    else if (iFrag.x == 5.) fVal.zw = ballVel;\n    else if (iFrag.x == 6.) fVal.zw = ballQt.xy;\n    else if (iFrag.x == 7.) fVal.zw = ballQt.zw;\n  } else if (iFrag.y == 1.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (el, az);\n    else if (iFrag.x == 1.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 2.) fVal.zw = vec2 (mPtr.z, autoRot);\n    else if (iFrag.x == 3.) fVal.zw = cEn;\n    else if (iFrag.x == 4.) fVal.zw = cEx;\n    else if (iFrag.x == 5.) fVal.zw = vec2 (growLim, pathLen);\n  }\n  fragColor = fVal;\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (dot (vec4 (q1.w, - q1.z, q1.yx), q2), dot (vec4 (q1.zw, - q1.x, q1.y), q2),\n     dot (vec4 (- q1.y, q1.xwz), q2), dot (vec4 (- q1.xyz, q1.w), q2));\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}