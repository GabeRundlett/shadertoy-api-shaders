{
    "Shader": {
        "info": {
            "date": "1650244523",
            "description": "Feel free to use this implementation in your own code but please give credit to me if you do so - I had to do a lot of analysis on this algorithm (which is also the reason for the many comments) for all these optimizations to be found.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lSyDV",
            "likes": 8,
            "name": "Iterative SDF for any Function",
            "published": 3,
            "tags": [
                "sdf",
                "distance",
                "de",
                "field",
                "function",
                "iterative",
                "iteration",
                "all",
                "signed",
                "any",
                "arbitrary",
                "estimate"
            ],
            "usePreview": 0,
            "username": "Spi3lot",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "/********************************************************\n\nI don't know if this algorithm is new (probably not),\nbut if it is\n    or you use my implementation\n    or any modified version of it,\n[PLEASE GIVE CREDIT TO ME] FOR DEVELOPING THE ALGORITHM\n\nFollow-up: https://www.shadertoy.com/view/flGcWz\n\n********************************************************/\n\n\n\n\n\n// CONSTANTS\n#define E cosh(1.0) + sinh(1.0)\n#define PI acos(-1.0)\n\n// SDF SETTINGS\n#define MAX_SDF_ITERATIONS (iTime * 5.)\n\n#define FAST\n\n\nfloat f(float x)\n{\n    //return sin(x + iTime) + sin(x - iTime);\n    return 15.0 * (sin(x * 2.0) + sin(1.1 * (x + PI * 0.5)));  // Rather steep function - good example\n    //return tan(x);  // Good example for the limits of this algorithm - the SDF for tan(x) takes a lot of iterations for it to converge because tan(x) is so steep\n}\n\n// WITH COMMENTS (scroll down a bit for version without comments)\nfloat sdf_by_Spi3lot(vec2 p)\n{\n    float y0 = f(p.x);\n    float minDist = p.y - y0;\n    \n    // Above function -> 1.0\n    // Exactly on function -> 0.0\n    // Below function -> -1.0\n    float sgn = sign(minDist);\n\n    // Make minDist non-negative (probably faster than abs because I already have the sign)\n    minDist *= sgn;\n\n    // i=1 and not i=0 (at the start of the loop)\n    //     because I count the first minDist initialization as the first iteration\n    //   AND\n    // Using < and not <=\n    //     because when i == MAX_SDF_ITERATIONS then dx == minDist and\n    //     when dx (>)= minDist then the distance can only be >= the current minDist\n    //     which means we can prune this iteration where i == MAX_SDF_ITERATIONS\n    for (float i = 1.; i < MAX_SDF_ITERATIONS; i++)\n    {\n        float dx = minDist * i / MAX_SDF_ITERATIONS;\n\n        float xL = p.x - dx;\n        float yL = f(xL);\n\n        float xR = p.x + dx;\n        float yR = f(xR);\n\n        float distL, distR, mini;\n        \n        // THE PRUNING SECTION CAN BE COMMENTED OUT\n        // BECAUSE THE PERFORMANCE IS WORSE THAN WITHOUT IT\n\n        /* (put/remove character between * and / for commenting out) -> * /\n        // vvvvvvvvvv PRUNING vvvvvvvvvv\n        bool pruneL = (yL < y0);  // Distance to left must be greater than p.y-y0 -> PRUNE\n        bool pruneR = (yR < y0);  // Distance to right must be greater than p.y-y0 -> PRUNE\n\n        if (pruneL && pruneR)\n        {\n            continue;  // Nothing changed\n        }\n\n        else if (pruneL)\n        {\n            distR = distance(p, vec2(xR, yR));\n            mini = distR;  // Minimum for sure\n        }\n        \n        else if (pruneR)\n        {\n            distL = distance(p, vec2(xL, yL));\n            mini = distL;  // Minimum for sure\n        }\n        \n        else\n        // ^^^^^^^^^^^^ PRUNING ^^^^^^^^^^^^\n        /* */\n        {\n            distL = distance(p, vec2(xL, yL));\n            distR = distance(p, vec2(xR, yR));\n\n            mini = min(distL, distR);\n        }\n        \n\n        if (mini < minDist)\n        {\n        #ifndef FAST\n            // Resetting i - The crucial difference which slows down everything by A LOT\n            // but also increases the speed of convergence of the minDist by quite a bit.\n\n            // BUT the total amount of iterations will still increase by such a big amount\n            // that this \"(actually not) optimized\" method where i is reset\n            // becomes COMPLETELY USELESS compared to the FAST one where i is NOT reset\n            i = 1.;\n        #endif\n        \n            // The algorithm works very well even without resetting i (resetting i whenever\n            // a smaller minDist was found) -> because when minDist gets updated, dx will\n            // get smaller which means p.x+dx will be closer to p.x and when i is reset\n            // we get closer and closer to p.x everytime we find a new and smaller distance,\n            // but as we get closer to p.x, the distance from p to the function\n            // approaches p.y-f(p.x) which is exactly what we DO NOT want\n            // since we could just scrap the iteration part\n            // and just return p.y-f(p.x) if this was what we wanted.\n            minDist = mini;\n        }\n    }\n\n    return sgn * minDist;\n}\n\n\n// WITHOUT COMMENTS AND UNNECESSARY CODE (scroll up a bit for version with comments)\n// copy/paste ready (name of function can be changed of course,\n// but if you remove my name please give credit to me in a comment or so)\nfloat sdf_by_Spi3lot_pure_no_comments(vec2 p)\n{\n    float y0 = f(p.x);\n    float minDist = p.y - y0;\n    float sgn = sign(minDist);\n    minDist *= sgn;\n\n    for (float i = 1.; i < MAX_SDF_ITERATIONS; i++)\n    {\n        float dx = minDist * i / MAX_SDF_ITERATIONS;\n\n        float xL = p.x - dx;\n        float yL = f(xL);\n\n        float xR = p.x + dx;\n        float yR = f(xR);\n\n        float distL = distance(p, vec2(xL, yL));\n        float distR = distance(p, vec2(xR, yR));\n        float mini = min(distL, distR);\n        \n        minDist = min(minDist, mini);\n    }\n\n    return sgn * minDist;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 pos = 100.0 * (uv - vec2(0.0, 0.5));\n    float dist = sdf_by_Spi3lot(pos);\n    vec3 col = vec3(abs(dist));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}