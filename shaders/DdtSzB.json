{
    "Shader": {
        "info": {
            "date": "1680030544",
            "description": "I've been trying to make the shortest raytracer.\nThanks to Fabrice and Xor, we've gotten this down to 348 chars!!\nLike most other raytracing on Shadertoy, it's FAST! (Try going full screen)\n\nCan you make it shorter?",
            "flags": 0,
            "hasliked": 0,
            "id": "DdtSzB",
            "likes": 8,
            "name": "Shortest Raytracing - 333 chars",
            "published": 3,
            "tags": [
                "raytracing",
                "reflections",
                "bw",
                "short",
                "golf"
            ],
            "usePreview": 0,
            "username": "GregRostami",
            "viewed": 320
        },
        "renderpass": [
            {
                "code": "// A VERY golfed shader that is based on Mirror Room by DiLemming (1911 chars):\n// https://www.shadertoy.com/view/4sS3zc\n// A big thanks to Fabrice and Xor for their help in golfing this shader.\n\n// 333 chars - Greg slightly changed the look to minus more CHARS!!\n\n// below is the sphere intersection test function\n#define S(x)                                                   \\\n    a  = dot(D, X=N/x+P),                                      \\\n    a -= sqrt( a*a - dot(X,X) + r),                            \\\n    a > 0. && a < t ? t = a, n = normalize( t*D - X ) : n,\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float t, l, r, a;\n\tvec3 R = iResolution, n, N, X,\n         P = 5./R,                          // camera position\n         D = normalize( vec3(u+u, R) - R ); // camera points forward\n\t\n\tfor (o *= l; o.a++ < 9.; o += a*a / l)  // 9 reflections\n    \n        t = r = 9e3,                  // set radius of large spheres that are the walls\n        N = 98.*sign(D),\n        S( R.zxx )                    // right & left wall \n        S( R.xzx )                    // floor & ceiling\n        S( R     )                    // front & back wall\n        r=1., N/=N, N.y=sin(iTime),\n        S( r  )                       // moving sphere\n        S( -r )                       // moving sphere 2\n        \n        P -= t*D,\n        a = dot (n, D), \n        D -= 2.*n * a,                // D = reflect(D, n)\n        l += t;\n}\n\n// 346 chars - Fabrice reworked the math to kill those evil CHARS!!\n// below is the sphere intersection test function\n/*\n#define S(x)                                                   \\\n    a  = dot(D, X=x+P),                                        \\\n    a -= sqrt( a*a - dot(X,X) + r),                            \\\n    a > 0. && a < t ? t = a, n = normalize( t*D - X ) : n,\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float t, l=0., r, a;\n\tvec3 R = iResolution, n, N, X,\n      P = 4./R,                         // camera position\n      D = normalize( vec3( u+u, R) - R ); // camera points forward\n\t\n\tfor (o *= l; o.a++ < 9.; o += a*a / l) // 9 reflections\n    \n        t = r = 94e2,                   // set radius of large spheres that are the walls\n        N = 1e2*sign(D),\n        S( N/R.zxx )                    // right & left wall \n        S( N/R.xzx )                    // floor & ceiling\n        S( N/R )                        // front & back wall\n        N = vec3(r=1., sin(iTime), 0),\n        S( -N )             // moving sphere\n        S( N.xzx )          // static sphere\n        \n        P -= t*D,\n        a = dot (n, D), \n        D -= 2.*n * a,                  // D = reflect(D, n)\n        l += t;\n}\n*/\n\n// Just for fun, here's the business card version like this one:\n// https://fabiensanglard.net/rayTracing_back_of_business_card/\n/*\n#define S(x)a=dot(D,X=N/x+P),a-=sqrt(a*a-dot\\\n(X, X)+r),a>0.&&a<t?t=a,n=normalize(t*D-X):n,\nvoid mainImage(out vec4 o,vec2 u){float t,l=0.\n,r,a;vec3 R = iResolution, n, N, X, P=5./R,D=\nnormalize(vec3(u+u,R)-R);for(o*=l;o.a++<9.; o\n+=a*a/l)t=r=94e2,N=1e2*sign(D),S(R.zxx)S(R.xzx)\nS(R)r=1.,N/=N,N.y=sin(iTime),S(r)S(-r)P-=t*D,a\n=dot(n,D),D-=2.*n*a,l+=t;}\n*/\n\n/*\n// 371 chars: \n#define v vec3//\n// below is the sphere intersection test function\n#define S(x)                                                   \\\n    b  = dot(D, x-P),                                          \\\n    b -= sqrt( b*b - dot(P-x, P-x) + r*r),                     \\\n    b > 0. && b < t ? t = b, p = P + t*D, n = normalize(p - x) : n,\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float t, b, l=0., r, a;\n\tv R = iResolution, p, n, N,\n         D = normalize( v( u+u, R) - R  ), // camera points forward\n\t     P = v (0, 0, -4),               // camera position\n         V = v (99, 0, 0 );               // walls offset by 100\n\t\n\tfor (o *= l; o.a++ < 9.; P=p) // 9 reflections\n    \n        t = r = 96.,              // set radius of large spheres that are the walls\n        N = sign(D),\n        S( V     * N )            // right & left wall\n        S( V.zxz * N )            // floor & ceiling\n        S( V.zzx * N )            // front & back wall\n        \n        S( v( r=1., 0, 1) )       // static sphere\n        S( v( -1, sin(iTime), 0) )// moving sphere\n        a = dot (n, D),\n        D -= 2.*n * a,            // D = reflect(D, n)\n        l += t,\n        o += a*a / l;             // shading calculation\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}