{
    "Shader": {
        "info": {
            "date": "1643918865",
            "description": "i was exploring fractal generation and i found... well... hats ?\n( click it ! )",
            "flags": 0,
            "hasliked": 0,
            "id": "sdSyzt",
            "likes": 14,
            "name": "fractal hat explorer",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 293
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\nvec2 foldRotate16 ( in vec2 p ) {\n    const vec2 k1 = vec2(0.38268343230, -0.9238795325 );\n    const vec2 k2 = vec2(0.19509032201, -0.9807852804 );\n    p = abs(p);\n    p = (p.y<p.x) ? p : p.yx;\n    p -= min(2.0*dot(k1,p),0.0)*k1;\n    p -= min(2.0*dot(k2,p),0.0)*k2;\n    return p;\n}\n\nvec2 getDist(vec3 p) {\n    \n    // parameters :\n    \n    int iterations = 6;\n    \n    vec3 offset = vec3(2.,2.,2.);\n\n    float ang1 = 3.88322207745;\n    float ang2 = iMouse.x/iResolution.x*PI;\n    float ang3 = iMouse.y/iResolution.y*PI;    \n    \n    //\n    \n    float size = 1.;\n    \n    float t = p.y + 3.25;    \n    float orbitTrap = 0.;\n\n    mat3 rot = mat3(cos(ang1),-sin(ang1),0.,  sin(ang1),cos(ang1),0.,  0.,0.,1.)\n              *mat3(cos(ang2),0.,sin(ang2),  0.,1.,0.,  -sin(ang2),0.,cos(ang2))\n              *mat3(1.,0.,0.,  0.,cos(ang3),sin(ang3),  0.,-sin(ang3),cos(ang3));\n\n            \n    for( int i=0; i++<iterations; ){\n        \n        p.xz = foldRotate16(p.xz);\n        //p.xy = foldRotate16(p.xy);\n\n        size *= 0.5;\n        \n        p = abs(p.zxy*rot) - offset*size;\n\n        orbitTrap += dot(p,p);\n    }\n    \n    float t2 = length(p) - size*2.;\n    \n    if (t<t2) { return vec2(t,-1.); }\n\n    return vec2(t2,0.5-cos(orbitTrap*0.8)*0.5);\n}\n\nfloat rayMarch( vec3 ro, vec3 rd) {\n\n    float coneWidth = 0.001;\n    float t = 0.;\n    int i = 0;\n\n    while ( i<100 && t<999. ) {\n\n        float r = abs( getDist( ro + rd*t ).x );\n\n        if ( r <= coneWidth*t ) break;\n        t += r;\n        i ++;\n    }\n    \n    return t;\n}\n\nvec3 distance_field_normal(vec3 pos) {\n    vec2 eps = vec2(0.0001,0.0);\n    float nx = getDist(pos + eps.xyy).x;\n    float ny = getDist(pos + eps.yxy).x;\n    float nz = getDist(pos + eps.yyx).x;\n    return normalize(vec3(nx, ny, nz)-getDist(pos).x);\n}\n\n\n//ambient occlusion\n//https://www.shadertoy.com/view/MtlBWB\nconst vec3 sq = 1./vec3(sqrt(2.),sqrt(3.),sqrt(4.));\nconst float eps = 0.1;\nconst vec3 eps2 = eps*vec3(2.,3.,4.);\nfloat ao(vec3 p, vec3 n) {\n    \n    float c1 = float(abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z));\n    float c2 = float(abs(n.y) < abs(n.z));\n    float c3 = c2 - c2*c1;\n    \n    vec3 t = vec3(c1, c3, 1. - c1 - c3);\n    vec3 u = cross(n, t);\n    vec3 v = cross(n, u);    \n    \n    vec3 epn = eps2[2]*n + p;\n    \n    float occ  = max(getDist(p + eps*n).x,0.0);\n          occ += max(getDist(p + eps*u).x,0.0);\n          occ += max(getDist(p - eps*u).x,0.0);\n          occ += max(getDist(p + eps*v).x,0.0);\n          occ += max(getDist(p - eps*v).x,0.0);\n    \n    occ += (max(getDist(epn + eps2[2]*u).x,0.0)\n        +   max(getDist(epn - eps2[2]*u).x,0.0)\n        +   max(getDist(epn + eps2[2]*v).x,0.0)\n        +   max(getDist(epn - eps2[2]*v).x,0.0))*0.5;\n\n    occ += max(getDist(p + eps2[0]*n).x*sq[0],0.0);\n    occ += max(getDist(p + eps2[1]*n).x*sq[1],0.0);\n    occ += max(getDist(epn          ).x*sq[2],0.0);\n\n    return max(1.0 - 1./(1.+2.*occ), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    float time2 = iTime*0.25;\n   \n    vec3 ro = vec3(cos(-time2)*8., 2.5, sin(-time2)*8. );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd.yz *= mat2(cos(0.3),sin(0.3),-sin(0.3),cos(0.3));\n    rd.xz = rd.xz*mat2(sin(time2),cos(time2),cos(time2),-sin(time2));\n    \n    ////\n        \t\n    float dist = rayMarch( ro, rd );\n    \n    vec3 hit = ro + rd*dist;\n    float orbitTrap = getDist(hit).y;\n    vec3 normals = distance_field_normal(hit);\n    vec3 pos = ro + dist*rd ;\n\n    vec3 col = vec3(.8,.8,1.);\n    if ( orbitTrap > 0. ) { col = mix(vec3(0.1,0.15,1.),vec3(1.,0.35,0.3),orbitTrap); }\n    \n    float diffuse = mix(normals.y,1.,0.65);\n    vec3 reflectDir = reflect(-vec3(0.,1.,0.),-normals);\n    float specular = pow (max (dot (-rd, reflectDir), 0.0), 100.0);\n    float ao = ao(pos, normals);\n        \n    fragColor = vec4( sqrt(( col + specular ) * diffuse * ao), 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}