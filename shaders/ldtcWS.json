{
    "Shader": {
        "info": {
            "date": "1520542929",
            "description": "ballpoint sketch style.\nnot very fast in fullscreen (at least for higher PNUM)\ncheckout a realtime version on shaderoo: [url]https://shaderoo.org/?shader=yMP3J7[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "ldtcWS",
            "likes": 237,
            "name": "ballpoint sketch",
            "published": 3,
            "tags": [
                "effect",
                "sketch",
                "drawing",
                "ballpoint"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 8634
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// realtime version on shaderoo: https://shaderoo.org/?shader=yMP3J7\n\n// final mixing and some paper-ish noise\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres = vec2(textureSize(iChannel1,0));\n    vec4 r=texture(iChannel1,pos/tres/sqrt(iResolution.x/600.));\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 r = getRand(fragCoord*1.1)-getRand(fragCoord*1.1+vec2(1,-1)*1.);\n    vec4 c = 1.-.3*texture(iChannel0,fragCoord/iResolution.xy);\n    fragColor = c*(.95+.06*r.xxxx+.06*r);\n    //fragColor = c;\n    vec2 sc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.0-.5*dot(sc,sc);\n    vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n    vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n    fragColor *= vign;\n    fragColor.w=1.;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// drawing a line segment from previous position to actual \n// for every particle (ballpoint tip)\n\n\nfloat sdLine( vec2 pos, vec2 p1, vec2 p2, float crop )\n{\n    float l=length(p2-p1);\n  \tif(l<.001) return 100000.;\n    vec2 t=(p2-p1)/l;\n    // crop a little from the ends, so subsequent segments will blend together well\n    l-=crop;\n    p2-=t*crop*.5;\n    p1+=t*crop*.5;\n  \tfloat pp = dot(pos-p1,t);\n  \tfloat pn = dot(pos-p1,t.yx*vec2(1,-1));\n  \treturn max(max(pp-l,-pp),abs(pn));\n}\n\nfloat segDist( int idx, vec2 pos, float crop )\n{    \n    Particle p,pp;\n    readParticle(p,idx,iChannel0);\n    readParticle(pp,idx+PNUM,iChannel0);\n\t//vec2 g=getGrad(p.pos,2.5*iResolution.x/600.)*iResolution.x/600.;\n    //if(length(g)<.01) return 10000.;\n    \n    if(length(pos-p.pos)>25.*iResolution.x/600.) return 10000.;\n    if(length(p.pos-pp.pos)>30.*iResolution.x/600.) return 10000.;\n    return sdLine(pos,p.pos,pp.pos,crop);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec3 col=vec3(0,.2,.65);\n    vec3 c=vec3(0);\n    float w=1.7*sqrt(iResolution.x/600.);\n    \n    for(int i=0; i<PNUM; i++)\n    {\n        c+=(-col+1.)*clamp(w*.5-segDist(i,fragCoord,w*.7),0.,1.);\n    }\n    fragColor=vec4(c,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// some particles (the actual ballpoint tips)\n\n#define N(v) (v.yx*vec2(1,-1))\n\nvoid propagate(inout Particle p)\n{\n    float dt=.02;\n    p.pos+=p.vel*dt;\n    float sc=(iResolution.x/800.);\n    \n    // gradient, its length, and unit vector\n    vec2 g = 1.0*getGrad(p.pos,2.5*sc,iChannel2,iResolution.xy)*sc;\n    // add some noise to gradient so plain areas get some texture\n    g += (getRand(p.pos/sc,iChannel1).xy-.5)*.003;  //getRand is pixel based so we divide arg by sc so that it looks the same on all scales\n    //g+=normalize(p.pos-iResolution.xy*.5)*.001;\n    float gl=length(g);\n    vec2 gu=normalize(g);\n    \n    // calculate velocity change\n    vec2 dvel=vec2(0);\n    \n    float dir = (float(p.idx%2)*2.-1.); // every 2nd particle is bent left/right\n    \n    // apply some randomness to velocity\n    dvel += .7*(getRand(p.pos/sc,iChannel1).xy-.5)/(.03+gl*gl)*sc;\n\n    // vel tends towards gradient\n    dvel -= 10.*gu*(1.+sqrt(gl*2.))*sc;\n    \n    // vel tends towards/away from normal to gradient (every second particle)\n    dvel -= 20.*N(gu)/(1.+1.*sqrt(gl*100.))*sc*dir;\n    \n    // vel bends right/left (every second particle)\n    //dvel += p.vel.yx*vec2(1,-1)*.06;\n    dvel += .06*N(p.vel)/(1.+gl*10.)*dir;\n    \n    p.vel += dvel;\n    \n    // minimum vel\n    //p.vel = normalize(p.vel)*max(length(p.vel),30.*sc);\n    \n    // anisotropic vel damping\n    p.vel-=gu*dot(p.vel,gu)*(.1+2.*gl);\n    //p.vel-=gu*dot(p.vel,gu)*.1;\n    p.vel-=N(gu)*dot(p.vel,N(gu))*-.02;\n    //p.vel*=.95;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    int lNum = 40;\n    Particle p;\n    int idx = particleIdx(fragCoord,iChannel0);\n    readParticle(p,idx%PNUM,iChannel0);\n    if (idx<PNUM)\n    {\n        propagate(p);\n        propagate(p);\n        propagate(p);\n        int atOnce=PNUM/100;\n        //if (int(getRand(iFrame%PNUM).x*float(PNUM/2)) == p.idx/30) p.pos=getRand((iFrame+p.idx)%PNUM).xy*iResolution.xy;\n        //if (int(getRand(iFrame).x*float(PNUM/atOnce)) == p.idx/atOnce)\n        if ((p.idx+iFrame)%lNum == lNum-1)\n        {\n            p.pos=getRand(p.idx+iFrame+iFrame/17,iChannel1).yz*iResolution.xy;\n            for(int i=0;i<10;i++) propagate(p);\n        }\n            //initParticle(p);\n    }\n\telse if (idx>PNUM*2) discard;\n    if (iFrame<10) initParticle(p,iChannel0,iChannel1,iFrame);\n    //if (idx>PNUM) { p.pos=vec2(0,0); p.vel=vec2(1,1); readParticle(p,idx-PNUM); }\n    writeParticle(p,fragColor,fragCoord,iChannel0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// accumulating up the line segments\n// slowly fading out older cotent\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //fragColor = max(texture(iChannel0,uv),clamp(texture(iChannel1,uv)-.003,0.,1.));\n    //fragColor = clamp(texture(iChannel0,uv)+texture(iChannel1,uv)-.003,0.,1.);\n    fragColor = (texture(iChannel0,uv)+texture(iChannel1,uv))*(1.-.006/2000.*float(PNUM));\n    fragColor.w=1.;\n    if(iFrame<10) fragColor=vec4(0,0,0,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// drawing a line segment from previous position to actual \n// for every particle (ballpoint tip)\n\n#define PI 3.1415927\n\n#define PNUM 200\n\nstruct Particle {\n    vec2 pos;\n    vec2 vel;\n    int idx;\n};\n\nint particleIdx(vec2 coord, sampler2D s)\n{\n    ivec2 ires=textureSize(s,0);\n    return int(coord.x)+int(coord.y)*ires.x;\n}\n\nvec2 particleCoord(int idx, sampler2D s)\n{\n    ivec2 ires=textureSize(s,0);\n    return vec2(idx%ires.x,idx/ires.x)+.5;\n}\n\nvec4 getPixel(vec2 coord, sampler2D s)\n{\n    return texelFetch(s,ivec2(coord),0);\n}\n\nvoid readParticle(inout Particle p, vec2 coord, sampler2D s)\n{\n    vec4 pix=getPixel(coord,s);\n    p.pos=pix.xy;\n    p.vel=pix.zw;\n    p.idx=particleIdx(coord,s);\n}\n\nvoid readParticle(inout Particle p, int idx, sampler2D s)\n{\n    readParticle(p,particleCoord(idx,s),s);\n}\n\nvoid writeParticle(Particle p, inout vec4 col, vec2 coord, sampler2D s)\n{\n    if (particleIdx(coord,s)%PNUM==p.idx) col=vec4(p.pos,p.vel);\n}\n\nvec4 getRand(vec2 pos, sampler2D s)\n{\n    vec2 rres=vec2(textureSize(s,0));\n    return textureLod(s,pos/rres,0.);\n}\n\nvec4 getRand(int idx, sampler2D s)\n{\n    ivec2 rres=textureSize(s,0);\n    idx=idx%(rres.x*rres.y);\n    return texelFetch(s,ivec2(idx%rres.x,idx/rres.x),0);\n}\n\nvoid initParticle(inout Particle p, sampler2D s, sampler2D sr, int frame)\n{\n    vec2 res=vec2(textureSize(s,0));\n    //p.pos = vec2((p.idx/2)%NUM_X,(p.idx/2)/NUM_X)*res/vec2(NUM_X,NUM_Y);\n    p.pos=getRand(frame+p.idx,sr).xy*res.xy;\n    p.vel = (getRand(p.pos,sr).xy-.5)*(float(p.idx%2)-.5)*300.;\n}\n\nvec4 getCol(vec2 pos, sampler2D s, vec2 res)\n{\n    return textureLod(s,pos/res.xy,0.);\n}\n\nfloat getVal(vec2 pos, sampler2D s, vec2 res)\n{\n    return dot(getCol(pos,s,res).xyz,vec3(1)/3.);\n}\n\nvec2 getGrad(vec2 pos, float eps, sampler2D s, vec2 res)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy,s,res)-getVal(pos-d.xy,s,res),\n        getVal(pos+d.yx,s,res)-getVal(pos-d.yx,s,res)\n        )/eps/2.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}