{
    "Shader": {
        "info": {
            "date": "1581547402",
            "description": "potaot",
            "flags": 32,
            "hasliked": 0,
            "id": "wl3Szs",
            "likes": 26,
            "name": "Day 55",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "// for something similar check out BigWIngs's shader\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.002).x;\n    fragColor.y = T(uv -f*0.002).y;\n    fragColor.z = T(uv).z;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// sdfs from inigo quilez\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdEquilateralTriangle( in vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n#define iTime (iTime + 100.)\n\n#define outline(x, w) (abs(x) - w)\n#define inline(x) -((x)) \n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(a, x) mod(a, x) - x*0.5\n\n#define drawCirc(i, o, repD, p) \\\ncirc =  min(circ, max(\t\\\n           max(\t\\\n               -min(circ, inline(length(p) + i)),\t\\\n               min(circ, inline(length(p) +o))\t\\\n              ),\t\\\n           min(circ, abs(pmod(pC.x, repD)) - W*2./pC.y)\t\\\n          ));\t\n\n\n#define pal(a,b,c,d,e) (a + b*sin(tau*(c*d + e)))\n\n#define mx (iTime*0.3 + 10.*iMouse.x/iResolution.x)\nvec3 sumonTheDemon( vec2 p, float id )\n{\n    vec3 col = vec3(0);\n\n    #define W 0.0003\n    \n    \n    float rA = texture(iChannel0, vec2(sin(id*0.01)*200.,id )).x;\n    float rB = texture(iChannel0, vec2(sin(id*0.03 + 0.2)*200.,id*1.4 )).x;\n    float rS = sign(rA - 0.5);\n    float rSB = sign(rB - 0.5);\n    \n    vec2 k = p;\n    p.xy *= rot(iTime*rB*rS*0.2);\n    //p.xy *= rot(iTime*sign(mod(id,2.)- 1.));\n    \n    float baseW = 0.05;\n    \n    float levels = 2.;\n    \n    //float circ = abs(length(p) - baseW) - W;\n    float circ = 10e5;\n    \n    float currW = baseW;\n    \n    \n    \n    vec2 pC = vec2(atan(p.y, p.x), length(p));\n    \n\n    pC.x += iTime*rS*rB*0.2; // mod\n    \n    \n    for(float level = 0.; level < levels; level++){\n        \n        currW += 0.1;\n        vec2 q = p;\n        float rots = 3. + floor(rA*3.);\n        if(rA>0.6)\n            rots = 20.;\n        for(float i = 0.; i < rots; i++){\n            //q = abs(q);\n            q*=rot(tau*i/rots + sin(iTime*0.2)*0.1);\n            circ = min(circ, outline(sdEquilateralTriangle( q, currW*0.86 ),W));\n            //circ = min(circ, outline(sdEquilateralTriangle( p*rot(0.325*pi), 0.26 ), W));\n\n        }\n    \n    }\n    circ = min(circ, outline(length(p) - currW*1., W));\n    \n    float outW = 0.03;\n    currW += outW;\n    circ = min(circ, outline(length(p) - currW*1., W));\n    \n    \n    drawCirc(- currW*1.- W, - currW*1.- W + outW, 0.125*pi ,p);\n    \n    //circ = min(circ, outline(length(p) - currW*0.74, W));\n    //drawCirc(- currW*1., - currW*1. - 0.2, 0.5 );\n\n    //float outerCircs = 4.;\n    float outerCircs = 4. + floor(rB*4.);\n    for(float i = 0.; i < outerCircs; i++){\n        vec2 u = p;\n        u *= rot(tau*i/outerCircs);\n    \tu += vec2(0,currW*1.5);\n        \n        vec2 j = u;\n        float currW = 0.18;\n        \n        \n        circ = max(circ, inline(length(u) - currW*1.+ W));\n        circ = min(circ, outline(length(u) - currW*1., W));\n\n        \n        pC = vec2(atan(u.y, u.x), length(u));\n\t\t\n    \tpC.x += -iTime*rS*rB*0.4; // mod\n        \n        drawCirc(- currW, - currW+ 0.03, 0.125*pi, u );\n        circ = min(circ, outline(length(u) - currW*1. + 0.03, W));\n\n        \n        vec2 q = j;\n        \n        \n        for(int i = 0;i < 3; i++){\n        \tq = abs(q);\n            //q *= rot(0.125*pi);\n            if(rB < 0.2){\n            \tq.x -= 0.2;\n            }\n            if(rA < 0.3){\n            \tq.y -= 0.01;\n            \n            }\n            q *= rot(pi*floor(rA*4.)/4.);\n            \n        }\n        circ = min(circ, outline(sdTriangleIsosceles( q, vec2(currW*0.69) ),W));\n        \n        float rots = 3.;\n        for(float i = 0.; i < rots; i++){\n            q*=rot(tau*i/rots);\n            circ = min(circ, outline(sdEquilateralTriangle( q, currW*0.86 ),W)); // mod\n        }\n    \n    }\n\n    for(int i = 0; i < 4; i++){\n        p *= rot(-0.125*pi);\n    \tp = abs(p);\n        p.x -= 0.65;\n        p.y -= 0.55;\n        \n    }\n    //p = abs(p);\n    for(float i = 1.; i <=outerCircs; i++){\n        float m = tau*i/outerCircs;\n        vec2 g = vec2(sin(m),cos(m))*0.7;\n        \n        m = tau*(i+1.)/outerCircs;\n        vec2 h = vec2(sin(m),cos(m))*0.7;\n        \n        circ = min(circ, sdLine( p, g,h ));\n\n    }\n    \n    p.xy *= rot(0.5);\n    \n    //circ = min(circ, sdLine( p, vec2(0.4),vec2(-0.4) ));\n    \n    col += smoothstep(0.005,0.,circ)*vec3(1)*1.;    \n    \n    \n    //col *= pal(0.9,vec3(1.,1.,1.)*.5,vec3(2.87,4.4,1.8), pi, id*.1)*2.;\n    //col *= pal(0.9,vec3(1.,1.,1.)*.5,vec3(2.87,4.4,1.8), pi, id*.1)*2.;\n    //col *= pal(0.8,vec3(1.,1.,1.)*0.5,vec3(1.87,4.4,1.8), vec3(3.7,2.3,0.1),  iTime);\n    //col *= pal(0.9,vec3(1.,1.,0.1)*0.5,vec3(1.87,4.4,1.8), vec3(3.7,2.3,0.1), iTime);\n    col *= pal(1.5,vec3(1.,1.,1.)*0.7,vec3(1.87,4.4,1.8), vec3(3.7,2.5,1.1), id*0.1);\n    //col *= pal(1.5,vec3(1.,1.,1.)*0.5,vec3(1.1,4.4,1.8), vec3(3.7,2.5,1.), id*0.1);\n    \n    \n    float stars = 10e5;\n    for(int i = 0; i < 7; i++){\n    \tk = abs(k);\n    \t\n        k.x -= 0.2;\n        k *= rot(2.);\n        if(i > 0){\n        \tstars = min(stars, length(k) - 0.001);\n        }\n    }\n    \n    col += smoothstep(0.005,0.,stars)*vec3(1)*2.;    \n\n    \n    return col;\n}\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 p0, vec3 n){\n    float denom = dot(rd,n);\n    if (denom > 1e-6) {\n        float t = - dot(ro - p0, n)/denom; \n\t\tif (t > 0.) return t;\n        return t;\n    }  \n    return 1e10;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    //uv *= 1. - length(uv)*0.15;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    ro.z;\n    vec3 rd = normalize(vec3(uv,1));\n    \n    \n    \n    #define fog(a) smoothstep(1., 0., a*0.24)\n    float plA = iPlane(ro, rd, vec3(0,0,mod(-mx,4.)), vec3(0,0,1));\n    col += sumonTheDemon( (ro+rd*plA).xy, floor(-mx/4.)*4.)*fog(plA);\n    float plB = iPlane(ro, rd, vec3(0,0,mod(-mx + 1., 4.)), vec3(0,0,1));\n    col += sumonTheDemon( (ro+rd*plB).xy, floor((-mx+1.)/4.)*4.+1.)*fog(plB);\n    float plC = iPlane(ro, rd, vec3(0,0,mod(-mx + 2., 4.)), vec3(0,0,1));\n    col += sumonTheDemon( (ro+rd*plC).xy, floor((-mx+2.)/4.)*4.+2.)*fog(plC);\n    float plD = iPlane(ro, rd, vec3(0,0,mod(-mx + 3., 4.)), vec3(0,0,1));\n    col += sumonTheDemon( (ro+rd*plD).xy, floor((-mx+3.)/4.)*4.+3.)*fog(plD);\n    \n    \n    \n    //col += sumonTheDemon( uv);\n\t\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}