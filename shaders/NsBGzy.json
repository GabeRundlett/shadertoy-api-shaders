{
    "Shader": {
        "info": {
            "date": "1617551725",
            "description": "Released in the 4k Executable Graphics compo at Revision 2021.\n\nDownload the executable version here: [url]https://www.pouet.net/prod.php?which=88577[/url]\n\nNote: All comments on how to minify the shader further will be deleted.",
            "flags": 32,
            "hasliked": 0,
            "id": "NsBGzy",
            "likes": 31,
            "name": "Submit [Revision 2021]",
            "published": 3,
            "tags": [
                "sdf",
                "pathtracing",
                "revision",
                "sizecoding",
                "demoparty",
                "bdsm"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 852
        },
        "renderpass": [
            {
                "code": "float seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\t// seed the RNG (again taken from Devour)\n    seed = float((int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n\t// readback the buffer\n\tvec4 tex = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    uv-=.5;\n\t\n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n    \n    // kinda hacky firefly denoiser\n    vec4 t0 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2( 1,0),0); t0/=t0.w;\n\tvec4 t1 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2(-1,0),0); t1/=t1.w;\n\tvec4 t2 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2(0, 1),0); t2/=t2.w;\n\tvec4 t3 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2(0,-1),0); t3/=t3.w;\n    vec4 colMax = max(max(t0,t1),max(t2,t3));\n    vec4 colMid = (t0+t1+t2+t3)*.25;\n\tif (color.r > colMax.r+.015)\n\t{\n\t\tcolor = colMid.rgb;\n\t}\n\n    // exposure and tonemap\n    color = 1.-exp(color*-2.);\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n\n    // make it pop\n    color = mix(color,smoothstep(.0,1.,color),.6);\n    \n    // raise black level\n    color = mix(vec3(.04),vec3(1),color);\n\n    // grain\n    color += (vec3(hash(),hash(),hash())-.5)*.01;\n\n    // aspect ratio\n    uv*=vec2(iResolution.xy/iResolution.yx);\n    color *= step(abs(uv.y),.5/(20./9.));\n    color *= step(abs(uv.x),.5*(20./9.));\n        \n\tfragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n#define tau (pi*2.)\n\n\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\nmat2 rotate(float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdRoundBox2( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k )\n{\n    return -smin(-a,-b,k);\n}\n\n\n\nint mat;\nconst int matNormal = -1;\nconst int matBall = 0;\nconst int matLeather = 1;\nconst int matMetal = 2;\nconst int matGround = 3;\n\nfloat scene_ball(vec3 p)\n{\n    float ball = length(p)-10.;\n    float seam = sdTorus(p.xzy,vec2(10.,.035));\n    return min(ball,seam);\n}\n\nfloat scene_inner_strap(vec3 p, float rivets)\n{\n    float height = 2.5;\n    float thickness = .4;\n\n    vec3 p1=p+vec3(0,0,smoothstep(20.,25.,abs(p.x))*.9);\n    float strap1 = sdRoundBox(p1,vec3(25,height,thickness),.1);\n    \n    vec3 p2=vec3(abs(p.x),p.yz)-vec3(20,0,1.+smoothstep(20.,25.,abs(p.x))*.9);\n    float strap2 = sdRoundBox(p2,vec3(5,height,thickness),.1);\n    \n    vec2 p3=vec2(length(vec2(abs(p.x)-25.,p.z-.5))-1.4,p.y);\n    float strap3 = max(sdRoundBox2(p3,vec2(thickness,height),.1),24.9-abs(p.x));\n    \n    float strap = min(min(strap1,strap2),strap3);\n    \n    strap = smax(strap,-rivets*.5,.5);\n    \n    if(abs(strap) < .025)\n    {\n        strap += (texture(iChannel1,p*.4).r-.5)*.025;\n    }\n    \n    return strap;\n}\n\nfloat scene_outer_strap(vec3 p)\n{\n    float height = 4.2;\n    float thickness = .4;\n    float loopRadius = .5;\n\n    vec3 p1=p+vec3(0,0,smoothstep(22.,25.,abs(p.x))*loopRadius);\n    float strap1 = sdRoundBox(p1,vec3(25,height,thickness),.1);\n    \n    vec3 p2=vec3(abs(p.x),p.yz)-vec3(22,0,1.+smoothstep(22.,25.,abs(p.x))*loopRadius);\n    float strap2 = sdRoundBox(p2,vec3(3,height,thickness),.1);\n    \n    vec2 p3=vec2(length(vec2(abs(p.x)-25.,p.z-.5))-(loopRadius+.5),p.y);\n    float strap3 = max(sdRoundBox2(p3,vec2(thickness,height),.1),24.9-abs(p.x));\n    \n    float strap = min(min(strap1,strap2),strap3);\n    \n    if(abs(strap) < .025)\n    {\n        strap += (texture(iChannel1,p*.4).r-.5)*.025;\n    }\n    \n    return strap;\n}\n\nfloat scene_inner_strap_rivets(vec3 p)\n{\n    p.x = abs(p.x)-18.;\n    p.z = abs(p.z-.4)-.75;\n    \n    float r = 1.5;\n    float bound = length(p)-r;\n    if (bound > .1)\n        return bound;\n    return sdEllipsoid(p,vec3(r,r,.4));\n}\n\nfloat scene_d_ring(vec3 p)\n{\n    float thickness = .6;\n    float bigradius = 6.;\n    float smallradius = 2.;\n    \n    float bigring = sdTorus(p.xzy,vec2(bigradius,thickness));\n    p.y=max(abs(p.y)-bigradius+smallradius,0.);\n    float corner = sdTorus(p.xzy,vec2(2,thickness));\n    return min(max(bigring,p.x),max(corner,-p.x));\n}\n\nfloat scene(vec3 p)\n{\n    vec3 oop=p;\n    \n    p.xz *= rotate(pi);\n    p.yz *= rotate(.5);\n    vec3 op=p;\n\n    float ball = scene_ball(p);\n    \n    vec2 pp=vec2(0,40)-p.xz;\n    p.xz = vec2(atan(pp.x,pp.y)*40.,-length(pp.xy)+40.);\n    float inner_strap_rivets = scene_inner_strap_rivets(p);\n    float inner_strap = scene_inner_strap(p,inner_strap_rivets);\n\n    p=op;\n    p.x = 58.4-abs(p.x);\n    p.xz *= rotate(1.);\n    p.xz -= vec2(-20.4,31.4);\n\n    float outer_strap = scene_outer_strap(p);\n    \n    p=op;\n    p.x=abs(p.x);\n    p.x -= 27.7;\n    p.z-=11.5;\n    p.xz*=rotate(-.7);\n    float d_ring = scene_d_ring(p);\n\n    float best = ball;\n    //best=min(best,ground);\n    best=min(best,inner_strap);\n    best=min(best,outer_strap);\n    best=min(best,inner_strap_rivets);\n    best=min(best,d_ring);\n    \n         if (best==ball)               mat=matBall;\n    else if (best==inner_strap)        mat=matLeather;\n    else if (best==outer_strap)        mat=matLeather;\n    else if (best==inner_strap_rivets) mat=matMetal;\n    else if (best==d_ring)             mat=matMetal;\n    \n    return best;\n}\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,-1),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 sunDir, vec3 viewDir) {\n    float side = smoothstep(.9,.98,dot(viewDir,normalize(vec3(1,.1,.5))));\n    float key = smoothstep(.99,1.,dot(viewDir,sunDir));\n    return vec3(side*.2 + key*5.) * 2.5;\n}    \n\nbool trace5(vec3 cam, vec3 dir, out vec3 h, out vec3 n, out float k) {\n\tfloat t=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t += k;\n        if (abs(k) < .001)\n            break;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<.001)\n    {\n        vec2 o = vec2(.001, 0);\n        k=scene(h);\n        n = normalize(vec3(\n            scene(h+o.xyy) - k,\n            scene(h+o.yxy) - k,\n            scene(h+o.yyx) - k \n        ));\n        return true;\n    }\n    return false;\n}\n\nvec3 trace2(vec3 cam, vec3 dir)\n{\n    vec3 sunDirection = normalize(vec3(-.3,.7,1.));\n    const float sunSize = 1e-3;\n    float sunColor = 2. * 2.5;\n    \n    vec3 accum = vec3(1.);\n    vec3 direct = vec3(0.);\n    for(int ibounce=0;ibounce<10;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace5(cam,dir,h,n,k))\n        {\n\t\t\tcam = h+n*.002;\n            \n            if (mat == matNormal)\n            {\n                return n*.5+.5;\n            }\n            else if (mat == matMetal)\n            {\n                dir = reflect(dir,n);\n            }\n            else\n            {\n                if (mat == matBall)\n                    accum *= .7;\n                if (mat == matGround)\n                    accum *= .1;\n            \n                dir=getSampleBiased(n,1.);\n\n                // haaaaaacks\n                if (mat == matLeather) {\n                    float fresnel = pow(1.-min(.99,dot(dir,n)),5.);\n                    accum *= fresnel;\n                }\n\n                vec3 sunSampleDir = getConeSample(sunDirection,sunSize);\n                float sunLight = dot(n, sunSampleDir);\n                vec3 dummy0,dummy1;\n                float dummy2;\n                if (sunLight>0.0 && !trace5(h + n*.002,sunSampleDir,dummy0,dummy1,dummy2)) {\n                    direct += accum*sunLight*sunColor;\n                }\n            }\n        }\n        else if (abs(k) > .1) {\n            return direct + sky(sunDirection, dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    // not sure about this\n    return direct + sky(sunDirection, dir) * accum;\n    \n    // deliberately fail the pixel\n    return vec3(1,0,1);\n}\n\nvec2 bokeh(){\n    // hexagon\n    vec2 a = hash2();\n    a.x=a.x*3.-1.;\n    a-=step(1.,a.x+a.y);\n\ta.x += a.y * .5;\n\ta.y *= sqrt(.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // readback previous pixel color\n    fragColor = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n    // clear on click\n    if (iMouse.z > 0.)\n        fragColor = vec4(0);\n\n\t// seed the RNG (again taken from Devour)\n    seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n    // get UVs\n    vec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n    \n    // correct UVs for aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x*=aspect;\n\tuv *= max(1.,(20./9.)/aspect);\n\t\n    // camera params\n    const vec3 camPos = vec3(0,0,-80);\n    const vec3 lookAt = vec3(0,1,0);\n    const float focusDistance=distance(camPos,lookAt);\n    const vec2 apertureRadius=vec2(1,1)*.3;\n   \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,2.5));\n    \n    // slight bokeh (imperceptible in practice)\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n\n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec3 pixel = trace2(cam,dir);\n        \n    fragColor += (!isnan(pixel.r) && pixel.r >= 0.) ? vec4(vec3(pixel),1) : vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n~ Submit\n  by yx\n\n~ 4kb executable graphics\n  released at Revision 2021\n\n~ content warning:\n  suggestive bdsm themes\n\n~ tools:\n  crinkler by loonies & tbc\n  shader minifier by llb\n  blossom by yx\n\n~ note:\n  the party exe runs at 1080p,\n  with a 30-second rendering limit\n  designed for Revision rules.\n  --\n  the other exe will match your\n  display's resolution, and takes\n  as long as it needs to reach\n  1024 samples.\n\n~ greetings:\n  alia\n  alkama\n  bitnenfer\n  blackle\n  cpdt\n  evvvvil\n  fizzer\n  flopine\n  iq\n  noby\n  nusan\n  slerpy\n  tdhooper\n  wrighter\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}