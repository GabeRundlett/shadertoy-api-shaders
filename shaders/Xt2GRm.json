{
    "Shader": {
        "info": {
            "date": "1428677010",
            "description": "Simple VR test (Google Cardboard, tested on iPhone 5S). The actual project uses the device's gyroscope to control the camera, here you can use the mouse instead. There is currently no correction of the lenses deformation as I couldn't find the specs...",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt2GRm",
            "likes": 15,
            "name": "VR City",
            "published": 3,
            "tags": [
                "raymarching",
                "vr"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1575
        },
        "renderpass": [
            {
                "code": "// Note: set \"VR\" to 0.0 for classic (non-VR) rendering / 1.0 for VR.\n// For VR, better increase \"FOV\".\n\n///////////////////\n// Shadertoy (1) //\n///////////////////\n\n// Rendering parameters\n#define FOV\t\t\t\t40.0\n#define IPD\t\t\t\t0.0005\n#define VR \t\t\t\t0.0\n#define headModel\t\tvec3 (0.0, 0.001, 0.0005)\n#define QUALITY_HIGH\n\n// Uniform variables\nvec3 resolution;\nfloat time;\nvec3 headPosition;\nmat3 headRotate;\n\n///////////\n// Unity //\n///////////\n\n// Rendering parameters (optional)\n#define HOLES\n#ifdef QUALITY_HIGH\n\t#define HOLLOW_THICKNESS_MIN\t0.001\n\t#define HOLLOW_THICKNESS_MAX\t0.1\n\t#define SHADOW_LENGTH\t\t\t20.0\n\t#define SHADOW_FACTOR\t\t\t250.0\n#endif\n#define HSV2RGB_FAST\n#define TEXTURE_SCALE\t\t\t\t2.0\n#define GLOW_FACTOR\t\t\t\t\t0.4\n\n// Rendering parameters (mandatory)\n#define RAY_LENGTH_MAX\t\t15.0\n#define RAY_STEP_MAX\t\t120.0\n#define AMBIENT\t\t\t\t0.1\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t2.0\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define DELTA\t0.0001\n#define PI\t\t3.14159265359\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\n// Identifier (color) of the ground\nfloat idGround (in vec2 p) {\n\t#ifdef TEXTURE_SCALE\n\treturn 0.2;\n\t#else\n\tp = fract (p * 19.0) - 0.5;\n\treturn p.x * p.y * 0.004 + 0.008;\n\t#endif\n}\n\n// Distance to the building\nfloat distBuilding (in vec3 p, out float id) {\n\n\t// Take note of the ground coordinates\n\tvec2 ground = p.xz;\n\n\t// Change coordinates to cell space, and get the id of this building\n\tp.xz += 0.5;\n\tid = rand (floor (p.xz));\n\tif (fract (id * 31.0) > 0.7) {\n\n\t\t// Ground (empty cell)\n\t\tid = idGround (ground);\n\t\treturn p.y;\n\t}\n\tp.xz = fract (p.xz) - 0.5;\n\n\t// Rotation\n\tfloat angle = id * PI * 0.5;\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\tp.xz = vec2 (c * p.x + s * p.z, c * p.z - s * p.x);\n\n\t// Translation\n\tangle = id * PI * 5.0;\n\tp.xz += 0.07 * vec2 (cos (angle), sin (angle));\n\n\t// Rounded box\n\tfloat boxHalfSize = 0.25 + 0.1 * cos (id * PI * 7.0);\n\tfloat boxHeight = 1.5 + id * 2.5;\n\tfloat boxRadius = boxHalfSize * (0.5 + 0.5 * cos (id * PI * 11.0));\n\tvec3 o = abs (p) - vec3 (boxHalfSize, boxHeight, boxHalfSize) + boxRadius;\n\tfloat dist = length (max (o, 0.0)) - boxRadius;\n\n\t// Carve this rounded box using other (signed) rounded boxes\n\t#ifdef HOLES\n\t#ifdef HOLLOW_THICKNESS_MIN\n\tfloat thickness = HOLLOW_THICKNESS_MIN + (HOLLOW_THICKNESS_MAX - HOLLOW_THICKNESS_MIN) * fract (id * 13.0);\n\tboxHalfSize -= thickness;\n\tboxHeight -= thickness;\n\tboxRadius = max (0.0, boxRadius - thickness);\n\to = abs (p) - vec3 (boxHalfSize, boxHeight, boxHalfSize) + boxRadius;\n\tdist = max (dist, boxRadius - min (max (o.x, max (o.y, o.z)), 0.0) - length (max (o, 0.0)));\n\tboxHalfSize += thickness;\n\t#endif\n\n\tfloat boxPeriod = boxHalfSize * 0.3 * (0.8 + 0.2 * cos (id * PI * 13.0));\n\tboxHalfSize = boxPeriod * 0.45 * (0.9 + 0.1 * cos (id * PI * 17.0));\n\tboxRadius = boxHalfSize * (0.5 + 0.5 * cos (id * PI * 19.0));\n\to = abs (mod (p, boxPeriod) - 0.5 * boxPeriod) - boxHalfSize + boxRadius;\n\tdist = max (dist, boxRadius - min (max (o.x, max (o.y, o.z)), 0.0) - length (max (o, 0.0)));\n\t#endif\n\n\t// Ground\n\tif (dist > p.y) {\n\t\tdist = p.y;\n\t\tid = idGround (ground);\n\t}\n\treturn dist;\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out float rayStepCount, out float shadow) {\n\n\t// Initialize the returned values\n\tvec3 hitPosition = rayOrigin;\n\trayLength = 0.0;\n\trayStepCount = 0.0;\n\tshadow = 1.0;\n\n\t// Initialize the tracking of the grid cells\n\tvec2 raySign = sign (rayDirection.xz);\n\tvec2 rayDeltaCell;\n\trayDeltaCell.x = rayDirection.x != 0.0 ? raySign.x / rayDirection.x : RAY_STEP_MAX;\n\trayDeltaCell.y = rayDirection.z != 0.0 ? raySign.y / rayDirection.z : RAY_STEP_MAX;\n\tvec2 rayDelta = (0.5 - raySign * (fract (rayOrigin.xz + 0.5) - 0.5)) * rayDeltaCell;\n\tfloat distMax = min (rayDelta.x, rayDelta.y);\n\n\t// Launch the ray\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Get the distance to the building in this grid cell\n\t\tfloat id;\n\t\tfloat dist = distBuilding (hitPosition, id);\n\t\tif (dist < DELTA) {\n\t\t\tshadow = 0.0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Soft shadow\n\t\t#ifdef SHADOW_FACTOR\n\t\tshadow = min (shadow, SHADOW_FACTOR * dist / rayLength);\n\t\t#endif\n\n\t\t// Make sure we haven't reached the next grid cell\n\t\tif (dist > distMax - rayLength) {\n\t\t\tdist = distMax - rayLength + DELTA;\n\t\t\trayDelta += step (rayDelta.xy, rayDelta.yx) * rayDeltaCell;\n\t\t\tdistMax = min (rayDelta.x, rayDelta.y);\n\t\t}\n\n\t\t// March...\n\t\trayLength += dist;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\thitPosition += dist * rayDirection;\n\t\t++rayStepCount;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, out float id) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n \t\th.xxx * distBuilding (p + h.xxx, id) +\n\t\th.xyy * distBuilding (p + h.xyy, id) +\n\t\th.yxy * distBuilding (p + h.yxy, id) +\n\t\th.yyx * distBuilding (p + h.yyx, id)\n\t);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid _main (out vec4 _gl_FragColor, in vec2 _gl_FragCoord) {\n\n\t// Change the position of the head\n\tvec3 headPositionModified = headPosition + vec3 (10.0 * cos (time * 0.1), 0.2 + 3.8 * smoothstep (0.5, -0.5, cos (time * 0.2)), 0.5);\n\n\t// Define the ray corresponding to this fragment\n\tfloat rayStereo = 0.5 * sign (_gl_FragCoord.x - resolution.x * 0.5) * step (0.5, VR);\n\tvec3 rayOrigin = headPositionModified + headRotate * (headModel + vec3 (rayStereo * IPD, 0.0, 0.0));\n\tvec3 rayDirection = headRotate * normalize (vec3 ((2.0 * _gl_FragCoord.x - (1.0 + rayStereo) * resolution.x), 2.0 * _gl_FragCoord.y - resolution.y, 0.5 * resolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tfloat hitStepCount;\n\tfloat hitShadow;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitStepCount, hitShadow);\n\n\t// Get the normal and ID\n\tfloat hitId;\n\tvec3 hitNormal = normal (hitPosition, hitId);\n\n\t// Lighting\n\tfloat lightYawAngle = PI * 0.1;\n\tfloat lightPitchAngle = time * 0.1;\n\tvec3 lightDirection = vec3 (sin (lightYawAngle) * sin (lightPitchAngle), cos (lightPitchAngle), cos (lightYawAngle) * sin (lightPitchAngle));\n\n\tfloat diffuse = 0.0;\n\tfloat specular = 0.0;\n\tif (lightDirection.y > 0.0) {\n\t\tdiffuse = max (0.0, dot (hitNormal, lightDirection));\n\t\tspecular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t#ifdef SHADOW_LENGTH\n\t\tfloat shadowDistance;\n\t\tfloat shadowStepCount;\n\t\tfloat shadow;\n\t\thit (hitPosition + hitNormal * DELTA * 2.0, lightDirection, SHADOW_LENGTH, shadowDistance, shadowStepCount, shadow);\n\t\tdiffuse *= shadow;\n\t\tspecular *= shadow;\n\t\t#endif\n\t}\n\n\t// Set the object color\n\tvec3 color = hsv2rgb (vec3 (hitId * 73.0, 0.8, 0.8));\n\t#ifdef TEXTURE_SCALE\n\tvec3 textureUV = hitPosition * TEXTURE_SCALE;\n\tvec3 textureFactor = abs (hitNormal);\n\tmat3 textureColor = mat3 (\n\t\ttexture (iChannel0, textureUV.yz).rgb,\n\t\ttexture (iChannel0, textureUV.zx).rgb,\n\t\ttexture (iChannel0, textureUV.xy).rgb\n\t\t);\n\tcolor *= textureColor * textureFactor / (textureFactor.x + textureFactor.y + textureFactor.z);\n\t#endif\n\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t// Set the sky color\n\tdiffuse = max (0.0, dot (rayDirection, lightDirection));\n\tfloat skyBelow = min (1.0, 1.0 + lightDirection.y);\n\tvec3 skyColor = mix (vec3 (1.0, 0.4, 0.2), vec3 (0.4, 0.4, 1.0), max (0.0, lightDirection.y));\n\tskyColor += vec3 (1.0, 0.9, 0.6) * pow (diffuse, 8.0);\n\tskyColor = mix (vec3 (0.0, 0.0, 0.1), skyColor, skyBelow);\n\tskyColor *= 0.3 + 0.7 * diffuse;\n\n\t// Blend the object and sky colors\n\tcolor = mix (skyColor, color, pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER));\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Add a glow effect\n\t#ifdef GLOW_FACTOR\n\tcolor += GLOW_FACTOR * (hitStepCount / RAY_STEP_MAX) * (1.0 - hitShadow) * (1.0 - skyBelow) * smoothstep (3.0, 0.0, hitPosition.y);\n\t#endif\n\n\t// Set the fragment color\n\t_gl_FragColor = vec4 (color, 1.0);\n}\n\n///////////////////\n// Shadertoy (2) //\n///////////////////\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Basic initialization\n\tresolution = iResolution;\n\ttime = iTime;\n\n\t// Set the position of the head\n\theadPosition = vec3 (0.0);\n\n\t// Set the orientation of the head\n\tfloat yawAngle = 4.0 * PI * iMouse.x / iResolution.x;\n\tfloat pitchAngle = PI * (0.5 - iMouse.y / iResolution.y);\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\theadRotate [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadRotate [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadRotate [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\t// Set the fragment color\n\t_main (fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}