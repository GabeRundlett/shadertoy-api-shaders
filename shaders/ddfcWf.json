{
    "Shader": {
        "info": {
            "date": "1687254767",
            "description": "Continuous Dijkstra's algorithm in Euclidean space.\n\nClick and drag to adjust the starting point.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddfcWf",
            "likes": 4,
            "name": "Generalized Dijkstra's Algorithm",
            "published": 3,
            "tags": [
                "sdf",
                "pathfinding",
                "continuous",
                "dijkstra"
            ],
            "usePreview": 1,
            "username": "copperbotte",
            "viewed": 213
        },
        "renderpass": [
            {
                "code": "\n//for i, path in enumerate(paths):\n//\tprint(\"const int path%d_len = %d;\"%(i, len(path)))\n//\tprint(\"vec2 path%d[path%d_len] = vec2[](\"%(i, i))\n//\tfor j, p in enumerate(path):\n//\t\ts = \"\\tvec2(%f, %f),\"%p\n//\t\tif j+1 == len(path):\n//\t\t\ts = s[:-1]\n//\t\tprint(s)\n//\tprint(\");\")\n//\tprint()\n\n\nconst int path0_len = 5;\nvec2 path0[path0_len] = vec2[](\n\tvec2(0.000000, 0.000000),\n\tvec2(1.388889, 0.000000),\n\tvec2(1.388889, 1.000000),\n\tvec2(0.000000, 1.000000),\n\tvec2(0.000000, 0.000000)\n);\n\nconst int path1_len = 7;\nvec2 path1[path1_len] = vec2[](\n\tvec2(0.176389, 0.919444),\n\tvec2(0.298611, 0.916667),\n\tvec2(0.379167, 0.811111),\n\tvec2(0.309722, 0.702778),\n\tvec2(0.162500, 0.702778),\n\tvec2(0.093056, 0.805556),\n\tvec2(0.176389, 0.919444)\n);\n\nconst int path2_len = 4;\nvec2 path2[path2_len] = vec2[](\n\tvec2(0.272222, 0.376389),\n\tvec2(0.591667, 0.773611),\n\tvec2(0.697222, 0.256944),\n\tvec2(0.272222, 0.376389)\n);\n\nconst int path3_len = 5;\nvec2 path3[path3_len] = vec2[](\n\tvec2(0.805555, 0.351389),\n\tvec2(0.750000, 0.156945),\n\tvec2(0.972222, 0.093056),\n\tvec2(1.036111, 0.268056),\n\tvec2(0.805555, 0.351389)\n);\n\nconst int path4_len = 9;\nvec2 path4[path4_len] = vec2[](\n\tvec2(0.791667, 0.845833),\n\tvec2(0.777778, 0.659722),\n\tvec2(0.963889, 0.529167),\n\tvec2(0.719444, 0.540278),\n\tvec2(1.077778, 0.298611),\n\tvec2(1.213889, 0.626389),\n\tvec2(0.947222, 0.623611),\n\tvec2(0.972222, 0.837500),\n\tvec2(0.791667, 0.845833)\n);\n\nvec2 offs0[4] = vec2[](\n\tvec2(-0.811534, -0.584305),\n\tvec2(0.811534, -0.584305),\n\tvec2(0.811534, 0.584305),\n\tvec2(-0.811534, 0.584305)\n);\n\nvec2 offs1[6] = vec2[](\n\tvec2(-0.316228, 0.948683),\n\tvec2(0.375705, 0.926739),\n\tvec2(0.999829, 0.018515),\n\tvec2(0.583207, -0.812324),\n\tvec2(-0.603443, -0.797406),\n\tvec2(-0.997366, -0.072536)\n);\n\nvec2 offs2[3] = vec2[](\n\tvec2(-0.936903, -0.349591),\n\tvec2(0.227884, 0.973688),\n\tvec2(0.640514, -0.767946)\n);\n\nvec2 offs3[4] = vec2[](\n\tvec2(-0.533038, 0.846092),\n\tvec2(-0.905024, -0.425361),\n\tvec2(0.552462, -0.833538),\n\tvec2(0.954800, 0.297249)\n);\n\nvec2 offs4[8] = vec2[](\n\tvec2(-0.650792, 0.759256),\n\tvec2(-0.963518, -0.267644),\n\tvec2(-0.949902, 0.312548),\n\tvec2(-0.922194, 0.386727),\n\tvec2(0.363543, -0.931578),\n\tvec2(0.773006, 0.634398),\n\tvec2(0.802744, 0.596324),\n\tvec2(0.707107, 0.707107)\n);\n\n\nvec2 pt1 = vec2(0.17256944176474115, 0.1586805690634476);\nvec2 pt2 = vec2(1.0201200976064742, 0.6792735789518283);\n\n//https://stackoverflow.com/questions/16069959/glsl-how-to-ensure-largest-possible-float-value-without-overflow\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\nfloat sdf_circle(vec2 x, vec2 x0)\n{\n    return length(x - x0);\n}\n\n// Thanks iq!  This is capsule, with r=0.\n// https://iquilezles.org/articles/distfunctions/\nfloat sdf_segment(vec2 x, vec2 x0, vec2 x1)\n{\n    vec2 dx = x - x0;\n    vec2 dx1 = x1 - x0;\n    float dist = clamp(dot(dx, dx1)/dot(dx1, dx1), 0.0, 1.0); // Projection\n    return length(dx - dx1*dist);\n}\n\nfloat sdf(vec2 x)\n{\n    float dist = FLT_MAX;\n    \n\tfor(int i=0; i<path0_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path0[i], path0[i+1]));\n        \n\tfor(int i=0; i<path1_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path1[i], path1[i+1]));\n        \n\tfor(int i=0; i<path2_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path2[i], path2[i+1]));\n        \n\tfor(int i=0; i<path3_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path3[i], path3[i+1]));\n        \n\tfor(int i=0; i<path4_len-1; ++i)\n\t\tdist = min(dist, sdf_segment(x, path4[i], path4[i+1]));\n    \n    return dist;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//     This function finds if the points x0 and x1 are visible to each other \n// through the segment s0 to s1.\n// \n//     This works similarly to barycentric point-in-triangle, but checks if all \n// three conditions are true.\nbool seg_vis(vec2 x0, vec2 x1, vec2 s0, vec2 s1)\n{\n    x1 -= x0;\n    s0 -= x0;\n    s1 -= x0;\n    mat2x2 M = inverse(mat2x2(s0, s1));\n    x1 = M*x1;\n    \n    if(0.0 < x1.x && 0.0 < x1.y && 1.0 < dot(x1, vec2(1)))\n        return false;\n\n    return true;\n}\n\n// This function finds if the points x0 and x1 are visible to each other.\nbool visibility(vec2 x0, vec2 x1)\n{\n    bool vis = true;\n\n    for(int i=0; i<path0_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path0[i], path0[i+1]);\n    \n\tfor(int i=0; i<path1_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path1[i], path1[i+1]);\n        \n\tfor(int i=0; i<path2_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path2[i], path2[i+1]);\n        \n\tfor(int i=0; i<path3_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path3[i], path3[i+1]);\n        \n\tfor(int i=0; i<path4_len-1; ++i)\n\t\tvis = vis && seg_vis(x0, x1, path4[i], path4[i+1]);\n\n    return vis;\n}\n\n// Get a position for the ith point, adjusted with epsilon if not x0.\nvec2 get_adjusted_pt(int i, vec2 x0, vec2 x1)\n{\n    if(i == 0) return x0;\n    i -= 1;\n    \n    if(i == 0) return x1;\n    i -= 1;\n    \n    float e = 1e-4; // epsilon\n    \n    if(i < path0_len-1) return path0[i] - offs0[i]*e;\n    i -= path0_len-1;\n    \n    if(i < path1_len-1) return path1[i] + offs1[i]*e;\n    i -= path1_len-1;\n    \n    if(i < path2_len-1) return path2[i] + offs2[i]*e;\n    i -= path2_len-1;\n    \n    if(i < path3_len-1) return path3[i] + offs3[i]*e;\n    i -= path3_len-1;\n    \n    return path4[i] + offs4[i]*e;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//     This function is the resulting generalized pathfinding distance field.  \n// Represents the distance from x0 to x1, or FLT_MAX if unreachable.\n\n\n\n// visibility matrix size, it was used in a previous version.\nconst int vismat_len = 2+4+6+3+4+8;\nint pathids[vismat_len]; // Linked list forming a tree\nfloat pathdist(vec2 x0, vec2 x1, out bool vis)\n{\n    // Maybe rewrite the algo right here.\n    // Starting at x0, we want to find the shortest distance to x1 minimizing work.\n    //vec2 x0 = pt;\n    //vec2 x1 = xy;\n\n    // intermediate path distance array\n    float pdist[vismat_len];\n    \n    // Generate a list of nodes that are currently visible, previously visible and visited.\n    bool c_vis[vismat_len];\n    bool p_vis[vismat_len];\n    bool visited[vismat_len];\n    for(int i=0; i<vismat_len; ++i)\n    {\n        c_vis[i] = p_vis[i] = visited[i] = false;\n        pdist[i] = FLT_MAX;\n        pathids[i] = 0; // Clears pathids\n    }\n    \n    pdist[0] = 0.0;\n    \n    // Loop through all nodes:\n    int current = 0;\n    int next;\n    \n    for(int n=0; n<vismat_len; ++n)\n    {\n        current = next;\n        visited[current] = true;\n\n        vec2 p0 = get_adjusted_pt(current, x0, x1);\n        for(int i=0; i<vismat_len; ++i)\n        {\n            if(visited[i]) continue; // Skip visited nodes. \n\n            // Find nodes that are visible to p0.\n            c_vis[i] = visibility(p0, get_adjusted_pt(i, x0, x1));\n            p_vis[i] = p_vis[i] || c_vis[i];\n\n            // Compute pdist if visible.\n            if(!c_vis[i]) continue;\n            \n            // Code for not using pathids.\n            //pdist[i] = min(pdist[i], pdist[current] + sdf_circle(p0, get_adjusted_pt(i, x0, x1)));\n            \n            // Code for using pathids.\n            \n            float ndist = pdist[current] + sdf_circle(p0, get_adjusted_pt(i, x0, x1));\n            if(ndist < pdist[i])\n            {\n                pdist[i] = ndist;\n                pathids[i] = current;\n                \n            }\n            \n        }    \n\n        //if(current == 1) break; // This might actually make it laggier?\n\n        // Find next unvisited, previously visible node.\n        next = -1;\n        for(int i=0; i<vismat_len; ++i)\n        {\n            if(visited[i] || !p_vis[i]) continue;\n            if(next == -1) next = i;\n            else if(pdist[i] < pdist[next]) next = i;\n        }\n    }\n    \n    vis = p_vis[1];\n    return pdist[1];\n    \n}\n\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    xy /= 1.5;\n    \n    xy += path0[2]/2.0;\n    \n    //float time = mod(iTime + 5.0, 10.0);\n    float time = iTime;// - 5.0;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(time + xy.xyx+vec3(0,2,4));\n    \n    // Default sdf appearance\n    float sdist = sdf(xy);\n    if(mod(sdist, 0.025)/0.025 > 0.5)\n        col /= 2.0;\n    \n    // Mouse input\n    vec2 pt = pt1;\n    if(0.5 < iMouse.z)\n    {\n        pt = iMouse.xy/iResolution.xy;\n        pt = pt*2.0 - 1.0;\n        pt.x *= iResolution.x/iResolution.y;\n        pt /= 1.5;\n        pt += path0[2]/2.0;\n    }\n\n    col /= 3.0;\n    \n    \n    vec3 colpath = col;\n    \n    bool vis = false;\n    float dist = pathdist(pt, xy, vis);\n    float diff = time - dist*4.0;\n    \n    // Resulting visual\n    if(vis)\n    {\n        //dist = pdist[1];\n        if(0.0 < diff)\n        {\n        \n        colpath = 0.5 + 0.5*cos(-diff + xy.xyx+vec3(0,2,4));\n        if(mod(dist, 0.025)/0.025 > 0.5)\n            colpath *= mix(1.0/3.0, 1.0, exp(-4.0*diff));\n            //colpath /= 3.0;\n            \n        }\n    }\n    \n    \n    \n    \n    bool vis2 = false;\n    float p2dist = pathdist(pt, pt2, vis2);\n    float diff2 = time - p2dist*4.0;\n    if(0.0 < diff2)\n    {\n        // super satisfying ripple effect\n        float crad = mix(0.05, 0.0, exp(-4.0*diff2));\n        if(sdf_circle(xy, pt2) < crad)\n        {\n            colpath += vec3(sqrt(exp(-4.0*(diff2))));\n\n        }\n\n    //}\n    \n        // Path from pt1 to pt2\n        if(vis)\n        {\n        int current = 1;\n        float dsum = 0.0;\n        for(int i=0; i<5; ++i)\n        {\n            int next = pathids[current];\n            vec2 p0 = get_adjusted_pt(current, pt, pt2);\n            vec2 p1 = get_adjusted_pt(next, pt, pt2);\n            \n            float dd = length(p1 - p0);\n            \n            //dsum += dd;\n            \n            float dd2 = diff2 - p2dist;\n            //float dd3 = diff2 - p2dist + dist;\n            float dd3 = dd2 + dist; // works, but uses dist.\n            //float dd3 = dd2 + dsum; // does not work\n            //dd3 = min(0.0, dd3);\n            // dd3 here is the distance from the destination back to the source.\n            \n            \n            // if dd3 < dsum + dd, dd3 can be used as a lerp!\n            // dsum < dd3 < dsum + dd\n            // ds1 < dd3 < ds2\n            // \n            \n            \n            \n            //float dd3 = dd2 - dsum - dd;\n            \n            \n            float dd4 = min(0.0, dd2);\n            \n            //if(0.0\n            \n            \n            //bool factor = 0.0 < (dist - dd2);\n            //bool factor = 0.0 < diff2 - p2dist + dist;\n            bool factor = 0.0 < dd3;\n            \n            \n            \n            if(sdf_segment(xy, p0, p1) < 0.005 && factor) colpath = mix(colpath, vec3(1.0), min(1.0, exp(-2.0*(time - p2dist*6.0))));\n            // This is oddly, really hard to get the segments working right.\n            \n            /*       \n            float ratio = clamp(dd2/dd, 0.0, 1.0);\n            p1 = mix(p0, p1, ratio);\n            if(sdf_segment(xy, p0, p1) < 0.005) col = vec3(1.0);\n            //*/\n\n            current = next;\n        }\n        }\n    }\n    \n    \n    //if(sdist*10.0 + time - p2dist*6.0 < 0.0)\n    //    col = colpath;\n    \n    //if(sdist*10.0 + time - p2dist*6.0 < 0.0)\n    //    col = colpath;\n    col = colpath;\n    \n    \n    /*\n    // Path from pt1 to pt2\n    dist = pathdist(pt, pt2, vis);\n    int current = 1;\n    for(int i=0; i<5; ++i)\n    {\n        int next = pathids[current];\n        vec2 p0 = get_adjusted_pt(current, pt, pt2);\n        vec2 p1 = get_adjusted_pt(next, pt, pt2);\n        if(sdf_segment(xy, p0, p1) < 0.01) col = vec3(1.0);\n        \n        current = next;\n    }\n    */\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}