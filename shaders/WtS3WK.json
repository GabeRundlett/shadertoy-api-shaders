{
    "Shader": {
        "info": {
            "date": "1561067685",
            "description": "zimzalabim reveluv\nhttps://www.youtube.com/watch?v=YBnGBb1wg98&t=2m13s",
            "flags": 32,
            "hasliked": 0,
            "id": "WtS3WK",
            "likes": 11,
            "name": "Zimzalabim",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "tunnel",
                "lighting",
                "red",
                "rollercoaster",
                "roller",
                "velvet",
                "coaster"
            ],
            "usePreview": 0,
            "username": "dubu",
            "viewed": 1176
        },
        "renderpass": [
            {
                "code": "#define GAMMA_STRENGTH 1.8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(pow(color,vec3(1./GAMMA_STRENGTH)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define t (iTime-25.8-10.)\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n\n// sane functions\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\nvec4 saturate(vec4 x){\n    return clamp(x,vec4(0.0),vec4(1.0));\n}\nfloat map(float value, float low1, float high1, float low2, float high2){\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n\n// Triplanar mapping\nvec3 BlendNormal(vec3 normal){\n\tvec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n\tblending /= vec3(blending.x + blending.y + blending.z);\n\treturn blending;\n}\nvec3 TriplanarMapping (sampler2D tex, vec3 normal, vec3 position) {\n\tvec3 normalBlend = BlendNormal(normal);\n\tvec3 xColor = texture(tex, position.yz).rgb;\n\tvec3 yColor = texture(tex, position.xz).rgb;\n\tvec3 zColor = texture(tex, position.xy).rgb;\n\n  \treturn (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);\n}\n\n\n// Smooth noise\nconst mat2 smm2 = mat2(1.6,-1.2,1.2,1.6);\nfloat Noise( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\nfloat SmoothNoise( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t0 = 0.0;\n\tfor( int i=0; i<1; i++ )\n\t{\n        t0 += s*Noise( p );\n\t\ts *= 0.5 + 0.1*t0;\n        p = 0.97*smm2*p + (t0-0.5)*0.2;\n\t}\n\treturn t0;\n}\n\n\n// Helper Functions\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n// Primitive Distance Functions\n#if 0\nfloat fBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n#else\nfloat fBoxCheap(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n#endif\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n\n// Domain Manipulation Operators\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid pTwist(inout vec2 p, float a){\n    float c = cos(a);\n    float s = sin(a);\n    p = mat2(c,-s,s,c)*p;\n}\n\n\n// Object Combination Operators\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\n// Hit\nstruct Hit{\n \tfloat d;\n    int ID;\n} _Hit;\n\nHit OpUnionHit(Hit a, Hit b){\n    if(a.d < b.d)return a;\n    return b;\n}\n\n\n// Material\nstruct Material{\n    vec3 albedo;\n    vec3 metallic;\n    float roughness;\n} _Material;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define FOV 1.0\n\n#define SKY_COLOR vec3(1.)/255.\n\n#define NUM_BOUNCES 2\n#define MAX_STEPS 512\n#define SURFACE_DIST 1e-4\n#define MAX_DIST 100.0\n#define NUM_AO_STEPS 8.\n\n#define MAT_RAILS 0\n#define MAT_TUBE 1\n\nconst float RAIL_WIDTH = 1.0;\nconst float RAIL_HEIGHT = 0.6;\n\nfloat RailAngle(in float z){\n    return SmoothNoise(vec2(5.,4.)*z)*4.-2.;\n}\nvec3 RailPath(in vec3 p, vec2 offset){\n    float roll = RailAngle(p.z);\n    \n    pTwist(offset.xy, roll);\n    \n    vec3 q = p + vec3(offset.xy, 0.0);\n    \n    q += vec3(0.0, SmoothNoise(vec2(8.,9.)*p.z)*2.-1., 0.0);\n    \n    return q;\n}\n\nHit Rails(in vec3 p){\n    vec3 q = vec3(-p.x, -p.y, p.z);\n    \n    // Rails\n    vec3 leftD = RailPath(q, vec2(-0.5*RAIL_WIDTH, RAIL_HEIGHT));\n    vec3 rightD = RailPath(q, vec2(0.5*RAIL_WIDTH, RAIL_HEIGHT));\n    vec3 bottomD = RailPath(q, vec2(0.0, 0.0));\n    \n    const float railRadius = 0.07;\n    float rightRail = length(leftD.xy)-railRadius;\n    float leftRail = length(rightD.xy)-railRadius;\n    float bottomRail = length(bottomD.xy)-railRadius;\n    \n    float rails = min(leftRail, rightRail);\n   \trails = min(rails, bottomRail);\n    \n    // Boxes\n    vec3 bottomBoxD = RailPath(q, vec2(0.0, 0.15));\n    vec3 leftBoxD = RailPath(q, vec2(-0.55*RAIL_WIDTH, 0.5*(RAIL_HEIGHT)));\n    vec3 rightBoxD = RailPath(q, vec2(0.55*RAIL_WIDTH, 0.5*(RAIL_HEIGHT)));\n    \n    float roll = RailAngle(q.z);\n    pR(bottomBoxD.xy, -roll);\n    pR(leftBoxD.xy, -roll);\n    pR(rightBoxD.xy, -roll);\n    \n    float rep = 3.5;\n    pMod1(bottomBoxD.z, rep);\n    pMod1(leftBoxD.z, rep);\n    pMod1(rightBoxD.z, rep);\n    \n    float thickness = 0.025;\n    float bottomBox = fBoxCheap(bottomBoxD, vec3(RAIL_WIDTH*0.55, 0.1, thickness));\n    float leftBox = fBoxCheap(leftBoxD, vec3(thickness, 0.25, thickness));\n    float rightBox = fBoxCheap(rightBoxD, vec3(thickness, 0.25, thickness));\n    \n    float boxes = bottomBox;\n    boxes = min(boxes, leftBox);\n    boxes = min(boxes, rightBox);\n    \n    Hit dRails = Hit(\n        fOpUnionRound(rails, boxes, 0.1),\n        MAT_RAILS\n    );\n    \n    return dRails;\n}\nHit Tube(vec3 p){\n    vec3 tubeD = RailPath(vec3(-p.x, -p.y, p.z), vec2(0.0, 0.0));\n    \n    float spacing = 400.;\n    float radius = 4.0;\n    float cylinder = radius-length(tubeD.xy);\n    float cube = radius-(abs(tubeD.x)+abs(tubeD.y));\n    \n    float tube = mix(\n        cylinder,\n        cube,\n        saturate(smoothstep(0.49,0.51, fract(tubeD.z/spacing)))\n    );\n    \n    \n    Hit dTube = Hit(\n        tube,\n        MAT_TUBE\n    );\n    \n    return dTube;\n}\n\nHit GetDist(vec3 p){\n   \tHit rails = Rails(p);\n    Hit tube = Tube(p);\n    \n    return OpUnionHit(rails, tube);\n}\n\nHit RayMarch(vec3 ro, vec3 rd, int bounce){\n\tfloat dO = 0.;\n    Hit hit;\n    \n    int steps = MAX_STEPS;\n    \n    if(bounce > 0){\n        steps /= bounce*4;\n    }\n    \n    for(int i = 0; i < steps; i++){\n        vec3 p = dO*rd+ro;\n        hit = GetDist(p);\n        \n        dO += hit.d;\n        \n        if(hit.d < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return Hit(dO, hit.ID);\n}\n\nMaterial GetMaterial(in vec3 p, in vec3 n, in Hit hit){\n    Material mat;\n    \n    if(hit.ID == MAT_RAILS){\n        \n        \n        mat.albedo = vec3(1.0, 0., 0.3);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 1.0;\n    }else if(hit.ID == MAT_TUBE){\n        float f = smoothstep(0.0, 0.09+hit.d*hit.d*0.0003, abs(fract(p.z*0.2)-0.5));\n        float angle = atan(p.y, p.x)/TAU + 0.5;\n        f *= smoothstep(0.0, 0.06+hit.d*hit.d*0.0002, abs(fract(angle*20.)-0.5));\n        mat.albedo = mix(\n            vec3(0.5, 0.2, 0.7),\n            vec3(1.0, 0.2, 1.0)*7.,\n            1. - saturate(f)\n        );\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.7;\n    }else{\n        mat.albedo = vec3(0.0, 0.0, 0.5);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 1.0;\n    }\n    \n    return mat;\n}\n\nvec3 GetNormal(vec3 pos){\n \tvec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize( e.xyy*GetDist( pos + e.xyy ).d + \n\t\t\t\t\t  e.yyx*GetDist( pos + e.yyx ).d + \n\t\t\t\t\t  e.yxy*GetDist( pos + e.yxy ).d + \n\t\t\t\t\t  e.xxx*GetDist( pos + e.xxx ).d );\n}\n\nfloat CalcAO(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float occ = 0.0;\n    for(float i = 0.0; i < NUM_AO_STEPS; ++i){\n        float len = 0.15 * i + 0.15;\n        float dist = GetDist(rd * len + ro).d;\n        occ += k * (len - dist);\n        k *= 0.5;\n    }\n    return saturate(1.0-occ);\n}\n\nvec4 GetColor(vec3 ro, vec3 rd){\n    int bounce = 0;\n    float depth = 0.;\n    \n    vec3 res = vec3(0.0);\n    vec3 carry = vec3(1.0);\n    \n    for(int bounce = 0; bounce <= NUM_BOUNCES; ++bounce){\n        Hit hit = RayMarch(ro, rd, bounce);\n        if(bounce == 0)depth = hit.d;\n    \n        depth = hit.d;\n\n        if(hit.d >= MAX_DIST){\n            return vec4(SKY_COLOR, depth);\n        }\n\n        vec3 p = rd * hit.d + ro;\n        vec3 n = GetNormal(p);\n        vec3 v = normalize(ro-p);\n\n        Material mat = GetMaterial(p, n, hit);\n\n        vec3 col = mat.albedo;\n\n        float ao = CalcAO(p, n);\n\n        col *= (1. / pow(length(p-ro), 1.5)) *\n            pow(saturate(dot(n, normalize(v))), 2.0);\n\n        col += 0.002;\n\n        col *= ao*ao;\n        \n        res += col * carry;\n        \n        carry = mat.albedo * carry * (1.0 - mat.roughness);\n        \n        if(length(carry) < 0.05){break;}\n        \n        // bounce ray\n        rd = rd - 2.0*dot(rd, n)*n;\n        ro = p + rd*0.001;\n    }\n        \n    return vec4(res, depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uvs = fragCoord/iResolution.xy;\n    vec2 uv = uvs * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    \n    float speed = 25.0;\n    float space = 5.5+3.5*sin(t*1.3);\n    \n    vec3 lookAt = RailPath(vec3(0.0, 0.0, t*speed+space), vec2(0.0));\n    vec2 mouse = (-iResolution.xy+iMouse.xy*2.)/iResolution.xy;\n    vec2 offset = vec2(0.0, 1.0);\n    //offset += mouse * 2.;\n    vec3 cameraPosition = RailPath(vec3(0.0, 0.0, t*speed), offset);\n    \n    vec3 forward = normalize(lookAt-cameraPosition);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    float roll = RailAngle(cameraPosition.z + space*0.5);\n    pTwist(right.xy, roll);\n    vec3 up = normalize(cross(forward,right));\n    \n\n    vec3 ro = cameraPosition; \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    vec4 tot = GetColor(ro, rd);\n    \n    vec3 color = tot.rgb;\n    float depth = tot.a;\n    \n    vec4 final = vec4(color, depth);\n    vec4 previousFinal = texture(iChannel3, uvs);\n    fragColor = saturate(mix(final, previousFinal, 0.4));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}