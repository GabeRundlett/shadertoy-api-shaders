{
    "Shader": {
        "info": {
            "date": "1718567093",
            "description": "This is all ChatGPT-4o from a coding standpoint. I just tweaked some numbers and made broad suggestions. I'm extremely impressed.",
            "flags": 0,
            "hasliked": 0,
            "id": "X3cSRH",
            "likes": 4,
            "name": "Gorgeous #2",
            "published": 3,
            "tags": [
                "waves",
                "bitwise"
            ],
            "usePreview": 0,
            "username": "multiphonic",
            "viewed": 64
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 20\n#define MAX_DIST 200.0\n#define SURF_DIST 0.001\n#define COLOR_BALANCE vec3(1.2, 1.0, 0.9)\n#define LIGHT_COLOR vec3(0.6, 0.9, 0.8)\n#define FOG_DENSITY 0.2\n#define AMBIENT_COLOR vec3(0.2, 0.3, 0.4)\n#define WAVE_INTENSITY 0.2\n#define NOISE_INTENSITY 0.001\n\n#define LINE_INTENSITY 2.7\n#define GRADIENT_INTENSITY 0.1\n#define BITWISE_INTENSITY 0.05\n#define HARMONIC_INTENSITY 1.0\n#define MOSAIC_SIZE 2.0\n#define TRIANGLE_SIZE 56.1\n\n#define COLOR1 vec3(1.8, 0.5, 0.3)\n#define COLOR2 vec3(0.3, 3.8, 0.9)\n#define COLOR3 vec3(0.7, 0.2, 0.8)\n#define COLOR4 vec3(0.4, 0.7, 0.5)\n\n#define NUM_LAYERS 20.0\n\nuniform float u_starSize;\nuniform float u_starDiffusion;\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat getDist(vec3 p) {\n    vec3 modP = mod(p, vec3(4.0)) - vec3(2.0);\n    float sphereRadius = 1.0 + 0.1 * hash(modP.x * 37.0 + modP.y * 17.0 + modP.z * 23.0);\n    float sphereDist = sdSphere(modP, sphereRadius);\n    float waveDist = sin(modP.x * 3.0 + iTime * 2.0) * WAVE_INTENSITY;\n    return sphereDist + waveDist;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        getDist(p + e.xyy) - d,\n        getDist(p + e.yxy) - d,\n        getDist(p + e.yyx) - d\n    ));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getColor(vec3 p, vec3 n, vec3 lightDir, vec3 bgCol) {\n    float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n    vec3 colorPattern = mix(mix(COLOR1, COLOR2, abs(sin(iTime))), mix(COLOR3, COLOR4, abs(cos(iTime))), diff);\n    vec3 diffuse = diff * LIGHT_COLOR * colorPattern;\n    vec3 ambient = AMBIENT_COLOR;\n    vec3 reactiveColor = mix(diffuse + ambient, bgCol, 0.5);\n    return reactiveColor;\n}\n\nfloat noise(vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 blendScreen(vec3 a, vec3 b) {\n    return 1.0 - (1.0 - a) * (1.0 - b);\n}\n\nvec3 blendVividLight(vec3 a, vec3 b) {\n    return mix(2.0 * a * b, 1.0 - 2.0 * (1.0 - a) * (1.0 - b), step(0.5, b));\n}\n\nvec3 blendDifference(vec3 a, vec3 b) {\n    return abs(a - b);\n}\n\nmat2 rotate2D(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat star(vec2 uv, float flare) {\n    float col = 0.0;\n    float d = length(uv);\n    float m = 0.02 / d;\n    \n    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n    m += rays * flare;\n    uv *= rotate2D(3.1415 / 4.0);\n    rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n    m += rays * 0.3 * flare;\n    \n    m *= smoothstep(1.0, 0.2, d);\n\n    return m;\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 starLayer(vec2 uv, float starSize, float starDiffusion) {\n    vec3 col = vec3(0.0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 offs = vec2(x, y);\n\n            float n = hash21(id + offs);\n            float size = fract(n * 345.32);\n            \n            vec2 p = vec2(n, fract(n * 34.0));\n            \n            float starVal = star(gv - offs - p + 0.5, smoothstep(0.8, 1.0, size) * starDiffusion);\n            \n            vec3 hueShift = fract(n * 2345.2 + dot(uv / 420.0, vec2(0.25, 0.0))) * vec3(0.2, 0.3, 0.9) * 123.2;\n\n            vec3 color = sin(hueShift) * 0.5 + 0.5;\n            color = color * vec3(1.0, 0.25, 1.0 + size);\n\n            starVal *= sin(iTime * 3.0 + n * 6.2831) * 0.4 + 1.0;\n            col += starVal * size * color * starSize;\n        }\n    }\n    \n    return col;\n}\n\n// Function to generate intricate patterns\nfloat pattern(vec2 uv) {\n    uv *= 5.0;\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    float k = 3.5;\n    float d = 0.0;\n    p *= mat2(0.8, -0.6, 0.6, 0.8);\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 r = b - f + (0.5 + 0.5 * sin(vec2(p.y - b.y, p.x - b.x)));\n            d += exp(-k * dot(r, r));\n        }\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0; // Center the coordinates\n    uv *= rotate2D(iTime * 0.1); // Apply rotation over time\n    uv *= 1.0 + 0.5 * sin(iTime * 0.2); // Zoom in and out\n\n    // Generate continuous diagonal lines\n    float lines = abs(sin(uv.x * LINE_INTENSITY + uv.y * LINE_INTENSITY + iTime));\n\n    // Apply harmonic distortions\n    float harmonic = cos(uv.x * 0.3 + iTime) * sin(uv.y * -5.0 + iTime);\n\n    // Add gradients for depth\n    vec3 gradient = mix(vec3(0.2, 0.0, 0.5), vec3(1.0, 0.5, 0.0), uv.y * 0.5 + 0.5);\n    vec3 col = mix(vec3(lines), gradient, GRADIENT_INTENSITY);\n\n    // Bitwise operations for retro feel\n    float bitwiseRed = float(int(uv.x * 10.1) ^ int(uv.y * 10.1)) * BITWISE_INTENSITY;\n    float bitwiseGreen = float(int(uv.x * 20.1) ^ int(uv.y * 20.1)) * BITWISE_INTENSITY;\n    float bitwiseBlue = float(int(uv.x * 30.1) ^ int(uv.y * 30.1)) * BITWISE_INTENSITY;\n    col += vec3(bitwiseRed, bitwiseGreen, bitwiseBlue);\n\n    // Apply the harmonic effect to the color\n    col += vec3(harmonic) * HARMONIC_INTENSITY;\n\n    // Subtle mosaic effect\n    vec2 mosaicUV = floor(uv * MOSAIC_SIZE) / MOSAIC_SIZE;\n    col *= vec3(mosaicUV, 2.0);\n\n    // Triangle effect\n    float tri = abs(uv.x * TRIANGLE_SIZE + uv.y * TRIANGLE_SIZE - iTime * 0.5);\n    col *= 1.0 - step(0.9, fract(tri));\n\n    // Intricate pattern\n    float patternValue = pattern(uv);\n    col += vec3(patternValue) * 0.3; // Reduce pattern intensity to mute banding effect\n\n    vec3 ro = vec3(5.0 * sin(iTime * 0.3), 2.0, 5.0 * cos(iTime * 0.3));\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float d = rayMarch(ro, rd);\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 lightDir = normalize(vec3(-0.5, 1.0, -0.5));\n        vec3 shapeCol = getColor(p, n, lightDir, col);  // Pass the background color to the getColor function\n        \n        float fog = exp(-d * FOG_DENSITY);\n        shapeCol = mix(AMBIENT_COLOR, shapeCol, fog);\n        \n        // Blend modes\n        col = blendScreen(col, shapeCol);\n    }\n\n    col = pow(col, COLOR_BALANCE);\n    \n    // Optional noise layer\n    if (NOISE_INTENSITY > 0.0) {\n        float noiseValue = noise(fragCoord.xy) * NOISE_INTENSITY;\n        col = mix(col, vec3(0.0), noiseValue);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}