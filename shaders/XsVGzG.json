{
    "Shader": {
        "info": {
            "date": "1455140499",
            "description": "Raymarching texture test",
            "flags": 32,
            "hasliked": 0,
            "id": "XsVGzG",
            "likes": 2,
            "name": "drl009",
            "published": 3,
            "tags": [
                "raymarchingtexturemotionblurmultipass"
            ],
            "usePreview": 0,
            "username": "DrLuke",
            "viewed": 801
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = texture(iChannel1, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\n#define PLANEMAT \tmat3 rotMat = rotationMatrix(vec3(0,0,1), p.x/500.0 * (sin(iTime*0.3)+1.0)) * rotationMatrix(vec3(1,0,0), -p.z/500.0 * (sin(iTime*0.3)+1.0))\n#define PLANE \t\tsdPlane(rotMat*p - vec3(0,-5,0))\n#define BOXMAT \t\trotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.01)*0.5), iTime*3.14159*0.0)\n#define BOX \t\tsdBox(rotMat*(p - vec3(0,0,0.0)), vec3(1,1,1))\n\nfloat map(vec3 p)\n{\n    PLANEMAT;\n\tfloat r = PLANE;\t// Return distance\n    \n    BOXMAT;\n    r = min(r, BOX);\n    \n    return r;\n}\n\nfloat mapid(vec3 p)\n{\n\tfloat oid = 0.0;\n    PLANEMAT;\n    float r = PLANE;\t// Return distance\n    \n    rotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.01)*0.5), iTime*3.14159*0.5);\n    float rn = min(r, BOX);\n    r = mix(r, rn, step(r,rn));\n    oid = mix(1.0, 0.0, step(r,rn));\n    \n    \n    return oid;\n}\n\n#define MARCHLIMIT 128\n#define MARCHSTEPFACTOR 0.9\n#define MAXDIST 1000.0\nfloat march(vec3 s, vec3 d)\n{\n    float dist = 1.0;\t// distance\n    for(int i = 0; i < MARCHLIMIT; i++)\n    {\n        dist += map(s + d*dist)*MARCHSTEPFACTOR;\n    }\n    \n\treturn min(dist, MAXDIST);\n}\n\nvec3 colorize(vec3 s, vec3 d, float dist, vec2 uv)\n{\n\tvec3 p = s+d*dist;  \n    float oid = mapid(s+d*dist);\n    \n    \n    //------------------------\tScrolling plane\n    PLANEMAT;\n    vec3 retcol = texture(iChannel0, vec2( p.xz/10.0 ) + vec2(0,iTime) ).rgb;\n\n    retcol = mix(retcol, vec3(0), step(1000.0, dist));\n    //------------------------\tBoxes\n    BOXMAT;\n    vec3 relp = rotMat*(p-vec3(0,0,0));\n    vec3 boxcol = vec3(((length(relp.xy) - 0.5)/abs(relp.z)) * ((length(relp.xz)-0.5)/abs(relp.y)) * ((length(relp.yz) - 0.5)/abs(relp.x)),0,0);\n\t//float a = (abs(relp.x)+abs(relp.y)+abs(relp.z))/3.0;\n    float a = smoothstep(0.8, 1.0, abs(relp.x)) + smoothstep(0.8, 1.0, abs(relp.y)) + smoothstep(0.8, 1.0, abs(relp.z));\n    boxcol = vec3(smoothstep(0.5,0.5,a/3.0)) * vec3(1.0,0.4,0);\n    \n    retcol = mix(retcol, boxcol, step(1.0, oid));\n    \n    return retcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - vec2(1);\t// Make UV go from -1 to 1 instead of 0 to 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 s = vec3(-sin(iTime*3.14159*0.1)*15.0, sin(iTime*0.4)*10.0 + 7.0,-cos(iTime*3.14159*0.1)*15.0);\n    #define FOCALLEN 0.6\n    vec3 d = vec3(uv*FOCALLEN, 1.0);\n    mat3 rotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.01)*0.1), -iTime*3.14159*0.1) * rotationMatrix(vec3(1,0,0), -0.5*sin(iTime*0.4) - 0.4);\n    d = rotMat * d;\n    \n    float marchdist = march(s, d);\n    \n    vec3 color = colorize(s,d,marchdist, uv);\n    \n    vec4 bufColor = vec4(0);\n    \n    for(int i = 0; i < 5; i++)\n    {\n        for(int j = 0; j < 5; j++)\n        {\n            bufColor += texture(iChannel1, (fragCoord.xy + vec2(i-2, j-2)) / iResolution.xy);\n        }\n    }\n    \n\tfragColor = mix(vec4(color, 1.0), bufColor/25.0, 0.7);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}