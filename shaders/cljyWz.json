{
    "Shader": {
        "info": {
            "date": "1691683416",
            "description": "An infinite number of matryoshka dolls. Combining SDFs in a recursive manner leads to compute overload. In this shader, I combined SDFs by shifting and scaling a single doll.",
            "flags": 0,
            "hasliked": 0,
            "id": "cljyWz",
            "likes": 4,
            "name": "Matryoshka Dolls",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "geometricseries",
                "matryoshka"
            ],
            "usePreview": 0,
            "username": "struminsky",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.1415926535897932384626433832795\n#define SCALE 0.9\n#define RADIUS 6.0\n\n// textures\nvec3 skirtColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(128. / 255., 0. / 255., 0. / 255.);\n    case 1:\n        return vec3(25. / 255., 25. / 255., 112. / 255.);\n    case 2:\n        return vec3(85. / 255., 107. / 255., 47. / 255.);\n    case 3:\n        return vec3(47. / 255., 79. / 255., 79. / 255.);\n    default:\n        return vec3(139. / 255., 69. / 255., 19. / 255.);\n    }        \n}\n\nvec3 apronColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(255. / 255., 215. / 255. , 0. / 255.);\n    case 1:\n        return vec3(199. / 255., 21. / 255., 133. / 255.);\n    case 2:\n        return vec3(255. / 255., 228. / 255., 225. / 255.);\n    case 3:\n        return vec3(65. / 255., 105. / 255., 225. / 255.);\n    default:\n        return vec3(60. / 255., 179. / 255., 113. / 255.);\n    }\n}\n\nvec3 hairColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(188. / 255., 143. / 255., 143. / 255.);\n    case 1:\n        return vec3(160. / 255., 82. / 255., 45. / 255.);\n    case 2:\n        return vec3(184. / 255., 134. / 255., 11. / 255.);\n    case 3:\n        return vec3(255. / 255., 69. / 255., 0. / 255.);\n    default:\n        return vec3(105. / 255., 105. / 255., 105. / 255.);\n    }\n}\n\nvec3 hairScarfColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(220. / 255., 20. / 255., 60. / 255.);\n    case 1:\n        return vec3(34. / 255., 139. / 255., 34. / 255.);\n    case 2:\n        return vec3(100. / 255., 149. / 255., 237. / 255.);\n    case 3:\n        return vec3(148. / 255., 0. / 255., 211. / 255.);\n    default:\n        return vec3(199. / 255., 21. / 255., 133. / 255.);\n    }\n}\n\nbool inCone(in vec3 pos, in vec3 w, in float r){\n    vec3 u = cross(w, vec3(0.0, 0.0, 1.0));\n    vec3 v = cross(w, u);\n    float x = dot(pos, u);\n    float y = dot(pos, v);\n    float z = dot(pos, w);\n    return (x * x + y * y) < (r * z * z);\n}\n\n// sdf primitives\nfloat sdSphere(in vec3 position,\n               in vec3 center,\n               in float radius){\n    return length(position - center) - radius;\n}\n\nfloat smin(in float a, in float b, in float k){\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h / (4. * k);\n}\n\n// single matryoshka\nvec4 matryoshka(in vec3 pos, in int color_index){\n    // compute sdf\n    vec3 head_center = vec3(0.0, 0.0, 1.5);\n    float head_radius = 0.7;\n    vec3 body_center = vec3(0.0, 0.0, 0.5);\n    float body_radius = 0.9;\n    float matryoshka_sdf = smin(\n        sdSphere(pos, head_center, head_radius),\n        sdSphere(pos, body_center, body_radius),\n        0.3);\n    \n    // get color\n    bool headscarf = pos.z > 1.2;\n    bool face = inCone(\n        vec3(pos.xy, pos.z - 1.65),\n        vec3(0., 1., 0.1),\n        0.45) && pos.y > 0.;\n    bool hair = inCone(\n        vec3(abs(pos.x), pos.y, pos.z - 1.65),\n        vec3(1.2, 0.2, 1.5),\n        1.8);\n    \n    vec3 color;\n    // headscarf\n    if (headscarf && !face){\n        color = hairScarfColor((11 * color_index) % 5);\n        return vec4(matryoshka_sdf, color);\n    }\n    // face \n    if (face && !hair){\n        color = vec3(0.9, 0.7, 0.6);\n        return vec4(matryoshka_sdf, color);\n    }\n    // hair\n    if (face && hair){\n        color = hairColor((13 * color_index) % 5);\n        return vec4(matryoshka_sdf, color);\n    }\n    // skirt\n    bool skirt = !inCone(pos, vec3(0., .6, 0.8), 0.09);\n    if (skirt){\n        color = skirtColor((17 * color_index) % 5);\n        return vec4(matryoshka_sdf, color);\n    }\n    // apron\n    color = apronColor((19 * color_index) % 5);\n    return vec4(matryoshka_sdf, color);\n}\n\nvec4 circleClone(in vec3 pos){\n    float phi = acos(pos.x / length(pos.xy));\n    phi = pos.y < 0. ? 2. * M_PI - phi : phi;\n    phi /= (2. * M_PI * (1. - SCALE));\n    \n    float copy_id = float(floor(log(1. - (1. - SCALE) * phi)\n                          / log(SCALE)));\n    //if (copy_id >= 64.) \n    //    return vec4(\n    //        pos.x,\n    //        pos.y,\n    //        pos.z + RADIUS,\n    //        1.0);\n    \n    // get center angle\n    float phi_center = (\n        0.5 * pow(SCALE, copy_id)\n        + (1. - pow(SCALE, copy_id)) / (1. - SCALE)\n    ) * (1. - SCALE) * 2. * M_PI;\n    \n    // rotate\n    float x = pos.x * cos(phi_center) + pos.y * sin(phi_center);\n    float y = -pos.x * sin(phi_center) + pos.y * cos(phi_center);\n    float z = pos.z;\n    // scale and shift\n    float current_scale = pow(SCALE, -copy_id);\n    x = (x - RADIUS) * current_scale;\n    y *= current_scale;\n    z *= current_scale;\n    \n    return vec4(copy_id,\n                x * cos(phi_center) - y * sin(phi_center),\n                x * sin(phi_center) + y * cos(phi_center),\n                z);\n}\n\nvec4 map(in vec3 pos){\n    vec4 id_and_pos = circleClone(pos);\n    float current_scale = pow(SCALE, -id_and_pos.x);\n    \n    float background_sdf = smin(\n        pos.z,\n        25. - length(pos.xy),\n        10.);\n    vec4 matryoshka_output = matryoshka(\n        id_and_pos.yzw,\n        int(id_and_pos.x)) / current_scale;\n    float matryoshka_sdf = matryoshka_output.x;\n    vec3 matryoshka_color = matryoshka_output.yzw;\n    \n    if (background_sdf < matryoshka_sdf)\n        return vec4(background_sdf, 1.0, 1.0, 1.0);\n    else\n        return matryoshka_output;\n}\n\nfloat castRay(in vec3 ro, in vec3 rd){\n    float t = 0.0;\n    for(int i=0; i<200; i++){\n        vec3 pos = ro + t*rd;\n        float h = map(pos).x;\n        if (h < 0.0001) break;\n        t += h;\n    }\n    return t;\n}\n\nfloat castSoftShadow(in vec3 ro, in vec3 rd){\n    float t = 1e-1;\n    float min_dist = 1.0;\n    for(int i=0; i<200 && t < RADIUS; i++){\n        float h = map(ro + t*rd).x;\n        if (h < 1e-3) return 0.;\n        t += h;\n        min_dist = min(min_dist, 8. * h / t );\n    }\n    return clamp(min_dist, 0., 1.);\n}\n\nvec3 calcNormal(in vec3 pos){\n    vec2 e = vec2(1e-3, 0.);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // map pixel coordinate to ray\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    \n    //float frame = 2.0 * iTime;\n    \n    vec3 ro;\n    vec3 camera_target;\n    if (iMouse.z > 0.0) {\n        ro = vec3(1.4 * RADIUS * cos(iMouse.x / 100.),\n                  1.4 * RADIUS * sin(iMouse.x / 100.),\n                  0.3 + iMouse.y / 100.);\n        camera_target = vec3(0.0, 0.0, iMouse.y / 1000.);\n    } else {\n        ro = vec3(1.4 * RADIUS * cos(iTime / 4.),\n                  1.4 * RADIUS * sin(iTime / 4.),\n                  1.3);\n        camera_target = vec3(0.0, 0.0, 0.3);\n    }\n    vec3 ww = normalize(camera_target - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 0.0, 1.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n    float t = castRay(ro, rd);\n    \n    vec3 pos = ro + t * rd;\n    vec3 normal = calcNormal(pos);\n    vec3 albedo = map(pos).yzw;\n    \n    \n    vec3 sun_dir = normalize(\n        vec3(0.5, 0.5, 0.7)\n    );\n    // sun shadow\n    float sun_shadow = castSoftShadow(pos, sun_dir);\n    // diffuse shadow\n    //vec3 diff_shadow = albedo;\n    vec3 diff_shadow = albedo * clamp(dot(sun_dir, normal), 0.0, 1.0);\n    // specular reflection\n    vec3 h = -normalize(-sun_dir + rd);\n    float alpha = 128.0;\n    vec3 specular_ref = vec3(0.7, 0.7, 0.8) * pow(clamp(dot(h, normal), 0.0, 1.0), alpha);\n    \n    vec3 col = vec3(0.05, 0.01, 0.01);\n    col += diff_shadow * sun_shadow; \n    col += specular_ref * sun_shadow; \n    fragColor = vec4(pow(col, vec3(0.4545)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}