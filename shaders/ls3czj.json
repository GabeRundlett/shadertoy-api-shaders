{
    "Shader": {
        "info": {
            "date": "1519520325",
            "description": "test",
            "flags": 0,
            "hasliked": 0,
            "id": "ls3czj",
            "likes": 1,
            "name": "glossy raytracing test",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "dtoadq",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "//------------------------------------------------------------------------------\n//-------- SETTINGS (FOR UTILITY LIBRARY) --------------------------------------\n\n#define Scene_width  3.5\n#define Scene_height 1.4\n// Uncomment below to have light move along with scene (you have to undefine\n// collect in Buf c)\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//-------- UTILITY LIBRARY -----------------------------------------------------\n//------------------------------------------------------------------------------\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n\n#define PI   3.141592653589793\n#define IPI  0.318309886183791\n#define IPI2 0.159154943091895\n#define TAU  6.283185307179586\n#define ITAU 0.159154943091895\n\n#define SQR(X) ((X)*(X))\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n\nstruct Ray { float3 ori, dir; };\n\nfloat2 Map ( float3 o );\n\nfloat2 March ( in Ray ray ) {\n  float dist = 0.0;\n  float2 cur;\n  for ( int i = 0; i != 64; ++ i ) {\n    cur = Map(ray.ori + ray.dir*dist);\n    if ( cur.x <= 0.0005 || dist > 256.0 ) break;\n    dist += cur.x;\n  }\n  if ( dist > 256.0 || dist < 0.0 ) return float2(-1.0);\n  return float2(dist, cur.y);\n}\n\nfloat3 Normal ( float3 p ) {\n  float2 e = float2(1.0, -1.0)*0.001;\n  return normalize(\n                   e.xyy*Map(p + e.xyy).x +\n                   e.yyx*Map(p + e.yyx).x +\n                   e.yxy*Map(p + e.yxy).x +\n                   e.xxx*Map(p + e.xxx).x);\n}\n\nRay Look_At ( float2 uv ) {\n  //----origin\n  float3 ori = float3(Scene_width*cos(1.0*iTime+3.0f),\n                      Scene_height+cos(2.0*iTime-1.0+1.5f)*0.3f,\n                      Scene_width*sin(1.0*iTime+3.0f));\n  //----etc\n  float3 center = float3(0.0),\n         up     = float3(0.0, 1.0, 0.0);\n  float3 ww = normalize(center - ori),\n         uu = normalize(cross(up, ww)),\n         vv = normalize(cross(ww, uu));\n  return Ray(ori, normalize(uv.x*uu + uv.y*vv + 2.5*ww));\n}\n\n// -- maps --\nfloat sdSphere ( in float3 O, in float R ) { return length(O) - R; }\nfloat sdShell  ( in float  D, in float R ) { return abs(D) - R*0.5f; }\nfloat sdPlane  ( in float3 O, in float3 N, in float D ) {\n  return dot(O, N) + D;\n}\n\nvoid Union ( inout float2 t, float d, in float ID ) {\n  if ( t.x > d ) t = float2(d, ID);\n}\n\nvoid opRotate(inout float2 p, in float a ) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -- random --\n\nfloat Sample_Uniform(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 Sample_Uniform2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 Sample_Uniform3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*\n                 vec3(43758.5453123,22578.1459123,842582.632592));\n}\n\n// -- sampler --\n\n//------------------------------------------------------------------------------\n//-------- MATERIALS -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nstruct Light {\n  float3 ori, emi;\n  float radius;\n};\n\n#define LIGHTS_LEN 3\nLight lights[LIGHTS_LEN];\n\nvoid Initialize_Lights ( ) {\n  lights[0].ori = float3(sin(iTime), 1.0f, 1.0f-cos(iTime));\n  lights[0].emi = float3(0.9, 0.2, 0.9)*2.0;\n  lights[0].radius = 0.05f;\n\n  lights[1].ori = float3(cos(iTime), 2.0f, log(1.0f-sin(iTime)*0.9f));\n  lights[1].emi = float3(0.8, 0.9, 0.7)*1.5;\n  lights[1].radius = 0.05f;\n\n  lights[2].ori = float3(-sin(iTime), cos(iTime*2.0f)*0.2f+0.5f, sin(iTime));\n  lights[2].emi = float3(0.2, 0.5, 0.9)*1.5;\n  lights[2].radius = 0.05f;\n}\n\nfloat noise ( in float2 uv ) {\n  return sin(1.5f*uv.x) + sin(1.5f*uv.y);\n}\n\nfloat2 Normal_Sampler ( in sampler2D s, in float2 uv ) {\n  float2 eps = float2(0.003f, 0.0f);\n  return float2(length(texture(s, uv+eps.xy)) - length(texture(s, uv-eps.xy)),\n                length(texture(s, uv+eps.yx)) - length(texture(s, uv-eps.yx)));\n}\n\nfloat2 Map ( in float3 O ) {\n  float3 ori = O;\n  float2 res = float2(999.0);\n  float2 nmap = Normal_Sampler(iChannel0, O.xz*0.2f);\n  O.y += nmap.y*0.08f;\n  float s = sdPlane(O, float3(0.0f, 1.0f, 0.0f), 0.0f);\n  Union(res, s*0.5f, 0.0f);\n\n  O = ori-float3(2.0f, 0.4f, 0.4f + sin(iTime));\n  opRotate(O.xy, tan(iTime));\n  opRotate(O.yz, iTime);\n  opRotate(O.xz, log(1.0f-sin(0.5f*iTime)*0.89f)*4.0f*PI);\n  nmap = Normal_Sampler(iChannel0, O.xy*0.2f + O.zy*0.3f);\n  O.y += length(nmap)*0.25f;\n  // O.x += length(nmap)*(sin(iTime)+2.0f);\n  Union(res, sdSphere(O, 0.5f)*0.5f, 1.0f);\n\n  O = ori;\n\n  for ( int i = 0; i != LIGHTS_LEN; ++ i )\n    Union(res, sdSphere(O-lights[i].ori, lights[i].radius), 10.0f+float(i));\n  return res;\n}\n\n\nfloat Smith_G_GGX_Correlated ( float L, float R, float a ) {\n  return L * sqrt(R - a*(R*R) + a);\n}\n\nfloat3 BRDF ( in float3 N, in float3 wi, in float3 wo ) {\n  wi = -wi;\n  float3 H = normalize(wi+wo);\n  float D, G, F;\n  { // -------- Distribution\n    float alpha = 0.8f;\n    float ggx = alpha*alpha;\n    ggx /= (PI * pow( pow(dot(N, wo), 2.0f) * (ggx - 1.0f) + 1.0f, 2.0f));\n    D = ggx;\n  }\n  { // -------- Geometric\n    G = dot(N, wo) * dot(N, wi) / pow(dot(wi, H), 2.0f);\n  }\n  return float3(G)/(4.0f*dot(N, wi)*dot(N, wo));\n}\n\nvoid mainImage(out vec4 frag_colour, in vec2 frag_coord) {\n  float2 uv = -1.0 + 2.0*frag_coord.xy/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n  Initialize_Lights();\n  frag_colour = float4(float3(0.0f), 1.0f);\n\n  Ray eye = Look_At(uv);\n  float2 res = March(eye);\n  if ( res.x > 0.0f ) {\n    float3 O = eye.ori + eye.dir*res.x,\n           N = Normal(O),\n          wi = eye.dir;\n\n    if ( res.y >= 10.0f ) {\n      frag_colour.xyz = lights[int(res.y-10.0f)].emi;\n      return;\n    }\n\n    float3 eps = float3(1.0f/iChannelResolution[0].xy, 0.0f);\n    float2 nmap = Normal_Sampler(iChannel0, O.xz*0.2f);\n    if ( res.y == 0.0f ) {\n      N.xz += nmap*1.0f;\n      N.yx += nmap.yx*1.4f;\n    }\n\n    for ( int i = 0; i != LIGHTS_LEN; ++ i ) {\n      float3 colour = float3(0.0f);\n      float3 wo = normalize(lights[i].ori - O);\n      float lobe = 0.4f;\n      float p = 1.0f/(1.0f*PI*(sin(0.5f)*sin(lobe)));\n      float3 NN = reflect(wi, N);\n      colour += BRDF(N, wi, wo)/p*lights[i].emi;\n      if ( res.y == 1.0f ) colour *= float3(1.0f, 1.0f, 0.2f);\n      if ( res.y == 0.0f ) {\n        colour *= texture(iChannel0, O.xz*0.2f).xyz*3.0f;\n      }\n      // 0.2f diffuse 0.8f glossy\n      colour = (colour*0.4f) + (colour*0.6f*float(dot(wo, NN) > cos(lobe)));\n\n      frag_colour.xyz += colour*(1.0f/float(LIGHTS_LEN));\n    }\n  }\n  frag_colour = clamp(frag_colour, float4(0.0f), float4(1.0f));\n  frag_colour.xyz = pow(frag_colour.xyz, float3(0.8f));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}