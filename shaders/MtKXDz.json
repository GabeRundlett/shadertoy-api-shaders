{
    "Shader": {
        "info": {
            "date": "1483985874",
            "description": "animation test...",
            "flags": 0,
            "hasliked": 0,
            "id": "MtKXDz",
            "likes": 5,
            "name": "Tween Test",
            "published": 3,
            "tags": [
                "easing",
                "tween"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 583
        },
        "renderpass": [
            {
                "code": "\n\t\t#define NEAR 0.01\n\t\t#define FAR 128.\n\t\t#define ITER 128\n\t\tconst float PI = 3.14159265359;\n\n\t\tvec4 QuatRotate (float x,float y,float z,float deg){\t\n\t\t    float rad = deg * (PI / 180.0) / 2.0;\n\t\t    float s = sin(rad);\n\t\t    return vec4(\n\t\t    \tcos(rad), //w\n\t\t    \tx * s, //x\n\t\t    \ty * s, //y\n\t\t    \tz * s //z\n\t\t    );\n\t\t}\n\n\t\tmat4 QuatRotateConvertToMatrix(vec4 q){\n\t\t    float s = sqrt(q.w * q.w + q.x * q.x + q.y * q.y\n\t\t + q.z * q.z);\n\t\t    s = 2.0 / (s * s);\n\t\t    float vx = q.x * s;\n\t\t    float vy = q.y * s;\n\t\t    float vz = q.z * s;\n\t\t    float wx = vx * q.w;\n\t\t    float wy = vy * q.w;\n\t\t    float wz = vz * q.w;\n\t\t    float sx = q.x * vx;\n\t\t    float sy = q.y * vy;\n\t\t    float sz = q.z * vz;\n\t\t    float cx = q.y * vz;\n\t\t    float cy = q.z * vx;\n\t\t    float cz = q.x * vy;\n\n\t\t    return mat4(\n\t\t        1.0 - sy - sz,\n\t\t        cz + wz,\n\t\t        cy - wy,\n\t\t        0.0,\n\t\t        cz - wz,\n\t\t        1.0 - sx - sz,\n\t\t        cx + wx,\n\t\t        0.0,\n\t\t        cy + wy,\n\t\t        cx - wx,\n\t\t        1.0 - sx - sy,\n\t\t        0.0,\n\t\t        0.0,\n\t\t        0.0,\n\t\t        0.0,\n\t\t        1.0\n\t\t    );\n\t\t}\n\n\t\tvec4 combine(vec4 val1, vec4 val2 )\n\t\t{\n\t\t\tif ( val1.w < val2.w ) return val1;\n\t\t\treturn val2;\n\t\t}\n\n\t\tfloat sdBox( vec3 p, vec3 b )\n\t\t{\n\t\t\tvec3 d = abs(p) - b;\n\t\t\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\n\t\t// CubicInOut is not working on ios. I changed quadratic. \n\t\tfloat cubicInOut(float t) {\n\t\t  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n            /*\n            return t < 0.5\n\t\t    ? 4.0 * t * t * t\n\t\t    : -0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n            */\n\t\t}\n\n\t\t// based on \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\n\t\tfloat scene(in float t, float w, float s) {\n\t\t    return clamp(t - w, 0.0, s) / s;  \n\t\t}\n\n\t\tvec4 map( vec3 pos, mat4 m, float sc, float sc2, float x1, float y2, float y3, float x4, float sx1, float sy2, float sy3, float sx4){\n\t\t\tvec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\t\t\tq.x = mod(q.x, 10.0)-5.0;\n\t\t\tq.y = mod(q.y, 8.0)-4.0;\n\n\t\t    vec3 color = vec3(0.1,0.1,0.1);\n\n\t\t\tvec4 val1 = vec4(color,sdBox(q.xyz+vec3(x1,1.5,1.0), vec3(sx1,sc2,sc) ));\n\t\t\tvec4 val2 = vec4(color,sdBox(q.xyz+vec3(-1.5,y2,1.0), vec3(sc2,sy2,sc) ));\n\t\t\tvec4 val3 = vec4(color,sdBox(q.xyz+vec3(1.5,y3,1.0), vec3(sc2,sy3,sc) ));\n\t\t\tvec4 val4 = vec4(color,sdBox(q.xyz+vec3(x4,-1.5,1.0), vec3(sx4,sc2,sc) ));\n\n\t\t\tvec4 res = combine(val1,val2);\n\t\t\tvec4 res2 = combine(val3,val4);\n\t\t\tvec4 res3 = combine(res,res2);\n\t\t\treturn res3;\n\t\t}\n\t\t\n\t\tvec2 rot(vec2 p, float a) {\n\t\t\treturn vec2(\n\t\t\t\tcos(a) * p.x - sin(a) * p.y,\n\t\t\t\tsin(a) * p.x + cos(a) * p.y);\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\t\t\tvec2 position = fragCoord.xy / iResolution.xy;\n\t\t\tposition -= .5;\n\t\t\tvec3 dir = vec3( position, 1.0 );\n\n         \tfloat aspect = iResolution.x / iResolution.y;\n         \tdir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n\t\t \tdir.yz = rot(dir.yz, 0.2);\n\n\t\t \tfloat t = mod(iTime,6.0);\n\n\t\t \tfloat animZ = cubicInOut(scene(t, 2.0, 1.0))*60.0;\n\t\t \tanimZ -= cubicInOut(scene(t, 3.0, 1.0))*60.0;\n\n\t\t \tvec3 pos = vec3(0.0, 5.0, 25.0);\n\n\t\t \tvec4 rotVec = QuatRotate(0.0,0.0,-1.0,animZ);\n\t\t\tmat4 m = QuatRotateConvertToMatrix(rotVec);\n\t\t\t\n\t\t    float sc = 0.0;\n\t\t    sc += cubicInOut(scene(t, 1.0, 1.0))*0.5;\n\t\t    sc -= cubicInOut(scene(t, 1.0, 1.0))*0.5;\n\n\t\t    float sc2 = 0.0;\n\t\t    sc2 += cubicInOut(scene(t, 1.0, 0.1))*0.5;\n\t\t    sc2 -= cubicInOut(scene(t, 5.0, 0.1))*0.5;\n\n\t\t\tfloat y2 = 2.0;\n\t\t\ty2 -= cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\ty2 -= cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\n\t\t\tfloat sy2 = 0.0;\n\t\t\tsy2 += cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\tsy2 -= cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\n\t\t\tfloat x1 = 2.0;\n\t\t\tx1 -= cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\tx1 -= cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\n\t\t\tfloat sx1 = 0.0;\n\t\t\tsx1 += cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\tsx1 -= cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\n\t\t\tfloat y3 = -2.0;\n\t\t\ty3 += cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\ty3 += cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\t\t\t\n\t\t\tfloat sy3 = 0.0;\n\t\t\tsy3 += cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\tsy3 -= cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\n\t\t\tfloat x4 = -2.0;\n\t\t\tx4 += cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\tx4 += cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\t\t\t\n\t\t\tfloat sx4 = 0.0;\n\t\t\tsx4 += cubicInOut(scene(t, 1.0, 1.0))*1.5;\n\t\t\tsx4 -= cubicInOut(scene(t, 4.0, 1.0))*1.5;\n\n\t\t\tvec4 result;\n\t\t\tint march = 0;\n\t\t\tfor (int i = 0; i < ITER; i++)\n\t\t\t{\n\t\t\t\tresult = map(pos, m, sc, sc2, x1, y2, y3, x4, sx1, sy2, sy3, sx4);\n\t\t\t\tmarch = i;\n\t\t\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\t\t\tpos += result.w * dir;\n\t\t\t}\n\n\t\t\tvec3 col = map(pos, m, sc, sc2, x1, y2, y3, x4, sx1, sy2, sy3, sx4).xyz;\n\t\t\tvec4 bgCol;\n\t\t\tif ( pos.z> 100. )\n\t\t\t{\n\t\t\t\t// bg\n\t\t\t\tfloat temp = length(vec2(position.xy))+1.0;\n\t\t\t\tcol = vec3(.98,.98,.98)/vec3(temp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//http://prideout.net/blog/?p=22\n\t\t\t\t// shade\n\n\t\t\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\t\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\t\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\t\t\tvec3 n = vec3( result.w - map( pos - eps.xyy, m, sc, sc2, x1, y2, y3, x4, sx1, sy2, sy3, sx4 ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yxy, m, sc, sc2, x1, y2, y3, x4, sx1, sy2, sy3, sx4 ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yyx, m, sc, sc2, x1, y2, y3, x4, sx1, sy2, sy3, sx4 ).w );\n\t\t\t\tn = normalize(n);\n\t\t\t\t\t\t\n\t\t\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\t\t\tcol *= vec3(lambert);\n\t\t\t    col += vec3(result.xyz);\n\t\t\t}\n\n\t\t\tfragColor = vec4( col, 1.0);\n\n\t\t\t\t\t\n\n\t\t}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}