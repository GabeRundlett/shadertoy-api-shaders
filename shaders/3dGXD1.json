{
    "Shader": {
        "info": {
            "date": "1573854089",
            "description": "Experimenting with hybrid raytracing/raymarching for perturbed surfaces. For each bounce, first raytrace, then do a bit of raymarching to find the exact depth and normal.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGXD1",
            "likes": 6,
            "name": "Wavy Crystal",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "reflection",
                "refraction",
                "glossy"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n\n#define SPHERESPACING 0.25\n#define SPHEREGRID 0.01\n\n#define RADIUS 1.\n\n#define ABSORPTION_RATE vec3(0.9, 0.8, 0.8)\n#define IOR 1.33\n#define LOW_SCATTER 0.001\n#define HIGH_SCATTER 0.03\n#define SAMPLES 25\n#define REFLECTIONS 3\n#define RAYMARCH_STEPS 15\n#define RAYMARCH_TOL 0.005\n\n#define TIME_T 6.\n#define TIME_H 6.\n#define TIME_L 6.\n\n\nfloat oscillate(float t_low, float t_high, float t_transition, float t_offset) {\n    float t_osc = 0.5*(t_high+t_low)+t_transition;\n    float h_l = 0.5*t_low/t_osc;\n    float h_h = (0.5*t_low+t_transition)/t_osc;\n    return smoothstep(0., 1., (clamp(abs(mod(iTime + t_offset, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n}\n\n/*vec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}*/\n\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 ni, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return vec2(-1.);\n    ni = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    no = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nfloat sphere(in vec3 ro, in vec3 rd, in float r, in bool entering, out vec3 n) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return -1.;\n    float tdiff = sqrt(disc);\n    float t = -pd + (entering ? -tdiff : tdiff);\n    n = normalize(ro + t * rd);\n    \n    return t;\n}\n\nfloat spheresdf(in vec3 ro, in float r) {\n    float mag = 0.02 * oscillate(TIME_L*.5, TIME_H*.5, TIME_T*0.5, -2.);\n    return length(ro) - r + mag*(sin(ro.y*20. + iTime*1.32)+1.);\n}\n\nvec3 spheregrad(in vec3 ro, in float r) {\n    vec2 diff = vec2(RAYMARCH_TOL, 0.);\n    float dx = spheresdf(ro + diff.xyy, r) - spheresdf(ro - diff.xyy, r);\n    float dy = spheresdf(ro + diff.yxy, r) - spheresdf(ro - diff.yxy, r);\n    float dz = spheresdf(ro + diff.yyx, r) - spheresdf(ro - diff.yyx, r);\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat hybridsphere(in vec3 ro, in vec3 rd, in float r, in bool entering, out vec3 n) {\n    float t = sphere(ro, rd, r, entering, n);\n    if (t > 0.) {\n        for (int i=0; i<RAYMARCH_STEPS; i++) {\n            float dist = spheresdf(ro + t*rd, r);\n            t += (entering ? dist : -dist);\n            if (dist < RAYMARCH_TOL) {\n                n = spheregrad(ro + t*rd, r);\n                return t;\n            }\n        }\n    }\n    return -1.;\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\nvec3 z_to_vec(in vec3 d, in vec3 z) {\n    vec3 u = normalize(cross(vec3(0., 0., 1.), d));\n    vec3 v = cross(d, u);\n    return u * z.x + v * z.y + d * z.z;\n}\n\n//raytrace the exterior surroundings\nvec4 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    vec3 col1;\n    if (t < 0.) {\n        t = 1000.;\n        col1 = bgcol(rd);\n    } else {\n        vec2 uv = ro.xy+t*rd.xy;\n        if (max(abs(uv.x), abs(uv.y)) > 8.) col1 = bgcol(rd);\n        else {\n            vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n            float aofac = smoothstep(0., 1.25, length(uv));\n            col1 = mix(vec3(0.2), vec3(0.8), min(checkers.x,checkers.y)) * (1.-0.5*(1.-aofac));\n        }\n    }\n    \n    vec3 ni;\n    float voffset = abs(0.8*sin(1.4*iTime));\n    float t2 = sphere(ro - vec3(0.6 + RADIUS, 0., -0.4 + voffset), rd, 0.6, true, ni);\n    vec3 spherero = t2 * rd + ro - vec3(0., 0., voffset);\n    vec3 spherech = smoothstep(vec3(SPHEREGRID*0.75), vec3(SPHEREGRID), abs(mod(spherero, vec3(SPHERESPACING))*2.-SPHERESPACING));\n    float tea = mix(t, t2, step(0., t2));\n    return vec4(mix(col1, mix(vec3(1., 0., 0.), mix(vec3(1.), vec3(0.5, 0.6, 0.8), spherero.z+1.), min(spherech.x, min(spherech.y, spherech.z))), step(0., t2)), tea);\n}\n\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nvec2 GetRandom2(){return vec2(GetRandom(), GetRandom());}\n\nvec3 randnorm(vec2 seed) {\n    vec2 utheta = GetRandom2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime*sin(iTime) + (fragCoord.x+iResolution.x*fragCoord.y)/(iResolution.y);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni;\n    float t = hybridsphere(eye, rd, RADIUS, true, ni);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    vec4 bgg = background(eye, rd);\n    \n    if (t > 0. && t < bgg.w) {\n        \n        float osc = oscillate(TIME_L, TIME_H, TIME_T, 0.);\n        float SCATTER_FACTOR = mix(LOW_SCATTER, HIGH_SCATTER, osc);\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec3 n = randnorm(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6));\n            // reflection\n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, ni), 5.);\n            vec3 rdr = mix(reflect(rd, ni), normalize(n + ni), SCATTER_FACTOR);\n            vec3 reflcol = background(ro, rdr).xyz;\n            \n            // refraction, absorption and internal reflection\n            vec3 rd_refr = mix(refract(rd, ni, 1./IOR), normalize(n-ni), SCATTER_FACTOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            vec3 ro_refr = ro;\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                \n                vec3 ni2, no2;\n                float tout = hybridsphere(ro_refr, rd_refr, RADIUS, false, no2);\n                ro_refr = ro_refr + tout * rd_refr;\n                vec3 randno2 = normalize(n + no2);\n                vec3 rd_refr_out = mix(refract(rd_refr, -no2, IOR), randno2, SCATTER_FACTOR);\n\n                float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rd_refr_out, no2), 5.);\n                           \n            \trd_refr = mix(reflect(rd_refr, -no2), randno2, SCATTER_FACTOR);\n                transmission *= pow(ABSORPTION_RATE, vec3(tout));\n            \tinsidecol += accum * (1.-fresnel2) * background(ro_refr, rd_refr_out).xyz * transmission;\n                accum *= fresnel2;\n            }    \n            \n            \n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(bgg.xyz, 1.);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}