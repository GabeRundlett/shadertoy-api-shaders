{
    "Shader": {
        "info": {
            "date": "1653987249",
            "description": "A shader created as a test while working on\n   https://www.shadertoy.com/view/XlcSDr\nIf someone find it usefull ...",
            "flags": 0,
            "hasliked": 0,
            "id": "NscyDS",
            "likes": 3,
            "name": "Fork Universe_G c_design_w 484",
            "published": 3,
            "tags": [
                "klm"
            ],
            "usePreview": 0,
            "username": "c_design_work",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "// Created by sebastien durand - 08/2016\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" by Duke (https://www.shadertoy.com/view/MsVXWW) \n// Sliders from IcePrimitives by Bers (https://www.shadertoy.com/view/MscXzn)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.14159265\n\n#define DENSE_DUST\n#define DITHERING\n#define BACKGROUND\n\nconst float time = 10.;\n\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x<b.x ? a  : b;\n} \n\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// [iq] https://www.shadertoy.com/view/4sfGzS\nfloat pn(in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = texture( iChannel0, (uv+.5)/256., -100.).yx;\n\treturn -1.+2.4*mix(rg.x, rg.y, f.z);\n}\n\nbool cylinder(vec3 ro, vec3 rd, float r, float h, out float tn, out float tf) {\n\tfloat a = dot(rd.xy, rd.xy), b = dot(ro.xy, rd.xy),\n\t\t  d = b*b - a*(dot(ro.xy, ro.xy) - r*r);    \n\tif(d < 0.) \n        return false;\n\td = sqrt(d);\n\ttn = (-b - d)/a; tf = (-b + d)/a;\n\t// order roots\n\ta = min(tf, tn); tf = max(tf, tn); tn = a;\n\ta = ro.z + tn * rd.z;\n    b = ro.z + tf * rd.z;\n\t// top, bottom\n\tvec2 zcap = h*vec2(.5, -.5), cap = (zcap - ro.z) / rd.z;\n    tn = a < zcap.y ? cap.y : a > zcap.x ? cap.x : tn;\n\ttf = b < zcap.y ? cap.y : b > zcap.x ? cap.x : tf;\n    return tf > 0. && tf > tn;\n}\n\n\nfloat fpn(vec3 p) { \n    return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;// + pn(p*.5)*.625;\n}\n\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co*.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 spiralArm(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n    float dephase = 2., loop = 4.;\n    float a = atan(p.x,p.z),  // angle     \n\t\t  r = length(p.xz), lr = log(r), // distance to center\n    \t  th = (.1-.25*r), // thickness according to distance\n    \t  d = fract(.5*(a-lr*loop)/pi); //apply rotation and scaling.\n    d = (.5/dephase - abs(d-.5))*2.*pi*r;\n  \td *= (1.-lr)/thickness;  // space fct of distance\n    // Perturb distance fiel1\n    float radialBlur = blurAmout*mix(fpn(8.*vec3(r*43.,40.*d,24.*p.y)),fpn(p*400.0), blurStyle);\n    return vec2(sqrt(d*d+10.*p.y*p.y/thickness)-th*r*.2-radialBlur);\n}\n\nfloat map(vec3 p, vec4 id) {\n   \treturn spiralArm(p.xzy*.2, 10.*(.5+.5*id.x), .2+.3*id.y, id.z).x;\n}\n\n\n//--------------------------------------------------------------\n\n\n// assign color to the media\nvec3 computeColor( float density, float radius ) {\n\t// color based on density alone, gives impression of occlusion within the media\n\tvec3 result = mix(vec3(.25,.22,.2), vec3(.1,.0375,.025), density );\n\t// color added for disk\n\treturn result * mix(  vec3(4.8,6.,6.), vec3(.96,1.06,1.), min( (radius+.5)/2.0, 1.15 ) );\n}\n\n\n// +----------------------------------------+\n// |                 Galaxy                 |\n// +----------------------------------------+\n\n\nvec4 renderGalaxy(in vec3 ro, in vec3 rd, in vec4 id, in float time) {\n        \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = .1;\n  #ifdef DITHERING\n\tvec2 seed = rd.xy + fract(iTime);    \n   \t// randomizing the length \n    // rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \n  #endif \n    \n\tvec4 sum = vec4(0);\n    float min_dist=0., max_dist=100.;\n\n    if(cylinder(ro, rd, 3.,3., min_dist, max_dist)) {\n        \t\n        t = max(min_dist,t); //*step(t,min_dist);\n\n        // raymarch loop\n        for (int i=0; i<60; i++)  {\n\n            vec3 pos = ro + t*rd;\n            float fld = 0.;\n\n            // Loop break conditions.\n            if(td>(1.-1./80.) ||  sum.a > .99 || t>max_dist) break;\n\n            // evaluate distance function\n            d = map(3.5*pos, id);\n            // kind of countour drawing\n            d = abs(d)+.05 ;\n\n            // direction to center\n            vec3 stardir = normalize(vec3(0.0)-pos);\n\n            // change this string to control density \n            d = max(d,.005);\n\n            if (d<.1) {\n                // compute local density \n                ld = .1 - d;\n\n              #ifdef DENSE_DUST          \n                fld = clamp((ld - map(pos*3.5+0.2*stardir, id))/0.4, 0.0, 1.0 );\n                ld += fld;\n              #endif\n\n                // compute weighting factor \n                w = (1. - td) * ld;\n\n                // accumulate density\n                td += w + 1./200.;\n\n                float radiusFromCenter = length(pos);\n                vec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\n                // uniform scale density\n                col.a *= 0.2;\n                // colour by alpha\n                col.rgb *= col.a/0.8;\n                // alpha blend in contribution\n                sum = sum + col*(1.0 - sum.a);  \n            }\n\n            td += 1./70.;\n\n            // point light calculations\n            vec3 ldst = pos*.25,\n                 ldst2 = pos*.05;\n            ldst2.z*=2.5;\n            float lDist = max(length(ldst),.0001), //max(length(ldst), 0.001);\n                  lDist2 = max(length(ldst2),.0001);\n            // star in center\n            vec3 lightColor = (1.-smoothstep(3.,4.5,lDist*lDist))*\n                mix(.07*vec3(1.,.5,.25)/(lDist),\n                    .008*vec3(1.,1.7,2.)/(lDist2), \n                    smoothstep(.2,.7,lDist));\n\n            // star in center\n            //lightColor=vec3(1.0,0.5,0.25);\n            sum.rgb += lightColor/(lDist*20.); //add a bloom around the light\n\n            // using the light distance to perform some falloff\n          //  float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\n            // accumulating the color\n          //  sum += w*atten*fld;\n\n            // enforce minimum stepsize\n            d = max(d, .04); \n\n          #ifdef DITHERING\n            // add in noise to reduce banding and create fuzz\n            d = abs(d)*(1.+.28*rand(seed*vec2(i)));\n          #endif \n\n            t +=  max(d * .3, .02);\n        }\n\n   \t\tsum = clamp( sum, 0., 1. );\n      \tsum.xyz = sum.xyz*sum.xyz*(3.-2.*sum.xyz);\n    }\n    \n    return sum;\n}\n\n// ---------------------------------------------------\n// Bers : https://www.shadertoy.com/view/MscXzn\nvec4 processSliders(in vec2 uv, out vec4 sliderVal) {\n    sliderVal = texture(iChannel1,vec2(0));\n    return length(uv.xy)>1. ? \n            texture(iChannel1,uv.xy/iResolution.xy) :  \n            vec4(0);\n}\n\n// ---------------------------------------------------\n// Based on \"Dusty nebula 4\" by Duke (https://www.shadertoy.com/view/MsVXWW) \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 sliderVal;\n    vec4 cSlider = processSliders(fragCoord, sliderVal);\n\n   // camera\t   \n    float a = sliderVal.w*pi;\n    vec3 ro = 8.*vec3(0, cos(a), sin(a)),\n         ta = vec3(0);\n\tro.xy = R(ro.xy, iTime);\n    // camera tx\n    vec3 cw = normalize( ta-ro ),\n     \t cu = normalize( cross(cw,vec3(0., 0., 1.)) ),\n     \t cv = normalize( cross(cu,cw) );\n    vec2 q = (fragCoord.xy)/iResolution.xy,\n     \t p = -1.+2.*q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    vec4 sum = vec4(0);\n    \n    vec4 cGalaxy = renderGalaxy(ro,rd, sliderVal, iTime);\n  \n    cGalaxy += (1.-cGalaxy.a)*sum;\n\n     //Apply slider overlay\n    fragColor = vec4(mix(cGalaxy.xyz, cSlider.rgb, cSlider.a), 1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}