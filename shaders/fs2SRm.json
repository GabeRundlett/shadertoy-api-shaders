{
    "Shader": {
        "info": {
            "date": "1644967409",
            "description": "Wrinkled material",
            "flags": 0,
            "hasliked": 0,
            "id": "fs2SRm",
            "likes": 6,
            "name": "Material - Wrinkled",
            "published": 3,
            "tags": [
                "material"
            ],
            "usePreview": 0,
            "username": "loryruta",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "#define NOISE fbm\n\n#define OBJ_DIFF vec3(1.0, 0.0, 0.0)\n\n#define LIGHT_DIFF vec3(1.0)\n#define LIGHT_AMB  vec3(0.1)\n#define LIGHT_DIR  normalize(vec3(-1.0, -1.0, -1.0))\n\n#define EPSILON 0.001\n#define PI 3.1415926538\n#define NUM_NOISE_OCTAVES 8\n\n#define REFRACTIVE_INDEX_OUTSIDE 1.0\n#define REFRACTIVE_INDEX_INSIDE 1.1\n#define OBJECT_REFLECTIVITY 0.1\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x)\n{\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 surf_norm(vec2 pos)\n{\n    float h = NOISE(pos);\n\n    vec3 d1 = normalize(vec3(EPSILON, 0, NOISE(pos + vec2(EPSILON, 0)) - h));\n    vec3 d2 = normalize(vec3(0, EPSILON, NOISE(pos + vec2(0, EPSILON)) - h));\n    \n    return normalize(cross(d1, d2));\n}\n\nvec3 get_scene_color(vec3 ray_dir)\n{\n    return vec3(1.0);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0 - cosX;\n    float ret = r0 + (1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0 - OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\nvec3 apply_light(vec3 surf_norm, vec3 view_dir)\n{\n    // ambient\n    vec3 diff = OBJ_DIFF * LIGHT_AMB; \n    \n    // diffuse\n    float diff_w = clamp(dot(surf_norm, -LIGHT_DIR), 0.0, 1.0);\n    diff += OBJ_DIFF * diff_w * LIGHT_DIFF;\n    \n    // specular\n    vec3 refl_light_dir = reflect(LIGHT_DIR, surf_norm);\n    float spec_w = max(dot(-view_dir, refl_light_dir), 0.0);\n    diff += pow(spec_w, 2.0) * LIGHT_DIFF;  \n    \n    // reflect\n    float reflect_mult = FresnelReflectAmount(\n        REFRACTIVE_INDEX_OUTSIDE,\n        REFRACTIVE_INDEX_INSIDE,\n        surf_norm,\n        view_dir\n    );\n    \n    vec3 view_refl_dir = reflect(view_dir, surf_norm);\n\n    vec3 ret = vec3(0);\n    ret += diff * (1.0 - reflect_mult);\n    ret += get_scene_color(view_refl_dir) * reflect_mult;\n    return ret;\n}\n\nfloat gamma = 2.2;\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    vec3 norm = surf_norm(uv);\n    vec3 view_dir = normalize(vec3(uv, -1.0));\n    \n    vec3 col = apply_light(norm, view_dir);\n    \n    // reinhard tone mapping\n    //col = col / (col + vec3(1.0));\n    \n    // tone mapping\n    //col = lumaBasedReinhardToneMapping(col);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}