{
    "Shader": {
        "info": {
            "date": "1665466113",
            "description": "Verlet cloth sim with point tearing. Hopefully you'll find it more \"tearable\" than \"terrible\". If you were expecting not to suffer any bad puns you've come to the wrong shader...\n\n*mouse to tear the cloth* \n*space to reset and resume attract mode*",
            "flags": 48,
            "hasliked": 0,
            "id": "NlKBW3",
            "likes": 68,
            "name": "Tearable 3D Fishnet",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "particles",
                "dynamics",
                "physics",
                "integration",
                "cloth",
                "fabric",
                "tearing",
                "tear",
                "fishnet"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 796
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Verlet cloth sim with point tearing. Hopefully you'll find it more \"tearable\" than\n//  \"terrible\". If you were expecting not to suffer any bad puns you've come to the wrong\n//  shader...\n// \n//  The stability of this, such as it is, comes from essentially an absurd number of\n//  edges. Not only is each particle connected via the visible lines to each neighbor,\n//  but to the next particle, and the next particle, and so on. I'm surely not the first\n//  person to come up with this appoach, so I don't think you can say I made this \"out\n//  of whole cloth\". Ahem.\n//  \n//  If the wind is a bit much, you can tone it down with WIND_SPEED. I could tell you\n//  more about the making of this shader, and it would be quite the yarn. But you might\n//  accuse me of fabrication.\n//\n//  OK, I'll stop.\n//\n//  Buffer A computes the particle positions\n//  Buffer B computes nearest particles to each screen pixel\n//\n// ---------------------------------------------------------------------------------------\n\nvoid drawLine(vec3 from, vec3 to, vec2 p, mat4 w2c, inout vec4 fragColor)\n{\n    // convert to camera space\n    vec3 fromCamera = (w2c * vec4(from,1.0)).xyz;\n    fromCamera.xy = fromCamera.xy / fromCamera.z;\n    vec3 toCamera = (w2c * vec4(to,1.0)).xyz;\n    toCamera.xy = toCamera.xy / toCamera.z;\n\n    // if in front of clipping plane\n    if(fromCamera.z > 0.01 && toCamera.z > 0.01) \n    {\n        float dist2 = fxLinePointDist2(fromCamera.xy, toCamera.xy, p);\n        float dist = sqrt(dist2);\n\n        float PARTICLE_SIZE = 2. / iResolution.y;\n        float particleTemp = max(0.0, PARTICLE_SIZE - dist) / PARTICLE_SIZE;\n\n        if (dist < PARTICLE_SIZE)\n        {\n            fragColor = min(fragColor, 1. - vec4(vec3(particleTemp), 0));\n        }\n    }\n}\n\nvoid drawLineToNeighbor(int nid, vec3 pos, vec2 p, mat4 w2c, inout vec4 fragColor)\n{\n    if (nid >= 0)\n    {\n        fxParticle nData = fxGetParticle(nid);\n\n        if (!nData.disabled) drawLine(pos, nData.pos, p, w2c, fragColor);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    computeClothSide(iResolution);\n    \n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n\tconst vec3 reverseLightDir = normalize(vec3(1.0,2.0,3.0));\n\tconst vec3 lightColor = vec3(0.5,0.5,0.5);\t\n\tconst vec3 ambientColor = vec3(0.05,0.05,0.05);\n   \n    fragColor = vec4(.7);\n    //return;\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n\n    for(int j=0; j<1; j++)\n    {\n        int particle = old[j];\n        if (particle < 0 || particle >= MAX_PARTICLES) continue;\n        fxParticle data = fxGetParticle(particle);\n        if (!data.disabled)\n        {\n            drawLineToNeighbor(above(particle), data.pos, p, w2c, fragColor);\n            drawLineToNeighbor(below(particle), data.pos, p, w2c, fragColor);\n            drawLineToNeighbor(left(particle), data.pos, p, w2c, fragColor);\n            drawLineToNeighbor(right(particle), data.pos, p, w2c, fragColor);\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "uvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0.0, 0.0f, 0.0);\n    cameraPos\t= vec3(0, 1, 3);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5*resolution.y / resolution.x * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nconst float MAX_TEMP = 1000.0;\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS 0\n#define PREV 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 prev;\n    bool pinned;\n    bool disabled;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, PREV), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.disabled = particleData0.w != 0.;\n    particle.prev = particleData1.xyz;\n    particle.pinned = particleData1.w != 0.;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, p.disabled ? 1. : 0.);\n    case PREV:  \n        return vec4(p.prev, p.pinned ? 1. : 0.);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float SIDE_LEN = 4.;\n\n// global variables, initialized via computeClothSide\nint CLOTH_SIDE = 0; // how many particles along each side of the square\nint MAX_PARTICLES = 0; // how many particles, total\n\n// computes the size of the cloth grid relative to the current resolution\nvoid computeClothSide(vec3 res)\n{\n    float particleUse = 0.7 * (1. - 0.6 * smoothstep(1000., 1200., res.y));\n    CLOTH_SIDE = int(sqrt(res.x * res.y / float(NUM_PARTICLE_DATA_TYPES)) * particleUse);\n    MAX_PARTICLES = CLOTH_SIDE * CLOTH_SIDE;\n}\n\n// These functions compute the neighbors from each particle, and -1 if there is\n// no neighbor in that direction. Crucially, they must continue to return -1 if\n// -1 is passed in, since we do not terminate the loop right away.\n\nint above(int i)\n{\n    return i >= 0 && i >= CLOTH_SIDE ? i - CLOTH_SIDE : -1;\n}\n\nint below(int i)\n{\n    return i >= 0 && i < (CLOTH_SIDE * (CLOTH_SIDE - 1)) ? i + CLOTH_SIDE : -1;\n}\n\nint left(int i)\n{\n    return i >= 0 && (i % CLOTH_SIDE) != 0 ? i - 1 : -1;\n}\n\nint right(int i)\n{\n    return i >= 0 && (i % CLOTH_SIDE) != CLOTH_SIDE - 1 ? i + 1 : -1;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the position of each particle.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-1,0);\n\nconst float WIND_SPEED = 100.; // wind strength\nconst float WIND_CHANGE_RATE = .5; // wind change speed\nconst float WIND_RIPPLE = .01; // wind variance\nconst float EDGE_BREAK_LEN = 5.; // length over rest length before breaking\nconst float COMPRESSION_RESIST = .005; // stiffness\n\nvoid constraint(inout int nid, inout fxParticle p, float edgeLen)\n{\n    if (nid < 0) return;\n    \n    fxParticle n = fxGetParticle(nid);\n    \n    if (n.disabled)\n    {\n        nid = -1;\n        return;\n    }\n    \n    vec3 deltaPos = n.pos - p.pos;\n    float len = length(deltaPos);\n    vec3 dir = deltaPos / len;\n    \n    float error = len - edgeLen;\n    \n    if (error < 0.) error *= COMPRESSION_RESIST;\n    if (distance(p.prev, n.pos) > edgeLen * EDGE_BREAK_LEN) p.disabled = true; // fragile cloth\n    \n    float f = n.pinned ? 1.0 : .7;\n    p.pos += dir * error * f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    computeClothSide(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    if (!p.pinned && !p.disabled)\n    {\n        p.prev = p.pos;\n        p.pos += p.pos - p.prev + GRAVITY; // verlet\n        p.pos.z += WIND_SPEED * sin((float(id % CLOTH_SIDE) * WIND_RIPPLE + iTime * WIND_CHANGE_RATE)); // wind\n\n        // edge constraints\n        int a, b, l, r;\n        a = b = l = r = id;\n        \n        float EDGE_LEN = SIDE_LEN / float(CLOTH_SIDE);\n        float CARDINAL_ITERATIONS = 45.;\n        for (float i = 1.; i < CARDINAL_ITERATIONS; ++i)\n        {\n            a = above(a);\n            b = below(b);\n            r = right(r);\n            l = left(l);\n\n            float sLen = EDGE_LEN * i;\n            constraint(a, p, sLen);\n            constraint(b, p, sLen);\n            constraint(r, p, sLen);\n            constraint(l, p, sLen);\n        }\n\n#define DIAGONAL_CONSTRAINTS 1\n\n#if DIAGONAL_CONSTRAINTS\n        int al, ar, bl, br;\n        al = ar = bl = br = id;\n        \n        float DIAGONAL_ITERATIONS = 25.;\n        for (float i = 1.; i < DIAGONAL_ITERATIONS; ++i)\n        {\n            ar = above(right(ar));\n            al = above(left(al));\n            br = below(right(br));\n            bl = below(left(bl));\n\n            float dLen = EDGE_LEN * i * sqrt(2.);\n            constraint(al, p, dLen);\n            constraint(ar, p, dLen);\n            constraint(bl, p, dLen);\n            constraint(br, p, dLen);\n        }\n#endif // DIAGONAL_CONSTRAINTS\n    }\n    \n    // Reset particles that have gotten too old\n    if (iFrame == 0 || state.x < 0.)\n    {   \n        float x = float(id % CLOTH_SIDE) / float(CLOTH_SIDE) - 0.5;\n        float y = 0.5 - float(id)/float(CLOTH_SIDE*CLOTH_SIDE);\n        p.pos = vec3(x + y, x - y, 0.) * SIDE_LEN / sqrt(2.);\n        p.prev = p.pos;\n        \n        // pin sides\n        p.pinned = id < CLOTH_SIDE || id >= (CLOTH_SIDE - 1) * CLOTH_SIDE || (id % CLOTH_SIDE) == 0 || (id % CLOTH_SIDE) == (CLOTH_SIDE - 1);\n        //if (id % (CLOTH_SIDE / 10) == 0 && (id / CLOTH_SIDE) % (CLOTH_SIDE / 10) == 0) p.pinned = true; // quilt pinning\n        p.disabled = false;\n    }\n    \n    bool del = false;\n    vec2 from, to;\n    if (iMouse.z > 0. && iMouse.w < 0.)\n    {\n        // mouse input\n        from = vec2(2.*iResolution.x/iResolution.y, 2.) * state.yz / iResolution.xy - vec2(iResolution.x/iResolution.y, 1.);\n        to = vec2(2.*iResolution.x/iResolution.y, 2.) * iMouse.xy / iResolution.xy - vec2(iResolution.x/iResolution.y, 1.);\n        del = true;\n    }\n    else if (state.yz == vec2(0) && state.w > 0.5)\n    {\n        // attract mode\n        from = vec2(sin((iTime - iTimeDelta) * 2.), cos((iTime - iTimeDelta) * 5.2)) * vec2(iResolution.x / iResolution.y, 1.) * 0.9;\n        to = vec2(sin(iTime * 2.), cos(iTime * 5.2)) * vec2(iResolution.x / iResolution.y, 1.) * 0.9;\n        del = sin(iTime * 23.) > 0.2;\n    }\n\n    if (del)\n    {\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n        mat4 w2c = inverse(c2w);\n        \n        vec3 posCamera = (w2c * vec4(p.pos,1.0)).xyz;\n        posCamera.xy = posCamera.xy / posCamera.z;     \n        \n        float dist2 = fxLinePointDist2(from, to, posCamera.xy);\n\n        if (dist2 < 0.0005) p.disabled = true;\n    }\n\n    fragColor = fxSaveParticle(p, dataType);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id==-1) return 1e20;\n    vec4 worldPos = fxGetParticleData(id, POS);\n    if (worldPos.w != 0.) return 1e20;\n    vec3 screenPos = (w2cNew * vec4(worldPos.xyz,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    computeClothSide(iResolution);\n    if(iFragCoord == ivec2(0))\n    {\n        // Reset if resolution changes\n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iFrame == 0 ||\n            iResolution.x * iResolution.y != abs(state.x) ||\n            keyDown(KEY_SPACE) ||\n            state.w > 30.)\n        {\n            state = vec4(-iResolution.x * iResolution.y, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            state.x = abs(state.x);\n        }\n        \n        if (iMouse.z > 0.)\n        {\n            state.yz = iMouse.xy;\n        }\n        \n        if (state.yz == vec2(0))\n        {\n            state.w += iTimeDelta;\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    ivec4 old   = fxGetClosest( iFragCoord );      \n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, p, w2c);\n        insertion_sort( new, dis, id, dis2 );\n        \n        // randomly check one of the neighbors of the particle, it's likely to be of interest\n        int nid;\n        switch((iFrame + int(j)) % 4)\n        {\n            case 0: nid = above(id); break;\n            case 1: nid = below(id); break;\n            case 2: nid = left(id); break;\n            case 3: nid = right(id); break;\n        }\n        \n        if (nid >= 0)\n        {\n            float dis2 = distance2Particle(nid, p, w2c);\n            insertion_sort( new, dis, nid, dis2 );\n        }\n    }\n\n    uint searchRange = 15u;\n    uint searchCount = 32u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, fragCoord) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<1; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n\n        //pick random id of particle\n        int id = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n    }\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}