{
    "Shader": {
        "info": {
            "date": "1682037096",
            "description": "Uses the normal mapping algorithms from https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set#Normal_map_effect . Click and drag to pan, Shift + W/S to zoom, hit c for a center dot for screenshots :)",
            "flags": 48,
            "hasliked": 0,
            "id": "mttGRN",
            "likes": 10,
            "name": "Normalbrot",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "normals"
            ],
            "usePreview": 1,
            "username": "RandomScientist",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n\nfloat mag(vec2 a){ return sqrt(dot(a,a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(keyDown(67)&&(mag(fragCoord-(iResolution.xy-iResolution.xy/2.)))<2.) c = vec4(1,0,0,1.0);\n    // Output to screen\n    fragColor = c;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst ivec2 POSITION = ivec2(1, 1);\nconst ivec2 ZOOM = ivec2(1,2);\nconst ivec2 BPOS = ivec2(2,2);\nconst ivec2 DPOSITION = ivec2(1,0);\nconst ivec2 OLDPOSITION = ivec2(2, 1);\nconst ivec2 DZOOM = ivec2(0,0);\nconst ivec2 OLDZOOM = ivec2(3, 0);\nconst ivec2 DBPOS = ivec2(0,1);\n// Henry Thasler's trick (this keeps the shader compiler from optimizing away precision that we want)\n// For some reason (at least on my machine), this needs only to be applied to subtractions\nfloat mul_frc(float a, float b) {\n  return a * b;\n}\n\nfloat add_frc(float a, float b) {\n  return a + b;\n}\n\nfloat sub_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat div_frc(float a, float b) {\n    return a / b;\n}\n\nfloat sqrt_frc(float a) {\n    return sqrt(a);\n}\n\n/*Double single precision numbers based on the ancient DSFUN90 fortran library. \nGlorious fortran 90 source here (thank god for internet archive): \nhttps://web.archive.org/web/20110807012734/http://crd.lbl.gov/~dhbailey/mpdist/dsfun90.tar.gz\n*/\n// create double-single number from float\nvec2 ftod(float a) {\n  return vec2(a, 0.0);\n}\n// Add: res = dsadd(a, b) => res = a + b\nvec2 dsadd (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = add_frc(dsa.x, dsb.x);\n  e = sub_frc(t1, dsa.x);\n  t2 = add_frc(add_frc(add_frc(sub_frc(dsb.x, e), sub_frc(dsa.x, sub_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = add_frc(t1, t2);\n  dsc.y = sub_frc(t2, sub_frc(dsc.x, t1));\n  return dsc;\n}\n// Subtract: res = dssub(a, b) => res = a - b\nvec2 dssub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = sub_frc(dsa.x, dsb.x);\n  e = sub_frc(t1, dsa.x);\n  t2 = sub_frc(add_frc(add_frc(sub_frc(sub_frc(0.0, dsb.x), e), sub_frc(dsa.x, sub_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = add_frc(t1, t2);\n  dsc.y = sub_frc(t2, sub_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat dscompare(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = dsmul(a, b) => res = a * b\nvec2 dsmul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = mul_frc(dsa.x, split);\n  conb = mul_frc(dsb.x, split);\n  a1 = sub_frc(cona, sub_frc(cona, dsa.x));\n  b1 = sub_frc(conb, sub_frc(conb, dsb.x));\n  a2 = sub_frc(dsa.x, a1);\n  b2 = sub_frc(dsb.x, b1);\n\n  c11 = mul_frc(dsa.x, dsb.x);\n  c21 = add_frc(mul_frc(a2, b2), add_frc(mul_frc(a2, b1), add_frc(mul_frc(a1, b2), sub_frc(mul_frc(a1, b1), c11))));\n\n  c2 = add_frc(mul_frc(dsa.x, dsb.y), mul_frc(dsa.y, dsb.x));\n\n  t1 = add_frc(c11, c2);\n  e = sub_frc(t1, c11);\n  t2 = add_frc(add_frc(mul_frc(dsa.y, dsb.y), add_frc(sub_frc(c2, e), sub_frc(c11, sub_frc(t1, e)))), c21);\n\n  dsc.x = add_frc(t1, t2);\n  dsc.y = sub_frc(t2, sub_frc(dsc.x, t1));\n\n  return dsc;\n}\n// Divide: res = dsdiv(a, b) => res = a / b\nconst float split = 8193.;\nvec2 dsdiv(vec2 dsa, vec2 dsb) {\n    float a1, a2, b1, b2, cona, conb, c11, c2, c21, e, s1, s2, t1, t2, t11, t12, t21, t22;\n    vec2 dsc;\n    s1 = div_frc(dsa.x, dsb.x);\n    cona = mul_frc(s1, split);\n    conb = mul_frc(dsb.x, split);\n    a1 = sub_frc(cona, sub_frc(cona, s1));\n    b1 = sub_frc(conb, sub_frc(conb, dsb.x));\n    a2 = sub_frc(s1, a1);\n    b2 = sub_frc(dsb.x, b1);\n    \n    c11 = mul_frc(s1, dsb.x);\n    c21 = add_frc(mul_frc(a2, b2), add_frc(mul_frc(a2, b1), add_frc(mul_frc(a1, b2), sub_frc(mul_frc(a1, b1), c11))));\n    \n    c2 = mul_frc(s1, dsb.y);\n    t1 = add_frc(c11, c2);\n    e = sub_frc(t1, c11);\n    \n    t2 = add_frc(add_frc(sub_frc(c2, e), sub_frc(c11, sub_frc(t1, e))),c21);\n    t12 = add_frc(t1, t2);\n    t22 = sub_frc(t2, sub_frc(t12, t1));\n    t11 = sub_frc(dsa.x, t12);\n    \n    e = sub_frc(t11, dsa.x);\n    t21 = add_frc(add_frc(sub_frc(-t12, e),sub_frc(dsa.x,sub_frc(t11,e))),sub_frc(dsa.y, t22));\n    \ns2 = div_frc(add_frc(t11, t21), dsb.x);\n    dsc.x = add_frc(s1, s2);\n    dsc.y = sub_frc(s2, sub_frc(dsc.x, s1));\n    return dsc;\n}\n// Absolute value: res = dsabs(a) = |a|\nvec2 dsabs(vec2 a) {\n    if(dscompare(a, vec2(0.0)) == -1.0) {return dsmul(a, ftod(-1.0));}\n    else {return a;}\n}\n//Max: res = dsmax(a, b) = a > b ? a : b\nvec2 dsmax(vec2 a, vec2 b) {\n    if(dscompare(a, b) == 1.0) {return a;} else {return b;}\n}\n//Min: res = dsmin(a, b) = a < b ? a : b\nvec2 dsmin(vec2 a, vec2 b) {\n    if(dscompare(a, b) == -1.0) {return a;} else {return b;}\n}\n\nvec2 dssqrt(vec2 a) {\n    float t1, t2, t3;\n    vec2 s0, s1, v0;\n    if(a.x == 0.0){return vec2(0.0,0.0);}\n    t1 = div_frc(1., sqrt(a.x));\n    //t2 = a.x * t1;\n    t2 = mul_frc(a.x, t1);\n    v0 = vec2(t2, 0.0);\n    s0 = dsmul(v0,v0);\n    s1 = dssub(a, s0);\n    //t3 = 0.5 * s1.x * t1;\n    t3 = mul_frc(mul_frc(s1.x, 0.5), t1);\n    s0.x = t2;\n    s0.y = 0.;\n    s1.x = t3;\n    s1.y = 0.;\n    return dsadd(s0, s1);\n}\n\n// this is still lossy, but it loses less information than pure single prec, soooo it's fine.\nvec2 double_ln(vec2 a) {\n    return\n    dsadd(vec2(log(a.x),0.0),\n    vec2(log(1.0+a.y/a.x),0.0)\n    );\n}\n\n//exp(x+y) = exp(x)*exp(y)\nvec2 double_exp(vec2 a) {\n    return dsmul(ftod(exp(a.x)),ftod(exp(a.y)));\n}\n\n// functions for 2d vectors of DS components\nvec4 to2d(vec2 a) {\n    return vec4(a.x, 0.0, a.y, 0.0);\n}\n//Hypot: res = hypot2d(<ai, bj>) = sqrt(a^2+b^2)\nvec2 hypot2d(vec4 z) {\n    vec2 t;\n    vec2 x = dsabs(z.xy);\n    vec2 y = dsabs(z.zw);\n    t = dsmin(x, y);\n    x = dsmax(x, y);\n    t = dsdiv(t, x);\n    if(z == vec4(0.0)) {return vec2(0.0);} else {\n        return dsmul(x, dssqrt(dsadd(ftod(1.0), dsmul(t, t))));\n    }\n}\n\n//Vector addition: add2d(a, b) = d2(a.x + b.x, a.y + b.y)\nvec4 add2d(vec4 a, vec4 b){ return vec4(dsadd(a.xy,b.xy),dsadd(a.zw,b.zw));}\n//Vector component wise multiplication: mul2d(a, b) = d2(a.x * b.x, a.y * b.y)\nvec4 mul2d(vec4 a, vec4 b){ return vec4(dsmul(a.xy,b.xy),dsmul(a.zw,b.zw));}\n//Vector component x scalar multiplication: mulBoth(a, b) = d2(a.x * b, a.y * b)\nvec4 mulBoth(vec4 a, vec2 b){ return vec4(dsmul(a.xy,b.xy),dsmul(a.zw,b.xy));}\n//Vector component / scalar division: divBoth(a, b) = d2(a.x / b, a.y / b)\nvec4 divBoth(vec4 a, vec2 b){ return vec4(dsdiv(a.xy, b.xy), dsdiv(a.zw, b.xy));}\n//Vector subtraction: sub2d(a, b) = d2(a.x - b.x, a.y - b.y)\nvec4 sub2d(vec4 a,vec4 b){return vec4(dssub(a.xy,b.xy),dssub(a.zw,b.zw));}\n//Vector dot product: dotd(a, b) = dot(a, b)\nvec2 dotd(vec4 a, vec4 b){return vec2(dsadd(dsmul(a.xy,b.xy),dsmul(a.zw,b.zw)));}\n// take the component wise square of a vector: square(a) = d2(a.x^2 + a.y^2) \nvec4 square(vec4 a){return vec4(dsmul(a.xy,a.xy),dsmul(a.zw,a.zw));}\n\n//numeric constants\nconst vec4 TWO = vec4(2.0,0.0,2.0,0.0);\nconst vec4 ONE = vec4(1.0,0.0,0.0,0.0);\nconst float PI = 3.14159265358979323846;\n//direction of incoming \"light\"\nconst vec2 light_direction = vec2(cos(PI/4.0), sin(PI/4.0));\n\n//macro to \"load\" a data pixel from iChannel0 (Buff_A)\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n// size of look behind buffer\n#define LOOKBEHIND_CT 2\n//keyboard\n#define keyDown(K) (texelFetch( iChannel1, ivec2(K,0),0 ).x==1.)\n        \nvec4 cmul(vec4 a, vec4 b) {\n    return vec4(dssub(dsmul(a.xy, b.xy), dsmul(a.zw,b.zw)), dsadd(dsmul(a.xy,b.zw), dsmul(a.zw, b.xy) ));\n}\nvec4 cdiv(vec4 a, vec4 b) {\n    vec2 bdot = dotd(b, b);\n    return vec4(\n        dsdiv(\n            dsadd(\n                dsmul(a.xy, b.xy),\n                dsmul(a.zw, b.zw)\n            ), \n            bdot), \n        dsdiv(\n            dssub(\n                dsmul(a.zw, b.xy),\n                dsmul(a.xy, b.zw)\n                )\n            ,\n            bdot)\n        );\n}\nvec4 csquare(vec4 a) {\n    return vec4(dssub(dsmul(a.xy,a.xy), dsmul(a.zw, a.zw)),dsmul(dsmul(a.zw,a.xy),ftod(2.)));\n}\n//complex conjugate of a\nvec4 conju(vec4 a) {return vec4(a.xy, dsmul(vec2(-1.0, 0.0), a.zw));}\n\nstruct Iterate {\n    vec4 z;\n    vec4 der;\n    vec4 der2;\n};\n\nconst float OVERFLOW = 100000000000000000.0;\nconst vec3 in_color = vec3(0.0);\n\nvec3 dmandel (vec4 c, int maxiter, float erad){\n    //init variables\n    Iterate current = Iterate(c, ONE, vec4(0.0));\n    vec2 erad2 = dsmul(ftod(erad), ftod(erad));\n    int stepstaken = 0;\n    float stepslimit = 2.0;\n    vec4 squared = vec4(0.0);\n    vec4 old = c;\n    vec4 u;\n    vec2 lo;\n    Iterate previousIterate;\n    \n    for (int i=0; i<maxiter; i++) {\n        //convenience for z^2\n        squared = square(current.z);\n        \n        // compute the next iteration's dz/dc\n        vec4 new_der = add2d(cmul(mul2d(TWO, current.der), current.z), ONE);\n        \n        //compute the next iteration's d^2z/d^2c\n        vec4 new_der2 = mul2d(TWO,add2d(cmul(current.der2, current.z), csquare(current.der)));\n        \n        //compute the next iteration's z\n        current.z = vec4(dsadd(dssub(squared.xy,squared.zw),c.xy),dsadd(dsmul(dsmul(current.z.zw,current.z.xy),ftod(2.)),c.zw));\n        \n        //set stored values\n        current.der = new_der;\n        current.der2 = new_der2;\n        \n        //update squared\n        squared = square(current.z);\n        \n        //test for escape\n        if(dscompare(dsadd(squared.xy, squared.zw), erad2) == 1.0) {\n            //normalized iteration count\n            float ni = float(i)+4.-log2(log2(dsadd(squared.xy,squared.zw).x));\n            \n            // we need this for later\n            squared = square(previousIterate.z);\n            \n            //nice gradient\n            vec3 col = 0.5 + 0.5*cos( 3.0 + ni*0.25 + vec3(0.0,0.6,1.0));\n            \n            //convenience for squared magnitude of z\n            vec2 magsq = dsadd(squared.xy, squared.zw);\n            \n            // complex analysis witchcraft\n            lo = dsmul(ftod(0.5), double_ln(magsq));\n            vec2 lop1 = dsadd(lo, ftod(1.0));\n            vec2 lop1XmagsqDer = dsmul(lop1, dotd(previousIterate.der, previousIterate.der));\n            vec2 loXmagsqZ = dsmul(lo, magsq);\n            u = sub2d(mulBoth(cmul(previousIterate.z, conju(previousIterate.der)), lop1XmagsqDer),\n                mulBoth(cmul(previousIterate.der, conju(previousIterate.der2)), loXmagsqZ)\n            );\n            \n            // if the witchcraft above will probably cause an overflow, use the normal derivative of M instead \n            // (I have no idea why the sqrt(erad) thing works, but it seems to make the switch correctly for any escape radius >= 1000)\n            if( hypot2d(previousIterate.der2).x > OVERFLOW / sqrt(erad - 999.0)) {\n                u = cdiv(previousIterate.z, previousIterate.der);\n            }\n            // if both normal generation methods will probably overflow, just return the color for this iteration\n            if(hypot2d(previousIterate.der).x > OVERFLOW) {\n                return col;\n            }\n            \n            // this function loses a lot less information than dssqrt(dotd(u, u))\n            vec2 hyp = hypot2d(u);\n            \n            //normalize u\n            u = divBoth(u, hyp);\n            \n            //lambertian lighting\n            float ref = dot(u.xz, light_direction) + 1.5;\n            ref /= 2.5;\n            \n            // shade color by light reflected\n            return ref * col;\n        }\n        \n        //brent's cycle detection\n        if(old==current.z) return in_color;\n        if(stepstaken==int(stepslimit)){\n            old = current.z;\n            stepstaken = 0;\n            stepslimit *= 2.;\n        }\n        stepstaken++;\n        \n        //store this iteration for potential use next iteration if it escapes\n        previousIterate = current;\n    }\n    return in_color;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "precision highp float;\n//macros\n// store/load macros that read/write vec4s to buffer A\n#define store(P,V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n//Keyboard macros\n#define keyDown(K) (texelFetch( iChannel1, ivec2(K,0),0 ).x==1.)\n\n\n//constants\n//keys\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n//define a memory boundary so we can use the rest of Buff_A for other things later\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\nconst int edit_me = 0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //if this pixel is outside of the memory boundary do other things(return)\n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    //passthrough previously defined values\n    fragColor = load(fragCoord);\n    //load relevant \"pixels\" from iChannel0 (which is set to display Buff_A) into local variables\n    float zoom = load(ZOOM).x;\n    vec2 pos = load(POSITION).xy;\n    vec2 bpos = load(BPOS).xy;\n    vec4 posd = load(DPOSITION);\n    store(OLDPOSITION, posd);\n    vec4 bposd = load(DBPOS);\n    vec2 dzoom = load(DZOOM).xy;\n    store(OLDZOOM, vec4(dzoom, vec2(0)));\n    //normalize mouse coordinates\n    vec4 mousecoords = vec4(iResolution.xy,iResolution.xy)-vec4(iMouse.xy,abs(iMouse.zw));\n    //default zoom value\n    if (zoom == 0.) zoom = 7.0;\n    if(dscompare(dzoom,ftod(0.))==0.) dzoom = ftod(0.01);\n    bool mouseDown = sign(iMouse.z) == 1.;\n    //set position to the latest base position plus the difference of mouse.xy and .zw if the mouse is held\n    if (mouseDown){ \n        pos = bpos + ((mousecoords.xy-mousecoords.zw)/pow(2.0,zoom));\n        posd = add2d(bposd,mul2d(to2d(mousecoords.xy-mousecoords.zw),vec4(dzoom,dzoom)));\n        \n    }\n    //update the base position if the mouse is not held\n    if (!mouseDown){ \n        bpos = pos;\n        bposd = posd;\n    }\n    //zoom in if w is held\n    if keyDown(87) {\n        //zoom faster if shift is held\n        if keyDown(16) {\n            zoom = zoom+.1;\n            dzoom = dsmul(dzoom,ftod(0.9));\n        }\n        else {\n            zoom = zoom+0.01;\n            dzoom = dsmul(dzoom,ftod(0.99));\n        }\n    }\n    //zoom out if s is held\n    if keyDown(83) {\n        //zoom faster if shift is held\n        if keyDown(16) {\n            zoom = zoom-0.1;\n            dzoom = dsmul(dzoom,ftod(1.1));\n        }\n        else {\n            zoom = zoom-0.01;\n            dzoom = dsmul(dzoom,ftod(1.01));\n        }\n    }\n    \n    store(DBPOS, bposd);\n    store(DPOSITION, posd);\n    store(DZOOM,vec4(dzoom,0.,0.));\n    store(ZOOM,vec4(zoom,0.,0.,0.));\n    store(POSITION,vec4(pos,0.,0.));\n    store(BPOS,vec4(bpos,0.,0.));\n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nuint hashInt( uint x )\n{\n  x += x >> 11;\n  x ^= x << 7;\n  x += x >> 15;\n  x ^= x << 5;\n  x += x >> 12;\n  x ^= x << 9;\n  return x;\n}\n\nuint hashInt( uvec2 v )\n{\n  uint x = v.x, y = v.y;\n  x += x >> 11;\n  x ^= x << 7;\n  x += y;\n  x ^= x << 6;\n  x += x >> 15;\n  x ^= x << 5;\n  x += x >> 12;\n  x ^= x << 9;\n  return x;\n}\n\nuint hashInt( uvec3 v )\n{\n  uint x = v.x, y = v.y, z = v.z;\n  x += x >> 11;\n  x ^= x << 7;\n  x += y;\n  x ^= x << 3;\n  x += z ^ ( x >> 14 );\n  x ^= x << 6;\n  x += x >> 15;\n  x ^= x << 5;\n  x += x >> 12;\n  x ^= x << 9;\n  return x;\n}\n\nfloat rand(uint h) {\n  const uint mantissaMask = 0x007FFFFFu;\n  const uint one          = 0x3F800000u;\n\n  h &= mantissaMask;\n  h |= one;\n    \n  float  r2 = uintBitsToFloat( h );\n  return r2 - 1.0;\n}\n\nfloat random( float f ) {\n  return rand(hashInt(floatBitsToUint(f)));\n}\n\nfloat random( vec2 f ) {\n  return rand(hashInt(floatBitsToUint(f)));\n}\n\nfloat random( vec3 f ) {\n  return rand(hashInt(floatBitsToUint(f)));\n}\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 posd = load(DPOSITION);\n    vec2 dzoom = load(DZOOM).xy;\n    vec4 oldpos = load(OLDPOSITION);\n    vec2 oldzoom = load(OLDZOOM).xy;\n    vec2 epsilon = dsmul(dzoom, ftod(0.5));\n    epsilon = dsmul(epsilon, ftod(random(vec3(fragCoord, float(iTime)))));\n    vec4 dcoords = mul2d(sub2d(to2d(fragCoord),mul2d(to2d(iResolution.xy),vec4(ftod(.5),ftod(.5)))),vec4(dzoom,dzoom));\n    vec4 duv = add2d(posd,dcoords);\n    int mi = 100;\n    float escaperadius = 1000.0;\n    vec4 result = vec4(dmandel(vec4(dsadd(duv.xy, epsilon), dsadd(duv.zw, epsilon)), mi, escaperadius), 1.0);\n    if(posd == oldpos && dzoom == oldzoom) {\n        fragColor = (texelFetch(iChannel2, ivec2(fragCoord), 0) + result) / 2.0;\n    } else {\n        fragColor = result;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}