{
    "Shader": {
        "info": {
            "date": "1558632367",
            "description": "2d perlin noise fbm",
            "flags": 0,
            "hasliked": 0,
            "id": "ttS3RD",
            "likes": 2,
            "name": "2D perlin 2D",
            "published": 3,
            "tags": [
                "perlin"
            ],
            "usePreview": 0,
            "username": "littlebird",
            "viewed": 529
        },
        "renderpass": [
            {
                "code": "vec2 rand2( vec2 x )\n{\n    const vec2 k = vec2( 3.1415926, 2.71828 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 136.0 * k * fract( x.x*x.y*(x.x+x.y)) );\n}\n\nvec2 rand1( vec2 x){\n     return -1.+2.*fract(sin(x * mat2(127.1,311.7, 269.5,183.3))*43758.5453123);\n}\n\nfloat noise(vec2 p, int rndx){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    //得到相邻4个点的随机梯度\n    vec2 g[4];\n    if(rndx == 1){\n        g[0] = rand1(i+vec2(0.0,0.0));\n        g[1] = rand1(i+vec2(1.0,0.0));\n        g[2] = rand1(i+vec2(0.0,1.0));\n        g[3] = rand1(i+vec2(1.0,1.0));\n    }\n    else if(rndx == 2){\n        g[0] = rand2(i+vec2(0.0,0.0));\n        g[1] = rand2(i+vec2(1.0,0.0));\n        g[2] = rand2(i+vec2(0.0,1.0));\n        g[3] = rand2(i+vec2(1.0,1.0));        \n    }\n    \n    //得到点与四个角的方向向量\n    vec2 d1 = f - vec2(0.0, 0.0);\n    vec2 d2 = f - vec2(1.0, 0.0);\n    vec2 d3 = f - vec2(0.0, 1.0);\n    vec2 d4 = f - vec2(1.0, 1.0);\n    \n    //计算每个点的梯队贡献值\n    float n1 = dot(g[0], d1);\n    float n2 = dot(g[1], d2);\n    float n3 = dot(g[2], d3);\n    float n4 = dot(g[3], d4);\n    \n    //加权求和\n    float r1 = mix(n1, n2, u.x);\n    float r2 = mix(n3, n4, u.x);\n    float r = mix(r1, r2, u.y);\n\n    return r;\n}\n\nfloat fbm(vec2 p, int rndx){\n    p *= 3.0;         //调整这里增加频率\n    float f = 0.;\n    f += 1.0 * abs(noise(p,rndx)); p=2.*p;\n    f += 0.5 * abs(noise(p,rndx)); p=2.*p;\n    f += 0.25 * abs(noise(p,rndx)); p=2.*p;\n    f += 0.125 * abs(noise(p,rndx)); p=2.*p;\n    f += 0.0625 * noise(p,rndx); p=2.*p;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    if(uv.x < 0.5){\n        col = vec3(fbm(uv,1));\n    }\n    else {\n        col = vec3(fbm(uv,1));\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}