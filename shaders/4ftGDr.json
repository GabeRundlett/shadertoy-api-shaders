{
    "Shader": {
        "info": {
            "date": "1711904826",
            "description": "Inspired by the discontinued IKEA kids carpet 'ringdans', with animations but a very limited selection of animals due to bad time planning capabilities.\n\nhttps://demozoo.org/graphics/342342/",
            "flags": 0,
            "hasliked": 0,
            "id": "4ftGDr",
            "likes": 8,
            "name": "Ringdans",
            "published": 3,
            "tags": [
                "2d",
                "revision",
                "gif"
            ],
            "usePreview": 1,
            "username": "wungasaurus",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "// 'ringdans':\n//   Inspired by the discontinued IKEA kids carpet 'ringdans', with animations but a very limited\n//   selection of animals due to bad time planning capabilities.\n// wungasaurus, Revision 2024, animated gif\n\n// #define PARTY_VERSION\n\n// All SDFs from/based on https://iquilezles.org/articles/, MIT, iq\n// [\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdOrientedVesica(vec2 p, vec2 a, vec2 b, float w) {\n  float r = 0.5 * length(b - a);\n  float d = 0.5 * (r * r - w * w) / w;\n  vec2  v = (b - a) / r;\n  vec2  c = (b + a) * 0.5;\n  vec2  q = 0.5 * abs(mat2(v.y, v.x, -v.x, v.y) * (p - c));\n  vec3  h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + w);\n  return length(q - h.xy) - h.z;\n}\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n  p = abs(p);\n  if (p.x > p.y) {\n    p  = p.yx;\n    ab = ab.yx;\n  }\n  float l  = ab.y * ab.y - ab.x * ab.x;\n  float m  = ab.x * p.x / l;\n  float m2 = m * m;\n  float n  = ab.y * p.y / l;\n  float n2 = n * n;\n  float c  = (m2 + n2 - 1.0) / 3.0;\n  float c3 = c * c * c;\n  float q  = c3 + m2 * n2 * 2.0;\n  float d  = c3 + m2 * n2;\n  float g  = m + m * n2;\n  float co;\n  if (d < 0.0) {\n    float h  = acos(q / c3) / 3.0;\n    float s  = cos(h);\n    float t  = sin(h) * sqrt(3.0);\n    float rx = sqrt(-c * (s + t + 2.0) + m2);\n    float ry = sqrt(-c * (s - t + 2.0) + m2);\n    co       = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) / 2.0;\n  } else {\n    float h  = 2.0 * m * n * sqrt(d);\n    float s  = sign(q + h) * pow(abs(q + h), 1.0 / 3.0);\n    float u  = sign(q - h) * pow(abs(q - h), 1.0 / 3.0);\n    float rx = -s - u - c * 4.0 + 2.0 * m2;\n    float ry = (s - u) * sqrt(3.0);\n    float rm = sqrt(rx * rx + ry * ry);\n    co       = (ry / sqrt(rm - rx) + 2.0 * g / rm - m) / 2.0;\n  }\n  vec2 r = ab * vec2(co, sqrt(1.0 - co * co));\n  return length(r - p) * sign(p.y - r.y);\n}\n\nvec3 sdJoint2DSphere(in vec2 p, in float l, in float a, float w) {\n  if (abs(a) < 0.001) {\n    float v  = p.y;\n    p.y     -= clamp(p.y, 0.0, l);\n    return vec3(length(p), p.x, v);\n  }\n  vec2  sc  = vec2(sin(a), cos(a));\n  float ra  = 0.5 * l / a;\n  p.x      -= ra;\n  vec2  q   = p - 2.0 * sc * max(0.0, dot(sc, p));\n  float u   = abs(ra) - length(q);\n  float d   = (q.y < 0.0) ? length(q + vec2(ra, 0.0)) : abs(u);\n  float s   = sign(a);\n  float v   = ra * atan(s * p.y, -s * p.x);\n  u         = u * s;\n  if (v < 0.0) {\n    if (s * p.x > 0.0) {\n      v = abs(ra) * 6.283185 + v;\n    } else {\n      v = p.y;\n      u = q.x + ra;\n    }\n  }\n  return vec3(d - w, u, v);\n}\n\nfloat dot2(in vec2 v) {\n  return dot(v, v);\n}\nfloat cro(in vec2 a, in vec2 b) {\n  return a.x * b.y - a.y * b.x;\n}\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n  vec2  a   = B - A;\n  vec2  b   = A - 2.0 * B + C;\n  vec2  c   = a * 2.0;\n  vec2  d   = A - pos;\n  float kk  = 1.0 / dot(b, b);\n  float kx  = kk * dot(a, b);\n  float ky  = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n  float kz  = kk * dot(d, a);\n  float res = 0.0;\n  float sgn = 0.0;\n  float p   = ky - kx * kx;\n  float q   = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n  float p3  = p * p * p;\n  float q2  = q * q;\n  float h   = q2 + 4.0 * p3;\n  if (h >= 0.0) { // 1 root\n    h        = sqrt(h);\n    vec2  x  = (vec2(h, -h) - q) / 2.0;\n    vec2  uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n    float t  = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    vec2  q  = d + (c + b * t) * t;\n    res      = dot2(q);\n    sgn      = cro(c + 2.0 * b * t, q);\n  } else { // 3 roots\n    float z  = sqrt(-p);\n    float v  = acos(q / (p * z * 2.0)) / 3.0;\n    float m  = cos(v);\n    float n  = sin(v) * 1.732050808;\n    vec3  t  = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n    vec2  qx = d + (c + b * t.x) * t.x;\n    float dx = dot2(qx), sx = cro(c + 2.0 * b * t.x, qx);\n    vec2  qy = d + (c + b * t.y) * t.y;\n    float dy = dot2(qy), sy = cro(c + 2.0 * b * t.y, qy);\n    if (dx < dy) {\n      res = dx;\n      sgn = sx;\n    } else {\n      res = dy;\n      sgn = sy;\n    }\n  }\n  return sqrt(res) * sign(sgn);\n}\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\nfloat opOnion(float sdf, float thickness) {\n  return abs(sdf) - thickness;\n}\nfloat opSmoothExpUnion(float a, float b, float k) {\n  float res = exp2(-k * a) + exp2(-k * b);\n  return -log2(res) / k;\n}\n\n#define REPEATED(OUT_, SCENE_, REPEATED_P_, REPEATED_S_)                                                                                                       \\\n  do {                                                                                                                                                         \\\n    vec2  REPEATED_P = REPEATED_P_;                                                                                                                            \\\n    float REPEATED_S = REPEATED_S_;                                                                                                                            \\\n                                                                                                                                                               \\\n    vec2 REPEATED_ID = round(REPEATED_P / REPEATED_S);                                                                                                         \\\n    vec2 REPEATED_O  = sign(REPEATED_P - REPEATED_S * REPEATED_ID);                                                                                            \\\n                                                                                                                                                               \\\n    OUT_ = 1e20;                                                                                                                                               \\\n    for (int j = 0; j < 2; j++) {                                                                                                                              \\\n      for (int i = 0; i < 2; i++) {                                                                                                                            \\\n        vec2 REPEATED_RID = REPEATED_ID + vec2(i, j) * REPEATED_O;                                                                                             \\\n        vec2 REPEATED_R   = REPEATED_P - REPEATED_S * REPEATED_RID;                                                                                            \\\n        OUT_              = min(OUT_, SCENE_(REPEATED_R));                                                                                                     \\\n      }                                                                                                                                                        \\\n    }                                                                                                                                                          \\\n  } while (false)\n// ]\n\n// Noise functions (brown, grey)\n// todo: unknown origin\n// [\nfloat noise3to1(in vec3 p) {\n  mat3 m = mat3(1.0, 0.0, 0.0, 0.5, 1.2, 0.0, 0.0, 0.0, 1.0);\n  vec3 s = m * p;\n  return sin(s.x) * sin(s.y) * sin(s.z);\n}\nvec3 noise3to3(in vec3 p) {\n  return vec3(noise3to1(p.xyz + vec3(1, 2, 3) * vec3(0.9, 0.7, 1.3)), noise3to1(p.zyx + vec3(7, 9, 8) * vec3(0.5, 1.2, 1.1)),\n              noise3to1(p.yxz + vec3(3, 2, 5) * vec3(0.8, 0.3, 1.5)));\n}\n\nvec3 brown(in vec3 p) {\n  return 0.5 * noise3to3(p) + 0.2 * noise3to3(p * 3.0) + 0.1 * noise3to3(p * 5.0);\n}\nvec3 grey(in vec3 p) {\n  return (brown(brown(p * 0.1) * 5.0) - vec3(.5)) * 2.;\n}\n// ]\n\n// Basic 2D math\n// [\n#define M_PI 3.1415926535897932384626433832795\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\nvec2 mirrorX(vec2 uv) {\n  return vec2(-1., 1.) * uv;\n}\nvec2 mirrorY(vec2 uv) {\n  return vec2(1., -1.) * uv;\n}\n// ]\n\n// -------------------------------------------\nfloat cocbpm   = 180.0;\nfloat cocfac   = 1.0;\nfloat looptime = 7.0;\nfloat time() {\n  return iTime * cocbpm / 30.0;\n}\nfloat csc() {\n  return 0.015 * pow(sin(2.0 * time() * cocfac), 4.) + 0.95;\n}\nvec3 greyt(int idx, int var) {\n  return grey(vec3(sin(2.0 * M_PI * time() / looptime), float(idx), float(var)));\n}\nfloat scrollOffs() {\n  float stutter = 0.00 * pow(sin(time()), 4.0);\n  return -1.5 - 1.0/1.0371 * time() / 3.5 + stutter;\n}\nfloat bgnoise(vec2 p) {\n//    p = sin(p/3.0);\n  return 0.9 + 0.5 * (0.02358 * grey(p.xyy * 13.0).x + 0.0225 * grey(p.xyy * 71.0).x + 0.02394 * grey(p.xyy * 17.0).x);\n}\n\n// idx [0]\nfloat sheepFoot(int idx, vec2 p, float a, float av, float b, float bv, float c, float cv) {\n  float d = 1.;\n\n  d = opUnion(sdJoint2DSphere(p, a + greyt(idx, 2).x * av, b + greyt(idx, 1).x * bv, c + greyt(idx, 0).x * cv).x, d);\n\n  return d;\n}\n\n// idx [0…7]\nfloat sheepCloud(int idx, vec2 p) {\n  float d = 1.;\n\n  d = opUnion(sdCircle(p + greyt(idx + 0, 1).xy * 0.02, 0.25 + greyt(idx + 0, 0).x * 0.01), d);\n  d = opUnion(sdCircle(p - vec2(0.2, 0.2) + greyt(idx + 1, 1).xy * 0.02, 0.25 + greyt(idx + 1, 0).x * 0.01), d);\n  d = opUnion(sdCircle(p - vec2(0.5, 0.1) + greyt(idx + 2, 1).xy * 0.03, 0.25 + greyt(idx + 2, 0).x * 0.02), d);\n  d = opUnion(sdCircle(p - vec2(0.6, -0.1) + greyt(idx + 3, 1).xy * 0.01, 0.25 + greyt(idx + 3, 0).x * 0.01), d);\n  d = opUnion(sdCircle(p - vec2(0.35, -0.25) + greyt(idx + 4, 1).xy * 0.03, 0.40 + greyt(idx + 4, 0).x * 0.03), d);\n  d = opUnion(sdCircle(p - vec2(-0.1, -0.2) + greyt(idx + 5, 1).xy * 0.02, 0.25 + greyt(idx + 5, 0).x * 0.01), d);\n  d = opUnion(sdCircle(p - vec2(0.05, -0.4) + greyt(idx + 6, 1).xy * 0.03, 0.25 + greyt(idx + 6, 0).x * 0.04), d);\n  d = opUnion(sdCircle(p - vec2(0.25, -0.4) + greyt(idx + 7, 1).xy * 0.02, 0.25 + greyt(idx + 7, 0).x * 0.01), d);\n\n  return d;\n}\n\n// idx [0…2]\nfloat sheepHead(int idx, vec2 p) {\n  float d = 1.;\n\n  d = opUnion(sdOrientedVesica(p - vec2(-.5, -.15), vec2(0.25, 0.05) - greyt(idx + 0, 1).xy * 0.005, vec2(0.5, 0.), 0.06), d);\n  d = opUnion(sdOrientedVesica(p - vec2(-.5, -.17), vec2(0.75, 0.05) - greyt(idx + 1, 1).xy * -0.01, vec2(0.5, 0.), 0.07), d);\n  d = opUnion(sdEllipse(p - vec2(.0, .0), vec2(.14, .22) + greyt(idx + 2, 1).xy * .01), d);\n\n  return d;\n}\n\n// idx [0…1]\nfloat sheepEyes(int idx, vec2 p) {\n  float d = 1.;\n\n  d = opUnion(sdOrientedVesica(rotate(p, 1.24) - vec2(-.3, -.1), vec2(0.3, 0.05) - greyt(idx + 0, 1).xy * 0.005, vec2(0.35, 0.04), 0.013), d);\n  d = opUnion(sdOrientedVesica(rotate(p, 1.25) - vec2(.02, -.03), vec2(0.01, 0.05) - greyt(idx + 1, 1).xy * -0.001, vec2(0.05, 0.03), 0.012), d);\n\n  return d;\n}\n\n// idx [0…16]\nfloat sheep(int idx, vec2 p, float sc) {\n  float d = 1.;\n\n  p += vec2(0.3, -0.1);\n  p *= sc;\n\n  d = opUnion(sheepCloud(idx + 0, p), d);\n  d = opUnion(sheepFoot(idx + 8, mirrorY(p - vec2(-0.2, -0.05)), .45, .10, -1.3, 0.2, .05, 0.008), d);\n  d = opUnion(sheepFoot(idx + 9, mirrorY(p - vec2(-0.2, -0.35)), .25, .05, -0.7, 0.2, .05, 0.009), d);\n  d = opUnion(sheepFoot(idx + 10, rotate(mirrorY(p - vec2(0.65, -0.48)), 3.14 / 2.), .25, .10, -0.7, 0.2, .05, 0.01), d);\n  d = opUnion(sheepFoot(idx + 11, rotate(mirrorY(p - vec2(0.85, -0.15)), 3.14 / 2.), .25, .10, -0.3, 0.2, .045, 0.01), d);\n  d = opSubtraction(sheepHead(idx + 12, rotate(p - vec2(0.25, -0.05) - greyt(12, 1).xy * .01, 2.2 - sin(greyt(12, 0).x))), d);\n  d = opUnion(sheepEyes(idx + 14, rotate(p - vec2(0.25, -0.05) - greyt(12, 1).xy * .01, 2.2 - sin(greyt(12, 0).x))), d);\n\n  return d;\n}\n\n// idx [0]\nfloat foxFoot(int idx, vec2 p) {\n  float d = 1.;\n\n  d = opUnion(opOnion(sdBezier(p, vec2(0.0, 0.0), vec2(0.0, -0.3), vec2(0.1, -0.25)), 0.008 * greyt(idx, 1).x + 0.03), d);\n\n  return d;\n}\n\n// idx [0…5]\nfloat fox(int idx, vec2 p, float sc) {\n  float d = 1.;\n\n  p *= sc;\n\n  vec2 q = (p + vec2(.2, .0));\n\n  if (p.x > 0.85) {\n    p.y -= smoothstep(0., 1., 1.05 * cos(time() / 2.3) * 0.9 * (p.x - 0.85) * .7);\n  }\n  if (q.x > 0.65) {\n    q.y += smoothstep(0., 1., 1.25 * sin(time() / 1.5) * 0.3 * (q.x - 0.65) * .7);\n  }\n\n  d = opUnion(sdOrientedVesica(p + vec2(.8, .1), vec2(-.3, -.2) - greyt(idx + 0, 1).xy * 0.005, vec2(0.5, 0.), 0.2), d);\n  d = opSmoothExpUnion(sdOrientedVesica(p + vec2(.3, .2), vec2(-.2, .0) - greyt(idx + 0, 1).xy * 0.005, vec2(1.5, 0.1), 0.26), d, 128.);\n  d = opSmoothExpUnion(sdOrientedVesica(q + vec2(.1, .2), vec2(-.2, .0) - greyt(idx + 0, 1).xy * 0.005, vec2(1.5, 0.1), 0.26), d, 128.);\n  d = opUnion(sdOrientedVesica(p + vec2(-.3, .2), vec2(.3, .5), vec2(.4, 0.1), 0.08), d);\n  d = opUnion(sdOrientedVesica(p + vec2(-.3, .2), vec2(.5, .47), vec2(.5, 0.05), 0.07), d);\n\n  // feet\n  d = opUnion(foxFoot(idx + 2, rotate(p + vec2(-.1, 0.35), 0.2 + 0.1 * (1. - sin(time())))), d);\n  d = opUnion(foxFoot(idx + 3, rotate(p + vec2(.1, .35), 0.1 + 0.1 * (1. - sin(1.5 + time())))), d);\n  d = opUnion(foxFoot(idx + 4, rotate(p + vec2(-.7, .3), 0.05 + 0.1 * (1. - sin(0.2 + time())))), d);\n  d = opUnion(foxFoot(idx + 5, rotate(p + vec2(-.6, .35), 0.2 + 0.1 * (1. - sin(1.3 + time())))), d);\n\n  // eyes\n  vec2 pEyes = p + vec2(-0.2, .16);\n  d          = opSubtraction(sdOrientedVesica(pEyes + vec2(0.05, .0) + greyt(idx + 0, 1).xy * 0.02, vec2(.5, .1), vec2(.5, 0.03), 0.02), d);\n  d          = opSubtraction(sdOrientedVesica(pEyes + vec2(-.05, .01) + greyt((idx + 1), 1).xy * 0.02, vec2(.5, .1), vec2(.5, 0.023), 0.02), d);\n\n  return d;\n}\n\nfloat snek(int idx, vec2 p, float sc) {\n  float d = 1.0;\n\n  p *= sc;\n\n  float t = time();\n\n  vec2 v0 = vec2(0.2, 0.4 + 0.11 * sin(5.1 + t));\n  vec2 v1 = vec2(0.0, 0.4 + 0.18 * sin(5.1 + t));\n  vec2 v2 = vec2(0.05, 0.0 + 0.07 * sin(0.0 + t));\n  vec2 v3 = vec2(0.1, -0.8 + 0.03 * sin(1.2 + t));\n  vec2 v4 = vec2(0.45, 0.05 + 0.03 * sin(2.1 + t));\n  vec2 v5 = vec2(0.6, 0.4 + 0.04 * sin(3.4 + t));\n  vec2 v6 = vec2(0.7, 0.1 + 0.04 * sin(3.4 + t));\n  vec2 v7 = vec2(0.9, -0.74 + 0.04 * sin(5.1 + t));\n  vec2 v8 = vec2(1.05, 0.3 + 0.08 * sin(5.1 + t));\n  vec2 v9 = vec2(1.15, 0.8 + 0.05 * sin(5.1 + t));\n  vec2 vA = vec2(1.3, 0.8 + 0.05 * sin(5.1 + t));\n  vec2 vB = vec2(1.55, 0.75 + 0.05 * sin(5.1 + t));\n  vec2 vC = vec2(1.55, 0.5 + 0.05 * sin(5.1 + t));\n\n  p += vec2(1., 0.3);\n\n  d = opUnion(opOnion(sdBezier(p, v0, v1, v2), 0.096), d);\n  d = opUnion(opOnion(sdBezier(p, v2, v3, v4), 0.097), d);\n  d = opUnion(opOnion(sdBezier(p, v4, v5, v6), 0.099), d);\n  d = opUnion(opOnion(sdBezier(p, v6, v7, v8), 0.101), d);\n  d = opUnion(opOnion(sdBezier(p, v8, v9, vA), 0.102), d);\n  d = opUnion(opOnion(sdBezier(p, vA, vB, vC), 0.11), d);\n\n  d = opSubtraction(sdOrientedVesica(p - vC - vec2(-0.5, 0.01 * sin(time())) + greyt(idx + 0, 1).xy * 0.02, vec2(.5, .1), vec2(.5, 0.03), 0.02), d);\n  d = opSubtraction(\n      sdOrientedVesica(p - vC - vec2(-0.54, -0.01 + 0.01 * sin(0.1 + time() / 2.0)) + greyt(idx + 0, 1).xy * 0.02, vec2(.5, .1), vec2(.5, 0.03), 0.02), d);\n\n  return d;\n}\n\nfloat fw  = 1.7;\nfloat shw = 1.8;\nfloat snw = 1.7;\n\nfloat scene(vec2 p) {\n  float d = 1.;\n\n  float sc = csc();\n\n  d = opUnion(fox((0), p + vec2(0.3, 0.15), sc), d);\n  d = opUnion(sheep((0 + 5), p - vec2(fw, 0.4), sc), d);\n  d = opUnion(snek((0 + 5 + 16), p - vec2(fw + shw, 0.1), sc), d);\n  d = opUnion(fox((0), p - vec2(-0.3 + fw + shw + snw, -0.15), sc), d);\n  d = opUnion(sheep((0 + 5), p - vec2(fw + shw + snw + fw, 0.4), sc), d);\n  d = opUnion(snek((0 + 5 + 16), p - vec2(fw + shw + snw + fw + shw, 0.1), sc), d);\n\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n// #define debug\n#ifndef debug\n  p.x += scrollOffs();\n  p   *= vec2(1.2);\n\n  float d;\n  REPEATED(d, scene, p, fw + shw + snw);\n#else\n  float d = sheep(0, p, csc());\n#endif\n\n  // coloring\n  vec3 col  = (d > 0.0) ? bgnoise(p) * vec3(57. / 255., 105. / 255., 38. / 255.) : vec3(181. / 255., 175. / 255., 159. / 255.);\n  col      *= 1.0 - 0.1 * exp(-10.0 * abs(d));\n  col      *= 1.8 + 0.01 * cos(150.0 * d);\n#ifdef PARTY_VERSION\n  col       = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.009, abs(d)));\n#else\n  col       = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 3./iResolution.y, abs(d)));\n#endif\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}