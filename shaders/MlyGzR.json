{
    "Shader": {
        "info": {
            "date": "1475362080",
            "description": "Imploded star cluster, inspired by this scene http://img.lum.dolimg.com/v1/images/swr214-journeyintothestarcluster_00ac28fd.jpeg?region=0%2C0%2C1280%2C720 from the show Star Wars Rebels. Song is the OST from the scene by Kevin Kiner. ",
            "flags": 112,
            "hasliked": 0,
            "id": "MlyGzR",
            "likes": 7,
            "name": "imploded star cluster",
            "published": 3,
            "tags": [
                "star",
                "imploded",
                "cluster"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 1315
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2016\n\n//http://i.imgur.com/g0SgMgS.jpg 1366x768 render\n\n\n/*\nLook at Buf A line 126 for the scene distance/material function.\n\nControls:\nlook - mouse\nmove - arrow keys\n\n*/\n\n\n\n\n//display montecarlo path trace result\n\n\n#define devrender 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if devrender == 0\n    vec4 csamp = texture(iChannel0, 0.5/iResolution.xy);\n    vec4 samp = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = pow(samp/samp.w/*/(float(iFrame-int(csamp.x*4096.)))*/, vec4(1./2.2));\n    \n    //used for exporting image in the format of r=lighting, g=opacity\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy)/(float(iFrame-120));\n    //fragColor.x = pow(fragColor.x, 1./2.2);\n    \n\t#else\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(1./2.2));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 4870,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/pandu-poluan/journey-into-the-star-cluster"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n//rendering pass\n\n\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n#define camera_fisheye 1.0\n\n#define iterations 64\n#define minDelta .35\n#define maxDelta .6\n#define skipDelta .5\n\n#define range 256.\n\n//#define sunImportance 0.05\n//#define sunDirectional 1.0\n\n\nvec3 sunDirection = normalize(vec3(-2.,5.,4.5)),\n     sunPosition = vec3(0.,0.,-35.);\nconst vec3 sunColor = vec3(1.,.74,.94)*1.,\n    \t   skyColor = vec3(1.,.9,.3)*0.05,\n    \t   ambientColor = vec3(1.);\n\nconst float sunSize = 0.001,//0-1\n    \t\tambientDensity = 0.;//0-2, global mist\n\n\n#define devrender 0\n\n\n\nstruct ctx {\n    vec3 point;\n    float distance_,\n          density, fluff, deformRoughness, deformAmount, deformScale, emission;\n    vec3 color;\n};\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\n\n\n//scene function, returns distance + material data at point\nctx scene(ctx i) {\n    vec3 p = i.point;\n        \n\t//star cluster base cloud\n    i.distance_ = max(-(length(p-vec3(0.,0.,-20.))-30.),max(0.,udBox(p, vec3(100.,100.,50.)-10.)-10.));\n\ti.color = 0.8+0.2*cos(vec3(.2,0.,.9284)*6.+abs(p.yzx*.1)+sin(p*0.034+vec3(.1,.3,2.)*20.834)*64.+cos(p.zxy)*1.1268);//random coloring\n    i.deformAmount = 0.7;\n    i.deformScale = 10.;\n    i.deformRoughness = 0.2;\n    i.fluff = 0.94;\n    //random emissive points\n    float em = (max(0.,hash3(floor(abs(p)/1.)*4.112773)-0.9995)/(1.-.9995))*(1.-length(fract(abs(p))-.5)/0.86602)+\n        \t   (max(0.,hash3(floor(abs(p)/20.)*7.812773)-0.91)/(1.-.91))*max(0.,1.-length(fract(abs(p/20.))-.5)/0.56602)*0.5;\n\ti.emission = em*5.;\n    i.density = .3+em;\n    \n    \n    //imploded star swirls\n    vec3 cp = p-vec3(0.,0.,20.);\n    float s = 2.;\n    vec2 id = vec2(0.);\n    if (length(cp.xy) > 25.) {\n        id = floor((cp.xy+50.0)/50.0)*0.1912485;\n        cp.xy = abs(abs(cp.xy)-50.0)+vec2(hash(id.y)-0.5,hash(id.x)-0.5)*50.0;\n        s = 0.5;\n    }\n    cp.xy = rot(cp.xy, pow(length(cp.xy)/.25,1./(1.8+cos(length(id)*6.19284)*0.2))+length(id)*10.9187);\n    float dst = udBox(cp, vec3(40.*s,0.05,30.))-1.;\n    i.distance_ += max(0.,5.*s-dst);\n    if (i.distance_ > dst-5.*s) {\n        if (s < 1.) i.distance_ = dst;\n        i.emission = s*50.0*max(0.,length(i.color)/1.74-.9);\n        i.color = vec3(254, 247, 223)/255.;\n        i.deformAmount = 0.05;\n    } else {\n        i.deformAmount = 0.7-max(0.,.7-max(0.,dst)/5.);   \n    }\n    \n    \n    return i;\n}\n\nctx scenePlain(ctx i) {\n    return i;\n}\n\n\n\n//backgrund\nvec3 background(vec3 d) {\n    \n    #ifdef sunDirectional\n    float sun = dot(normalize(sunDirection), d);\n    return mix(skyColor,\n               sunColor,\n               pow(max(0., sun-(1.-sunSize))/sunSize,.3));\n    #else\n    return skyColor;\n    #endif\n}\n\n\n\n//apply cloud warping and distance modifiers\nctx scene_warp(ctx cx) {\n    \n    cx = scene(cx);\n   \tfloat d = cx.distance_;\n    \n    vec3 p = cx.point;\n\n    //cloud shape deform\n    if (cx.deformAmount > 0.0) {\n        #define ldst d\n        for (int i = 1; i < 4; i++) {\n            float pfi = pow(float(i),2.)*cx.deformScale,\n                \tdmx = mix(1.,ldst+cos((p.x+p.y+p.z)/pfi)*pfi,cx.deformRoughness);\n            ldst -= abs(cos(p.x/pfi+cos(26.2348+dmx*(p.y*.39)/pfi)*4.)*\n                     cos(p.y/pfi+cos(29.8937+dmx*(p.z*.37)/pfi)*4.)*\n                     cos(p.z/pfi+cos(14.972+dmx*(p.x*.41)/pfi)*4.))*pfi*cx.deformAmount;\n        }\n    }\n    \n    cx = scenePlain(cx);\n    cx.distance_ = max(skipDelta, min(d,cx.distance_));\n    return cx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 camtex = texture(iChannel1, 0.5/iResolution.xy);\n    float frame = texture(iChannel2, 0.5/iResolution.xy).x*4096.;\n       \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //ray direction from uvs and ray position at origin\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)*vec2(-1.,1.)/iResolution.x,1./camera_fisheye)),\n         ird,\n         rp = camtex.xyz-range;\n    \n    vec2 cameraRot = decodeRot(camtex.w);\n    rd.yz = rot(rd.yz,cameraRot.y);\n    rd.xz = rot(rd.xz,cameraRot.x);\n    \n    ird = rd;\n    float ifrm = float(iFrame);\n    #define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n    \n    vec4 c = vec4(1,1,1,0);\n    \n    ctx cx;\n    \n    #if devrender == 0\n    \n    vec3 l = vec3(0.0);\n    \n    //render\n    for (int i = 0; i < iterations; i++) {\n        cx.point = rp;\n        cx = scene_warp(cx);\n        float d = cx.distance_,\n              dt = d*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta)),\n              k = min(1., (d-skipDelta)*10.*(1.-cx.fluff));\n        if (mix(cx.density,ambientDensity,k)*max(1.,dt*.1) > hash3(rp+rndifrm(rp)*256.)) {\n            c.xyz *= mix(cx.color,ambientColor,floor(k));\n            c.w = 1.;\n            l += cx.color*cx.emission*(1.0-floor(k));\n            #ifdef sunImportance\n            #ifdef sunDirectional\n            rd = mix(randomRay(rp+rndifrm(rp*1024.)*1024.), sunDirection, floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+sunImportance-1e-6));\n        \t#else\n            rd = mix(randomRay(rp+rndifrm(rp*1024.)*1024.), normalize(sunPosition-rp), floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+sunImportance-1e-6));\n            #endif\n            #else\n            rd = randomRay(rp+rndifrm(rp*1024.)*1024.);\n            #endif\n        }\n        \n        rp += rd*dt;\n        if (length(rp) > range) break;\n    }\n   \n    c.xyz = c.xyz*background(rd)*float(length(rp)/range > 1.)+ //if light ray makes it too edge of world illuminate it  \n    \t\tc.xyz*l;\n    fragColor = mix(vec4(background(ird),1.), c, c.w)+\n    texture(iChannel0, uv)*float(float(iFrame)-frame > 1.0);//blend result with background and add to buffer\n\n    //used for exporting image in the format of r=lighting, g=opacity\n    /*(fragColor = vec4(c.x*float(max(length(rp)/range,max(0.,-rp.y)/yRange) > 1.),c.w,0,0)+\n                     texture(iChannel0, uv);\n    */\n    \n    #else\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp);\n        if (d < .2 || c.w > range) break;\n        \n        rp += rd*d;\n        c.w += d;\n    }\n    if (df(rp) < .2) {\n       c = vec4(cloudColor*(.3+max(0.,(df(rp)-df(rp-sunDirection)))),1.);\n    } else {\n       c = vec4(background(ird),1.); \n    }\n    fragColor = c+texture(iChannel0,uv);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n\n//camera move and look\n\n\n\n#define uv (.5/iResolution.xy)\n#define camerarange 256.\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n\n#define mouse_sensitivity 0.025 * 60.0\n#define movement_sensitivity .5 * 60.0\n\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n\n\nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    if (iFrame < 10) {\n     \t//set default camera\n        vec3 camPos = vec3(30., -60., 130.),\n             camRot = vec3(3.14/-1.8, 3.14/2.9, 0.0);\n        \n        fragColor = vec4(camPos+camerarange, encodeRot(mod(camRot.xy,pi2)));\n        return;\n    }\n        \n   \tvec4 samp = texture(iChannel0, uv);\n    vec3 camPos = samp.xyz,\n             camRot = decodeRot(samp.w).xyy;\n    \n    //movement\n    float movementA = texture(iChannel1, vec2(38.5, 25.5)/255.).x-\n                                 texture(iChannel1, vec2(40.5, 25.5)/255.).x;\n    if (movementA != 0.) {\n        vec3 rdB = vec3(0.,0.,1.);    \n        rdB.yz = rot(rdB.yz,camRot.y);\n        rdB.xz = rot(rdB.xz,camRot.x);\n    \tcamPos.xyz += movementA*rdB*iTimeDelta*movement_sensitivity;\n    }\n    float movementB = texture(iChannel1, vec2(37.5, 25.5)/255.).x-\n                      texture(iChannel1, vec2(39.5, 25.5)/255.).x;\n    if (movementB != 0.) {\n         vec3 rdB = vec3(1.,0.,0.);    \n         rdB.yz = rot(rdB.yz,camRot.y);\n         rdB.xz = rot(rdB.xz,camRot.x);\n         camPos.xyz += movementB*rdB*iTimeDelta*movement_sensitivity;\n    }\n                \n    //rotation\n    if (iMouse.w > 0.) {\n    \tvec2 muv = (iMouse.xy/iResolution.xy)-.5;\n        camRot.xy += muv*vec2(1.,-1.)*mouse_sensitivity*iTimeDelta;\n    }\n\n    fragColor = vec4(max(camPos, 0.0), encodeRot(mod(camRot.xy,pi2)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n//frame of last camera change\n\n\n#define uv (.5/iResolution.xy)\n#define change_epsilon 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    vec4 csamp = texture(iChannel0, uv),\n         bsamp = texture(iChannel1, uv);\n    \n    float hash = fract(length(bsamp)+bsamp.w);\n    if (abs(hash-csamp.y) > change_epsilon) {\n     \tcsamp.y = hash;\n        csamp.x = float(iFrame)/4096.;\n    }\n    \n    fragColor = csamp;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}