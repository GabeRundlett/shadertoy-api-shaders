{
    "Shader": {
        "info": {
            "date": "1547078597",
            "description": "Made live shading style.",
            "flags": 0,
            "hasliked": 0,
            "id": "tssGRX",
            "likes": 7,
            "name": "Amas globulaire",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefield",
                "liveshading"
            ],
            "usePreview": 0,
            "username": "Alkama",
            "viewed": 634
        },
        "renderpass": [
            {
                "code": "#define t mod(iTime, 100.)*4.\n#define sat(v) clamp(v, 0., 1.)\n#define spow(v, p) clamp(pow(v, p), 0., 1.)\n\nconst float pi = acos(-1.);\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 40.;\n\nstruct ray {\n  vec3 o, d;\n};\n\nstruct material {\n  vec3 diffuse, specular;\n  float shine;\n};\n\nvec2 repeat(vec2 p, float n) { return mod(p-.5*n, n)-.5*n; }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nmat2 rot(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\nfloat torus(vec3 p, vec2 c) {\n  vec2 q = vec2(length(p.xz)-c.x, p.y);\n  return length(q)-c.y;\n}\n\nfloat dist(vec3 p) {\n  vec3 sp = p;\n  sp.xy = repeat(p.xy, 2.);\n  sp.xz = repeat(p.xz, 4.8);\n  sp.xz *= rot(t+p.y*8.)+.2*sin(t*.4);\n  sp.xy *= rot(pi/2.);\n\n  return torus(sp, vec2(1., .5));\n}\n\nray camera(vec2 uv, vec3 eye, vec3 target, float zoom) {\n  ray r;\n  r.o = eye;\n  vec3 f = normalize(target - eye);\n  //vec3 s = normalize(cross(vec3(0,1,0), f));\n  vec3 s = cross(vec3(0,1,0), f);\n  vec3 u = cross(f, s);\n  r.d = normalize(f*zoom + uv.x*s + uv.y*u);\n  return r;\n}\n\nvec2 march(ray r) {\n  float d = 0.;\n  for(int i=0; i<MAX_ITER*5; i++) {\n    float h = dist(r.o+r.d*d)*.1;\n    if(h<0.001*d || d>MAX_DIST) return vec2(d,i);\n    d+=h;\n  }\n  return vec2(d,MAX_ITER);\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 e = vec2(-0.001, 0.001);\n  return normalize(e.xyy*dist(p+e.xyy) + e.yxy*dist(p+e.yxy) + e.yyx*dist(p+e.yyx) + e.xxx*dist(p+e.xxx));\n}\n\nvec3 phong(vec3 p, material m, vec3 eye, vec3 lightPos) {\n  vec3 n = norm(p);\n  vec3 l = normalize(lightPos-p);\n  vec3 v = normalize(eye - p);\n  vec3 rf = normalize(reflect(-l, n));\n\n  vec3 diff = m.diffuse * max(0., dot(n, l));\n  vec3 spec = m.specular * max(0., pow(dot(rf, v), m.shine));\n\n  return diff + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 ruv = uv * (1.-uv);\n  float vig = pow(ruv.x*ruv.y * 15., .8);;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n  uv *= 1.+length(uv)*2.;\n\n  uv.y = abs(uv.y);\n  vec3 eye = vec3(0,1,-2);\n  eye.xz += .1*vec2(sin(cos(t*.05)*8.), cos(sin(t*.04)*12.));\n  vec3 target = vec3(0.,1.+2.*sin(t*.1),0.);\n\n  ray r = camera(uv, eye, target, .3+sin(t*.2)*.04);\n  vec2 m = march(r);\n  if(m.x > MAX_DIST) {\n    fragColor = vec4(0.);\n    return;\n  }\n\n  vec3 p = r.o+r.d*m.x;\n\n  float halo = spow(.5*m.y/float(MAX_ITER), 2.);\n\n  vec3 lightPos = vec3(3,3,-3);\n  lightPos.xz += 20.*vec2(sin(t*.25), cos(t*.5));\n\n  material mta;\n  mta.diffuse = vec3(.14, .3, .9);\n  mta.specular = vec3(1, 0, 0);\n  mta.shine = 5.;\n\n  vec3 color = phong(p, mta, eye, lightPos );\n  color *= halo*20.;\n  color = color*sat(exp(-m.y)) + color*halo;\n\n  color *= vig;\n  fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}