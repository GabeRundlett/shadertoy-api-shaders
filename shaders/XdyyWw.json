{
    "Shader": {
        "info": {
            "date": "1522156638",
            "description": "Mouse : spiral parameters\nMouse.x  : rotation\nMouse.y : warp\nMove mouse to bottom left corner for default parameters\n\nNum keys : mesh\nM : display the mesh\nF : flip spiral\nT : flip texture\nB : display bulb",
            "flags": 16,
            "hasliked": 0,
            "id": "XdyyWw",
            "likes": 7,
            "name": "Spiral orth parametrization",
            "published": 3,
            "tags": [
                "spiral",
                "orthogonal",
                "parametrization"
            ],
            "usePreview": 0,
            "username": "ABizard",
            "viewed": 786
        },
        "renderpass": [
            {
                "code": "\n// Thanks to FabriceNeyret for his help :-)\n\n#define InBLCorner(UV) (length(UV)<30.)\n\n///////\n// Default parameters for the spiral :\n// Warp\n#define DEF_BETA 1.5\n// Rotation\n#define DEF_GAMMA mod(iTime*.3,2.*PI)\n// Number of first spiral arms\n#define DEF_N 4\n///////\n\n#define MESH_THINNESS 12.\n\n//////////////////////////////////////////////\n// Keyboard controls\n\n// 'F' : flip the spiral\n#define FLIP\t\t\t\t!keyToggle(70)\n// 'T' : flip the texture\n#define FLIP_TEX\t\t\t!keyToggle(84)\n// 'M' : display the mesh\n#define DISP_MESH\t\t\t keyToggle(77)\n// 'B' : display the bulb\n#define DISP_BULB\t\t\t keyToggle(66)\n\n//////////////////////////////////////////////\n///////////////////  MAIN  ///////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = BLACK;\n    \n    // Centered normalized coordinates in [-1,1]\n    vec2 pixel = 2.*(fragCoord-floor(R.xy/4.)*2.) / R.y;\n    \n    if(FLIP)\n        pixel.y = -pixel.y;\n    \n    // Polar coords\n\tfloat rho = length(pixel),\n          theta = atan(pixel.y,pixel.x); // theta in [-PI,PI]\n    \n    \n    // Parameters of the spiral\n    float beta,\t\t// warp\n    \t  gamma;\t// rotation\n    int\t  n;\t\t// number of arms\n    \n    ///////////////////////\n    // Tuning of the parameters\n    \n    vec2 mouse = iMouse.xy;\n    bool control_by_mouse = !InBLCorner(mouse);\n    beta  =\tcontrol_by_mouse ?\n        \t\t1. + POW3(mouse.y/R.y*2.5)+.12\t: DEF_BETA;\n    gamma =\tcontrol_by_mouse ?\n        \t\t(mouse.x/R.x)*2.*PI\t\t\t\t: DEF_GAMMA;\n    \n    n = DEF_N;\n    for(int i=1;i<=9;i++)\t// Num keys to change n\n        if(keyPress(48+i) || keyPress(96+i))\n            n = i;\n\n    ///////////////////////\n    // Parameter for the orthogonal spirals\n    float beta_orth = exp(-1./log(beta));\n    \n    // Number of spirals in the orthogonal mesh\n    int n_orth = int(round(float(n)*1./log(beta)));\n    //int n_orth = 4+n;\n    \n    // Find the parametrization\n    vec2 uv_param;\n\t\n    #define PARAM(BETA,N,OFFSET) logBase(BETA,rho/(pow(BETA,theta+OFFSET)))*float(N)/(2.*PI)\n    \n    uv_param.x = PARAM(beta,n,gamma);\n    uv_param.y = PARAM(beta_orth,n_orth,0.);\n    \n    if(FLIP_TEX)\n        uv_param = uv_param.yx;\n    color = texture(iChannel0,uv_param).rgb;\n    \n    /////////////////////////\n    // Draw the white mesh\n    if(DISP_MESH){\n        float s = pow(2.,MESH_THINNESS)*rho*sqrt(rho)*log(beta);\n        #define DRAWMESH(XY) mix(color,GREY(.8),periodicDirac(uv_param.XY,1.,s))\n        color = DRAWMESH(x);\n        color = DRAWMESH(y);\n    }\n    /////////////////////////\n    \n    if(DISP_BULB){\n        #define BULB_R .2\n        float r = rho/BULB_R;\n        color = mix(color,BLACK,exp(-r*r));\n    }\n    \n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define POW2(A) ((A)*(A))\n#define POW3(A) (POW2(A)*(A))\n#define POW4(A) (POW3(A)*(A))\n\n#define PI 3.141593\n#define E 2.718282\n\n#define keyToggle(K) (texture(iChannel1,vec2((.5+float(K))/256.,0.75)).x > 0.)\n#define keyPress(K) (texelFetch(iChannel1, ivec2(K, 0), 0).x > 0.)\n\n// Trigonometric functions mapped to [0,1]\n#define NCOS(A) (cos(A)*.5+.5)\n#define NSIN(A) (sin(A)*.5+.5)\n\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define PURPLE \t\tvec3(.5,0,1)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define PINK\t\tvec3(1,.3,.7)\n#define ORANGE\t\tvec3(1.,.5,0)\n\n#define R iResolution\n\nfloat logBase(float base, float x){\n    return log(x)/log(base);\n}\n\n// Periodic function __|__|__|__|__\n// s : dirac compression\nfloat periodicDirac(float x, float period, float s){\n\treturn pow(abs(cos(x*(PI/period))),s);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}