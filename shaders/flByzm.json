{
    "Shader": {
        "info": {
            "date": "1649336846",
            "description": "Pyramid with glooing alinmation",
            "flags": 0,
            "hasliked": 0,
            "id": "flByzm",
            "likes": 8,
            "name": "Pyramid and glowing 3D ",
            "published": 3,
            "tags": [
                "glow",
                "pyramid"
            ],
            "usePreview": 0,
            "username": "electralite",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "//SOURCES :\n//Pyramid base : https://www.shadertoy.com/view/3lcGWn\n//Daugnut Tutorial base : https://www.shadertoy.com/view/7stGWj\n\nconst float PI = 3.14159265;\nconst int MAX_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 1e-6;\n\n\n//----------------------------- Pyramid ------------------------------\n//fonction barry crée les \"faces\" triangles multicolores + gamma\nvec3 bary(vec3 a, vec3 b, vec3 c, vec2 p) {\n    vec2 v0 = b.xy - a.xy, v1 = c.xy - a.xy, v2 = p - a.xy;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    vec3 bc = abs(vec3(u,v,w));\n    return bc * clamp(1.1 - floor(bc.x + bc.y + bc.z - 0.0001), 0.0, 1.0);\n}\n\n\n\n//----------------------------- Daugnut & glow ------------------------------\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, EPSILON), intensity);\t\n}\n\n//----------------------------- Camera ------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, float yAddition, float size) {\n    vec2 xy = (fragCoord - iResolution.xy / 2.0);\n    xy.y = xy.y + yAddition;\n    float z = (size * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n    vec3 zaxis = normalize(targetDir);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\n\n//-------------------------- SDF and scene ---------------------------\n//Donut rotation fonction\nvec3 rotate(vec3 p, vec4 q){\n  return (2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p + 1.0-abs(cos(iTime)/2.0));\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat torusSDF( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat getSDF(vec3 position) {\n\t//rotation avec iTime | set l'angle du donut pour le faire \"tourner\" - ca change l'angle du cercle de base sur leques les glow sont posés\n   \tfloat angle = iTime;\n    vec3 axis = normalize(vec3(1.0, 1.0, 1.0));\n    position = rotate(position, vec4(axis * sin(-angle*0.5), cos(-angle*0.5))); \n    return torusSDF(position, vec2(0.4, 0.1));\n\n}\n\n\n//---------------------------- Raymarching ----------------------------\n\n// Glow variable is passed in by reference using the keyword inout. The result written in this\n// function can be read afterwards from where it was called.\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, inout float glow, int steps, float glowIntensity) {\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = 0; i < steps; i++) {\n        \n        // Get the SDF value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir);\n        \n        // Calculate the glow at the current distance using the distance based glow function\n        // Accumulate this value over the whole view ray\n        // The smaller the step size, the smoother the final result\n        glow += getGlow(dist, 1e-3, glowIntensity);\n        \n        // If the distance is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if(dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if(depth >= end){\n            return end;\n        }\n    }\n    \n    // Return max value if we hit nothing but remain in the scene after max steps\n    return end;\n}\n\n\n//----------------------- Tonemapping and render ------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(60.0, fragCoord, 50.0, 0.5);\n    vec3 rayDir2 = rayDirection(60.0, fragCoord, 15.0, 2.5);\n    \n    //----------------- Define a camera -----------------\n\n    vec3 cameraPos = vec3(2.0);\n    \n    vec3 target = -normalize(cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, target, up);\n    \n    //---------------------------------------------------\n\n    // Transform the ray to point in the correct direction\n    rayDir = viewMatrix * rayDir;\n    rayDir2 = viewMatrix * rayDir2;\n\n    // Initialize glow to 0\n    float glow = 0.00;\n    \n    // Find the distance to where the ray stops, pass in the glow variable to be accumulated\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, glow, 64, 0.555);\n    float dist2 = distanceToScene(cameraPos, rayDir2, MIN_DIST, MAX_DIST, glow, 2, 1.0);\n    \n    // Dist can now be used to render surfaces in the scene. We will only render the glow\n  \n    vec3 glowColour = vec3(0.9, 0.1, 0.2);\n    \n    // Glow now holds the value from the ray marching\n    vec3 col = glow * glowColour;\n\n    // Tonemapping\n    col = ACESFilm(col);\n\n    // Gamma\n    col = pow(col, vec3(0.4545));\n        \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //auto rotate pyramid with sin to right/left mouvment\n    float rotateX = 3.5 * cos(iTime/2.0) - iResolution.x;\n    \n    //Define pyramid points, moving with the obj.x val\n    vec3 p1 = vec3(0.5 + sin(rotateX)       *0.25, 0.2 + cos(rotateX+PI)    *0.1, 0.5 + sin(rotateX));\n    vec3 p3 = vec3(0.5 + sin(rotateX+PI)    *0.25, 0.2 + cos(rotateX)       *0.1, 0.5 + sin(rotateX+PI));\n    vec3 p2 = vec3(0.5 + sin(rotateX+PI/2.0)*0.25, 0.2 + cos(rotateX-0.5*PI)*0.1, 0.5 + sin(rotateX+PI/2.0)*0.2);\n    vec3 p4 = vec3(0.5 + sin(rotateX-PI/2.0)*0.25, 0.2 + cos(rotateX+0.5*PI)*0.1, 0.5 + sin(rotateX-PI/2.0)*0.2);\n    vec3 p5 = vec3(0.5 , 0.8+abs((sin(iTime)/8.0)), 0.0);\n\n    //creating \"faces\" with color & gamma betweeb*n points\n    vec3 bc1 = bary(p1, p2, p5, uv);\n    vec3 bc2 = bary(p2, p3, p5, uv);\n    vec3 bc3 = bary(p3, p4, p5, uv);\n    vec3 bc4 = bary(p4, p1, p5, uv);\n    //bc5 & bc6 makes the base with 2 triangles\n    vec3 bc5 = bary(p1, p2, p3, uv);\n    vec3 bc6 = bary(p1, p4, p3, uv);\n    \n    //adding everything in fragColor to implement this into shadertoy\n\tfragColor = vec4(bc1 + bc2 + bc3 + bc4 + bc5 + bc6 + col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}