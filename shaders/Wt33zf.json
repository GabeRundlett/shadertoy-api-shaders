{
    "Shader": {
        "info": {
            "date": "1577022027",
            "description": "MDTMJVM = Middecembertomidjanuaryvember\nCheck out the other days at https://github.com/wrightwriter/Middecembertomidjanuaryvember\n\nCoding daily at http://twitch.tv/wwrighter",
            "flags": 8,
            "hasliked": 0,
            "id": "Wt33zf",
            "likes": 9,
            "name": "[Music][Twitch] Day 4 of MDTMJVM",
            "published": 3,
            "tags": [
                "music",
                "kaleidoscope",
                "polar",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 536
        },
        "renderpass": [
            {
                "code": "#define PI acos(-1.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n// from hg_sdf library. \nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n#define dmin(a,b)   (a.x < b.x) ? a : b\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    vec2 s = mainSound( in int samp, iTime );\n    vec3 col = vec3(0.);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y; \n\n    float t = mod(iTime, 18.);\n    float r = random(mod(floor(t/hbeat), 20.));\n    if (r < 0.33) {\n    \tpModPolar(uv, 6.);\n    } else if (r < 0.66){\n    \tpModPolar(uv, 8.);\n    } else{\n    \tpModPolar(uv, 4.);\n    }\n\n    vec2 d = vec2(10e3);\n    \n    uv -= normalize(uv)*pow(length(uv*1.1), 7.);\n    \n    #define pal(x) (0.5 + sin(vec3(5.8,0.3,0.8) * x)*0.9)\n    for (int i = 0; i < 60; i++) {\n    \tuv.xy *= rot(0.5*PI - t*0.1 + 0.1*mpow(sin(t), 5.) - 0.1*sin(mod(t, hbeat) + t));\n    \tuv.x -= 0.07+ pow(cos(t*0.2)*0.06, 2.);\n    \tuv.y -= 0.2 + sin(t*0.8)*0.01;\n        uv = abs(uv);\n    }\n    //d.x = min(d.x, vec2(sdBox(uv, vec2(0.1)), 1.));\n    d = dmin(d, vec2(sdBox(uv, vec2(0.1)), 1.));\n    d = dmin(d, vec2(sdBox(uv - vec2(0,0.1), vec2(0.06)), 2.));\n    d = dmin(d, vec2(sdBox(uv - vec2(0,0.2), vec2(0.1)), 3.));\n    d = dmin(d, vec2(sdBox(uv - vec2(0,0.3), vec2(0.1)), 4.));\n    //d = dmin(d, vec2(sdBox(uv - vec2(0,0.2), vec2(0.06)), 2.));\n    \n    col += vec3(smoothstep(0.001,0., d.x));\n    \n    if (d.y == 1.) {\n        col *= pal(d.y + iTime*0.1);\n\t\t//col.x = 0.;\n    } else if (d.y == 2.) {\n        col *= pal(d.y*0.2 + iTime*0.4);\n    } else {\n        col *= pal(d.y*0.7 + iTime*0.4);\n        //col = pal(0. + iTime*0.4);\n        //col = vec3(0);\n    }\n    if (length(col) < 0.4) {\n        col += pal(d.y*0.7 + iTime*0.4);\n    }\n        \n    //col.x += fract(uv.y);\n\n    col *= vec3(0.8,0.5,0.9);\n    col = pow(col, vec3(0.44));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "float mpow(float num, float times) {\n    for (float i = 0.; i < times; i++) {\n    \tnum *= num;\n    }\n    return num;\n}\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\nfloat random(float st){\n\treturn fract(sin(st*42151.5524124));\n}\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define tempo 120.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (hbeat*2.)\n\n\nfloat note(float note, float octave){\n\treturn 27.5*pow(2., ((octave*12.) + note )/12.);\n}\n\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\n\nvec2 snare(float t) {\n\tvec2 s = vec2(0);\n\tt = mod(t + hbeat, beat);\n    \n    float env = exp(-t*20.);\n    float noise = noise(vec2(t))*env;\n    //s.x += ;\n    s.x += sin((180. + env*150. + noise*20.)*tau*t )*env;\n    s.y = s.x;\n    \n    return s;\n}\nvec2 kickSecond(float t, float phase) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.));\n    float rB = random( mod(floor((t + 4.)/ hbeat), 26.));\n    \n    \n    if (rB < 0.25) {\n        r *= 4.;\n\t\tr = floor(r);\n        r += 1.;\n        float offs = hbeat * 1./r;\n        if (offs == hbeat) {\n        \toffs -= hbeat/4.;\n        }\n        t = mod(t + offs, hbeat);\n\n        float env = exp(-t*10.);\n        if (phase == 1.) {\n        \ts.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n        } else if (phase == 2.) {\n        \ts.x += sin( (240. * env+ 10. ) *tau*t) * env ;\n        \n        }\n\t\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    }\n    \n\treturn s;\n}\n\nvec2 kick (float t) {\n\tvec2 s = vec2(0);\n    \n    t = mod(t, hbeat);\n    float env = exp(-t*10.);\n    s.x += sin( (140. * env+ 10.) *tau*t) * env ;\n    s.x += sin( (random(t)) *tau*t) * env ;\n    \n    s.x = clamp(s.x*1.6,-1., 1.);\n    \n    s.y = s.x;\n\treturn s;\n}\n\nfloat arp(float t, float period, float scale) {\n\tfloat n = 0. ;\n    float r = random( mod( floor(t/period), 50.));\n    r *= 7.;\n    r = floor(r);\n    (r == 0.) ? n = note(1., 1.) :\n    (r == 1.) ? n = note(3., 1.) :\n    (r == 2.) ? n = note(4., 1.) :\n    (r == 3.) ? n = note(8., 1.) :\n    (r == 4.) ? n = note(7., 1.) :\n    (r == 5.) ? n = note(11., 2.) :\n    (r == 6.) ? n = note(8., 2.) :\n    (r == 7.) ? n = note(13., 1.) : 0.;\n    //);\n    return n;\n}\n\nvec2 synthLead (float t) {\n\tvec2 s = vec2(0);\n    \n    float note = arp(t, qnote, 1.);\n    t = mod(t,qnote);\n    float env = exp(-t*20.);\n    \n    float iterations = 5.;\n    float freq = note;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = random(i)*10.;\n    \ts.x += sin((note + r)*tau*t )*env*scale;\n    \ts.x += sin(note*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*note*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        note *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\n\nvec2 synthAmbient(float t, bool vary){\n\tvec2 s = vec2(0);\n\tfloat r = 1.;\n    if (vary) {\n    \tr = random( mod( floor(t/hbeat), 50.));\n    }\n \n    float freq = note(1., 1.);\n    if (r<0.4) {\n    \tfreq *= 1.5;\n    }\n    float iterations = 11.;\n    for (float i = 0.; i < iterations; i++) {\n    \ts.x += sin(freq*tau*t );\n        freq *= 2.01;\n    }\n    \n    freq = note(8., 2.);\n    if (r<0.4) {\n    \tfreq *= 1.5;\n    }\n    for (float i = 0.; i < iterations; i++) {\n    \ts.x += sin(freq*tau*t );\n        freq *= 2.01;\n    }\n    \n    freq = note(4., 2.);\n    if (r<0.4) {\n    \tfreq *= 1.5;\n    }\n    for (float i = 0.; i < iterations; i++) {\n    \ts.x += sin(freq*tau*t );\n        freq *= 1.01;\n    }\n    \n    s.x /= iterations*3.;\n    //s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\n\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.85, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += synthLead(t) * cf; cf *= fb; \n    s += synthLead(t) * cf; cf *= fb; \n    // tap 2\n    s += synthLead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += synthLead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += synthLead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += synthLead(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\n\nvec2 hats (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat);\n    float env = exp(-t*20.);\n    \n    float r = random(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*1500.)*4.  ) * env;\n    s.y = s.x;\n    \n    return s;\n}\n\nvec2 hatsTwo (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat/2.);\n    float env = exp(-t*50.);\n    \n    float r = random(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4.  ) * env;\n    s.y = s.x;\n    \n    return s;\n\n}\n\nvec2 bass(float t) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.));\n    float rB = random( mod(floor((t + 4.)/ hbeat), 26.));\n    if (rB < 0.33) {\n        r *= 4.;\n\t\tr = floor(r);\n        r += 1.;\n        float offs = hbeat * 1./r;\n        if (offs == hbeat) {\n        \toffs -= hbeat/4.;\n        }\n        t = mod(t + offs, hbeat);\n\n        float env = smoothstep(1., 0.,exp(-t*10.));\n        \n        float f = note(1.,0.);\n        float f2 = note(1.,1.);\n        s.x += sin(f*tau*t)*0.8;\n        s.x += sin(f2*tau*t)*0.5;\n    \ts.y += s.x;\n    }\n    return s;\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    t += beat*8.;\n    vec2 s = vec2(0);\n    bool varyAmbient = false;\n    if (t < beat*8.) {\n        varyAmbient = true;\n        vec2 ambient = synthAmbient(t, varyAmbient);\n        //s += echoChannel(t)*0.9;\n        ambient += synthAmbient(t + sin(t)*0.01, varyAmbient); // chorus\n        ambient += synthAmbient(t + sin(t*1.01 + 2.)*0.015, varyAmbient); // chorus\n    \ts += ambient*0.5;\n    \ts += kick(t);\n    \n    } else if (t < beat*16.) { \n        float tMod = mod(t,beat*8.);\n        varyAmbient = false;\n        float expMod = sin(t*20.)*exp(tMod - 5.);\n        vec2 ambient = synthAmbient(t + expMod, varyAmbient);\n        ambient += synthAmbient(t + sin(t)*0.01+ expMod, varyAmbient); // chorus\n        ambient += synthAmbient(t + sin(t*1.01 + 2.)*0.015+ expMod, varyAmbient); // chorus\n    \ts += ambient*0.5;\n        s += hats(t)*clamp(expMod,-1.,1.)*0.7;\n        s += echoChannel(t)*0.9 * clamp(expMod, -1., 1.);\n        \n    \t//s += kick(t);  \n        //s += hatsTwo(t)*0.2;\n        //s += hatsTwo(t + 0.1)*0.3* expMod;\n        //s += hatsTwo(t)* expMod;\n        //s += bass(t);\n\n        s = clamp(s, -1., 1.);\n        \n    }else if (t < beat*8.*2.) {\n        s += kickSecond(t, 1.)*1.5;\n        vec2 ambient = synthAmbient(t, false);\n        ambient += synthAmbient(t + sin(t)*0.01,  false); // chorus\n        ambient += synthAmbient(t + sin(t*1.01 + 2.)*0.015,  false); // chorus\n\n        s += snare(t)*1.5;\n        s += echoChannel(t)*0.9;\n        s += echoChannel(t + sin(t)*0.01)*0.9;\n\n        s += hats(t);\n        s += hatsTwo(t);\n        s += hatsTwo(t + 0.1)*0.3;\n\n        s += bass(t);\n\n        s *= 0.7;\n\n        s = clamp(s, -1., 1.);\n    } else {\n        s += kickSecond(t, 2.)*1.5;\n        vec2 ambient = synthAmbient(t, false);\n        ambient += synthAmbient(t + sin(t)*0.01,  false); // chorus\n        ambient += synthAmbient(t + sin(t*1.01 + 2.)*0.015,  false); // chorus\n\n        s += snare(t)*1.5;\n        s += echoChannel(t)*0.9;\n        s += echoChannel(t + sin(t)*0.01)*0.9;\n\n        s += hats(t);\n        s += hatsTwo(t);\n        s += hatsTwo(t + 0.1)*0.3;\n\n        s += bass(t);\n\n        s *= 0.7;\n\n        s = clamp(s, -1., 1.);\n    }\n\n    \n    return s;\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0* (mod(time, beat)) ) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}