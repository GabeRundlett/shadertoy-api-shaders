{
    "Shader": {
        "info": {
            "date": "1589149403",
            "description": "attempt to put voronoi on sphere",
            "flags": 0,
            "hasliked": 0,
            "id": "WdXBWf",
            "likes": 2,
            "name": "Voronoi on sphere attempt",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "Veggiebob",
            "viewed": 576
        },
        "renderpass": [
            {
                "code": "#define E 0.001\n#define balls 30\nstruct RayHit {\n    vec3 end;\n    float dist;\n    int steps;\n};\nvec2 rotate2D (vec2 p, float angle) {\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\n//most random stuff stolen from https://www.shadertoy.com/view/wdffWj\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) {\n    seed = s;\n}\nint rand(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\n// --------------------------------------\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec3 randomOnSphere( void ) {\n    float theta = (6.283185 / 32767.0) * float(rand());\n    float u = (2.0 / 32767.0) * float(rand()) - 1.0;\n    return vec3(sqrt(1.0 - u * u) * vec2(cos(theta), sin(theta)), u);\n}\nvec3 randomUnitSphere (int t) {\n    return (vec3(\n        hash(t),\n        hash(t+8),\n        hash(t+10)\n       ) - 0.5\n    );\n}\nfloat sphere (vec3 p, float radius) {\n    return length(p) - radius;\n}\nfloat shell (float sdf, float thickness) {\n    return abs(sdf) - thickness / 2.;\n}\nfloat hollowSphere (vec3 p, float outerRadius, float thickness) {\n    //return abs(sphere(p, outerRadius - thickness / 2.)) - thickness / 2.;\n    return shell(sphere(p, outerRadius - thickness / 2.), thickness);\n}\nfloat comp (vec3 a, vec3 b) {\n    return dot(a, b) / length(b);\n}\nfloat voronoi (vec3 p) {\n    float vdist = 1000.;\n    float last_dist = vdist;\n    vec3 point = vec3(0.);\n    vec3 last_point = vec3(0.);\n    for (int i = 0; i<balls; i++) {\n        vec3 pos = 1.0 * normalize(randomUnitSphere(i));\n        float newDist = length(p-pos);\n        if (newDist < vdist) {\n            last_dist = vdist;\n            last_point = point;\n       \t\tvdist = newDist;\n            point = pos;\n        } else if (newDist < last_dist) {\n            last_dist = newDist;\n            last_point = pos;\n        }\n    }\n    //see https://www.shadertoy.com/view/3sfBDf\n    /*\n    float max_dist = length(point - last_point) / 2.;\n    float dist = comp2(uv-point, last_point - point);\n    float h = max_dist - dist;\n    float hp = h / max_dist;\n    vec3 col = vec3(smoothstep(0.0, 0.01, h));\n*/\n    float max_dist = length(point - last_point) / 2.;\n    float dist = comp(p-point, last_point-point);\n    float vd = abs(max_dist - dist);\n    return vd;\n}\nfloat sdf (vec3 p) {\n    float d = 10000.;\n    \n    float thickness = 0.03;\n    float radius = 0.7;\n    float wall_dist = voronoi(p) - 0.03;\n        //-sphere(p-point * (radius-thickness/2.), thickness*2.);\n    float hollow_sphere = \n        //abs(p.x) - 0.1;\n        hollowSphere(p, radius, thickness);\n   \td = min(d, max(wall_dist, hollow_sphere));\n    d = min(p.y - length(sin(p.xz * 2.)) * 0.2 + 2.5, d);\n    return d;\n}\nRayHit raymarch (vec3 origin, vec3 ray) {\n    vec3 p = origin;\n    int steps = 0;\n    float dist = 0.;\n    for (int i = 0; i<64; i++) {\n        p = origin + ray * dist;\n        float d = sdf(p);\n        dist += d * 0.8;\n        steps ++;\n    }\n    return RayHit(p, dist, steps);\n}\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z))-sdf(vec3(p.x-E, p.y, p.z)),\n        sdf(vec3(p.x, p.y+E, p.z))-sdf(vec3(p.x, p.y-E, p.z)),\n        sdf(vec3(p.x, p.y, p.z+E))-sdf(vec3(p.x, p.y, p.z-E))\n    ));\n}\nvec3 getRay (vec3 cam, vec3 focusPoint, vec3 UP, float xFOV, float yFOV, vec2 uv) {\n    vec3 forward = normalize(focusPoint - cam);\n    vec3 right = cross(forward, UP);\n    vec3 up = cross(right, forward);\n    vec3 down = -up;\n    vec3 left = -right;\n    right = normalize(mix(forward, right, xFOV));\n    left = normalize(mix(forward, left, xFOV));\n    up = normalize(mix(forward, up, yFOV));\n    down = normalize(mix(forward, down, yFOV));\n    return normalize(mix(left, right, uv.x) + mix(down, up, uv.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 realUV = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    float aspect = iResolution.y / iResolution.x;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    uv.x-=iResolution.x/iResolution.y/2.;\n    uv.y-=0.5;\n    uv*=2.0;\n    float perspective = 0.8;\n    vec3 cam = vec3(1., 0., 0.);\n    cam.xy = rotate2D(cam.xy, -mouse.y*5.0);\n    cam.xz = normalize(rotate2D(cam.xz, mouse.x*10.0));\n    cam.y = clamp(cam.y, -0.8, 0.8);\n    cam *= 2.;\n    \n    float fov = 0.8;\n    vec3 ray = getRay(cam, vec3(0.), vec3(0., 1., 0.), fov, fov * aspect, realUV);\n    \n    RayHit hit = raymarch(cam, ray);\n    vec3 normal = estimateNormal(hit.end);\n    \n    vec3 col = vec3(1.0);\n    vec3 ambient = vec3(0.5);\n    vec3 lightDir = normalize(vec3(1.0));\n    vec3 lightCol = vec3(1.0);\n    float diffuse = max(dot(normal, lightDir), 0.);\n    float specular = pow(max(dot(reflect(ray, normal), lightDir), 0.), 4.);\n   \tvec3 outCol = col * ambient + lightCol * (diffuse * 0.3 + specular * 0.2);\n    //if (hit.dist > 10.) outCol = vec3(0.);\n    outCol *= 1. / (1. + 0.01 * pow(hit.dist, 2.));\n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}