{
    "Shader": {
        "info": {
            "date": "1580142211",
            "description": "fork of pimp that ass by makc\noriginal here: https://www.shadertoy.com/view/WtV3Wc",
            "flags": 0,
            "hasliked": 0,
            "id": "3ty3Dd",
            "likes": 22,
            "name": "PimpThatAss2",
            "published": 3,
            "tags": [
                "sdf",
                "animated",
                "distance",
                "parametric"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 2068
        },
        "renderpass": [
            {
                "code": "// fork of pimp that ass - https://www.shadertoy.com/view/WtV3Wc - added jiggle anim + various other tweaks :)\n// basically a combination of:\n// - https://mathematica.stackexchange.com/a/66564 by Nikolai Mikuszeit\n// - https://www.shadertoy.com/view/Ws3SDl by Inigo Quilez\n\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\t\n    float jiggle = p.z*1.75;\n    float jsize = 0.5;\n    if (iMouse.z>0.5)\n    {\n        jiggle+=p.y*.5;\n        jsize+=.175;\n    }\n    \n\tdx *= 1.5+(sin(jiggle+iTime*9.65)*jsize);\n\t\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n//\tfloat d1 = (.5 + .5 * smoothstep(.4,1.,p.z)) * (length(vec2(p.y, p.x - dx)) - r_expected);\n\tfloat d1 = (length(vec2(p.y, p.x - dx)) - r_expected)*0.5;\n    \n    p.x -= dx;\n\tfloat d2 = sdSphere(p+vec3(-0.35,0.4,-1.875),0.4);\n\tfloat d3 = sdSphere(p+vec3(-0.35,-0.4,-1.875),0.4);\n    d2 = smin(d2,d3,0.35);\n    return smin(d1,d2,0.07);\n    //return min(d1,min(d2,d3));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = sin(iTime+2.15)*0.7;\t//0.5*iTime - 0.8;\n    if (iMouse.z>0.5)\n        an+=iMouse.x/(iResolution.x*0.25);\n    //an+=3.14;\n    \n\tvec3 ro = vec3( 2.55*sin(an), 0.5, -2.55*cos(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    \n    vec2 p1 = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float val = sin(iTime+p1.x+p1.y*20.0)*(0.8+sin(p1.y+iTime*3.0)*0.3);\n    val = clamp(val,0.0,2.0);\n    vec3 bcol = vec3(val,val*0.2,val*0.1);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        vec3 col = bcol;\n        // raymarch\n        if (abs(p.x)<0.8)\n        {\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n            \n            const float tmax = 5.0;\n            float t = 0.0;\n            for( int i=0; i<150; i++ )\n            {\n                vec3 pos = ro + t*rd;\n                float h = map(pos);\n                if( h<0.0001 || t>tmax ) break;\n                t += h;\n            }\n            // shading/lighting\t\n            if( t<tmax )\n            {\n                vec3 pos = ro + t*rd;\n                vec3 nor = calcNormal(pos);\n                float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n                float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n                col = vec3(0.3,0.15,0.1)*amb + vec3(0.8,0.5,0.2)*dif;\n                col += pow(dif,16.0);\n            }\n        }\n\n        // gamma        \n        //col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    // gamma        \n    tot = sqrt( tot );\n    \n   tot *= 1.0 - 0.2*dot(p1,p1);\t\t// vignette\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}