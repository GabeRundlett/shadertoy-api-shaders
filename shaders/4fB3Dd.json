{
    "Shader": {
        "info": {
            "date": "1704782402",
            "description": "Shows the amount of light reflected when a ray transitions from water to air.\nThe extremely-subtly-shaded dark circle shows almost no reflection inside Snell's Window,\nand the white area is total internal.  Has Gamma Correction. FOV = 100ยบ.",
            "flags": 0,
            "hasliked": 0,
            "id": "4fB3Dd",
            "likes": 3,
            "name": "Snell's Window Study",
            "published": 3,
            "tags": [
                "refraction",
                "study",
                "optics"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "/*\n\nPixel intensity is the (gamma-adjusted)\namount of light reflected when a ray\ntransitions from water to air.\nIt's a direct visualization of the amount of reflection,\nthere's no actual reflection.\nIf you look very closely at the darkness in the middle\nyou can see a faint increase of reflection\nas the ray gets farther from the center.\n\nI was feeling that the \"Snell's Window\" effect\nin my refraction shaders was too dramatic,\nie, that too little light was reflected inside the window,\nbut looking at photographs of the effect it seems\nlike that might be right.\neg: https://upload.wikimedia.org/wikipedia/commons/7/77/US_Navy_110607-N-XD935-191_Navy_Diver_2nd_Class_Ryan_Arnold%2C_assigned_to_Mobile_Diving_and_Salvage_Unit_2%2C_snorkels_on_the_surface_to_monitor_multi.jpg\n\nThe short side of the shader is 100ยบ FOV.\nSo they say Snell's Window is about 96ยบ for water -> air,\nso that part of things are looking right, at least.\n\n\n\n*/\n\nconst float gZoom       = 1.0;\n      vec2  gM;         // set in main\n      \nfloat sqr(float a) {\n    return a * a;\n}\n\nfloat pow5(float a) {\n    float b;\n    b  = a;  // b = a    \n    b *= b;  // b = a^2\n    b *= b;  // b = a^4\n    b *= a;  // b = a^5\n    return b;\n}\n\n      \n// A modified Schlick's approximation to Fresnel's eqn's.\n// where reflectamount -> 0 as n2 -> n1.\nfloat elenzilsApproximation(float n1, float n2, float incidentDotNormal) {\n    // from https://en.wikipedia.org/wiki/Schlick%27s_approximation \n    float R0 = sqr((n1 - n2) / (n1 + n2));\n    float R  = R0 + (1.0 - R0) * pow5(1.0 - incidentDotNormal);\n\n    // Schlick's approximation seems invalid when n1 ~= n2.\n    // Compensate with an additional fudge.\n    // https://physics.stackexchange.com/q/794963\n    float ndiffSqr      = sqr(n1 - n2);\n    float elenzilFudge  = ndiffSqr / (ndiffSqr + 0.01);\n    R                  *= elenzilFudge;\n\n    return R;\n}\n\n\nfloat reflectionAmount(\n    in vec3  incident,\n    in vec3  normal,\n    in float n1,\n    in float n2)\n{\n    float reflectAmt = elenzilsApproximation(n1, n2, dot(incident, -normal));\n    \n    // check for total internal reflection.\n    float eta     = n1 / n2;\n    vec3 vTransmit = refract(incident, normal, eta);\n    if (dot(vTransmit, vTransmit) == 0.0) {\n        // total internal\n        reflectAmt = 1.0;\n    }\n    \n    float transmitAmt = 1.0 - reflectAmt;\n    \n    if (iMouse.z > 0.0) {\n        return transmitAmt;\n    }\n    else {\n        return reflectAmt;\n    }\n}\n\nvec3 render(in vec2 viewPos) {\n\n    float FOV = 100.0 / 360.0 * pi;\n\n    vec3  rd         = normalize(vec3(viewPos * tan(FOV), 1.0));\n    \n    // shooting a ray from water into air\n    vec3  normal     = -vZ;\n    float n1         = 1.33;\n    float n2         = 1.0;\n    float reflection = reflectionAmount(rd, normal, n1, n2);\n    \n    return v1 * reflection;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 p    = VIEWFROMSCREEN(XY);\n    \n    RGBA.rgb  = render(p);\n    \n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}