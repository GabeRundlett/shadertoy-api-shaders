{
    "Shader": {
        "info": {
            "date": "1709614336",
            "description": "Playing around with some ideas.",
            "flags": 0,
            "hasliked": 0,
            "id": "slcSDN",
            "likes": 21,
            "name": "Torus mf",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "milkfat",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "#define SCREEN_D -1200.0\n#define LIGHT rot(vec3(1000,1000,1000))\n#define RADIUS 2500.0\n//#define AA\n\n#define GLOW_HEIGHT 30.0\n#define GLOW_SHARPNESS 2.0\n\nconst vec2 u = vec2(.1,0);\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\n\nvec2 irotate(vec2 p, float a) {return rotate(p, -a);}\n\nfloat ang_between(vec2 a, vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,a.x*b.x+a.y*b.y);\n}\n\nfloat hash(float p) {\n   // p=isnan(p)?0.0:p;\n    p=fract(p*.917331);\n    uint b = uint(p*123456.7);\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn fract(abs(float(b)/1000000.0));\n}\n\nvec3 iproject(vec3 p)\n{\n    p.xy -= iResolution.xy/2.0; //center coordinates\n    p.xy /= iResolution.y/675.0; //scale according to screen height\n    p.xy *= (SCREEN_D+(p.z-2000.0));\n    p.xy /= (SCREEN_D);\n    if (iMouse.xy == vec2(0)) return p;\n    //mouse control\n    p.z += 8000.0;\n    p.yz =  irotate(p.yz, 4.0*sin((iResolution.y/2.0 - iMouse.y)/iResolution.y));\n    p.xz =  irotate(p.xz, 4.0*sin((iResolution.x/2.0 - iMouse.x)/iResolution.x));\n    //p.xy = irotate(p.xy, -iTime*.3);\n    p.z -= 8000.0;\n    return p;  \n}\n\nvec3 rot(vec3 p)\n{\n    if (iMouse.xy == vec2(0)) return p;\n    p.z += 8000.0;\n    p.yz =  irotate(p.yz, 4.0*sin((iResolution.y/2.0 - iMouse.y)/iResolution.y));\n    p.xz =  irotate(p.xz, 4.0*sin((iResolution.x/2.0 - iMouse.x)/iResolution.x));\n    //p.xy = irotate(p.xy, -iTime*.3);\n    p.z -= 8000.0;\n    return p;\n}\n\nfloat lookup_height(vec2 angs, inout float col, float len)\n{\n    angs/=3.14159*2.0;\n    angs.x*=8.0;\n    angs=mod(angs,1.0);\n    vec2 id = floor(angs*16.0);\n    angs = mod(angs*16.0,1.0)/16.0;\n    vec2 angs2 = angs*16.0;\n    angs.xy+=floor(vec2(hash(id.x+id.y*17.3),hash(id.y+id.x*16.1))*16.0)/16.0; //select a random cell\n    \n    float v = texture(iChannel0,angs,1.0).r;\n    float v2 = texture(iChannel1,angs,1.0).r;\n    \n    float v3 = texture(iChannel0,angs,1.0+clamp(len/GLOW_HEIGHT,0.0,1.0)*GLOW_SHARPNESS).r;\n    if(min(abs(angs2.x),abs(angs2.y))<.03 || max(abs(angs2.x),abs(angs2.y))>.97)\n    {\n        v3=0.0;\n        //v=0.0;\n    }\n    col += v3*.2*clamp(1.0-len/GLOW_HEIGHT,0.0,1.0); //LEFT OFF HERE Dec 9th, 2021\n    return v*20.0 + (1.0-v)*v2*3.;\n}\n\nfloat twisted_torus(vec3 p, float a, inout vec2 angs, inout float col)\n{\n    float time = a+mod(iTime,3.14159*2.0);\n    float ang = atan(-p.y,p.x); //our current angle\n    float angb = ang+.01;\n    vec3 p2 = p;\n    p.xy = rotate(p.xy,ang); //sweep a torus\n    p2.xy = rotate(p2.xy,angb);\n    \n    //return early\n    float test = distance(p,vec3(RADIUS,0,-8000));\n    if(test>1600.0)return test*.7;\n    \n    vec3 pp = p;\n    vec3 pp2 = p2;\n    pp.z += sin(ang*3.0+time)*430.0; //modify z based on angle\n    pp2.z += sin(angb*3.0+time)*430.0;\n    pp.x += cos(ang*3.0+time)*430.0; //modify radius based on angle\n    pp2.x += cos(angb*3.0+time)*430.0;\n    \n    vec2 v1 = p2.xy-p.xy;\n    vec2 v2 = pp2.xy-pp.xy;\n    float ang3 = ang_between(v1,v2);\n    \n    vec2 v11 = p2.zy-p.zy;\n    vec2 v22 = pp2.zy-pp.zy;\n    float ang4 = ang_between(v11,v22);\n    \n    pp.x-=RADIUS;\n    pp.xy = rotate(pp.xy,ang3); //adjust for x-axis distortion\n    pp.z+=8000.0;\n    pp.zy = rotate(pp.zy,ang4); //adjust for z-axis distortion\n    \n    //figure out UV coordinates\n    vec2 prr = pp2.xy-pp.xy;\n    float angrr = atan(prr.y,-prr.x);\n    angs.x = ang+angrr;\n    angs.y = -atan(pp.z,pp.x)-angrr; \n    \n    float col_amount = 0.0;\n    float len = length(pp.xz)-380.0; //thread radius\n    float height = lookup_height(angs.xy,col_amount,len);\n    \n    if(len < GLOW_HEIGHT) col+=col_amount;\n    \n    float d = len+height;\n    \n    col*=1.0-clamp(d/GLOW_HEIGHT,0.0,1.0);\n    \n    return d; \n}\n\n\nvec2 scene(vec3 p, inout vec2 angs, inout vec3 vals, inout vec3 col)\n{\n    vec2 o;\n    vec2 angs1;\n    float d1 = twisted_torus(p,0.,angs1, col.b); //phase, overall radius, z coordinate\n    //angs=angs1;\n    //return vec2(d1-400.0,0);\n    vec2 angs2;\n    float d2 = twisted_torus(p,2.,angs2, col.g);\n    vec2 angs3;\n    float d3 = twisted_torus(p,4.,angs3, col.r);\n    vals = vec3(d1,d2,d3);\n    \n    o.x = min(d1,d2);\n    o.y = (o.x==d1)?0.0:2.;\n    angs = (o.x==d1)?angs1:angs2;\n    o.x = min(o.x,d3);\n    o.y = (o.x==d3)?4.1:o.y;\n    angs = (o.x==d3)?angs3:angs;\n    return o;   \n}\n\nvec4 pixel(vec2 C)\n{\n    vec4 F = vec4(0);\n    vec3 p = iproject(vec3(C, -2000));\n    vec3 p2 = iproject(vec3(C, -10000));\n    vec3 ps = normalize(p2-p);\n    \n    float travel = 0.0;\n    vec2 scn;\n    vec2 angs;\n    vec3 vals;\n    vec3 glow_col = vec3(0);\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 gc = vec3(0);\n        scn =  scene(p,angs,vals,gc);\n        glow_col+=gc*(scn.x*.7)/20.0;\n        travel += scn.x*.7;\n        p += ps*scn.x*.7;\n        if(scn.x<1.1 || travel > 12000.0) break;\n        //if(travel > 12000.0 ) return vec4(glow_col*100.0,0);\n        \n    }\n    vec2 angs2;\n    vec3 vals2;\n    vec3 nothing;\n    vec3 norm = normalize(vec3(scene(p+u.xyy,angs2,vals2,nothing).x-scene(p-u.xyy,angs2,vals2,nothing).x, scene(p+u.yxy,angs2,vals2,nothing).x-scene(p-u.yxy,angs2,vals2,nothing).x, scene(p+u.yyx,angs2,vals2,nothing).x-scene(p-u.yyx,angs2,vals2,nothing).x));\n    vec3 col = vec3(1);\n    \n    //normalize UV\n    angs/=3.14159*2.0;\n    vec2 orig_angs = mod(angs,1.0);\n    angs.x*=8.0;\n    angs=mod(angs,1.0);\n    \n    vec3 c2 = texture(iChannel1,angs.xy).xyz; //read surface texture\n    \n    //randomize our letters\n    vec2 id = floor(angs.xy*16.0); //quantize UV into 16x16 grid\n    vec2 uv_t = mod(angs*16.0,1.0);\n    angs=mod(angs*16.0,1.0)/16.0;  //relative UV inside a cell\n    angs+=floor(vec2(hash(id.x+id.y*17.3),hash(id.y+id.x*16.1))*16.0)/16.0; //select a random cell\n\n    vec3 c1 = texture(iChannel0,angs.xy).xyz;\n    \n    if(uv_t.x<.03 || uv_t.y<.03 || uv_t.x>.97 || uv_t.y>.97) {c1 = vec3(0);} // workaround for mipmap weirdness (grid effect around letters)\n    col = c2*.2*(1.0-c1.r);\n    col=clamp(col,0.0,4.0);\n    \n    \n    float bri = dot(norm,normalize(LIGHT-p));\n    float spec = pow(bri,100.0)*.4*(1.0-c1.r)*c2.r;\n    float ld = distance(LIGHT,p) * .000010;\n    bri = clamp(bri*(1.0/(ld*ld+1.0)),0.0,1.0)*.5;\n    \n    vals = clamp((800.0-vals)/800.0,0.0,1.0);\n    \n    //ambient occlusion\n    bri*=(scn.y==4.1)?min(1.0-vals.x,1.0-vals.y):(scn.y==2.0)?min(1.0-vals.x,1.0-vals.z):(scn.y==0.0)?min(1.0-vals.z,1.0-vals.y):1.0;\n    if(scn.x<11.1)\n    {\n        F = vec4(col*bri*c2.r,1.0);\n    }\n    \n    //letter color\n    float lp1 = floor(orig_angs.y*16.0)/16.0;\n    float lp2 = floor(orig_angs.x*8.0*16.0)/(8.0*16.0);\n    lp2 = int(lp1*16.0)%2==0?lp2:1.0-lp2; //reverse every other row\n    //lp2 = mod(lp2*2.0,1.0);\n    if(scn.x<11.1)\n    {\n        F.r += c1.r*float(scn.y==4.1)*pow(mod(mod(lp1*21.0,1.0) + lp2-iTime*(.15+lp1*.15)*2.0,1.0),4.0);\n        F.g += c1.r*float(scn.y==2.0)*pow(mod(mod(lp1*10.0,1.0) + .33+lp2-iTime*(.15+lp1*.15)*2.0,1.0),4.0);\n        F.b += c1.r*float(scn.y==0.0)*pow(mod(mod(lp1*11.0,1.0) + .66+lp2-iTime*(.15+lp1*.15)*2.0,1.0),4.0);\n        F.r += glow_col.r*float(scn.y==4.1)*pow(mod(mod(lp1*21.0,1.0) + lp2-iTime*(.15+lp1*.15)*2.0,1.0),4.0);\n        F.g += glow_col.g*float(scn.y==2.0)*pow(mod(mod(lp1*10.0,1.0) + .33+lp2-iTime*(.15+lp1*.15)*2.0,1.0),4.0);\n        F.b += glow_col.b*float(scn.y==0.0)*pow(mod(mod(lp1*11.0,1.0) + .66+lp2-iTime*(.15+lp1*.15)*2.0,1.0),4.0);\n    }\n    \n    //specular\n    if(scn.x<11.1)\n    {\n        F+=spec;\n    }\n    \n    //ambient color\n    if(scn.x<11.1)\n    {\n        float peep = clamp(dot(-ps, norm),0.0,1.0)*.3;\n        F.r += c2.r*float(scn.y!=4.1)*vals.z*peep*.035;\n        F.g += c2.g*float(scn.y!=2.0)*vals.y*peep*.025;\n        F.b += c2.b*float(scn.y!=0.0)*vals.x*peep*.05;\n    }\n    return F;\n}\n\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    F=vec4(0);\n    F += pixel(C+vec2(.0,.0));\n    #ifdef AA\n    F += pixel(C+vec2(.5,.0));\n    F += pixel(C+vec2(.0,.5));\n    F += pixel(C+vec2(.5,.5));\n    F/=4.0;\n    #endif\n    F = pow(F, vec4(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}