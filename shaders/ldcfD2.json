{
    "Shader": {
        "info": {
            "date": "1526755755",
            "description": "Taken from the 64k intro DÃ¶dens Triumf by OJ\nYoutube: https://www.youtube.com/watch?v=9_UBJuamDIw\nPouet: http://www.pouet.net/prod.php?which=76111\n",
            "flags": 32,
            "hasliked": 0,
            "id": "ldcfD2",
            "likes": 13,
            "name": "Spooky Corridor",
            "published": 3,
            "tags": [
                "3d",
                "postprocessing",
                "patterns"
            ],
            "usePreview": 0,
            "username": "rammoskar",
            "viewed": 888
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n\tfragColor = texture(iChannel0, uv);\n\n    vec2 dir = normalize(uv - vec2(0.5));\n    float l = length(vec2(0.5) - uv);\n\n    fragColor.g = texture(iChannel0, uv + dir * 0.01*l).g;\n    fragColor.b = texture(iChannel0,  uv + dir * 0.02*l).b;\n\n\tfragColor.rgb *=  0.7 + 0.3*clamp(sin(uv.y*1000.0) + 0.8, 0.0, 1.0);\n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Uses some iq functions and patterns from https://www.shadertoy.com/view/4dfyzf\n\n#define PART_TWIST 15.0\n#define PART_END (PART_TWIST + 20.0)\n\n#define PI 3.141592\n\n#define TIME mod(iTime, PART_END + 4.0)\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n#define MAT_FLOOR 1.0\n#define MAT_ROOF 2.0\n#define MAT_CORRIDOR 3.0\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\n\nfloat hash( in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noiseOctave(in vec2 p, int octaves, float persistence)\n{\n\tfloat n = 0.;\n\tfloat amplitude = 1.;\n\tfloat frequency = 1.;\n\tfloat maxValue = 0.;\n\n\tfor(int i = 0; i < octaves; i++)\n\t{\n\t\tn += noise((p+float(i)) * frequency) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= persistence;\n\t\tfrequency *= 2.0;\n\t}\n\treturn n / maxValue; \n}\n\n\n\n\nfloat BrickPattern(in vec2 p) \n{\n  p *= vec2 (1.0, 2.8);\n  vec2 f = floor (p);\n  if (2. * floor (f.y * 0.5) != f.y) \n    p.x += 0.5;\n  p = smoothstep (0.03, 0.08, abs (fract (p + 0.5) - 0.5));\n  return 1. - 0.9 * p.x * p.y;\n}\n\n\nfloat GridPattern(in vec2 uv)\n{\n  return 0.5*clamp(10.*sin(PI*uv.x) + 10.5, 0.0, 1.0)\n       / 0.5*clamp(10.*sin(PI*uv.y) + 10.5, 0.0, 1.0);\n}\n\nfloat SquareHolePattern(in vec2 uv)\n{\n  float thickness = 0.4;\n  float t = cos(uv.x*2.0) * cos(uv.y*2.0) / thickness;\n  return smoothstep(0.1, 0.0, t*t);\n}\n\n\nfloat floorPattern(vec2 p) {\n\t return SquareHolePattern(p*7.2 - vec2(0.0, 0.0));\n}\n\nfloat roofPattern(vec2 p) {\n\treturn GridPattern(p*5.0);\n}\n\nfloat corrNoise(vec3 p){\n\treturn 0.4*noiseOctave(vec2(p.z, abs(p.y) > 0.95 ? p.x : p.y) * 25.0, 3, 1.0);\n}\n\nvec3 distort(vec3 p) {\n\tif (TIME > PART_TWIST) {\n\t\tfloat a = atan(p.y, p.x);\n\t\tfloat l = length(p.xy);\n\t\ta += (p.z - PART_TWIST)*0.2*smoothstep(PART_TWIST + 5.0, PART_TWIST + 10.0, TIME);\n\t\ta -= (p.z - PART_TWIST)*0.2*smoothstep(PART_TWIST + 10.0, PART_TWIST + 15.0, TIME);\n\t\treturn vec3(cos(a) * l, sin(a) * l, p.z);\n\t}\n\n\treturn p;\n}\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k, inout float h)\n{\n    h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(vec3 p, vec3 rd) \n{\n\tp = distort(p);\n\t\n\tfloat pattern = BrickPattern(p.zy * 2.1 + vec2(0.0, 0.0));\n\tfloat n = corrNoise(p);\n\tfloat dc = -sdBox(p - vec3(sign(p.x)*pattern * 0.02-n*0.05*sign(p.x), 0.0, 0.0), vec3(1.4, 10.0, 5000.0));\n\tvec2 res = vec2(dc, MAT_CORRIDOR);\n\n\tfloat fPattern = floorPattern(p.xz);\n\tres = un(res, vec2(p.y + 1.0 + fPattern*0.01  - n*0.03, MAT_FLOOR));\n\t\n\tfloat rPattern = roofPattern(p.xz);\n\tres = un(res, vec2(-p.y + 1.0 -rPattern * 0.03 - n*0.01, MAT_ROOF));\n\t\n\tif (TIME > PART_TWIST) {\n\t\tvec3 sp = p;\n\t\tfloat s = 5.0;\n\t\tsp.z = mod(p.z + s*0.5, s) - s*0.5;\n\t\t\n\t\tfloat rr = p.z;\n\t\tvec2 rs = vec2(cos(rr)*p.x + sin(rr)*p.y ,sp.z);\n\t\tfloat r = 0.1 + 0.3*(1.0 - smoothstep(0.0, 0.6, length(p.xy))) * (0.5 + 0.5 * sin(TIME* 5.0));\n\t\tfloat d = length(rs - vec2(0, 1.5)) - r;\n\n\t\tfloat h = -1.0;\n\t\td = smink(d, res.x, 0.5, h);\n\t\tres.x = d;\n\t\tres.y += h*0.5;\n\t}\n\t\n\treturn res;\n}\n\nvec3 lightAModifyPos(vec3 p)\n{\n\tfloat s = 5.0;\n\tp.z = mod(p.z + s*0.5, s) - s * 0.5;\n\treturn p - vec3(0.0, 0.75, 0.0);\n}\n\nvec4 lightA(vec3 p, vec3 realp)\n{\n\tfloat dis = sdCappedCylinder(p.zxy, vec2(0.0, 0.3));\n\tvec3 col = vec3(1.0, 0.6, 0.6);\n\tfloat strength = 1.0;\n\tint q = int((realp.z + 2.5) / 5.0);\n\tif (TIME*4.0 +  float(q) *5.0 > 60.0 && TIME <= PART_TWIST) {\n        col = vec3(0.0, 1.0, 0.2);\n        strength = smoothstep(0.0 + 1.0, 0.0 + 2.0 + 1.0, TIME);\t\t\n\t}\n\tif (TIME > PART_END) {\n\t\tfloat m = (1.0 - (TIME - PART_END - 4.0));\n\t\tm = clamp(m, 0.0, 1.0);\n\t\tstrength *= m;\n\t}\n\tvec3 res = col * strength / (dis * dis * dis);\n\treturn vec4(res, dis);\n}\n\nvec4 lightUnion(vec4 a, vec4 b)\n{\n\treturn vec4(a.rgb + b.rgb, min(a.w, b.w));\n}\n\nvec4 evaluateLight(vec3 pos)\n{\n\tpos = distort(pos);\n\tvec4 res = lightA(lightAModifyPos(pos), pos);\n\treturn res;\n}\n\nfloat shadowFunction(in vec3 ro, in vec3 rd, float mint, float maxt)\n{\n    float t = 0.1;\n    for(float _ = 0.0; _ == 0.0; _ += 0.0)\n    {\n        if (t >= maxt) {\n        \treturn 1.0;\n        }\n        float h = map(ro + rd*t, rd).x;\n        if( h<0.01 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid addLight(inout vec3 diffRes, inout float specRes, vec3 normal, vec3 eye, vec3 lightPos, vec3 lightCol, float shadow, vec3 pos)\n{\n\tvec3 col = vec3(0.0);\n\tvec3 invLight = normalize(lightPos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 100.0);\n\tfloat dis = length(lightPos - pos);\n\tfloat str = 1.0/(0.5 + 0.01*dis + 0.1*dis*dis);\n\tfloat specStr = 1.0/(0.0 + 0.00*dis + dis*dis*dis);\n\tdiffRes += diffuse * lightCol * shadow;\n\t\n\tspecRes += spec  *  shadow  * 1.0 * length(lightCol);\n}\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\tvec3 diffuse = vec3(0.0);\n\tfloat specular = 0.0;\n\tconst float ambient = 0.0;\n\n\t{\n\t\tvec3 dp = distort(pos);\n\t\tvec3 posLightOrigo = lightAModifyPos(dp);\n\t\t\n\t\tfloat s = 5.0;\n\t\tint q = int(round(dp.z / s));\n\t\tvec3 lightPos = distort(vec3(0.0, 0.8, float(q)*s)); \n\t\tvec3 dir = lightPos - pos;\n\t\tfloat shadow = 1.0;\n\t\taddLight(diffuse, specular, normal, eye, lightPos, lightA(posLightOrigo, pos).rgb, shadow, pos);\n\t}\n\tcolor = color * (ambient + diffuse) + specular;\n}\n\nvec3 getNormal(vec3 p, vec3 rd)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz, rd).x - map(p - ep.xyz, rd).x;\n    normal.y = map(p + ep.yxz, rd).x - map(p - ep.yxz, rd).x;\n    normal.z = map(p + ep.yzx, rd).x - map(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\nfloat occlusion(vec3 p, vec3 normal, vec3 rd)\n{\n\tfloat o = clamp(2.0*map(p + normal * 0.5, rd).x, 0.0, 1.0);\n\treturn 0.8 + 0.2*o;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, vec3 eye) \n{\n\tint maxIter = 300;\n\tconst float maxDis = 200.0;\n\tconst int jumps = 2;\n\n\tvec3 col = vec3(0);\t\n\tfloat ref = 1.0;\n\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tfor (int j = 0; j < jumps; j++) {\n\t\tif (j == 1) {\n\t\t\tmaxIter = 10;\n\t\t}\n\t\tfloat t = 0.0;\n\t\tfor (int i = 0; i < maxIter; i++) {\n\t\t\tvec3 p = ro + rd * t;\n\t\t\tvec2 res = map(p, rd);\n\t\t\tfloat d = res.x;\n\t\t\tfloat m = res.y;\n\n\t\t\tfloat fogAmount = 0.001;\n\n\t\t\tint q = int((p.z + 2.5) / 5.0);\n            if (TIME < PART_TWIST) {\n                fogAmount = mix(fogAmount, 0.5, smoothstep(70.0, 80.0, TIME*4.0 +  p.z));\n            }\n\t\t\t\n\t\t\tvec4 lightColDis = evaluateLight(p);\n\t\t\tvec3 light = lightColDis.rgb;\n\t\t\td = min(d, lightColDis.w);\n\n\t\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\t\tscatteredLight += transmittance * lightIntegrated;\t\n\t\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\t\tt += d;\t\t\n\t\t\tbool end = i == maxIter - 1 || t > maxDis;\n\t\t\tif (d < 0.01 || end) {\n\t\t\t\tvec3 c = vec3(1, 0, 1);\n\t\t\t\tvec3 normal = getNormal(p, rd);\n\n\t\t\t\tfloat fm = floor(m);\n\t\t\t\tif (fm == MAT_CORRIDOR) {\n\t\t\t\t\tvec3 dp = distort(p);\n\t\t\t\t\tfloat pattern = BrickPattern(dp.zy * 2.1 + vec2(0.0, 0.0));\n\t\t\t\t\tfloat n = noiseOctave(vec2(dp.z, dp.y) * 5.0, 10, 0.7);\n\t\t\t\t\tvec3 brick = vec3(1.0, 0.6, 0.35)*(0.1 + 0.9 * n);\n\t\t\t\t\tvec3 mortar = vec3(1.0);\n\t\t\t\t\tc = mix(brick, mortar, pattern);\n\n\t\t\t\t} else if (fm == MAT_ROOF) {\n\t\t\t\t\tvec3 dp = distort(p);\n\t\t\t\t\tfloat pattern = roofPattern(dp.xz);\n\t\t\t\t\tc = mix(vec3(0.5), vec3(0.85, 0.75, 0.45), pattern);\n\t\t\t\t} else if (fm == MAT_FLOOR) {\n\t\t\t\t\tvec3 dp = distort(p);\n\t\t\t\t\tfloat n = corrNoise(dp*4.0);\n\t\t\t\t\tfloat pattern = floorPattern(dp.xz);\n\t\t\t\t\tvec3 mortar = vec3(0.5);\n\t\t\t\t\tvec3 tile = mix(vec3(0.4)*1.0, vec3(1.0), n);\n\t\t\t\t\tc = mix(tile,mortar, pattern);\n\t\t\t\t}\n\n\t\t\t\tfloat ms = mod(m, 1.0) * 2.0;\n\n\t\t\t\tvec3 dp = distort(p);\n\t\t\t\tvec3 pc = vec3(1.0, 0.0, 0.0);\n\t\t\t\tc = mix(c, pc, ms);\n\n\t\t\t\tc *= occlusion(p, normal, rd);\n\t\t\t\taddLightning(c, normal, eye, p);\n\t\t\t\t\n\t\t\t\tif (end) {\n\t\t\t\t\ttransmittance = 0.0;\n\t\t\t\t}\n\t\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\t\t\t\t\n\t\t\t\tif (ms > 0.05 ) {\n\t\t\t\t\t\tref *= ms * 0.2;\n\n\t\t\t\t} else {\n\t\t\t\t\treturn col;\n\t\t\t\t}\n\n\t\t\t\trd = reflect(rd, getNormal(p, rd));\n\n\t\t\t\tro = p + rd*0.5;\n\t\t\t\tt = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= 16.0 / 9.0;\n\tfloat end = PART_END;\n    vec3 eye = vec3( 0.0, 0.0, TIME); \n\tif (TIME > end){\n\t\tfloat x = TIME - end;\n\t\teye.z = end + 1.0 - pow(3.0, -x);\n\t}\n    \n\tif (TIME > PART_TWIST) {\n\t\tfloat o = 3.0;\n\t\teye.x = cos(eye.z * 0.2 + o) * 0.7;\n\t\teye.y = sin(eye.z * 0.2 + o) * 0.5;\n\t}\n\t\n\tvec3 ed = distort(eye);\n\tvec3 td = distort(eye + vec3(0, 0, 1));\n\ttd.x = -td.x;\n\teye.x = -ed.x;\n\t\n\tvec3 tar = td;\n\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(vec3(0, 1, 0), dir));\n\tvec3 up = cross(dir, right);\n\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right * uv.x * 1.0 + up  *uv.y * 1.0);\n\t\n\tvec3 color = raymarch(ro, rd, eye);\n    \n\tcolor /= (color + vec3(1.0));\n\n\tfloat t = 0.5;\n\tfloat a = abs(TIME - 0.0);\n\n    color = mix(color, vec3(0.0), clamp(1.0 - a / t + length(uv), 0.0, 1.0));\n\n\tfloat b = abs(TIME - PART_TWIST);\n\tcolor = mix(color, vec3(0), clamp(1.0 - b / t + length(uv), 0.0, 1.0));\n    fragColor = vec4(color, 1.0);\n} \n",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}