{
    "Shader": {
        "info": {
            "date": "1648581678",
            "description": "smooth blobby blobs with bisexual lighting, we'll see where it goes",
            "flags": 32,
            "hasliked": 0,
            "id": "7tlyRs",
            "likes": 4,
            "name": "bisexual raymarching",
            "published": 3,
            "tags": [
                "blobs",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 208
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    uv = fragCoord.xy / iResolution.xy;\n        \n    vec3 col_a = texture(iChannel0,uv).rgb;\n    vec3 col_b = texture(iChannel1,uv).rgb; // twinkle feedback\n    \n    vec3 col = col_a+col_b;\n    \n    // return col\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define SHORTSTEP 6\n#define ORBS 12\n#define ORBSIZE 0.3\n#define ANIMSPEED .5\n#define ORBSPREAD .7\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat map(in vec3 p, in float sizer, in float smoother) {\n    float time = iTime*ANIMSPEED;\n    float sphere_d = length(p)-.1*sin(p.y+time*3.)*sizer-.4*sizer;\n    float step_d = sphere_d;\n    for (int j=1;j<ORBS;j++){\n        vec3 sphere_p1 = vec3(\n            sin(time+float(j)),\n            cos(time*0.333*float(j)),\n            cos(time*3.+float(j))\n        );\n        vec3 sphere_p2 = vec3(\n            sin(time*2.+float(j))*0.6+sin(time*.5+float(j))*0.6,\n            sin(time*0.03*float(j)*float(j)),\n            sin(time*1.5+float(j))            \n        );\n        vec3 sphere_p3 = vec3(\n            sin(time*1.+float(j))*sin(time*1.+float(j))*sin(time*1.+float(j)),\n            cos(time*1.+float(j))*cos(time*1.+float(j))*cos(time*1.+float(j)),\n            sin(time*3.+float(j))+sin(time*.5+float(j))*0.6            \n        );\n        float pattern_mix = noise(vec2(iTime*0.1,float(j)));\n        float pattern_mix2 = noise(vec2(iTime*0.1,-float(j)));\n        vec3 sphere_p = mix(sphere_p1,sphere_p2,pattern_mix);\n        sphere_p = mix(sphere_p,sphere_p3,pattern_mix2);\n        sphere_p *= 1.7 - (abs(pattern_mix-.5)-abs(pattern_mix2-0.5))*0.7;\n        sphere_d = length(p - ORBSPREAD*sphere_p)-ORBSIZE*sizer;\n        step_d = smin(step_d, sphere_d, smoother*rand(vec2(float(j))));\n    }\n    return step_d;\n}\n\nfloat map(in vec3 p) {\n    return map(p, 1., 1.);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.01,0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec3 RayPlane(in vec3 ro, in vec3 rd, in vec3 p, in vec3 n) {\n    float t = max(0., dot(p-ro,n)/dot(rd,n));\n    return ro + rd*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    uv *= 1.5;    \n    \n    vec3 ro = vec3(0.,0.,-10.);\n    vec3 rd = normalize(vec3(uv,8.));\n    \n    float d,smooth_d = 0.;\n    bool hit,smooth_hit = false;\n    vec3 p,smooth_p = vec3(0.);\n    int steps = 0;\n    float glow = 0.;\n    for(int i=0;i<60;i++){\n        steps++;\n        p = ro + d*rd;\n        float step_d = map(p);\n        d += step_d;\n        if (i==SHORTSTEP) { smooth_d = d; smooth_p = p; }\n        if (step_d < 0.01) hit=true;\n        if (i==SHORTSTEP && step_d < 0.001) smooth_hit=true;\n        if (i>SHORTSTEP && (step_d < 0.001 || d > 60.)) break;\n        if (d < 20.) glow += 1./(step_d+.5);\n    }\n    vec3 col = vec3(d * smooth_d * 0.001);\n    \n    vec3 smooth_norm = getNormal(smooth_p);\n    vec3 norm = getNormal(p);\n    \n    col.r = 2. - length(p)*1.5;\n    \n    if (!hit) col = vec3(glow*glow*0.0001);\n    if (hit) col = mix(vec3(glow*0.1),col,0.8);\n    \n    float rays, ray_d = 0.;\n    vec3 pp = RayPlane(ro, normalize(vec3(uv,9.)), vec3(0), normalize(ro));\n    float step_d = map(normalize(pp));\n    ray_d += step_d;\n    \n    rays = ray_d;\n    rays = smoothstep(.0,.05 + length(uv),rays) * .7;\n    rays *= smoothstep(0.,.5,length(uv));    \n    rays += smoothstep(0.5,1.,1.0 - length(uv)) * .3;\n    \n    if (!hit) col.b += .01;\n    if (!hit) col.b *= 1.2;\n    vec3 lightcol = mix(vec3(1.,.1,.1),vec3(.1,.1,.3),pow(1.0-rays,5.));\n    if (!hit || hit && d < 2.) col += vec3(pow(rays,1.1)) * lightcol;\n    if (hit) col.b *= 0.3;\n    if (hit) col.g *= 0.1;\n    \n    if (hit) col += vec3(clamp(1.-dot(-norm,rd),0.,1.))*.5*lightcol;\n    \n    col = pow(col, vec3(.4545)); // gamma\n    \n    if (hit) col.gb += vec2(map(p,.05,.1));\n    \n    // return col\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= 0.5;\n    uv *= 0.995;\n    uv += 0.5;\n    \n    vec3 col = texture(iChannel0,uv).rgb;\n    float brightness = (col.r+col.g+col.b)/3.;\n    \n    vec3 blur = vec3(0.);\n    \n    vec2 px = 1./iResolution.xy;\n    \n    float n = noise(uv*10. + iTime*1.);\n    vec2 np = vec2(0.);\n    float b = 0.;\n    \n    if (brightness < 1.)\n    for (float i=1.;i<6.5;i+=2.1) {\n        // tl\n        np = vec2(-i,-i);\n        np *= Rot(iTime);\n        vec3 tl = texture(iChannel0,uv+px*np).rgb*n;\n        b = (tl.r+tl.g+tl.b)/3.;\n        if (b>1.2) blur += tl;\n        // tr\n        np = vec2(i,-i);\n        np *= Rot(iTime);\n        vec3 tr = texture(iChannel0,uv+px*np).rgb*n;\n        b = (tr.r+tr.g+tr.b)/3.;\n        if (b>1.2) blur += tr;\n        // br\n        np = vec2(-i,i);\n        np *= Rot(iTime);\n        vec3 br = texture(iChannel0,uv+px*np).rgb*n;\n        b = (br.r+br.g+br.b)/3.;\n        if (b>1.2) blur += br;\n        // bl\n        np = vec2(i,-i);\n        np *= Rot(iTime);\n        vec3 bl = texture(iChannel0,uv+px*np).rgb*n;\n        b = (bl.r+bl.g+bl.b)/3.;\n        if (b>1.2) blur += bl;\n    }\n    \n    col = min(col,vec3(1.));\n    \n    col = mix(col,blur,0.95);\n    \n    vec3 lastpass = texture(iChannel1,uv).rgb;\n    \n    col = mix(col,lastpass,1.-col.b);\n    \n    col = vec3(min(col.b,1.0));\n    col *= vec3(2.,0.95,0.95);\n    // col = vec3(n);\n    // return col\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}