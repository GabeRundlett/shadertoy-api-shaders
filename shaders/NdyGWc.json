{
    "Shader": {
        "info": {
            "date": "1632461515",
            "description": "Uses importance sampling / inverse transform sampling to estimate human luminance frequency response. (CIE XYZ's Y coordinate)\n\nBlends two sampled states using a transformed bezier curve.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdyGWc",
            "likes": 3,
            "name": "Luminance spectra sampling",
            "published": 3,
            "tags": [
                "color",
                "physics",
                "statistics"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n// CIE 1931 Color matching function approximation\n// Y is used as a luma curve\n// https://en.wikipedia.org/wiki/CIE_1931_color_space#Color_matching_functions\n\n// piecewise gaussian\nfloat p_gauss(float am, float A, float mu, float sigmaLow, float sigmaHigh)\n{\n    float sigma;\n    if(am < mu)\n        sigma = sigmaLow;\n    else\n        sigma = sigmaHigh;\n    float dx = am - mu;\n    return A*exp(dx*dx / (-2.0*sigma*sigma));\n}\n\n// CIE 1931 standard observer\nvec3 spectra_to_XYZ(float wavelength_nm)\n{\n    float X, Y, Z;\n    X  = p_gauss(wavelength_nm, 1.056, 599.8, 37.9, 31.0);\n    X += p_gauss(wavelength_nm, 0.362, 442.0, 16.0, 26.7);\n    X += p_gauss(wavelength_nm,-0.065, 501.1, 20.4, 26.2);\n\n    Y  = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    Z  = p_gauss(wavelength_nm, 1.217, 437.0, 11.8, 36.0);\n    Z += p_gauss(wavelength_nm, 0.681, 459.0, 26.0, 13.8);\n    \n    return vec3(X, Y, Z);\n}\n\n// close enough\n// an unbiased importance sampler would divide the pdf of gaussian\n//     to the pdf of the integrated, shifted atanh. The max\n//     absolute error between erf(x) and tanh(x / (sqrt(pi)/2) is\n//     around 0.035. This implies that the inverse tanh function\n//     is a pretty good approximation of erf(x), when scaled.\n//\n// This function is no longer used, as euler's gassian integral works instead. However, its still interesting nonetheless\nfloat erfinv(float x)\n{\n    return atanh(x) * sqrt(3.141592) / 2.0;\n}\n\n// Performs an importance sample of the luminance spectra\nfloat isample_luma()\n{\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    \n    // normalized distribution sample\n    vec4 Lum = vec4(0.0);\n    Lum[0] = 0.821 * 46.9 * sqpi_2;\n    Lum[1] = 0.821 * 40.5 * sqpi_2;\n    Lum[2] = 0.286 * 16.3 * sqpi_2;\n    Lum[3] = 0.286 * 31.1 * sqpi_2;\n    \n    vec4 csum = vec4(0.0);\n    csum[0] = Lum[0];\n    csum[1] = csum[0] + Lum[1];\n    csum[2] = csum[1] + Lum[2];\n    csum[3] = csum[2] + Lum[3];\n    \n    float weight = rnd() * csum[3];\n    int i=0;\n    for(; i<4; ++i)\n    {\n        if(weight <= csum[i])\n            break;\n    }\n    \n    // from the given selection, inverse sample the distribution\n    vec4 mus = vec4(568.8, 568.8, 530.9, 530.9);\n    vec4 sigmas = vec4(-46.9, 40.5, -16.3, 31.1);\n    \n    vec2 xi = vec2(rnd(), rnd());\n    float r = sqrt(-2.0*log(1.0 - xi.x)) * sin(xi.y * 3.141592);\n    return r*sigmas[i] + mus[i];\n}\n\nfloat pdf_luma(float wavelength_nm)\n{\n    // Find the normalized luminance for this frequency\n    //norm = 106.9224850198325\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    const float norm = (0.821 * (46.9 + 40.5) + 0.286 * (16.3 + 31.1)) * sqpi_2;\n\n    float Y = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    return Y / norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Aspect ratio adjusted coordinates\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.y *= iResolution.y/iResolution.x;\n    xy = (xy + 1.0) / 2.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Luminance curve\n    float nm = mix(350.0, 850.0, xy.x);\n    float luma = spectra_to_XYZ(nm).y;\n    \n    // re-scale nm to xy coords\n    vec2 pt = vec2(nm, luma);\n    pt.x = (pt.x - 350.0) / (850.0 - 350.0); // inverse lerp into xy coords\n    pt.y = mix(0.25, 0.75, pt.y); // re-scale into xy coords\n    \n    // color the curve\n    if(xy.y < pt.y)\n        col = mix(col, vec3(0.0), 0.66);\n    if(length(pt - xy) < 0.005)\n        col *= 0.0;\n    \n    // Generate 512 samples using a standard key\n    const int pt_count = 512;\n    const float dt = 4.0;\n    \n    //const int pt_count = 16;\n    //const float dt = 0.4;\n    \n    \n    const bool isample_each_frame = false;\n    if(isample_each_frame)\n    {\n        seed = iTime;\n        for(int i=0; i<pt_count; ++i)\n        {\n            float nm = isample_luma();\n            float pct = rnd();\n            vec2 pt = vec2(nm, pct);\n\n            // re-scale into xy coords\n            float luma = spectra_to_XYZ(nm).y;\n            pt.y *= luma;\n\n            pt.y = mix(0.25, 0.75, pt.y); // re-scale into xy coords\n            pt.x = (pt.x - 350.0) / (850.0 - 350.0); // inverse lerp into xy coords\n\n            if(length(pt - xy) < 0.002)\n                col = wavelength_to_srgb(nm);\n        }\n    }\n    else\n    {\n        seed = float(int(iTime / dt)) * dt;\n        vec2 points[pt_count];\n        //points have the unit of (nm, pct)\n        \n        for(int i=0; i<pt_count; ++i)\n        {\n            float nm = isample_luma();\n            float pct = rnd();\n            points[i] = vec2(nm, pct);\n        }\n\n        // Generate a second set of points to blend \n        seed = float(int(iTime / dt) + 1) * dt;\n        vec2 points_dst[pt_count];\n\n        for(int i=0; i<pt_count; ++i)\n        {\n            float nm = isample_luma();\n            float pct = rnd();\n            points_dst[i] = vec2(nm, pct);\n        }\n\n        // Blend points and render using sdf\n        for(int i=0; i<pt_count; ++i)\n        {\n            float t = mod(iTime, dt) / dt;\n\n            // adds a delay at the end of each cycle\n            t = (t - 0.1) / (0.9 - 0.1);\n            t = clamp(t, 0.0, 1.0);\n\n            // Function-bounded Bezier mix\n            vec2 pt0 = points[i];\n            vec2 pt1 = points_dst[i];\n\n            // Lerp mix\n            //vec2 pt = mix(pt0, pt1, t);\n\n            // Bezier mix\n            vec2 d_pt = pt1 - pt0;\n            vec2 pt = pt0 + t*t*(3.0*d_pt - 2.0*t*d_pt);\n\n            // re-scale into xy coords\n            float nm = pt.x;\n            float luma = spectra_to_XYZ(nm).y;\n            pt.y *= luma;\n\n            pt.y = mix(0.25, 0.75, pt.y); // re-scale into xy coords\n            pt.x = (pt.x - 350.0) / (850.0 - 350.0); // inverse lerp into xy coords\n\n            if(length(pt - xy) < 0.002)\n                col = wavelength_to_srgb(nm);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Color space transforms are hidden away in common for clarity of isample\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 XYZ_to_lsrgb(vec3 XYZ)\n{\n    mat3 tolsrgb = transpose(mat3( 3.2406,-1.5372,-0.4986,\n                                  -0.9689, 1.8758, 0.0415,\n                                   0.0557,-0.2040, 1.0570));\n    return tolsrgb * XYZ;\n}\n\n// this is a copy of the function used in main, to avoid a redefinition.\n// its used for the convinience funciton wavelength_to_srgb below.\nfloat _p_gauss(float am, float A, float mu, float sigmaLow, float sigmaHigh)\n{\n    float sigma;\n    if(am < mu)\n        sigma = sigmaLow;\n    else\n        sigma = sigmaHigh;\n    float dx = am - mu;\n    return A*exp(dx*dx / (-2.0*sigma*sigma));\n}\n\nvec3 _spectra_to_XYZ(float wavelength_nm)\n{\n    float X, Y, Z;\n    float ang = wavelength_nm * 10.0;\n    X  = _p_gauss(ang, 1.056, 5998.0, 379.0, 310.0);\n    X += _p_gauss(ang, 0.362, 4420.0, 160.0, 267.0);\n    X += _p_gauss(ang,-0.065, 5011.0, 204.0, 262.0);\n\n    Y  = _p_gauss(ang, 0.821, 5688.0, 469.0, 405.0);\n    Y += _p_gauss(ang, 0.286, 5309.0, 163.0, 311.0);\n\n    Z  = _p_gauss(ang, 1.217, 4370.0, 118.0, 360.0);\n    Z += _p_gauss(ang, 0.681, 4590.0, 260.0, 138.0);\n    \n    return vec3(X, Y, Z);\n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        //hsv.yz /= hsv.z;\n        hsv.z /= hsv.z;\n    \n    if(1.0 < hsv.y)\n        //hsv.yz /= hsv.z;\n        hsv.y /= hsv.y;\n    \n    return hsv2rgb(hsv);\n}\n\nvec3 wavelength_to_srgb(float wavelength)\n{\n    vec3 XYZ = _spectra_to_XYZ(wavelength);\n    vec3 lsrgb = XYZ_to_lsrgb(XYZ);\n    \n    //lsrgb is apparently clipped here? this feels off, like it should be projected instead\n    //https://photo.stackexchange.com/questions/67990/what-should-i-do-with-negative-values-when-computing-srgb-colors-from-spectra\n    lsrgb = clamp(lsrgb, vec3(0.0), vec3(1.0));\n    \n    return lsrgb2srgb(lsrgb);\n}\n\nfloat plancks_law(float wavelength_nm, float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n\n    float m = wavelength_nm * 1.0e-9;\n    float m2 = m*m;\n\n    float Rayleigh_Jeans = 2.0*h*c*c/(m2*m2*m);\n    float quantum_temp_ratio = h*c/(k*m*temperature);\n    float Wien = exp(quantum_temp_ratio) - 1.0;\n    \n    return Rayleigh_Jeans / Wien;\n}\n\nfloat plancks_law_max(float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n\n    // dPlanck / dlambda = 0\n    // (hc/lkT) / (1-exp(-hc/lkT)) = 5\n    // x = hc/lkT\n    // x / (1-exp(-x) = 5\n    // x = 5 - 5exp(-x)\n    // 0 = 5 + (x-5)exp(x)\n    // -5exp(-5) = (x-5)exp(x-5)\n    // W(-5exp(-5)) + 5 = x\n    // 1/x is approximately 0.2014052352726422\n    // l = hc / xkT\n    return (h*c/(k*temperature)) * 0.2014052352726422;\n}\n\nfloat plancks_law_normalized(float wavelength_nm, float temperature)\n{\n    float planck = plancks_law(wavelength_nm, temperature);\n    planck /= plancks_law(plancks_law_max(temperature), temperature);\n    return planck;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}