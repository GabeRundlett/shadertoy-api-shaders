{
    "Shader": {
        "info": {
            "date": "1643163477",
            "description": "Based on a popular animated canvas drawing; I was just curious what it would be like to implement this in GLSL.\nFirst accumulating polar coordinates of all nearby particles in an array. Then scanning this 'ring' for opposites.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssScRD",
            "likes": 20,
            "name": "Particle Network",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 0,
            "username": "ruudhelderman",
            "viewed": 602
        },
        "renderpass": [
            {
                "code": "const int number_of_particles = 250;\nconst int number_of_buckets = 32;\nconst float brightness_particle = -50000.0;\nconst float brightness_wire = -500.0;\nconst float cutoff = 0.01;\nconst float speed = 0.04;\nconst float time_offset = 999.0;\nconst vec3 color = vec3(0.0, -0.3, -0.6);\n\nconst int half_of_buckets = number_of_buckets / 2;\nconst float bucket_angle_ratio = float(half_of_buckets) / 3.14159265359;\n\nconst float angle = 1.2;\nconst mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat ring[number_of_buckets];\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float average_resolution = 0.5 * (iResolution.x + iResolution.y);\n    vec2 pole = fragCoord / average_resolution - 0.5;\n    vec2 particle = vec2(speed * (time_offset + iTime), 0);\n    float brightness = 0.0;\n    \n    for (int i = 0; i < number_of_particles; i++)\n    {\n        vec2 partial_wire = fract((particle *= rotate) - pole) - 0.5;\n        float radius = dot(partial_wire, partial_wire);\n        \n        if (radius < cutoff)\n        {\n            float radial_brightness = exp(radius * brightness_wire);\n            float bucket = bucket_angle_ratio * (atan(partial_wire.y, partial_wire.x) + 7.0);\n            float leaking_brightness = radial_brightness * fract(bucket);\n            int b = int(bucket);\n            \n            ring[b % number_of_buckets] += radial_brightness - leaking_brightness;\n            ring[(b+1) % number_of_buckets] += leaking_brightness;\n\n            brightness += exp(radius * brightness_particle);\n        }\n    }\n\n    for (int i = 0; i < half_of_buckets; i++)\n    {\n        brightness += ring[i] * ring[i + half_of_buckets];\n    }\n\n    fragColor = vec4(color + brightness, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}