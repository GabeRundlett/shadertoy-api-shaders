{
    "Shader": {
        "info": {
            "date": "1617460465",
            "description": "License CC0: Hex tile transition effect\nResult after playing around with transition effects\n",
            "flags": 0,
            "hasliked": 0,
            "id": "sd2GWD",
            "likes": 39,
            "name": "Hex tile transition effect",
            "published": 3,
            "tags": [
                "transition",
                "hextile"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 1166
        },
        "renderpass": [
            {
                "code": "// License CC0: Hex tile transition effect\n//  Result after playing around with transition effects\n\n#define HEXTILE_SIZE 0.125\n#define RANDOMNESS   0.75\n\n// -\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n#define RESOLUTION   iResolution\n#define TIME         iTime\n#define PERIOD       8.0\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// IQ's hex\nfloat hex(vec2 p, float r) {\n  p.xy = p.yx;\n  const vec3 k = vec3(-sqrt(3.0/4.0),1.0/2.0,1.0/sqrt(3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// See Art of Code: Hexagonal Tiling Explained!\n// https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\n// IQ's polynominal soft min\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's ellipse\nfloat ellipse(vec2 p, vec2 ab) {\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nconst int N = 4;\n\n// IQ's polygon\nfloat polygon(vec2 p, vec2[N] v) {\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ ) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst vec2[] wing = vec2[](vec2(0.385, 0.435), vec2(1.35, 0.435), vec2(0.92, 0.035), vec2(0.385, 0.035));\n\nfloat commodore(vec2 p, out bool isRed) {\n  vec2 op = p;\n  p.y = abs(p.y);\n  float d0 = ellipse(p, vec2(1.0, 0.865));\n  d0 = abs(d0)- 0.275;\n  float d1 = p.x-0.375;\n  float d2 = polygon(p, wing);\n  float d = d0;\n  d = pmax(d, d1, 0.025);\n  d = pmin(d, d2, 0.025);\n  isRed = op.y > 0.0 && d2 <= 0.0025;\n  return d;\n}\n\n\nvec3 hexTransition(vec2 p, float aa, vec3 from, vec3 to, float m) {\n  m = clamp(m, 0.0, 1.0);\n  const float hz = HEXTILE_SIZE;\n  const float rz = RANDOMNESS;\n  vec2 hp = p;\n  hp /= hz;\n//  hp *= ROT(0.5*(1.0-m));\n  vec2 hn = hextile(hp)*hz*-vec2(-1.0, sqrt(3.0));\n  float r = hash(hn+123.4);\n  \n  const float off = 3.0;\n  float fi = smoothstep(0.0, 0.1, m);\n  float fo = smoothstep(0.9, 1.0, m);\n\n  float sz = 0.45*(0.5+0.5*tanh_approx(((rz*r+hn.x + hn.y-off+m*off*2.0))*2.0));\n  float hd = (hex(hp, sz)-0.1*sz)*hz;\n  \n  float mm = smoothstep(-aa, aa, -hd);\n  mm = mix(0.0, mm, fi);\n  mm = mix(mm, 1.0, fo);\n  \n  vec3 col = mix(from, to, mm);\n  vec2 ahn = abs(hn);\n  return col;\n}\n\nvec3 sunset(vec2 p, float aa) {\n  const float z = 0.75;\n  const float so = 0.05;\n\n  bool isRed;\n  float d = commodore(p/z, isRed)*z;\n  bool sisRed;\n  float ds = commodore((p-so*vec2(-1.0, -1.0))/z, sisRed)*z;\n\n  vec3 col = vec3(1.0);\n\n  float sy = abs(p.y);\n\n  vec3 sky   = hsv2rgb(vec3(0.55, max(sy, 0.0), max(1.0-1.0*sy, 0.0)))*0.6;\n  vec3 sun1  = hsv2rgb(vec3(0.05, max(1.0-sy, 0.0), max(1.0-(1.0/1.25)*sy, 0.0)))*0.6;\n  vec3 sun2  = hsv2rgb(vec3(0.05, smoothstep(0.0, 0.125, sy)*0.5, (1.0-sy)*smoothstep(0.0, 0.125, sy)))*0.6;\n  vec3 venus = 1.0*exp(-300.0*(length(p - vec2(0.5))))*vec3(1.0);\n  vec3 land  = vec3(0.05);\n  vec3 sea   = hsv2rgb(vec3(0.5, 0.5*sy, sy))*1.9;\n  \n  col = sun1+sun2;\n  col = mix(col, sky, max(sy*sy, 0.0));  \n  col = mix(col, land, smoothstep(0.026, 0.0, sy));  \n  col += 0.33*(1.0-tanh_approx(8.0*length((p-vec2(0.0, 0.0125))*vec2(0.125, 1.0))));\n  col += 0.66*(1.0-tanh_approx(8.0*length((p-vec2(0.0, 0.0125))*vec2(1.0, 1.0))));\n  col += venus;\n  col += sea*sqrt(max(-p.y, 0.0));\n  \n  col = clamp(col, 0.0, 1.0);\n  \n  col = mix(col, vec3(0.25, 0.25, 0.25) , 1.0*exp(-10.0*max(ds+so*sqrt(2.0), 0.0)));\n  col = mix(col, isRed ? vec3(1.0, 0.215, 0.25) : vec3(1.0), smoothstep(-aa, aa, -d));\n\n  col = clamp(col, 0.0, 1.0);\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 dark   = vec3(0.25)*(1.0-tanh_approx(length(p)));\n  vec3 sunset = sunset(p, aa);\n\n  float nt = TIME/PERIOD;\n  float m = fract(nt)*1.25;\n  float n = mod(floor(nt), 2.0);\n  \n  vec3 from = n == 0.0 ? dark:sunset;\n  vec3 to   = n != 0.0 ? dark:sunset;\n  \n  vec3 col = hexTransition(p, aa, from, to, m);\n \n  col = postProcess(col, q);\n\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}