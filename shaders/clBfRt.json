{
    "Shader": {
        "info": {
            "date": "1694640050",
            "description": "any feedback on how to make it look nicer is welcome! (thank you shane)\n(also if anyone is still getting a black screen please tell me)",
            "flags": 0,
            "hasliked": 0,
            "id": "clBfRt",
            "likes": 4,
            "name": "woven strings",
            "published": 3,
            "tags": [
                "woven",
                "strings"
            ],
            "usePreview": 0,
            "username": "77Tigers",
            "viewed": 194
        },
        "renderpass": [
            {
                "code": "#define EPS 0.001\n#define PI 3.1419526535\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\n// rotate around axis\nvec3 rot_around(vec3 v, vec3 axis, float deg) {\n    vec3 height_v = axis * dot(v, axis);\n    vec3 proj_v = v - height_v;\n    return height_v + cos(deg) * proj_v + sin(deg) * cross(axis, proj_v);\n}\n\n// nicked this from https://www.shadertoy.com/view/MtsGWH, thanks iq\n// \"p\" point apply texture to\n// \"n\" normal at \"p\"\n// \"k\" controls the sharpness of the blending in the\n//     transitions areas.\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k ) {\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvec2 get_dists(vec3 r) {\n    // 1 and 2 represent the two diagonals\n    vec3 r1 = mat3x3(\n        cos(PI * 0.25), sin(PI * 0.25), 0.0,\n        -sin(PI * 0.25), cos(PI * 0.25), 0.0,\n        0.0, 0.0, 1.0\n    ) * r;\n    \n    vec3 r2 = r1.yxz;\n    \n    vec3 r1_floor = vec3(mod(r1.x - 1., 2.) - 1., r1.yz);\n    vec3 r2_floor = vec3(mod(r2.x - 1., 2.) - 1., r2.yz);\n    \n    float dist1 = length(r1_floor.xz - vec2(0.0, 0.5 *\n        -cos((r1.y * .5 + floor(r1.x * .5 - .5)) * PI)\n    )) - 0.5;\n    float dist2 = length(r2_floor.xz - vec2(0.0, 0.5 *\n        cos((r2.y * .5 + floor(r2.x * .5 - .5)) * PI)\n    )) - 0.5;\n    \n    // neighbours\n    dist1 = min(length(r1_floor.xz + vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        -cos((r1.y * .5 + 1. + floor(r1.x * .5 - .5)) * PI)\n    )) - 0.5, dist1);\n    dist1 = min(length(r1_floor.xz - vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        -cos((r1.y * .5 - 1. + floor(r1.x * .5 - .5)) * PI)\n    )) - 0.5, dist1);\n    dist2 = min(length(r2_floor.xz + vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        cos((r2.y * .5 + 1. + floor(r2.x * .5 - .5)) * PI)\n    )) - 0.5, dist2);\n    dist2 = min(length(r2_floor.xz - vec2(2.0, 0.0) - vec2(0.0, 0.5 *\n        cos((r2.y * .5 - 1. + floor(r2.x * .5 - .5)) * PI)\n    )) - 0.5, dist2);\n    \n    return vec2(dist1, dist2);\n}\n\nfloat sdf (vec3 r) {\n    // 1 and 2 represent the two diagonals\n    vec2 dists = get_dists(r);\n    \n    float dist1 = dists.x;\n    float dist2 = dists.y;\n    \n    // floor\n    float distf = r.z + 0.7;\n    \n    return min(min(dist1, dist2) * .6, distf);\n}\n\nfloat sdf (ray r) {\n    return sdf(r.pos);\n}\n\n// sdf norm\n// thanks to shane for feedback\nvec3 sdfn (vec3 pos) {\n    float f = sdf(pos);\n    vec2 e = vec2(EPS * 10.0, 0.0);\n    \n    return normalize(vec3(\n        (f - sdf(pos + e.xyy)),\n        (f - sdf(pos + e.yxy)),\n        (f - sdf(pos + e.yyx))\n    ));\n}\n\n// keep going until too far or too close\n// thanks to shane for feedback\nvoid march (inout ray r) {\n    for (int i = 0; i < 500; i++) {\n        float dist = sdf(r);\n        \n        if (dist < EPS || dist > 100.) {\n            return;\n        }\n        r.pos += dist * r.dir;\n    }\n}\n\nvec3 col (ray r) {\n    vec3 base_col = vec3(0.0);\n    \n    vec3 norm = sdfn(r.pos);\n    vec3 rfl = reflect(r.dir, norm);\n    float sq2 = sqrt(2.);\n    vec2 mcoords = mod(r.pos.xy - sq2 * .25, sq2 * .5) - sq2 * .25;\n    \n    vec2 dists = get_dists(r.pos);\n    float dist1 = dists.x;\n    float dist2 = dists.y;\n    \n    if (r.pos.z <= -.69) {\n        base_col = vec3(1.0);\n        \n        // vec3(0.2) + sin(30. * (r.pos.x)) * sin(30. * (r.pos.y)) * .2 +\n        if (length(mcoords) < .3 && length(mcoords) > .15) {\n            base_col = vec3(0.8, 0.4, 0.0) * .1 + .9 * 1.;\n        }\n        vec3 result = base_col + .1 * texture(iChannel1, rfl).rgb * dot(norm, vec3(1.0, 1.0, 1.0));\n        result += min(dist1 * dist1 * 1. - .5, 0.);\n        result += min(dist2 * dist2 * 1. - .5, 0.);\n        result = clamp(result, 0.0, 1.0);\n        return sqrt(result);\n    } else {\n        if (dist1 < 0.01) {\n            base_col = boxmap(iChannel0, mat3x3(1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0) * r.pos * .5, norm, 0.5 ).rgb;\n        } else {\n            base_col = 0.75 * boxmap(iChannel0, mat3x3(1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 0.0, 0.0, 1.0) * r.pos * .5, norm, 0.5 ).rgb;\n        }\n    }\n    if (dist1 > 0.01) {\n        base_col *= min(.3 + dist1 * 1.5, 1.0);\n    }\n    if (dist2 > 0.01) {\n        base_col *= min(.3 + dist2 * 1.5, 1.0);\n    }\n    if (dist1 < 0.01 && dist2 < 0.01) {\n        base_col = vec3(0.0);\n    }\n    return .9 * base_col;\n    \n}\n\nvec3 trace (inout ray r) {\n    march(r);\n    float d = sdf(r);\n    \n    if (d > 100.) {\n        return vec3(1.0, 1.0, 1.0);\n    } else if (d < EPS) {\n        return col(r);\n    } else {\n        return vec3(0.5);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.0*(fragCoord - vec2(iResolution.x/2.0, iResolution.y/2.0))/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    ray r = ray(vec3(25. * vec2(cos(iTime * 0.1), sin(iTime * 0.1)), 5.0), rot_around(\n        normalize(vec3(p, 1.)),\n        vec3(1., 0., 0.),\n        PI * (1.0 )//+ 0.05 * sin(iTime) - 0.05)\n    ));\n    \n    col = trace(r);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}