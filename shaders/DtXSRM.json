{
    "Shader": {
        "info": {
            "date": "1674481844",
            "description": "My first 3D fractal scene :)",
            "flags": 32,
            "hasliked": 0,
            "id": "DtXSRM",
            "likes": 30,
            "name": "Inside the Mandelbulb",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "distance",
                "tracing",
                "estimator",
                "path"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 702
        },
        "renderpass": [
            {
                "code": "/* \"Inside the Mandelbulb\" by @kishimisu (2023) - https://www.shadertoy.com/view/DtXSRM\n    \n    My third path-tracing scene and first 3D fractal scene!\n    \n    I spent the whole last week exploring, learning and being amazed by\n    fractalforum.org posts from 2013 only wishing I discovered this community \n    sooner. The mandelbulb seems to be a great first step into 3D fractal worlds.\n    \n    Technically we're not inside the mandelbulb, we're looking at one of\n    its edges, however I mirrored it around the surface of a sphere slightly\n    bigger than the fractal boundary. This means that at the center of the scene\n    is the original mandelbulb, but everywhere else is a mirrored/inside out \n    version of the mandelbulb, allowing this feeling of being \"inside\".\n    \n    Finally, this scene has 3 viewpoints and animates every 10 seconds between\n    each of them. You can control this interval in Buffer A.\n    \n    Move the camera with the mouse!\n*/\n\nvec3 ACESFilm(vec3 x) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0., 1.);\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec3 col = texture(iChannel0, F/iResolution.xy).rgb;\n    \n    col *= .5;                   // exposure\n    col = ACESFilm(col);         // tone-mapping\n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    O = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Time to wait before switching viewpoints (in seconds)\n#define T 10.\n\n// Maximum number of ray bounces during the path-tracing loop\n#define BOUNCES 3\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define hash(p) fract(sin(p)*43758.5453)\n\n#define iter 200.\n#define max_dist 10.\n#define eps 0.0004\n\n// Viewpoints coordinates\nconst vec2 VP1 = vec2(.45, .7);\nconst vec2 VP2 = vec2(0, -.18);\nconst vec2 VP3 = vec2(-.4, -.4);\n\n// 4-values smoothstep (0->1 between a & b, 1->0 between c & d)\nfloat smooth4(float a, float b, float c, float d, float x) {\n    if (x < b) return smoothstep(a, b, x);\n    if (x < c) return 1.;\n    return smoothstep(d, c, x);\n}\n\n// (Clamped) quadratic rational smoothstep - https://iquilezles.org/articles/smoothsteps/\nfloat qrstep(float x) {\n    x = clamp(x, 0., 1.);\n    return x*x/(2.*x * (x-1.) + 1.);\n}\n\n// I think this is from iq ? Can't find the original version\nvec3 cosineDirection(float seed, vec3 nor) {\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// Mandelbulb distance estimator\nfloat orbitTrap;\nfloat mdb(vec3 p) {\n    const float scale = 2.5;\n    p = vec3(p.x, p.z, -p.y)/scale;\n    float lp = length(p); \n    \n    // Magic line that mirrors the mandelulb around a sphere\n    // Uncomment it to see the difference \n    if (lp > 1.1) p = normalize(p) * (2.2-lp);\n    \n    vec3 z = p;\n    float r = length(p), dr = 1.;    \n    orbitTrap = 1e7;\n    \n    //http://blog.hvidtfeldts.net/index.php/2011/09/\n    for (float i = 0.; i < 4.; i++) {\n        if (r > 2.) break;\n        \n        // convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi   = atan(z.y,z.x);\n\t\tdr =  8.*pow(r, 7.)*dr + 1.;\n        \n        // scale and rotate the point\n\t\tfloat zr = pow(r, 8.);\n\t\ttheta = theta*8.;\n\t\tphi   = phi*8.;\n        \n        // convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += p;\n\n        orbitTrap = min(orbitTrap, zr);\n        r = length(z);\n    }\n    \n    return .5*log(r)*r/dr * scale;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) { \n    float t = 0.;\n    for (float i = 0.; i < iter; i++) {\n        vec3  p = ro + t*rd;\n        float d = mdb(p);\n        t += d;\n        \n        if (d < eps || t > max_dist) return t;\n    }\n    return -1.;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(1,-1)*.0001;\n    return normalize(e.xyy*mdb(p + e.xyy) + e.yyx*mdb(p + e.yyx) + \n\t\t\t\t\t e.yxy*mdb(p + e.yxy) + e.xxx*mdb(p + e.xxx));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd, float t) { \n    // Mouse coordinates (clip space)           + handle default mouse position\n    vec2 m  = (iMouse.xy/iResolution.xy*2.-1.)  * step(1., dot(iMouse.xy, iMouse.xy)); \n    \n    // Animate viewpoint\n    vec2 vp = t < T*2. ?\n                mix(VP1, VP2, qrstep(t/T-0.5)) :\n                mix(VP2, VP3, qrstep(t/T-2.5)) ;\n    \n    // Setup ray origin\n    ro = vec3(0, 1.8, 2.04);\n    ro.yz *= rot(vp.y*.7 + m.y*.1);\n    ro.zx *= rot(vp.x*2. + m.x*.2 - .22);\n      \n    // Setup ray direction\n    const vec3 lookAt = vec3(0,2.2,0);\n    vec3 f = normalize(lookAt-ro), \n         r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {  \n    // Animation progression\n    float t = T*4. - abs(mod(iTime + T*1.5, T*8.) - T*4.);\n    bool isAnim = abs(T - abs(t - T*2.)) < T*.48; // True when the camera position is animating\n    \n    // Frame average management\n    float frame = texture(iChannel0, vec2(0)).r;\n    bool  reset = iFrame == 0 || iMouse.z > 1.;     \n    if (all(equal(F-.5, vec2(0)))) {\n        O.r = reset || isAnim ? 3. : (frame + 1.);  \n        return;\n    }\n    \n    // Path-tracing setup\n    float seed = hash(dot(F, vec2(12.9898, 78.233)) + 1113.1*iTime); \n    vec2 of = vec2(hash(seed+13.271), hash(seed+63.216))-0.5;\n    vec2 uv = (2.*(F+of) - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd;\n\n    initRayOriginAndDirection(uv, ro, rd, t);\n    \n    vec3 col = vec3(0);\n    vec3 lum = vec3(1);\n    float t0;\n    \n    // Path-tracing loop\n    for (int i = 0; i < BOUNCES; i++) {\n        // Get scene intersection\n        float d = raymarch(ro, rd);\n        \n        if (i == 0) t0 = d;\n        if (d < 0.) break;\n        \n        // Calculate hit position and normal\n        vec3 p = ro + d*rd;\n        vec3 n = getNormal(p - rd*eps*2.);\n        \n        // Update ray origin and direction\n        float cseed = seed + 76.2 + 73.1*float(i) + 17.7*iTime;\n        ro = p + n*eps*2.;\n        rd = cosineDirection(cseed, n);\n        \n        // Colorize ray\n        const vec3 lavaCol = vec3(0.96, 0.27, 0);\n        const vec3 glowCol = vec3(.3, .2, 1);\n        const vec3 reflCol = vec3(0.61,0.07,0.07) * .75;\n        \n        float centerMask = smoothstep(1., .6, length(p - vec3(0,2.2,0)));\n        float lavaMask = 3.*smoothstep(.4,.5, .06+abs(orbitTrap-.5) - smoothstep(0., 1.5, p.y-1.6));\n        float glowMask = 3.*pow((1.+centerMask)*smoothstep(.04, .03, orbitTrap), 4.);\n        glowMask = min(25., glowMask);\n        \n        float reflMask = smooth4(.03, .045, .045, .06, orbitTrap-.1) +\n                         smooth4(.5, .9, 1.7, 1.8, orbitTrap);\n              \n        vec3 albedo   = lavaCol*.6 + .4;\n        vec3 emissive = lavaMask * lavaCol + \n                        glowMask * glowCol + \n                        reflMask * reflCol ;\n  \n        col += emissive*lum;\n        lum *= albedo;\n    }\n    \n    // Apply fog\n    col = mix(vec3(0,.01,.03), col, exp2(-t0*.8));\n        \n    if (reset) O.rgb = col;\n    else {\n        // Average frames\n        vec3 ocol = texture(iChannel0, F/iResolution.xy).rgb;\n        O.rgb = mix(ocol, col, isAnim ? .16 : 1./frame);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}