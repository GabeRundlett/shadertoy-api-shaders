{
    "Shader": {
        "info": {
            "date": "1704868552",
            "description": "The cool thing about curl noise is that you can just throw whatever the hell you want in there and it sorta just works",
            "flags": 32,
            "hasliked": 0,
            "id": "4cBGWt",
            "likes": 30,
            "name": "Curly Text",
            "published": 3,
            "tags": [
                "simulation",
                "curl",
                "particles"
            ],
            "usePreview": 0,
            "username": "TheBen27",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "\n// Most SDFs and operations taken from Inigo Quilez\n// Curl noise from the original paper: https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph2007-curlnoise.pdf\n\n// recoloring\n\nvec3 palette1(float color) {\n    return vec3(\n        smoothstep(0.0, 0.33, color),\n        smoothstep(0.33, 0.66, color),\n        smoothstep(0.66, 1.0, color)\n    );\n}\n\nvec3 palette2(float color) {\n    return vec3(\n        smoothstep(0.66, 1.0, color),\n        smoothstep(0.33, 0.66, color),\n        smoothstep(0.0, 0.33, color)\n    );\n}\n\nvec3 palette(vec2 uv, float color) {\n    return mix(palette1(color), palette2(color), vec3(smoothstep(-0.05, 0.05, sdCurl(uv))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 bufferB = texture(iChannel0, uv);\n    float value = bufferB.r;\n    fragColor = vec4(palette(uv, value), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// particle simulation\n\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat mapHash(uint h) {\n    return float(h) / float(0xffffffffU);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint x = uint(fragCoord.x);\n    uint y = uint(fragCoord.y);\n    // if this pixel will be ignored do not update it\n    if (x + y * uint(iResolution.x) > uint(particles)) {\n        return;\n    }\n    \n    uint hash = (x + 1u) * (y + 1u);\n    if (iFrame == 0 || iMouse.z > 0.0) {\n        // cycle through hashes to find a good starting seed\n        hashi(hash);\n        vec2 pos = vec2(\n            mapHash(hashi(hash)),\n            mapHash(hashi(hash))\n        );\n        float color = 0.5 + 0.5 * mapHash(hashi(hash));\n        fragColor = vec4(pos, color, 0.0);\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 pos = data.xy;\n    float color = data.z;\n    \n    // advect\n    vec2 vel = velocity(pos);\n    \n    // integrate\n    pos += vel * 0.001;\n    \n    #if 1\n    // move offscreen particles back onscreen\n    if (any(lessThan(pos, vec2(0.0))) || any(greaterThan(pos, vec2(1.0)))) {\n        pos = vec2(\n            mapHash(hashi(hash)),\n            mapHash(hashi(hash))\n        );\n    }\n    #endif\n    \n    fragColor = vec4(pos, color, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int particles = 1024;\n\nfloat rand(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 randv(vec2 n) {\n    float x = rand(n);\n    float y = rand(vec2(x, n.y));\n    return normalize(vec2(x, y) - 0.5);\n}\n\nvec2 fade(vec2 t) {\n                                                        // Fade function as defined by Ken Perlin.  This eases coordinate values\n                                                        // so that they will ease towards integral values.  This ends up smoothing\n                                                        // the final output.\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);   // 6t^5 - 15t^4 + 10t^3\n}\n\nfloat noise(vec2 uv, float freq) {\n    \n    // Get cell index and modulo\n    vec2 cn = floor(uv * freq);\n    vec2 mn = mod(uv, 1.0 / freq) * freq;\n    \n    // Find random gradients for the nearby cells\n    vec2 c00, c01, c10, c11;\n    c00 = randv(cn);\n    c01 = randv(cn + vec2(0.0, 1.0));\n    c10 = randv(cn + vec2(1.0, 0.0));\n    c11 = randv(cn + vec2(1.0, 1.0));\n    \n    // Find vector pointing to the current point\n    vec2 d00, d01, d10, d11;\n    d00 = mn - vec2(0.0, 0.0);\n    d01 = mn - vec2(0.0, 1.0);\n    d10 = mn - vec2(1.0, 0.0);\n    d11 = mn - vec2(1.0, 1.0);\n    \n    // Get the dot products of each value and mix them together\n    vec2 mni = fade(mn);\n    float top = mix(dot(c00, d00), dot(c10, d10), mni.x);\n    float bottom = mix(dot(c01, d01), dot(c11, d11), mni.x);\n    float mid = mix(top, bottom, mni.y);\n    \n\treturn mid * 0.5 + 0.5;\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat layeredNoise(vec2 uv) {\n    const int octaves = 1;\n    float v = 0.0;\n    float f = 4.0;\n    float a = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        v += a * noise(uv, f);\n        f *= 2.0;\n        s += a;\n        a /= 2.0;\n    }\n    return v / s;\n}\n\nconst float pi = 3.14159;\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nconst float outerRadius = 0.25;\nconst float innerRadius = 0.1;\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdC(vec2 p) {\n    float size = pi * 0.7;\n    vec2 sc = vec2(sin(size), cos(size));\n    p.y -= 0.015;\n    return sdArc(rot(pi * 0.5) * p, sc, outerRadius * 1.05, innerRadius);\n}\n\nfloat sdU(vec2 p) {\n    float rightBar = length(vec2(p.x - outerRadius, p.y - clamp(p.y, -0.25, 0.25))) - innerRadius;\n    \n    float size = pi * 0.5;\n    vec2 sc = vec2(sin(size), cos(size));\n    p = rot(pi) * p;\n    p.y = p.y - clamp(p.y, -outerRadius, 0.0);\n    \n    return min(rightBar, sdArc(p, sc, outerRadius, innerRadius));\n}\n\nfloat sdR(vec2 p) {\n    float leftBar = length(vec2(p.x, p.y - clamp(p.y, -0.25, 0.25))) - innerRadius;\n    \n    float size = pi * 0.1;\n    vec2 sc = vec2(sin(size), cos(size));\n    float topArc = sdArc(p - vec2(0.15, -0.1), sc, outerRadius, innerRadius);\n    \n    return min(leftBar, topArc);\n}\n\nfloat sdL(vec2 p) {\n    return length(vec2(p.x - outerRadius, p.y - clamp(p.y, -0.25, 0.5))) - innerRadius;\n}\n\nfloat sdCurl(vec2 p) {\n    p *= 3.0;\n    p -= vec2(1.6, 1.4);\n    float c = sdC(p - vec2(-0.875, 0.0));\n    float u = sdU(p - vec2(-0.21, 0.0));\n    float r = sdR(p - vec2(0.35, 0.0));\n    float el = sdL(p - vec2(0.6, 0.));\n    float borders = sdRoundedBox(p - vec2(-0.125, 0.065), vec2(1.25, 0.55), vec4(outerRadius));\n    return min(c, min(u, min(r, min(el, abs(borders) - innerRadius))));\n}\n\nfloat boundarySdf(vec2 pos) {\n    return sdCurl(pos);\n}\n\nfloat mainNoise(vec2 pos) {\n    float noise = layeredNoise(pos);\n    // scale field around boundaries\n    float scaleSize = 0.1;\n    float boundaryFactor = smoothstep(-1.0, 1.0, boundarySdf(pos) / scaleSize) * 2.0 - 1.0;\n    return noise * boundaryFactor;\n}\n\nvec2 velocity(vec2 pos) {\n    // curl of noise flow\n    const vec2 eps = vec2(0.001,0.0);\n    float dx = mainNoise(pos + eps) - mainNoise(pos - eps);\n    float dy = mainNoise(pos + eps.yx) - mainNoise(pos - eps.yx);\n    return normalize(vec2(dy, -dx)); // vec2(dy, -dx) / (2.0 * eps.xx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// particle rendering and trail simulation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iMouse.z > 0.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    #if 1\n    // displace trail with curl noise\n    vec2 dv = uv + 0.001 * velocity(uv);\n    float value = texture(iChannel1, dv).r;\n    value *= 0.99;\n    #else\n    // boring fade\n    float value = texture(iChannel1, uv).r;\n    #endif\n    value *= 0.993;\n    \n    for (float i = 0.0; i < float(particles); i++) {\n        float tx = mod(i, iResolution.x);\n        float ty = floor(i / iResolution.x);\n        vec4 particle = texelFetch(iChannel0, ivec2(tx, ty), 0);\n        vec2 pos = particle.xy;\n        float color = particle.z;\n        float size = smoothstep(0.005, 0.0, distance(pos, uv));\n        value = max(value, color * size);\n    }\n    \n    fragColor = vec4(value);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}