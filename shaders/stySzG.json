{
    "Shader": {
        "info": {
            "date": "1697008958",
            "description": "Aperiodic Wang Tiling. The four quadrants of each tile are coloured and in a valid tiling, the quadrant colours match across tile edges. Here, there are 16 tile types or colour combinations. Mouse to pan, up/down to zoom.",
            "flags": 48,
            "hasliked": 0,
            "id": "stySzG",
            "likes": 14,
            "name": "Aperiodic Wang Tiling",
            "published": 3,
            "tags": [
                "tiles",
                "wang",
                "aperiodic"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 321
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////\n//\n// Aperiodic Wang Tiling, mla, 2023\n//\n// Wang tilings, introduced by Hao Wang (王浩) in 1961, are\n// square tiles with colored edges. A valid tiling is one where\n// the colors on the edges of adjacent tiles match. The first set of\n// aperiodic tiles discovered, by Robert Berger in 1964, was a set of \n// 20476 Wang tiles. This number has been reduced since & in fact the\n// smallest aperiodic set of Wang tiles now known contains 11\n// tiles and it has been proved that no smaller set is possible.\n//\n// This shader uses the substitution rules for the 16 tile tiling \n// described in Grünbaum & Shephard. The grid is NxN where N is a \n// Fibonacci number and the recurrence splits the grid into two squares\n// and two rectangles, which are then treated as parts of a larger square.\n//\n// <mouse>: pan image\n// <up/down>: zoom in/out\n// m: disable mouse\n// r: rotate by 45°\n// x,y: grid line display\n//\n////////////////////////////////////////////////////////////////////\n\nconst float phi = 0.618033989; // NB, not 1.618..\n\n// 6 colors, 16 tile types\nconst int X = -1, A = 10, B = 11, C = 12, D = 13, E = 14, F = 15;\nivec4 transitions[] =\n  ivec4[](ivec4(X,X,X,2),ivec4(0,9,C,3),ivec4(0,B,E,3),ivec4(0,8,D,1),\n          ivec4(0,B,C,3),ivec4(0,8,C,7),ivec4(0,9,E,3),ivec4(0,9,D,5),\n          ivec4(X,X,D,1),ivec4(X,X,F,6),ivec4(X,X,C,7),ivec4(X,X,F,2),\n          ivec4(X,A,X,4),ivec4(X,8,X,1),ivec4(X,A,X,2),ivec4(X,9,X,5));\n\nivec4 colors[] =\n  ivec4[](ivec4(1,2,1,2),ivec4(3,4,3,4),ivec4(4,5,4,5),ivec4(6,3,6,3),\n          ivec4(4,5,3,4),ivec4(6,3,3,4),ivec4(3,4,4,5),ivec4(3,4,6,3),\n          ivec4(5,1,2,3),ivec4(4,1,2,6),ivec4(5,1,1,4),ivec4(3,2,2,6),\n          ivec4(2,6,4,1),ivec4(2,3,5,1),ivec4(2,6,3,2),ivec4(1,4,5,1));\n\nconst vec3 palette[] =\n  // \"Party Pastels\"\n  vec3[](vec3(182,230,189),vec3(172,154,241),vec3(247,200,238),\n         vec3(255,239,176),vec3(255,202,150),vec3(245,154,142));\n\nvec3 getcol(int i) {\n  vec3 col = palette[i-1]/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = mod(iTime,40.0);\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  float k = pow(phi,time);\n  if (!key(CHAR_Z)) z *= 10.0*k;\n  if (!key(CHAR_M) && iMouse.x > 0.0) z -= (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  if (key(CHAR_R)) z *= mat2(1,1,-1,1);\n  if (key(CHAR_C)) z = abs(z);\n  else z = (z+1.0);\n  z *= 0.5;\n  vec3 col = vec3(0.1,0,0);\n  int M = 1, N = 0;\n  for (int i = 0; i < int(time); i++) {\n    M = M+N; N = M-N; // I could just have a table of fib(i)\n  }\n  if (z.x >= 0.0 && z.x < 1.0 && z.y >= 0.0 && z.y < 1.0) {\n    int state = 1; // 1-7 are valid start states\n    z *= float(N+M);\n    float pwidth = fwidth(length(z));\n    ivec2 p = ivec2(z);\n    vec2 dx = dFdx(z), dy = dFdy(z);\n    z = fract(z);\n    while (N != 0) {\n      // Split region into (N+M)x(N+M) regions\n      // and recurse into the region our point is in,\n      // after applying the relevant state transition.\n      // Non-square subregions are treated as part of\n      // a larger square.\n      int sector = 2*int(p.x >= N)+int(p.y >= N);\n      state = transitions[state][sector];\n      assert(state >= 0);\n      if (p.x < N) p.x += M-N;\n      else p.x -= N;\n      if (p.y < N) p.y += M-N;\n      else p.y -= N;\n      N = M-N; M = M-N; // Think about it!\n    }\n    int icol = colors[state][int(z.x+z.y >= 1.0) + 2*int(z.x>=z.y)];\n    col = getcol(icol);\n    vec2 uv = 0.25*(vec2(state/4,state%4)+z);\n    col *= 2.0*textureGrad(iChannel0,uv,0.25*dx,0.25*dy).xyz;\n    if (!key(CHAR_X)) {\n      vec2 z1 = min(z,1.0-z);\n      float d = min(z1.x,z1.y);\n      col *= smoothstep(0.0,pwidth,d-0.0125);\n    }\n    if (!key(CHAR_Y)) {\n      float d = min(abs(z.x-z.y),abs(z.x+z.y-1.0));\n      col *= smoothstep(0.0,pwidth,d-0.01);\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (keystate(KEY_ALT,0).x == 0.0 && w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}