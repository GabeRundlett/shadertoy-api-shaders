{
    "Shader": {
        "info": {
            "date": "1706367383",
            "description": "Look mom, no tris!\nLacks anti-aliasing, but could be added.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfjSWD",
            "likes": 1,
            "name": "Warping Textured Quad",
            "published": 3,
            "tags": [
                "retro",
                "uv",
                "warp",
                "sampling",
                "quad"
            ],
            "usePreview": 1,
            "username": "WasabiThumbs",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "// Made by Wasabi (https://wasabithumb.github.io/)\n// Creator of warp3d (https://github.com/WasabiThumb/warp3d-kotlin)\n// Warp3D has always deserved to be a shader, now here it is!\n// Uses a magical expression to solve U/V coordinates.\n// This could be used to make many textured 3D objects.\n// This is how the concept was proven: https://www.desmos.com/calculator/s8evwnqxiy\n// May have been initially inspired by Sega Geneis, not sure what set me on this path anymore ;)\n\nfloat p;\nfloat o;\nfloat u;\nfloat t;\nfloat l;\nfloat k;\nfloat j;\nfloat h;\n\nfloat sampleU(vec2 fragCoord)\n{\n    float v = fragCoord.x/iResolution.x;\n    float b = fragCoord.y/iResolution.y;\n    \n    float v6 = (h - j) * o - (h - j) * p - (k - l) * t + (k - l) * u;\n    if (v6 == 0.0) return -1.0;\n    \n    float b2 = b * b;\n    float j2 = j * j;\n    float h2 = h * h;\n    float l2 = l * l;\n    float k2 = k * k;\n    \n    float two = 2.0;\n    \n    float v1 = b2 - two * b * h;\n    float v5  = (b2 - two * b * j + j2) * (o * o) - two * (b2 - b * h - (b - h) * j) * o * p\n    + (v1 + h2) * (p * p) + (b2 - two * b * l + l2) * (t * t) + (b2 - two * b * k + k2) * (u * u)\n    + (h2 - two * h * j + j2 - two * (h - j) * k + k2 + two * (h - j - k) * l + l2) * (v * v)\n    - two * ((b2 - b * j - (b - j) * l) * o - (b2 + b * h - two * b * j - two * (b - j) * k\n    + (b - h) * l) * p) * t + two * ((v1 + b * j + (b - j) * k - two * (b - h) * l) * o\n    - (b2 - b * h - (b - h) * k) * p - (b2 - b * k - (b - k) * l) * t) * u + two * ((b * h - (b - h) * j - j2\n    - (b - j) * k + (b - two * h + j) * l) * o - (b * h + h2 - (b + h) * j - (b + h - two * j) * k\n    + (b - h) * l) * p - (b * h - b * j - (b - two * j) * k + (b - h - j - k) * l + l2) * t\n    + (b * h - b * j - (b - h - j) * k - k2 + (b - two * h + k) * l) * u) * v;\n    \n    if (v5 < 0.0) return -1.0;\n    \n    float v2 = (b - j) * o - (b + h - two * j) * p - (b - l) * t;\n    float v3 = (b + k - two * l) * u;\n    float v4 = (h - j - k + l) * v;\n    float v7 = v2 + v3 + v4;\n    \n    v5 = sqrt(v5);\n    \n    float ret = 0.5 * (v7 - v5) / v6;\n    if (ret >= 0.0 && ret <= 1.0) return ret;\n    \n    ret = 0.5 * (v7 + v5) / v6;\n    if (isinf(ret) || isnan(ret)) return -1.0;\n    return ret;\n}\n\nfloat sampleV(vec2 fragCoord, float su)\n{\n    float v = fragCoord.x/iResolution.x;\n    float b = fragCoord.y/iResolution.y;\n    \n    float tx = p + (o - p) * su;\n    float bx = u + (t - u) * su;\n    \n    float diffX = bx - tx;\n    if (abs(diffX) < 0.01) {\n        float ty = l + (k - l) * su;\n        float by = j + (h - j) * su;\n        return (b - ty) / (by - ty);\n    }\n    return (v - tx) / diffX;\n}\n\nvoid calcVars() {\n    vec2 tl = vec2(0.1, 0.2);\n    tl += vec2(0.05 * cos(iTime), 0.05 * sin(iDate.w));\n    vec2 tr = vec2(0.9, 0.1);\n    tr += vec2(0.06 * sin(iTime * 0.8), 0.04 * cos(iDate.w * 0.8));\n    vec2 bl = vec2(0.2, 0.8);\n    bl += vec2(0.04 * sin(iTime * 0.9), 0.06 * cos(iDate.w * 1.1));\n    vec2 br = vec2(0.8, 0.9);\n    br += vec2(0.05 * cos(iTime * 1.2), 0.05 * sin(iDate.w * 1.2));\n    \n    p = tl.x;\n    o = tr.x;\n    u = bl.x;\n    t = br.x;\n    l = tl.y;\n    k = tr.y;\n    j = bl.y;\n    h = br.y;\n}\n\n// START Gaussian blur for background effect (https://www.shadertoy.com/view/ltScRG)\nconst int samples = 35,\n          LOD = 2,\n          sLOD = 1 << LOD;\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n// END Gaussian blur for background effect\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    calcVars();\n    float u = sampleU(fragCoord);\n    if (u > 0.0 && u < 1.0) {\n        float v = sampleV(fragCoord, u);\n        if (v > 0.0 && v < 1.0) {\n            fragColor = texture(iChannel0, vec2(u,v));\n            return;\n        }\n    }\n    fragColor = blur(iChannel0, fragCoord/iResolution.xy, 1./iChannelResolution[0].xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}