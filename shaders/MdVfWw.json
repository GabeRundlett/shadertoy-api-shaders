{
    "Shader": {
        "info": {
            "date": "1529186398",
            "description": "Trying to work out how VR works with Shadertoy (not much luck so far). So a quick sketch inspired by the cute balloon dogs from Henry",
            "flags": 1,
            "hasliked": 0,
            "id": "MdVfWw",
            "likes": 27,
            "name": "Balloon Dogs",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 1,
            "username": "shau",
            "viewed": 1070
        },
        "renderpass": [
            {
                "code": "#define T iTime\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0;\n    float w = 1.0;\n    float s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n// IQ anti-aliasing - see https://www.shadertoy.com/view/MtffWs\nvec3 pri(vec3 x) {\n    vec3 h = fract(x / 2.0) - 0.5;\n    return x * 0.5 + h * (1.0 - 2.0 * abs(h));\n}\n\nfloat checkersTextureGradTri(vec3 p, vec3 ddx, vec3 ddy) {\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01; // filter kernel\n    vec3 i = (pri(p + w) - 2.0 * pri(p) + pri(p - w)) / (w * w); // analytical integral (box filter)\n    return 0.5 - 0.5 * i.x *  i.y * i.z; // xor pattern\n}\n\nvec3 texCoords(vec3 p) {\n\treturn 5.0 * p;\n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(T * 0.013, 0.0), T * 0.013)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\n\nvec2 map(vec3 p) {\n\tp.xz *= rot(T);    \n    float ofs = pModPolar(p.xz, 5.0);\n    return vec2(dfDog(p - vec3(8.0, 0.0, 0.0), ofs, T), ofs);;    \n}\n\n//inner glow\nvec2 gmap(vec3 p) {\n\tp.xz *= rot(T);    \n    float ofs = pModPolar(p.xz, 5.0);\n    return vec2(gdfDog(p - vec3(8.0, 0.0, 0.0), ofs, T), ofs);;    \n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\nfloat AO(vec3 p, vec3 n) {\n\n    float r = 0.0;\n    float w = 1.0;\n    float d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(p + n * d).x);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//IQ https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float tmax) {\n\t\n    float res = 1.0;\n    float t = 0.0;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for(int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if (res < EPS || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    float t = 0.0, id = 0.0;\n    vec3 n = vec3(0.);\n    for (int i = 0; i < 98; i++) {\n        vec3 rp = ro + rd * t;\n        vec2 ns = map(rp);\n        if (ns.x < EPS || t > FAR) {\n            id = ns.y;\n            break;\n        }\n        t += ns.x * 0.6;\n    }\n    return vec2(t, id);\n}\n\n/*\n//balloom interior\nvec2 vMarch(vec3 ro, vec3 rd) {\n    float t = 0.0, gc1 = 0., gc2 = 0.;\n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        float ns = map(rp).x;\n        if (ns > 0.01 || t > FAR) break;\n        \n        vec2 gns = gmap(rp);\n        gc1 += 0.1 / (1.0 + gns.x * gns.x * 10.);\n        gc2 += 0.8 / (1.0 + gns.x * gns.x * 100.);\n        \n        t += 0.1;\n    }\n    return vec2(gc1, gc2);\n}\n*/\n\nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n    float did;\n};\n\nScene drawScene(vec3 ro, vec3 rd) {\n\n    float mint = FAR, id = 0., did = 0., rf = 0.;\n    vec3 minn = vec3(0.);\n    \n    vec3 fn = vec3(0.0, 1.0, 0.0), fo = vec3(0.0, -2.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < FAR) {\n        mint = ft;\n        minn = fn;\n        id = 1.0;\n    }\n    \n    vec2 t = march(ro, rd);\n        \n    if (t.x > 0.0 && t.x < mint) {\n        vec3 rp = ro + rd * t.x;\n        mint = t.x;\n        minn = normal(rp);\n        id = 2.0;\n        did = t.y;\n    }\n    \n    return Scene(mint, id, minn, did);\n}\n        \nvec3 colourScene(Scene scene, vec3 ro, vec3 rd) {\n \n    vec3 pc = vec3(0.);\n    vec3 lp = vec3(4.0, 5.0, -2.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float df = max(dot(ld, scene.n), 0.05);\n    float atn = 1.0 / (1.0 + lt * lt * 0.01);\n    float sh = 0.5 + 0.5 * shadow(rp, ld, 20.0);\n    float sp = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\n    float frs = pow(clamp(dot(scene.n, rd) + 1., 0., 1.), 2.);\n\n    if (scene.id == 1.0) {\n        \n        // calc texture sampling footprint\t\n        vec3 uvw = texCoords(rp * 0.08);\n\t\tvec3 ddx_uvw = dFdx(uvw); \n    \tvec3 ddy_uvw = dFdy(uvw);\n        float fc = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n        fc = clamp(fc, 0.2, 0.8);\n        pc = ac * (fc + noise(fc + rp * vec3(8.0 * fc, 1.0 *fc * 2.0, 0.5))) * df * atn * sh;\n\n    } else if (scene.id == 2.0) {\n\n        float ao = AO(rp, scene.n);\n        df = max(dot(ld, scene.n), 0.8);\n\n        //finally tried implemnting some of IQs suggestions and removed vMarch\n        vec3 sc = palette((T + (scene.did + 2.0) * 2.0) * 0.1, CA, CB, CC, CD);\n        pc = sc * ao;\n        pc *= 1. - ao * 0.6;\n        pc += sc * frs * 0.6;\n        pc *= df;\n        //pc *= df * 2.;\n        pc += vec3(1.) * sp;\n        \n        //vec2 vc = vMarch(rp, rd);;\n        //pc += sc * vc.x; //fake balloon volume\n        //pc += sc * vc.y * max(sin(T * 0.4), 0.0); //glow\n    }\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    ro = lookAt + vec3(0.0, 6.0 + sin(T * 0.5) * 5.0, -17.0 - sin(T * 0.3) * 3.);\n\n    ro.xz *= rot(T * -0.2);\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    \n    vec3 pc = clouds(rd) * ac * 2.0;\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.id > 0.0) {\n        pc = colourScene(scene, ro, rd);\n        //reflection\n        vec3 rro = ro + rd * (scene.t - EPS);\n        vec3 rrd = reflect(rd, scene.n);\n        Scene rs = drawScene(rro, rrd);\n        vec3 rc = colourScene(rs, rro, rrd);\n        float rfatn = 1.0 / (1.0 + rs.t * rs.t * 0.1);\n        pc += rc * rfatn * 0.5;\n    }\n    \n    return pc; \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    fragColor = vec4(render(ro, rd), 1.0);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {    \n    fragColor = vec4(render(fragRayOri * 4. + vec3(0.0,1.0,1.5), fragRayDir), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592\n#define FAR 50.0 \n#define EPS 0.005\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\nconst vec3 ac = vec3(1.0, 0.6, 0.05);\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\n\n/* Distance functions IQ & Mercury */\n\nfloat sdCaps(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;    \n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.0;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\n/* Model - g prefix = glow */\n\nfloat dfEars(vec3 p, float T) {\n    p.z = abs(p.z);\n    p.yz *= rot(1.1 + sin(T * 4.0) * 0.3);\n    p.xy *= rot(-0.8);\n    return smin(sdCaps(p, vec3(0.0, 0.6, 0.0), vec3(0.0, 0.9, 0.0), 0.4),\n                sdCaps(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.9, 0.0), 0.1), 0.2);  \n}\n\nfloat gdfEars(vec3 p, float T) {\n    p.z = abs(p.z);\n    p.yz *= rot(1.1 + sin(T * 4.0) * 0.3);\n    p.xy *= rot(-0.8);\n    return sdCaps(p, vec3(0.0, 0.7, 0.0), vec3(0.0, 0.8, 0.0), 0.02);\n}\n\nfloat dfSnout(vec3 p) {\n    p.xy *= rot(-0.2);\n    return smin(sdCaps(p, vec3(-0.5, 0.0, 0.0), vec3(-0.9, 0.0, 0.0), 0.4),\n                sdCaps(p, vec3(0.0, 0.0, 0.0), vec3(-1.4, 0.0, 0.0), 0.1), 0.2); \n}\n\nfloat gdfSnout(vec3 p) {\n    p.xy *= rot(-0.2);\n    return sdCaps(p, vec3(-0.6, 0.0, 0.0), vec3(-0.8, 0.0, 0.0), 0.02);\n}\n\nfloat dfHead(vec3 p, float ofs, float T) {\n    p.xy *= rot(0.4 + sin(T * 2.0) * 0.2);\n    float neck = smin(sdCaps(p, vec3(0.0, 0.6, 0.0), vec3(0.0, 1.1, 0.0), 0.4),\n                      sdCaps(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.7, 0.0), 0.1), 0.2); \n    float head = dfSnout(p - vec3(0.0, 1.7, 0.0));\n    float ears = dfEars(p - vec3(0.0, 1.7, 0.0), T);\n    float knot = sdSphere(p - vec3(0.0, 1.7, 0.0), 0.16);\n    return min(min(head, knot), min(neck, ears));\n}\n\nfloat gdfHead(vec3 p, float ofs, float T) {\n    p.xy *= rot(0.4 + sin(T * 2.0) * 0.2);\n    float neck = sdCaps(p, vec3(0.0, 0.8, 0.0), vec3(0.0, 0.9, 0.0), 0.02);\n    float head = gdfSnout(p - vec3(0.0, 1.7, 0.0));\n    float ears = gdfEars(p - vec3(0.0, 1.7, 0.0), T);\n    return min(head, min(neck, ears));\n}\n\nfloat dfLegs(vec3 p, float a) {\n    p.z = abs(p.z);\n    p.yz *= rot(-0.6);\n    p.xy *= rot(a);\n    return smin(sdCaps(p, vec3(0.0, -0.6, 0.0), vec3(0.0, -1.6, 0.0), 0.4),\n                sdCaps(p, vec3(0.0, 0.0, 0.0), vec3(0.0, -2.1, 0.0), 0.1), 0.2);\n}\n\nfloat gdfLegs(vec3 p, float a) {\n    p.z = abs(p.z);\n    p.yz *= rot(-0.6);\n    p.xy *= rot(a);\n    return sdCaps(p, vec3(0.0, -1.0, 0.0), vec3(0.0, -1.2, 0.0), 0.02);\n}\n\nfloat dfTail(vec3 p, float a) {\n    p.yz *= rot(a);\n    p.xy *= rot(-0.5);\n    return smin(sdCaps(p, vec3(0.0, 0.6, 0.0), vec3(0.0, 1.0, 0.0), 0.4),\n                sdCaps(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.5, 0.0), 0.1), 0.2);  \n}\n\nfloat gdfTail(vec3 p, float a) {\n    p.yz *= rot(a);\n    p.xy *= rot(-0.5);\n    return sdCaps(p, vec3(0.0, 0.7, 0.0), vec3(0.0, 0.9, 0.0), 0.02);\n}\n\nfloat dfDog(vec3 p, float ofs, float T) {\n    \n    p.xz *= rot(PI * -0.5);\n    p.y -= 1.0 - sin((T + ofs) * 2.0); //jump\n    \n    float body = smin(sdCaps(p, vec3(-0.85, 0.0, 0.0), vec3(0.85, 0.0, 0.0), 0.4),\n                     sdCaps(p, vec3(-1.4, 0.0, 0.0), vec3(1.4, 0.0, 0.0), 0.1), 0.2);\n\tbody = min(body, sdSphere(p - vec3(-1.4, 0.0, 0.0), 0.16));\n\tbody = min(body, sdSphere(p - vec3(1.4, 0.0, 0.0), 0.16));\n               \n    vec3 q = p;\n    q.x = abs(q.x);\n    float legs = dfLegs(q - vec3(1.4, 0.0, 0.0), 0.5 + sin((T + ofs) * 2.0) * 0.4);\n    \n    float waggle = sin(T * 8.0) * 0.4; //waggle tail\n    float tail = dfTail(p - vec3(1.4, 0.0, 0.0), waggle); \n    float head = dfHead(p - vec3(-1.4, 0.0, 0.0), ofs, T);\n\n    return min(body, min(tail, min(head, legs)));\n}\n\nfloat gdfDog(vec3 p, float ofs, float T) {\n    \n    p.xz *= rot(PI * -0.5);\n    p.y -= 1.0 - sin((T + ofs) * 2.0); //jump\n    \n    float body = sdCaps(p, vec3(-0.5, 0.0, 0.0), vec3(0.5, 0.0, 0.0), 0.02);\n               \n    vec3 q = p;\n    q.x = abs(q.x);\n    float legs = gdfLegs(q - vec3(1.4, 0.0, 0.0), 0.5 + sin((T + ofs) * 2.0) * 0.4);\n    \n    float waggle = sin(T * 8.0) * 0.4; //waggle tail\n    float tail = gdfTail(p - vec3(1.4, 0.0, 0.0), waggle); \n    float head = gdfHead(p - vec3(-1.4, 0.0, 0.0), ofs, T);\n\n    return min(body, min(tail, min(head, legs)));\n}\n\n//https://www.shadertoy.com/view/lsdXDH\nvec4 desaturate(vec3 c, float f) {\n\tvec3 lum = vec3(0.299, 0.587, 0.114);\n\tvec3 gray = vec3(dot(lum, c));\n\treturn vec4(mix(c, gray, f), 1.0);\n}\n\nvec3 saturate(vec3 c) {\n    return clamp(c, 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}