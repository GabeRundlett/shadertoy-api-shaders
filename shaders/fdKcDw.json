{
    "Shader": {
        "info": {
            "date": "1654975295",
            "description": "...",
            "flags": 0,
            "hasliked": 0,
            "id": "fdKcDw",
            "likes": 7,
            "name": "my second raymarching",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "SONENEIS",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "/*settings*/\n#define AA 1\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define STEPS 256\n#define EPSILON 0.001\n/*end settings*/\n\n#define pi 3.14159265\n#define tau pi * 2.0\n\n//random\nfloat hash(float v){return fract(sin(v*dot(vec2(737.873,777.873),vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec3 uv){return fract(sin(dot(uv,vec3(173.873,515.526,726.873)))*82723.782);}\n\n//noise 1d\nfloat noise(float a){\n\tfloat f = fract(a);\n\tfloat h = f*f*(3.0-2.0*f);\n\treturn mix(hash(a),hash(a + 1.0),h);\n}\n\n//noise 2d\nfloat noise(vec2 uv){\n\tvec2 e = vec2(0.0,1.0);\n\tvec2 p = floor(uv);\n\tvec2 f = smoothstep(0.0,1.0,fract(uv));\n\treturn mix(\n\t\tmix(hash(p + e.xx),hash(p + e.yx),f.x),\n\t\tmix(hash(p + e.xy),hash(p + e.yy),f.x),\n\t\tf.y\n\t);\n}\n\n//noise 3d\nfloat noise(vec3 uv3d){\n\tvec2 e = vec2(0.0,1.0);\n\tvec3 s = vec3(110.0,241.0,171.0);\n\tvec3 i = floor(uv3d);\n\tvec3 f = fract(uv3d);\n\tfloat n = dot(i,s);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\tfloat x1 = mix(hash(n + dot(s,e.xxx)),hash(n + dot(s,e.yxx)),u.x);\n\tfloat x2 = mix(hash(n + dot(s,e.xyx)),hash(n + dot(s,e.yyx)),u.x);\n  float y1 = mix(hash(n + dot(s,e.xxy)),hash(n + dot(s,e.yxy)),u.x);\n  float y2 = mix(hash(n + dot(s,e.xyy)),hash(n + dot(s,e.yyy)),u.x);\n\treturn mix(mix(x1,x2,u.y),mix(y1,y2,u.y),u.z);\n}\n\n//clamp zero one\n#define czo(a) clamp(a,0.0,1.0)\n\n//integer mix\n#define imix(a,b,k) mix(float(a),float(b),k)\n\n//vector min\nfloat vmin(vec2 a){return min(a.x,a.y);}\nfloat vmin(vec3 a){return min(min(a.x,a.y),a.z);}\nfloat vmin(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n\n//vector max\nfloat vmax(vec2 a){return max(a.x,a.y);}\nfloat vmax(vec3 a){return max(max(a.x,a.y),a.z);}\nfloat vmax(vec4 a){return max(max(a.x,a.y),max(a.z,a.w));}\n\n//square\nfloat sq(float a){return pow(a,2.0);}\nvec2 sq(vec2 a){return pow(a,vec2(2.0));}\nvec3 sq(vec3 a){return pow(a,vec3(2.0));}\nvec4 sq(vec4 a){return pow(a,vec4(2.0));}\n\n//length square\n//length square\n#define lsq(a) dot(a,a)\n\n//smooth min\nfloat smin(float a,float b,float k){\n\tfloat h = czo(0.5 + 0.5*(b-a)/k);\n\treturn mix(b,a,h) - k*h*(1.0-h);\n}\n\n//smooth max\n#define smax(a,b,k) -smin(-a,-b,k)\n\nstruct Object{\n  float f;\n  vec3 p;\n\tfloat id;\n\tvec3 col;\n};\n\n//3d sdf primitives\nObject fSphere(float id,vec3 uv3d,float rad,vec3 col){\n\tfloat sphere = length(uv3d) - rad;\n\treturn Object(sphere,uv3d,id,col);\n}\nObject fEllipsoid(float id,vec3 uv3d,vec3 rad,vec3 col){\n  float p1 = length(uv3d/rad);\n  float p2 = length(uv3d/sq(rad));\n  float elli = p1*(p1-1.0)/p2;\n\treturn Object(elli,uv3d,id,col);\n}\nObject fCube(float id,vec3 uv3d,float size,vec3 col){\n\tvec3 p = abs(uv3d) - size;\n\tfloat cube = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Object(cube,uv3d,id,col);\n}\nObject fBox(float id,vec3 uv3d,vec3 size,vec3 col){\n\tvec3 p = abs(uv3d) - size;\n\tfloat box = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Object(box,uv3d,id,col);\n}\nObject fBoxInfinity(float id,vec3 uv3d,vec2 size,vec3 col){\n\tvec2 p = abs(uv3d.xy) - size;\n\tfloat box = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Object(box,uv3d,id,col);\n}\nObject fTorus(float id,vec3 uv3d,vec2 t,vec3 col){\n\tfloat torus = length(vec2(length(uv3d.xz)-t.x,uv3d.y))-t.y;;\n\treturn Object(torus,uv3d,id,col);\n}\nObject fCylinder(float id,vec3 uv3d,vec2 h,vec3 col){\n  vec2 p = abs(vec2(length(uv3d.xz),uv3d.y)) - h;\n  float cylin = min(max(p.x,p.y),0.0) + length(max(p,0.0));\n\treturn Object(cylin,uv3d,id,col);\n}\nObject fLine(float id,vec3 uv3d,float rad,vec3 v1,vec3 v2,vec3 col){\n\tvec3 a = uv3d-v1,b = v2-v1;\n\tfloat line = length(a - b*czo(dot(a,b)/lsq(b))) - rad;\n\treturn Object(line,uv3d,id,col);\n}\nObject fConeRound(float id,vec3 uv3d,float d,float r1,float r2,vec3 col){\n  vec2 p = vec2(length(uv3d.xz),uv3d.y);\n\n  float b = (r1-r2)/d;\n  float a = sqrt(1.0-sq(b));\n  float k = dot(p,vec2(-b,a));\n\n  float cone;\n  if(k < 0.0) cone = length(p) - r1;\n  else if(k > a*d) cone = length(p-vec2(0.0,d)) - r2;\n  else cone = dot(p,vec2(a,b)) - r1;\n\n\treturn Object(cone,uv3d,id,col);\n}\nObject fPlane(float id,vec3 uv3d,float d,vec3 n,vec3 col){\n\tfloat plane = dot(uv3d,n) - (-d);\n\treturn Object(plane,uv3d,id,col);\n}\n\n//3d sdf operations\n//union\nObject fOpUnion(Object a,Object b){\n  if(a.f < b.f) return a;\n  else return b;\n}\nObject fOpUnionSmooth(Object a,Object b,float k,float div){\n  Object res;\n  float h = czo(0.5 + 0.5*(a.f-b.f)/k);\n  res.f = smin(a.f,b.f,k);\n  res.col = mix(a.col,b.col,czo(0.5+0.5*(a.f-b.f)/k));\n  res.id = mix(a.id,b.id,h) < div ? a.id : b.id;\n  res.p = mix(a.p,b.p,h) == a.p ? a.p : b.p;\n\treturn res;\n}\n//intersection\nObject fOpIntersection(Object a,Object b){\n  if(a.f > b.f) return a;\n  else return b;\n}\nObject fOpIntersectionSmooth(Object a,Object b,float k,float div){\n  Object res;\n  float h = czo(0.5 - 0.5*(b.f-a.f)/k);\n  res.f = smax(a.f,b.f,k);\n  res.col = mix(a.col,b.col,czo(0.5+0.5*(a.f-b.f)/k));\n  res.id = mix(a.id,b.id,h) < div ? a.id : b.id;\n  res.p = mix(a.p,b.p,h) == a.p ? a.p : b.p;\n\treturn res;\n}\n//difference\nObject fOpDifference(Object a,Object b){\n\ta.f = -a.f;\n\treturn fOpIntersection(a,b);\n}\nObject fOpDifferenceSmooth(Object a,Object b,float k,float div){\n  Object res;\n  float h = czo(0.5 - 0.5*(a.f+b.f)/k);\n  res.f = smax(-a.f,b.f,k);\n  res.col = mix(a.col,b.col,czo(0.5+0.5*(a.f-b.f)/k));\n  res.id = mix(b.id,a.id,h) < div ? a.id : b.id;\n  res.p = mix(b.p,a.p,h) == a.p ? a.p : b.p;\n\treturn res;\n}\n\n//rotation matrices\nmat3 rotateX(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(1,0,0),\n\t\tvec3(0,c,-s),\n\t\tvec3(0,s,c)\n\t);\n}\nmat3 rotateY(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,0,s),\n\t\tvec3(0,1,0),\n\t\tvec3(-s,0,c)\n\t);\n}\nmat3 rotateZ(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,-s,0),\n\t\tvec3(s,c,0),\n\t\tvec3(0,0,1)\n\t);\n}\n\n/*texture mapping algorithms*/\n//triplanar mapping\nvec3 fTextureTP(sampler2D tex,vec3 uv3d,vec3 normal){\n  normal = uv3d;\n  normal = abs(normal);\n  normal = pow(normal,vec3(5.0));\n  normal /= normal.x + normal.y + normal.z;\n  return\n  texture(tex,uv3d.xy + 0.5).rgb * normal.z +\n  texture(tex,uv3d.xz + 0.5).rgb * normal.y +\n  texture(tex,uv3d.yz + 0.5).rgb * normal.x;\n}\n//bump mapping\nvec3 fTextureBP(sampler2D tex,vec3 uv3d){\n  return vec3(0.0);\n}\n\n//background\nvec3 bgCol(){return vec3(0.2,0.6,1.0);}\nvec3 mist(){return vec3(0.85,0.9,1.0);}\nvec3 background(vec3 rd){\n\tvec3 bg = vec3(0.0);\n\n  bg += bgCol() - 0.7*rd.y;\n  bg = mix(bg,mist(),exp(-10.0*rd.y));\n\n  if(rd.y < 0.0) bg = mist();\n\n\treturn bg;\n}\n\nObject scene(vec3 uv3d){\n\tObject dist = Object(1.0,uv3d,-1.0,vec3(0.0));\n\n\tObject ball;\n\t{\n\t  vec3 p = uv3d;\n\t  p *= rotateX(iTime);\n\t  p *= rotateY(iTime);\n\t  p *= rotateZ(iTime);\n\n\t  ball = fSphere(-1.0,\n\t\t  p,0.6,\n\t\t  vec3(1.0,0.0,0.0)\n\t  );\n\n\t  ball.f += sin(p.x*5.0)*sin(p.y*5.0)*sin(p.z*5.0) * 0.2;\n\t  ball.f += sin(p.x*20.0)*sin(p.y*20.0)*sin(p.z*20.0) * 0.02;\n  }\n\n\tObject elli = fEllipsoid(-1.0,\n\t\tuv3d,vec3(0.6,0.3,0.1),\n\t\tvec3(1.0,0.5,0.0)\n\t);\n\n\tObject cube = fCube(-1.0,\n\t\tuv3d,0.45,\n\t\tvec3(0.9,0.35,0.1)\n\t);\n\tcube.f -= 0.1;\n\n\n\tObject torus = fTorus(-1.0,\n\t\tuv3d,vec2(0.5,0.2),\n\t\tvec3(1.0,0.6,0.1)\n\t);\n\n\t{\n\t\tvec3 p = uv3d.zyx;\n\n    Object door;\n\t  {\n\t  \tvec3 p = uv3d;\n\n\t  \tp.z = abs(p.z) - 1.5;\n\n\t  \tp.x = mod(p.x,2.0) - 1.0;\n\n\t    Object box = fBox(-1.0,\n\t    \tp,vec3(0.3,0.5,0.4),\n\t    \tvec3(1.0) //vec3(0.1,0.4,1.0)\n  \t  );\n  \t  Object cylin = fCylinder(-1.0,\n  \t  \tp.xzy - vec3(0.0,0.0,0.5),\n  \t  \tvec2(0.3,0.4),\n  \t  \tvec3(1.0) //vec3(0.1,0.4,1.0)\n\t    );\n\n      door = fOpUnion(cylin,box);\n    }\n\n\t\tp.x = abs(p.x) - 1.5;\n\n    Object wall = fBoxInfinity(-1.0,\n\t  \tp,vec2(0.1,1.0) - 0.1,\n\t  \tvec3(1.0)\n\t  );\n\t  wall.f -= 0.1;\n\n    //dist = wall;\n    //dist = door;\n    dist = fOpDifferenceSmooth(door,wall,0.05,0.0);\n    //dist = fOpDifference(door,wall);\n  }\n\n\tObject line = fLine(2.0,\n\t\tuv3d,0.05,\n\t\tvec3(0.0,0.0,0.0),\n\t\tvec3(0.5,0.5,0.5),\n\t\tvec3(1.0)\n\t);\n\n\tObject rcone = fConeRound(-1.0,\n\t\tuv3d,0.35,0.4,0.3,\n\t\tvec3(1.0,0.45,0.5)\n\t);\n\n\t/*rotating cube*/ {\n\t\tvec3 p = uv3d;\n\t\tp *= rotateX(iTime)*rotateY(iTime)*rotateZ(iTime);\n\n    float rad = 0.5;\n    rad += sin(p.x*10.0)*sin(p.y*10.0)*sin(p.z*10.0) * 0.05;\n\n    vec3 color = normalize(p)*0.5 + 0.5;\n\n\t  Object cube = fCube(-1.0,p,rad,color);\n\n\t  //dist = cube;\n  }\n\n  /*texture cube*/ {\n\t\tvec3 p = uv3d;\n\t\tp *= rotateX(iTime)*rotateY(iTime)*rotateZ(iTime);\n\n    float round = 0.0;\n    float rad = 0.5 - round;\n    //rad += sin(p.x*10.0)*sin(p.y*10.0)*sin(p.z*10.0) * 0.05;\n\n\t  Object cube = fCube(0.0,p,rad,vec3(0.0));\n\t  cube.f -= round;\n\n\t  //dist = cube;\n  }\n\n\tObject ground = fPlane(-1.0,\n\t\tuv3d,0.6,vec3(0.0,1.0,0.0),\n\t\ttexture(iChannel0,uv3d.zx*0.5).rgb\n\t\t//vec3(0.5+0.5*mod(floor(uv3d.x*5.0)+floor(uv3d.y*5.0)+floor(uv3d.z*5.0),2.0))\n\t);\n\n  //dist = fOpDifferenceSmooth(ball,cube,0.1,5.0);\n  //dist = fOpUnionSmooth(cube,ball,0.025,9.0);//,0.025);\n  dist = fOpUnion(dist,ball);\n\n  dist = fOpUnionSmooth(dist,ground,0.75,0.0);\n  //dist = fOpUnionSmooth(dist,ground,0.5,0.001);\n\n  //dist = fOpIntersection(dist,ground);\n  //dist = fOpIntersectionSmooth(dist,ground,0.5,6.0);\n\n  //dist = fOpDifference(dist,ground);\n  //dist = fOpDifferenceSmooth(dist,ground,0.5,0.75);\n\n  //dist = fOpDifference(ground,dist);\n  //dist = fOpDifferenceSmooth(ground,dist,0.5,0.1);\n\n  return dist;\n}\n\nObject raymarch(vec3 ro,vec3 rd){\n\tfloat dist = MIN_DIST;\n\tObject hit;\n\n\tfor(int i=0;i<STEPS;i++){\n\t\tvec3 uv3d = ro + dist*rd;\n\t\thit = scene(uv3d);\n\t\tif(abs(hit.f) < EPSILON || dist > MAX_DIST) break;\n\t\tdist += hit.f;\n\t}\n\n\treturn Object(dist,hit.p,hit.id,hit.col);\n}\n\nfloat getShadow(vec3 ro,vec3 rd){\n\tfloat start = 0.0, end = 3.0;\n\tfloat k = 10.0;\n\tfloat shadow = 1.0;\n\n\tfor(float d=start;d<end;){\n\t\tfloat hit = scene(ro + d*rd).f;\n\n\t\tif(hit < 0.001) return 0.0;\n\t\tshadow = min(shadow,k*hit/d);\n\n\t\td += hit;\n\t}\n\n\treturn shadow;\n}\n\nfloat getAmbOcc(vec3 ro,vec3 rd){\n  float occ = 0.0;\n  float w = 1.0;\n\n  for(float i=0.0;i<8.0;i++){\n  \tfloat len = 0.1 + 0.01*sq(i);\n  \tfloat dist = scene(ro + len*rd).f;\n  \tocc += (len - dist) * w;\n  \tw *= 0.85;\n  }\n\n  return 1.0 - czo(0.5 * occ);\n}\n\nvec3 getNormal(vec3 uv3d){\n\tvec2 e = vec2(1.0,-1.0) * EPSILON;\n\treturn normalize(vec3(\n\t\te.xyy * scene(uv3d + e.xyy).f +\n\t\te.yyx * scene(uv3d + e.yyx).f +\n\t\te.yxy * scene(uv3d + e.yxy).f +\n\t\te.xxx * scene(uv3d + e.xxx).f\n\t));\n}\n\nvec3 getMaterial(Object obj,vec3 normal){\n\tvec3 m = vec3(0.0);\n\n  switch(int(obj.id)){\n  \tdefault:\n  \t  m += vec3(1.0);\n  \t  break;\n\n  \tcase -1:\n  \t  m += obj.col;\n  \t  break;\n\n  \tcase 0:\n  \t  m += fTextureTP(iChannel1,obj.p,normal);\n  \t  break;\n  \tcase 1:\n  \t  m += texture(iChannel0,obj.p.zx).rgb;\n  \t  break;\n  }\n\n\treturn m;\n}\n\nstruct Light{\n\tvec3 pos;\n\tvec3 col;\n\tvec3 add;\n};\nLight light(vec3 uv3d,vec3 ro,vec3 rd,Object obj,vec3 pos,vec3 col){\n  Light res;\n\tres.pos = pos;\n\tres.col = col;\n\n  vec3 L = normalize(pos - uv3d);\n  vec3 N = getNormal(uv3d);\n  vec3 R = reflect(-L,N);\n  vec3 V = -rd;\n\n  vec3 color = getMaterial(obj,N);\n\tvec3 bg = background(rd);\n\n  //phong\n  vec3 speCol = vec3(1.0,1.0,1.0) * 0.5;\n  vec3 ambient = color * 0.05;\n  vec3 diffuse = color * czo(dot(L,N));\n  vec3 specular = speCol * pow(czo(dot(R,V)),10.0);\n\n  vec3 fresnel = 0.25 * color * pow(1.0 + dot(rd,N),3.0);\n\n  //shadow\n  float shadow = getShadow(uv3d+N*0.02,normalize(pos));\n  //float shadow = raymarch(uv3d+N*0.02,normalize(pos)).f;\n  //length(L)\n  //if(shadow < MAX_DIST && obj.id != Light_ID)\n  //  return Light(pos,col,ambient + fresnel);\n\n  //ambient occlusion\n  float occ = getAmbOcc(uv3d,N);\n\n  //back\n  vec3 back = 0.05 * color * czo(dot(N,-L));\n\n  //res.add = pow(abs(N),vec3(5.0));\n  //res.add = back;\n  //res.add = 0.9 * vec3(1.0) * occ;\n  res.add = (back + ambient + fresnel) * occ + (diffuse * occ + specular) * shadow;\n  //res.add = (ambient + fresnel) * occ + (diffuse * occ + specular) * shadow;\n  //res.add = ambient + (diffuse + specular) * shadow;\n  //res.add = ambient + diffuse + specular;\n\n\treturn res;\n}\n\nmat3 lookAt(vec3 ro,vec3 la){\n\tvec3 cf = normalize(ro - la);\n\tvec3 cr = normalize(cross(vec3(0,1,0),cf));\n\tvec3 cu = normalize(cross(cf,cr));\n\n\treturn mat3(cr,cu,cf);\n}\n\nvec2 getUV(vec2 offset,vec2 fragCoord){\n\treturn (2.0 * (fragCoord - offset) - iResolution.xy)/iResolution.y;\n}\n\nvec3 render(vec2 uv){\n  vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  //camera\n  float fov = 1.0;\n  vec3 la = vec3(0.0,0.0,0.0);\n  vec3 ro = vec3(0.0,0.5,3.0);\n\n  ro *= rotateX(mouse.y * pi * 0.5 - 0.5);\n  ro *= rotateY(-mouse.x * tau * 2.0 + 1.0);\n\n  vec3 rd = lookAt(ro,la) * normalize(vec3(uv,-fov));\n\n  Object obj = raymarch(ro,rd);\n  {\n    vec3 uv3d = ro + obj.f*rd;\n    vec3 normal = getNormal(uv3d);\n\n    vec3 bg = background(rd);\n    vec3 material = vec3(0.0);\n\n\t  Light sun = light(uv3d,ro,rd,obj,\n  \t  vec3(30.0,40.0,-30.0),\n\t    vec3(1.0,1.0,1.0)\n  \t);\n    material  += sun.add;\n\n    if(obj.f < MAX_DIST){\n      col += material;\n\n      //gamma correction\n      col = pow(col,vec3(1.0/2.2));\n      //mist\n      col = mix(col,mist(),1.0-exp(-1e-5*pow(obj.f,3.0)));\n    }else{\n    \tcol = bg;\n    }\n  }\n\n  return col;\n}\n\nvoid renderAAx4(inout vec3 color,vec2 c){\n\tvec4 e = vec4(0.125,-0.125,0.375,-0.375);\n\tvec3 colAA = render(getUV(e.xz,c)) + render(getUV(e.yw,c)) + render(getUV(e.wx,c)) + render(getUV(e.zy,c));\n\tcolor += colAA / 4.0;\n}\nvoid renderAAx1(inout vec3 color,vec2 c){\n\tcolor += render(getUV(vec2(0.0),c));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec3 col = vec3(0.0);\n\n  if(AA == 1) renderAAx1(col,fragCoord);\n  else if(AA == 4) renderAAx4(col,fragCoord);\n\n  fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}