{
    "Shader": {
        "info": {
            "date": "1563739741",
            "description": "A little galaxy raymarcher from my game engine, pasted in some IQ bits to fill the gaps.",
            "flags": 33,
            "hasliked": 0,
            "id": "wtfSzH",
            "likes": 8,
            "name": "Galaxy Test",
            "published": 3,
            "tags": [
                "raymarch",
                "space",
                "galaxy"
            ],
            "usePreview": 0,
            "username": "Zeliss",
            "viewed": 1150
        },
        "renderpass": [
            {
                "code": "#ifdef GL_EXT_texture3D\n#define SAMPLER iChannel2\n#else\n#define SAMPLER iChannel0\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n\tvec2 uv = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n    //Shameless theft of IQ's camera setup\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    vec3 ro = 50.0*normalize(vec3(sin(3.0*m.x), 1.4*m.y, cos(4.0*m.x)));\n    ro += vec3(10.0*cos(iTime/5.0), 10.0, 10.0*sin(iTime/5.0)+10.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera(ro, ta, 0.0);\n    // ray\n    vec3 rd = ca * normalize(vec3(uv, 1.0));\n\n#ifdef CUBEMAP_RENDER\n    fragColor = texture(iChannel0, rd);\n#else\n    fragColor = texelFetch(iChannel3, ivec2(fragCoord-0.5), 0);\n#endif\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{\n\tfragColor = texture(iChannel0, fragRayDir);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifdef GL_EXT_texture3D\n#define SAMPLER iChannel2\n#else\n#define SAMPLER iChannel0\n#endif\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n#ifdef CUBEMAP_RENDER\n    vec4 color = vec4(0.0);\n    rayOri += vec3(10.0*cos(iTime/5.0)+50.0, 10.0, 10.0*sin(iTime/5.0));\n    //Could probably do some better per-pixel noise for the cubemap.\n\tmainCommon(SAMPLER, iChannel1, iFrame, color, fragCoord, rayOri, rayDir);\n#ifdef ACCUMULATE\n    fragColor = mix(texture(iChannel3, rayDir), color, freshness);\n#else\n    fragColor = color;\n#endif\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "//Maximum number of steps through the volume\n//(actually will be less than this from sphere clipping)\n//Unfortunately due to attenuation applied each step, colors are affected by sample count.\n//This is certainly solvable, I just haven't taken the time to do it yet.\nint samples = 10;\n//1.0 means fresh pixels every frame, nearer 0.0 means use more of the accumulation buffer.\nfloat freshness = 0.1;\n//Uncomment to render to a cubemap instead of Buffer A (needed for VR)\n//#define CUBEMAP_RENDER\n\nuniform sampler2D rgba_noise;\n\nvec3 eye_pos = vec3(0.0);\nfloat brightness = 1.0;\nfloat rotation = 643.0;\nfloat galaxy_diameter = 115.0;\n//arm_width, noise_scale, noise_strength, spiral_density\nvec4 tweaks1 = vec4(2.85, 4.45, 4.7, 2.8);\n//diffuse_intensity, light_step_distance, emission_strength, disk_height\nvec4 tweaks2 = vec4(1.0, 0.2, 1.0, 8.71);\n//bulge_width, bulge_mask_radius, bulge_mask_power, bulge_width_squared\nvec4 bulge = vec4(17.3, 9.95, 2.18, 300.0);\nvec4 transmittance = vec4(0.8, 0.9, 0.98, 1.0);\nfloat render_dist = 100.0;\nvec3 spiral_origin = vec3(0.0);\n\nconst float PHI = 1.61803398874989; //Golden ratio\nconst float PI = 3.1415926535;\nconst float INVPI = 1.0/PI;\nconst float E = 2.7182818284;\nconst vec3 bulge_color = vec3(0.992, 0.941, 0.549);\n\n#define BOUNDING_SPHERE\n#define ACCUMULATE\n#define NOISE //Controls if rays are jittered relative to neighbor pixels\n//#define BACK_TO_FRONT\n\n//Somewhat-fast check if a sample point is within the galaxy\nbool in_galaxy(vec3 p)\n{\n\tfloat l = length(p.xz);\n\tfloat d = l*l / bulge.w;\n\treturn l < galaxy_diameter && (abs(p.y) < tweaks2.w/(d + 1.0) || length(p)/bulge.y < 2.0);\n}\n\n//Density of the spiral portion of the galaxy, no noise or profile, etc.\nfloat spiral_density(vec3 p)\n{\n\tfloat r = atan(p.x, p.z) + //Polar coordinates\n\t\trotation / 3000.0 * length(p.xz);\n\treturn pow(\n\t\tsin(2.0 * r) * 0.5 + 0.5, //Smoothly wrap to 0.0-1.0. Could possibly replace with fract?\n\t\ttweaks1.x);\n}\n\n//Returns discriminant in x, lambda1 in y, lambda2 in z.\nvec3 sphereIntersection(vec3 p, vec3 d, vec4 s)\n{\n\t//Solve the quadratic equation to find a lambda if there are intersections.\n\t//Since d is unit length, a = dot(d,d) is always 1\n\tvec3 o = p-s.xyz;\n\t//If we move the 2-factor off b, and the 4-factor off c in the discriminant,\n\t//We can eliminate one multiply, and move the other into the \"if\", making it slightly faster.\n\tfloat b = dot(d,o);\n\tfloat c = dot(o,o) - s.w*s.w;\n\n\tfloat discriminant = b*b - c;\n\tif (discriminant >= 0.0) {\n\t\tfloat sqd = sqrt(discriminant);\n\t\t//If discriminant == 0, there's only one intersection, and lambda1 == lambda2.\n\t\t//This should be fairly uncommon.\n\t\tfloat lambda1 = -b-sqd;\n\t\tfloat lambda2 = -b+sqd;\n\t\treturn vec3(discriminant, lambda1, lambda2);\n\t}\n\t//No intersection.\n\treturn vec3(discriminant, 0.0, 0.0);\n}\n\n#ifdef GL_EXT_texture3D\n#define SAMPLERTYPE sampler3D\n#else\n#define SAMPLERTYPE sampler2D\n#endif\n\nfloat noise(in SAMPLERTYPE sampler, in vec3 x)\n{\n#ifdef GL_EXT_texture3D\n    return textureLod(sampler, x/15.0, 0.0).r*2.0;\n#else\n    //Shameless theft of IQ's noise function for now\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(sampler, (uv+ 0.5)/256.0, 0. ).yx;  \n    \n\treturn -1.+2.0*mix( rg.x, rg.y, f.z );\n#endif\n}\n\n//Returns noise at a position, with a certain number of octaves\nfloat snoise_oct(in SAMPLERTYPE sampler, vec3 v, int oct)\n{\n\tfloat sum = 0.0;\n\tfloat q = 1.0;\n\tfor (int i = 0; i < 10 && i < oct; i++) {\n\t\tfloat s = abs(noise(sampler, v*q));\n\t\tq *= 2.;\n\t\tsum += s / q;\n\t}\n\treturn sum;\n}\n\n//Density of the galaxy, accounting for spiral, noise, galaxy profile, disk radius.\nfloat galaxy_density(in SAMPLERTYPE sampler, vec3 p, float bulge_density, float noise_scale, float noise_strength)\n{\n\tfloat s = 1.0;\n\t//Distort the sample point by noise (domain transformation)\n\t//This line is responsible for a lot of the visual interest of the spiral,\n\t//and is probably the first thing that should be tweaked to improve the appearance.\n\tp += (normalize(p) * (snoise_oct(sampler, p / noise_scale, 3) - 0.4)) * noise_strength; //Domain transformation.\n\ts *= spiral_density(p);\n\tfloat d2 = dot(p.xz, p.xz) / bulge.w;\n\treturn tweaks1.w *\n\t\tmax(s, bulge_density) * //Spiral and bulge\n\t\t(1.0 - smoothstep(0., tweaks2.w/(1.0 + d2), abs(p.y))) * //Galaxy profile\n\t\t(1.0 - smoothstep(0., galaxy_diameter, 2.*length(p.xz))); //Fade spiral out into disk shape\n}\n\n//Unscientific mapping of (I think, been a while since I wrote this) density to a color.\nvec3 color_ramp(float v)\n{\n\t// return vec3(smoothstep(0, 100, 1.0));\n\treturn vec3(\n\t\tsmoothstep(70., 100., v),\n\t\tsmoothstep(20., 100., v),\n\t\tsmoothstep(0., 100., v));\n}\n\nvec3 raymarch(SAMPLERTYPE sampler, vec3 ray_start, vec3 step, float max_dist)\n{\n\tfloat step_dist = length(step);\n\tfloat dist = 0.0;\n\tvec3 color = vec3(0.0);\n\tvec3 sdt = vec3(1.0);\n\n\tvec3 p = ray_start;\n\t/*if (si.x <= 0) */{\n\t\tfor (int i = 0; i < samples && dist < max_dist; i++, dist += step_dist, p += step) {\n\n\t\t\t// float r = d/2.0;\n\t\t\tvec3 p2 = p - spiral_origin;\n\t\t\tif (in_galaxy(p2)) {\n\t\t\t\tfloat lp2 = length(p2);\n\n\t\t\t\tfloat bulge_density = pow(max(2.0 - lp2/bulge.y, 0.0), bulge.z);\n\t\t\t\tfloat density = galaxy_density(sampler, p2, bulge_density, tweaks1.y, tweaks1.z);\n\t\t\t\tfloat clamped_density = clamp(density, 0.0, 1.0);\n\t\t\t\tfloat eps = tweaks2.y;\n\t\t\t\tfloat dif = clamp(\n\t\t\t\t\t(galaxy_density(sampler, p2 - eps*normalize(p2), bulge_density, tweaks1.y, tweaks1.z) - density) / eps,\n\t\t\t\t\t0.0, 1.0);\n\n\t\t\t\tsdt *= transmittance.xyz*(1.0 - clamped_density);\n\t\t\t\t// float clamped_bulge_density = clamp(bulge_density, 0.0, 1.0);\n\t\t\t\tfloat bulge_light_intensity = bulge.y*bulge.y * 2.0 * PI / (10.0 * lp2); //Roughly solid angle of bulge from p2's vantage point.\n\n#ifdef BACK_TO_FRONT\n\t\t\t\tcolor =\n\t\t\t\t\t(\n\t\t\t\t\t\tcolor + //Color from previous steps\n\t\t\t\t\t\tmix(color_ramp(clamped_density * step_dist * 30.0), bulge_color * bulge_density, bulge_density) * tweaks2.z + //Emissivity\n\t\t\t\t\t\tbulge_light_intensity * tweaks2.x * dif*bulge_color //Diffuse lighting\n\t\t\t\t\t) *\n\t\t\t\t\t(vec3(1.0) - transmittance.xyz*clamped_density); //Attenuation\n#else\n\t\t\t\tif (length(sdt) < 0.005) {\n\t\t\t\t\t// samples = i;\n\t\t\t\t\t// color = vec3(1.0, 0.0, 0.0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcolor +=\n\t\t\t\t\t(\n\t\t\t\t\t\tmix(color_ramp(clamped_density * step_dist * 30.0), bulge_color * bulge_density, bulge_density) + //Emissivity\n\t\t\t\t\t\tbulge_light_intensity * tweaks2.x * dif*bulge_color //Diffuse lighting\n\t\t\t\t\t) * sdt; //Attenuation\n#endif\n\t\t\t}\n\t\t}\n\t}\n\treturn clamp(color * brightness, 0.0, 100000.0);\n}\n\n//Shameless theft of IQ's setCamera\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat perPixelStartBias(in sampler2D sampler, in int frame)\n{\n\treturn fract(4.0*textureLod(sampler, gl_FragCoord.xy/256.,1.).r + PHI * float(frame));\n}\n\nvoid mainCommon(in SAMPLERTYPE sampler, in sampler2D sbSampler, in int frame, out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    float start_bias = 0.0;\n\tfloat max_dist = render_dist;\n\n\t#ifdef BOUNDING_SPHERE\n\t\tvec3 si = sphereIntersection(eye_pos, rd, vec4(spiral_origin-ro, galaxy_diameter/2.0));\n\t\tstart_bias += max(0.0, si.y); //Second intersection with the sphere\n\t\tmax_dist = min(si.z, render_dist);\n\t#endif\n\n\tfloat step_dist = render_dist / float(samples);\n\tvec3 step = rd * step_dist;\n\n\t#ifdef BACK_TO_FRONT\n\t\tro = (max_dist * rd) + ro;\n\t\tstep = -step;\n\t#endif\n\n\t#ifdef NOISE\n    \tstart_bias += step_dist * perPixelStartBias(sbSampler, frame);\n\t#else\n\t\tfloat golden_step = mod(PHI * float(iFrame) * step_dist, step_dist) / step_dist;\n\t\tstart_bias += golden_step * step_dist;\n\t#endif\n\n\tro += rd*start_bias;\n\tfragColor = vec4(raymarch(sampler, ro, step, max_dist+start_bias), freshness);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#ifdef GL_EXT_texture3D\n#define SAMPLER iChannel2\n#else\n#define SAMPLER iChannel0\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#ifndef CUBEMAP_RENDER\n\tvec2 uv = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n    //Shameless theft of IQ's camera setup\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    vec3 ro = 50.0*normalize(vec3(sin(3.0*m.x), 1.4*m.y, cos(4.0*m.x)));\n    ro += vec3(10.0*cos(iTime/5.0), 10.0, 10.0*sin(iTime/5.0)+10.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera(ro, ta, 0.0);\n    // ray\n    vec3 rd = ca * normalize(vec3(uv, 1.0));\n\n    mainCommon(SAMPLER, iChannel1, iFrame, fragColor, fragCoord, ro, rd);\n#ifdef ACCUMULATE\n    fragColor.xyz = mix(texelFetch(iChannel3, ivec2(fragCoord-0.5), 0 ).xyz, fragColor.xyz, freshness);\n#endif\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}