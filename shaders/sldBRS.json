{
    "Shader": {
        "info": {
            "date": "1663293666",
            "description": "colored 2D variation of \"Anaglyph Sphere Waves\" - [url]www.shadertoy.com/view/ftdfW8[/url]\n\n\nSubstance Reference: Psilocin + DMXE (Deoxymethoxetamine)",
            "flags": 0,
            "hasliked": 0,
            "id": "sldBRS",
            "likes": 1,
            "name": "Colored Sphere Waves",
            "published": 3,
            "tags": [
                "3d",
                "sphere",
                "mirror"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "//                   = Colored Sphere Waves =         \n//                by  Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n\n#define MAX_STEPS 300\n#define MAX_DIS 500.\n#define MIN_DIS 20.\n\n#define SURF_DIS .001\n#define SURF_MUL 100.\n#define SURF_EXP 2.\n\n#define iTime iTime*.5\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Dist(vec3 p) \n{\n    p.xy *= Rot(smoothstep(-.2,.2,sin(iTime/15.))*.785);\n    p.xz *= Rot((smoothstep(-.8,.0,sin(iTime/12.))*2.-1.)*1.57+1.57);\n\n    float f = 1./(300.+sin(iTime/11.)*120.-sin(iTime/9.)*80.+sin(iTime/7.)*50.);\n    float dis = length(p)*f;\n    \n    p.xy *= Rot(p.z/MAX_DIS*(smoothstep(.2,1.,sin(iTime/13.)) - smoothstep(-.2,-1.,sin(iTime/13.)))*6.28);\n\n    vec3 size = vec3(20.+sin(iTime/33.)*5.);\n    p = mod(abs(-mod(p,4.*size)+2.*size),4.*size);    \n\n    float d = length(p - sin(iTime*.5+dis*6.28)*size.x-size) - \n              (10.+sin(iTime/33.)*5.)*(sin(iTime*1.5+dis*6.28)*.5+.8)*\n              (1.+.5*smoothstep(0.8,1.,sin(iTime/3.+dis/f/200.))); \n\n    return d;\n}\n\nvec3 RTM(vec3 ro, vec3 rd) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIS;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0.);\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIS * (pow(d/MAX_DIS, SURF_EXP)*SURF_MUL+1.));\n        if (s < sd || d > MAX_DIS) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        s = Dist(p);\n        s = max(abs(s), 2.*sd);\n        d += s * 0.5;\n        sum += a;\n    }\n    \n    return vec3(smoothstep(0., 1., sum * (1.-exp(-d*d))), tanh(s/150.), float(steps) / float(MAX_STEPS));\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0.,1.,0.), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    vec3 ro = vec3( 0., 0., -80.);\n    vec3 rd = R(uv, ro, vec3(0.), .3 + .8*smoothstep(.5,1.,sin(iTime/12.)));\n    vec3 r = RTM(ro, rd);\n    \n    vec3 col = vec3(r.y*r.z+r.y+r.x*.1, r.z-r.x*.4+r.y*.4, r.x-r.y);\n    col *= smoothstep(2.,-2./5., dot(uv,uv)); \n    vec3 colS = smoothstep(vec3(0.), vec3(1.), vec3(col));\n    \n    fragColor = vec4(colS, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}