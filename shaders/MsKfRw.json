{
    "Shader": {
        "info": {
            "date": "1528301470",
            "description": "crosshatch effect\nor...  \"when voxels wed pixels by pencil\"\n...also works on videos (or cam), but i needed a break from britney and jcvd ;-)\nsee [url]https://www.shaderoo.org/?shader=8Yw3Q8[/url] for video version",
            "flags": 32,
            "hasliked": 0,
            "id": "MsKfRw",
            "likes": 141,
            "name": "when voxels wed pixels",
            "published": 3,
            "tags": [
                "voxels",
                "effect",
                "crosshatch",
                "pencil",
                "drawing",
                "handdrawing"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 5927
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// crosshatch effect\n\n// wedding of voxels and SDF\n\n// try to enable FAKE_VOXEL_AO (in Buf A) if its very slow on your machine\n\n#define FLICKER 1.\n\n#define PI2 6.28318530718\n#define sc (iResolution.x/600.)\n    \nvec2 roffs;\nfloat ramp;\nfloat rsc;\n\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    return uv+.6*sin(uv*res*PI2)/PI2/res;\n}\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres=vec2(textureSize(iChannel1,0));\n    //vec2 fr=fract(pos-.5);\n    //vec2 uv=(pos-.7*sin(fr*PI2)/PI2)/tres.xy;\n    vec2 uv=pos/tres.xy;\n    uv=uvSmooth(uv,tres);\n    return textureLod(iChannel1,uv,0.);\n}\n\nvec4 getCol(vec2 pos)\n{\n    vec4 r1 = (getRand((pos+roffs)*.05*rsc/sc+iTime*131.*FLICKER)-.5)*10.*ramp;\n    vec2 res0=vec2(textureSize(iChannel0,0));\n    vec2 uv=(pos+r1.xy*sc)/iResolution.xy;\n    //uv=uvSmooth(uv,res0);\n    vec4 c = texture(iChannel0,uv);\n    vec4 bg= vec4(vec3(clamp(.3+pow(length(uv-.5),2.),0.,1.)),1);\n    bg=vec4(1);\n    //c = mix(c,bg,clamp(dot(c.xyz,vec3(-1,2,-1)*1.5),0.,1.));\n    float vign=pow(clamp(-.5+length(uv-.5)*2.,0.,1.),3.);\n    //c = mix(c,bg,vign);\n    return c;\n}\n\nfloat getVal(vec2 pos)\n{\n    return clamp(dot(getCol(pos).xyz,vec3(.333)),0.,1.);\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx)\n        )/eps/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // subtraction of 2 rand values, so its [-1..1] and noise-wise not as white anymore\n    vec4 r = getRand(fragCoord*1.2/sqrt(sc))-getRand(fragCoord*1.2/sqrt(sc)+vec2(1,-1)*1.5);\n    // white noise\n    vec4 r2 = getRand(fragCoord*1.2/sqrt(sc));\n    \n    // outlines\n    float br=0.;\n    roffs = vec2(0.);\n    ramp = .7;\n    rsc=.7;\n    int num=3;\n    for(int i=0;i<num;i++)\n    {\n        float fi=float(i)/float(num-1);\n    \tfloat t=.03+.25*fi, w=t*2.;\n        // one closely matched edge-line\n    \tramp=.15*pow(1.3,fi*5.); rsc=1.7*pow(1.3,-fi*5.);\n    \tbr+=.6*(.5+fi)*smoothstep(t-w/2.,t+w/2.,length(getGrad(fragCoord,.4*sc))*sc);\n        // another wildly varying edge-line\n    \tramp=.3*pow(1.3,fi*5.); rsc=10.7*pow(1.3,-fi*5.);\n    \tbr+=.4*(.2+fi)*smoothstep(t-w/2.,t+w/2.,length(getGrad(fragCoord,.4*sc))*sc);\n    \t//roffs += vec2(13.,37.);\n    }\n    fragColor.xyz=vec3(1)-.7*br*(.5+.5*r2.z)*3./float(num);\n    fragColor.xyz=clamp(fragColor.xyz,0.,1.);\n    \n    \n    // cross hatch\n    ramp=0.;\n    int hnum=5;\n    #define N(v) (v.yx*vec2(-1,1))\n    #define CS(ang) cos(ang-vec2(0,1.6))\n    float hatch = 0.;\n    float hatch2 = 0.;\n    float sum=0.;\n    for(int i=0;i<hnum;i++)\n    {\n \t\tfloat br=getVal(fragCoord+1.5*sc*(getRand(fragCoord*.02+iTime*1120.).xy-.5)*clamp(FLICKER,-1.,1.))*1.7;\n        // chose the hatch angle to be prop to i*i\n        // so the first 2 hatches are close to the same angle, \n        // and all the higher i's are fairly random in angle\n    \tfloat ang=-.5-.08*float(i)*float(i);\n    \tvec2 uvh=mat2(CS(ang),N(CS(ang)))*fragCoord/sqrt(sc)*vec2(.05,1)*1.3;\n    \tvec4 rh = pow(getRand(uvh+1003.123*iTime*FLICKER+vec2(sin(uvh.y),0)),vec4(1.));\n    \thatch += 1.-smoothstep(.5,1.5,(rh.x)+br)-.3*abs(r.z);\n    \thatch2 = max(hatch2, 1.-smoothstep(.5,1.5,(rh.x)+br)-.3*abs(r.z));\n    \tsum+=1.;\n    \tif( float(i)>(1.-br)*float(hnum) && i>=2 ) break;\n    }\n    \n    fragColor.xyz*=1.-clamp(mix(hatch/sum,hatch2,.5),0.,1.);\n    \n\n    fragColor.xyz=1.-((1.-fragColor.xyz)*.7);\n    // paper\n    fragColor.xyz *= .95+.06*r.xxx+.06*r.xyz;\n    fragColor.w = 1.;\n    \n    if(true)\n    {\n    \tvec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    \tfloat vign = 1.-.3*dot(scc,scc);\n    \tvign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*40.);\n    \tvign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*20.);\n    \tfragColor.xyz *= vign;\n    }\n    \n    //fragColor.xyz=getCol(fragCoord).xyz;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// wedding of voxels and SDF\n\n// try to enable FAKE_VOXEL_AO if its very slow on your machine\n\n#define SHADOW\n//#define FAKE_VOXEL_AO\n//#define GRID_LINES\n\n// some quaternion functions\n\n#define PI2 (3.141592653*2.)\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1) * sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n//vec3 light=normalize(vec3(cos(iTime),sin(iTime),sin(iTime*.17)));\nvec3 light=normalize(vec3(1,.6,.3));\n\nfloat torusDist(vec3 pos, float R, float r)\n{\n    return length(vec2(length(pos.xy)-R,pos.z))-r;\n}\n\n#define randSampler iChannel0\n\nvec4 getRand(vec3 texc)\n{\n    // nonlinear interpolation experiment by adding a sine to texcoords\n    texc+=.6*sin(texc*256.*PI2)/PI2/256.;\n    float z=texc.z*256.+.5;\n    float fz=floor(z);\n    vec4 v1 = textureLod( randSampler, texc.xy+(fz     *vec2(17.0,7.0))/256.0, 0.0);\n    vec4 v2 = textureLod( randSampler, texc.xy+((fz+1.)*vec2(17.0,7.0))/256.0, 0.0);\n    return mix( v1, v2, fract(z) );\n}\n\nfloat distGradX;\n\nfloat distTor(vec3 pos)\n{\n    vec4 q = vec4(0,0,0,1);\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),PI2*.125));\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),iTime*.5+2.));\n    pos=transformVecByQuat(pos,q);\n    \n    pos+=.100*(getRand(pos*.015).xyz-.5);\n    pos+=.050*(getRand(pos*.030).xyz-.5);\n    pos+=.025*(getRand(pos*.060).xyz-.5);\n    float d=torusDist(pos+vec3(.33,0,0),.66,.22+/*(pos.x+.33)**/distGradX);\n    d=min(d,torusDist((pos-vec3(.33,0,0)).xzy,.66,.22+/*(pos.x-.33)**/-distGradX));\n    return d;\n}\n\n#define iMouseData vec4(0)\nfloat dist(vec3 pos)\n{\n    return distTor(pos);\n}\n\nvec3 grad(vec3 pos, float eps)\n{\n    vec3 d=vec3(eps,0,0);\n    return vec3(\n        dist(pos+d.xyz)-dist(pos-d.xyz),\n        dist(pos+d.zxy)-dist(pos-d.zxy),\n        dist(pos+d.yzx)-dist(pos-d.yzx)\n        )/eps/2.;\n}\n\nbool checkSolid(vec3 pos)\n{\n    return dist(pos)-.00<.0;\n}\n\nbool gridStep(inout vec3 pos, inout vec3 n, vec3 grid, vec3 dir)\n{\n    float l,lmin=10000.;\n    vec3 s = sign(dir);\n    // find next nearest cube border (.00001 -> step a tiny bit into next cube)\n    vec3 next=floor(pos/grid+s*(.5+.00001)+.5)*grid; // assuming floor(x+1.)==ceil(x)\n    l=(next.x-pos.x)/dir.x; if (l>0. && l<lmin) { lmin=l; n=-vec3(1,0,0)*s; }\n    l=(next.y-pos.y)/dir.y; if (l>0. && l<lmin) { lmin=l; n=-vec3(0,1,0)*s; }\n    l=(next.z-pos.z)/dir.z; if (l>0. && l<lmin) { lmin=l; n=-vec3(0,0,1)*s; }\n    \n    pos+=dir*lmin;\n    return checkSolid((floor((pos-.5*n*grid)/grid)+.5)*grid);\n}\n\nbool march(inout vec3 pos, vec3 dir, inout float dmin)\n{\n    bool rval=false;\n    float eps=.001;\n    float dtot=0.;\n    dmin=10000.;\n    float dp=dist(pos);\n    for(int i=0;i<100;i++)\n    {\n        float d=dist(pos);\n        if(d<dp) dmin=min(d,dmin);\n        dp=d;\n        d*=.8;\n        pos+=d*dir;\n        dtot+=d;\n        if(d<eps) { rval=true; break; }\n        if(dtot>4.) { pos-=(dtot-4.)*dir; break; }\n    }\n    return rval;\n}\n\nbool march(inout vec3 pos, vec3 dir)\n{\n    float dmin;\n    return march(pos,dir,dmin);\n}\n\n#define GRID vec3(.05)\n\nint stepAny(inout vec3 pos, in vec3 dir, inout vec3 n)\n{\n    distGradX=0.;\n    vec3 startPos=pos;\n    vec3 posV = pos;\n    vec3 nV = vec3(0,0,1);\n    bool bgV = true;\n    for(int i=0;i<100;i++)\n    {\n        if(gridStep(posV,nV,GRID,dir)) { bgV=false; break; }\n    }\n    if (bgV) { n=light; posV=startPos+4.*dir; }\n    \n    distGradX=.1;\n    vec3 posN = startPos;\n    vec3 nN = vec3(0,0,1);\n    bool bgN=!march(posN,dir);\n    nN=grad(posN,.01);\n    if (bgN) { nN=light; posN=startPos+4.*dir; }\n    \n    pos=posN; n=nN;\n    if (bgV && bgN) return 0;\n    if (length(posV-startPos)>length(posN-startPos)) return 1;\n    pos=posV; n=nV; \n    return 2;\n}\n\nvec4 getRand( int idx )\n{\n    ivec2 res=textureSize(iChannel0,0);\n    return texelFetch(iChannel0,ivec2(idx%res.x,(idx/res.x)%res.y),0);\n}\n\nvec4 getRand( vec2 pos )\n{\n    vec2 res=vec2(textureSize(iChannel0,0));\n    return texture(iChannel0,pos/res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ph=iMouse.x/iResolution.x*7.;\n    float th=-(iMouse.y/iResolution.y-.5)*3.;\n    if(iMouse.x<1.) th=-0.1;\n    if(iMouse.y<1.) ph=2.3;\n    vec3 fwd = vec3(vec2(cos(ph),sin(ph))*cos(th),sin(th));\n    vec3 right=normalize(vec3(fwd.yx*vec2(1,-1),0));\n    vec3 up=cross(right,fwd);\n    vec3 startPos=-fwd*2.5*(1.-iMouseData.z*.001);\n    vec3 pos=startPos;\n    vec2 sc=(fragCoord/iResolution.xy-.5)*2.*vec2(1,iResolution.y/iResolution.x);\n    vec3 dir=normalize(fwd*1.6+right*sc.x+up*sc.y);\n    vec3 n=vec3(0,0,1);\n    float ao=1.;\n    float sh=1.;\n    float br=1.;\n    float ao1,sh1,ao2,sh2;\n    vec3 posS,nS;\n\n    int m = stepAny(pos,dir,n);\n    #ifdef SHADOW\n    posS=pos+n*.005;\n    int s = stepAny(posS,light,nS);\n    sh = (s==0)?1.:0.;\n    #endif\n\n    #ifdef GRID_LINES\n    if(m==2){\n        vec3 s=sin(pos/GRID*PI2*.5);\n        br*=1.-.15*(dot(exp(-s*s/.05),vec3(1))-1.);\n        br*=1.-.075*(dot(exp(-s*s/.5),vec3(1))-1.);\n    }\n    #endif\n    \n    ao=1.;\n    #ifndef FAKE_VOXEL_AO\n    ao=0.;\n    #define AONUM 24\n    for(int i=0;i<AONUM;i++)\n    {\n        vec3 r=2.*(getRand(i+int(getRand(fragCoord).x*147.)+int(123.*pos.x+37.*pos.y+17.*pos.y)).xyz-.5);\n        r-=dot(r,n)*n*.5;\n        vec3 posC=pos+n*.02+r*.04;\n        distGradX=0.;\n        float solid=0.;\n        if(dist((floor(posC/GRID)+.5)*GRID)<0.) solid=1.;\n        distGradX=.1;\n        if(dist(posC)<0.) solid=1.;\n        ao+=solid;\n    }\n    ao=clamp(1.-ao/float(AONUM),0.,1.);\n    #else\n    if(m==2) { distGradX=.0; ao*=clamp(.8+.25*(dist(pos)+.03)/GRID.x,0.,1.); }\n    if(m==1) { \n            ao-=.5*max(.15-dist(pos+n*.1),0.);\n        \tao-=.5*max(.30-dist(pos+n*.2),0.);\n        \tao-=.5*max(.60-dist(pos+n*.4),0.);\n    }\n    #endif\n    ao*=1.-5.*max(.1-dist(pos+n*.2),0.);\n    ao*=1.-8.*max(.05-dist(pos+n*.1),0.);\n    \n    float amb=.25;\n    float fog=clamp(1.5-.5*length(pos),0.,1.);\n    float diff=clamp(dot(normalize(n),normalize(light)),0.,1.)*.6;\n    fragColor.xyz=vec3(mix(diff*sh,ao,amb))*br;\n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}