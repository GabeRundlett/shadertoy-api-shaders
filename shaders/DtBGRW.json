{
    "Shader": {
        "info": {
            "date": "1681731522",
            "description": "Implementing GGX for PBR with approximate multiscattering for learning\nHas depth of field with a number of custom bokeh shapes to choose from\n\nMouse drag to look around\nDefines in Common",
            "flags": 32,
            "hasliked": 0,
            "id": "DtBGRW",
            "likes": 22,
            "name": "PBR GGX BRDF",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "pathtracing",
                "brdf",
                "pbr",
                "ggx",
                "mutliscattering"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 650
        },
        "renderpass": [
            {
                "code": "\n// PBR GGX BRDF by gelami\n// https://www.shadertoy.com/view/DtBGRW\n\n/* \n * Implementing GGX for PBR with approximate multiscattering for learning\n * Has depth of field with a number of custom bokeh shapes to choose from\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * List of bokeh shapes:\n *   Circle, Square, Polygon, Star, Heart,\n *   Crescent (Rejection sampling and approx.), Cross + 4 Circles, Annulus / 2D Torus, E\n * \n * For the crescent shape, there seems to be no exact way to uniformly sample it\n * You can do rejection sampling, but it takes too many tries when the crescent becomes thin\n * So an approximation I did is to sample on the two arcs of the cresent in a sine PDF,\n * and interpolate between them\n * \n * Here's the Desmos graph for the sampling:\n * https://www.desmos.com/calculator/uwcqvxdsjc\n * \n * I tried to implement random-walk multiscattering\n * but haven't gotten it to work yet though T_T\n * \n * Resources:\n * \n * - PBR implementation:\n * \n * Physically Based Rendering in Filament\n * https://google.github.io/filament/Filament.md.html\n *\n * - Multiscattering GGX approximation:\n * \n * A Multi-Faceted Exploration\n * https://blog.selfshadow.com/2018/05/13/multi-faceted-part-1/\n * \n * Revisiting Physically Based Shading at Imageworks\n * https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n * \n * Multiscattering BRDF Energy Compensation\n * https://patapom.com/blog/BRDF/MSBRDFEnergyCompensation/\n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-01-04 08:38:20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n        col = texelFetch(iChannel0, ivec2(1, 0), 0).rgb;\n    \n    col *= exp2(EXPOSURE);\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// 0 : Grid of spheres\n// 1 : Single sphere\n#define SCENE 0\n\n// 0 : Fake iridescent-like color\n// 1 : Metallic colors\n// 2 : White\n#define COLOR 1\n\n// Shape type of depth of field\n// 0 : Circle\n// 1 : Square\n// 2 : Polygon\n// 3 : Star\n// 4 : Heart\n// 5 : Crescent\n// 6 : Cross + 4 Circles\n// 7 : Annulus / 2D Torus\n// 8 : E\n#define DOF_TYPE 3\n\n// Number of sides for Polygon and Star shapes\n#define DOF_SIDES 5\n\n#define DOF_STRENGTH 0.1\n\n#define DOF_AUTOFOCUS\n#define DOF_FOCUS_DISTANCE 0.75\n\n#define ENABLE_SKY_STARS\n#define SKYBOX_STRENGTH 1.0\n#define EXPOSURE 0.0\n\n#define BOUNCES 4\n\n// 0: No importance sampling\n// 1: D importance sampling\n// 2: VNDF importance sampling\n#define GGX_IMPORTANCE_SAMPLING 2\n\n// 0: No Multiscattering\n// 1: Approx\n// 2: Random walk // TODO: Brokey T_T\n#define GGX_MULTISCATTERING 1\n\n//#define WHITE_FURNACE_TEST\n//#define STATIC_CAM\n//#define NO_ACCUMULATE\n\n#define MIN_ROUGHNESS 0.045\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPSILON 1e-3\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n#define INV_PI (1.0 / PI)\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 color;\n    vec3 emissive;\n    float roughness;\n    float metallic;\n    float transmission;\n    float clearcoat;\n    float ior;\n};\n\nstruct HitInfo\n{\n    float t;\n    vec3 normal;\n    vec3 bumpNormal;\n    bool inside;\n};\n\nHitInfo NewHitInfo()\n{\n    return HitInfo(MAX_DIST, vec3(0), vec3(0), false);\n}\n\nMaterial DefaultMaterial()\n{\n    return Material(vec3(1), vec3(0), 1.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nbool noHit(HitInfo hit)\n{\n    return hit.t >= MAX_DIST;\n}\n\nvec3 reorientedNormalMapping(vec3 n1, vec3 n2)\n{\n    vec3 t = (n1*0.5+0.5) * vec3( 2,  2, 2) + vec3(-1, -1,  0);\n    vec3 u = (n2*0.5+0.5) * vec3(-2, -2, 2) + vec3( 1,  1, -1);\n    vec3 r = t*dot(t, u)/t.z - u;\n    return r*0.5 + 0.5;\n}\n\nbool sphereIntersect(Ray ray, vec3 center, float radius, inout HitInfo hit)\n{\n    vec3 oc = ray.origin - center;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - radius * radius;\n    float h = b*b - c;\n    if( h < 0.0 || b > 0.0) return false;\n    h = sqrt( h );\n    vec2 t = vec2(-b-h, -b+h );\n    \n    bool inside = false;\n    if (t.x < 0.0)\n    {\n        t.x = t.y;\n        inside = true;\n    }\n    \n    if (t.x < hit.t)\n    {\n        hit.t = t.x;\n        hit.normal = normalize(ray.origin - center + ray.direction * hit.t);\n        if (inside) hit.normal = -hit.normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat pow5(float x)\n{\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat pow6(float x)\n{\n    float x2 = x * x;\n    return x2 * x2 * x2;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n    vec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(vec2(s),coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// Modified to work with 4 values at once\nuvec4 hash4i(inout uint y)\n{\n    uvec4 x = y * uvec4(213u, 2131u, 21313u, 213132u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\n// Modified to work with 4 values at once\nuvec3 hash3i(inout uint y)\n{\n    uvec3 x = y * uvec3(213u, 2131u, 21313u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3( hash3i(x) ) / float( 0xffffffffU );\n    //return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\n\n// Random point in circle\n// Very straightforward, unit circle scaled by sqrt of the radius\nvec2 randomPointInCircle()\n{\n    vec2 rand = hash2(state);\n    \n    float a = rand.x * TAU;\n    float r = sqrt(rand.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Random point in polygon\n// Pick a random side and\n// generate a point in a rhombus (equal quadrilateral),\n// and fold it if the point is outside the inner triangle\nvec2 randomPointInPolygon(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    vec2 p1 = s1 * rand.y + s2 * rand.z;\n    vec2 p2 = s1 * (1.0 - rand.y) + s2 * (1.0 - rand.z);\n    \n    return rand.y + rand.z > 1.0 ? p2 : p1;\n}\n\n// Random point in star\n// Same as the random point in polygon,\n// but without folding the rhombus into a triangle\nvec2 randomPointInStar(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    \n    return s1 * rand.y + s2 * rand.z;\n}\n\nvec2 randomPointInSquare()\n{\n    vec2 rand = hash2(state);\n    \n    return rand * 2.0 - 1.0;\n}\n\nvec2 randomPointInRectangle(vec2 a, vec2 b)\n{\n    vec2 rand = hash2(state);\n    \n    vec2 sq = rand * 2.0 - 1.0;\n    return a * sq.x + b * sq.y;\n}\n\nconst mat2 ROT_45 = mat2(sqrt(2.0)/2.0, sqrt(2.0)/2.0, -sqrt(2.0) / 2.0, sqrt(2.0)/2.0);\n\nvec2 randomPointTest()\n{\n    vec3 r = hash3(state);\n    vec3 r2 = hash3(state);\n    \n    vec2 a = vec2(0, 2);\n    vec2 b = vec2(0.5, 0);\n    vec2 rc = randomPointInRectangle(a, b);\n    vec2 c = randomPointInCircle() + a;\n    c.y = r.x < 0.5 ? -c.y : c.y;\n    \n    vec2 rc2 = randomPointInRectangle(a, b).yx;\n    vec2 c2 = vec2(c.y, c.x);\n    \n    float a1 = (2.0 * a.y) * (2.0 * b.x);\n    float a2 = PI;\n    \n    vec2 v = length(rc - a) < 1.0 || length(rc + a) < 1.0 || r.y < a2 / (a2 + a1) ? c : rc;\n    vec2 v2 = length(rc2 - a.yx) < 1.0 || length(rc2 + a.yx) < 1.0 || r2.y < a2 / (a2 + a1) ? c2 : rc2;\n    \n    vec2 sq = abs(v) - b.x;\n    v = max(sq.x, sq.y) < 0.0 || r.z < 0.5 ? v2 : v;\n    \n    return ROT_45 * v / a.y;\n}\n\nvec2 randomPointInE()\n{\n    vec2 rc1 = randomPointInRectangle(vec2(0, 1), vec2(0.2, 0));\n    vec2 rc2 = randomPointInRectangle(vec2(0, 0.2), vec2(0.5, 0)) + vec2(0.5 + 0.2, 0);\n    \n    rc2.y += (floor(hash(state) * 3.0) - 1.0) * (1.0 - 0.2);\n    \n    float a1 = 2.0 * 0.4;\n    float a2 = 3.0 * (0.4 * 1.0);\n    \n    vec2 v = hash(state) < a1 / (a1 + a2) ? rc1 : rc2;\n    v.x += 0.2 - (1.4 * 0.5);\n    \n    return v;\n}\n\nvec2 randomPointInCresent(float o)\n{\n    vec2 pa, pb, v;\n    \n    vec2 a = vec2(0, 0);\n    vec2 b = vec2(o, 0);\n    float r = 1.0;\n    \n    #define COUNT 50\n    for (int i = 0; i < COUNT; i++)\n    {\n        v = randomPointInCircle();\n    \n        pa = v - a;\n        pb = pa - b;\n        \n        if (dot(pb, pb) >= r)\n            break;\n    }\n    \n    return v + (a + b) * 0.5;\n}\n\nvec2 randomPointInCrescentApprox(float o)\n{\n    float r1 = 1.0;\n    float r2 = 1.0;\n    \n    float xi = (r1*r1 - r2*r2 + o*o) / (2.0 * o);\n    float yi = sqrt(r1*r1 - xi*xi);\n    \n    float a0 = atan(yi, xi);\n    float a1 = -a0;\n    float at = a1 - a0;\n    \n    float b0 = PI - a0;\n    float b1 = -b0;\n    float bt = b1 - b0;\n    \n    vec2 rand = hash2(state);\n    \n    // Inverse CDF of sine distribution\n    float t = acos(1.0 - 2.0 * rand.x) * INV_PI;\n    \n    vec2 p0 = vec2(cos(a0 + t * at), sin(a0 + t * at));\n    vec2 p1 = vec2(cos(b0 + t * bt)+o, sin(b0 + t * bt));\n    \n    vec2 pi = p0 - (p0.y / (p1.y - p0.y)) * (p1 - p0);\n\n    float ar1 = length(p0 + pi);\n    float ar2 = length(p1 + pi);\n    \n    // TODO: Find a better sampling distribution for line segment\n    //float t2 = (sqrt(ar1*ar1 * (1.0 - rand.y) + ar2*ar2 * rand.y) - min(ar1, ar2)) / abs(ar2 - ar1);\n    float t2 = rand.y;\n    \n    vec2 v = mix(p0, p1, t2);\n\n    return v + vec2(o, 0) * 0.5;\n}\n\nvec2 randomPointInAnnulus(float r1, float r2)\n{\n    vec2 rand = hash2(state);\n    \n    float theta = rand.x * TAU;\n    float v = rand.y;\n    float r = sqrt((1.0 - v) * r1*r1 + v * r2*r2);\n    \n    return vec2(cos(theta) * r, sin(theta) * r);\n    \n}\n\n// Random point in heart\n// It is generated by combining a square rotated 45 degrees\n// and a circle with one half reflected on the x axis\nvec2 randomPointInHeart()\n{\n    vec3 rand = hash3(state);\n    \n    const vec2 a = vec2(sqrt(2.0) / 2.0);\n    const vec2 b = vec2(-a.y, a.x);\n    \n    vec2 sq = rand.xy * 2.0 - 1.0;\n    sq = a * sq.x + b * sq.y;\n    \n    float an = rand.x * TAU;\n    float r = sqrt(rand.y);\n    vec2 c = vec2(cos(an), sin(an)) * r;\n    \n    if (dot(c, b) < 0.0)\n    {\n        c = -c;\n        c = c - a;\n        c.x = -c.x;\n    } else {\n        c = c - a;\n    }\n    \n    c.y += a.x * 2.0;\n    float a1 = 4.0;\n    float a2 = PI;\n    \n    vec2 v = rand.z < a1 / (a1 + a2) ? sq : c;\n    v.y += sqrt(2.0) - (sqrt(2.0) + (1.0 + a.y)) * 0.5;\n    \n    return v / sqrt(2.0);\n}\n\n// Random unit vector\n// Generate a random unit circle and scaled the z with a circular mapping\nvec3 randomUnitVector()\n{\n    vec2 rand = hash2(state);\n    rand.y = rand.y*2.-1.;\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\nvec3 randomHemisphere(vec3 n)\n{\n    vec3 r = randomUnitVector();\n    return dot(r, n) < 0.0 ? -r : r;\n}\n\n// Random cosine-weighted unit vector on a hemisphere\n// Unit vector + random unit vector\nvec3 randomCosineHemisphere(vec3 n)\n{\n    return normalize(randomUnitVector() + n);\n}\n\n// Orthonormal Basis\n// https://www.shadertoy.com/view/tlVczh\n// MBR method 2a variant\nmat3 getBasis(in vec3 n)\n{\n    float sz = n.z >= 0.0 ? 1.0 : -1.0;\n    float a  =  n.y/(1.0+abs(n.z));\n    float b  =  n.y*a;\n    float c  = -n.x*a;\n\n    vec3 xp = vec3(n.z+sz*b, sz*c, -n.x);\n    vec3 yp = vec3(c, 1.0-b, -sz*n.y);\n    \n    return mat3(xp, yp, n);\n}\n\nvoid getBasis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n    float sz = n.z >= 0.0 ? 1.0 : -1.0;\n    float a  =  n.y/(1.0+abs(n.z));\n    float b  =  n.y*a;\n    float c  = -n.x*a;\n\n    xp = vec3(n.z+sz*b, sz*c, -n.x);\n    yp = vec3(c, 1.0-b, -sz*n.y);\n}\n\n// PBR Stuff\n\n\nfloat F_Schlick(float u, float f0, float f90) {\n    return f0 + (f90 - f0) * pow5(1.0 - u);\n}\n\nfloat F_Schlick(float u, float f0) {\n    float f = pow5(1.0 - u);\n    return f + f0 * (1.0 - f);\n}\n\nvec3 F_Schlick(float u, vec3 f0) {\n    float f = pow5(1.0 - u);\n    return f + f0 * (1.0 - f);\n}\n\nfloat FresnelDielectric(float cosT, float eta)\n{\n    float scale = cosT > 0.0 ? 1.0 / eta : eta;\n    float cosTSq = 1.0 - (1.0 - cosT*cosT) * (scale*scale);\n    \n    if (cosTSq <= 0.0)\n    {\n        return 1.0;\n    }\n    \n    float cosTI = abs(cosT);\n    float cosTT = sqrt(cosTSq);\n\n    float Rs = (cosTI - eta * cosTT) / (cosTI + eta * cosTT);\n    float Rp = (eta * cosTI - cosTT) / (eta * cosTI + cosTT);\n    \n    return 0.5 * (Rs + Rp);\n}\n\nfloat pdfDiffuse()\n{\n    return INV_PI;\n}\n\nfloat Fd_Lambertian()\n{\n    return INV_PI;\n}\n\nfloat Fd_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(NoL, 1.0, f90);\n    float viewScatter = F_Schlick(NoV, 1.0, f90);\n    return lightScatter * viewScatter * INV_PI;\n}\n\nvec3 sampleDiffuse(vec3 normal)\n{\n    return randomCosineHemisphere(normal);\n}\n\n// \nfloat D_GGX(float NdotH, float roughness)\n{\n    float a = NdotH * roughness;\n    float k = roughness / (1.0 - NdotH * NdotH + a * a);\n    return k * k * INV_PI;\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 * NoL * NoV / (GGXV + GGXL);\n}\n\nfloat V_SmithGGXMasking(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    \n    float denom = sqrt(NoV * NoV * (1.0 - a2) + a2) + NoV;\n    \n    return 0.5 * NoV / denom;\n}\n\nfloat FresnelAvg(float ior)\n{\n    if (ior > 1.0)\n        return (ior - 1.0) / (4.08567 + 1.00071 * ior);\n    return 0.997118 + ior * (0.1014 + ior * (-0.965241 - 0.130607 * ior));\n}\n\nvec3 FresnelAvg(vec3 ior)\n{\n    return vec3(FresnelAvg(ior.x), FresnelAvg(ior.y), FresnelAvg(ior.z));\n}\n\n// https://patapom.com/blog/BRDF/MSBRDFEnergyCompensation/\nvec3 FresnelAvg2(vec3 f0)\n{\n    return f0 * (0.04 + f0 * (0.66 + 0.3 * f0));\n}\n\n// 1 - E\nfloat EnergyLoss(float cosT, float roughness)\n{\n    float u = cosT;\n    float r = roughness;\n    float S = -0.170718 * sqrt(u) + r * (4.07985 + r * (-11.5295 + r * (18.4961 - r * 9.23618)));\n    float t = 0.0632331 * u + r * (3.1434 + r * (-7.47567 + r * (13.0482 - r * 7.0401)));\n    return pow6(S) * pow(u, 3.0 / 4.0) / (pow6(t) + u * u);\n}\n\n// 1 - E\nfloat EnergyLossAvg(float roughness)\n{\n    float r = roughness;\n    return 0.592665 * r * r * r / (1.0 + r * (-1.47034 + r * 1.47196));\n}\n\nvec3 sampleSpecular(vec3 wo, float roughness, out vec3 wm)\n{\n#if GGX_IMPORTANCE_SAMPLING == 1\n    vec2 r = hash2(state);\n    float a2 = roughness * roughness;\n    \n    float cosTheta = sqrt((1.0 - r.x) / ((a2 - 1.0) * r.x + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = TAU * r.y;\n    \n    wm = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    return -reflect(wo, wm);\n\n// VNDF Importance Sampling\n// https://hal.archives-ouvertes.fr/hal-01509746/document\n#elif GGX_IMPORTANCE_SAMPLING == 2\n    vec2 rand = hash2(state);\n    float U1 = rand.x;\n    float U2 = rand.y;\n    \n    float alpha_x = roughness;\n    float alpha_y = roughness;\n    vec3 V = normalize(vec3(alpha_x * wo.x, alpha_y * wo.y, wo.z));\n    // orthonormal basis\n    //vec3 T1, T2;\n    //getBasis(V, T1, T2);\n\n    vec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0,0,1))) : vec3(1,0,0);\n    vec3 T2 = cross(T1, V);\n\n    // sample point with polar coordinates (r, phi)\n    float a = 1.0 / (1.0 + V.z);\n    float r = sqrt(U1);\n    float phi = (U2<a) ? U2/a * PI : PI + (U2-a)/(1.0-a) * PI;\n    float P1 = r*cos(phi);\n    float P2 = r*sin(phi)*((U2<a) ? 1.0 : V.z);\n    // compute normal\n    vec3 N = P1*T1 + P2*T2 + sqrt(max(0.0, 1.0 - P1*P1 - P2*P2))*V;\n    // unstretch\n    wm = normalize(vec3(alpha_x*N.x, alpha_y*N.y, max(0.0, N.z)));\n    \n    return -reflect(wo, wm);\n#else\n    return sampleHemisphere(vec3(0, 0, 1));\n#endif\n}\n\nfloat alpha_i(vec3 wi, float alpha)\n{\n    float m_alpha_x = alpha;\n    float m_alpha_y = alpha;\n    float invSinTheta2 = 1.0f / (1.0f - wi.z*wi.z);\n    float cosPhi2 = wi.x*wi.x*invSinTheta2;\n    float sinPhi2 = wi.y*wi.y*invSinTheta2;\n    float alpha_i = sqrt( cosPhi2*m_alpha_x*m_alpha_x + sinPhi2*m_alpha_y*m_alpha_y );\n    return alpha_i;\n\n}\n\nfloat SmithLambda(vec3 wi, float alpha)\n{\n    if (wi.z > 0.9999)\n        return 0.0;\n    if (wi.z < -0.9999)\n        return 1.0;\n    \n    #if 0\n    // a\n    float theta_i = acos(wi.z);\n    float a = 1.0f/tan(theta_i)/alpha_i(wi, alpha);\n    // value\n    return 0.5f*(-1.0 + sign(a) * sqrt(1.0 + 1.0/(a*a)));\n    \n    #else\n    \n    float inv_wz2 = 1.0 / max(wi.z * wi.z, EPSILON);\n    vec2 wa = vec2(wi.x, wi.y) * alpha;\n    float v = sqrt(1.0 + dot(wa, wa) * inv_wz2);\n    \n    if (wi.z <= 0.0)\n        v = -v;\n\n    return 0.5 * (v - 1.0);\n    #endif\n}\n\nfloat C1(float h)\n{\n    return saturate(0.5 * (h + 1.0));\n}\n\nfloat invC1(float h)\n{\n    return 2.0 * saturate(h) - 1.0;\n}\n\nfloat G1(vec3 w, float C1, float lambda)\n{\n    if (w.z > 0.9999)\n        return 1.0f;\n    if (w.z < EPSILON)\n        return 0.0f;\n    return pow(C1, lambda);\n}\n\nbool sampleHeight(vec3 wr, float U, float lambda, inout float h)\n{\n    if (wr.z > 0.9999)\n        return false;\n        \n    if (wr.z < -0.9999)\n    {\n        h = invC1(U * C1(h));\n        return true;\n    }\n    \n    if(abs(wr.z) < 0.0001)\n        return true;\n    \n    float G1_ = G1(wr, h, lambda);\n    \n    if (U > 1.0 - G1_)\n        return false;\n        \n    h = invC1(C1(h) / pow(1.0 - U, 1.0 / lambda));\n    return true;\n}\n\nfloat projectedArea(vec3 wi, float alpha)\n{\n    if(wi.z > 0.9999f)\n        return 1.0f;\n    if( wi.z < -0.9999f)\n        return 0.0f;\n    // a\n     float theta_i = acos(wi.z);\n     float sin_theta_i = sin(theta_i);\n     float alphai = alpha_i(wi, alpha);\n    // value\n     float value = 0.5f * (wi.z + sqrt(wi.z*wi.z + sin_theta_i*sin_theta_i*alphai*alphai));\n    return value;\n}\n\nfloat P22(float slope_x, float slope_y, float alpha)\n{\n    float m_alpha_x = alpha;\n    float m_alpha_y = alpha;\n    float tmp = 1.0f + slope_x*slope_x/(m_alpha_x*m_alpha_x) + slope_y*slope_y/(m_alpha_y*m_alpha_y);\n    float value = 1.0f / (PI * m_alpha_x * m_alpha_y) / (tmp * tmp);\n    return value;\n\n}\n\nfloat D(vec3 wm, float alpha)\n{\n    if( wm.z <= 0.0f)\n    return 0.0f;\n    // slope of wm\n    float slope_x = -wm.x/wm.z;\n    float slope_y = -wm.y/wm.z;\n    // value\n    float value = P22(slope_x, slope_y, alpha) / (wm.z*wm.z*wm.z*wm.z);\n    return value;\n}\n\nfloat D_wi(vec3 wi, vec3 wm, float alpha)\n{\n    if( wm.z <= 0.0f)\n    return 0.0f;\n    // normalization coefficient\n    float projectedarea = projectedArea(wi, alpha);\n    if(projectedarea == 0.0)\n    return 0.0;\n    float c = 1.0f / projectedarea;\n    // value\n    float value = c * max(0.0f, dot(wi, wm)) * D(wm, alpha);\n    return value;\n\n}\n\nfloat Fresnel(vec3 wi, vec3 wm, float eta)\n{\n    float cos_theta_i = dot(wi, wm);\n    float cos_theta_t2 = 1.0f - (1.0f-cos_theta_i*cos_theta_i) / (eta*eta);\n    // total internal reflection\n    if (cos_theta_t2 <= 0.0f) return 1.0f;\n    float cos_theta_t = sqrt(cos_theta_t2);\n    float Rs = (cos_theta_i - eta * cos_theta_t) / (cos_theta_i + eta * cos_theta_t);\n    float Rp = (eta * cos_theta_i - cos_theta_t) / (eta * cos_theta_i + cos_theta_t);\n    float F = 0.5f * (Rs * Rs + Rp * Rp);\n    return F;\n}\n\nfloat evalPhase(vec3 wi, vec3 wo, float lambda, float alpha, float eta)\n{\n#if 0\n    if (wi.z > 0.9999)\n        return 0.0;\n    \n    vec3 wh = normalize(wo - wi);\n    \n    if (wh.z < 0.0)\n        return 0.0;\n    \n    float pArea = (wi.z < -0.9999) ? 1.0 : lambda * wi.z;\n  \n    float dotW_WH = dot(-wi, wh);\n    \n    if (dotW_WH < 0.0)\n        return 0.0;\n        \n    return 0.25 * max(0.0f, dotW_WH) * D_GGX(wh.z, alpha) / max(pArea * dotW_WH, EPSILON);\n#else\n    \n    if (wi.z > 0.9999)\n        return 0.0;\n    \n    vec3 wh = normalize(wo + wi);\n\n    float res = float(wh.z > 0.0) * 0.25f * D_wi(wi, wh, alpha) / dot(wi, wh) * Fresnel(wi, wh, eta);\n    \n    eta = 1.0 / eta;\n    wh = -normalize(wi + wo * eta);\n    wh *= sign(wh.z);\n    if(dot(wh, wi) > 0.0)\n    {\n        res += eta*eta * (1.0-Fresnel(wi, wh, eta)) * D_wi(wi, wh, alpha) * max(0.0f, -dot(wo, wh)) *\n                1.0f / pow(dot(wi, wh)+eta*dot(wo,wh), 2.0f);\n    }\n    \n    return res;\n#endif\n}\n\nvec2 sampleP22_11(float cosI, float randx, float randy)\n{\n    if (cosI > 0.9999f || abs(cosI) < 1e-6f) {\n        float r = sqrt(randx / max(1.0f - randx, 1e-7f));\n        float phi = TAU * randy;\n        return vec2(r * cos(phi), r * sin(phi));\n    }\n\n    float sinI = sqrt(1.0f - cosI * cosI);\n    float tanI = sinI / cosI;\n    float projA = 0.5f * (cosI + 1.0f);\n    if (projA < 0.0001f)\n        return vec2(0.0f, 0.0f);\n    float A = 2.0f * randx * projA / cosI - 1.0f;\n    float tmp = A * A - 1.0f;\n    if (abs(tmp) < 1e-7f)\n        return vec2(0.0f, 0.0f);\n    tmp = 1.0f / tmp;\n    float D = sqrt(tanI * tanI * tmp * tmp - (A * A - tanI * tanI) * tmp);\n\n    float slopeX2 = tanI * tmp + D;\n    float slopeX = (A < 0.0f || slopeX2 > 1.0f / tanI) ? (tanI * tmp - D) : slopeX2;\n\n    float U2;\n    if (randy >= 0.5f)\n        U2 = 2.0f * (randy - 0.5f);\n    else\n        U2 = 2.0f * (0.5f - randy);\n    float z = (U2 * (U2 * (U2 * 0.27385f - 0.73369f) + 0.46341f)) /\n                  (U2 * (U2 * (U2 * 0.093073f + 0.309420f) - 1.0f) + 0.597999f);\n    float slopeY = z * sqrt(1.0f + slopeX * slopeX);\n\n    if (randy >= 0.5f)\n        return vec2(slopeX, slopeY);\n    \n    return vec2(slopeX, -slopeY);\n}\n\nvec3 samplePhase(vec3 wi, float alpha)\n{\n    vec2 rand = hash2(state);\n    vec3 wi_11 = normalize(vec3(alpha * wi.x, alpha * wi.y, wi.z));\n    vec2 slope_11 = sampleP22_11(wi_11.z, rand.x, rand.y);\n\n    vec3 cossin_phi = normalize(vec3(wi_11.x, wi_11.y, 0));\n    float slope_x = alpha * (cossin_phi.x * slope_11.x - cossin_phi.y * slope_11.y);\n    float slope_y = alpha * (cossin_phi.y * slope_11.x + cossin_phi.x * slope_11.y);\n\n    vec3 wm = normalize(vec3(-slope_x, -slope_y, 1));\n    \n    return -reflect(wi, wm);\n}\n\nvec3 MultiscatteringEval(vec3 wi, vec3 wo, float alpha)\n{\n    if (wo.z < 0.0)\n        return vec3(0);\n        \n    bool swapped = false;\n    if (wo.z < wi.z) {\n        vec3 tmp = wo;\n        //wo = wi;\n        //wi = tmp;\n        swapped = true;\n    }\n  \n    float eta = 1.45;\n    \n    vec3 wr = -wi;\n    \n    float lambda = SmithLambda(wr, alpha);\n    float shadowingLambda = SmithLambda(wo, alpha);\n    \n    //const float G2 = 1.0f / (1.0f - (lambda_r + 1.0f) + shadowing_lambda);\n    //float val = G2 * D_GGX(wh, alpha) * 0.25f / wi.z;\n    \n    float h = 1.0 + invC1(0.999);\n    vec3 throughput = vec3(1);\n    vec3 res = vec3(0);\n    \n    int order = 0;\n    \n    for (int i = 0; i < 10; i++)\n    {\n        if (!sampleHeight(wr, hash(state), lambda, h))\n            break;\n        \n        vec3 phase = evalPhase(wr, wo, lambda, alpha, eta) * throughput;\n        float shadowing = G1(wo, h, lambda);\n        \n        if (i == 0 || i+1 == 10)\n            res += throughput * phase * G1(wo, C1(h), shadowingLambda);\n        \n        wr = samplePhase(-wr, alpha);\n        //vec3 wm;\n        //wr = sampleSpecular(-wr, alpha, wm);\n        \n        lambda = SmithLambda(wr, alpha);\n    }\n    \n    //if (swapped)\n    //    res *= abs(wi.z / wo.z);\n        \n    return res;\n}\n\nvec3 MultiscatteringSample(vec3 wi, vec3 wo, float alpha)\n{\n    vec3 wr = -wi;\n    float h = 1.0 + invC1(0.999);\n    \n    float lambda = SmithLambda(wr, alpha);\n    vec3 throughput = vec3(1);\n    int order = 0;\n    \n    for (int i = 0; i < 10; i++)\n    {\n        if (!sampleHeight(wr, hash(state), lambda, h))\n            break;\n        \n        wr = samplePhase(-wr, alpha);\n        //vec3 wm;\n        //wr = sampleSpecular(-wr, alpha, wm);\n    \n        lambda = SmithLambda(wr, alpha);\n    }\n    \n    return wr;\n}\n\nfloat MultiscatteringGGXAlbedo(float r)\n{\n    float albedo = 0.806495f * exp(-1.98712f * r * r) + 0.199531f;\n    albedo -= ((((((1.76741f * r - 8.43891f) * r + 15.784f) * r - 14.398f) * r + 6.45221f) * r -\n              1.19722f) *\n                 r +\n             0.027803f) *\n                r +\n            0.00568739f;\n  return saturate(albedo);\n}\n\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec4 data = vec4(0);\n\nvec3 sampleTriplanarTexture(sampler2D channel, vec3 normal, vec3 position, float sharpness)\n{\n    vec3 n = pow(abs(normal), vec3(sharpness));\n    n /= n.x + n.y + n.z;\n    \n    vec3 tx = sRGBToLinear(texture(channel, position.zy).rgb);\n    vec3 ty = sRGBToLinear(texture(channel, position.xz).rgb);\n    vec3 tz = sRGBToLinear(texture(channel, position.yx).rgb);\n    \n    return tx * n.x + ty * n.y + tz * n.z;\n}\n\nvec3 sampleEquirectangularTexture(sampler2D channel, vec3 normal, vec2 scale, vec2 offset)\n{\n    float theta = atan(normal.z, normal.x) / TAU + 0.5;\n    float phi = acos(normal.y) / PI;\n    \n    return sRGBToLinear(texture(channel, (vec2(theta, phi) + offset) * scale).rgb);\n}\n\nvec3 sampleEquirectangularTexture(sampler2D channel, vec3 normal)\n{\n    return sampleEquirectangularTexture(channel, normal, vec2(1), vec2(0));\n}\n\nvec3 getSkybox(vec3 direction)\n{\n#ifdef WHITE_FURNACE_TEST\n    return vec3(1);\n#else\n    vec3 sky = sRGBToLinear(texture(iChannel1, direction).rgb);\n    vec3 stars = sampleEquirectangularTexture(iChannel2, direction, 5.0*vec2(1, 0.5), vec2(0.23, 0.285));\n#ifdef ENABLE_SKY_STARS\n    sky += 40.0*pow(stars, vec3(5.0));\n#endif\n    return SKYBOX_STRENGTH * sky;\n#endif\n}\n\nvec3 getColor(int i)\n{\n    vec3 color = vec3(1);\n    if (i == 0)\n        color = vec3(1.00, 0.85, 0.57); // Gold\n    else if (i == 1)\n        color = vec3(0.98, 0.90, 0.59); // Brass\n    else if (i == 2)\n        color = vec3(0.97, 0.74, 0.62); // Copper\n    else if (i == 3)\n        color = vec3(0.77, 0.78, 0.78); // Iron\n    else if (i == 4)\n        color = vec3(0.97, 0.96, 0.91); // Silver\n        \n    return sRGBToLinear(color);\n}\n\nvoid sceneIntersect(Ray ray, out HitInfo hit, out Material mat)\n{   \n    hit = NewHitInfo();\n    mat = DefaultMaterial();\n    \n#if SCENE == 0\n    #define NUM_SPHERES 5\n    for (int x = 0; x < NUM_SPHERES; x++)\n    for (int y = 0; y < NUM_SPHERES; y++)\n    {\n        float radius = 0.4;\n        float spacing = 0.05;\n        float xp = (float(x) - float(NUM_SPHERES - 1) / 2.0) * (2.0 * radius + spacing);\n        float yp = (float(y) - float(NUM_SPHERES - 1) / 2.0) * (2.0 * radius + spacing);\n        float roughness = float(x) / float(NUM_SPHERES - 1) * 0.8 + 0.2;//float(i) * 0.2;\n        float metallic = float(y) / float(NUM_SPHERES - 1) * 0.5 + 0.5;\n        \n        metallic = saturate(metallic);\n        roughness = saturate(roughness);\n        roughness *= roughness;\n        \n        if (sphereIntersect(ray, vec3(-xp, 0, -yp), radius, hit))\n        {\n            vec3 p = ray.origin + ray.direction * hit.t;\n            \n            float scale = 0.6;\n            float e = 2.0 / iChannelResolution[2].x;\n            vec3 tex = sampleEquirectangularTexture(iChannel2, hit.normal, scale * vec2(1.0, 0.5), vec2(xp, yp));\n            vec3 texDx = sampleEquirectangularTexture(iChannel2, hit.normal, scale * vec2(1.0, 0.5), vec2(xp + e, yp));\n            vec3 texDy = sampleEquirectangularTexture(iChannel2, hit.normal, scale * vec2(1.0, 0.5), vec2(xp, yp + e * 0.5));\n            \n            vec3 N = hit.normal;\n            vec3 A = abs(N.z) > 0.9999 ? vec3(0, 1, 0) : vec3(0, 0, 1);\n            vec3 T = normalize(cross(N, A));\n            vec3 B = cross(T, N);\n            \n            float h = luminance(tex);\n            float hx = luminance(texDx);\n            float hy = luminance(texDy);\n            vec3 tn = normalize(vec3(h - hx, (h - hy) * 2.0, e));\n            //vec3 tex = sampleTriplanarTexture(iChannel2, hit.normal, p * 0.3, 5.0);\n            float m = smoothstep(0.03, 0.1, luminance(tex));\n            \n            tn = normalize(mix(vec3(0, 0, 1), tn, 1.0 - m));\n            \n            hit.bumpNormal = normalize(T * tn.x + B * tn.y + N * tn.z);\n            \n            metallic = min(metallic, m);\n            roughness = max(roughness, 1.0 - m);\n            \n            uint r = uint(x+y*NUM_SPHERES)+23u;\n            uint r2 = r+123u;\n            \n            #if COLOR == 0\n            vec3 color = mix(palette(hash(r)), 1.0-palette(hash(r2)), pow(mix(abs(dot(hit.normal, ray.direction)), 1.0, roughness), 1.5));\n            #elif COLOR == 1\n            vec3 color = getColor(y);\n            #else\n            vec3 color = vec3(1);\n            #endif\n            \n            color = mix(saturate(tex * 5.0), color, m);\n            \n            mat = Material(color, vec3(0), roughness, metallic, 0.0, 1.0, 1.0);\n            \n            #ifdef WHITE_FURNACE_TEST\n            mat.color = vec3(1);\n            #endif\n        }\n    }\n#else\n    if (sphereIntersect(ray, vec3(0, 0, 0), 1.0, hit))\n    {\n        mat = DefaultMaterial();\n        //mat.color = vec3(1, 0.5, 0.5);\n        //mat.color = mix(vec3(1, 0.5, 0.5), vec3(0.3, 0.6, 1.0), pow(abs(dot(hit.normal, ray.direction)), 1.5));\n        mat.transmission = 0.0;\n        mat.roughness = 1.0;\n        mat.metallic = 0.0;\n        mat.ior = 1.33;\n        mat.clearcoat = 0.0;\n    }\n\n#endif\n    if (noHit(hit))\n    {\n        mat.emissive = getSkybox(ray.direction);\n    }\n}\n\nfloat pdfSpecular(float NdotV, float NdotL, float NdotWM, float WOdotWM, float roughness, vec3 wi)\n{\n#if GGX_MULTISCATTERING != 2\n\n#if GGX_IMPORTANCE_SAMPLING == 1\n    return NdotV * D_GGX(NdotWM, roughness) * NdotWM / (4.0 * WOdotWM);\n#elif GGX_IMPORTANCE_SAMPLING == 2\n    return V_SmithGGXMasking(NdotV, NdotL, roughness) * D_GGX(NdotWM, roughness);\n#else\n    return NdotV * INV_PI * 0.5;\n#endif\n\n#else\n    float D = D_GGX(NdotWM, roughness);\n    float lambda = SmithLambda(wi, roughness);\n    //float singlescatter = V_SmithGGXMasking(NdotV, NdotL, roughness) * D_GGX(NdotWM, roughness);\n    float singlescatter = 0.25 * D / max((1.0 + lambda), EPSILON);\n    \n    float multiscatter = NdotV * INV_PI;\n\n    float albedo = MultiscatteringGGXAlbedo(roughness);\n    \n    return (albedo * singlescatter + (1.0f - albedo) * multiscatter);\n#endif\n}\n\nvec3 Fr_GGX(float NdotV, float NdotL, float NdotH, float LdotH, float VdotH, vec3 f0, float roughness, vec3 wi, vec3 wo)\n{\n    float D = D_GGX(NdotH, roughness);\n    vec3  F = F_Schlick(LdotH, f0);\n    float V = V_SmithGGXCorrelated(NdotV, NdotL, roughness);\n\n#if GGX_MULTISCATTERING == 1\n    if (roughness <= MIN_ROUGHNESS)\n        return F * (D * V);\n\n    // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n    float Eavg = EnergyLossAvg(roughness);\n    float Ems = EnergyLoss(NdotV, roughness) * EnergyLoss(NdotL, roughness) * INV_PI / Eavg;\n    \n    #if 0\n    vec3 sqrtF0 = sqrt(f0);\n    vec3 fIor = (1.0 + sqrtF0) / (1.0 - sqrtF0);\n    vec3 Favg = FresnelAvg(1.0 / fIor);\n    vec3 Fms = (Favg * Favg * (1.0 - Eavg)) / (1.0 - Favg * Eavg);\n    #else\n    vec3 Fms = FresnelAvg2(f0);\n    #endif\n    \n    return F * (D * V) + Ems * Fms * NdotV / 2.0;\n#elif GGX_MULTISCATTERING == 2\n    \n    return MultiscatteringEval(wi, wo, roughness);\n#else\n    return F * (D * V);\n#endif\n}\n\nvec3 Fr_GGX_Transmission(float NdotV, float NdotL, float NdotH, float LdotH, float VdotH, vec3 f0, float iorV, float iorL, float roughness)\n{\n    float D = D_GGX(NdotH, roughness);\n    //vec3  F = F_Schlick(LdotH, f0);\n    float F = FresnelDielectric(LdotH, iorV);\n    float V = V_SmithGGXCorrelated(NdotV, NdotL, roughness);\n    float denom = iorL * LdotH +  iorV * VdotH;\n    \n    return 4.0 * f0 * (1.0 - F) * (D * V) * LdotH * VdotH * iorV * iorV / (denom * denom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    \n    vec2 o = halton(vec2(13, 23) * float(iFrame));\n    vec2 pv = (2. * (fragCoord + o - 0.5) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    data.xy = uv;\n    \n    vec3 ro = vec3(0, 0, 5);\n    vec3 lo = vec3(0, 0, 0);\n    \n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame < 2)\n        m = vec4(0.59, 0.46, 0, 0);\n    \n    #ifdef STATIC_CAM\n    //m.xy = vec2(0.5, 0.334);\n    //m.xy = vec2(0.67, 0.45);\n    //m.xy = vec2(0.59, 0.46);\n    //m.xy = vec2(0.88, 0.44);\n    //m.xy = vec2(0.415, 0.46);\n    //m.xy = vec2(0.56, 0.44);\n    m.xy = vec2(0.59, 0.46);\n    #endif\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(0.59, 0.46, 0, 0);\n        } else\n        {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0)\n            {\n                if (fragColor.zw != vec2(0))\n                    fragColor.xy += (mn - m.zw);\n                fragColor.zw = mn;\n            } else\n            {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    }\n    \n    float ax = -m.x * TAU + PI;\n    float ay = -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro.xz *= rot2D(PI);\n    ro += lo;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    float fovScale = 4.0;\n    \n    float dofStrength = DOF_STRENGTH;\n    float dofDist = DOF_FOCUS_DISTANCE;\n    \n    #ifdef DOF_AUTOFOCUS\n    Ray dofRay = Ray(ro, cmat[2]);\n    HitInfo dofHit;\n    Material dofMat;\n    \n    sceneIntersect(dofRay, dofHit, dofMat);\n    \n    dofDist = dofHit.t / fovScale;\n    #endif\n    \n    #if DOF_TYPE == 0\n    vec2 rc = randomPointInCircle();\n    #elif DOF_TYPE == 1\n    vec2 rc = randomPointInSquare();\n    #elif DOF_TYPE == 2\n    vec2 rc = randomPointInPolygon(float(DOF_SIDES));\n    #elif DOF_TYPE == 3\n    vec2 rc = randomPointInStar(float(DOF_SIDES));\n    #elif DOF_TYPE == 4\n    vec2 rc = randomPointInHeart();\n    #elif DOF_TYPE == 5\n    //vec2 rc = randomPointInCresent(-0.5);\n    vec2 rc = randomPointInCrescentApprox(-0.5);\n    #elif DOF_TYPE == 6\n    vec2 rc = randomPointTest();\n    #elif DOF_TYPE == 7\n    vec2 rc = randomPointInAnnulus(0.5, 1.0);\n    #else\n    vec2 rc = randomPointInE();\n    #endif\n    \n    rc *= dofStrength * dofDist;\n    \n    pv -= rc / dofDist;\n    ro += cmat * vec3(rc, 0);\n    \n    vec3 rd = normalize(cmat * vec3(pv, fovScale));\n    \n    vec3 color = vec3(0);\n    vec3 throughput = vec3(1);\n    \n    Ray ray = Ray(ro, rd);\n    HitInfo hit;\n    Material mat;\n    \n    Ray rayNext;\n    HitInfo hitNext;\n    Material matNext;\n\n    sceneIntersect(ray, hit, mat);\n    \n    color += mat.emissive;\n    \n    int i = 0;\n    for (; i < BOUNCES; i++)\n    {\n        if (noHit(hit))\n            break;\n            \n        // Default clearcoat roughness to 0\n        #define CLEARCOAT_ROUGHNESS 0.0\n        float clearcoatRoughness = max(CLEARCOAT_ROUGHNESS, MIN_ROUGHNESS);\n        clearcoatRoughness *= clearcoatRoughness;\n        float roughness = max(mat.roughness, MIN_ROUGHNESS);\n        roughness *= roughness;\n        \n        vec3 normal = hit.bumpNormal != vec3(0) ? hit.bumpNormal : hit.normal;\n        \n        float NdotV = max((dot(hit.normal, -ray.direction)), EPSILON);\n        float NBdotV = max((dot(normal, -ray.direction)), EPSILON);\n        \n        vec3 f0 = mix(vec3(0.04), mat.color, mat.metallic);\n        vec3 fresnel3 = F_Schlick(NBdotV, f0);\n        float fresnel = (fresnel3.x + fresnel3.y + fresnel3.z) / 3.0;\n        \n        float clearcoatFresnel = F_Schlick(NdotV, 0.04);\n        \n        float clearcoatRayPdf = clearcoatFresnel * mat.clearcoat;\n        \n        // This is wrong but idk yet, sorry devsh v_v\n        float specularRayPdf = mix(fresnel, 1.0, mat.metallic);\n        float diffuseRayPdf = (1.0 - mat.transmission) * (1.0 - specularRayPdf);\n        float transmissionRayPdf = mat.transmission * (1.0 - specularRayPdf);\n        \n        specularRayPdf *= (1.0 - clearcoatRayPdf);\n        diffuseRayPdf *= (1.0 - clearcoatRayPdf);\n        transmissionRayPdf *= (1.0 - clearcoatRayPdf);\n        \n        float totalRayPdf = clearcoatRayPdf + specularRayPdf + transmissionRayPdf + diffuseRayPdf;\n        \n        bool isClearcoatRay = hash(state) < clearcoatRayPdf / totalRayPdf;\n        bool isSpecularRay = !isClearcoatRay && hash(state) < specularRayPdf / totalRayPdf;\n        bool isTransmissionRay = !isClearcoatRay && !isSpecularRay && hash(state) < transmissionRayPdf / totalRayPdf;\n        \n        //isClearcoatRay = false; isSpecularRay = true; isTransmissionRay = false;\n        \n        if (isClearcoatRay)\n            normal = hit.normal;\n        \n        mat3 tbn = getBasis(normal);\n        \n        vec3 wo = inverse(tbn) * -ray.direction;\n        vec3 wi, wm;\n        \n        if (isClearcoatRay)\n        {\n            wi = sampleSpecular(wo, clearcoatRoughness, wm);\n            rayNext.direction = tbn * wi;\n        } else if (isSpecularRay)\n        {\n        #if GGX_MULTISCATTERING == 2\n            wi = MultiscatteringSample(-wi, wo, roughness);\n        #else\n            wi = sampleSpecular(wo, roughness, wm);\n        #endif\n            rayNext.direction = tbn * wi;\n        } else if (isTransmissionRay)\n        {\n            sampleSpecular(wo, roughness, wm);\n            wi = -refract(wo, -wm, hit.inside ? mat.ior : 1.0 / mat.ior);\n            if (dot(wi, wi) < EPSILON)\n                wi = -reflect(wo, wm);\n            rayNext.direction = tbn * wi;\n        } else {\n            rayNext.direction = sampleDiffuse(hit.normal);\n        }\n        \n        rayNext.origin = ray.origin + ray.direction * hit.t + rayNext.direction * 1e-3;\n        rayNext.origin += (isTransmissionRay ? -hit.normal : hit.normal) * 1e-3;\n        \n        sceneIntersect(rayNext, hitNext, matNext);\n        \n        vec3 halfVector = normalize(-ray.direction + rayNext.direction);\n        \n        float NdotL = max(dot(normal, rayNext.direction), EPSILON);\n        float NdotH = max(dot(normal, halfVector), EPSILON);\n        float LdotH = max(dot(rayNext.direction, halfVector), EPSILON);\n        float VdotH = max(dot(-ray.direction, halfVector), EPSILON);\n        float WOdotWM = max(dot(wo, wm), EPSILON);\n        float NdotWM = max(wm.z, EPSILON);\n        \n        vec3 diffuse, specular;\n        \n        vec3 reflectance = vec3(0);\n        \n        if (isClearcoatRay)\n        {\n            specular = Fr_GGX(NdotV, NdotL, NdotH, LdotH, VdotH, vec3(1), clearcoatRoughness, wi, wo);\n            \n            float specularPdf = pdfSpecular(NdotV, NdotL, NdotWM, WOdotWM, clearcoatRoughness, wi);\n            \n            reflectance = throughput * matNext.emissive * specular / specularPdf;\n            throughput *= specular / specularPdf;\n            \n        } else if (isSpecularRay)\n        {\n            specular = Fr_GGX(NdotV, NdotL, NdotH, LdotH, VdotH, mat.color, roughness, wi, wo);\n            \n            float specularPdf = pdfSpecular(NdotV, NdotL, NdotWM, WOdotWM, roughness, wi);\n            \n            reflectance = throughput * matNext.emissive * specular / specularPdf;\n            throughput *= specular / specularPdf;\n            \n        } else if (isTransmissionRay)\n        {\n            float eta = wi.z > 0.0 ? mat.ior : 1.0 / mat.ior;\n            halfVector = normalize(-ray.direction + rayNext.direction * eta);\n            NdotL = max(abs(dot(normal, -rayNext.direction)), EPSILON);\n            NdotH = max(abs(dot(normal, halfVector)), EPSILON);\n            LdotH = max(abs(dot(-rayNext.direction, halfVector)), EPSILON);\n            VdotH = max(abs(dot(-ray.direction, halfVector)), EPSILON);\n            \n            float iorV = hit.inside ? mat.ior : 1.0;\n            float iorL = !hit.inside ? mat.ior : 1.0;\n            \n            specular = Fr_GGX_Transmission(NdotV, NdotL, NdotH, LdotH, VdotH, mat.color, iorV, iorL, roughness);\n            \n            float specularPdf = pdfSpecular(NdotV, NdotL, NdotH, VdotH, roughness, wi);\n            \n            reflectance = throughput * matNext.emissive * specular / specularPdf;\n            throughput *= specular / specularPdf;\n            \n        } else {\n            vec3 diffuseColor = mat.color;\n            #if 0\n            diffuse = diffuseColor * Fd_Burley(NdotV, NdotL, LdotH, roughness);\n            #else\n            diffuse = diffuseColor * Fd_Lambertian();\n            #endif\n            \n            float diffusePdf = pdfDiffuse();\n            \n            reflectance = throughput * matNext.emissive * diffuse / diffusePdf;\n            throughput *= diffuse / diffusePdf;\n        }\n        \n        color += reflectance;\n        \n        if (luminance(throughput) < 1.0 / 256.0)\n            break;\n        \n        if (noHit(hitNext))\n            break;\n        \n        ray = rayNext;\n        hit = hitNext;\n        mat = matNext;\n    }\n    \n    vec3 outColor = color;\n\n#ifndef NO_ACCUMULATE\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float blend = iFrame == 0 ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    \n    #ifndef STATIC_CAM\n    if (m.zw != vec2(0))\n        blend = 1.0;\n    #endif\n    \n    fragColor = vec4(mix(prevColor.rgb, outColor, blend), blend);\n#else\n    fragColor = vec4(outColor, 1);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}