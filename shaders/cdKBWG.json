{
    "Shader": {
        "info": {
            "date": "1698600652",
            "description": "inspired by Ryoiji Ikeda and Evangelion",
            "flags": 0,
            "hasliked": 0,
            "id": "cdKBWG",
            "likes": 104,
            "name": "Decodering",
            "published": 3,
            "tags": [
                "text",
                "code",
                "matrix"
            ],
            "usePreview": 1,
            "username": "leon",
            "viewed": 2229
        },
        "renderpass": [
            {
                "code": "\n// Decodering\n// Leon Denise 2023-10-29\n// inspired by Ryoiji Ikeda and Evangelion\n\n// 2023-10-31: updated code from Fabrice Neyret suggestions\n\n// Blackle Mori\n// https://suricrasia.online/blog/shader-functions/\n#define erot(p,A,a) mix(dot(A, p)*A, p, cos(a)) + cross(A,p)*sin(a)\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // coordinates\n    vec2 p = (pixel-iResolution.xy/2.)/iResolution.y;\n    \n    // perspective\n    vec3 q = vec3(p, 1.);\n    q = erot(q, vec3(1,1,1), -.5);\n    p = q.xy/q.z;\n    \n    // scroll\n    p.y += iTime*.1;\n    \n    // grid\n    float grid = 16.;\n    vec2 cell = floor(p*grid);\n    \n    // column animation\n    float mask = floor(iTime*hash11(cell.x));\n    mask = step(.5,sin(mask));\n    float speed = 40.*hash11(cell.x+75.);\n    cell.y += floor(iTime*speed)*mask;\n    \n    // random per cell\n    vec2 rng = hash22(cell);\n    \n    // character selection\n    int char = int(iTime * rng.x);\n    int grd = int(grid);\n    char = (char % 50)+145;\n    vec2 offset = vec2(char%grd, char/grd);\n    \n    // atlas coordinates\n    p = mod(p, 1./grid);\n    p += offset/grid;\n    vec4 map = textureLod(iChannel0, p, 1.5/q.z);\n    \n    // color\n    bool colorful = sin(rng.y*6.+iTime) > 0.5;\n    if (colorful)\n    {\n        color.rgb = .5+.5*cos(vec3(0,2,4)+floor(cell.y*.1));\n        color.rgb *= 1.-map.r;\n    }\n    else\n    {\n        color.rgb = vec3(map.r);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}