{
    "Shader": {
        "info": {
            "date": "1526352430",
            "description": "A sort of hommage to provod's Revision 2018 shader-competition entry. Doing \"illegal\" things (bending and distoring) to the distance-fields of the two circling spheres. Thanks to hints from Shane there are almost no more artefacts :)",
            "flags": 64,
            "hasliked": 0,
            "id": "XsKyWt",
            "likes": 7,
            "name": "The T-1000 as embryo ;)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflections",
                "realtime",
                "material"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 845
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The T-1000 as embryo ;)\" - hommage to provod's Revision 2018 shader-entry\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .0001;\n\nfloat udBox (in vec3 p, in vec3 size, in float r)\n{\n    return length (max (abs (p) - (size -r), .0)) - r;\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat sdSphere (in vec3 p, in float r)\n{\n    return length (p) - r;\n}\n\nvec3 opRepeat3 (in vec3 p, float d)\n{\n    return mod (p + d*.5, d) - d*.5;\n}\n\nfloat opUnion (in float a, in float b)\n{\n\treturn min (a, b);\n}\n\nfloat opIntersect (in float a, in float b)\n{\n\treturn max (a, b);\n}\n\nfloat opSubtract (in float a, in float b)\n{\n\treturn max (-a, b);\n}\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad * p.y);\n    float s = sin (rad * p.y);\n    mat2  m = mat2 (c, -s, s, c);\n    p = vec3 (m * p.xy, p.z);\n\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 5. + 4. * (.5 + .5 * cos (iTime));\n\tresult = .125 * sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n\n    return result;\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat scene (in vec3 p)\n{\n    vec2 offset = 1. * vec2 (cos (iTime), sin (iTime));\n    vec2 offset2 = -1. * vec2 (cos (6.28+iTime), sin (6.28+iTime));\n    float warp = .2 + .05 * (.5 + .5 * cos (25.*p.y + 8.*iTime));\n    float sphere = sdSphere (p + vec3 (-offset.x, .0+offset.y, .0), .2 + warp);\n\n    vec3 w = (p + vec3 (-offset2.x, -.125+offset2.y, .0));\n    opBend (w, 42.5 * cos (3.*iTime));\n    float dt = sdSphere (w, .65);\n    float dp = displace (w);\n    float thing = dt + dp;\n    thing = min (thing, sphere);\n \n    \n    p.xz *= r2d (-12.*iTime);\n    p.yx *= r2d (8.*iTime);\n    vec3 p1 = p + vec3 (.355);\n    p1 = opRepeat3 (p1, .325);\n    float boxes = udBox (p1, vec3 (.15), .03);\n    float cutBox = sdBox (p, vec3 (2.7), .05);\n    float wallBox = sdBox (p, vec3 (2.8), .05);\n\n    return opUnion (thing, opUnion (-wallBox, opSubtract (cutBox, boxes)));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd)\n{\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs(t) < EPSILON*(1. + .125*t)) break;\n        d += t * .75;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - scene (p));\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n    vec3 ambient = vec3 (.05);\n    vec3 diffuseColor = vec3 (.9, .3, .3);\n    vec3 specularColor = vec3 (.9, .8, .7);\n    float shininess = 40.;\n    float diffuseStrength = .25;\n    float t = 3.*iTime;\n\n    vec3 n = normal (p, d*d*EPSILON);\n    vec3 lPos = 1.5 * vec3 (cos (t), 1., sin (t));\n    float lDist = distance (lPos, p);\n    vec3 lDir = normalize (lPos - p);\n    vec3 hDir = normalize (ro + lDir);\n    float diffuse = max (dot (n, lDir), .0)*(1. / lDist)*diffuseStrength;\n    float specular = pow (max (dot (hDir, n), .0), shininess);\n\n\tvec3 diffuseColor2 = vec3 (.3, .9, .3);\n    vec3 specularColor2 = vec3 (.7, .8, .9);\n    vec3 lPos2 = -1.5 * vec3 (.0, sin(t), .75*cos(t));\n    float lDist2 = distance (lPos2, p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    vec3 hDir2 = normalize (ro + lDir2);\n    float diffuse2 = max (dot (n, lDir2), .0)*(1. / lDist2)*diffuseStrength;\n    float specular2 = pow (max (dot (hDir2, n), .0), shininess);\n\n\tvec3 diffuseColor3 = vec3 (.3, .3, .9);\n    vec3 specularColor3 = vec3 (.8, .9, .7);\n    vec3 lPos3 = 1.5 * vec3 (sin (t), .5*cos(t), -1.);\n    float lDist3 = distance (lPos3, p);\n    vec3 lDir3 = normalize (lPos3 - p);\n    vec3 hDir3 = normalize (ro + lDir3);\n    float diffuse3 = max (dot (n, lDir3), .0)*(1. / lDist3)*diffuseStrength;\n    float specular3 = pow (max (dot (hDir3, n), .0), shininess);\n\n    vec3 col = ambient +\n\t\t\t   diffuse * diffuseColor + specular * specularColor +\n\t\t\t   diffuse2 * diffuseColor2 + specular2 * specularColor2 +\n\t\t\t   diffuse3 * diffuseColor3 + specular3 * specularColor3;\n    return col;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n    \n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // set up \"camera\", view origin (ro) and view direction (rd)\n    float angle = radians (300. + 55. * iTime);\n    float dist = 2.65;\n    vec3 ro = vec3 (dist * cos (angle), cos (iTime), dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // primary-/view-ray\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.03);\n    vec3 p = ro + d * rd;\n    vec3 n = normal (p, d*.0002);\n    vec3 col = shade (ro, rd, d);\n    col = mix (col, vec3 (.95, .85, .7), pow (1. - 1. / d, 10.));\n\n    // secondary-/1st reflection-ray\n    vec3 rd2 = normalize (reflect (rd, n));\n    float d2 = raymarch (p + n*.001, rd2);\n    vec3 p2 = p + d2 * rd2;\n    vec3 n2 = normal (p2, .0002);\n    vec3 col2 = shade (p, rd2, d2);\n    col += (.05 + .05*(.5 + .5 * cos (5.*iTime))) * col2;\n\n    // ternary-/2nd reflection-ray\n    vec3 rd3 = normalize (reflect (rd2, n2));\n    float d3 = raymarch (p2 + n2*.001, rd3);\n    vec3 p3 = p2 + d3 * rd3;\n    vec3 n3 = normal (p3, .0002);\n    vec3 col3 = shade (p2, rd3, d3);\n    col += (.025 + .025*(.5 + .5 * cos (5.*iTime))) * col3;\n\n    // fog, tint, tone-mapping, gamma-correction, vingette\n    col *= fog;\n    col *= vec3 (.85, .9, .95);\n    col = col / (.85 + col);\n    col = .1 * col + .9 * sqrt (col);\n    col *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 14749,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/professorkliq/crystals-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}