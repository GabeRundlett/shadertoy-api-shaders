{
    "Shader": {
        "info": {
            "date": "1585134465",
            "description": "Herbert Müller's method for inverse Schwarz-Christoffel mapping for regular polygons.\n\n[url]http://herbert-mueller.info/uploads/3/5/2/3/35235984/circletopolygon.pdf[/url]\n\nMouse moves inversion point.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tsfyRj",
            "likes": 22,
            "name": "Schwarz-Christoffel Mapping",
            "published": 3,
            "tags": [
                "mapping",
                "conformal",
                "schwarzchristoffel"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 775
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Herbert Müller's method for inverse Schwarz-Christoffel mapping for\n// regular polygons.\n//\n// Matthew Arcus, 2020.\n//\n// The Schwarz-Christoffel mapping:\n//\n// https://en.wikipedia.org/wiki/Schwarz%E2%80%93Christoffel_mapping\n//\n// maps the unit circle (or half-plane) to any polygon in the complex plane.\n// Here we construct the inverse mapping for a regular polygon using a\n// method due to Herbert Müller:\n//\n// http://herbert-mueller.info/uploads/3/5/2/3/35235984/circletopolygon.pdf\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\n\nvec2 expi(float x) {\n  return normalize(vec2(cos(x),sin(x)));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,\n              z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z*vec2(1,-1)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993; // Unnecessary precision\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n  \n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  // Pixel specific code starts here\n  z *= C; // Scale polygon to have diameter 1\n  vec2 h = cpow(z,int(K));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 rotate(vec2 p, in float t) {\n  return cmul(expi(t),p);\n}\n\nvec2 map(vec2 screenpos) {\n  float scale = 1.0;\n  vec2 p = (2.0*screenpos.xy-iResolution.xy)/iResolution.y;\n  p *= scale;\n  p = p.yx;\n  return p;\n}\n\nvec3 getcolor(vec2 z, int K) {\n  if (iMouse.x > 0.0) {\n    vec2 c = map(iMouse.xy);\n    float t = (1.0-dot(c,c))/dot(z-c,z-c);\n    z = t*z-(1.0+t)*c;\n    z /= dot(z,z); // Keeps chirality\n  }\n  // And a rotation (also a Mobius transformation)\n  z = rotate(z,0.5*iTime);\n\n  float r = length(z);\n  float px = 0.5*fwidth(z.x);\n  float theta = atan(z.y,z.x);\n  vec3 col = hsv2rgb(theta/(2.0*PI),1.0,1.0);\n  float A = 4.0;\n  float B = 2.0*float(K);\n  float a = -log(r)*A;\n  float ds = 0.07;\n  if (a <= 6.0+ds) {\n    a = fract(a);\n    float b = fract(theta/PI*B);\n    float d = min(min(a,1.0-a),min(b,1.0-b));\n    col *= mix(0.2,1.0,smoothstep(-ds-px,ds+px,d));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = map(fragCoord.xy);\n  vec3 col = vec3(0.5);\n  int K = (3+int(0.2*iTime)%7);\n  // Check if point in polygon\n  bool inpoly = true;\n  {\n    float theta = PI/float(K);\n    vec2 n = vec2(cos(theta),sin(theta));\n    for (int i = 0; i < K; i++) {\n      vec2 w = rotate(z,2.0*float(i)*theta);\n      w.x -= 1.0;\n      if (dot(w,n) > 0.0) inpoly = false;\n    }\n  }\n  bool incircle = length(z) < 1.0;\n  z = inversesc(z,K);\n  col = getcolor(z,K);\n  if (!incircle) col *= 0.75;\n  if (!inpoly) col *= 0.75;\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}