{
    "Shader": {
        "info": {
            "date": "1612493298",
            "description": "for mickey test",
            "flags": 0,
            "hasliked": 0,
            "id": "tl3BWn",
            "likes": 1,
            "name": "For Mickey",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "MacLin",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "/*\nMIT License\n\nCopyright (c) 2019 - 2021 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nUpdate 1 (25-9-2019): added 2 lines to prevent mie from shining through objects inside the atmosphere\nUpdate 2 (2-10-2019): made use of HW_PERFORMANCE to improve performance on mobile (reduces number of samples), also added a sun\nUpdate 3 (5-10-2019): added a license\nUpdate 4 (28-11-2019): atmosphere now correctly blocks light from the scene passing through, and added an ambient scattering term\nUpdate 5 (28-11-2019): mouse drag now changes the time of day\nUpdate 6 (28-11-2019): atmosphere now doesn't use the ray sphere intersect function, meaning it's only one function\nUpdate 7 (22-12-2019): Compacted the mie and rayleigh parts into a single vec2 + added a basic skylight\nUpdate 8 (15-5-2020): Added ozone absorption (Can also be used as absorption in general)\n\nScattering works by calculating how much light is scattered to the camera on a certain path/\nThis implementation does that by taking a number of samples across that path to check the amount of light that reaches the path\nand it calculates the color of this light from the effects of scattering.\n\nThere are two types of scattering, rayleigh and mie\nrayleigh is caused by small particles (molecules) and scatters certain colors better than others (causing a blue sky on earth)\nmie is caused by bigger particles (like water droplets), and scatters all colors equally, but only in a certain direction. \nMie scattering causes the red sky during the sunset, because it scatters the remaining red light\n\nTo know where the ray starts and ends, we need to calculate where the ray enters and exits the atmosphere\nWe do this using a ray-sphere intersect\n\nThe scattering code is based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\nwith some modifications to allow moving the planet, as well as objects inside the atmosphere, correct light absorbsion\nfrom objects in the scene and an ambient scattering term tp light up the dark side a bit if needed\n\nthe camera also moves up and down, and the sun rotates around the planet as well\n\nNote: \tBecause rayleigh is a long word to type, I use ray instead on most variable names\n\t\tthe same goes for position (which becomes pos), direction (which becomes dir) and optical (becomes opt)\n*/\n\n// first, lets define some constants to use (planet radius, position, and scattering coefficients)\n#define PLANET_POS vec3(0.0) /* the position of the planet */\n#define PLANET_RADIUS 6371e3 /* radius of the planet */\n#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */\n// scattering coeffs\n#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */\n#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */\n#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */\n#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */\n#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */\n// and the heights (how far to go up before the scattering has no effect)\n#define HEIGHT_RAY 8e3 /* rayleigh height */\n#define HEIGHT_MIE 1.2e3 /* and mie */\n#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */\n#define ABSORPTION_FALLOFF 3e3 /* how much the absorption decreases the further away it gets from the maximum height */\n// and the steps (more looks better, but is slower)\n// the primary step has the most effect on looks\n#if HW_PERFORMANCE==0\n// edit these if you are on mobile\n#define PRIMARY_STEPS 12 \n#define LIGHT_STEPS 4\n# else\n// and these on desktop\n#define PRIMARY_STEPS 64 /* primary steps, affects quality the most */\n#define LIGHT_STEPS 4 /* light steps, how much steps in the light direction are taken */\n#endif\n\n// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space\n#define CAMERA_MODE 0\n\n/*\nNext we'll define the main scattering function.\nThis traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.\nFor every sample, we'll also trace a ray in the direction of the light, \nbecause the color that reaches the sample also changes due to scattering\n*/\nvec3 calculate_scattering(\n\tvec3 start, \t\t\t\t// the start of the ray (the camera position)\n    vec3 dir, \t\t\t\t\t// the direction of the ray (the camera vector)\n    float max_dist, \t\t\t// the maximum distance the ray can travel (because something is in the way, like an object)\n    vec3 scene_color,\t\t\t// the color of the scene\n    vec3 light_dir, \t\t\t// the direction of the light\n    vec3 light_intensity,\t\t// how bright the light is, affects the brightness of the atmosphere\n    vec3 planet_position, \t\t// the position of the planet\n    float planet_radius, \t\t// the radius of the planet\n    float atmo_radius, \t\t\t// the radius of the atmosphere\n    vec3 beta_ray, \t\t\t\t// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\n    vec3 beta_mie, \t\t\t\t// the amount mie scattering scatters colors\n    vec3 beta_absorption,   \t// how much air is absorbed\n    vec3 beta_ambient,\t\t\t// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter\n    float g, \t\t\t\t\t// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\n    float height_ray, \t\t\t// how high do you have to go before there is no rayleigh scattering?\n    float height_mie, \t\t\t// the same, but for mie\n    float height_absorption,\t// the height at which the most absorption happens\n    float absorption_falloff,\t// how fast the absorption falls off from the absorption height\n    int steps_i, \t\t\t\t// the amount of steps along the 'primary' ray, more looks better but slower\n    int steps_l \t\t\t\t// the amount of steps along the light ray, more looks better but slower\n) {\n    // add an offset to the camera position, so that the atmosphere is in the correct position\n    start -= planet_position;\n    // calculate the start and end position of the ray, as a distance along the ray\n    // we do this with a ray sphere intersect\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (atmo_radius * atmo_radius);\n    float d = (b * b) - 4.0 * a * c;\n    \n    // stop early if there is no intersect\n    if (d < 0.0) return scene_color;\n    \n    // calculate the ray length\n    vec2 ray_length = vec2(\n        max((-b - sqrt(d)) / (2.0 * a), 0.0),\n        min((-b + sqrt(d)) / (2.0 * a), max_dist)\n    );\n    \n    // if the ray did not hit the atmosphere, return a black color\n    if (ray_length.x > ray_length.y) return scene_color;\n    // prevent the mie glow from appearing if there's an object in front of the camera\n    bool allow_mie = max_dist > ray_length.y;\n    // make sure the ray is no longer than allowed\n    ray_length.y = min(ray_length.y, max_dist);\n    ray_length.x = max(ray_length.x, 0.0);\n    // get the step size of the ray\n    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);\n    \n    // next, set how far we are along the ray, so we can calculate the position of the sample\n    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere\n    // if it's inside, it should start at the position of the camera\n    // the min statement makes sure of that\n    float ray_pos_i = ray_length.x;\n    \n    // these are the values we use to gather all the scattered light\n    vec3 total_ray = vec3(0.0); // for rayleigh\n    vec3 total_mie = vec3(0.0); // for mie\n    \n    // initialize the optical depth. This is used to calculate how much air was in the ray\n    vec3 opt_i = vec3(0.0);\n    \n    // also init the scale height, avoids some vec2's later on\n    vec2 scale_height = vec2(height_ray, height_mie);\n    \n    // Calculate the Rayleigh and Mie phases.\n    // This is the color that will be scattered for this ray\n    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them\n    float mu = dot(dir, light_dir);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n    \n    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it\n    for (int i = 0; i < steps_i; ++i) {\n        \n        // calculate where we are along this ray\n        vec3 pos_i = start + dir * (ray_pos_i + step_size_i * 0.5);\n        \n        // and how high we are above the surface\n        float height_i = length(pos_i) - planet_radius;\n        \n        // now calculate the density of the particles (both for rayleigh and mie)\n        vec3 density = vec3(exp(-height_i / scale_height), 0.0);\n        \n        // and the absorption density. this is for ozone, which scales together with the rayleigh, \n        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height\n        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side\n        density.z = clamp((1.0 / cosh((height_absorption - height_i) / absorption_falloff)) * density.x, 0.0, 1.0);\n        density *= step_size_i;\n        \n        // Add these densities to the optical depth, so that we know how many particles are on this ray.\n        opt_i += density;\n\n        // Calculate the step size of the light ray.\n        // again with a ray sphere intersect\n        // a, b, c and d are already defined\n        a = dot(light_dir, light_dir);\n        b = 2.0 * dot(light_dir, pos_i);\n        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);\n        d = (b * b) - 4.0 * a * c;\n\n        // no early stopping, this one should always be inside the atmosphere\n        // calculate the ray length\n        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));\n\n        // and the position along this ray\n        // this time we are sure the ray is in the atmosphere, so set it to 0\n        float ray_pos_l = 0.0;\n\n        // and the optical depth of this ray\n        vec3 opt_l = vec3(0.0);\n        \n        // now sample the light ray\n        // this is similar to what we did before\n        for (int l = 0; l < steps_l; ++l) {\n\n            // calculate where we are along this ray\n            vec3 pos_l = pos_i + light_dir * (ray_pos_l + step_size_l * 0.5);\n\n            // the heigth of the position\n            float height_l = length(pos_l) - planet_radius;\n\n            // calculate the particle density, and add it\n            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);\n            density_l.z = clamp((1.0 / cosh((height_absorption - height_l) / absorption_falloff)) * density_l.x, 0.0, 1.0);\n            opt_l += density_l * step_size_l;\n\n            // and increment where we are along the light ray.\n            ray_pos_l += step_size_l;\n            \n        }\n        \n        // Now we need to calculate the attenuation\n        // this is essentially how much light reaches the current sample point due to scattering\n        vec3 attn = exp(-(beta_mie * (opt_i.y + opt_l.y) + beta_ray * (opt_i.x + opt_l.x) + beta_absorption * (opt_i.z + opt_l.z)));\n\n        // accumulate the scattered light (how much will be scattered towards the camera)\n        total_ray += density.x * attn;\n        total_mie += density.y * attn;\n\n        // and increment the position on this ray\n        ray_pos_i += step_size_i;\n    \t\n    }\n    \n    // calculate how much light can pass through the atmosphere\n    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));\n    \n\t// calculate and return the final color\n    return (\n        \tphase_ray * beta_ray * total_ray // rayleigh color\n       \t\t+ phase_mie * beta_mie * total_mie // mie\n            + opt_i.x * beta_ambient // and ambient\n    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly\n}\n\n/*\nA ray-sphere intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray sphere intersect built in\n*/\n\nvec2 ray_sphere_intersect(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {\n\n    // slightly bend the surface normal towards the light direction\n    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));\n    \n    // and sample the atmosphere\n    return calculate_scattering(\n    \tsample_pos,\t\t\t\t\t\t// the position of the camera\n        surface_normal, \t\t\t\t// the camera vector (ray direction of this pixel)\n        3.0 * ATMOS_RADIUS, \t\t\t// max dist, since nothing will stop the ray here, just use some arbitrary value\n        background_col,\t\t\t\t\t// scene color, just the background color here\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height\n        LIGHT_STEPS, \t\t\t\t\t// steps in the ray direction\n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n}\n\n/*\nThe following function returns the scene color and depth \n(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)\n\nin this case, the function renders a green sphere on the place where the planet should be\ncolor is in .xyz, distance in .w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {\n    \n    // the color to use, w is the scene depth\n    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);\n    \n    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white\n    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);\n    \n    // get where the ray intersects the planet\n    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); \n    \n    // if the ray hit the planet, set the max distance to that ray\n    if (0.0 < planet_intersect.y) {\n    \tcolor.w = max(planet_intersect.x, 0.0);\n        \n        // sample position, where the pixel is\n        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;\n        \n        // and the surface normal\n        vec3 surface_normal = normalize(sample_pos);\n        \n        // get the color of the sphere\n        color.xyz = vec3(0.0, 0.25, 0.05); \n        \n        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law\n        vec3 N = surface_normal;\n        vec3 V = -dir;\n        vec3 L = light_dir;\n        float dotNV = max(1e-6, dot(N, V));\n        float dotNL = max(1e-6, dot(N, L));\n        float shadow = dotNL / (dotNL + dotNV);\n        \n        // apply the shadow\n        color.xyz *= shadow;\n        \n        // apply skylight\n        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);\n    }\n    \n\treturn color;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 uv    = coord.xy / resolution.xy - vec2(0.5);\n         uv.x *= resolution.x / resolution.y;\n\n    return normalize(vec3(uv.x, uv.y, -1.0));\n}\n\n/*\nFinally, draw the atmosphere to screen\n\nwe first get the camera vector and position, as well as the light dir\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the camera vector\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord);\n    \n    // get the camera position, switch based on the defines\n#if CAMERA_MODE==0\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);\n#endif\n#if CAMERA_MODE==1\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS , ATMOS_RADIUS);\n#endif\n#if CAMERA_MODE==2\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS + (-cos(iTime / 2.0) * (ATMOS_RADIUS - PLANET_RADIUS - 1.0)), 0.0);\n#endif\n#if CAMERA_MODE==3\n    float offset = (1.0 - cos(iTime / 2.0)) * ATMOS_RADIUS;\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 1.0, offset);\n#endif\n    // get the light direction\n    // also base this on the mouse position, that way the time of day can be changed with the mouse\n    float theta = (iMouse.y - iResolution.y/2.0) / (iResolution.y/2.0) * (3.14/4.0);\n    float phi   = (iMouse.x + iResolution.x) / (iResolution.x/2.0) * (3.14/2.0);\n\n    float y = sin(theta);\n    float x = cos(theta) * cos(phi);\n    float z = cos(theta) * sin(phi);\n    \n    vec3 light_dir = normalize(vec3(x, y, z));\n    \n    // get the scene color and depth, color is in xyz, depth in w\n    // replace this with something better if you are using this shader for something else\n    vec4 scene = render_scene(camera_position, camera_vector, light_dir);\n    \n    // the color of this pixel\n    vec3 col = vec3(0.0);//scene.xyz;\n    \n    // get the atmosphere color\n    col += calculate_scattering(\n    \tcamera_position,\t\t\t\t// the position of the camera\n        camera_vector, \t\t\t\t\t// the camera vector (ray direction of this pixel)\n        scene.w, \t\t\t\t\t\t// max dist, essentially the scene depth\n        scene.xyz,\t\t\t\t\t\t// scene color, the color of the current pixel being rendered\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height \n        PRIMARY_STEPS, \t\t\t\t\t// steps in the ray direction \n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n        \n    // apply exposure, removing this makes the brighter colors look ugly\n    // you can play around with removing this\n    col = 1.0 - exp(-col);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}