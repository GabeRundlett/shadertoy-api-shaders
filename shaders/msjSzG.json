{
    "Shader": {
        "info": {
            "date": "1670479533",
            "description": "My first shader! I followed The Art of Code's tutorials for the camera and pixel coordinate setup, but I did manage to us my own method for calculating the surface normals.",
            "flags": 0,
            "hasliked": 0,
            "id": "msjSzG",
            "likes": 1,
            "name": "Foobar's Sphere",
            "published": 3,
            "tags": [
                "raymarcher",
                "spheretracing",
                "firstshader"
            ],
            "usePreview": 0,
            "username": "FoobarBigTime",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "const float MAX_DIST = 100.;\nconst int MAX_STEPS = 50;\nconst float MIN_DIST = .01;\n\nvec4 normSDF_Sph(vec3 obsPoint, vec3 orig, float size){\n    vec3 disp_vec = orig - obsPoint;\n    float dist = length(disp_vec)-size;\n    return vec4 (disp_vec, dist);\n}\n\nvec4 sceneSDF(vec3 obsPoint){\n    return normSDF_Sph(obsPoint, vec3(0., 0., 0.), 1.);\n}\n\nvec4 rayMarcher(vec3 rayOrig, vec3 rayDir){\n    vec4 sdfValues = sceneSDF(rayOrig);\n    float dist = sdfValues.w;\n\n    for(int i = 0; i < MAX_STEPS; i ++){\n        vec3 p = rayOrig + rayDir*dist;\n        vec4 sdfValues = sceneSDF(p);\n\n        float newDist = sdfValues.w;\n        if(newDist < MIN_DIST){\n            return(sdfValues);\n        }\n        dist += newDist;\n        if(dist > MAX_DIST){\n            return vec4(.7, .2, .2, MAX_DIST);\n        }\n    }\n    return(vec4(rayDir, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float FoVy = radians(45.);\n    \n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float turnSpeed = 0.005;\n    \n    vec3 camPos = vec3(4. * (sin(.01 * iMouse.x)), 0., 4. * (cos(.01 * iMouse.x)));\n    \n    //.5 is size of screen from center to edge\n    float camZoom = 1. / (tan(FoVy));\n    \n    vec3 camTarget = vec3(0., 0., 0.);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camRight = cross(vec3(0., 1., 0.), camDir);\n    vec3 camUp = cross(camDir,camRight);\n    \n    vec3 camCenter = camPos + camDir*camZoom;\n    vec3 rayIntersect = camCenter + uv.x*camRight + uv.y*camUp;\n    \n    vec3 rayDir = rayIntersect-camPos;\n\n    //Draw Scene.\n    vec4 sceneView = rayMarcher(camPos, rayDir);\n    float hit = sceneView.w;\n    vec3 hitNormal = normalize(sceneView.xyz);\n    \n    vec3 col = vec3(1., 0., 1.);\n    vec3 lightDir = vec3(0., -.65, 2);\n    float lit = dot(lightDir, hitNormal);\n    fragColor = vec4(col*lit, 1.);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}