{
    "Shader": {
        "info": {
            "date": "1563401369",
            "description": "A simple gabor noise implementation with analytical derivatives.  ",
            "flags": 0,
            "hasliked": 0,
            "id": "3tlXRB",
            "likes": 6,
            "name": "Analytical Gabor Noise",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "gabor"
            ],
            "usePreview": 0,
            "username": "joeedh",
            "viewed": 525
        },
        "renderpass": [
            {
                "code": "/*\na simple gabor noise implementation with analytical derivatives.\n\nauthor: Joseph Eagar\nhttps://www.shadertoy.com/view/3tlXRB\n*/\n\n//uncomment to enable finite difference version\n//#define SHOW_FINITE_DIFFERENCE\n#define SHOW_FUNCTION //uncomment to see final noise\n\n#define STEPS 6                //size of grid, lower values require higher DECAY\n#define DECAY 1.0              //gabor decay; lower values require higher STEPS\n#define K1 sqrt(10.132)        //hash function coefficient for x\n#define K2 sqrt(2.2342)        //hash function coefficient for y\n#define GABOR_FREQUENCY 5.534  //frequency of gabor line grating\n\n#define PI 3.14159265453\nfloat vnoise(vec2 p,out vec2 dv) {\n    vec2 fp = floor(p);\n    float f=0.0, tot=0.0;\n    \n    dv[0] = dv[1] = 0.0;\n    float scale2 = GABOR_FREQUENCY;\n    \n    /* script for reduce-algebra symbolic manipulator\n    on factor;\n\t\n\tcomment: very bad but simple and fast hashing functions;\n\n    procedure hash(seed);\n        cos(seed*PI);\n    procedure hash2(x, y);\n        hash(x*k1 + y*k2);\n\n    seed := hash2(p2x, p2y);\n    d := (p2x-px)**2 + (p2y-py)**2;\n\n    f2 := cos((cos(seed)*px - sin(seed)*py)*scale2);\n    f2 := trigsimp(f2);\n    w := exp(-d*decay);\n\n    on fort;\n\n    dx := df(f2, px);\n    dy := df(f2, py);\n\n    wdx := df(w, px);\n    wdy := df(w, py);\n    */\n\n    for (int i=0; i<STEPS; i++) {\n        for (int j=0; j<STEPS; j++) {\n            vec2 p2 = fp;\n            \n            p2.x += (float(i) - float(STEPS)*0.5);\n            p2.y += (float(j) - float(STEPS)*0.5);\n\n            vec2 n = p2 - p;\n            float d = dot(n, n);\n            float f2;\n            \n            float px = p.x, py = p.y, p2x = p2.x, p2y = p2.y;\n            float pi = PI;\n            \n            //coefficients for hashing function\n            float k1=K1, k2=K2;\n            \n            //gabor noise is made from randomly rotated line gratings\n            //here we approximate \"random\", see reduce script above.\n           \tf2 = cos((cos(cos((k1*p2x+k2*p2y)*pi))*px-sin(cos((k1*p2x+k2*p2y)*pi))*py)*scale2);\n\t\t\t\n            //derivatives of grating\n            float dx = -cos(cos((k1*p2x+k2*p2y)*pi))*sin((cos(cos((k1*p2x+k2*p2y)*\n     \t\t\t\t\tpi))*px-sin(cos((k1*p2x+k2*p2y)*pi))*py)*scale2)*scale2;\n\n            float dy = sin(cos((k1*p2x+k2*p2y)*pi))*sin((cos(cos((k1*p2x+k2*p2y)*\n     \t\t\t\t\tpi))*px-sin(cos((k1*p2x+k2*p2y)*pi))*py)*scale2)*scale2;\n\n            \n            //derivative of decay function\n            float w = exp(-d*DECAY);\n            float dwx = (2.0*(p2x-px)*DECAY)/exp(((p2x-px)*(p2x-px)+(p2y-py)*(p2y-py))*DECAY);\n            float dwy = (2.0*(p2y-py)*DECAY)/exp(((p2x-px)*(p2x-px)+(p2y-py)*(p2y-py))*DECAY);\n            \n            //apply product rule\n            dv[0] += dx*w + f2*dwx;\n            dv[1] += dy*w + f2*dwy;\n            \n            f += f2*w;\n            tot += w;\n            \n        }\n    }\n    \n    //since final value is (f/tot)*0.5+0.5, we have to divide the derivatives\n    //by 2.0*tot\n    dv /= 2.0*tot;\n    \n    f /= tot;\n    f = f*0.5 + 0.5;\n    \n    return f;\n}\n\nvec2 dvnoise(vec2 uv) {\n    const float df = 0.0005;\n    vec2 dv1;\n\n    float a = vnoise(uv, dv1);\n    float b = vnoise(uv+vec2(df, 0.0), dv1);\n    float c = vnoise(uv+vec2(0.0, df), dv1);\n        \n\treturn vec2(\n        (b - a)/df,\n        (c - a)/df\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 dv;\n    float sz = 12.5 + 100.0*iMouse.y / iResolution.y;\n    float f = vnoise(uv*sz, dv); \n    \n#ifdef SHOW_FUNCTION\n    fragColor = vec4(f, f, f, 1.0);\n#else\n#ifdef SHOW_FINITE_DIFFERENCE\n    dv = dvnoise(uv*sz);\n#endif\n    \n    dv = dv*0.5 + 0.5;\n    fragColor = vec4(dv, 0.0, 1.0);\n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}