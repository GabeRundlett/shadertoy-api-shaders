{
    "Shader": {
        "info": {
            "date": "1719538965",
            "description": "Warmhole Aventurer Visualizer",
            "flags": 33,
            "hasliked": 0,
            "id": "4XcSWj",
            "likes": 10,
            "name": "Warmhole aventurer",
            "published": 3,
            "tags": [
                "tunnel",
                "sound",
                "fft",
                "hyperspace"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "// Fork of \"Hyperspace Visualizer\" by orblivius. https://shadertoy.com/view/l3V3D1\n// 2024-06-28 00:03:24\n\n// Hyperspace music visualizer\n// by Orblivius\n\n// Fork of \"The Hole adventure\" by vovach777. https://shadertoy.com/view/lXG3D1\n// 2024-06-05 17:43:33\n//logic taken from gaz: https://www.shadertoy.com/view/ftKBzt\n//and made more verbose and tweaked\n\n#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos( h/2. * vec3(1,2,4) )*.7 + .2 )\n\n//formula for mapping scale factor \n#define M(c)  log(c)\n\n#define R iResolution\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p, vec2 roll) {\nfloat theta=0., phi=0.;\n  vec2 mm = roll;\n  if (iMouse.x > 0.0) {\n    theta += (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    phi += (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n   \n  }\n   p.yz = rotate(p.yz,-theta+mm.x);\n   p.zx = rotate(p.zx,phi+mm.y);\n  return p;\n}\n\n  \nfloat map(float v, float v_min, float v_max, float out1, float out2)\n{\n    if ( v_max - v_min == 0. )\n        return out2;\n        \n     return (clamp(v,v_min,v_max) - v_min) / (v_max - v_min) * (out2-out1)+out1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  mouseCoord = iMouse.xy / iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    vec2  rolling = vec2(sin(iTime), cos(iTime));\n     vec2 uvv = vec2( map(fragCoord.x,0., iResolution.x,-1.,1.),  map(fragCoord.y,0., iResolution.y,-ar,ar)    ) + rolling*0.25;\n    float z = 2. / max(length(uvv),0.1);\n    float angle = map( atan(uvv.y,uvv.x), -PI, PI, 0., 1. );\n    float zmax =  map(rolling.x,-1.,1.,0.025,0.);\n    float fade = map(z,0.,  20.-8.*zmax , 1.0, 0.);\n    \n   vec4 O = vec4(0); vec2 U = fragCoord;\n   \n    vec3 c=vec3(0), rd = normalize( vec3(U-.5*R.xy, R.y))*10.;\n    \n    float sc,dotp,totdist=0.;\n    vec2 m = vec2(iMouse.x,iMouse.y)/iResolution.xy*10.;\n  \n    for (float i=0.; i<100.; i++) {\n     float snd = (texture(iChannel0, vec2(.1,0.25)).r +  texture(iChannel0, vec2(.1001,0.25)).r); \n        \n        vec4 p = vec4( .5+rd*totdist, 0.5);\n        \n        \n       p.xyz += vec3(0,0,-20.-80.*abs(sin(.1*iTime)*cos(.3*iTime)));\n   \n  \n        p.xyz = transform(p.xyz,rolling); // ; //ROT( p.xyz, normalize(vec3(sin(t/5.),cos(t/3.),0)+vec3(m.x,m.y,-m.x/m.y) ),t);\n        sc = 1.;  //scale factor\n           \n        float dd = 1.;\n       // p = mod(p6dd,2.*dd) - dd;  //try this if you like\n        \n        for (float j=0.; j<4.; j++) {\n        \n            p =  log(.56+abs(p)) ;\n            \n            dotp = max(1.05/dot(p,p),.12);\n            sc *= dotp + 0.025; \n            \n            p *= dotp - .2-.6*.07+.05*clamp(snd,.01,.1);\n          \n           \n        }\n         \n        float dist =  abs( length(p)-.5)/sc ;  //funky distance estimate\n        float stepsize = dist/2. + 1e-4;     //distance plus a little extra\n        totdist += stepsize;              //move the distance along rd\n        \n       \n        //accumulate color, fading with distance and iteration count\n        c += mix( vec3(1), H(M(sc)),.35) *.03*  exp(-i*i*stepsize*stepsize*200.);\n    }\n    \n    c = clamp(c,0.,1.);\n    c *= c;\n    \n    //O = ( vec4(c,0) );\n    // Normalized pixel coordinates (from 0 to 1)\n\n   \n    vec3 color =   vec3( texture(iChannel0, vec2( angle +rolling.y*0.04, z * zmax+ iTime*0.2)  ).r )     * vec3(2.,.3,.8);\n    vec3 color1 =  vec3( pow( texture(iChannel1, vec2( angle+0.5+rolling.y*0.04,z *  (zmax)  + iTime*0.1)  ).r*1.2 ,2.1)) * vec3(.8,.1,1.5);\n     vec3 color2 =  vec3( pow( texture(iChannel2, vec2( angle+0.5+rolling.y*0.04,z *  (zmax)  + iTime*0.1)  ).r*1.2 ,2.1)) * vec3(.8,.1,1.5);\n   color2 =  hueShift(color2, .8); \n   color = hueShift(color, 5.5);  color*= color; \n  \n    color1 = hueShift(color1,1.); \n    color1*=color1;    \n     fragColor = vec4( 2.*c+(color +  color2) * fade , 1.);\n  //  \n    // Output to screen\n    //fragColor = vec4(col,col*0.65,0.,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat text(vec2 fragCoord)\n{\n    vec2 uv = mod(fragCoord.xy, 16.)*.0625;\n    vec2 block = fragCoord*.0625 - uv;\n    uv = uv*.8+.1; // scale the letters up a bit\n    uv += floor(texture(iChannel1, block/iChannelResolution[1].xy + iTime * .002).xy * 16.); // randomize letters\n    uv *= .0625; // bring back into 0-1 range\n    uv.x = -uv.x; // flip letters horizontally\n    return texture(iChannel0, uv).r;\n}\n\nvec3 rain(vec2 fragCoord)\n{\n\tfragCoord.x -= mod(fragCoord.x, 16.);\n    //fragCoord.y -= mod(fragCoord.y, 16.);\n    \n    float offset=sin(fragCoord.x*15.);\n    float speed=cos(fragCoord.x*3.)*.3+.12;\n   \n    float y = 5.*fract(fragCoord.y/iResolution.y + iTime*speed + offset);\n    return vec3(random(vec2(offset)),random(vec2(offset)*y),random(vec2(offset)*speed)) / (y*5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(text(fragCoord)*rain(fragCoord),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define BPM 120.0\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPS 0.0001\n#define _beat (iTime * BPM / 60.0)\n#define beat (mod(_beat, 32.0))\n\nbool between(float x, float from, float to) {\n    return from <= x && x < to;\n}\n\n// primitives\nfloat sdCircle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdRect(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return max(d.x, d.y) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTriangle(vec2 p, float size) {\n    vec2 s = size * vec2(0.25, 0.43301270189);\n    p.y -= size * 0.14433756729;// sqrt(3) / 12\n\treturn sdRect(p, vec2(s.x - p.y * s.x / s.y, s.y));\n}\n\n// operations\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nvec2 opRep(vec2 p, vec2 c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nfloat opRep(float p, float c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n// color\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// https://www.shadertoy.com/view/3tX3R4\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\n// https://gist.github.com/mattatz/d7b8decb481947d2e37eab98aff2d0ad\n// https://neort.io/art/bj2225k3p9f9psc9ovf0?index=0&origin=my_profile\nfloat ease_in_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn c*(t/=d)*t + b;\n}\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\nvec3 hueShift(vec3 col, float shift){\nvec3 m = vec3(cos(shift), -sin(shift) * .57735, 0);\nm = vec3(m.xy, -m.y) + (1. - m.x) * .33333;\nreturn mat3(m, m.zxy, m.yzx) * col;\n}\n\nfloat ease_out_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn -c *(t/=d)*(t-2.) + b;\n}\n\nfloat ease_in_out_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\tif ((t/=d/2.)<1.) return c/2.*t*t + b;\n\treturn -c/2. * ((--t)*(t-2.) - 1.) + b;\n}\n\nfloat ease_in_cubic(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn c*(t/=d)*t*t + b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"star and universe\" by nayk. https://shadertoy.com/view/XffXDf\n// 2024-01-22 05:55:07\n\n/*https://www.shadertoy.com/view/4tyfWy  https://www.shadertoy.com/view/MfsSD2  https://www.shadertoy.com/view/lslyRn*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n      p.xy*=mat2(cos(iTime*0.005),sin(iTime*0.005),-sin(iTime*0.005),cos(iTime*0.005));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.1; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*vec3(0.015,0.015,0.015); // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define TAU 6.283184\n\nconst vec4 lineColor = vec4(0.25, 0.5, 1.0, 1.0);\nconst vec4[] bgColors = vec4[]\n(\n    lineColor * 0.5,\n    lineColor - vec4(0.2, 0.2, 0.7, 1)\n);\n\n\n// probably can optimize w/ noise, but currently using fourier transform\nfloat random(float t)\n{\n    return (cos(t) + cos(t * 1.3 + 1.3) + cos(t * 1.4 + 1.4)) / 3.0;   \n}\n\nvec2 rotateUV(vec2 uv, float angle) \n{\n    angle = angle*TAU;\n    mat2 matrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    return matrix * uv;\n}\n\n\nfloat arc(float r, vec2 uv, float orientation, float radius, float section)\n{\n    uv = rotateUV(uv, orientation);\n    float theta = atan(uv.x, uv.y)/TAU;\n\n    float t = 100. * section;\n    float value = \n        min(2.0, pow(0.001 / abs(r - radius),2.)) *\n        min(2.0, pow(0.005 / abs(theta / t),t / 1.));\n    \n    return value;\n}\nfloat radial(float r, vec2 uv, float orientation, float radius, float section)\n{\n    uv = rotateUV(uv, orientation);\n    float theta = atan(uv.x, uv.y)/TAU;\n\n    //float value = min(2.0, 0.002 / abs(theta)) *;\n\n    float t = 100. * section;\n    float value = \n        min(2.0, 0.00025 / abs(theta)) *\n        min(2.0, pow(0.005 / abs((r - radius) / t),t / 2.));\n\n    return value;\n}\n\nfloat rich_beautiful_healthy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nfloat hash11(float p) {\n    return float(pcg(uint(p)))/4294967296.;\n}\n\nvec2 hash21(float p) {\n    return vec2(pcg2d(uvec2(p, 0)))/4294967296.;\n}\n\nvec3 hash33(vec3 p3) {\n    return vec3(pcg3d(uvec3(p3)))/4294967296.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec2 uv2=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.002);\n\tfloat time=iTime*speed+.25;\n\n float aspect = iResolution.x / iResolution.y;\n    \n\n    float r = length(uv);\n    \n\n    const vec3 base_color = vec3(0.2, 0.3, 1.0);\n    \n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n    vec2 center = (iResolution.xy/2.);\n\t float c0 = 0., c1 = 0.;\n\n \n    // Some blueish tone\n    const vec3 blue_shift = vec3(1.0, 1.0, 1.0);\n    vec3 color = vec3(.3,0.3,1.1);\n\n    float verticalFade = cos(uv2.y * 13.28) * 0.05 + 0.5;\n    fragColor = mix(bgColors[1], bgColors[1], uv2.x/1.);\n    fragColor *= verticalFade/2.;\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n \n   // fragColor += vec4(c0*blue_shift,0.5);\n   //  fragColor += vec4(c1*base_color,1.0);\n     // uv *=  ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n   // float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n\n   // fragColor*= vec4( vec3(0.5,0.1,0.01), 1.0);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Crossing storms, by ukeshet\n// Based on https://twitter.com/zozuar/status/1441384708441456651, with added periodic darkening + lightening.\n// As mentioned in comments: the @zozuar tweet is apparently based on nimitz (twitter: @stormoid) https://www.shadertoy.com/view/3l23Rh\n\nfloat rs = 0.;\nfloat hash21(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\n\nfloat perlinNoise(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec2 blur = smoothstep(.0, 1., fuv);\n    vec2 bl = vec2(.0, .0);\n    vec2 br = vec2(1., .0);\n    vec2 tl = vec2(.0, 1.);\n    vec2 tr = vec2(1., 1.);\n    vec2 bln = hash22(iuv + bl);\n    vec2 brn = hash22(iuv + br);\n    vec2 tln = hash22(iuv + tl);\n    vec2 trn = hash22(iuv + tr);\n    float b  = mix(dot(bln, fuv - bl), dot(brn, fuv - br), blur.x);\n    float t  = mix(dot(tln, fuv - tl), dot(trn, fuv - tr), blur.x);\n    float c = mix(b, t, blur.y);\n   \n       \n    return (c);\n}\n\nfloat fbm(vec2 uv, int octaves)\n{\n    float value = 0.;\n    float ampitude  = 2.;\n    float freq = 2. ;\n   \n\n    \n    for(int i = 0; i < octaves; i++)\n    {  \n      value += .5 * perlinNoise(uv) * ampitude;\n        uv *= freq;\n        ampitude *= .15+.4*rs;\n    }\n    return value;\n}\n\n\nmat2 R(float q){return mat2(cos(q),sin(q),-sin(q),cos(q));}\nvoid mainImage(out vec4 Col,in vec2 FC) \n{\n    vec2 uvv = (FC - 0.5 * iResolution.xy)/iResolution.y;\n      rs = texture(iChannel0, vec2(abs(FC.x/iResolution.x-0.5),0.25)).r;\n    vec3 col1, col2; \n    uvv.y = 0.4*uvv.y+ fbm(uvv.yx+2.*((.2*iTime)) ,10);\n    float dist1 = abs(uvv.y);\n    \n    dist1 = hash21(vec2(abs(sin(iTime)))) / dist1;\n    col1 = mix(vec3(0.), vec3(.02), dist1);\n \n    \n    \n    Col = vec4(col1,dist1);\n   \n   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Gaussian blur effect\n    vec2 texel = 1.0 / iResolution.xy;\n    vec4 total_color = vec4(0.0);\n\n    // Gaussian kernel from common tab\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    // Apply Gaussian blur to the texture from channel 0\n    for (int i = 0; i < 2; i++) {\n        float fi = float(i) - 2.0;\n        for (int j = 0; j < 7; j++) {\n            float fj = float(j) - 2.0;\n            vec4 color = texture(iChannel0, uv + vec2(texel.x * fi, texel.y * fj)) +\n             texture(iChannel1, uv + vec2(texel.x * fi, texel.y * fj));\n            total_color += color * gk1s[i * 5 + j];\n        }\n    }\n\n\n    // Output the final color\n    fragColor = total_color;\n}\n\n\n\n   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}