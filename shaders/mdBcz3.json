{
    "Shader": {
        "info": {
            "date": "1688036284",
            "description": "Check out my Interactive 2D Wave Simulation:\nhttps://www.shadertoy.com/view/mdScW1\n\nCheck out my Python wave simulation project:\nhttps://github.com/bean-mhm/wave-simulation-py",
            "flags": 32,
            "hasliked": 0,
            "id": "mdBcz3",
            "likes": 21,
            "name": "3D Wave Simulation",
            "published": 3,
            "tags": [
                "wave",
                "simulation",
                "physics",
                "waveequation",
                "wavesim"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 462
        },
        "renderpass": [
            {
                "code": "// iChannel0 = Buffer A\n// iChannel1 = Buffer B\n\nfloat wave_fetch_curr(ivec3 icoord)\n{\n    if (!icoord_in_bounds(icoord, wave_res))\n        return 0.0;\n    return texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0).x;\n}\n\nvec3 get_col(vec2 frag_coord, vec3 tint)\n{\n    // UV\n    vec2 uv = frag_coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    // Setup camera\n\n    float r = 1.25 * max(wave_dims.x, wave_dims.y);\n    float theta = TWO_PI * iTime * 0.08 - (PI / 2.0);\n    vec3 cam_pos = vec3(r * cos(theta), r * sin(theta), wave_dims.z * 0.2);\n    float cam_fov = 80.0;\n    float cam_zoom = 90.0 / cam_fov;\n\n    vec3 cam_forward = normalize(vec3(0.0, 0.0, wave_dims.z * -0.04) - cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n\n    // Ray\n    Ray ray;\n    ray.orig = cam_pos;\n    ray.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    \n    // Box that contains the wave field\n    vec3 box_min = -wave_dims / 2.0;\n    vec3 box_max = wave_dims / 2.0;\n    \n    // Check intersection with the box\n    Hit hit;\n    ray_aabb(box_min, box_max, ray, hit);\n    \n    // Shade\n    vec3 col = vec3(0.0);\n    if (hit.hit)\n    {\n        col += vec3(0.01);\n        \n        // Intersection length along the ray\n        float len = max(0.0, hit.tmax - hit.tmin);\n        \n        // Step size for traversing the volume\n        const float volume_traverse_step = max(max(wave_dims.x, wave_dims.y), wave_dims.z) / 40.0;\n        \n        // Number of volume samples\n        int num_volume_samples = int(max(4.0, len / volume_traverse_step));\n        \n        // Constants multiplier\n        float mul = pow(2.0, 25.0) / float(num_volume_samples);\n        \n        // Samples\n        for (int i = 0; i < num_volume_samples; i++)\n        {\n            // Point along the ray inside the volume\n            float t = mix(hit.tmin, hit.tmax, float(i) / float(num_volume_samples));\n            vec3 p = ray.orig + t * ray.dir;\n            \n            // Trilinear interpolation\n            vec3 coord = vec3(wave_res) * (p - box_min) / wave_dims;\n            ivec3 p0 = ivec3(floor(coord));\n            ivec3 p1 = p0 + 1;\n            float x0y0z0 = wave_fetch_curr(p0);\n            float x1y0z0 = wave_fetch_curr(ivec3(p1.x, p0.y, p0.z));\n            float x0y1z0 = wave_fetch_curr(ivec3(p0.x, p1.y, p0.z));\n            float x1y1z0 = wave_fetch_curr(ivec3(p1.x, p1.y, p0.z));\n            float x0y0z1 = wave_fetch_curr(ivec3(p0.x, p0.y, p1.z));\n            float x1y0z1 = wave_fetch_curr(ivec3(p1.x, p0.y, p1.z));\n            float x0y1z1 = wave_fetch_curr(ivec3(p0.x, p1.y, p1.z));\n            float x1y1z1 = wave_fetch_curr(p1);\n            float v = interpolate3D(\n                coord - vec3(p0),\n                x0y0z0,\n                x1y0z0,\n                x0y1z0,\n                x1y1z0,\n                x0y0z1,\n                x1y0z1,\n                x0y1z1,\n                x1y1z1\n            );\n            \n            // Update the color\n            col += pow(abs(v), 3.0) * mul * tint;\n        }\n    }\n    \n    // Glow\n    col += tint * 0.15 * pow(max(0.0, dot(ray.dir, normalize(-cam_pos))), 9.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Initialize PRNG\n    eprng_init(frag_coord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // RGB sweep\n    vec3 tint = rgb_sweep(iTime * 0.05 + 0.53);\n\n    // Jitter sampling\n    const int num_samples = 4;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        col += get_col(frag_coord + vec2(random() - 0.5, random() - 0.5), tint);\n    }\n    col /= float(num_samples);\n    \n    // Color grading\n    col = pow(col, vec3(1.2));\n    col += 0.015 * pow(tint, vec3(6.0));\n    \n    // Noise\n    col += map_range_clamp(random(), 0.0, 1.0, -0.01, 0.005);\n    \n    // flim\n    col = flim_transform(col, 0.0, iChannel1);\n    \n    frag_col = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265358979\n#define TWO_PI 6.28318530717959\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float tmin;\n    float tmax;\n};\n\n// Grid Resolution\nconst ivec3 wave_res = ivec3(50, 50, 50);\n\n// Minimum distance in the grid\nconst float wave_step = 0.01;\nconst float wave_step2 = wave_step * wave_step;\n\n// Grid dimensions\nconst vec3 wave_dims = wave_step * vec3(wave_res - 1);\n\n// Propagation speed in 2D\nconst float wave_speed = 10.0;\nconst float wave_speed2 = wave_speed * wave_speed;\n\n// Minimum wavelength\n// At least 8 steps needed for a perfectly smooth spherical wave.\nconst float wave_min_wavelength = wave_step * sqrt(3.0) * 8.0;\n\n// Maximum frequency\nconst float wave_max_frequency = wave_speed / wave_min_wavelength;\n\n// Maximum timestep\nconst float wave_max_dt = wave_step / (wave_speed * sqrt(3.0));\n\n// Timestep\nconst float wave_dt = 0.3 * wave_max_dt;\n\n// Stiffness\n// Must be greater than or equal to 1 to function properly.\nconst float wave_stiffness = 10.0;\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat fit_to_screen(vec2 image_res, vec2 screen_res)\n{\n    return min(screen_res.x / image_res.x, screen_res.y / image_res.y);\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), map_range_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), map_range_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), map_range_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), map_range_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), map_range_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), map_range_clamp(x, 0.6, 1.0, 0.0, 1.0));\n\n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n\n    return c;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y)\n        && (icoord.z >= 0) && (icoord.z < res.z);\n}\n\nivec3 idx_to_icoord3d(int idx, ivec3 res)\n{\n    return ivec3(\n        idx % res.x,\n        (idx % (res.x * res.y)) / res.x,\n        idx / (res.x * res.y)\n    );\n}\n\nint icoord3d_to_idx(ivec3 icoord, ivec3 res)\n{\n    return\n        icoord.x\n        + icoord.y * res.x\n        + icoord.z * res.x * res.y;\n}\n\nivec2 idx_to_icoord2d(int idx, ivec2 res)\n{\n    return ivec2(idx % res.x, idx / res.x);\n}\n\nint icoord2d_to_idx(ivec2 icoord, ivec2 res)\n{\n    return icoord.x + icoord.y * res.x;\n}\n\nivec3 icoord2d_to_3d(ivec2 icoord2d, ivec2 res2d, ivec3 res3d)\n{\n    return idx_to_icoord3d(icoord2d_to_idx(icoord2d, res2d), res3d);\n}\n\nivec2 icoord3d_to_2d(ivec3 icoord3d, ivec3 res3d, ivec2 res2d)\n{\n    return idx_to_icoord2d(icoord3d_to_idx(icoord3d, res3d), res2d);\n}\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, const Ray r, out Hit hit) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    hit.tmin = t0;\n    hit.tmax = t1;\n    hit.hit = t1 > max(t0, 0.0);\n}\n\nvec4 sample_bilinear(vec2 coord, sampler2D src, ivec2 src_res)\n{\n    ivec2 bottomLeftPos = ivec2(int(floor(coord.x - 0.5)), int(floor(coord.y - 0.5)));\n\n    ivec2 topRightPos = ivec2(bottomLeftPos.x + 1, bottomLeftPos.y + 1);\n\n    ivec2 bottomRightPos = ivec2(topRightPos.x, bottomLeftPos.y);\n\n    ivec2 topLeftPos = ivec2(bottomLeftPos.x, topRightPos.y);\n\n    float alongX = coord.x - (float(bottomLeftPos.x) + 0.5);\n    float alongY = coord.y - (float(bottomLeftPos.y) + 0.5);\n\n    float bottomLeftWeight = (1.0 - alongX) * (1.0 - alongY);\n    float bottomRightWeight = (alongX) * (1.0 - alongY);\n    float topLeftWeight = (1.0 - alongX) * (alongY);\n    float topRightWeight = (alongX) * (alongY);\n\n    vec4 result = vec4(0.0);\n\n    if (icoord_in_bounds(bottomLeftPos, src_res))\n        result += bottomLeftWeight * texelFetch(src, bottomLeftPos, 0);\n\n    if (icoord_in_bounds(topRightPos, src_res))\n        result += topRightWeight * texelFetch(src, topRightPos, 0);\n\n    if (icoord_in_bounds(bottomRightPos, src_res))\n        result += bottomRightWeight * texelFetch(src, bottomRightPos, 0);\n\n    if (icoord_in_bounds(topLeftPos, src_res))\n        result += topLeftWeight * texelFetch(src, topLeftPos, 0);\n\n    return result;\n}\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_INTERPOLATE_2D(T) T \\\ninterpolate2D(vec2 p, T x0y0, T x1y0, T x0y1, T x1y1) \\\n{ \\\n    T s = lerp(x0y0, x1y0, p.x); \\\n    T t = lerp(x0y1, x1y1, p.x); \\\n    return lerp(s, t, p.y); \\\n}\n\n#define FUNC_INTERPOLATE_3D(T) \\\nT interpolate3D( \\\n    vec3 p, \\\n    T x0y0z0, \\\n    T x1y0z0, \\\n    T x0y1z0, \\\n    T x1y1z0, \\\n    T x0y0z1, \\\n    T x1y0z1, \\\n    T x0y1z1, \\\n    T x1y1z1) \\\n{ \\\n    T s = interpolate2D(p.xy, x0y0z0, x1y0z0, x0y1z0, x1y1z0); \\\n    T t = interpolate2D(p.xy, x0y0z1, x1y0z1, x0y1z1, x1y1z1); \\\n    return lerp(s, t, p.z); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_INTERPOLATE_2D(float)\nFUNC_INTERPOLATE_2D(vec2)\nFUNC_INTERPOLATE_2D(vec3)\nFUNC_INTERPOLATE_2D(vec4)\n\nFUNC_INTERPOLATE_3D(float)\nFUNC_INTERPOLATE_3D(vec2)\nFUNC_INTERPOLATE_3D(vec3)\nFUNC_INTERPOLATE_3D(vec4)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// iChannel0 = Buffer A (self-feeding)\n// iChannel1 = Buffer C\n\nfloat wave_initial_val(ivec3 icoord)\n{\n    return 0.0;\n}\n\nfloat wave_update_val(ivec3 icoord, float curr, float sim_time)\n{\n    // Initial pulse at the center\n    if (icoord == wave_res / 2)\n    {\n        float amp = map_range_clamp(sim_time, 0.0, 0.006, 1.0, 0.0);\n        float freq = 0.95 * wave_max_frequency;\n        if (amp > 0.001)\n        {\n            return amp * sin(TWO_PI * sim_time * freq);\n        }\n    }\n\n    return curr;\n}\n\nfloat wave_fetch_curr(ivec3 icoord)\n{\n    //if (!icoord_in_bounds(icoord, wave_res))\n    //    return 0.0;\n    \n    // Disabled bounds checking because below we\n    // do manual bounds checking ONLY on the axis\n    // needed, reducing the overall number of\n    // checks.\n    \n    return texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0).x;\n}\n\n// X = current value\n// Y = previous value\n// Z = iteration\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec3 icoord = icoord2d_to_3d(ivec2(frag_coord), ivec2(iResolution.xy), wave_res);\n\n    // Skip if we're outside the grid\n    if (!icoord_in_bounds(icoord, wave_res))\n        return;\n\n    vec4 data = texelFetch(iChannel0, icoord3d_to_2d(icoord, wave_res, ivec2(iResolution.xy)), 0);\n    float curr = data.x;\n    float prev = data.y;\n    int iter = int(data.z);\n\n    // First frame (initial values)\n    bool reset =\n        iter == 0\n        || iFrame < 1\n        || iTime == 0.0\n        || ivec2(iResolution.xy) != ivec2(texelFetch(iChannel1, ivec2(0), 0).xy);\n    if (reset)\n    {\n        float v = wave_initial_val(icoord);\n        frag_col = vec4(v, v, 1.0, 0.0);\n        return;\n    }\n\n    float next_in_x = 0.0;\n    float prev_in_x = 0.0;\n    float next_in_y = 0.0;\n    float prev_in_y = 0.0;\n    float next_in_z = 0.0;\n    float prev_in_z = 0.0;\n    if ((icoord.x + 1) < wave_res.x)\n    {\n        next_in_x = wave_fetch_curr(icoord + ivec3(1, 0, 0));\n    }\n    if ((icoord.x - 1) >= 0)\n    {\n        prev_in_x = wave_fetch_curr(icoord + ivec3(-1, 0, 0));\n    }\n    if ((icoord.y + 1) < wave_res.y)\n    {\n        next_in_y = wave_fetch_curr(icoord + ivec3(0, 1, 0));\n    }\n    if ((icoord.y - 1) >= 0)\n    {\n        prev_in_y = wave_fetch_curr(icoord + ivec3(0, -1, 0));\n    }\n    if ((icoord.z + 1) < wave_res.z)\n    {\n        next_in_z = wave_fetch_curr(icoord + ivec3(0, 0, 1));\n    }\n    if ((icoord.z - 1) >= 0)\n    {\n        prev_in_z = wave_fetch_curr(icoord + ivec3(0, 0, -1));\n    }\n\n    float grad_x = next_in_x - curr - curr + prev_in_x;\n    float grad_y = next_in_y - curr - curr + prev_in_y;\n    float grad_z = next_in_z - curr - curr + prev_in_z;\n\n    float acc = (grad_x + grad_y + grad_z) * wave_speed2 / wave_step2;\n    float vel = (curr - prev) / wave_dt;\n    vel += (acc * wave_dt);\n    vel *= pow(wave_stiffness, -wave_dt);\n\n    prev = curr;\n    curr += (vel * wave_dt);\n\n    float sim_time = wave_dt * float(iter);\n    curr = wave_update_val(icoord, curr, sim_time);\n\n    frag_col = vec4(curr, prev, float(iter + 1), 0.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    frag_col = vec4(iResolution.xy, 1.0, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}