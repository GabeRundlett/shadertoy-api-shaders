{
    "Shader": {
        "info": {
            "date": "1704201346",
            "description": "from   \"Compound of Five Tetrahedra\" by mla. https://shadertoy.com/view/tsXyWs\nkeeping only the edges, + deep simplification\nMouse controls camera",
            "flags": 0,
            "hasliked": 0,
            "id": "lfj3W1",
            "likes": 17,
            "name": "wireframe dodecahedron",
            "published": 3,
            "tags": [
                "wireframe",
                "dodecahedron"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "// Fork of 2020 \"Compound of Five Tetrahedra\" by mla. https://shadertoy.com/view/tsXyWs\n// keeping only the edges, + simplification\n// See also the projective vector variant: https://www.shadertoy.com/view/4cBGDW\n\n#define R      iResolution.xy\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n\nfloat map(vec3 p) { // --- dodecahedron edges  \n   // cascaded folding\n   vec3 C = vec3(-.81,-.47, .36);\n# define F(A) dot(p,A) < 0. ?  p = reflect(p,A) : p // p -= 2.*dot(p,A)*A\n    for (int i; i++ < 5; )   // p = fold(p) \n                             // Face plane normals, dot(A,B) = -cos(PI/P) etc.\n        F( vec3( 1  , 0  , 0  ) ),    // A\n        F( vec3(-.5 , .87, 0  ) ),    // B\n        F( C );                       // C\n      \n    // draw edge        // segment( p, c, reflect(c,C) ) - .03\n    p.z--;   \n    vec3 b = -.72*C;    //  -2.* dot ( C , c ) * C ; c = (0,0,1)\n    return length(p - b * clamp(dot(p, b) *2. , 0., 1.) ) - .03;\n}                                      // / dot(b, b)\n\nvec3 N(vec3 p) {\n    vec3 e = vec3(.001, 0,0);\n    return normalize(\n             vec3(map(p + e.xyy) - map(p - e.xyy),\n                  map(p + e.yxy) - map(p - e.yxy),\n                  map(p + e.yyx) - map(p - e.yyx))\n           );\n}\n\nvec3 T(vec3 p) {\n    vec2 M = iMouse.xy;\n    if (M.x > 0.)\n      M = ( 2.*M/R - 1. ) * 3.14,\n      p.yz *= rot( M.y),  // theta\n      p.zx *= rot(-M.x);  // phi\n\n    p.yz *= rot(iTime/8.);\n    p.zx *= rot(iTime/5.);\n    return p;\n}\n\nvoid mainImage( out vec4 O, vec2 u ) {\n\n  vec3 P = T(vec3(0, 0, 2.5)), n,\n       D = T(normalize(vec3( u - .5*R, -R.y ))),\n       L = T(normalize(vec3(5, 1, 3)));\n\n  float t, h=1., i; // t = march(P, D)\n  for (; i++ < 1e2 && h > .001 ; )\n      t += h = .5*map(P+D*t); // something strange happens without the .5\n\n  O = sqrt( i < 1e2                            // hit\n              ? P += t * D,  n = N(P)\n               ,vec4(.8,.8,.5,0)\n                * ( .2+ .8 * max(0., dot(n, L) ) )            // diffuse\n                +  .3* pow(max(0.,dot(reflect(L,n),D)), 50. ) // specular\n              : .2* vec4( 1. - u.y/R.y )       // background\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}