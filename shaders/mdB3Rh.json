{
    "Shader": {
        "info": {
            "date": "1667208284",
            "description": "Another Alien scene to add to my collection. :)\nYouTube version: https://youtu.be/6ZFq3TlvHBA",
            "flags": 0,
            "hasliked": 0,
            "id": "mdB3Rh",
            "likes": 113,
            "name": "Alien Space Jockey",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "space",
                "fog",
                "halloween",
                "movie",
                "cineshader",
                "navigator"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 7851
        },
        "renderpass": [
            {
                "code": "// 'Space Jockey' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/mdB3Rh (YouTube: https://youtu.be/6ZFq3TlvHBA)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another Alien scene to add to my collection. :)\n// I nearly gave up on this one several times as modelling\n// all the details was a bit daunting, but I'm glad I\n// perservered to the end.\n//\n// Tricks to try to improve performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - Noise functions called once in the lighting code,\n//     and re-used multiple times.\n//   - Bounding shapes are applied to each part of the scene\n//     so the SDF calculations can return early if the ray\n//     position is deemed too far away to warrant calculating\n//     the fine details.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SKY_RGB\tvec3(.5, .6, .65)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat t;\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Two n31 results from two scales.\nvec2 n331(vec3 p) {\n\tconst vec2 s = vec2(20, 38);\n\tvec2 ns;\n\tfor (int i = I0; i < 2; i++)\n\t\tns[i] = n31(p * s[i]);\n\n\treturn ns;\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 ax(vec3 p) { return vec3(abs(p.x) - .18, p.yz); }\n\nfloat opRep(float p, float c) {\n\tfloat c2 = c * .5;\n\treturn mod(p + c2, c) - c2;\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.x, p.y) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nvec3 bend(vec3 p, float k) {\n\tfloat c = cos(k * p.x);\n\tfloat s = sin(k * p.x);\n\tp.xy *= mat2(c, s, -s, c);\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, -h, 0.);\n\treturn length(p) - r;\n}\n\nfloat capTor(vec3 p, vec2 sc, float r) {\n\tp.x = abs(p.x);\n\treturn sqrt(dot(p, p) + r * r - 2. * r * (sc.y * p.x > sc.x * p.y ? dot(p.xy, sc) : length(p.xy)));\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.yz) - t.x, p.x);\n\treturn length(q) - t.y;\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, -1, 0) - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat walls(vec3 p) {\n\tp.y -= 6.;\n\n\t// Walls.\n\tfloat d = 10.75 - length(p.yz);\n\n\t// Ray too far away - Bail early.\n\tif (d > 5.) return d;\n\n\t// Wobbles.\n\tfloat ox = p.x;\n\tp.x = opRep(p.x - 5., 6.);\n\tfloat a = atan(p.y, p.z);\n\td -= .01 * sin(a * 172.);\n\td -= .1 * cos(p.x * p.x * .7);\n\n\t// Main pipes.\n\tp.x = abs(p.x) - .7;\n\tfloat f = S(.5, 1., sin(a * 250.));\n\tf = tor(p, vec2(10, f * -.03 + .5));\n\n\t// Side pipe.\n\tp.x -= .5;\n\tf = min(f, tor(p, vec2(9.7, .15)));\n\n\t// Ball bones.\n\tp.zy = opModPolar(p.zy, 30., 0.);\n\tp.z -= 10.8;\n\tp.y = abs(p.y) - .5;\n\tp = bend(p, .11 * p.x * sin(12. * (a + floor(ox / 2.))));\n\tp.x -= 1.4;\n\treturn smin(min(d, smin(length(p) - .25, cap(p, 1.5, .2), .1)), f, 1.);\n}\n\nfloat dais(vec3 p) {\n\tfloat a = atan(p.z, p.x);\n\tfloat l = length(p.xz);\n\n\t// Inner column.\n\tvec2 q = vec2(l, p.y);\n\tfloat d = box2(q, vec2(1.2 - abs(sin(a * 20.)) * .02, .8));\n\n\t// Ray too far away - Bail early.\n\tif (d > 4.) return d;\n\n\t// Middle ring.\n\tfloat l40 = abs(sin(l * 40.));\n\td = min(d, box2(q - vec2(2.8, -.2), vec2(.16, .7 + l40 * .01)));\n\n\t// Radial pipes.\n\tvec3 v = p;\n\tv.xz = opModPolar(p.xz, 8., .2);\n\td = smin(d, length(v.yz - vec2(.5, 0)) - .15 - l40 * .01, .1);\n\n\t// Radial struts.\n\tv.xz = opModPolar(p.xz, 32., 0.);\n\tv.z = abs(v.z) - .05;\n\td = min(d, box2(v.yz - vec2(.2, 0), vec2(.2, 0)));\n\n\t// Clip content to dais radius.\n\td = max(d, l - 4.12);\n\n\t// Geared outer ring.\n\td = min(d, box2(q - vec2(4, -.1), vec2(.28 - S01(sin(a * 130.)) * .03, .7 + l40 * .02 * step(l, 4.16))));\n\n\t// Round edges off.\n\treturn d - .03;\n}\n\nfloat chair(vec3 p) {\n\tp.y--;\n\tvec3 op = p;\n\n\t// Mounting struts.\n\tfloat d = cyl(ax(p) - vec3(0, 0, .1), vec2(1, S01(.5 - p.y) * .2 + .06));\n\td += .005 * S(0., .03, abs(abs(p.y - .3) - .3));\n\td = smin(d, p.y - .7, -.05);\n\n\t// Ray too far away - Bail early.\n\tif (d > 3.) return d;\n\n\t// Primary base exhaust.\n\tp.x = abs(p.x);\n\tp.y += .3 * S(.8, 1.6, p.x) * sin(p.x * 1.9);\n\tfloat f = cyl(p - vec3(.8, .12, .7), vec2(.2, 1));\n\tf = abs(f) - .005;\n\tf += .05 * S(.04, -.16, abs(p.y - .2));\n\tfloat q = length(p - vec3(1.8, .3, .85));\n\tf = smin(f, .2 - q, -.1);\n\tf += .01 * S(0., .03, abs(q - .35));\n\n\t// Seconardy pipe.\n\tq = S(.2, .9, -op.x);\n\tf = smin(f, cap(p - vec3(.7, .4 - q * .25, .6), .8, .15), .1 * q);\n\td = min(d, f);\n\n\t// Central tube.\n\tf = cyl(op - vec3(.7, .3, 0), vec2(.3, 1.2)) - .1;\n\n\t// Toral pipe.\n\tf = max(f, .44 - length(op.xy - vec2(1.55, 1)));\n\tp = op.zyx - vec3(0, .25, .94);\n\tf = min(f, max(tor(p, vec2(.83, .08 - .005 * abs(sin(atan(p.y, p.z) * 40.)))), -p.z));\n\n\t// Organic scope mount.\n\tp = bend(op, -.08 * p.y);\n\tf = smin(f, box(p - vec3(.75, 1.45, 0), vec3(.2 - p.y * .1, 1, .1)) - .15 - abs(sin(p.y * 10.) * .01), .12);\n\td = min(d, f);\n\n\t// Chair back.\n\tp = op;\n\tp.y -= 1.74;\n\tp.xy *= mat2(-.80114, .59847, -.59847, -.80114);\n\tfloat a = atan(p.x, p.y);\n\tfloat l = length(p);\n\tf = sat(sin(a * 1e2) - .6);\n\tf *= S(1.6, 1.1, l);\n\tconst vec2 v = vec2(.64422, .76484);\n\td = min(d, capTor(p, v, 1.56) - .5 - .02 * S(.7, .75, a) - .02 * f);\n\tf = length(p.xy - vec2(1.35, 0));\n\td = smin(d, 1. - f, -.04);\n\tf *= S(.99, .95, f) * .4;\n\tf *= S(.25, .1, abs(p.x - 1.15));\n\td -= .05 * (S(.2, .1, p.z) + sin(p.x * 50.) * f);\n\n\t// Chair side pipe.\n\tf = sin(a * 50.);\n\td = min(d, capTor(p - vec3(0, 0, .5), v, 1.56) - .05 - .01 * f * f);\n\td = min(d, capTor(p - vec3(0, 0, .5), v, 1.5) - .02);\n\n\t// Torso.\n\tp.xy *= mat2(.98007, .19867, -.19867, .98007);\n\tf *= S(0., .15, p.z);\n\td = min(d, capTor(p, v, 1.25) - .36 - f * .015);\n\n\t// Shoulders.\n\tp -= vec3(.74, .9, .28);\n\td = min(d, length(p) - .16);\n\n\t// Arms.\n\tp.z -= .075;\n\tp.xy *= rot(mix(.06, -.24, S(.15, -.6, op.x)));\n\tf = .086 - f * f * .002 * S(.3, .5, -op.x);\n\tf += .03 * S(.35, .05, abs(p.x + .3));\n\tf = cap(p, 1.4, f);\n\ta = atan(p.y, p.z);\n\tf += .01 * sin(a * 6.5) * S(1.3, 0., abs(p.x));\n\tf += .007 * sin(a * 9.) * S(.035, .3, op.x);\n\td = min(d, f);\n\n\t// Head.\n\tp = op;\n\tp -= vec3(-1, 1.5, 0);\n\tf = mix(box(p, vec3(.25, .28, .26)), length(p) - .23, .9);\n\tp.xy = op.xy * mat2(.07074, -.99749, .99749, .07074);\n\treturn smin(d, max(smin(f, capTor(p + vec3(1, 1.46, 0), v, 1.) - .04, .16), .05 - length(p.xz - vec2(-1.6, .15))), .3 * S(-1.5, -1., p.x)) - .02;\n}\n\nfloat mount(vec3 p, float x, float a) {\n\tp.xy *= rot(-.15 - a);\n\tp = p.zyx * vec3(-1, 1, 1);\n\tfloat d = cap(p, .3, .1);\n\tp.x += .3;\n\tp = p.yxz;\n\tp.xy *= rot(a);\n\tvec3 v = vec3(p.y + .176, opRep(p.x, .08), p.z - .11);\n\tfloat q = 1.1 + x;\n\td = smin(d, cap(p, q, .1), .04);\n\tp.x += q;\n\tp = p.zyx;\n\tp.xz *= mat2(.87758, .47943, -.47943, .87758);\n\td = smin(d, cap(p, .3, .1), .04);\n\tp.x += .3;\n\tp.xz *= mat2(.5403, -.84147, .84147, .5403);\n\td = smin(d, cap(p, .1, .1), .04);\n\td = smin(d, -p.y - .09, -.003);\n\n\t// Square cut-outs.\n\treturn max(d, -box(v, vec3(.1, .02, .1)));\n}\n\nfloat mounts(vec3 p) {\n\tfloat d = mount(p - vec3(.9, 2.95, 0), .2, .05);\n\n\t// Ray too far away - Bail early.\n\tif (d > 3.) return d;\n\treturn min(min(d, mount(p - vec3(1.2, 3.1, 0), .3, .1)), mount(p - vec3(1.5, 3.2, 0), -.2, .2));\n}\n\nfloat scope(vec3 p) {\n\tp.y -= 2.9;\n\tp.xy *= mat2(-.89676, -.44252, .44252, -.89676);\n\tvec3 op = p;\n\n\t// Barrel.\n\tfloat a = atan(p.y, p.z);\n\tfloat f = .005 * sat(-sin(a * 24. + 3.141));\n\tf = max(f, .04 * S(.2, 0., p.x + 2.9 - p.y * .4));\n\tp.y += .8 * S01(p.y + .3) * S(1., 0., p.x + 3.8);\n\tfloat d = cap(p, 3.2, .4 + f);\n\n\t// Ray too far away - Bail early.\n\tif (d > 1.) return d;\n\n\t// Side pipes.\n\tp.y = abs(p.y);\n\tp.zy = opModPolar(p.zy, 9., 0.);\n\tp -= vec3(-.4, 0, .35);\n\td = min(d, cap(p, 2.6, .07 + abs(sin(p.x * 90.)) * .004));\n\n\t// End Bulge.\n\tp = op.zyx;\n\td = smin(d, cyl(p + vec3(0, .2, 0), vec2(.4, .4 - abs(p.y) * .6)), .3);\n\n\t// Viewscreen.\n\tp.yz += vec2(.1, -1.23);\n\treturn min(d, smin(cyl(p, vec2(.8, .2)), -cyl(p - vec3(0, 0, 1.12), vec2(1.8, 1)), -.14));\n}\n\nfloat map(vec3 p) {\n\tfloat d = walls(p);\n\tp.y += 2.8;\n\td = min(d, dais(p));\n\tp.xz *= mat2(.76484, -.64422, .64422, .76484);\n\tp.z = abs(p.z);\n\treturn min(min(min(d, chair(p)), scope(p)), mounts(p));\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .05;\n\tfloat mxt = length(p - vec3(-20, 3, 3));\n\tfor (float i = Z0; i < 30.; i++) {\n\t\td = map(t * ld + p);\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.03, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 2);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = map(h[i] * n + p);\n\n\treturn sat(min2(ao / h));\n}\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld) { return S01(map(1. * ld + p)); }\n\nfloat fog(vec3 p) {\n\tfloat d = abs(p.x);\n\td += 20. * S(-1.3, -4., p.y) * (.7 + .3 * n21(p.xz * 2.));\n\treturn exp(d * d * -2e-4);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n\tvec2 ns = n331(p); // Cache noise.\n\tvec3 ld = normalize(vec3(-20, 3, 3) - p),\n\t     c = vec3(.5, .8, 1);\n\tc *= .3 - sum2(ns) * .06;\n\tc += sss(p, ld) * .1;\n\tfloat y = S(1.8, 0., length(p));\n\ty *= S(0., -.2, p.y + p.x + .7);\n\tc *= 1. + vec3(21, 19, 13) * (dot(ns, ns) * .6 + .4) * y;\n\n\t// Adjust specular power and brightness.\n\ty = sat(y * 6.);\n\tfloat sh1 = mix(2e2, 10., y);\n\tfloat sh2 = mix(5., .3, y);\n\tsh2 *= .8 * ns.x * ns.y + .2;\n\tvec3 l = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl.yz *= .1 + .9 * ao(p, n); // Ambient occlusion.\n\tl *= vec3(.05 + .95 * S(3., -10., p.x), .05, .02); // Light contributions (key, reverse, sky).\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), sh1) * sh2; // Specular (Blinn-Phong)\n\tl.x *= .05 + .95 * shadow(p, ld, n); // Shadow.\n\treturn mix((sum2(l.xy) * vec3(.6, .51, .42) + l.z * SKY_RGB) * c, SKY_RGB, S(.6, 1., 1. + dot(rd, n)) * .02);\n}\n\nfloat addFade(float a) { return min(1., abs(t - a)); }\n\nvec3 scene(vec3 p, vec3 rd) {\n\t// March the scene.\n\tfloat i, h,\n\t      d = 1.;\n\tfor (i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\t\tif (abs(h) < 2e-4 * d || d > 40.) break;\n\t\td += h;\n\t\tp += h * rd;\n\t}\n\n\tvec3 col = mix(SKY_RGB, lights(p, rd, N(p, d)), fog(p));\n\n\t// Gamma.\n\treturn pow(max(vec3(0), col), vec3(.4545));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 30.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 ro = mix(vec3(-1, -1, -7), vec3(-1.1, -1.8, -3), S(0., 15., t));\n\tfloat f = S(15., 30., t);\n\tif (f > 0.) ro = vec3(1. - f * 4., cos(f * 6.283) + .5, -3);\n\tvec3 col = scene(ro, rayDir(ro, uv));\n\n\t// Blue tint.\n\tcol = pow(col * 1.2, vec3(1.2, 1.1, 1));\n\n\t// Vignette.\n\tcol *= 1. - .3 * dot(uv, uv);\n\n\t// Grain.\n\tcol += (h21(fc) - .5) / 20.;\n\tfragColor = vec4(col * addFade(0.) * addFade(15.), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}