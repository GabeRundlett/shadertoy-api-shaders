{
    "Shader": {
        "info": {
            "date": "1653797056",
            "description": "A method of azimuthal orthomorphic projection.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdccRX",
            "likes": 6,
            "name": "The Panorama Projection(stars)",
            "published": 3,
            "tags": [
                "texture",
                "sphere",
                "star",
                "projection",
                "stars",
                "ball",
                "orb",
                "photo",
                "image",
                "panorama",
                "bent",
                "move",
                "picture",
                "globe",
                "azimuthal",
                "method",
                "methods",
                "orthomorphic"
            ],
            "usePreview": 0,
            "username": "blackholes",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "// View settings\n\n    float CAMERA_HEIGHT = 400000000000.0; // meters\n    float sightdistance = 0.03;//meters\n\nconst int INTEGRATION_STEPS = 0;\n\n// Constants\n\nconst float PI = 3.141592653589793;\nconst float time_speed=3000.0;\n// in seconds\nconst float INF = 1e10;//1.0 / 0.0;\nconst float rotation_of_earth=86164.09;\nconst float revolution_of_earth=31558152.96;\nfloat time(){return time_speed*iTime/rotation_of_earth-0.015;}\nfloat day_time(){return time()-time_speed*iTime/revolution_of_earth;}\nfloat brightness(){return 1.0+9.5*(1.0-smoothstep(-1.0/18.0,0.0,day_time()-floor(day_time()))+smoothstep(0.5,0.5+1.0/18.0,day_time()-floor(day_time()))-smoothstep(1.0-1.0/18.0,1.0,day_time()-floor(day_time())));}\nconst float beta =PI/2.0;\nconst vec2 EMPTY_INTERVAL = vec2(INF, -INF); // interval [a,b] represented as vec2(a, b)\n\nconst float EARTH_RADIUS = 6372000.0; // meters\nconst float ATMOSPHERE_HEIGHT = 100000.0; // meters\n vec3 camera_position(){return vec3(0.0, 0.0, EARTH_RADIUS + CAMERA_HEIGHT);}\nconst vec3 SUN_EMISSION = vec3(1.0);\nconst vec3 SUN_COLOR = vec3(1,1.06,1.034);\nconst vec3 EARTH_COLOR = vec3(0.10,0.19,0.29);\n\n// Scattering & absorption settings (try to set some to zero to see how important each of them is)\n\nconst vec3 RAYLEIGH_SCATTERING = vec3(5.802, 13.558, 33.1) * 6.8e-7;\nconst vec3 RAYLEIGH_EXTINSION = RAYLEIGH_SCATTERING;\n\nconst vec3 MIE_ABSOPTION = vec3(4.4) * 9.5e-6;\nconst vec3 MIE_SCATTERING = vec3(2.1) * 1e-5/1.5;\nconst vec3 MIE_EXTINSION = MIE_ABSOPTION + MIE_SCATTERING;\n\nconst vec3 OZONE_ABSORPTION = vec3(0.650, 1.881, 0.085) * 0.405e-6;\nconst vec3 OZONE_EXTINSION = OZONE_ABSORPTION;\n\nfloat rayleigh_density(float height)\n{\n    return exp(- height / 7994.0);\n}\n\nfloat mie_density(float height)\n{\n    return exp(- height / 1200.0);\n}\n\nfloat ozone_density(float height)\n{\n    return max(0.0, 1.0 - abs(height - 25000.0) / 15000.0);\n}\n\nfloat rayleigh_phase(float c)\n{\n    return (1.0 + c * c) * (3.0 / 16.0 / PI);\n}\n\nfloat mie_phase(float c)\n{\n    float g = 0.76;\n    return (3.0 / 8.0 / PI) * (1.0 - g * g) * (1.0 + c * c) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * c, 1.5);\n}\n\n// Math helpers\n\nvec2 interval_intersection(vec2 i1, vec2 i2)\n{\n    return vec2(max(i1.x, i2.x), min(i1.y, i2.y));\n}\n\nbool empty(vec2 i)\n{\n    return i.x > i.y;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    float D = b * b - 4.0 * a * c;\n    if (D < 0.0)\n        return vec2(INF, INF);\n    D = sqrt(D);\n        \n    float x1, x2;\n    if (b >= 0.0)\n    {\n        x1 = (- b - D) / 2.0 / a;\n        x2 = 2.0 * c / (- b - D);\n    }\n    else\n    {\n        x1 = 2.0 * c / (- b + D);\n        x2 = (- b + D) / 2.0 / a;\n    }\n    \n    if (x1 < x2)\n        return vec2(x1, x2);\n    return vec2(x2, x1);\n}\n\n// Raycast\nmat3 spinxyz(int axis,float angle,mat3 XYZ)\n{\n    vec3 X,Y,Z;\n\n\tif(axis==1)\n\t{\n\t   X = XYZ[0];\n       Y = XYZ[1];\n       Z = XYZ[2];\n\t}\n\tif(axis==2)\n\t{\n\t   X = XYZ[1];\n       Y = XYZ[2];\n       Z = XYZ[0];\n\t}\t\n    if(axis==3)\n\t{\n       X = XYZ[2];\n       Y = XYZ[0];\n       Z = XYZ[1];\n\t}\n\tZ = Z * cos(angle) + Y * sin(angle);\n    Y = cross(Z, X);\n\tif(axis==1)\n\treturn mat3(X,Y,Z);\n\tif(axis==2)\n\treturn mat3(Z,X,Y);\n\tif(axis==3)\n\treturn mat3(Y,Z,X);\n}\nvec3 transformxyz(vec3 xyz,mat3 XYZ)\n{\n    float nx=XYZ[0].x*xyz.x+XYZ[0].y*xyz.y+XYZ[0].z*xyz.z;\n\tfloat ny=XYZ[1].x*xyz.x+XYZ[1].y*xyz.y+XYZ[1].z*xyz.z;\n\tfloat nz=XYZ[2].x*xyz.x+XYZ[2].y*xyz.y+XYZ[2].z*xyz.z;\n\treturn vec3(nx,ny,nz);\n}\nvec2 sphere_raycast(vec3 ray_origin, vec3 ray_direction, float radius)\n{\n//    |o + td| = r\n//    o^2 + 2t do + t^2 d^2 = r^2\n    float a = 1.0;\n    float b = dot(ray_direction, ray_origin) * 2.0;\n    float c = dot(ray_origin, ray_origin) - radius * radius;\n        \n    vec2 t = solve_quadratic(a, b, c);        \n    if (t == vec2(INF, INF))\n        return EMPTY_INTERVAL;\n    return interval_intersection(t, vec2(0.0, INF));\n}\n\nvec2 atmosphere_raycast(vec3 ray_origin, vec3 ray_direction)\n{\n    vec2 i = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 ip = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    if (!empty(ip))\n        i = interval_intersection(i, vec2(-INF, ip.x));\n    return i;\n}\n\n// Main raymarching\n\nvec3 transmittance(vec3 origin, vec3 direction, float tmax, int steps)\n{\n    vec3 log_result = vec3(0.0);\n    float dt = tmax / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt;\n        vec3 p = origin + t * direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        log_result += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        log_result += MIE_EXTINSION * mie_density(h) * dt;\n        log_result += OZONE_EXTINSION * ozone_density(h) * dt;\n    }\n    return exp(- log_result);\n}\n\nvec3 sky_color(vec3 ray_origin, vec3 ray_direction, vec3 sun_direction, int steps)\n{\n    vec3 background = vec3(0.0);\n    vec3 stars= vec3(0);\n\tvec3 sun = vec3(0);\n    vec2 interval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 uv;\n    vec2 pinterval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n\tmat3 n0=spinxyz(1,PI/2.0-beta,mat3(1,0,0,0,1,0,0,0,1));\n\tmat3 n=spinxyz(3,2.0*PI*time(),n0);\n\tmat3 n1=spinxyz(3,2.0*PI*day_time(),n0);\n\tvec3 skyn=transformxyz(ray_direction,n);\n\tvec3 sunn=transformxyz(ray_direction,n1);\n    \t\t\t\t float ay2 = asin(skyn.z);\n     float ax2=asin(skyn.x / cos(asin(skyn.z)));\n\t\t\t if (skyn.y < 0.0) ax2 = 3.0 * PI / 2.0 + ax2;\n\t\t\t else ax2 = PI / 2.0 - ax2;\n\t\t\t uv.x=1.0-ax2/PI/2.0;\n\t\t\t uv.y=1.0-(ay2+PI/2.0)/PI;\n stars = texture( iChannel0, uv ).xyz;\n if(stars.b>0.8)stars=exp(2.15*(stars.r+stars.g+stars.b))*stars/2.8;\n if(sunn.x>0.9999891)sun = vec3(1);\n else sun=sun;\n    if (!empty(pinterval))\n    {\n        vec3 n = normalize(ray_origin + ray_direction * pinterval.x);\n\t\t\t\tvec3 earthcolor=transformxyz(n,n0);\n    float ay = asin(earthcolor.z);\n     float ax=asin(earthcolor.x / cos(asin(earthcolor.z)));\n\t\t\t if (earthcolor.y < 0.0) ax = 3.0 * PI / 2.0 + ax;\n\t\t\t else ax = PI / 2.0 - ax;\n\t\t\t uv.x=ax/PI/2.0;\n\t\t\t uv.y=0.5-ay/PI;\n\tvec3 col4 = texture( iChannel1, uv ).xyz;\n        background = 0.017* max(0.0, dot(n, sun_direction))*col4;\n\t\tstars=sun=vec3(0);\n        interval = interval_intersection(interval, vec2(-INF, pinterval.x));\n    }\n    \n    \n    vec3 result = vec3(0.0);\n\n    vec3 tcoeff = vec3(0.0);\n    \n    float dt = (interval.y - interval.x) / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt + interval.x;\n        vec3 p = ray_origin + t * ray_direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        // Instead of calling transmittance(p, -ray_direction, t, steps) to\n        // compute how much scattered light actually reachs the camera (as opposed\n        // to being absorbed or scattered again), we make use of the raymarching\n        // and compute transmittance on the go. The actuall transmittance factor\n        // is exp(-tcoeff) * dt\n        \n        tcoeff += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        tcoeff += MIE_EXTINSION * mie_density(h) * dt;\n        tcoeff += OZONE_EXTINSION * ozone_density(h) * dt;\n        \n        vec2 it = sphere_raycast(p, sun_direction, EARTH_RADIUS);\n        \n        vec3 emitter = vec3(0.0);\n        if (!empty(it))\n            emitter = EARTH_COLOR;\n        else\n        {\n            it = sphere_raycast(p, sun_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n        \n            if (!empty(it))\n                emitter = SUN_EMISSION* rayleigh_density(h);\n        }\n            \n        vec3 incoming = transmittance(p + it.x * sun_direction, sun_direction, it.y - it.x, steps) * SUN_EMISSION;\n        \n        float c = dot(-sun_direction, -ray_direction);\n        \n        vec3 scatter = vec3(0.0);\n        scatter += RAYLEIGH_SCATTERING * rayleigh_phase(c)*rayleigh_density(h)*1.0;\n        scatter += MIE_SCATTERING * mie_phase(c)*mie_density(h)*0.25;\n        \n        result += incoming * scatter * exp(-tcoeff) * dt;\n    }\n\n    result += (background+0.00002*stars+sun) * exp(-tcoeff);\n\n    return result;\n}\n\nvec3 tone_map(vec3 color)\n{\n    return pow(color / (vec3(1.0) + color), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec3 sun_direction = vec3(sin(2.0*PI*day_time()+PI/2.0), cos(2.0*PI*day_time()+PI/2.0)*cos(PI/2.0-beta), -cos(2.0*PI*day_time()+PI/2.0)*sin(PI/2.0-beta));\n   vec2 uv = fragCoord/iResolution.y;\n    float x1 =uv.x-0.5*iResolution.x/iResolution.y;\n    float y1 =0.5-uv.y;\n    float screenR = sqrt(x1 * x1 + y1 * y1);\n    float eyeay = PI / 2.0 - screenR*0.15/ sightdistance;\n    float eyeax=asin(y1 / screenR);\n     if (x1 > 0.0) eyeax = PI/2.0+eyeax;\n\t\t\t else eyeax = 3.0*PI/2.0- eyeax;       \n    vec2 m = vec2(2.0*iMouse.x / iResolution.y,-2.0*iMouse.y / iResolution.y)+vec2(0,0.5);    \n    m *= PI;   \n\t\n    vec3 view_direction;\n    //Rotation of spatial cartesian coordinates\n\t\tmat3 n=spinxyz(2,-m.y,spinxyz(3,-m.x,mat3(1.0, 0.0, 0.0,0.0, 1.0, 0.0,0.0, 0.0, 1.0)));\n    //Space cartesian coordinates to spherical coordinates\n    view_direction =\n        n[0] * cos(eyeax) * cos(eyeay) +\n        n[1] * sin(eyeax) * cos(eyeay) +\n        n[2] * sin(eyeay);\n    vec3 color = sky_color(camera_position(), view_direction, sun_direction, INTEGRATION_STEPS);       \n    fragColor = vec4(5.0*tone_map(color)*24.0, 1.0);\n\tif(eyeay>PI / 2.0||eyeay<-PI / 2.0)fragColor = vec4(0,0,0,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}