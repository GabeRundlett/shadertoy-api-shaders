{
    "Shader": {
        "info": {
            "date": "1713779797",
            "description": "Two ways how to fold 2D coordinates into hexagonal cells.\nBoth are commonly used of course, but I had fun working them out. ;)",
            "flags": 0,
            "hasliked": 0,
            "id": "DldXzr",
            "likes": 3,
            "name": "Hexagon fold",
            "published": 3,
            "tags": [
                "folding"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "// Two ways how to fold 2D coordinates into hexagonal cells.\n// Both are commonly used of course, but I had fun working them out. ;)\n\n// The folded coordinates have [0, 0] in the center of the cell.\n// You also get the 2D integer cell index.\n\n// To change the cell size: p_folded = hexfold(p / size, cell_index) * size\n\n\n// Method 1: cluster of six triangles.\nvec2 hexfold(vec2 p, out vec2 cell_index) {\n    // Convert to triangular coordinates: → x [2, 0], ↖ y [-1, √3].\n    // The cell index will be in the dual basis: ↗ x* [0.5, 0.5/√3], ↑ y* [0, 1/√3].\n    // (The dual basis has dot(x*,x) = dot(y*,y) = 1, dot(x*,y) = dot(y*,x) = 0.)\n    vec4 M = vec4(2,-1, 0,sqrt(3.));\n    vec2 s = mat2(M) * p;\n\n    // Take six triangles and combine them into a hexagon.\n    // Division by 3 is not exact, so we need to avoid edge cases when rounding.\n    // These are all OK:\n    //cell_index = round((floor(s) + ceil(s.x+s.y)) / 3.);  // 0 0.33 | 0.66\n    //cell_index = round((ceil(s) + floor(s.x+s.y)) / 3.);\n    //cell_index = round((floor(s) + floor(s.x+s.y) + 1.) / 3.);\n    //cell_index = floor((ceil(s) + ceil(s.x+s.y) + .5) / 3.);  // | 0.16 0.5 0.83 |\n    cell_index = floor((floor(s) + floor(s.x+s.y) + 2.5) / 3.);\n\n    // Transform the cell indices back and fold the coordinates.\n    return p - .5*mat2(M.xzyw) * cell_index;  // transpose(M) manually for WebGL 1\n}\n\n// Method 2: two stretched rectangular grids.\nvec2 hexfold2(vec2 p, out vec2 cell_index) {\n    // Convert to stretched rectangular coordinates.\n    vec2 s = vec2(1, sqrt(3.));\n\n    // Duplicate the grid with a [0.5, 0.5] offset.\n    vec2 i = round(p/s), j = round(p/s + .5) - .5;\n    vec2 q = p - i*s, r = p - j*s;\n\n    // Find the closest cell center.\n    cell_index = round(dot(q,q)<dot(r,r) ? i+i : j+j);  // integer\n    return dot(q,q)<dot(r,r) ? q : r;\n}\n\n// Golfed versions of the above.\n// These return the folded coordinates in .xy and the cell index in .zw.\nvec4 hexfold_vec4(vec2 p) {\n    vec4 M = vec4(2,-1, 0,sqrt(3.));\n    vec2 s = mat2(M) * p,\n         i = round(floor(s + ceil(s.x+s.y)) / 3.);\n    return vec4(p - .5*mat2(M.xzyw) * i, i);\n}\n\nvec4 hexfold2_vec4(vec2 p) {\n    vec2 s = vec2(1,sqrt(3.)),\n         i = round(p/s), j = round(p/s + .5) - .5,\n         q = p-i*s, r = p-j*s;\n    return dot(q,q)<dot(r,r) ? vec4(q,round(i+i)) : vec4(r,round(j+j));\n}\n\n// If you want just the cell index of method 1, you don't need the matrix.\n// Method 2 works with distances, so it can't be much shorter.\nvec2 hexindex(vec2 r) {\n    vec2 s = vec2(2.*r.x, sqrt(3.)*r.y-r.x);\n    return round(floor(s + ceil(s.x+s.y)) / 3.);\n}\n\n// Square fold for comparison.\n// It also has 0 in the center of the cell.\nvec2 squarefold(vec2 p, out vec2 cell_index) {\n    cell_index = round(p);\n    return p - cell_index;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 4. * (2.*fragCoord - iResolution.xy) / iResolution.y;  // y: -4 .. 4\n    vec2 p_folded, cell_index;\n\n    float t = mod(iTime/2., 6.);\n\n    // 0..3: Show the full versions to compare with the square fold.\n    if      (t < 1.) p_folded = hexfold(p, cell_index);\n    else if (t < 2.) p_folded = hexfold2(p, cell_index);\n    else if (t < 3.) p_folded = squarefold(p, cell_index);\n    \n    // 4..5: Show the golfed versions.\n    else if (t < 4.) { vec4 v = hexfold_vec4(p); p_folded = v.xy; cell_index = v.zw; }\n    else if (t < 5.) { vec4 v = hexfold2_vec4(p); p_folded = v.xy; cell_index = v.zw; }\n    \n    // 6..7: Show how the cell indices are oriented.\n    else {\n        if (fract(t) < .5) {\n            vec2 h = hexindex(p);\n            // Method 1 gives you cell indices with Y vertical and X 60° clockwise from it.\n            // Even directions on the clock: 12 y, 2 x, 4 x-y, 6 -y, 8 -x, 10 y-x.\n            // Add neighbors to get odd directions: 3 x+x-y.\n            fragColor = .5 + .07 * vec4(.4*(h.y-h.x - h.x), h.y, .4*(h.x + h.x-h.y),0); }  // 9, 12, 3\n        else {\n            // Method 2 has Y vertical and X is 90° clockwise: 12 y, 3 x, 6 -y, 9 -x.\n            vec2 h = hexfold2_vec4(p).zw;\n            fragColor = .5 + .07 * vec4(.4*-h.x, h.y, .4*h.x,0); }  // 9, 12, 3\n    }\n    \n    if (t < 5.) {\n        // Show cell indices mod 4 (red+green) and local coordinates (blue).\n        vec2  index = mod(cell_index, 4.);\n        float angle = fract(atan(p_folded.x, p_folded.y) / 6.283 - t);\n        fragColor = pow(vec4(index*.3, angle*.6, 1), vec4(1./2.2));\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}