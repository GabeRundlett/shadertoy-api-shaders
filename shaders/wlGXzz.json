{
    "Shader": {
        "info": {
            "date": "1582059223",
            "description": "nvidia",
            "flags": 0,
            "hasliked": 0,
            "id": "wlGXzz",
            "likes": 8,
            "name": "大龙猫 - Nvidia",
            "published": 3,
            "tags": [
                "nvidia"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "\n#define ITER 92.\n#define dtime pow(fract(iTime*.25),.5)+floor(iTime*.25)\n#define ttime sin(iTime) *pow(cos(pow(iTime,.125)),2)\nmat2 r(float a){return mat2(cos(a),sin(a),\n                           -sin(a),cos(a));}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat sdBox (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n\n// SDF Sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// Global SDF\n// This represent our \"scene\" with the objects\n\n\nfloat fig(vec3 pos, float x,float b) {\n pos.y-=0.4;\n      pos.y +=cos(abs(pos.x))*.5*(b);\n      float sideBox =sdBox(pos,vec3(1.9*x,0.1-cos(abs(pos.x))*.05,0.4));\n      return sideBox;\n}\nvec2 SDF(vec3 pos) {\n   pos.y+=.5;\n   float c = 15.;\n      vec3 ppos = pos;\n      \n     vec3 id = floor(pos);\n      ppos.xy *=r(ppos.z*.006*sin(dtime));\n     pos = mod(ppos+0.5*c,c)-0.5*c;\n  \n   \n     pos.x*=1.4; \n     pos.yz  *=r(sin(iTime+pos.x*.5)*.4);\n     pos.xz  *=r(cos(iTime+pos.x*.5)*.4);\n \n\n   float dist = min(fig(pos+vec3(-.2,-0.4,.0),0.7,1.5),\n                min(fig(pos,1.,1.2),\n                    fig((-pos)+vec3(-.2,+1.1,.0),1./1.1,1.21))\n   \n   );\n   dist = min(dist,fig((-pos)+vec3(-.17,+.69,.0),0.5,1.21));\n\n   float labox = sdBox(pos-vec3(0.,.5,.0),vec3(2.3,.99,.29));\n  \n   \n   //dist = max(labox , -dist*cos(pos.x+dtime) );\n   dist = max(labox , -dist*sin(pos.x));\n      \n   return vec2(dist,0.0);\n  \n  }\n\n// Compute a normal from a vec3.\nvec3 get_normal(vec3 p) \n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(\n             vec3(\n                  SDF(p+eps.xyy).x - SDF(p-eps.xyy).x, // Diff in X\n                  SDF(p+eps.yxy).x - SDF(p-eps.yxy).x, // Diff in Y\n                  SDF(p+eps.yyx).x - SDF(p-eps.yyx).x  // Diff in Z\n             )\n            );  // Math Vector\n  }\n  \n// Lighting, here my limit of the knowledge\nfloat diffuse_directional(vec3 n,vec3 l){\n        \n    float a =  max(0.,dot(n,normalize(l))); // realistic lighting\n    float b =  dot(n,normalize(l))*.5+.5;   // less realistic lighting\n    return (b+a)/2. ; \n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n  \n  // Initialization of the Ray Marching algorithm\n  vec3 ray_origin = vec3(.01,.01,-8); // Were we start \n \n  vec3 ray_direction = normalize(vec3(uv,1.)); // going forward\n  \n  ray_direction.xz *=r(cos(iTime*.5)*.1);\n  vec3 position = ray_origin ; \n  \n  vec3 color = vec3(.0,.0,.0); // By default, everything will be black\n  \n  bool hit = false; \n  \n  float shad = 0.;\n  float part = 0.;\n  \n  \n  for(float i=0.; i<ITER; ++i) { // We iterate the ray\n \n    vec2 _distance = SDF(position); // Find the closest distance from the current position\n    if(_distance.x <0.0001) { // If we are close enough, it's a hit, we put the shad and break the loop\n        shad = i / ITER;\n        hit = true;\n        break;\n     }\n     part = _distance.y;\n     position += _distance.x * ray_direction; // Otherwise we conditnue the marching, updating the ray position\n   \n  }\n  \n  if(hit) { // If there is a hit we want to perfom some coloring\n  \n    // I don't really understand here, just some lighting effect to get a good rendering\n    vec3 n = get_normal(position);  \n    vec3 l = vec3(0.01+sin(iTime)*10.,-1.5+cos(iTime)*10.,-5.);\n    \n     color =  vec3(diffuse_directional(n,l)); // light diffuse\n   \n    \n      // Using the mix method toget some color\n      if(part == 0.){\n            vec3 color1 = mix(vec3(.1,0.1,0.1), vec3(0.0,0.9,0.2), color)*(1.-shad); \n             vec3 color2 = mix(vec3(.7,0.7,0.), vec3(0.0,0.5,0.6), color)*(1.6-shad); \n             color = mix(color1,color2,smoothstep(-0.5,0.9,sin(-iTime+length(uv)-2.*10.)));\n     } else {\n        color = mix(vec3(.9,0.9,0.9), vec3(0.9,0.0,0.2)+vec3(0.,0.,length(uv)), color)*(1.-shad); \n     }\n  } \n \n  fragColor = vec4(color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}