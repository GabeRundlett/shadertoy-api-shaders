{
    "Shader": {
        "info": {
            "date": "1581977744",
            "description": "potaot",
            "flags": 32,
            "hasliked": 0,
            "id": "tl3XDs",
            "likes": 13,
            "name": "Day 60",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 448
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 59\" by jeyko. https://shadertoy.com/view/3ldSWf\n// 2020-02-17 13:02:38\n\n// Fork of \"Day 55\" by jeyko. https://shadertoy.com/view/wl3Szs\n// 2020-02-16 14:20:34\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    #define chromaticAbberationAmt (0.01 + sin(iTime)*0.00)\n    //float f = length(uv  - 0.5);\n    float f = dot(uv  - 0.5,uv  - 0.5);\n    fragColor.x = T(uv + f*chromaticAbberationAmt).x;\n    fragColor.y = T(uv).y;\n    fragColor.z = T(uv -f*chromaticAbberationAmt).z;\n    fragColor += clamp(texture(iChannel0,uv, 6.), 0., 1.)*0.4;\n    fragColor *= 1.9;\n    //fragColor = smoothstep(0.,1., fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define iTime (iTime + 100.)\n\n#define outline(x, w) (abs(x) - w)\n#define inline(x) -((x)) \n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(a, x) mod(a, x) - x*0.5\n\n//#define KALEIDOMODE\n\n\nfloat rand2D(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n// http://www.science-and-fiction.org/rendering/noise.html\n// dot noise from here\n\nfloat dotNoise2D(in float x, in float y, in float fractionalMaxDotSize, in float dDensity)\n{\n    float integer_x = x - fract(x);\n    float fractional_x = x - integer_x;\n\n    float integer_y = y - fract(y);\n    float fractional_y = y - integer_y;\n\n    if (rand2D(vec2(integer_x+1.0, integer_y +1.0)) > dDensity)\n       {return 0.0;}\n\n    float xoffset = (rand2D(vec2(integer_x, integer_y)) -0.5);\n    float yoffset = (rand2D(vec2(integer_x+1.0, integer_y)) - 0.5);\n    float dotSize = 0.5 * fractionalMaxDotSize * max(0.25,rand2D(vec2(integer_x, integer_y+1.0)));\n\n    vec2 truePos = vec2 (0.5 + xoffset * (1.0 - 2.0 * dotSize) , 0.5 + yoffset * (1.0 -2.0 * dotSize));\n\n    float distance = length(truePos - vec2(fractional_x, fractional_y));\n\n    return 1.0 - smoothstep (0.3 * dotSize, 1.0* dotSize, distance);\n\n}\n\n    \n#define pal(a,b,c,d,e) (a + b*sin(tau*(c*d + e)))\n\nvec4 valueNoise(float i, float tol){\n    vec4 a = texture(iChannel0,vec2(floor(i)*0.02));\n    vec4 b = texture(iChannel0,vec2(floor((i+1.))*0.02));\n    \n    if (a.z > tol)\n        a -= a;\n    if (b.z > tol)\n        b -= b;\n    \n\treturn mix(a,b,pow(fract(i), 20.));\n}\n\n\nvec2 sUv = vec2(0);\n#define mx (iTime*4. + 10.*iMouse.x/iResolution.x)\nvec3 sumonTheDemon( vec2 p, float id )\n{\n    vec3 col = vec3(0);\n\n    #define spacing (0.08 + sin(iTime*0.7)*0.07)\n    #define PLANES 40.\n    #define W 0.0005\n    \n    float rA = texture(iChannel0, vec2(sin(id*0.01)*200.,id )).x;\n    float rB = texture(iChannel0, vec2(sin(id*0.03 + 0.2)*200.,id*1.4 )).x;\n    float rS = sign(rA - 0.5);\n    float rSB = sign(rB - 0.5);\n    float fig = 10e6;\n    vec2 k = p;\n    \n    p.xy *= rot(iTime*rB*rS*0.9);\n    \n    float baseW = 0.05;\n   \n    vec4 nScreen = valueNoise(iTime, 1.);\n    \n    p.x += 0.1*nScreen.z*exp(-(500.+nScreen.y*500.)*abs(sUv.y - nScreen.x + 0.5))*0.2*sin(sUv.y*200. + iTime*50.);\n    \n    #define onion(d, amt) (length(mod(amt*d, 1.) - 0.5 ) - 0.0)\n    \n    #define ysep 2.\n    \n    float idy = floor(2000.*k.y/ysep);\n    vec4 nPolar = valueNoise(iTime*2000.*rS + atan(p.y, p.x)*100.5 + id*2., 0.7);\n    p.x += valueNoise(iTime*20. + idy*20.5 + id, 0.1).x*0.02;\n    p.xy *= 1. + nPolar.x*.06;\n    vec4 nPolarB = valueNoise(iTime*1.*rS + mod(atan(p.y, p.x), 6.14)*10. + id*2., 0.9);\n        \n    float pol = mod(atan(p.y, p.x) + id*0.2, 6.38);\n    pol = 1.;\n    p.xy += normalize(p.xy)*nPolarB.x*pol*0.007;\n    //p.xy += normalize(p.xy)*nPolarB.x*.008;\n    \n    p.xy += 0.005;\n    \n    p *= rot(0.25*pi);\n    if(rA < 0.5){\n    \tp = abs(p);\n    \tp *= rot(0.25*pi);\n    }\n    \n    \n    fig = min(fig, outline( length(p.xy*3.) - 0.2 + sin(id)*0.05, 0.001    ));\n    \n    //fig = onion(fig , (20. + 5.*sin(iTime + id)));\n \n    col += smoothstep(0.02,0.,fig)*vec3(1)*1.;    \n\n    col *= pal(0.,vec3(1.,1.,1.)*(1.5 - nPolar.y),vec3(3.87,4.4,4.1), vec3(2.1,-0.9,5.1), id*0.1 + sin(id*2. + nPolar.x)*0.05);\n    col *= 1. + 2.*pol/6.38;\n    \n    \n    k += id;\n    for(int i = 0; i < 2; i++){\n    \tk = abs(k);\n    \t\n        k.x -= 0.6;\n        k *= rot(2.);\n    }\n    k *= 20.;\n    col += dotNoise2D(k.x, k.y, 0.05, 1.);\n    \n    float stars = 10e5;\n    \n\n    \n    //col += smoothstep(0.005,0.,stars)*vec3(1)*2.;    \n\n    \n    return col;\n}\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 p0, vec3 n){\n    float denom = dot(rd,n);\n    if (denom > 1e-6) {\n        float t = - dot(ro - p0, n)/denom; \n\t\tif (t > 0.) return t;\n        return t;\n    }  \n    return 1e10;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tsUv = uv;\n    //uv *= 1. + dot(uv,uv)*0.7;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    \n    \n    \n    ro.z;\n    vec3 rd = normalize(vec3(uv,1));\n   \n    rd.xz *= rot(sin(iTime)*0.04);\n    rd.xy *= rot(sin(iTime*0.2)*0.5);\n    \n    #define fog(a) smoothstep(1., 0., a*0.8)\n    \n    for(float i = 0.; i < PLANES + float(min(iFrame, 0)); i++ ){\n    \tfloat plA = iPlane(ro, rd, vec3(0,0,mod(-mx + i,PLANES))*spacing, vec3(0,0,1));\n    \tcol += sumonTheDemon( (ro+rd*plA).xy, floor((-mx+i)/PLANES)*PLANES + i)*fog(plA);\n    }\n    \n\t\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}