{
    "Shader": {
        "info": {
            "date": "1465975269",
            "description": "My second day tinkering with shaders at all and my first raymarching shader. Change definitions to affect effect. Mouse position to control. I suggest vanilla settings and the mouse on the left side of the screen when beginning.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldySzt",
            "likes": 1,
            "name": "My First Raymarch Shader",
            "published": 3,
            "tags": [
                "3d",
                "mouse",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "gunnarclovis",
            "viewed": 793
        },
        "renderpass": [
            {
                "code": "// change MODE to 0, 1\n// suggest changing ROT_SPEED to 0 when using MODE 1\n#define MODE 0\n// rotation speed\n// make negative to reverse direction\n// may cause stuttering/skipping if abs(ROT_SPEED) > 1\n#define ROT_SPEED 0.25\n\n// active movement axises\n#define MOVE_X false\n#define MOVE_Y true\n#define MOVE_Z true\n\n// increase RANGE for new hidden effects to find with mouse\n#define RANGE 1.0\n// marching iterations\n// depends on complexity of the scene\n// 16, 32 good values\n#define ITERATIONS 32\n// z-value\n// make negative to reverse direction\n#define Z 1.0\n// whether or not to tint with RGB color values over time\n// play with values at bottom of mainImage function\n#define RGB_TINT false\n\n// map function return a scalar from a point\nfloat map(vec3 point)\n{\n    if(MODE == 0)\n    {\n        // instancing\n        // transform the space into repeating coordinate system\n    \tvec3 q = fract(point) * 2.0 - RANGE * (1.0 - smoothstep(0.0, iResolution.x, iMouse.x));\n        // length of point minus radius\n        return length(q) - RANGE * (1.0 - smoothstep(0.0, iResolution.y, iMouse.y));\n    }\n    // Basic sphere\n    else\n    {\n        return length(point) - 5.0 * smoothstep(0.0, iResolution.x, iMouse.x);\n    }\n}\n\n// numerical marching algorithm\n// march along ray from origin\nfloat trace(vec3 origin, vec3 ray)\n{\n    float intersection = 0.0;\n    \n    for(int i = 0; i < ITERATIONS; ++i)\n    {\n        // calculate position on the array\n        // gradually converge to the intersection\n        vec3 point = origin + ray * intersection;\n        \n        float d = map(point);\n        // accumulate\n        intersection += d * 0.5;\n    }\n    \n    return intersection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate uv coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Transform the coordinates to go from -1.0 to 1.0 instead of default 0.0 to 1.0 pixel shader coordinates\n    uv = uv * 2.0 - 1.0;\n    \n    // aspect ratio correction to create sphere instead of ovoid\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // create normalized ray with z value to project uv into 3D space\n    vec3 ray = normalize(vec3(uv, Z));\n    \n    // basic rotation\n    float rotation = iTime * ROT_SPEED;\n    ray.xz *= mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    \n    // origin z-value iTime sets back from the sphere\n    vec3 origin;\n    if(MODE == 0)\n    {\n        origin = vec3(0.0);\n        \n        if(MOVE_X) origin.x = iTime;\n        if(MOVE_Y) origin.y = iTime;\n        if(MOVE_Z) origin.z = iTime;\n    }\n    // set z to -3.0 if sphere to be visible\n    else\n    {\n        origin = vec3(0.0, 0.0, -3.0);\n    }\n    \n    \n    // trace ray from origin\n    float t = trace(origin, ray);\n    \n    // simple fogging function to render\n    // the further away something is the darker it gets\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n    // RGB tint\n    if(RGB_TINT)\n    {\n        fc.r += 0.0 + 0.1 * sin(iTime * 1.0);\n        fc.g += 0.0 + 0.1 * cos(iTime * 1.0);\n        fc.b += 0.0 + 0.1 * cos(iTime * 1.5);\n    }\n    \n    // Set fragColor output\n\tfragColor = vec4(fc, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}