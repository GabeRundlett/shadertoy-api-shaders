{
    "Shader": {
        "info": {
            "date": "1600154963",
            "description": "3-pass variant + stratif sampling + kernel (Common:63)\noversample only where aliased Left: none, for reference [url]https://shadertoy.com/view/3ljfRG[/url]\nMouse.x : ref separator   \nSPACE: show oversampled areas (colors = not )\nM: show oversampling level",
            "flags": 48,
            "hasliked": 0,
            "id": "WlSBDt",
            "likes": 22,
            "name": "easy adaptive sampling: checker",
            "published": 3,
            "tags": [
                "raytracing",
                "antialiasing",
                "sampling",
                "optimization",
                "adaptive",
                "gpmipmap",
                "spacefungus"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1048
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/Wt2fzV\n// adapted from https://shadertoy.com/view/3ljfRG\n//          and https://shadertoy.com/view/WtjBzV\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage(out vec4 O, vec2 u) {    \n    pass = 3.;\n    R = iResolution.xy;                        // here because stupidely can't be in Common\n    time = iTime;                              // here because stupidely can't be in Common\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.; // selector.  here because stupidely can't be in Common\n    \n    O = AArender( u, s+.1*R.x, iChannel0 );    // oversample only where necessary\n  //O = texelFetch(iChannel2, ivec2(u), 0);    // test: show brute image\n  //O = texelFetch(iChannel1, ivec2(u), 0);    // test: show pass1 AA\n  //O = texelFetch(iChannel0, ivec2(u), 0);    // test: show pass2 AA\n\n    if ( keyToggle(32) && O.a==0. )            // SPACE: show red/blue where not oversampled\n           O.r -= .5, O.b += .5;\n    if   keyToggle(64+13) O = O.a - vec4(0,1,2,0); // 'M': show #pass oversampling mask\n        \n    if ( floor(u.x-s+.1*R.x) == 0. ) O = vec4(.3,0,0,1);  // pass0/1 red separator\n    if ( floor(u.x-s       ) == 0. ) O = vec4(.6,0,0,1);  // pass1/2 red separator\n    if ( floor(u.x-s-.1*R.x) == 0. ) O = vec4(1.,0,0,1);  // pass2/3 red separator\n    \n    O = pow( O, vec4(1./2.2) );                // to sRGB\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define N 5              // pixel oversampling NxN ( only where necessary )\nfloat n = float(N), time, pass = 0.; // pass id\nvec2    R;               // iResolution, that we stupidely can't have in Common\n#define T(U,l)     textureLod(iChannel0, (U)/R, float(l) )\n\n// --- custom function or image or render: FXAA checkerpattern filter  https://www.shadertoy.com/view/wt2fD3\n\n#define map(p) ( (p).y - .1 )   // plane\n\nvoid lookAt(inout vec3 ro, inout vec3 rd, vec3 tg) {\n    vec3 ot = normalize(tg - ro),\n         up = vec3(0, 1, 0),\n         rr = normalize(cross(ot, up));\n         up = cross(rr, ot);\n    rd = mat3(rr, up, ot) * rd;\n}\n\nfloat checkerPattern(vec3 p, float t) { \n    if (t < 0.)  return 1.;  // comment if you wanna go beyond infinity :-p\n    p -= time;\n    p = floor(p);    return float( mod(p.x + p.z, 2.) > 0. ); // base checkers\n // p = sin(3.14*p); return 1.-R.y/3.*p.x*p.z;                // continuous variant\n // p = sin(3.14*p); return clamp( 1.-R.y/3.*p.x*p.z, 0.,1.); // clamped\n}\n\nvec4 render( vec2 u ) {\n    vec3 p = vec3(0, 3.5, 15),           // setup camera\n         D = normalize( vec3( ( 2.*u - R ) / R.y, 1) ); \n         lookAt(p, D, vec3(0));\n#if 1                                    // --- true ray-tracing\n    float t = ( .1 - p.y ) / D.y; p += t * D; \n#else                                    // --- ray-marching\n    float ep = 1e-4, d, t=0.;\n\n    int i = 0;\n    for ( ; i < 50; i++) {               // march\n        d = map(p);                      // shape\n        if (d < ep || t > 120. ) break;  // hit\n        p += d * D, t += d;              // step along ray\n    }\n#endif\n    return vec4( vec3(checkerPattern(p, t)), 0 ); // return color & texture at hit point\n                                         // 0: mark native areas\n}\n\n// --- my adaptive antialiasing: oversample only if neighborhood disagree\n\n              //           /  0. for test. should be 99. for different sampling per pass\n#define hash12(p)  fract(sin( 99.*pass + float(p) * vec2(12.9898, 78.233) ) * 43758.5453)\n\nvec4 AArender( vec2 u, float side, sampler2D iChannel0 ) { // we stupidely can't have iChannel0 in Common\n    vec4  O =  T(u,0), C;                // result of previous pass\n    if (u.x < side) return O;            // no AAÂ at left of side\n    \n  //               / 1, or pass ?\n  //if ( length( T(u,1).rgb - T(u,0).rgb ) > 0. ) { // neighborhood does not agree\n    if ( abs( T(u,1).x - T(u,0).x ) > 2./256. )   { // neighborhood does not agree\n        C = vec4(0);\n        float w = 1., wt = 0.;           // weigth\n        for (int k=0; k<N*N; k++) {      // --- oversampling\n          //vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n;     // subpixel : grid\n          //vec2 D = hash12(k) - .5;                            // subpixel : rand\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. + hash12(k)-.5 ) / n; // stratified\n            D *= 1.5; w = exp(-4.*dot(D,D)); wt += w;           // gaussian kernel filter\n            C += render(  u +  D ) * w;\n        }\n        C *= n*n / wt;                   // normalize by pass weigth (for kernel filter )\n        O *= n*n*(pass-1.);              // restore weigth\n        O += C;                          // add new contribs\n        O /= n*n *pass;                  // normalize by multipass weigth\n        O.a = pass;                      // 1: mark filtered aread\n    }\n  //else                                 // LOD#0 is ok\n    \n    return O;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    R = iResolution.xy;           // here because stupidely can't be in Common\n    time = iTime;                 // here because stupidely can't be in Common\n\n    O = render(u);                // render brute image (no oversampling)\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- Adative oversampling where needed\n\nvoid mainImage(out vec4 O, vec2 u) {\n    pass = 1.;\n    R = iResolution.xy;                        // here because stupidely can't be in Common\n    time = iTime;                              // here because stupidely can't be in Common\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.; // selector.  here because stupidely can't be in Common\n\n    O = AArender( u, s-.1*R.x, iChannel0 );    // oversample only where necessary\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- Adative oversampling where needed\n\nvoid mainImage(out vec4 O, vec2 u) {\n    pass = 2.;\n    R = iResolution.xy;                        // here because stupidely can't be in Common\n    time = iTime;                              // here because stupidely can't be in Common\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.; // selector.  here because stupidely can't be in Common\n\n    O = AArender( u, s, iChannel0 );           // oversample only where necessary\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}