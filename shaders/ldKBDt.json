{
    "Shader": {
        "info": {
            "date": "1531126775",
            "description": "The combination of a glass block and sphere. Still, not using raymarching, but using intersectings.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKBDt",
            "likes": 13,
            "name": "Glass block and sphere",
            "published": 3,
            "tags": [
                "ray",
                "sphere",
                "glass",
                "box",
                "tracing",
                "reflect",
                "refract"
            ],
            "usePreview": 0,
            "username": "0xAA55",
            "viewed": 857
        },
        "renderpass": [
            {
                "code": "\nfloat PI = 3.1415926535897932384626;\nfloat glass_eta = 1.458;\nvec3 glass_color = vec3(.1);\nfloat glass_impurity = .01;\n\nmat3 mi = mat3(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1));\n\nstruct box_t\n{\n    vec3 p, d; // Position, Dimension\n    mat3 r; // Rotation\n};\n\nstruct sphere_t\n{\n    vec3 p;\n\tfloat radius;\n    mat3 r;\n};\n\nstruct raycast_t\n{\n\tvec3 p;\n\tvec3 n;\n\tvec2 uv;\n\tfloat d;\n\tbool i;\n};\n\nsphere_t sph;\nbox_t bx;\n\nvoid scene_init()\n{\n\tsph = sphere_t(vec3(-sin(iTime),0.,0.), 1., mi);\n\tbx = box_t(vec3(.5,0.,0.), vec3(.8), mi);\n}\n\nmat3 rot_x(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cang,-sang),\n        vec3(0.0, sang, cang)\n    );\n}\n\nmat3 rot_y(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, 0.0, sang),\n        vec3(  0.0, 1.0, 0.0),\n        vec3(-sang, 0.0, cang)\n    );\n}\n\nmat3 rot_z(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, sang, 0.0),\n        vec3(-sang, cang, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 rot_axis(vec3 v, float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3\n        (\n            (1.0 - cang) * v.x * v.x + cang,\n            (1.0 - cang) * v.x * v.y - sang * v.z,\n            (1.0 - cang) * v.x * v.z + sang * v.y\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.y * v.x + sang * v.z,\n            (1.0 - cang) * v.y * v.y + cang,\n            (1.0 - cang) * v.y * v.z - sang * v.x\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.z * v.x - sang * v.y,\n            (1.0 - cang) * v.z * v.y + sang * v.x,\n            (1.0 - cang) * v.z * v.z + cang\n        )\n    );\n}\n    \nmat3 rot_yaw_pitch_roll(vec3 ypr)\n{\n    return rot_z(ypr.z) * rot_x(ypr.y) * rot_y(ypr.x);\n}\n\nbool sphere_raycast(sphere_t sphere, vec3 orig, vec3 dir, bool isfrominside, out raycast_t raycast)\n{\n\tvec3 o = orig;\n\tvec3 d = dir;\n\tvec3 c = sphere.p;\n\tfloat r = sphere.radius;\n    float rsq = r * r;\n    mat3 rot_mat = sphere.r;\n\t\n\tbool isinside = false;\n\n    vec3 o2c = c - o;\n    float distsq = dot(o2c, o2c);\n    float o2cdp = dot(o2c, d);\n    float c2raysq = max(0., distsq - o2cdp * o2cdp);\n    if(c2raysq > rsq) return false;\n    float foo = sqrt(rsq - c2raysq);\n    float dist1 = o2cdp - foo;\n    float dist2 = o2cdp + foo;\n    if(distsq < rsq) isinside = true;\n    if(isinside && !isfrominside) return false;\n\n    if(isinside || isfrominside) raycast.d = dist2;\n    else raycast.d = dist1;\n    \n    if(!isfrominside && raycast.d < 0.) return false;\n    \n\traycast.p = o + d * raycast.d;\n\tvec3 nor = (raycast.p - c) / r;\n\traycast.n = nor;\n    if(isfrominside) raycast.n = -raycast.n;\n\traycast.i = isinside;\n\t\n    vec3 uvn = nor * rot_mat;\n\traycast.uv.x = (atan(uvn.z, uvn.x) / PI) * .5 + .5;\n\traycast.uv.y = (atan(uvn.y, length(uvn.xz)) / PI) * .5 + .5;\n    return true;\n}\n\nbool box_raycast(box_t box, vec3 start, vec3 n_ray, bool isfrominside, out raycast_t raycast)\n{\n    mat4 box_mat = mat4\n    (\n        vec4(box.r[0], 0.),\n        vec4(box.r[1], 0.),\n        vec4(box.r[2], 0.),\n        vec4(box.p, 1.)\n    );\n    bool inside = false;\n    \n    mat4 box_mat_inv = inverse(box_mat);\n    \n    vec3 start_local = (box_mat_inv * vec4(start, 1.)).xyz;\n    vec3 ray_local = (box_mat_inv * vec4(n_ray, 0.)).xyz;\n    \n    vec3 sv = step(abs(start_local), box.d);\n    if(sv.x > .5 && sv.y > .5 && sv.z > .5) inside = true;\n    if(inside && !isfrominside) return false;\n    if(inside || isfrominside) start_local = -start_local;\n    \n    vec3 rat = 1.0 / ray_local;\n    vec3 trp = rat * start_local;\n    vec3 dim = box.d * abs(rat);\n    \n    vec3 t1 = -trp - dim;\n    vec3 t2 = -trp + dim;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    \n\tif( tN > tF || (!isfrominside && tF < 0.0) ) return false;\n    \n    vec3 nor = -sign(ray_local)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    raycast.p = start + n_ray * tN;\n    raycast.d = abs(tN);\n    raycast.n = (box_mat * vec4(nor,0.)).xyz * (isfrominside ? -1.:1.);\n    raycast.i = inside;\n    \n    vec3 cp_local = (box_mat_inv * vec4(raycast.p, 1.)).xyz;\n    \n    raycast.uv = (nor.x * cp_local.yz + nor.y * cp_local.zx + nor.z * cp_local.xy) *.5 + .5;\n    \n    return true;\n}\n\n// Can change this function to render some featured environment\nvec4 sky_sample(vec3 ray)\n{\n    return texture(iChannel0, ray);\n}\n\nvoid ray_enter_glass(vec3 ray, vec3 normal, out vec3 out_ray, float inside_distance, inout vec4 surface_color)\n{\n\tsurface_color += mix(sky_sample(reflect(ray, normal)) * (1. - max(0., dot(ray, -normal))),\n\t\t\t\t\t\t vec4(0),\n\t\t\t\t\t\t clamp(inside_distance * glass_impurity, 0., 1.));\n\t\n\tout_ray = refract(ray, normal, 1. / glass_eta);\n}\n\nbool ray_inside_glass(vec3 ray, vec3 normal, float cast_dist, out vec3 out_ray, inout float inside_distance)\n{\n\tfloat k;\n\tfloat dot_ni = dot(normal, ray);\n\t\n\tinside_distance += cast_dist;\n\tk = 1. - glass_eta * glass_eta * (1. - dot_ni * dot_ni);\n\tif(k >= 0.)\n\t{\n        out_ray = glass_eta * ray - (glass_eta * dot_ni + sqrt(k)) * normal;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tout_ray = reflect(ray, normal);\n\t\treturn true;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scene_init();\n    \n\tvec2 xy = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 mouse_rotation = ((iMouse.xy / iResolution.y) * 2. -1.) * PI;\n    if(length(iMouse.xy) < 0.000001) mouse_rotation = vec2(0);\n    \n\tvec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y) + vec2(iTime * .3, sin(iTime * .5) * .25);\n    mat3 viewmat = rot_yaw_pitch_roll(vec3(yawpitch, 0));\n    \n    vec3 ray = normalize(vec3(xy, 1)) * viewmat;\n    vec3 eyepos = vec3(0., 0., -5.) * viewmat;\n    \n    vec3 trace_org = eyepos;\n    vec3 trace_ray = ray;\n\traycast_t cur_cast;\n    \n    vec4 color = vec4(0);\n\tvec4 surface_color = vec4(0);\n\tfloat dist_inside_glass = 0.;\n    \n\tbool inside = false;\n\tbool no_cast = true;\n\tfor(float iter = 0.0; iter < 128.; iter ++)\n\t{\n\t\traycast_t csph_front;\n\t\traycast_t csph_back;\n\t\traycast_t cbx_front;\n\t\traycast_t cbx_back;\n\t\t\n\t\tbool csf = sphere_raycast(sph, trace_org, trace_ray, false, csph_front);\n\t\tbool csb = sphere_raycast(sph, trace_org, trace_ray, true, csph_back);\n\t\tbool cbf = box_raycast(bx, trace_org, trace_ray, false, cbx_front);\n\t\tbool cbb = box_raycast(bx, trace_org, trace_ray, true, cbx_back);\n\t\t\n\t\t// Cast from outside\n\t\tif(!inside)\n\t\t{\n\t\t\t// No cast\n\t\t\tif(!csf && !cbf) break;\n\t\t\t// Cast sphere\n\t\t\telse if(csf && !cbf) cur_cast = csph_front;\n\t\t\t// Cast box\n\t\t\telse if(!csf && cbf) cur_cast = cbx_front;\n\t\t\t// Cast both\n\t\t\telse if(csph_front.d <= cbx_front.d) cur_cast = csph_front;\n\t\t\telse cur_cast = cbx_front;\n\t\t\t\n\t\t\tinside = true;\n\t\t\tno_cast = false;\n\t\t\t\n\t\t\ttrace_org = cur_cast.p;\n\t\t\tray_enter_glass(trace_ray, cur_cast.n, trace_ray, dist_inside_glass, surface_color);\n\t\t}\n\t\t// Cast from inside\n\t\telse\n\t\t{\n\t\t\tif(csb && !cbb) cur_cast = csph_back;\n\t\t\telse if(!csb && cbb) cur_cast = cbx_back;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(csph_back.d < cbx_back.d)\n\t\t\t\t{\n\t\t\t\t\tcur_cast = csph_back;\n\t\t\t\t\tif(cbx_back.d >= cur_cast.d) cur_cast = cbx_back;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcur_cast = cbx_back;\n\t\t\t\t\tif(csph_back.d >= cur_cast.d) cur_cast = csph_back;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttrace_org = cur_cast.p;\n\t\t\tinside = ray_inside_glass(trace_ray, cur_cast.n, cur_cast.d, trace_ray, dist_inside_glass);\n\t\t}\n\t}\n    \n\tif(no_cast)\n\t\tcolor = sky_sample(trace_ray);\n\telse\n\t{\n        if(inside)\n        {\n            dist_inside_glass = 2. / glass_impurity;\n        }\n        color = mix(sky_sample(trace_ray),\n                    vec4(glass_color, 1.),\n                    clamp(dist_inside_glass * glass_impurity, 0., 1.))\n        + surface_color;\n\t}\n\t\n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}