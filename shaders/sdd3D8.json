{
    "Shader": {
        "info": {
            "date": "1629740650",
            "description": "Alphabet \"S\" made out of water is lying on the window.\n\nThis is my first serious shader. I brought a lot of code from iq's tutorials.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdd3D8",
            "likes": 28,
            "name": "Water Alphabet on window",
            "published": 3,
            "tags": [
                "sdf",
                "refraction",
                "water"
            ],
            "usePreview": 0,
            "username": "sunhokim",
            "viewed": 801
        },
        "renderpass": [
            {
                "code": "#define M_PI (3.1415926535897932384626433832795)\n#define ZERO (min(int(iTime), 0))\n\n#define LETTER_INDEX (1.3)\n#define LETTER_R0 ((LETTER_INDEX - 1.0) * (LETTER_INDEX - 1.0) / ((LETTER_INDEX + 1.0) * (LETTER_INDEX + 1.0)))\n#define LETTER_BEAM ((vec3(1) - vec3(0.66, 0.95, 1)) * 0.5)\n\n//******************\n//* sdf primitives *\n//******************\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdArc(in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb)\n{\n  p *= mat2(sca.x, sca.y, -sca.y, sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y * p.x > scb.x * p.y) ? dot(p, scb) : length(p);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat opExtrusion(in float z, in float d, in float h)\n{\n  vec2 w = vec2(d, abs(z) - h);\n  return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat sdC(vec3 p, vec3 size) {\n  float d = sdArc(p.xy, vec2(0.0, 1.0), vec2(sin(M_PI * 0.5), cos(M_PI * 0.5)), size.x, size.y);\n  return opExtrusion(p.z, d, size.z);\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r)\n{\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n  return (-d1.x > d2.x) ? vec2(-d1.x, d1.y) : d2;\n}\n\nvec4 opElongate(in vec3 p, in vec3 h)\n{\n  vec3 q = abs(p) - h;\n  return vec4(max(q, 0.0), min(max(q.x, max(q.y, q.z)), 0.0));\n}\n\n//*********\n//* utils *\n//*********\nvec3 rotateX(in vec3 p, float t)\n{\n  float co = cos(t);\n  float si = sin(t);\n  p.yz = mat2(co, -si, si, co) * p.yz;\n  return p;\n}\n\nvec3 rotateY(in vec3 p, float t)\n{\n  float co = cos(t);\n  float si = sin(t);\n  p.xz = mat2(co, -si, si, co) * p.xz;\n  return p;\n}\n\nvec3 rotateZ(in vec3 p, float t)\n{\n  float co = cos(t);\n  float si = sin(t);\n  p.xy = mat2(co, -si, si, co) * p.xy;\n  return p;\n}\n\nfloat noise(in vec3 x)\n{\n  return texture(iChannel0, x / 32.0).x;\n}\n\nfloat noise2(in vec2 p) {\n  return noise(vec3(p, 0.5));\n}\n\nvec3 refractRay(in vec3 rd, in vec3 normal, float indexRatio) {\n  float cosTh = dot(rd, normal);\n  float cosPhi2 = 1.0 - (1.0 - cosTh * cosTh) / (indexRatio * indexRatio);\n  if (cosPhi2 < 0.0) {\n    // total internal reflection\n    return rd;\n  }\n  vec3 firstTerm = (rd - normal * cosTh) / indexRatio;\n  vec3 secondTerm = normal * sqrt(cosPhi2);\n  return normalize(firstTerm - secondTerm);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(in vec3 eye, in vec3 look)\n{\n  vec3 w = normalize(eye - look);\n  vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n  vec3 v = cross(w, u);\n  return transpose(mat3(u, v, w));\n}\n\nfloat fresnel(float R0, float cosTh) {\n  float a = (1.0 - cosTh);\n  return R0 + (1.0 - R0) * (a * a * a * a * a);\n}\n\nvec2 iSphere(in vec3 ro, in vec3 rd, in float rad)\n{\n  float b = dot(ro, rd);\n  float c = dot(ro, ro) - rad * rad;\n  float h = b * b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n//************\n//* geometry *\n//************\nfloat mountainfbm(in vec2 x)\n{\n  float G = 0.30;\n  float a = 1.0;\n  float t = 0.0;\n  const mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n  for (int i = 0; i < 6; i++)\n  {\n    t += a * noise2(x);\n    a *= -G;\n    x = rotate2D * x;\n  }\n\n  return t;\n}\n\nvec2 mountain(vec3 p) {\n  if (p.z > -2.0) return vec2(1e10, 0.0);\n  vec2 q = 0.1 * p.xz;\n  float height = mountainfbm(0.5 * q + vec2(7.0, 3.0));\n  height *= 15.0;\n  height = mix(height, 1.5 * noise2(q * 1.2) - 7.1, 1.0 - smoothstep(50.0, 140.0, length(p)));\n  float h = (-height - p.y) * 0.4;\n  return vec2(h, 2.0);\n}\n\nfloat waveoctave(vec3 uv) {\n  uv += noise(uv);\n  vec3 wv = 1.0 - abs(sin(uv));\n  vec3 swv = abs(cos(uv));\n  wv = mix(wv, swv, wv);\n  return 1.0 - pow(wv.x * wv.y * wv.z, 0.65);\n}\n\nfloat wavefbm(in vec3 uv)\n{\n  float G = 0.3;\n  float f = 1.9;\n  float a = 1.0;\n  float t = 0.0;\n\n  float d = 0.0;\n  for (int i = 0; i < 6; i++)\n  {\n    float k = waveoctave((0.5 * iTime + uv) * f);\n    d += k * a;\n    a *= G;\n    f *= 2.0;\n  }\n\n  return d;\n}\n\nfloat table(vec3 p, float h) {\n  vec4 q = opElongate(rotateX(p, M_PI * 0.5), vec3(7.0, 0.0, 0.0));\n  return max(sdTriPrism(q.xyz, vec2(5.0, h)), sdBox(p - vec3(0.0, 0.0, -5.0), vec3(9.0, h + 0.1, 5.0)));\n}\n\nfloat windowPart(vec3 p) {\n  float window = sdBox(p, vec3(3.75, 7.4, 0.5));\n  float windowCut = sdBox(p, vec3(3.75 - 0.7, 7.4 - 0.7, 0.6));\n  window = max(-windowCut, window);\n  vec3 q = rotateZ(p - vec3(3.75, 2.2, 0.0), M_PI * 0.5);\n  window = opSmoothUnion(window, sdVerticalCapsule(q, 7.2, 0.2), 0.3);\n  q = rotateZ(p - vec3(3.75, -2.2, 0.0), M_PI * 0.5);\n  window = opSmoothUnion(window, sdVerticalCapsule(q, 7.2, 0.2), 0.3);\n  return window;\n}\n\nvec2 window(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  {\n    res = opU(res, vec2(table(p - vec3(0.0, 0.2, 2.0), 0.2), 3.0));\n  }\n  {\n    vec3 q = p - vec3(-3.5, -7.2, -3.7);\n    res = opU(res, vec2(windowPart(q), 3.0));\n    q = p - vec3(3.5, -7.2, -3.7);\n    res = opU(res, vec2(windowPart(q), 3.0));\n  }\n  return res;\n}\n\nvec2 mapBackground(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  res = opU(res, mountain(p));\n  {\n    res = opU(res, window(p));\n  }\n  {\n    vec3 q = p - vec3(0.0, -17.0, 37.0);\n    vec2 room = vec2(sdBox(q, vec3(35.0, 25.0, 40.0)), 6.0);\n    vec2 roomcut1 = vec2(sdBox(q, vec3(35.0 - 3.0, 25.0 - 2.0, 40.0 - 5.0)), 6.0);\n    room = opS(roomcut1, room);\n\n    q = p * 0.995 - vec3(0.0, -7.0, 2.0);\n    vec2 windowcut2 = vec2(table(q, 7.4), 6.0);\n    room = opS(windowcut2, room);\n    res = opU(res, room);\n  }\n  return res;\n}\n\nvec2 letter(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  res = opU(res, vec2(sdC(rotateZ(p, -M_PI * 0.2), vec3(0.8, 0.4, 0.5)), 1.0));\n  res = opU(res, vec2(sdC(rotateZ(p, M_PI * 0.8) - vec3(0.0, 1.6, 0), vec3(0.8, 0.4, 0.5)), 1.0));\n  return res;\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  {\n    vec3 q = (rotateY(rotateZ(p, M_PI * 0.1), -M_PI * 0.01) - vec3(0, -3.6, 0.0)) / 2.5;\n    vec2 a = letter(q) / 2.5;\n\n    float h = 0.04 * wavefbm(q);\n    res = opU(res, vec2(a.x - h, a.y));\n  }\n\n  {\n    res = opU(res, mapBackground(p));\n  }\n\n  return res;\n}\n\n//***********************\n//* shading subroutines *\n//***********************\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n{\n  float res = 1.0;\n  float t = 0.01;\n  for (int i = 0; i < 128; i++)\n  {\n    float h = mapBackground(ro + rd * t).x;\n    if (h < 0.001 || (ro + rd * t).y > 10.0)\n      return 0.0;\n    res = min(res, k * max(h, 0.0) / t);\n    t += h;\n  }\n  return res;\n}\n\nfloat ao(vec3 p, vec3 n) {\n  float occ = 0.0;\n  for (int i = ZERO; i < 32; i++)\n  {\n    float h = 0.01 + 2.0 * pow(float(i) / 31.0, 2.0);\n    occ += clamp(2.0 * mapBackground(p + h * n).x / h, -1.0, 1.0);\n  }\n  return clamp(occ / 32.0, 0.0, 1.0);\n}\n\nvec3 applyFog(in vec3 rgb,\n  in float distance,\n  in vec3 rayOri,\n  in vec3 rayDir)\n{\n  const float b = 0.005; // beam transmittance\n  float fogAmount = 1.0 - exp(-distance * b);\n  vec3 fogColor = vec3(0.5, 0.6, 0.6);\n  return mix(rgb, fogColor, fogAmount);\n}\n\nfloat cloudfbm(in vec2 x)\n{\n  float f = 1.0;\n  float G = 0.30;\n  float a = 1.0;\n  float t = 0.0;\n  for (int i = 0; i < 1; i++)\n  {\n    t += a * noise2(f * x);\n    a *= G;\n    f *= 2.0;\n  }\n\n  return t;\n}\n\nvec3 skyColor(vec3 rd) {\n  float k = (max(-rd.y, 0.0) * 1.2 + 0.2) * 0.8;\n  vec3 sky = vec3(pow(1.0 - k, 2.0), 1.0 - k, 0.6 + (1.0 - k) * 0.46) * 1.1;\n  float v = (-200.0) / rd.y;\n  rd.xz *= v;\n  rd.xz *= 0.005;\n  float f = (cloudfbm(rd.xz) - 0.6) * 20.0;\n  sky = mix(sky, vec3(.9, .9, .9), clamp(f * -rd.y, 0.0, 1.0));\n  return sky;\n}\n\nfloat woodfbm(in vec3 x)\n{\n  float G = 0.5;\n  float f = 0.6;\n  float a = 1.0;\n  float t = 0.0;\n  for (int i = 0; i < 4; i++)\n  {\n    t += a * noise(f * x);\n    f *= 2.0;\n    a *= G;\n  }\n  return t;\n}\n\n//********************\n//* ray intersection *\n//********************\nvec3 calcNormal(in vec3 p, float h)\n{\n  vec3 n = vec3(0.0);\n  for (int i = ZERO; i < 4; i++)\n  {\n    vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n    n += e * map(p + e * h).x;\n  }\n  return normalize(n);\n}\n\nvec2 raycast(in vec3 ro, in vec3 rd)\n{\n  vec2 res = vec2(-1.0);\n\n  vec2 tminmax = iSphere(ro, rd, 300.0);\n  if (tminmax.y > 0.0)\n  {\n    float t = max(tminmax.x, 0.01);\n    for (int i = 0; i < 400 && t < tminmax.y; i++)\n    {\n      vec2 h = map(ro + t * rd);\n      if (h.x < 0.001) { res = vec2(t, h.y); break; }\n      t += h.x;\n    }\n  }\n\n  return res;\n}\n\nvec2 raycastBackground(in vec3 ro, in vec3 rd)\n{\n  vec2 res = vec2(-1.0);\n\n  vec2 tminmax = iSphere(ro, rd, 300.0);\n  if (tminmax.y > 0.0)\n  {\n    float t = max(tminmax.x, 0.001);\n    for (int i = 0; i < 400 && t < tminmax.y; i++)\n    {\n      vec2 h = mapBackground(ro + t * rd);\n      if (h.x < 0.001) { res = vec2(t, h.y); break; }\n      t += h.x;\n    }\n  }\n\n  return res;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd) {\n  const int STEP_SIZE = 30;\n  const float TIME_MAX = 3.0;\n  const float EPSILON = 0.0;\n  const float STEP = TIME_MAX / float(STEP_SIZE);\n  float time = 0.0;\n  for (int i = 0; i < STEP_SIZE; ++i) {\n    vec2 h = map(ro + time * rd);\n    if (h.x > EPSILON) {\n      return time;\n    }\n    time += STEP;\n  }\n  return TIME_MAX;\n}\n\nstruct RayHit {\n  vec2 res;\n  vec3 rd;\n  vec3 color;\n  vec3 albedo;\n  vec3 normal;\n  vec3 pos;\n};\n\nRayHit rayIntersect(in vec3 ro, vec3 rd)\n{\n  vec2 res = raycast(ro, rd);\n  vec3 pos = ro + res.x * rd;\n  if (res.y < 0.1 || res.y > 1.1) {\n    vec3 normal = calcNormal(pos, 0.1);\n    return RayHit(res, rd, vec3(0.0), vec3(1.0), normal, pos);\n  }\n\n  // Letter intersected; process refraction\n  vec3 origNormal = calcNormal(pos, 0.1);\n  float F = fresnel(LETTER_R0, dot(origNormal, -rd));\n  rd = refract(rd, origNormal, 1.0 / LETTER_INDEX);\n  vec3 origRefracted = rd;\n\n  float marchTime = raymarch(pos - origNormal * 0.01, rd);\n  vec3 extPos = pos + marchTime * rd;\n  vec3 extNormal = calcNormal(extPos, 0.05);\n  rd = refractRay(rd, -extNormal, LETTER_INDEX);\n\n  vec3 trans = vec3(exp(-LETTER_BEAM.x * marchTime), exp(-LETTER_BEAM.y * marchTime), exp(-LETTER_BEAM.z * marchTime));\n  vec3 albedo = vec3(0.0);\n  albedo += (1.0 - F) * trans * vec3(1);\n  albedo *= max(dot(origNormal, -origRefracted), 0.0);\n\n  res = raycastBackground(extPos, rd);\n  vec3 backgroundPos = extPos + res.x * rd;\n  vec3 backgroundNormal = calcNormal(backgroundPos, 0.05);\n  return RayHit(res, rd, vec3(F), albedo, backgroundNormal, backgroundPos);\n}\n\n//**************\n//* entrypoint *\n//**************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  //\n  // Camera\n  //\n  const float R = 38.0;\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  if (mouse == vec2(0.0)) {\n    mouse = vec2(0.5, 0.5);\n  }\n  vec2 spr = vec2(0.2 * (mouse.x - 0.5) * M_PI, 0.05 * (mouse.y - 0.5) * M_PI - 0.45 * M_PI);\n  vec3 eye = vec3(-R * sin(spr.x) * sin(spr.y), -R * cos(spr.y), -R * sin(spr.y) * cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n  vec3 look = vec3(0.0, -5.0, 0);\n  mat3 view = viewMatrix(eye, look);\n  vec3 dir = view * rayDirection(45.0, iResolution.xy, fragCoord);\n\n  RayHit gb = rayIntersect(eye, dir);\n  vec3 col = vec3(0.0);\n\n  //\n  // Lighting\n  //\n  if (gb.res.x < 0.01) {\n    col = skyColor(gb.rd);\n  } else {\n    vec3 sunDir = normalize(vec3(-0.3, -1.3, -0.9));\n    vec3 mate;\n    float skyamb = 0.0;\n    float roomamb = 0.0;\n    float ksp = 100.0;\n\n    if (gb.res.y < 2.1) {\n      // mountain\n      float h = noise(gb.pos * 0.1 + noise(gb.pos * 0.3));\n      h = clamp(h, 0.1, 1.0);\n      h *= 0.7;\n      mate = mix(vec3(0.7 * h + 0.2, 0.7 * h + 0.1, 0.7 * h + 0.1), vec3(0.2 * h + 0.3, 0.2 * h + 0.15, 0.2 * h + 0.15), h);\n      skyamb = 1.0;\n      ksp = 100000.0;\n    } else if (gb.res.y < 3.1) {\n      // wood\n      float g = 0.8 + woodfbm(vec3(1.0, 10.0, 5.0) * gb.pos);\n      mate = mix(vec3(0.48, 0.3, 0.09), vec3(0.36, 0.22, 0.06), g);\n      roomamb = 1.0;\n      ksp = 10.0;\n    } else if (gb.res.y < 6.1) {\n      // wall\n      mate = vec3(0.69, 0.68, 0.57);\n      roomamb = 1.0;\n    }\n\n    vec3 linDir = normalize(vec3(sunDir.x, sunDir.y, sunDir.z + 0.3 * smoothstep(50.0, 100.0, length(gb.pos))));\n    float dif = clamp(dot(gb.normal, linDir), 0.0, 1.0);\n    float bak = clamp(dot(gb.normal, normalize(vec3(-linDir.x, linDir.y, -linDir.z))), 0.0, 1.0);\n    float sha = softshadow(gb.pos + gb.normal * 0.1, sunDir, 0.04, 30.0, 400.0);\n    float occ = ao(gb.pos + gb.normal * 0.01, gb.normal);\n    float indw = smoothstep(4.0, -2.0, gb.pos.z) * smoothstep(-5.0, 5.0, gb.pos.x);\n    float ind2mask = smoothstep(1.9, 1.91, gb.pos.z) * dot(gb.normal, vec3(0, 0, 1));\n    indw += 5.0 / exp(0.16 * length(gb.pos.xy-1.5*noise2(0.3*gb.pos.xy) - vec2(3.0, -5.0))) * smoothstep(-5.0, 5.0, gb.pos.x) * ind2mask;\n    indw += 5.0 / length(gb.pos.xy - vec2(0.0, -5.0)) * smoothstep(5.0, -5.0, gb.pos.x) * ind2mask;\n    dif = clamp(dif * sha, 0.0, 1.0);\n    col += 5.0 * dif * vec3(0.99, 0.54, 0.24);\n    col += 0.3 * skyamb * bak * vec3(0.11, 0.24, 0.35) * occ;\n    col += 0.3 * skyamb * vec3(0.11, 0.24, 0.35) * occ;\n    col += 0.3 * roomamb * vec3(0.44, 0.38, 0.13) * (0.5 * occ + 0.5);\n    col += 1.0 * roomamb * indw * vec3(0.51, 0.51, 0.44) * (0.5 + 0.5 * occ);\n    col *= mate;\n\n    vec3 hal = normalize(linDir - gb.rd);\n    float spe = pow(clamp(dot(gb.normal, hal), 0.0, 1.0), ksp) * sha * (0.5 + 0.5 * occ);\n    float d = length(gb.pos - eye);\n    col += vec3(0.8) * spe;\n    col = applyFog(col, smoothstep(80.0, 100.0, d) * d, eye, gb.rd);\n    col = gb.albedo * col + gb.color;\n  }\n\n  col = pow(col, vec3(1.0 / 2.2));\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}