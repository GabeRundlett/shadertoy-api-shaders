{
    "Shader": {
        "info": {
            "date": "1552089591",
            "description": "Solice, redone.  Original credit goes to someone else, I tweaked it heavily, though.  Make sure to comment additional features ,tips, or suggestions! Also, AA is not working 4 dome (PS, wiggle for stereography, can turn it off by #define WIGGLE 0, ln 18)",
            "flags": 32,
            "hasliked": 0,
            "id": "tdsXRl",
            "likes": 2,
            "name": "Solice",
            "published": 3,
            "tags": [
                "solice"
            ],
            "usePreview": 0,
            "username": "ShadowFlare",
            "viewed": 519
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n\nI tried to do lots of different lighting features with this. It has ambient occlusion.\nI did a traced shadow for sky light, but it took too much code space, so I faked it. (#define)\nThere is bounced light from where the sun rays hit.\nThere is light from the stained glass dome.\nThere are glowy rays and god rays.\nI kept running into code size limits on this one. I probably would have gone forever\nif it wasn't for those damn \"unknown error\" things when the code gets too big.\nI tried to do refraction in the crystal, but hit code size limits.\n-Otavio Good\n*/\n#define MANUAL_CAMERA 1\n#define TRACED_SKY_SHADOWS 1\n#define WIGGLE 0\n \t\n\nfloat PI=3.14159265;\nvec3 sunColOrig = vec3(255.0, 208.0, 100.0) / 255.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901);\nvec3 environmentGroundColor = vec3(0.4001, 0.25, 0.1) * 0.25;\n\nfloat sparkle = 1.0;\nfloat sinking;\nfloat marchingMultplier = 1.0;\nfloat glowDist;\nfloat globalRadial;\nfloat shadow;\nfloat localTime;\nvec3 sunCol;\nfloat rotateGem;\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nfloat material;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat SmoothMix(float a, float b, float x)\n{\n\tfloat t = x*x*(3.0 - 2.0*x);\n\treturn mix(a, b, t);\n}\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n\t//else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\t//else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// makes a thick line and passes back gray in x and derivates for lighting in yz\nvec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv)\n{\n\tvec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = normalize(dir);\n\tfloat dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\tfloat d1 = distance(uv, proj);\n\tvec2 derivative = (uv - proj);\n\n\tfloat finalGray = saturate(1.0 - d1 * radiusInv);\n\t// multiply derivative by gray so it smoothly fades out at the edges.\n\treturn vec3(finalGray, derivative * finalGray);\n}\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\n// passes back gray in x and derivates for lighting in yz\nvec3 Rune(vec2 uv, vec2 seed)\n{\n\tvec3 finalLine = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n\t\t// generate seeded random line endPoints - just about any texture should work.\n\t\t// Hopefully this randomness will work the same on all GPUs (had some trouble with that)\n\t\tvec2 posA = texture(iChannel1, floor(seed+0.5) / iChannelResolution[1].xy).xy;\n\t\tvec2 posB = texture(iChannel1, floor(seed+1.5) / iChannelResolution[1].xy).xy;\n\t\tseed += 2.0;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) posA.y = 0.0;\n\t\tif (i == 1) posA.x = 0.999;\n\t\tif (i == 2) posA.x = 0.0;\n\t\tif (i == 3) posA.y = 0.999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec2 snaps = vec2(2.0, 3.0);\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\t// + 0.5 to center it in a grid cell\n\t\tposB = (floor(posB * snaps) + 0.5) / snaps;\n\t\t//if (distance(posA, posB) < 0.0001) continue;\t// eliminate dots.\n\n\t\t// Dots (degenerate lines) are not cross-GPU safe without adding 0.001 - divide by 0 error.\n\t\tvec3 tl = ThickLine(uv, posA, posB + 0.001, 10.0);\n\t\tif (tl.x > finalLine.x) finalLine = tl;\n\t}\n\treturn finalLine.xyz;\n}\n\n// k should be negative. -4.0 works nicely.\nfloat smin(float a, float b, float k)\n{\n\t// I'm guessing that base 2 operations are the fastest.\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = max(0.0, 0.01 / sunIntensity - 0.025);\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tvec3 ground = mix(environmentGroundColor, environmentSphereColor,\n\t\t\t\t\t  pow(abs(localRay.y), 0.35)*sign(localRay.y) * 0.5 + 0.5);\n\treturn ground + sunCol * sunIntensity;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n\treturn length(p) - rad;\n}\n\nfloat dBox(vec3 pos, vec3 b)\n{\n\treturn length(max(abs(pos)-(b),0.0));\n}\n\nfloat dBoxSlant(vec3 p, vec3 b)\n{\n\tfloat size = b.x;\n\tfloat f = length(max(abs(p)-(b),0.0));\n\t//float f = length(max(abs(p.x)+abs(p.z)-(b),0.0));\n\t//f = max(f, p.y*0.5 + abs(p.x) + abs(p.z) - size * 0.995);\n\treturn f;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat dBoxSigned(vec3 p)\n{\n\tfloat b = 1.0;\n\tvec3 b2 = vec3(6.0, 2.0, 2.0);\n\tvec3 center = vec3(0, -2.0, 0.0);\n\tvec3 d = abs(p - center) - b2;//*abs(cos(p.y + 0.5));\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dFloor(vec3 p)\n{\n\treturn p.y + 1.0;\n}\n\nfloat sdColumn( vec3 p, vec3 c )\n{\n\tfloat cyl = length(p.xz-c.xy)-c.z;// + abs(p.y);\n\tcyl -= cos(p.y*2.0)*0.045;\n\tfloat a = atan(p.x - c.x, p.z - c.y);\n\ta /= 2.0*PI;\n\tfloat subs = 48.0;\n\ta *= subs;\n\t//cyl *= pow(sin(a), 0.5) * 0.925 + 1.0;\n\tcyl += abs(sin(a)) * 0.015;\n\n\tcyl = max(cyl, p.y - 2.4);\n\tcyl = min(cyl, dBox(p + vec3(0.0, 1.0, 0.0), vec3(0.3, 0.2, 0.3)));\n\tcyl = smin(cyl, dBoxSlant(RotateY(p, PI/4.0) + vec3(0.0, -2.3, 0.0), vec3(0.3, 0.15, 0.3)), -24.0);\n\t//cyl = min(cyl, dBox(RotateY(p, PI/4.0) + vec3(0.0, -2.3, 0.0), vec3(0.3, 0.15, 0.3)));\n\treturn cyl;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat length16(vec2 v)\n{\n\treturn pow(pow(abs(v.x),16.0) + pow(abs(v.y), 16.0), 1.0/16.0);\n\t//return pow((pow(v.x,16.0) + pow(v.y, 16.0)), (1.0/16.0));\n}\nfloat sdTorusBricks( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = globalRadial;// + PI/6.0;// atan(p.x, p.z);\n\ta = pow(abs(sin(a*subs)), 0.25);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.2 + 0.8;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length16(q)-t.y*a;\n}\nfloat sdTorusArch( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = atan(p.y, p.z);\n\ta = pow(abs(sin(a*subs)), 0.25);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.25 + 0.75;\n\tp.y -= cos(p.y)*0.4;\n\tvec2 q = vec2(length(p.yz)-t.x,p.x);\n\treturn length16(q)-t.y*a;\n}\n\nfloat sdPedestal( vec3 p, vec2 h )\n{\n\tp.y += 0.5 + sinking*0.2;\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.z+q.x*0.57735,q.x*1.1547)-(h.x*(2.35 - p.y)));\n}\n\nfloat matMin(float a, float b, float matNum)\n{\n\tif (a < b)\n\t{\n\t\t//material = 0.0;\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\tmaterial = matNum;\n\t\treturn b;\n\t}\n}\n\n// This makes the stained glass windows in the dome.\nfloat dTiles(vec3 p)\n{\n\tfloat subs = 16.0;\n\tfloat final = length(p) - 2.2;\n\tfloat a = globalRadial;// atan(p.x, p.z);\n\ta /= 2.0*PI;\n\ta *= subs;\n\ta = abs((fract(a) - 0.5))*2.0;\t// triangle wave from 0.0 to 1.0\n\ta -= 0.15;\n\ta *= 6.0;\n\ta = max(0.0, a);\n\ta = min(0.75, a);\n\n\tfloat b = atan(length(p.xz), p.y);\n\tb /= 2.0*PI;\n\tb *= subs;\n\tb = abs((fract(b) - 0.5))*2.0;\t// triangle wave from 0.0 to 1.0\n\tb -= 0.15;\n\tb *= 6.0;\n\tb = max(0.0, b);\n\tb = min(0.75, b);\n\t\n\ta = a*b;\n\n\ta = a *0.2 + 0.8;\n\tb = b *0.2 + 0.8;\n\t\n\tfinal = final - a;\n\tfinal = max(final, 0.5-p.y);\n\tfinal = min(final, length(p.xz) - 0.5);\t// oculus - cylinder in middle\n\treturn final/1.414;\n}\n\nfloat GemCut(vec3 p)\n{\n\tfloat size = 0.5;\n\tfloat f = length(p) - size;\n\tif (f <= 1.0)\n\t{\n\t\tmarchingMultplier = 0.65;\n\t\tf = max(f, p.y - size * 0.25);\n\t\t\n\t\tf = max(f, p.y + max(abs(p.x), abs(p.z)) - size * 0.7);\n\t\t\n\t\tf = max(f, -p.y + max(abs(p.x), abs(p.z)) - size * 0.6);\n\t\t//f = max(f, -p.y + p.x - size * 0.6);\n\t\t//f = max(f, -p.y - p.x - size * 0.6);\n\t\t//f = max(f, -p.y + p.z - size * 0.6);\n\t\t//f = max(f, -p.y - p.z - size * 0.6);\n\n\t\tf = max(f, p.y + abs(p.x) + abs(p.z) - size * 0.95);\n\t\t//f = max(f, p.y + p.x + p.z - size * 0.95);\n\t\t//f = max(f, p.y - p.x + p.z - size * 0.95);\n\t\t//f = max(f, p.y - p.x - p.z - size * 0.95);\n\t\t//f = max(f, p.y + p.x - p.z - size * 0.95);\n\n\t\tf = max(f, -p.y + abs(p.x) + abs(p.z) - size * 0.85);\n\t\t//f = max(f, -p.y + p.x + p.z - size * 0.85);\n\t\t//f = max(f, -p.y - p.x + p.z - size * 0.85);\n\t\t//f = max(f, -p.y - p.x - p.z - size * 0.85);\n\t\t//f = max(f, -p.y + p.x - p.z - size * 0.85);\n\t} else marchingMultplier = 1.0;\n\treturn f;\n}\n\nfloat GenSwirl(vec3 p, float anim)\n{\n\tvec2 spin = vec2(sin(p.y*1.75-anim), cos(p.y*1.75 - anim));\n\tfloat swirl = length(p.xz + spin*0.2) - 0.05;\n\tswirl = max(swirl, p.y - 5.25);\n\tswirl = max(swirl, p.y - fract(anim)*10.0 + 2.0);\n\tswirl = max(swirl, -(p.y - fract(anim)*10.0 + 5.0));\n\treturn swirl;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tglobalRadial = atan(p.x, p.z);\n\t// set up repeating spaces for pillars and arches\n\tvec3 c = vec3(1.0, 1.0, 1.0)* 4.0;\n\tfloat c2 = 5.2;\n\tvec3 q = mod(p,c)-0.5*c;\n\tfloat q2 = mod(p.x,c2)-0.5*c2;\n\tvec3 p2 = vec3(q.x, p.y, q.z);\n\tvec3 p3 = vec3(q2, p.y, p.z);\n\n\tfloat final = -sdCapsule(p, vec3(0.0,-0.5,0.0), vec3(0.0,2.25,0.0), 3.0);\n\t// This if condition is for a culling speedup and a cool bevel effect on the ceiling tiles.\n\tif (final < 0.01) final = max(final, -dTiles(p + vec3(0.0, -2.25, 0.0)));\n\tfinal = min(final, sdTorusBricks(p, vec2(2.75, 0.25), vec3(0.0, -0.795, 0.0), 12.0));\n\tfinal = max(final, -sdCapsule(p, vec3(-6.0,0.0,0.0), vec3(6.0,0.0,0.0), 2.0));\n\t//final = max(final, -sdCapsule(p, vec3(0.0,0.0,-16.0), vec3(0.0,0.0,16.0), 2.0));\n\tfinal = max(final, -dBoxSigned(p));\n\t//final = max(final, -sdCapsule(p, vec3(0.0,0.0,0.0), vec3(0.0,5.5,0.0), 0.5));//oculus\n\tfinal = max(final, p.y - 5.3);\t// open the sky\n\t//final = max(final, sdCapsule(p, vec3(0.0,-0.5,0.0), vec3(0.0,0.5,0.0), 3.05));\n\t//final = max(final, -dSphere(p2, 0.08));\n\tfinal = min(final, sdColumn(p2, vec3(0.0, 0.0, 0.25)));\n\t//final = max(final, -sdBox(p - vec3(0.0,0.5,0.0), vec3(0.5, 1.0, 3.5)));\n\n\tfinal = min(final, sdTorusBricks(p, vec2(2.75, 0.25), vec3(0.0, 2.7, 0.0), 8.0));\n\tfinal = min(final, sdTorusBricks(p, vec2(0.75, 0.25), vec3(0.0, -1.0, 0.0), 3.0));\n\t\n    //Exit Arch\n    final = min(final, sdTorusArch(p3, vec2(2.125, 0.3), vec3(0.0, 0.1, 0.0), 12.0));\n\t//final = min(final, sdTorusArch(p, vec2(2.125, 0.3), vec3(2.6, -0.1, 0.0), 6.0));\n\t//final = min(final, sdTorusArch(p, vec2(2.125, 0.3), vec3(-2.6, -0.1, 0.0), 6.0));\n\t\n    //Bottom Floor\n    final = min(final, dFloor(p));\n\tmaterial = 0.0;\n\n\t// rotate the gem and light rays.\n\tvec3 pr = RotateY(p, rotateGem);\n\t// mirror light rays in each axis.\n\tif (pr.x < 0.0) pr.xz = -pr.xz;\n\tvec3 pr2 = pr;\n\tif (pr2.z < 0.0) pr2.xz = -pr2.xz;\n\t// glow rays\n\tif ((sparkle > 0.0) && (shadow != 1000000.0))\n\t{\n\t\tvec2 dir = vec2(1.0, 0.0);\n\t\tfloat rad = 0.04*max(0.0, sparkle - 0.2);\n\t\tfloat tempGlow = sdCapsule(pr, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t\t\t\t\t\t   vec3(dir.x*3.0, 1.8 + sparkle, dir.y*3.0), rad)+saturate(0.6-sparkle);\n\t\tdir = vec2(0.0, 1.0);\n\t\ttempGlow = min(tempGlow, sdCapsule(pr2, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t\t\t\t\t\t   vec3(dir.x*3.0, 1.8 + sparkle, dir.y*3.0), rad)+saturate(0.25-sparkle) );\n\t\t//dir = vec2(-1.0, 0.0);\n\t\t//tempGlow = min(tempGlow, sdCapsule(pr, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t//\t\t\t\t\t   vec3(dir.x*2.65, 1.7 + sparkle, dir.y*2.65), rad)+saturate(0.8-sparkle));\n\t\t//dir = vec2(0.0, -1.0);\n\t\t//tempGlow = min(tempGlow, sdCapsule(pr, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t//\t\t\t\t\t   vec3(dir.x*2.65, 1.7 + sparkle, dir.y*2.65), rad));\n\t\t//float len = length(p.xz)*0.5+0.5;\n\t\t//tempGlow = min(tempGlow, sdCapsule(pr, vec3(0.0, 1.0 + sparkle, 0.0),\n\t\t//\t\t\t\t\t   vec3(0.0, -12.7, 0.0), rad*2.0)+saturate(0.25-sparkle) );\n\t\t// vertical glow from the pedestal to the crystal. capped cylinder.\n\t\ttempGlow = min(tempGlow, max(length(p.xz) - rad*2.0, p.y - 0.6 - sparkle));\n\t\tglowDist += 1.5*sparkle / max(0.1, tempGlow*tempGlow);\n\t\tfinal = matMin(final, tempGlow, 3.0);\n\t}\n\tfloat spirits = max(0.0, sinking - 7.0);\n\tfloat tempGlow2 = length(p.xyz - vec3(0.0,-0.95,0.0)) - 0.015 - pow(spirits, 1.5)*0.1;\n\tif ((spirits > 0.0) && (shadow != 1000000.0))\n\t{\n\t\tfloat anim = spirits - 2.0;\n\t\tfloat swirl = GenSwirl(p, anim);\n\t\tswirl = min(swirl, GenSwirl(p, anim+1.4));\n\t\tswirl = min(swirl, GenSwirl(p, anim+2.8));\n\t\tswirl = min(swirl, GenSwirl(p, anim+4.6));\n\t\tswirl = max(swirl, p.y-anim*3.0);\n\t\ttempGlow2 = smin(tempGlow2, swirl, -4.0);\n\t\tfinal = matMin(final, swirl, 3.0);\n\n\t\tglowDist += 1.5*sinking*0.1 / max(0.1, tempGlow2 * tempGlow2);\n\t\tglowDist *= min(1.0, spirits);\n\t\tfinal = matMin(final, tempGlow2, 3.0);\n\t}\n\n\tfinal = matMin(final, sdPedestal(p, vec2(0.25, 1.0)), 2.0);\t// pedestal\n\n\tfinal = matMin(final, GemCut(pr - vec3(0, 0.8 + sparkle - sinking*0.2, 0)), 1.0);\t// Gem\n\n\treturn final;\n}\nvec4 tex3d2(sampler2D samp, vec3 pos, vec3 normal) {\n \tvec4 texX = texture(samp, pos.yz);\n\tvec4 texY = texture(samp, pos.xz);\n\tvec4 texZ = texture(samp, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;   \n}\nconst vec2 e = vec2(0.002, 0);\nvec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf, in int channelID) \n{\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3d2(tx, p - e.xyy, n).rgb, tex3d2(tx, p - e.yxy, n).rgb, tex3d2(tx, p - e.yyx, n).rgb);\n\n    // Converting to greyscale.\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(tex3d2(tx, p, n).rgb, vec3(0.299, 0.587, 0.114))) / e.x; g -= n*dot(n, g);\n\n    // Bumped normal. \"bf\" - bump factor.\n    return normalize(n + g * bf); \n}\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t// loook up brick texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel0, pos.yz);\n\tvec4 texY = texture(iChannel0, pos.xz);\n\tvec4 texZ = texture(iChannel0, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\nvec3 calcNormal( in vec3 pos ) // for function f(p)\n{\n    float dist = DistanceToObject(pos);\n    vec3 smallVec = vec3(0.005, 0, 0);\n\tvec3 dx = pos - smallVec.xyy;\n\tvec3 dy = pos - smallVec.yxy;\n\tvec3 dz = pos - smallVec.yyx;\n\tvec3 normal = vec3(dist - DistanceToObject(dx),\n\t\t\t\t\t   dist - DistanceToObject(dy),\n\t\t\t\t\t   dist - DistanceToObject(dz));\n\treturn normalize(normal);\n}\n\nvec3 orientate(vec3 vecA, vec3 vecB)\n{\n    \n    vec3 axis = normalize(cross(vecA, vecB));\n    float angle = dot(vecA, vecB);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\tmat4 rmat =  mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n\n    return vecA*mat3(rmat);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = DistanceToObject( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = DistanceToObject( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\nvec3 toSphere(vec3 point, vec3 sphereCenter, vec3 rad) {\n \tvec3 p = point-sphereCenter;\n    p = (rad/length(p))*p;\n    return p+sphereCenter;\n}\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float dist\n             ){\n    float b = 0.001;\n    float fogAmount = 1.0 - exp( -dist*b );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float dist, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = 0.2;\n    float fogAmount = 0.001 * exp(-rayOri.y*b) * (1.0-exp( -dist*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n//vec3 calcRefract (in vec3 pos, in vec3\nbool castRay(vec3 ro, vec3 rd, float resT, inout vec4 intersectInfo, out vec3 interNorm)\n{\n    float dt = 0.01f;\n    const float mint = 0.001f;\n    const float maxt = 10.0f;\n    float lh = 0.0f;\n    float ly = 0.0f;\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3  p = ro + rd*t;\n        float h = DistanceToObject(p);\n        if( p.y < h )\n        {\n            // interpolate the intersection distance\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            intersectInfo.a = resT;\n            intersectInfo.rgb = p;\n            interNorm = calcNormal(p);\n            return true;\n        }\n        // allow the error to be proportinal to the distance\n        dt = 0.01f*t;\n        lh = h;\n        ly = p.y;\n    }\n    return false;\n}\nvec3 castRay(vec3 ro, vec3 rd, float resT)\n{\n    float dt = 0.1f;\n    const float mint = 0.2f;\n    const float maxt = 40.0f;\n    float lh = 0.0f;\n    float ly = 0.0f;\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3  p = ro + rd*t;\n        float h = DistanceToObject(p);\n        if(floor(h*10.0)/10.0 == 0.0)\n        {\n            // interpolate the intersection distance\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            return p;\n        }\n        // allow the error to be proportinal to the distance\n        dt = 0.01f*t;\n        lh = h;\n        ly = p.y;\n    }\n    return vec3(1e10);\n}\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n\tlocalTime = fract((iTime)/54.0)*54.0;//mod(iTime+30.0, 55.0);\t// repeat anim after this many seconds.\n\tsinking = localTime - 30.0;//clamp(localTime - 30.0, 0.0, 16.5);\t// start and end the sinking of the pedestal\n\tif (sinking < 0.0) sinking = 0.0;// mac/chrome/nvidia bug didn't let me use max. :(\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\tvec3 shake = texture(iChannel3, vec2(localTime * 1.372, 0.0)).xyz*0.04 * saturate(sinking);\n\t// Camera lookat.\n#if MANUAL_CAMERA\n\tvec3 camLookat=vec3(0,1.0,0);\t// vrp\n\tvec3 camPos=vec3(2.7, 2.7, 2.7);\n\n\tif (localTime < 5.0)\n\t{\n\t\t//camLookat.y = mix(3.0, 1.0, saturate(localTime*0.2));\n\t\t//camPos.x = smoothstep(0.0, 2.75, saturate(localTime*0.2));\n\t}\n\t//camLookat.x *= smoothstep(-1.0, 1.0, cos(localTime));\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n    #if WIGGLE\n    mx *= 0.99+(cos(localTime*40.0)/200.0);\n    #endif\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*camPos; \t// prp\n    //camPos.x *= smoothstep(-1.0, 1.0, cos(localTime));\n#else\n\tvec3 camLookat=vec3(0,1.0,0);\t// vrp\n\tvec3 camPos=vec3(0.0, 0.0, 0.0);\n\tfloat firstTimer = saturate(localTime * 0.09);\n\tcamPos.x = SmoothMix(-3.5, 2.6, firstTimer);\n\tcamPos.z = pow(abs(sin(firstTimer*PI)), 3.0)*2.0;\n\tcamPos.z -= firstTimer;\n\n#endif\n\n\tcamLookat += shake;\n\tcamPos += shake;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// -------------------------- Animate some things -----------------------------\n\tfloat sunSpeed = 0.045;\n\tvec3 sunDir;// = normalize(vec3(sin(iTime*sunSpeed), -3.0, sin(iTime*sunSpeed)));\n\tsunDir = normalize(vec3(localTime*sunSpeed - 0.95, -3.0, localTime*sunSpeed - 0.95));\n\t//sparkle = saturate((1.0 - abs(sin(iTime*sunSpeed))) - 0.8) * 5.0;\n\tsparkle = min(1.0, saturate(-sunDir.y - 0.988) * 200.0);\n\tsparkle = smoothstep(0.0, 1.0, sparkle);\n\tfloat sparkleLasting = max(sparkle, saturate(localTime - 20.0));\n\tglowDist = 0.0;\n\tsunCol = min(sunColOrig, (sunColOrig * 0.00025)*pow(2.5, localTime));\n\trotateGem = SmoothMix(0.0, 3.0*PI, saturate((localTime - 14.0)/15.0));\n\n\t// ------------------------------ Ray march -----------------------------------\n\tfloat dist = 0.02;\n\tfloat t = 0.1;\n\tfloat maxDepth = 40.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n\tfor (int i = 0; i < 120; i++)\n\t{\n\t\tif ((t > maxDepth) || (abs(dist) < 0.001))\n\t\t{\n\t\t\tbreak;\t// break doesn't work on some machines\n\t\t\tcontinue;\t// so do a continue for those\n\t\t}\n\t\tpos = camPos + relVec * t;\n\t\tdist = DistanceToObject(pos);\n\t\tt += dist * marchingMultplier;\t// because deformations mess up distance function.\n\t}\n\tfloat finalMaterial = material;\n\tmarchingMultplier = 1.0;\n\n\t// ----------------------------------------------------------------------------\n\n\t// oculus is the word for the hole in the roof of the dome.\n\tvec3 oculus = vec3(0.0, 5.3, 0.0);\n\tvec3 floorHit = (oculus) + sunDir * 6.3 / abs(sunDir.y);\n\n\tvec3 cr = normalize(cross(-sunDir, relVec));\n\tfloat d1 = dot(oculus, cr);\n\tfloat d2 = dot(pos, cr);\n\tfloat haze = pow(saturate(1.0 - abs(d1 - d2) * 2.0), 0.6);\n\n\tvec3 finalColor = vec3(1.0,1.0,1.0);// GetSunColorReflection(relVec, -sunDir) + vec3(0.1, 0.1, 0.1);\n\n\t// calculate normal from distance field\n\tvec3 normal = calcNormal(pos);\n\t\n\t// -------------------------- Shadow trace to oculus --------------------------\n\tfloat origGlowDist = glowDist;\n\tshadow = 1000000.0;\n\t//for (int i = 1; i < 8; i++)\n\t//{\n\t//\tvec3 midPos = mix(pos, oculus, float(i) / 64.0);\n\t//\tfloat shadow0 = max(0.0, DistanceToObject(midPos));\n\t//\tshadow = min(shadow, shadow0);\n\t//}\n#if TRACED_SKY_SHADOWS\n\tfloat dist2 = 0.02;\n\tfloat t2 = 0.1;\n\tfloat maxDepth2 = 40.0;\n\tvec3 pos2 = vec3(0,0,0);\n\t// ray marching time\n\tfloat mCount = 0.0;\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\tif ((t2 > maxDepth2) || (abs(dist2) < 0.001)) continue;\t// break DOESN'T WORK!!! ARRRGGG!\n\t\tpos2 = (pos + normal*0.02) + normalize(oculus - pos) * t2;\n\t\tdist2 = DistanceToObject(pos2);\n\t\tt2 += dist2 * marchingMultplier;\t// because deformations mess up distance function.\n\t\tmCount++;\n\t}\n    \n\tif (dist2 < 0.01) shadow = 0.0;\n\t//shadow = calcShadow(pos2, oculus, 0.01, 3.0, 1);\n\tshadow = saturate(shadow * 300.9);\n    //shadow = calcShadow(pos2, oculus, 0.01, 3.0, 1);\n#else\n\t// fake the shadows\n\tfloat xzDist = length(pos.xz);\n\tshadow = (abs(xzDist - 3.0))*5.0;\n\tshadow += pow(saturate(-(pos.y - 2.5)), 3.0);\n\tshadow += saturate((pos.y - 2.5)*8.0);\n\tshadow *= 1.0 - saturate(xzDist - 2.995);\n\t//shadow = calcShadow(pos2, oculus, 0.01, 3.0, 1);\n    shadow = saturate(shadow);\n\n#endif\n\n//\tfloat shadow0 = max(0.0, DistanceToObject(mix(oculus, pos, 0.333)));\n//\tfloat shadow1 = max(0.0, DistanceToObject(mix(oculus, pos, 0.666)));\n//\tshadow0 = min(shadow0, shadow1);\n\tglowDist = origGlowDist;\n\t// ----------------------------------------------------------------------------\n\n\t// calculate ambient occlusion with 2 extra distance field queries\n\t/*float ambient = DistanceToObject(pos + normal * 1.0)*0.5;\n\tambient += DistanceToObject(pos + normal * 0.1)*5.0;\n\tambient = max(0.1, pow(abs(ambient), 0.5));\t// tone down ambient with a pow and min clamp it.\n\t*/\n\tfloat ambient = calcAO(pos, normal)*0.25;\n    //ambient = max(0.1, pow(abs(ambient), 0.5));\n    ambient += calcAO(pos,  normal * 0.1)*2.5;\n    ambient = max(0.1, pow(abs(ambient), 0.5));\n\tvec3 tempPos = pos;\n\tif (finalMaterial == 2.0) tempPos.y = pos.y + sinking*0.2;\n\t// look up brick texture, blended across xyz axis based on normal.\n\tvec4 tex = tex3d(tempPos*0.75, normal);\n\t//tex = tex * tex;\t// gamma correct\n\ttex.xyz = pow(tex.xyz, vec3(1.35,1.35,1.35));\t// gamma correct sorta\n\n\t// weathering texture\n\tvec3 texSpots = texture(iChannel3, pos.xz*0.085* (1.0 + pos.y*0.02)).xyz;\n\ttexSpots = saturate(texSpots * 4.0 - 0.75);\n\t//if (pos.y < -0.999)\n\ttexSpots.y = min(1.0-abs(normal.y*0.75), texSpots.y);\t// only for vertical surfaces\n\ttex.xyz = mix(tex.xyz, vec3(0.3, 0.24, 0.25)*1.25-tex.xzy*0.45, texSpots.y);\n\t//tex.xyz = vec3(0.75, 0.75, 0.75);\n\n\t// Make the rune ring texture around the top ledge\n\tfloat radial = atan(pos.x, pos.z);\n\tradial /= 2.0*PI;\n\tvec2 runeUV = vec2(radial * 16.0, pos.y + 0.14) * 3.0;\n\tif (finalMaterial == 2.0)\n\t{\n\t\truneUV = vec2(radial * 4.0, pos.y + 0.395 + sinking*0.2) * 9.0;\n\t}\n\tvec2 runeSeed = floor(runeUV)*vec2(1.0, 6.0);\n\truneUV = fract(runeUV) + (tex.xy - 0.4)*0.25;\n\n\t// closing credit text\n\tif (localTime > 46.5)\n\t{\n\t\tfloat fu = floor((uv.x*0.5+0.5)*8.0);\n\t\tvec2 seed = vec2(15.0, 2.0);\n\t\tif (fu == 1.0) seed = vec2(-5,-5);\n\t\tif (fu == 2.0) seed = vec2(34,4);\n\t\tif (fu == 4.0) seed = vec2(19,5);\n\t\tif (fu == 5.0) seed = vec2(51,4);\n\t\tif (fu == 6.0) seed = vec2(66,-2);\n\t\tif (fu == 7.0) seed = vec2(-8,6);\n\t\tvec2 shift = uv + vec2(0.0, 0.125);\n\t\truneUV = fract(shift*4.0);\n\t\truneSeed = seed;\n\t}\n\n\t// Generate a rune based on a random seed.\n\t// GLSL unrolls function calls, so try really hard to only call this once. :(\n\tvec3 runeCol = Rune(runeUV, runeSeed);\n\t// If it is the base of the dome, do the runes for that.\n\tif (floor((pos.y + 0.14)*3.0) == 8.0)\n\t{\n\t\ttex.xyz *= (1.0 - pow(runeCol.x, 0.95)*0.65);\n\t\tnormal.y -= runeCol.z*100.0;\n        normal = doBumpMap(iChannel0, abs(pos), abs(normal), .025, 0);\n\t}\n\telse\n\t{\n\t\tif ((finalMaterial != 2.0) && (localTime <= 46.5)) runeCol = vec3(0.0, 0.0, 0.0);\n\t}\n\n\t// materials\n\t//normal.y += (tex.z - 0.23)*2.0;\t// fake bump map\n\tnormal = normalize(normal);\n\tvec3 ref = reflect(relVec, normal);\n\n\t// Gem material\n\tif (finalMaterial == 1.0)\n\t{\n\t\t// vec3 refraction = normalize(mix(-ref, relVec, 0.5));\n        normal = doBumpMap(iChannel1, abs(pos), abs(normal), .025, 1);\n\t\ttex.xyz = pow(texture(iChannel2, ref).xyz, vec3(2.0,2.0,2.0)) * vec3(0.9, 0.1, 0.5);\n\t\t//tex.xyz += pow(texture(iChannel2, ref).xyz, vec3(2.0,2.0,2.0)) * vec3(0.9, 0.1, 0.5);\n\t}\n\t// pedestal material\n\telse if (finalMaterial == 2.0)\n\t{\n\t\t//float radial = atan(pos.x, pos.z);\n\t\t//radial /= 2.0*PI;\n\t\t//runeUV = vec2(radial * 4.0, pos.y + 0.405 + sinking*0.2) * 9.0;\n\t\t//runeCol = vec3(0.0, 0.0, 0.0);\n\t\tif (abs(normal.y) < 0.99)\n\t\t{\n//\t\t\truneCol = Rune(fract(runeUV) + (tex.xy - 0.4)*0.25, floor(runeUV)*vec2(1.0, 6.0));\n\t\t\t//runeCol.x = pow(runeCol.x, 2.0);\n\t\t\ttex.xyz *= (1.0 - pow(runeCol.x, 0.55)*0.85);// * (1.0+saturate(-runeCol.z)*18.0);\n\t\t\t//tex.xyz *= saturate(1.0 - vec3(0.997, 0.92, 0.997)*runeCol.x*0.8);//*0.3;\n\t\t\tnormal.y -= runeCol.z*52.0;\n\t\t\t\n            normal = doBumpMap(iChannel0, abs(pos), abs(normal), .025, 0);\n            normal = normalize(normal);\n\t\t\ttex.xyz += sunCol*4.0*runeCol.x * max(0.0,sparkleLasting-0.6)*2.0;\n            \n\t\t}\n\t}\n\t// glow ray material\n\telse if (finalMaterial == 3.0)\n\t{\n\t\ttex.xyz = sunCol*8.0;\n\t}\n\n\t// try to fake stained glass windows on the interior of the dome.\n\tfloat domeAlpha = 0.0;\n\tif (pos.y > 2.95)\n\t{\n\t\tdomeAlpha = length(pos - vec3(0.0, 2.25, 0.0)) - 3.05;\n\t\tdomeAlpha *= 12.0;\n\t\tdomeAlpha = saturate(domeAlpha);\n\t\t//tex *= alpha;// mix(tex, tex*texture(iChannel1, pos.xz*0.75).xxxw, 0.5);\n        vec3 spherePos = 0.5+(0.5*normalize(pos));//toSphere(pos, vec3(0.25, 2.895, 0.0), vec3(1.0, 2.25, 0.0025));\n\t\tvec3 t2 = texture(iChannel1, pos.xz*0.75).yzx;\n\t\tvec3 t3 = texture(iChannel1, pos.xz*0.5).yzz;\n\t\tt2 = t2*t2;\n\t\tt3 = t3*t3;\n\t\tt2 = saturate(t2*1.0 - 0.05) * (texture(iChannel1, pos.xz).rgb*10.0);\n\t\tt3 = saturate(t3*1.5 - 0.05) * vec3(0.0,2.0,2.0);\n\t\ttex.xyz = mix(tex.xyz, (t2 + t3), domeAlpha);\n        normal = doBumpMap(iChannel1, abs(pos), abs(normal), .025, 1);\n\t}\n   \n   \t\n\t// glowing hole in the ground\n\tif (pos.y < -0.99)\n\t{\n\t\tif (length(pos.xz) < 0.5) tex.xyz = sunCol*1.5;\n\t}\n\t//tex.xyz = vec3(0.75, 0.75, 0.75);\n\n\t// if ray marching found an intersection, then calculate lighting and stuff\n\tif (t <= maxDepth)\n\t{\n        \n\t\tvec3 lightDir = pos - oculus;\n        vec3 nld = normalize(lightDir);\n        //float shadow = calcShadow(pos, oculus, 0.01, 8.0, 0);\n        //shadow *= 100.0;\n\t\tfloat lenLightDir = length(lightDir);\n\t\tfloat skyMult = max(0.0, -lightDir.y) * max(0.0, dot(lightDir, -normal));\n\t\tskyMult *= 0.55 / (lenLightDir*lenLightDir);\n\t\tvec3 envLight = environmentSphereColor;// * skyMult;// + environmentGroundColor * (normal.y * 0.5 + 0.5);\n\t\t//vec3 envLight = mix(environmentGroundColor, environmentSphereColor, (normal.y * 0.5 + 0.5)) * 0.9;\n\t\t\n        //vec3 domeLight = texture(iChannel1, pos.xz).rgb * (normal.y * 0.5 + 0.5) * min(ambient, shadow) * 0.15;\n\t\tvec3 spherePos = 0.5+(0.5*normalize(lightDir));//toSphere(pos, vec3(0.25, 2.895, 0.0), vec3(1.0, 2.25, 0.0025));\n        vec3 noiseCoords = texture(iChannel3, vec2(cos(iTime/10.0), sin(iTime/10.0))*lenLightDir).rgb;\n\t\tvec3 ld = lightDir+0.01*toSphere(noiseCoords, vec3(0.25, 2.895, 0.0), vec3(1.0, 2.25, 0.0025));\n        vec3 t2 = texture(iChannel1, ld.xz*0.75).yzx;\n\t\tvec3 t3 = texture(iChannel1, ld.xz*0.5).yzz;\n\t\tt2 = t2*t2;\n\t\tt3 = t3*t3;\n\t\tt2 = saturate(t2*1.0 - 0.05) * (texture(iChannel1, ld.xz).rgb*12.0);\n\t\tt3 = saturate(t3*1.5 - 0.05) * vec3(1.0,0.0,2.0);\n\t\tvec3 domeLight = mix(vec3(0.0), (t2 + t3)* (normal * 0.5 + 0.5) * min(ambient, shadow) * 0.15, skyMult);\n        domeLight *= dot(-lightDir, normal);\n        domeLight /= 9.0-(8.0*skyMult);\n        //domeLight /= 10.0;\n        vec3 rpos = castRay(pos+(normal/3.0), normal/10.0, 1.0);\n        //domeLight /= normalize(rpos);\n        if (rpos.x != 1e10) {\n         \tdomeLight *= 1.0-dot(normal, normalize(rpos));\n        }\n        \n        //domeLight -= vec3(length(rpos));\n        //domeLight *= shadow;\n        //domeLight /= 2.0;\n       \n        vec3 n = texture(iChannel3, cross(texture(iChannel1, normal.xz).rgb, normal).xz).rgb;\n        if (n.r-n.g > n.g-n.b) {\n         \tdomeLight /= 1.0+(sin(iTime/10.0)*100.0*(n.r-n.g));   \n        }\n        \n        envLight *= shadow * skyMult;\n\t\tenvLight += environmentSphereColor * 0.045;\t// ambient is lame, but better than black.\n\t\t//envLight /= 0.1;\n        /*envLight = pow(envLight, vec3(9.2));\n        envLight /= 150.0;*/\n        //domeLight = pow(domeLight, vec3(0.5/skyMult));\n        \n       //domeLight = pow(domeLight, vec3(3.0));\n\t\tfloat d1 = dot(sunDir, pos);\n\t\tfloat d2 = dot(sunDir, oculus);\n\t\tfloat d3 = dot(sunDir, camPos);\n\t\tvec3 flatPos = pos - sunDir * d1;\n\t\tvec3 flatOculus = oculus - sunDir * d2;\n\t\tvec3 flatCam = camPos - sunDir * d3;\n\t\tfloat sunShadow = calcShadow(flatPos, flatOculus, 0.02, 3.0, 0);//pow(saturate(0.5 - distance(flatPos, flatOculus)), 0.2);\n\t\tsunShadow /= 4.0;\n        vec3 sunDirect = max(0.0, dot(-sunDir, normal)) * sunCol * sunShadow * 1.0;\n      \t\n        vec3 sD = sunDirect;\n\t\tvec3 sunIndirect;// = 0.25*pow(saturate((3.5-distance(flatPos, flatOculus))), 2.0) * sunCol * 0.31;\n\t\tvec3 indirectDir = pos - floorHit;\n\t\tfloat indirectLen = length(indirectDir);\n\t\tindirectDir = normalize(indirectDir);\n\t\tsunIndirect = sunCol * (dot(-indirectDir, normal)*0.5+0.54) * 2.5 / pow(indirectLen, 1.75)*sunCol.x;\n\t\tsunDirect += tex.xyz*0.1;\n        //sunDirect /= 2.0;\n        vec3 totalLight = sunDirect+sunIndirect+envLight+domeLight;\n        vec3 lightColor = vec3(0.0);\n        lightColor = (envLight + sunIndirect + domeLight);\n        lightColor *= vec3(1.0,1.0,1.0) * ambient;\n        vec3 sunCol2 = max(vec3(0.0,0.0,0.0),\n\t\t\t\t\t\t  GetSunColorReflection(ref, normalize(-indirectDir))*0.5*tex.x*domeAlpha-0.25);\n        lightColor += sunDirect;\n        lightColor += sunCol2;\n        finalColor = lightColor * tex.xyz;\n        lightColor += sunCol * runeCol.x * 1.5 * max(0.0,sparkleLasting-0.1)*2.0;\n\t\tfinalColor *= vec3(1.0,1.0,1.0) * ambient;\n\t\tfinalColor += (sunDirect) * tex.xyz;// * ambient;\n\t\tfinalColor += sunCol2;\n\t\tfinalColor += sunCol * runeCol.x * 1.5 * max(0.0,sparkleLasting-0.1)*2.0;\n\t\t//finalColor = domeLight * min(ambient, shadow);\n\t\tfinalColor = mix(finalColor, vec3(0.015,0.015,0.015), pow(saturate(distance(pos, camPos)*0.075), 0.7) );\n\t\ttotalLight = normalize(totalLight);\n        totalLight *= (0.5+totalLight);\n        //totalLight = sqrt(3.0+totalLight)-sqrt(3.0);\n        //if (length(totalLight) > 0.1) {\n           \n        //}\n            //finalColor = vec3(1.0,1.0,1.0) * distance(pos, floorHit)*0.1;\n\t\t//finalColor = vec3(1.0,1.0,1.0) * distance(floorHit, pos)*0.01;// skyMult * shadow;\n\t\tif (distance(flatPos, flatCam) > distance(flatOculus, flatCam))\n\t\t{\n\t\t\tfloat ratioA = distance(flatOculus, flatCam) / distance(flatPos, flatCam);\n\t\t\tvec3 hazePos = mix(camPos, pos, ratioA);\n\t\t\tvec3 hazeNoise = texture(iChannel3, (hazePos.xz + vec2(0.0, -iTime* 0.125))* 0.03).xyz;\n\t\t\thaze = haze * hazeNoise.x;\n\t\t\tfinalColor += (sunCol + vec3(1.0, 1.0, 1.0)) * haze * 0.15 * sunCol.x;\n\t\t}\n\t\tfinalColor += sunCol * glowDist*0.001;\n        //finalColor = vec3(calcShadow(pos, normalize(oculus), 0.2, 40.0, 0));\n        //finalColor = pos;\n        //finalColor = applyFog(finalColor, distance(pos, camPos));\n        //finalColor = vec3(skyMult);\n        //finalColor = vec3(domeLight);\n\t\t//finalColor = vec3(1.0,1.0,1.0)*shadow*0.25;\n\t\t//finalColor = vec3(1.0,1.0,1.0)*mCount*0.005;\n\t\t//finalColor = vec3(saturate(tex.y-0.35), saturate(-(tex.y-0.35)), 0.0);\n\t}\n\n\t// closing credit text\n\tif (localTime > 46.5)\n\t{\n\t\tfloat creditsTimer = saturate((localTime - 47.0)*0.5);\n\t\t//finalColor = saturate(vec3(1.0,1.0,1.0)*0.25-creditsTimer);\n\t\tfinalColor = vec3(1.0,1.0,1.0)*0.25;\n\t\tvec2 shift = uv + vec2(0.0, 0.125);\n\t\t//runeCol = Rune(fract(shift*4.0), vec2(seed, seed))*creditsTimer;\n\t\truneCol *= creditsTimer;\n\t\tif (floor(shift.y*4.0) == 0.0)\n\t\t{\n\t\t\tfinalColor = mix(finalColor, vec3(0.25, 0.025, 0.01), pow(runeCol.x, 0.75));\n\t\t\tfinalColor += runeCol.z*2.0;\n\t\t}\n\t\t//finalColor = Rune(fract(uv*8.0), floor(uv*8.0*1.0+vec2(64.0, 0.0)*1.0)).xxx;\n\t\t//finalColor = Rune(fract(uv*8.0), floor(vec2(66.0, -2.0)*1.0)).xxx;\n\t\t// S - (-1, -7) :( (15, 2)\n\t\t// O - (5,-1) (-5, -5)\n\t\t// L - (34, 4)\n\t\t// S\n\t\t// T - (5,2) :( (19, 5)\n\t\t// I - (51, 4)\n\t\t// C - (66,-2)\n\t\t// E - (-8.0, 6.0)\n\t\t// N - (0, 4)\n\t\t// U - (-3, 0)\n\t\t// R -\n\t}\n    vec4 interInfo = vec4(0.0);\n    vec3 interNorm = vec3(0.0);\n\tbool hitSphere = castRay(pos, pos-normal, 1.0, interInfo, interNorm);\n    if (false) {\n        // is this correct for the position and normal from the point to the dome?\n     \tfragColor = vec4(interNorm.xyz, 1.0);   \n    } else {\n\t\tfragColor = vec4(sqrt(clamp(finalColor*4.0, 0.0, 1.0)),1.0);\n    }\n    //fragColor = texture(iChannel3, iMouse.xy/iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Copyright © 2017 Shuichi Hayashi\n\n// License of original voronoi implementation (https://www.shadertoy.com/view/ldl3W8)\n//\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Bump mapping impmentation is from https://www.shadertoy.com/view/ldj3zz written by demofox.\n// The license of this part follows the original code's one.\n\n//#define ANIMATE\n//#define SHOW_REFRACTION_ONLY\n//#define SHOW_REFLECTION_ONLY\n//#define SHOW_WITHOUT_SPECULAR\nconst float ANIMATION_RADIUS = 0.6; // up to 0.5\nconst float NUM_CELLS = 10.0;\nconst float IOR = 1.5;\nconst float F0 = ((1.0-IOR)/(1.0+IOR)) * ((1.0-IOR)/(1.0+IOR));\nconst float F90 = 1.0;\nconst float BASE_SHARPNESS = 2.0;\nconst float cubemapPower = 15.0;\nconst float chromaFactor = 7.0;\nconst float toneFactor = 0.55;\nconst float voronoiColorFactor = 1.0 / cubemapPower * chromaFactor;\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel2, (p+0.5)/256.0, 0.0).rg;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\n// from https://www.shadertoy.com/view/ldl3W8 (bit modified to return desired values)\n// returns,\n//   x: distance to nearest neighbor\n//   y: cell id\n//   z: distance to border\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    float id;\n\n    float md = 8.0;\n    int r = 5;\n    for( int j=-r; j<=r; j++ )\n    for( int i=-r; i<=r; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        vec2 ao = (1.-ANIMATION_RADIUS) + ANIMATION_RADIUS*sin( 0 + 6.2831*o );\n        #else\n        vec2 ao = o;\n        #endif\t\n        vec2 r = g + ao - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            id = o.x+o.y;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = (1.0-ANIMATION_RADIUS) + ANIMATION_RADIUS*sin( 0 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( length(mr), id, md );\n}\n\n// based on https://www.shadertoy.com/view/ldj3zz\nvec3 bump(vec3 surfaceNormal, vec2 uv) {\n\t// bump mapping\n\tvec3 uaxis = normalize(cross(vec3(0.0,1.0,0.0), surfaceNormal));\n\tvec3 vaxis = normalize(cross(uaxis, surfaceNormal));\n\tmat3 mattanspace = mat3\n\t(\n\t\tuaxis,\n\t\tvaxis,\n\t\tsurfaceNormal\n\t);\n\t\n\tfloat delta = -1.0/512.0;\n\tfloat A = texture(iChannel1, uv + vec2(0.0, 0.0)).x;\n\tfloat B = texture(iChannel1, uv + vec2(delta, 0.0)).x;\n    float C = texture(iChannel1, uv + vec2(0.0, delta)).x;\n\t\n    // animate sharpness\n    float sharpness = BASE_SHARPNESS;\n    float tm = mod(0.0/5.0, 3.5);\n    if (tm < 1.0) {\n\t    sharpness += 32.0 * ((cos(fract(tm)*6.2831)) * -0.5 + 0.5);\n    }\n\tvec3 norm = normalize(vec3(B - A, C - A, sharpness));\n\t//vec3 norm = normalize(vec3(B - A, C - A, 1.0));\n\t\t\n\treturn normalize(mattanspace * norm);\n}\n\n#define PI 3.1415926\n\nfloat F_Schlick(in float f0, in float f90, in float u) {\n    return f0 + (f90 - f0) * pow(1.0 - u, 5.0);\n}\n\nfloat saturate(in float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(in vec3 x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// Sampling 3d normal vector on a hemisphere according to parameter e.\n// distribute uniformly when e == 0\n//\n// reference:\n//   Shirley, Realistic Ray Tracing\n//   Suffern, Ray Tracing from the Ground Up, 7.3\nvec3 sampleHemisphere(in vec2 seed0, in vec2 seed1, in float e) {\n    float r1 = 2.0 * PI * rand(seed0); // phi(azimuth angle)\n    float r2 = rand(seed1); // theta(polar angle)\n    \n    float c = pow(1.0 - r2, 1.0 / (e + 1.0));\n    float s = sqrt(1.0 - c * c);\n    float rx = cos(r1) * s;\n    float ry = sin(r1) * c;\n    float rz = c;\n    return vec3(rx, ry, rz);\n}\n\n// vec3 luminance = BSDF(...) * saturate(dot(N, L)) * lightColor * att;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 frag = fragCoord.xy;\n    fragCoord.xy -= vec2(0.5)*iResolution.xy;\n    vec2 pn = frag.xy/iResolution.xy;\n    vec2 p1 = fragCoord.xy/max(iResolution.x,iResolution.y); // スクリーン長辺基準で[0.0, 1.0]\n#if 0\n    fragColor= vec4(hash(floor(p*10.0)), 0, 1);\n    return;\n#endif\n\tvec2 p = vec2(0.0);\n    p.x = atan(p1.y/p1.x);\n    p.y = length(p1);\n    \n    // compute voronoi pattern\n    vec3 c = voronoi( /*(14.0+ * sin(0.2*0))*/ p*NUM_CELLS );\n\n    // colorize\n    vec3 col = 0.5 + 0.5*cos( c.y*6.2831 + vec3(0.0,1.0,2.0) );\n    col *= voronoiColorFactor;\n\n    // calculate ray direction\n    vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.xy;\n    vec3 camAt = vec3(0, 0, -4.0);\n    vec3 camTarget = vec3(0, 0.5, 0);\n    vec3 camDir = normalize(camTarget - camAt);\n    vec3 camRight = cross(camDir, vec3(0,1,0));\n    vec3 camUp = normalize(cross(camRight, camDir));\n    float focus = 1.0;\n    float aspect = iResolution.y/iResolution.x;\n    vec3 rayDir = normalize(camRight*pos.x + camUp*pos.y*aspect + camDir*focus);\n\n    // generate normal\n    vec2 seed0 = vec2(c.y*0.34567, c.y*0.78901);\n    vec2 seed1 = vec2(c.y*0.45678, c.y*0.89012);\n    //vec3 n = -camDir;\n    vec3 n = cos( c.y*6.2831 + vec3(1.0,2.0,3.0) );\n    //vec3 n = sampleHemisphere(seed0, seed1, 0.0); // random normal\n    n = normalize( normalize(n) + -20.0*camDir ); // get toward to camera\n    n = bump(n, p);\n\n// for debug\n//fragColor = vec4(0, 0, n.b*0.5+0.5, 1.0);\n//fragColor = vec4(rayDir*0.5+0.5, 1.0);\n//fragColor = vec4(refract(rayDir, n, 1.0)*0.5+0.5, 1.0);\n//fragColor = vec4(texture( iChannel0, rayDir).rgb, 1.0);\n//return;\n\n    // rotate camera and normal\n    float rot = 0.0*6.2831 * -0.01;\n    mat2 mRot = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    rayDir.xz = mRot * rayDir.xz;\n    n.xz = mRot * n.xz;\n\t//fragColor = vec4((n+1.0)*0.5, 1.0);\n\t//return;\n\n    // transmitted color\n    vec3 tr = refract(rayDir, n, 1.0/IOR);\n    vec3 tColor = texture( iChannel0, tr ).rgb;\n#ifdef SHOW_REFRACTION_ONLY\n\tfragColor = vec4(tColor.rgb, 1.0);\n    return;\n#endif\n    float thickness = smoothstep(0.0, 0.4, c.z);\n    thickness = pow((thickness), 0.25);\n#ifdef SHOW_BORDER_ONLY\n\tfragColor = vec4(thickness, thickness, thickness, 1.0);\n\treturn;\n#endif\n    tColor = (col * thickness) * (tColor*cubemapPower);\n    // add frame\n    float frame = smoothstep(0.015, 0.06, c.z);\n    tColor.rgb *= frame;\n\n    // reflected color\n    vec3 r = reflect(rayDir, n);\n    vec3 rColor = texture(iChannel0, r).rgb;\n    rColor *= cubemapPower;\n#ifdef SHOW_REFLECTION_ONLY\n    fragColor = vec4(rColor, 1.0);\n    return;\n#endif\n    rColor.rgb *= (0.3 + 0.7*frame);\n    \n    // combine refracted and reflected colors\n    float NdotV = dot(n, -rayDir);\n    float f = F_Schlick(F0, F90, NdotV);\n#ifdef SHOW_WITHOUT_SPECULAR\n    fragColor.rgb = tColor;\n    return;\n#endif\n    fragColor.rgb = (f * rColor) + (1.0 - (f * rColor)) * tColor;\n    //fragColor.rgb = f * rColor + (1.0-f) * tColor;\n    fragColor.rgb *= toneFactor;\n    fragColor.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nfloat grad(float t){\n\treturn 6.0*pow(t,5.0)-15.0*pow(t,4.0)+10.0*pow(t,3.0);\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\n#define RES 100.0\nvec4 voronoi2d(vec2 p,float t){\n\tfloat v=8.0;\n\tvec4 c;\n\tvec2 f=floor(p);\n\tfor(float i=-3.0;i<3.0;i++)\n\tfor(float j=-3.0;j<3.0;j++){\n\t\tsrand(f+vec2(i,j));\n\t\tvec2 o;\n\t\to.x=rand();\n\t\to.y=rand();\n\t\to*=rot2d(t*(rand()-0.1));\n\t\tfloat d=distance(p,f+vec2(i,j)+o);\n\t\tif(d<v){\n\t\t\tv=d;\n\t\t\tc=texture(iChannel0,(f+vec2(i,j)+o)/RES);\n\t\t}\n\t}\n\treturn c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=0.0;\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 s=fragCoord.xy/vec2(iResolution.x,-iResolution.y);\n\t//fragColor=texture(iChannel0,s);\n\tfragColor=voronoi2d(s*RES,t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}