{
    "Shader": {
        "info": {
            "date": "1676873708",
            "description": "water surface https://www.shadertoy.com/view/MdXyzX\ncaustics https://alltd.org/realtime-caustics-in-touchdesigner-with-easy-glsl/",
            "flags": 0,
            "hasliked": 0,
            "id": "ctjXzd",
            "likes": 6,
            "name": "realtime water caustics point",
            "published": 3,
            "tags": [
                "water",
                "caustics"
            ],
            "usePreview": 0,
            "username": "lanx06",
            "viewed": 152
        },
        "renderpass": [
            {
                "code": "#define fc fragCoord\n#define ir iResolution.xy\n#define iter 20\n#define SIZE 7\n//#define N 10\n#define N int(iResolution.y/1.5)\n#define T iTime*0.2\nvec2 stdNormalMap(vec2  uv) \n{\n    float h =texture(iChannel0, uv).r;\n    return -vec2(dFdx(h), dFdy(h)); \n}\nvec3 normalPlane(vec2 uv){\n    \n    vec3 normalMap;\n    const int textureOffset =1;\n    //uv*=1.2;\n    uv*=0.5+ length(iMouse.xy / ir)*1.5;\n    \n    float p =getwaves(uv,iter,T);\n    float h1=getwaves(uv +  vec2(textureOffset,0)/ir,iter,T);\n    float v1=getwaves(uv +  vec2(0,textureOffset)/ir,iter,T);\n   \tnormalMap.xy= (p - vec2(h1, v1))*100.0;\n    //normalMap.xy=-vec2(dFdx(p), dFdy())*10.0; \n    normalMap+=0.5;\n    normalMap.z=1.0;\n    vec3 normal;\n    mat3 TBN=mat3(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1));\n    \n    //normal=(TBN*normalMap)*2.0-1.0;\n    //normal=normalize(normal);\n    normal=normalMap;\n    return normal;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 lightdir=\n    vec2(0.5,0.5);\n    //(iMouse.xy / ir.xy)-0.5;\n    float row=iResolution.x/float(N);\n    vec3 col ;\n \n    \n    vec2 block=vec2( floor(fc/vec2(row)) );\n    if(uv.x<0.5 && uv.y>0.5)\n        col=normalPlane(uv);\n    if(uv.x<0.5)\n        col=normalPlane(uv);\n    else \n        for(int i=0;i<SIZE*SIZE;i++){\n                vec2 id=vec2(i%SIZE , i/SIZE )+vec2(-SIZE/2)\n                //+block;\n                ;vec2 simaplepos=(id+vec2(0.5))*row\n                +fc;\n                ;\n                //pos+=(random(id)-vec2(0.5))*v*row*float(SIZE)*0.5;\n                float pix=0.5;\n                float radius=0.5;\n                vec3 normal=normalPlane(simaplepos/ir);\n                \n                vec2 offset=refract(vec3(lightdir,-0.707),normal,1.0/1.3).xy;\n                float len=row*float(SIZE)*0.7;\n                vec2 midpos=simaplepos+offset*len;\n                \n                //vec2 dis=();\n                float l=length((fc-midpos)/row);\n                vec2 lo=normalize(offset)*len*0.2;\n                float ldis=line_segment(fc,midpos-lo,midpos+lo)/row*1.0;\n                float tem=dot((fc-midpos),normalize(offset))/pow(length(lo)+(pix+radius)*row,1.0);\n                vec3 color=\n                //spectral_bruton((tem+1.5)*0.4);\n                //spectral_bruton((tem+1.0)*0.5);\n                //spectral_jet((tem+.8)*0.5);\n                spectral_jet((tem+1.0)*.5);\n                \n                color=rgb2hsv(color);\n                color.y=pow(l,2.0);\n                //l*0.9;\n                color=hsv2rgb(color);\n                color.g*=0.7;\n                col+=(smoothstep(radius+pix,radius-pix,ldis))/float(SIZE)*1.0\n                \n                //*(tem+1.0)*0.5;\n                //*abs(tem);\n                *color;\n                //col.xy+=pos/ir*smoothstep(radius+pix,radius-pix,dis);\n                //col+=normal *smoothstep(radius+pix,radius-pix,dis);\n            }\n    \n    \n    //col.xy=block/float(N);;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations,float t){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    #define DRAG_MULT 0.048\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, t);\n        position += p * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}float line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\nvec3 spectral_bruton (float w)\n{\n    //remap 0to 1->380 780\n    w=mix(400.0,800.0,w);\n\tvec3 c;\n\n\tif (w >= 380. && w < 440.)\n\t\tc = vec3\n\t\t(\n\t\t\t-(w - 440.) / (440. - 380.),\n\t\t\t0.0,\n\t\t\t1.0\n\t\t);\n\telse if (w >= 440. && w < 490.)\n\t\tc = vec3\n\t\t(\n\t\t\t0.0,\n\t\t\t(w - 440.) / (490. - 440.),\n\t\t\t1.0\n\t\t);\n\telse if (w >= 490. && w < 510.)\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t1.0,\n\t\t\t-(w - 510.) / (510. - 490.)\n\t\t);\n\telse if (w >= 510. && w < 580.)\n\t\tc = vec3\n\t\t(\n\t\t\t(w - 510.) / (580. - 510.),\n\t\t\t1.0,\n\t\t\t0.0\n\t\t);\n\telse if (w >= 580. && w < 645.)\n\t\tc = vec3\n\t\t(\n\t\t\t1.0,\n\t\t\t-(w - 645.) / (645. - 580.),\n\t\t\t0.0\n\t\t);\n\telse if (w >= 645. && w <= 780.)\n\t\tc = vec3\n\t\t(\t1.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\telse\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\n\treturn saturate(c);\n}\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = w;\n    //saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}