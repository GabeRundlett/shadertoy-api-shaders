{
    "Shader": {
        "info": {
            "date": "1464187659",
            "description": "Equirectangular test image i made for the OpenSource Dome Mapping Software omnidome. \nhttp://omnido.me \nDemo video: https://vimeo.com/167266452",
            "flags": 0,
            "hasliked": 0,
            "id": "MdKXDh",
            "likes": 12,
            "name": "Omnidome Parametric Test Image",
            "published": 3,
            "tags": [
                "testimage",
                "spherical",
                "parametric",
                "equirectangular"
            ],
            "usePreview": 0,
            "username": "WilstonOreo",
            "viewed": 1388
        },
        "renderpass": [
            {
                "code": "/// Omnidome Parametric Test Image\n/// (C) 2016 by cr8tr. Licensed under AGPLv2.\n/// Visit http://omnido.me to checkout our opensource dome mapping software!\n\nconst float PI = 3.14159265358979323846264;\n\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in float c )\n{\n  vec3 rgb = clamp( abs(mod(c*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn rgb; \n}\n\nfloat spherical_direction(in vec2 uv, out vec3 rd)\n{\n  float theta = (uv.t) * PI,\n        phi = (uv.s - 0.5)* 2.0 * PI;\n  rd = vec3(sin(theta) * sin(phi), sin(theta) * cos(phi), cos(theta));\n  return 1.0;\n}\n\nfloat dist_vertical_line( vec3 p)\n{\n  return length(vec2(length(p.xz)-1.0,p.y));\n}\n\nfloat dist_horizontal_line( vec3 p)\n{\n  return length(vec2(length(p.xy)-1.0,p.z));\n}\n\nvec2 pos;\nfloat sin_theta, cos_theta;\nfloat sin_phi, cos_phi;\n\nvec2 linePosition(in vec2 numLines)\n{\n  return vec2(\n    mod(pos.x*numLines.x + 0.25,1.0),\n    mod(pos.y*numLines.y + 0.5,1.0)); \n}\n\nfloat grid(in vec2 numLines, in float thickness)\n{\n  vec2 linePos = linePosition(numLines);\n  vec2 vertical = vec2(linePos.x,pos.y);\n  vec2 horizontal = vec2(pos.x,linePos.y); \n  \n  float theta = linePos.y * PI;\n  float phi = (linePos.x - 0.5)* 2.0 * PI;\n  vec3 vertPoint = vec3(sin_theta * sin(phi), sin_theta * cos(phi), cos_theta);\n  vec3 horzPoint = vec3(sin(theta) * sin_phi, sin(theta) * cos_phi, cos(theta));\n\n  float v = min(dist_vertical_line(vertPoint),dist_horizontal_line(horzPoint)) / thickness;\n\n  return clamp(pow(v*1.8,10.0),0.0,1.0);\n}\n\n\nfloat ruler(vec2 ruler_pos)\n{\n  float theta = (pos.t) * PI,\n        phi = (pos.s - ruler_pos.x + 0.25)* 2.0 * PI;\n  vec3 rd = vec3(sin(theta) * sin(phi), sin(theta) * cos(phi), cos(theta));\n \n  float mouse_theta = (0.5 + ruler_pos.y ) * PI;\n  float mouse_phi = (ruler_pos.x - 0.5)* 2.0 * PI;\n  vec3 mousePoint = vec3(sin(mouse_theta) * sin(mouse_phi), sin(mouse_theta) * cos(mouse_phi), cos(mouse_theta));\n  \n  float horizontal_line = length(vec2(length(rd.xy) - length(mousePoint.xy),rd.z  + mousePoint.z));\n\n  float vertical_line = length(vec2(length(rd.xz)-1.0,rd.y));\n\n  return min(vertical_line,horizontal_line) / 0.01;\n}\n\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.0 - smoothstep(0.05,0.15,abs(uv.x))) *\n\t\t\t       (1.-smoothstep(0.35,0.55,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // minus sign.\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn digit(uv,nr);\n}\n\n//    ... end of digits adapted from Andre\n\n#define STEPX .875\n#define STEPY 1.5\n\n// 2digit int + sign\nfloat display(vec2 uv, vec2 pos, vec2 scale, int number) { // dot: draw separator\n\tuv = (uv-pos)/scale*2.; \n  uv.x = .5-uv.x + STEPX*0.6;\n\tuv.y -= 1.;\n    float seg = 0.0;\n\t if (number != 0) {\n\tseg += showNum(uv - vec2(1.5,0),number,true);\n     }\n    seg += showNum(uv,0,true);\n\n\treturn seg;\n}\n\n// Simplified cylinder intersection, used for drawing number with correct distorsion\nfloat Cylinder_intersection(in vec3 rd, out vec3 iPoint)\n{\n  float a = dot(rd.xz,rd.xz);\n  float disc = a;\n  if (disc < 0.0) return -1.0;\n\n  iPoint = rd * inversesqrt(disc);\n  if (dot(iPoint,vec3(1.0,0.0,0.0)) < 0.0) return -1.0;\n \n  if (iPoint.y > 0.3 || \n      iPoint.y < -0.3) return -1.0;\n  return 1.0;\n}\n\nfloat fisheyeMapping(in vec3 uvw, out vec2 texCoords)\n{\n  float phi = atan(length(uvw.xy),abs(uvw.z));\n  float r =  phi / PI * 2.0 / (-0.667 + 1.0);\n  if ((r > 1.0) || (r <= 0.0)) return -1.0;\n  float theta = atan(uvw.x,uvw.y);\n  texCoords.s = fract(0.5 * (1.0 + r* sin(theta)));\n  texCoords.t = fract(0.5 * (1.0 + r * cos(theta)));\n  return 1.0;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  pos = fragCoord.xy / iResolution.xy;\n  vec2 ruler_pos = vec2(iMouse.xy / iResolution.xy - vec2(0.5)) * vec2(1.0,-1.0);    \n  vec3 rgb = hsv2rgb_smooth(pos.x);\n  vec3 vertPoint,horzPoint;\n\n  float theta = pos.t * PI;\n  float phi = (pos.s - 0.5)* 2.0 * PI;\n  sin_theta = sin(theta);\n  cos_theta = cos(theta);\n  sin_phi = sin(phi);\n  cos_phi = cos(phi);\n  vec3 rd = vec3(sin_theta * sin_phi, sin_theta * cos_phi, cos_theta);\n\n  float leaders = clamp((2.0 - ruler(ruler_pos)) * (abs(sin(PI*1.0*(ruler_pos.x - pos.x)))),0.0,2.0) ;\n  float coarseGrid = max(clamp(1.0 - grid(vec2(18.0,18.0),0.1),0.0,1.0),\n    clamp(1.0 - grid(vec2(2.0,2.0),0.04),0.0,1.0));\n  float fineGrid = clamp(1.0 - grid(vec2(90.0,90.0),0.5),0.0,1.0) * 4.0;\n\n  vec4 color = vec4(vec3(coarseGrid + fineGrid*0.10)*vec3(rgb) + vec3(leaders * 0.5 + leaders * fineGrid * 0.05) + pow(1.0 - sin(pos.y*PI) ,10.0),1.0);\n\n  for (int i = 0; i < 4; ++i) {\n    float phi_mouse = (pos.s - (float(i)/4.0)) * 2.0 * PI;\n    rd = vec3(sin_theta * sin(phi_mouse), sin_theta * cos(phi_mouse), cos_theta);\n    vec3 iPoint;\n  \n    if (Cylinder_intersection(rd,iPoint) > 0.0)\n    {\n      vec2 texCoord = vec2(acos(iPoint.y / 0.6) / PI,- iPoint.z +0.003);\n      for (float j = 3.0; j < 16.0; j += 1.0 ) { \n        int value = (j == 9.0) ? i * 9 : 9 - int(j);\n        \n        color += display(texCoord,vec2(0.45,cos((j/9.0)*PI*0.5)),vec2(0.033,0.05 * sin(j/9.0*PI*0.5)),value);\n      }\n    }\n  }\n\n  color = clamp(color,vec4(0.0),vec4(1.0));\n  vec2 texCoords;\n  if (fisheyeMapping(rd,texCoords) > 0.0) {\n    float d = clamp(2.0*length(texCoords - vec2(0.5)),0.0,1.0);\n    color -= vec4(1.0 - pow(d,3.0));\n     color = clamp(color,vec4(0.0),vec4(1.0));\n\n      color += texture(iChannel0,texCoords);\n  }\n\n    \n  fragColor = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}