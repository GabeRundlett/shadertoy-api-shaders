{
    "Shader": {
        "info": {
            "date": "1589229373",
            "description": "An experiment in eliminating the field array. There is no global state. This is different than me previous work that actually used a damn global array to store vector field points! Yikes... ;^o This one scales much better!\n\nBeware of some Epilepsy...",
            "flags": 0,
            "hasliked": 0,
            "id": "3dffDX",
            "likes": 6,
            "name": "Angler v:0.0.0",
            "published": 3,
            "tags": [
                "fractal",
                "field",
                "vector",
                "vector",
                "angle"
            ],
            "usePreview": 0,
            "username": "Chris_M_Thomasson",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.4\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n\n-- Removed the global array! :^)\n\n-- Removed Create an attractor by clicking and dragging it around.\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 16\n\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    vec2 g = vec2(0.0, 0.0);\n    \n    const int imax = CT_N;\n    \n    float abase = 6.28318 / float(imax);\n    float rbase = 1. / float(imax);\n    \n    for (int i = 0; i < imax * 2; ++i)\n    {\n        float angle = abase * float(i);\n        float radius = rbase * float(i);\n        \n        angle += sin(iTime * .5) * 3.1459;\n       \n        vec2 vp = vec2(\n            cos(angle) * radius * (1. + abs(sin(iTime))), \n            sin(angle) * radius * (1. + abs(cos(iTime)))\n        );\n        \n        float vm = -1.;\n        \n        vec2 dif = vp - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + vm * dif[0] / mass;\n      \tg[1] = g[1] + vm * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = cos(iTime * .1) * 3.14; // Humm...\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float scale = float(CT_N);\n    \n    float color = mod(npi * scale, 1.0);\n    \n    if (color < .5)\n    {\n        //color /= .5;\n        //return vec4(color, 0, color, 1.0);\n    }\n    \n    return vec4(color, color, color, 1.0);\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){  \n    return ct_vpixel(c, c, 128, 2.);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0.0, \n        0.0, \n        0.1 + abs(sin(iTime * .1)) * 4.9\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}