{
    "Shader": {
        "info": {
            "date": "1648821113",
            "description": "Analytic Filtering of Cosine using a gaussian pixel footprint \nDetails here: [url]https://h4w0.frama.io/pages/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "NtlcWf",
            "likes": 8,
            "name": "Filtered Cosine",
            "published": 3,
            "tags": [
                "procedural",
                "filtering",
                "cosine",
                "harmonic"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= Pre-Filtered Cosine (gaussian filter)\n//=======================================================\n//== Code       : https://www.shadertoy.com/view/NtlcWf\n//== Comparison : https://www.shadertoy.com/view/NlscWf\n//== Details    : https://h4w0.frama.io/pages/posts/2022-04-01-FilteredCosine.html\n//=======================================================\n//== For a box filtered cosine -> see IQ's article :\n//== https://iquilezles.org/articles/bandlimiting\n//== And in action :  https://www.shadertoy.com/view/WtScDt\n//=======================================================\n//== Author  : Arthur Cavalier\n//=======================================================\n\n#define REMAP_0_1\n\nfloat cosine(vec2 x, float alpha, vec2 f)\n{\n    return alpha * cos(dot(x,f));\n}\n\nfloat prefiltered_cosine(vec2 x, float alpha, vec2 f)\n{\n    mat2  J = 0.5*mat2(dFdx(x),dFdy(x));\n    mat2  S = J*transpose(J);\n    return alpha * cos(dot(x,f)) * exp(-0.5*dot(f,S*f));\n}\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = ((2.*fragCoord.xy-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(0.1*iTime + 6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(0.1*iTime + 6.0*mouse) );\n    vec3 target = vec3( 0., -0.4, -0. );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(1.),1.);\n  \n    // Harmonic Parameters\n    float F0 = 2.0 + sin(0.5*iTime);\n    float T0 = 0.0;\n    vec2  F = m_2_pi * F0 * vec2( cos(T0), sin(T0) ); \n\n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,20.));\n    if(hit>0.0)\n    {\n        vec3 hit_position = (origin + hit*direction);\n        vec2 x = hit_position.xz/5.;\n        float harmonic = 0.; \n        if(coords.x<0.)\n        {\n            harmonic = cosine(x,1.0,F);\n        }\n        else\n        {\n            harmonic = prefiltered_cosine(x,1.0,F);\n        }\n        \n        fragColor.rgb = vec3(harmonic);\n        \n        #ifdef REMAP_0_1\n        fragColor.rgb = vec3(0.5+0.5*harmonic);\n        #endif\n    }\n    fragColor.rgb *= smoothstep( 0.0, 0.01, abs(coords.x) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uint  LRPN_GLOBAL_SEED = 0u;\n\n// Constants -----------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n// RayTracing -----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n// Matrix Maths ------------------------------------------------------------------------------------------\nfloat det2x2(in mat2 m)         {return (m[0][0]*m[1][1] - m[0][1]*m[1][0]);}\nmat2  inv2x2(in mat2 m)         {return (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);}\nmat2  tra2x2(in mat2 m)         {return mat2(m[0][0],m[1][0],m[0][1],m[1][1]);}\n\n// PRNG ----------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}