{
    "Shader": {
        "info": {
            "date": "1612041733",
            "description": "This is a couple of years old, however I only recently managed to get running fast enough to publish. I had been using about 100 (!) samples to get a smooth dispersion gradient, now I'm using just 3 thanks to some blue noise and frame averaging.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wl3BRr",
            "likes": 74,
            "name": "feelsgood.glsl",
            "published": 3,
            "tags": [
                "head"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 2439
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Head SDF\n    --------\n\n\tThis gets written into a \"3D\" texture using the utilities in Common.\n\t\n\tFor other appearances see:\n\n    * https://www.shadertoy.com/view/wlf3WX\n\t* https://www.shadertoy.com/view/wtf3RM\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\n// Modelling\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat helix(vec3 p, float lead, float thick) {\n    // p.z += iTime * .1;\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\n    d = abs(d) - thick;\n    return d;\n}\n\nvoid fMouth(inout float d, vec3 pp) {\n    vec3 p;\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n}\n\nbool isMap = true;\nbool isEye = false;\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    //p.y -= .13;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n\n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // return d;\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    fMouth(d, pp);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n    if (isMap) isEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // hole\n    p = pp;\n    p += vec3(-.36,.19,.06);\n    pR(p.xz, -.5);\n    pR(p.xy, -.2);\n    p.x += .02;\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    p -= OFFSET;\n    p /= SCALE;\n   \treturn mHead(p);\n\treturn length(p) - .3;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    int id = faceIdFromDir(rayDir);\n    \n    vec2 coord = fragCoord.xy;\n    vec2 size = iResolution.xy;\n    vec2 uv = coord / size;\n    \n    vec4 lastFrame = texture(iChannel0, rayDir);\n    if (lastFrame.x != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n    \treturn;\n    }\n    \n    mat4 space = texToSpace(coord, id, size);\n    \n    vec3 p0 = space[0].xyz;\n    vec3 p1 = space[1].xyz;\n    vec3 p2 = space[2].xyz;\n    vec3 p3 = space[3].xyz;\n\n    fragColor = vec4(\n        map(p0),\n        map(p1),\n        map(p2),\n        map(p3)\n    );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "\n#define PI 3.14159265359\n\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Read head sdf from '3D' texture\nfloat mHead(vec3 p) {\n    p.x = -abs(p.x);\n    p += OFFSET / SCALE;\n    float bound = fBox(p, 1./SCALE);\n    if (bound > .01) return bound;\n    p *= SCALE;\n    float d = mapTex(iChannel0, p, iChannelResolution[0].xy);\n    return d;\n}\n\nfloat sinstep(float t) {\n\treturn sin(t * PI + PI * .5) * .5 + .5;\n}\n\nfloat map(vec3 p) {\n    p.y -= .06;\n    \n    vec2 im= iMouse.xy / iResolution.xy;\n    im= vec2(.38,.6);\n    \n    if (im.x > 0. && im.y > 0.) {\n    \tpR(p.zx, ((im.x)*2.-1.)*1.5);\n    \tpR(p.zy, ((im.y)*2.-1.)*1.5);\n    }\n\n    float r = sin(1. * fTime * PI * 2. - PI * .6);\n    r = smoothstep(0., 1., clamp((r - .4) * .7, -1., 1.) * .5 + .5);\n    float t = mod(fTime - .2, 1.);\n    r = sinstep(range(.05, .45, fTime)) - sinstep(range(.45, 1., fTime));\n    r = r * .05;\n    pR(p.zy, -r);\n\n    float d = mHead(p);\n    return d;\n}\n\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n}\n\nconst float DISPERSION_SAMPLES = 3.; // Higher = slower but smoother blending\n\nvec3 drawBg(vec3 rd) {\n    float t = atan(rd.y, rd.z);\n    t = sin(t * 15. - fTime * PI * 2.);\n\tvec3 c = vec3(smoothstep(-.2, .0, -1. + t)) * 2.;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n\n    if (iMouse.z > 0.) {\n    \tp /= 1.8;\n    }\n\n    p /= 1.15;\n    \n    float wavelength;\n    vec3 pos;\n    vec3 nor;\n    vec3 rrd;\n    float ri;\n    vec3 sam;\n\n    float rand = texture(iChannel1, fragCoord.xy / iChannelResolution[1].xy).r;\n    rand = fract(rand + 1.61803398875 * float(iFrame)); // https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n\n    vec3 origin = vec3(0,.05,3.2);\n    vec3 rd = normalize(vec3(p + vec2(0,-0),-4));\n    float rayLength = 0.;\n    float dist = 0.;\n\n    for (int i = 0; i < 50; i++) {\n        rayLength += dist;\n\n        pos = origin + rd * rayLength;\n        dist = map(pos);\n\n        if (dist < .0005) {\n            nor = calcNormal(pos);\n\n            for(float r = 0.; r < DISPERSION_SAMPLES; r++){\n                wavelength = r / DISPERSION_SAMPLES;\n                wavelength += (rand * 2. - 1.) * (.5 / DISPERSION_SAMPLES);\n                wavelength = mod(wavelength, 1.);\n\n                ri = 1.3 + (wavelength - .5) * .9;\n                ri = 1. / ri;\n                rrd = refract(rd, nor, ri);\n                col += drawBg(rrd) * spectrum(wavelength);\n            }\n\n            break;\n        }\n\n        if (rayLength > 5.) {\n            break;\n        }\n    }\n\n    col /= DISPERSION_SAMPLES / 2.;    \n    \n    if (iFrame > 2) {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec3 lastcol = texture(iChannel2, uv).rgb;\n        col = mix(lastcol, col, clamp(15. * iTimeDelta, 0., 1.));\n    }\n\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\n    '3D' Texture Utils\n    ------------------\n\n\tThese allow reading and writing to a cubemap texture that's\n    repurposed as a 3D texture.\n\n*/\n\n\n#define fTime mod(iTime / 3., 1.)\n//#define fTime (0.)\n\nvec2 texSubdivisions = vec2(8,2);\n\n#define MIRROR\n#define SCALE (vec3(4.1,1.73,1.75)/1.1)\n#define OFFSET vec3(.95, .094, -.088)\n\n// #define SCALE vec3(1)\n// #define OFFSET vec3(0)\n\n// Cube face ID from direction\n// 0 x\n// 1 y\n// 2 z\n// 3 -x\n// 4 -y\n// 5 -z\nint faceIdFromDir(vec3 v) {\n    vec3 va = abs(v);\n    int id = 0;\n    float m = va.x;\n    if (va.y > m) id = 1, m = va.y;\n    if (va.z > m) id = 2;\n    if (v[id] < 0.) id += 3;\n    return id;\n}\n\n\n// Direction from uv and cube face ID\n// uv: vec2(0,0) to vec2(1,1)\n// id: 0 to 5\nvec3 dirFromFaceId(vec2 uv, int id) {\n    vec3 dir = vec3(.5, .5 - uv.yx);\n    dir = normalize(dir);\n    if (id == 4) dir.yz *= -1.;\n    if (id > 2) dir.xz *= -1., id -= 3;\n    if (id == 1) return (dir * vec3(1,-1,-1)).zxy;\n    if (id == 2) return (dir * vec3(1,1,-1)).zyx;    \n    return dir;\n}\n\n\n// Divide texture into 3d space coordinates\n// uv = 2d texture coordinates 0:1\n// c = channel 0:3\n// id = face id 0:6\n\n// xy is split for each z\n// z is split across channels and cube map faces (4 * 6 = 24)\n\n// Returns matrix representing four positions in space\n// vec3 p0 = mat4[0].xyz;\n// vec3 p1 = mat4[1].xyz;\n// vec3 p2 = mat4[2].xyz;\n// vec3 p3 = mat4[4].xyz;\n\nvec3 texToSpace(vec2 coord, int c, int id, vec2 size) {\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n    vec2 subCoord = floor(coord / subSize);\n    float z = 0.;\n    z += float(id) * 4. * sub.y * sub.x; // face offset\n    z += float(c) * sub.y * sub.x; // channel offset\n    z += subCoord.y * sub.x; // y offset\n    z += subCoord.x; // x offset\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    z /= zRange;\n    vec2 subUv = mod(coord / subSize, 1.);\n    vec3 p = vec3(subUv, z);\n    p = p * 2. - 1.; // range -1:1\n    return p;\n}\n\nmat4 texToSpace(vec2 coord, int id, vec2 size) {\n    return mat4(\n        vec4(texToSpace(coord, 0, id, size), 0),\n        vec4(texToSpace(coord, 1, id, size), 0),\n        vec4(texToSpace(coord, 2, id, size), 0),\n        vec4(texToSpace(coord, 3, id, size), 0)\n    );\n}\n\n\n// Transform xyz coordinate in range -1,-1,-1 to 1,1,1\n// to texture rayDir and channel\nvec4 spaceToTex(vec3 p, vec2 size) {\n    p = clamp(p, -1., 1.);\n    p = p * .5 + .5; // range 0:1\n\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n\n    // Work out the z index\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float i = round(p.z * zRange);\n\n    // return vec3(mod(i, sub.x)/sub.x);\n    // translate uv into the micro offset in the z block\n    vec2 coord = p.xy * subSize;\n\n    int faceId = int(floor(i / (4. * sub.y * sub.x)));\n    float channel = mod(floor(i / (sub.x * sub.y)), 4.);\n    float y = mod(floor(i / sub.x), sub.y);\n    float x = mod(i, sub.x);\n    \n    // Work out the macro offset for the xy block from the z block\n    coord += vec2(x,y) * subSize;\n\tcoord /= size;\n    \n    vec3 dir = dirFromFaceId(coord, faceId);\n\n    return vec4(dir, channel);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat mapTex(samplerCube tex, vec3 p, vec2 size) {\n    // stop x bleeding into the next cell as it's the mirror cut\n    #ifdef MIRROR\n        p.x = clamp(p.x, -.95, .95);\n    #endif\n    vec2 sub = texSubdivisions;\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float z = p.z * .5 + .5; // range 0:1\n    float zFloor = (floor(z * zRange) / zRange) * 2. - 1.;\n    float zCeil = (ceil(z * zRange) / zRange) * 2. - 1.;\n    vec4 uvcA = spaceToTex(vec3(p.xy, zFloor), size);\n    vec4 uvcB = spaceToTex(vec3(p.xy, zCeil), size);\n    float a = texture(tex, uvcA.xyz)[int(uvcA.w)];\n    float b = texture(tex, uvcB.xyz)[int(uvcB.w)];\n    return mix(a, b, range(zFloor, zCeil, p.z));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}