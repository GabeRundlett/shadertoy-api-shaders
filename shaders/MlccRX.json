{
    "Shader": {
        "info": {
            "date": "1533396700",
            "description": "Rotating pink noise grid (inspired by Ash Thorp)",
            "flags": 0,
            "hasliked": 0,
            "id": "MlccRX",
            "likes": 13,
            "name": "Checker Eye",
            "published": 3,
            "tags": [
                "bookofshaders"
            ],
            "usePreview": 0,
            "username": "momoro",
            "viewed": 718
        },
        "renderpass": [
            {
                "code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n    \t\n\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\n#define PI 3.141592654\n#define RINGS 180./2.\n#define COLS 200./2.\n#define BLACK .02\n#define p 3.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //vec2 fragCoord = gl_FragCoord.xy;\n    //vec2 iResolution = u_resolution;\n    //float iTime = u_time;\n    \n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float ringRotation = random(vec2(ceil(pow(1.0 - length(st), p) * RINGS))) - .5;\n    ringRotation *=  iTime/1.5;\n\tst = (rotate(ringRotation)) * st;\n\n    \n    // Set up circular coordinate system\n    float distance = length(st);\n\tfloat angle = atan(st.x, st.y) + PI;\n    angle = angle / (PI * 2.);\n    \n    \n    // x = distance\n    // y = angle\n    vec2 uv = vec2(distance, angle);\n\n\n    vec2 uvGrid;\n    float ix = 1.-uv.x;\n    uvGrid.x = ceil(pow(ix, p) * RINGS);\n    uvGrid.y = ceil(pow(uv.y, p) * COLS );\n\n    \n\n    float f = random(vec2(uvGrid));\n    \n    // Add padding between rings\n    if(fract(pow(ix, p)* RINGS) < 0.340) {\n        f = BLACK;\n    }\n    \n    // Add padding between columns\n    if(fract(pow(uv.y, p) * COLS) < 0.032) {\n        f = BLACK;\n    }\n    \n    // Black Rings\n    float r1 = 2.684;\n    if(uvGrid.x > RINGS/r1 && uvGrid.x < RINGS/(r1-0.152)) {\n        f = BLACK;\n    }\n    float r2 = r1 * 0.688;\n    if(uvGrid.x > RINGS/r2 && uvGrid.x < RINGS/(r2-0.040)) {\n        f = BLACK;\n    }\n    float r3 = r2 * 0.848;\n    if(uvGrid.x > RINGS/r3 && uvGrid.x < RINGS/(r3-0.016)) {\n        f = BLACK;\n    }\n\n    \n    // Cut it off\n    if(length(st) > 0.445 || length(st) < .05) {\n        f  = BLACK;\n    }\n\t// Drop some to black\n    if(f < .05) {\n        f = BLACK;\n    }\n    \n    \n    // Assign blue\n    vec3 color;\n    \n    if(f > .9) {\n        color = vec3(1.);\n    }\n    else if(f > .75)  {\n        color = vec3(0.920,0.248,0.709);\n    } else if(f >.6) {\n        color = vec3(0.302,0.065,0.475);\n    } else if(f < .4 && f > BLACK) {\n        color = vec3(0.064,0.048,0.435);\n    } else\n    {\n   \t\tcolor = vec3(0.875,0.021,0.561) * f;\n    }\n    \n    float c = sin01(uvGrid.x);\n   // color = vec3(c, .5, .5);\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}