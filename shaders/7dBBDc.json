{
    "Shader": {
        "info": {
            "date": "1647252073",
            "description": "gradient",
            "flags": 0,
            "hasliked": 0,
            "id": "7dBBDc",
            "likes": 17,
            "name": "swirl camera zsj gradient",
            "published": 3,
            "tags": [
                "gradient"
            ],
            "usePreview": 0,
            "username": "zsjasper",
            "viewed": 400
        },
        "renderpass": [
            {
                "code": "//Shader License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)\n\n/*\n\tMany thanks to pik33. I was inspired by his shader: \n\thttps://www.shadertoy.com/view/wdcSzr\n\n\tI reused his idea to distort space using only sine functions, but I made it as a 3D volumetric plane.\n\n\tYou can switch to HIGH_QUALITY mode in the common tab :)\n\n\tPreview generated at 11.88 s.\n\n\t1.01 - add HIGH QUALITY\n\t1.02 - add balanced HIGH_QUALITY and vignette \n\t1.03 - lower flight\n*/\n\nvec3 colorFromUV(vec2 uv, float shift)\n{\n \treturn 0.7 + 0.3*cos(TIME * 0.2 + uv.xyx * 0.1 + vec3(0,2,4) + pow(shift, 4.0)); //XD\n}\n\nvec3 fancyLayer(vec2 uv, float cut)\n{\n    uv *= 0.1;\n\n    for (float i = DISTORTION_BASE_ITERATION; i <= DISTORTION_BASE_ITERATION + DISTORTION_ITERATIONS; i++)\n    {\n     \tuv.x += STRENGTH * sin(uv.y * pow(DISTORTION_POW, i) + TIME * DISTORTION_SPEED + i * 0.18) / pow(DISTORTION_POW, i);\n        uv.y += STRENGTH * sin(uv.x * pow(DISTORTION_POW, i) + TIME * DISTORTION_SPEED + i * 0.21) / pow(DISTORTION_POW, i);\n    }\n    \n    float fancyness = noise12(uv * 10.0 + TIME * 0.1 * 5.0);\n    float noise = noise12(uv * 2.0 + TIME * 0.5 + 21.0);\n    \n    vec3 col = colorFromUV(uv, noise);\n    \n    return smoothstep(cut - VOLUMETRIC_CUT_WIDTH, cut + VOLUMETRIC_CUT_WIDTH, fancyness) * (2.0 + fancyness) / 3.0 * col;\n}\n\n\nvec3 uvToCastPlane(vec2 uv)\n{\n \treturn vec3(uv.x, uv.y, -1.0 + sin(TIME * 0.2) * 0.2);   \n}\n\n//xy - plane uv\n//z - distance to plane point\nvec3 rayCastPlane(vec3 rayOrigin, vec3 rayDirection, float planeHeight)\n{\n    rayDirection /= rayDirection.y;\n    float distanceToPlane = abs(rayOrigin.y - planeHeight);\n    rayDirection *= distanceToPlane;\n    return vec3(rayOrigin.xz + rayDirection.xz, length(rayDirection));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    //Camera rotation and position\n    vec3 angle = vec3(-0.42 + cos(TIME * 0.3) * 0.08, sin(TIME * 0.2) * 0.5, cos(TIME * 0.21) * 0.1);\n    mat3x3 rotationMatrix = mat3x3(cos(angle.z), -sin(angle.z), 0.0,\n                                  sin(angle.z), cos(angle.z), 0.0,\n                                  0.0, 0.0, 1.0)\n        \t\t\t\t  * mat3x3(1.0, 0.0, 0.0,\n                                  0.0, cos(angle.x), -sin(angle.x),\n                                  0.0, sin(angle.x), cos(angle.x))\n        \t\t\t\t  * mat3x3(cos(angle.y), 0.0, -sin(angle.y),\n                                  0.0, 1.0, 0.0,\n                                  sin(angle.y), 0.0, cos(angle.y));\n    \n    vec3 cameraShift = vec3(0.0, sin(TIME * 0.24) * 0.12 - 0.36, TIME * 1.3);\n    \n    //Creating ray\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0) + cameraShift;\n    vec3 castPoint = uvToCastPlane(uv) * rotationMatrix + cameraShift;\n    vec3 rayDirection = castPoint - rayOrigin;\n    \n    //Raycast vase plane to get fog\n    vec3 planeUV = rayCastPlane(rayOrigin, rayDirection, -0.5);\n    float fog = 0.0;\n    if(rayDirection.y > 0.0) fog = 1.0;\n    else fog = sqrt(smoothstep(-0.1, FOG_DISTANCE, distance(cameraShift.xz, planeUV.xy)));\n\n    //ambient lighting\n    vec3 backgroundColor = colorFromUV(rayOrigin.xz, 0.0) * 0.3 * smoothstep(0.14, 0.0, abs(rayDirection.y - 0.02));\n    \n    //Adding many planes with small height differencies to create volumentric effect\n    vec3 col = vec3(0.0) + colorFromUV(rayOrigin.xz, 0.0) * 0.2;\n    \n    for (float i = 1.0; i <= LAYERS_COUNT ; i++)\n    {\n        planeUV = rayCastPlane(rayOrigin, rayDirection, -0.5 - i * LAYERS_DISTANCE - 1.0 * LAYERS_DISTANCE);\n        col += fancyLayer(planeUV.xy, 1.1 - pow(i / LAYERS_COUNT, 2.0)) * COLOR_MULTIPLIER * pow(0.99, i);\n    }\n    \n    //Mixing volumetric plane, fog and ambient lighting with some postprocessing\n    float vignette = smoothstep(2.5, 0.4, length(uv));\n\tcol = smoothstep(-0.0, 1.1, col * (1.0 - fog) + backgroundColor * fog) * vignette;\n    \n    //Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TIMESCALE 1.0\n\n//Uncoment if you have better PC\n//#define HIGH_QUALITY\n\n//Display parameters\n#ifdef HIGH_QUALITY \n\t#define STRENGTH 0.7\n    #define LAYERS_COUNT 200.0\n    #define LAYERS_DISTANCE 0.00225\n    #define COLOR_MULTIPLIER 0.05\n    #define NOISE_SHARPNESS 0.9\n    #define VOLUMETRIC_CUT_WIDTH 0.01\n    #define DISTORTION_POW 1.3\n    #define DISTORTION_SPEED 0.4\n    #define DISTORTION_BASE_ITERATION 8.0\n    #define DISTORTION_ITERATIONS 20.0\n    #define FOG_DISTANCE 17.0\n#else\n\t#define STRENGTH 0.7\n    #define LAYERS_COUNT 45.0\n    #define LAYERS_DISTANCE 0.0095\n    #define COLOR_MULTIPLIER 0.074\n    #define NOISE_SHARPNESS 1.0\n    #define VOLUMETRIC_CUT_WIDTH 0.05\n    #define DISTORTION_POW 1.3\n    #define DISTORTION_SPEED 0.4\n    #define DISTORTION_BASE_ITERATION 8.0\n    #define DISTORTION_ITERATIONS 15.0\n    #define FOG_DISTANCE 17.0\n#endif\n\n\n//Misc\n#define TIME (iTime * TIMESCALE)\n\n//Useful functions\nfloat hash12(vec2 x)   \n{\n    return fract(sin(dot(x, vec2(342.243, 234.4281))) * 235.2412);\n}\n\nfloat hash11(float x)   \n{\n    return fract(sin(x * 342.243) * 235.2412);\n}\n\nfloat noise12(vec2 uv)\n{\n \tvec2 rootUV = floor(uv);\n    vec2 fractUV = smoothstep(0.0, 1.0, fract(uv));\n    \n    float v00 = hash12(rootUV + vec2(0.0, 0.0));\n    float v01 = hash12(rootUV + vec2(0.0, 1.0));\n    float v10 = hash12(rootUV + vec2(1.0, 0.0));\n    float v11 = hash12(rootUV + vec2(1.0, 1.0));\n    \n    float v0 = mix(v00, v01, fractUV.y);\n    float v1 = mix(v10, v11, fractUV.y);\n    \n    return pow(mix(v0, v1, fractUV.x), NOISE_SHARPNESS);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}