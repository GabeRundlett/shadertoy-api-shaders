{
    "Shader": {
        "info": {
            "date": "1616167985",
            "description": "Controls:\nWASD - move\nMouse - view\nF - disaster mode\nG - RTX on/off\nR - reset player position",
            "flags": 48,
            "hasliked": 0,
            "id": "fdfGW8",
            "likes": 16,
            "name": "Anti-mass Spectrometer half life",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "halflife"
            ],
            "usePreview": 1,
            "username": "kosmaks",
            "viewed": 645
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST (30.)\n#define MIN_DIST (0.01)\n#define MAX_STEPS (100)\n\n#define ENABLE_GUARDS\n#define MODULE\n\n#ifdef ENABLE_GUARDS\n#define SD_GUARD(p, r) { float guardl = length(p); if (guardl - r * 1.1 > 0.) return guardl - r;}\n#else\n#define SD_GUARD(p, r) {}\n#endif\n\nfloat getBeamerRot() {\n    return iTime;\n}\n\nbool isDisasterMode() {\n    return isToggled(iChannel2, KEY_F);\n}\n\nbool isPoor() {\n    return isToggled(iChannel2, KEY_G);\n}\n\n// ===\n\nfloat marching_sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat marching_sdCylinder(vec3 p, float r) {\n  return length(p.xz) - r;\n}\n\nfloat marching_sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat marching_sdFloor(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float td, d = MAX_DIST;\n    float l = length(p.xz);\n    \n    // floor\n    d = p.y;\n    if (d < MIN_DIST) {\n        vec3 color = texture(iChannel1, p.xz / 10.).xyz;\n        m.diffuse = 1.5 * color.yzx* vec3(0.85, 0.3, 0.03);\n        //m.reflection = color * 0.2;\n        m.roughness = 0.1;\n        if (l > 5. || l < 4.7 && mod(theta + 0.1 + angle45, angle90) < 0.2) {\n            m.diffuse = color;\n        }\n        m.specular = vec4(m.diffuse, 20.);\n    }\n    \n    // tubes\n    theta = mod(theta + angle45, angle90) + angle45;\n    vec3 ap = vec3(l * cos(theta), p.y, l * sin(theta));\n    float curve = ap.z * 0.2;\n    curve = -abs(2. * curve - 1.) + 1.;\n    curve = max(0., curve) * 0.8;\n    td = marching_sdCylinder(abs(ap.yzx) - vec3(0., 0., curve), 0.1);\n    if (td < d) {\n        d = td;\n        m = mWhite;\n        m.diffuse = vec3(0.9);\n        m.specular = vec4(vec3(10.), 10.);\n    }\n    \n    // center\n    td = marching_sdCappedCylinder(p, 1.5 - p.y * 0.5, 0.2);\n    if (td < d) {\n        d = td;\n        if (d < MIN_DIST) {\n            m = mWhite;\n            m.diffuse = vec3(0.3) * texture(iChannel0, p.xz).x;\n        }\n    }\n    \n    // road  \n    p = qRotate(p, qCreateRotation(up, angle45));\n    \n    td = marching_sdBox(p - vec3(3.5, 0., 0.), vec3(2.5 , 0.1, 0.8));\n    if (td < d) {\n        d = td;\n        if (d < MIN_DIST) {\n            m = mWhite;\n            m.diffuse = mix(\n                vec3(0.3), \n                vec3(1., 1., 0.), \n                round(abs(sin((p.x + p.z * 0.2) * 10.)))\n            );\n        }\n    }\n    \n    td = -marching_sdBox(p - vec3(3.5, 0., 0.), vec3(2.5 , 0.2, 0.6));\n    if (td > d) {\n        d = td;\n        if (d < MIN_DIST) {\n            m = mWhite;\n            m.diffuse = vec3(0.3) * texture(iChannel0, p.xz).x;\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_sdDuct(vec3 p, out Material m) {\n    m = mWhite;\n    p = vec3(p.x, p.y, abs(p.z));\n    p -= vec3(-0.6, 0., 6.5);\n    \n    float d = length(p.xz) - 0.9;\n    float base = length(p.xz * vec2(0.8, 1.)) - 1.2;\n    float baseCutoff = smoothstep(0., 1., (p.y - 1.) * 1.);\n    base += baseCutoff * 1.2;\n    \n    float disp = -(clamp(cos(p.y * 10.), 0.9, 1.) - 0.9) * 0.2;\n    disp *= baseCutoff;\n    \n    d = min(d, base) + disp;\n    \n    if (d < MIN_DIST) {\n        vec3 col = texture(iChannel1, p.xy / 10.).xyz;\n        m.diffuse = col * 1.8;\n    }\n    \n    return d;\n}\n\nfloat marching_sdRoom(vec3 p, out Material m) {\n    m = mWhite;\n    vec3 ap = abs(p);\n    float r = 6., td;\n    \n    float l = length(p.xz);\n    float guard = r * 0.9 - l;\n    if (guard > 0.) return r - l;\n    \n    float di = r - (ap.x + ap.z) * 0.7071;\n    float sq = min(r - ap.x, r - ap.z);\n    \n    float angle = atan(ap.z / ap.x);\n    \n    // Walls\n    float disp = 1.;\n    disp *= (clamp(cos(angle * 18.5), -0.5, 0.5) + 0.5) * 0.2; // l1 grooves\n    //disp *= min(1., pow(6. * (p.y + 0.1) - 1., 10.)); // footer\n    disp *= min(1., pow(4. * (1.8 - p.y) - 1., 6.)); // l1 bars\n    //disp *= min(1., pow(10. * (3. - p.y) - 1., 2.)); // l2 bars\n    disp *= smoothstep(1., 0., (p.y - 3.5) * 10.); // cutoff grooves\n    disp *= 1. - smoothstep(0., 1., (p.y - 3.) * 10.) * 0.6; // shallow l3 grooves\n    float disp2 = (clamp(cos(angle * 18.5), -0.7, -0.6) + 0.7) * 0.5;\n    disp2 *= smoothstep(0., 1., (p.y - 3.7) * 10.);\n    disp2 *= min(1., pow(10. * mod(p.y - 3.5, 2.) - 1., 6.)); // l1 bars\n    disp += disp2;\n    disp *= smoothstep(1., 0., (p.y - 9.) * 30.);\n    float d = min(sq, di) + disp;\n    \n    if (d < MIN_DIST) {\n        if (p.y < 9.) {\n            vec3 color = texture(iChannel0, vec2(angle * 10., p.y)).xyz;\n            m.diffuse = vec3(0.7, 0.5, 0.1) + color * 0.1;\n            //m.reflection = vec3(1.);\n        }\n        \n        if (p.y > 8.) {\n            m.diffuse *= vec3(max(0., 9. - p.y));\n        }\n    }\n    \n    // Door\n    vec3 doorp = qRotate(p, qCreateRotation(up, angle45));\n    doorp -= vec3(.3, 0.8, 6.1);\n    float doorDisp = min(0., sin(p.y * 9.5)) * 0.05;\n    td = -marching_sdBox(doorp, vec3(1., 1., 0.2 + doorDisp));\n    if (td > d) {\n        d = td;\n        if (d < MIN_DIST) {\n            vec3 tex = texture(iChannel1, doorp.xy / 8.).xyz;\n            m.reflection = tex * 0.5;\n            m.diffuse = tex;\n            m.roughness = 0.04;\n        }\n    }\n    \n    // Window\n    doorp = qRotate(p, qCreateRotation(up, -angle45));\n    doorp -= vec3(0., 2.8, 6.1);\n    td = -marching_sdBox(doorp, vec3(1.5, 0.3, 0.2));\n    if (td > d) {\n        d = td;\n        if (d < MIN_DIST) {\n            vec3 tex = texture(iChannel1, doorp.xy / 8.).xyz;\n            m.reflection = tex * 0.5;\n            m.diffuse = tex;\n            m.roughness = 0.04;\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_sdResArm(vec3 p, out Material m) {\n    float d = MAX_DIST;\n    \n    d = min(d, marching_sdBox(p - vec3(1., 0., 0.), \n        vec3(0.4, 0.8, 0.2 * ( 0.6 + 0.6 * (p.x - 0.6)/0.8 ))));\n    d = min(d, marching_sdBox(p - vec3(1.4, 0.6, 0.), \n        vec3(0.5, 0.2 + ( 0.2 - 0.2 * (p.x - 1.)/0.8 ), 0.16)));\n        \n    d = min(d, marching_sdBox(p - vec3(1.74 + (p.y-0.6) * 0.08, 1.2, 0.), \n        vec3(0.16, 0.6, 0.16)));\n        \n    d = min(d, 0.5 * marching_sdBox(p - vec3(1.4 + (p.y - 1.8) * 1.2, 2.0, 0.), \n        vec3(0.6 * (1. - (p.y - 1.8)/0.6 ), 0.2, 0.16)));\n    \n    if (d < MIN_DIST) {\n        vec3 tex = texture(iChannel1, p.xy / 1.).xyz;\n        m.diffuse = tex * vec3(0.8, 1., 1.) * 2.;\n        //m.reflection = vec3(0.3);\n        //m.roughness = 0.1;\n    }\n        \n    return d;\n}\n\nfloat marching_sdRes(vec3 p, out Material m) {\n    m = mWhite;\n    Material tm;\n    \n    SD_GUARD(p - vec3(0., 1., 0.), 2.4);\n    //return length(p - vec3(0., 1., 0.)) - 2.;\n    p = qRotate(p, qCreateRotation(up, 3.14-angle45));\n    float d = max(\n        marching_sdCappedCylinder(p, 1., 0.4),\n        -marching_sdCylinder(p, 0.6)\n    );\n    \n    if (d < MIN_DIST) {\n        m.diffuse = texture(iChannel1, p.xz).xyz * vec3(0.5, 1., 0.5);\n        m.reflection = vec3(0.5, 1., 0.5);\n    }\n    \n    float arm = marching_sdResArm(abs(p), tm);\n    arm = min(arm, marching_sdResArm(p.zyx, tm));\n    if (arm < d) {\n        d = arm;\n        m = tm;\n    }\n    \n    return d;\n}\n\nfloat marching_sdSheild(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float r = 2.;\n    float h = 1.;\n    float sr = r * 0.4;\n    \n    p -= vec3(0., 9. - h, 0.);\n    \n    // 6 bars\n    float l = length(p.xz);\n    theta = mod(theta, angle60) - angle30;\n    vec2 ap = vec2(cos(theta), sin(theta)) * l;\n    ap = abs(ap);\n    float c = rot2d(ap, rotMin15).y;\n    float d = max(max(l - r, -c), -l + sr);\n    \n    // cap\n    d = max(d, marching_sdCappedCylinder(p, r, h));\n    \n    // cone\n    p.y += h;\n    float cone = length(p.xz) - (p.y * 1.2 + 1.5);\n    d = max(cone, d);\n    \n    if (d < MIN_DIST) {\n        vec3 tex = texture(iChannel1, ap.xy).xyz;\n        m.diffuse = tex * 2.;\n        m.specular = vec4(m.diffuse, 10.);\n    }\n    \n    return d;\n}\n\nfloat marching_sdCore(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float r = 1.;\n    float h = 0.8;\n    p -= vec3(0., 9. - h, 0.);\n    \n    float disp = cos(theta * 10. + iTime * 60.) * 0.1;\n    float d = MAX_DIST;\n    d = min(d, marching_sdCappedCylinder(p, r + disp, h));\n    \n    return d;\n}\n\nfloat marching_sdBeamer(vec3 p) {\n    vec3 ap = abs(p);\n    float fallout = mix(0.2, 0., ap.y - 0.1);\n    return marching_sdCappedCylinder(ap - vec3(0., 0.19, 0.), fallout, 0.15);\n}\n\nfloat marching_sdBeamers(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    p -= vec3(0., 6.5, 0.);\n    \n    theta = mod(theta + getBeamerRot(), angle120);\n    float l = length(p.xz);\n    vec3 ap = vec3(cos(theta) * l, p.y, sin(theta) * l);\n    float d = marching_sdBeamer(ap - vec3(1., 0., sq3) * 0.7);\n    return d;\n}\n\nfloat marching_sdLaser(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    p -= vec3(0., 6.5, 0.);\n    \n    theta = mod(theta, angle60) / angle60;\n    float disp = min(1., pow(5. * theta - 2., 10.)) * 0.02;\n    float r = 0.3 + disp;\n    float fallout = clamp(p.y * 3. + 1.5, 0., 1.);\n    r *= fallout;\n\n    return marching_sdCappedCylinder(p, r, 0.35);\n}\n\nfloat marching_sdTile(vec3 p, float w, float h) {\n    float r = 6.;\n    float size = tan225 * p.x;\n    float d = marching_sdBox(p - vec3(r, 0., 0.), vec3(w, h, size));\n    return d;\n}\n\nfloat marching_sdFloorTiles(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float w = 3., h = 0.2, td;\n    \n    theta = mod(theta - angle45, angle90) - angle45;\n    float l = length(p.xz);\n    p = vec3(l * cos(theta), p.y, l * sin(theta));\n    float d = marching_sdTile(p, w, h);\n    if (d < MIN_DIST) {\n        m.diffuse = vec3(0.97, 0.58, 0.02) * (texture(iChannel0, p.xz).x * 0.5 + 0.5);\n    }\n    \n    vec2 grid = max(sin(p.xz * vec2(40., 34.)), 0.);\n    float gridDisp = max(grid.x, grid.y);\n    td = marching_sdBox(p - vec3(4.6, 0., 0.), vec3(0.4, 0.202 + gridDisp * 0.01, 0.6));\n    if (td < d) {\n        d = td;\n        m.diffuse = vec3(0.);\n        m.reflection = round(gridDisp) * vec3(0.9, 0.7, 0.5);\n    }\n    \n    p = qRotate(p - vec3(3., 0., 0.), qForwAngle45);\n    \n    td = marching_sdBox(p, vec3(0.15, 0.15, 0.4));\n    if (td < d) {\n        d = td;\n        m.diffuse = vec3(0.2);\n    }\n    \n    td = marching_sdBox(p, vec3(0.17, 0.1, 0.34));\n    if (td < d) {\n        d = td;\n        m.emission = vec3(1.);\n    }\n    \n    return d;\n}\n\nfloat marching_sdRailing(vec3 p) {\n    float r = 4.2;\n    float rr = 0.03;\n    float hr = 0.05;\n    float h = 0.3;\n    \n    float len = tan225 * r * 0.9;\n    \n    float d = MAX_DIST;\n    \n    vec3 ap = vec3(p.x, p.y, abs(p.z));\n    d = min(d, marching_sdCappedCylinder(ap - vec3(r, h, len * 0.8), rr, h));\n    d = min(d, marching_sdBox(p - vec3(r, 2. * h, 0.), vec3(hr, rr, len)));\n    \n    return d;\n}\n\nfloat marching_sdFirstFloor(vec3 p, out Material m) {\n    m = mWhite;\n    float w = 1.9, h = 1.;\n    \n    float d = MAX_DIST;\n    \n    vec3 y = vec3(0., h, 0.);\n    \n    p = rot3d(p, up, -angle90 - angle45);\n    d = min(d, marching_sdBox(p - vec3(0., 0., 4.), vec3(0.8, 0.5, 0.3)));\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p - y));\n    p = rot3d(p, up, angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p - y));\n    p = rot3d(p, up, angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    \n    \n    if (d < MIN_DIST) {\n        if (p.y > 1.03) {\n            m.reflection = vec3(0.7);\n        } else if (p.y > 0.97) {        \n            m.diffuse = 0.97 * (texture(iChannel0, p.xz).xxx * 0.5 + 0.5);\n        } else {\n            m.diffuse = vec3(0.97, 0.58, 0.02) * (texture(iChannel0, vec2(p.x + p.z, p.y)).xyz * 0.5 + 0.5);\n            m.specular = vec4(vec3(m.diffuse), 10.);\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_sdSecondFloor(vec3 p, out Material m) {\n    m = mWhite;\n    float d = MAX_DIST;\n    \n    float w = 1.9, h = 0.1;\n    p -= vec3(0., 5.5, 0.);\n    p = rot3d(p, up, -angle90 - angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p));\n    p = rot3d(p, up, -angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p));\n    \n\n    if (d < MIN_DIST) {\n        if (p.y > 0.13) {\n            m.reflection = vec3(0.7);\n        } else if (p.y > 0.07 || p.y < 0.07) {        \n            m.diffuse = 0.97 * (texture(iChannel0, p.xz).xxx * 0.5 + 0.5);\n        } else {\n            m.diffuse = vec3(0.97, 0.58, 0.02) * (texture(iChannel0, vec2(p.x + p.z, p.y)).xyz * 0.5 + 0.5);\n            m.specular = vec4(vec3(m.diffuse), 10.);\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_getDist(vec3 p, out Material m) {\n    Material tm;\n    m = mWhite;\n    float d = MAX_DIST + 1., td;\n    float tanzx = atan(p.z, p.x);\n    \n    td = marching_sdRoom(p, tm);\n    if (td < d) { d = td; m = tm; }\n    \n    if (p.y > 0.3) {\n        d = min(d, p.y - 0.2);\n    } else {\n        td = marching_sdFloor(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdFloorTiles(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n    }\n    \n    if (p.y > 2.) {\n        d = min(d, p.y - 1.5);\n    } else {\n        td = marching_sdFirstFloor(p, tm);\n        if (td < d) { d = td; m = tm; }\n    }\n    \n    float s = length(p - vec3(0., 8., 0.));\n    if (s - 3. > 0.) {\n        d = min(d, s - 2.5);\n    } else {\n        td = marching_sdSheild(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdCore(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdBeamers(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdLaser(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n    }\n    \n    if (td < d) { d = td; m = tm; }\n    td = marching_sdRes(p, tm);\n    if (td < d) { d = td; m = tm; }\n    td = marching_sdSecondFloor(p, tm);\n    if (td < d) { d = td; m = tm; }\n    return d;\n}\n\nvec3 marching_getNormal(vec3 p) {\n    Material m;\n    float dist = marching_getDist(p, m);\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = dist - vec3(\n        marching_getDist(p - e.xyy, m),\n        marching_getDist(p - e.yxy, m),\n        marching_getDist(p - e.yyx, m));\n    return normalize(n);\n}\n\nfloat marching_castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    float totalDist = 0.;\n    \n    int i = 0;\n    for (; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        totalDist += d;\n        if (abs(d) < MIN_DIST || totalDist > MAX_DIST) break;\n    }\n    \n    if (i == MAX_STEPS - 1) totalDist = MAX_DIST + 1.;\n    \n    if (totalDist < MAX_DIST) {\n        touch = ro + totalDist * rd;\n        n = marching_getNormal(touch);\n    }\n    \n    return totalDist;\n}\n\nfloat marching_softShadow(vec3 ro, vec3 rd, float k, float mind, float maxd) {\n    Material m;\n    float totalDist = 0.1;\n    float res = 1.;\n    for (int i = 0; i < 20; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        res = min(res, k * d / totalDist);\n        if (abs(d) < mind) return 0.;\n        totalDist += d;\n        if (totalDist > maxd) break;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\n// ====\n\nfloat int_plane(vec3 ro, vec3 rd, vec3 n, float d) {\n    float dist = -(d + dot(n, ro)) / dot(n, rd);\n    return dist;\n}\n\nvec2 int_lightning(vec3 ro, vec3 rd, vec3 start, vec3 end, float intensity, float jiggle) {\n    vec3 n = normalize(end - start);\n    float theta = acos(dot(up, n));\n    float phi = atan(n.z, n.x);\n    \n    Quat xRot = qCreateRotation(forw, theta);\n    Quat yRot = qCreateRotation(up, phi);\n    Quat rot = qMul(qMul(yRot, xRot), yRot);\n    \n    vec3 initialRo = ro;\n    vec3 sdir = start - ro;\n    ro -= start;\n    ro = qRotate(ro, rot);\n    rd = qRotate(rd, rot);\n\n    vec3 pn = normalize(vec3(rd.x, 0., rd.z));\n    float t = int_plane(ro, rd, pn, 0.);\n    if (t < 0.01) return vec2(MAX_DIST, 0.);\n    vec3 touch = ro + t * rd;\n    \n    float halflen = distance(start, end) / 2.;\n    float dim = max(0., -pow((touch.y - halflen) / halflen, 4.) + 1.);\n    \n    float power = 0.;\n    \n    if (dim > 0.01) {\n        float time = iTime;\n        vec3 tex = texture(iChannel0, vec2(time, touch.y / 40.)).xyz;\n        vec2 disp = tex.xy * 2. - 1.;\n        disp *= 0.4;\n        disp += 0.1 * (texture(iChannel0, vec2(time + 0.1, touch.y / 5.)).xy * 2. - 1.);\n        disp *= vec2(dot(forw, pn), dot(right, pn));\n        disp *= dim;\n        disp *= jiggle;\n        \n        vec2 pr = normalize(cross(up, pn)).xz;\n        float dist = length(touch.xz - pr * (disp.x + disp.y));\n        \n        float varpow = mix(10., 100., tex.z);\n        power = exp(-dist * varpow * intensity) * dim;\n    }\n    \n    if (power < 0.001) {\n        return vec2(MAX_DIST, power);\n    }\n\n    return vec2(t, power);\n}\n\nfloat int_castRay(vec3 ro, vec3 rd, float intensity, out vec3 light) {\n    float d = MAX_DIST;\n    \n    float angle = getBeamerRot();\n    vec3 first = rot3d(vec3(-1.4, 6.5, 0.), up, angle);\n    vec3 second = rot3d(vec3(0.7, 6.5, sq3 * 0.7), up, angle);\n    vec3 third = rot3d(vec3(0.7, 6.5, -sq3 * 0.7), up, angle);\n    \n    vec2 t1 = int_lightning(ro, rd, vec3(0., 6.5, 0.), first, intensity, 1.);\n    d = min(d, t1.x);\n    vec2 t2 = int_lightning(ro, rd, vec3(0., 6.5, 0.), second, intensity, 1.);\n    d = min(d, t2.x);    \n    vec2 t3 = int_lightning(ro, rd, vec3(0., 6.5, 0.), third, intensity, 1.);\n    d = min(d, t3.x);\n    \n    vec2 l1 = int_lightning(ro, rd, vec3(0., 0., 0.), first, intensity, 1.);\n    d = min(d, l1.x);\n    vec2 l2 = int_lightning(ro, rd, vec3(0., 0., 0.), second, intensity, 1.);\n    d = min(d, l2.x);\n    vec2 l3 = int_lightning(ro, rd, vec3(0., 0., 0.), third, intensity, 1.);\n    d = min(d, l3.x);\n    \n    vec2 main = int_lightning(ro, rd, vec3(0., 0., 0.), vec3(0., 7., 0.), intensity * 0.3, 0.);\n    d = min(d, main.x);  \n\n    bool disaster = isDisasterMode();\n\n    vec3 shortCol = vec3(1., 0.6, 0.);\n    if (disaster) shortCol = vec3(0.1, 1., 0.);\n    light = (l1.y + l2.y + l3.y) * shortCol\n          + (t1.y + t2.y + t3.y + main.y) * vec3(1., 1., 0.8);\n    \n    if (disaster) {\n        if (sin(iTime * 10.) < 0.4) {\n            float key = floor(iTime) / 100.;\n            vec2 tex = texture(iChannel0, vec2(key, 0.)).xy;\n            float theta = tex.x * twopi;\n            vec3 target = vec3(cos(theta), 0., sin(theta)) * 6.;\n            target.y = 7. * tex.y;\n            \n            vec2 ray = int_lightning(ro, rd, vec3(0., 0., 0.), target, intensity, 1.);\n            d = min(d, ray.x);\n            light += ray.y * shortCol;\n        }\n    }\n    \n    return d;\n}\n\n// ====\n\nvec3 getLightningPos(vec3 touch) {\n    return vec3(0., clamp(touch.y, 1., 5.), 0.);\n}\n\nvec3 castLightning(vec3 touch, vec3 n) {\n    vec3 lp = getLightningPos(touch);\n    vec3 l = lp - touch;\n    vec3 ld = normalize(l);\n    vec3 lo = touch + n * 0.1;\n    vec3 rad = vec3(dot(n, ld) * 0.8);\n    if (!isPoor()) {\n        vec3 lightning;\n        int_castRay(lo, ld, 0.01, lightning);\n        rad *= lightning * 0.6;\n        rad *= marching_softShadow(lo, ld, 15., 0.01, 3.);\n        rad *= marching_softShadow(lo, ld, 1., 0.1, 0.1);\n    }\n    return rad;\n}\n\nfloat castLightningSpecular(vec3 touch, vec3 rd, vec3 n) {\n    vec3 lp = getLightningPos(touch);\n    vec3 l = lp - touch;\n    vec3 ld = normalize(l);\n    vec3 lo = touch + n * 0.1;\n    float specular = dot(reflect(normalize(touch - lp), n), -rd);\n    return max(0., specular);\n}\n\nvec3 castNormalLight(vec3 touch, vec3 n) {\n    vec3 lp = vec3(5., 10., 0.);\n    vec3 l = lp - touch;\n    vec3 ld = normalize(l);\n    vec3 lo = touch + n * 0.1;\n    vec3 rad = vec3(1., 0.8, 0.67) * dot(n, ld) * 0.6;\n\n    //rad *= marching_softShadow(lo, ld, 10., 3.);\n    return rad;\n}\n\nvec3 castLight(vec3 touch, vec3 n) {\n    return castNormalLight(touch, n) + castLightning(touch, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float vpWindow = 2. / iResolution.y;\n    vec2 vpShift = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 vp = fragCoord * vpWindow - vpShift;\n    \n    vec3 col = vec3(0.);\n    \n    float rot = iMouse.x / 100.;\n    vec3 ro = sampleCell(iChannel3, CELL_CAMERA_POS).xyz;\n    vec3 rt = ro + sampleCell(iChannel3, CELL_CAMERA_DIR).xyz;\n    vec3 rd = getInitialRD(vp, ro, rt, 1.2);\n    \n    float effect = isDisasterMode() ? 0.01 : 0.001;\n    rd += vec3(0., sin(iTime  * 40.) * effect, 0.);\n    rd = normalize(rd);\n    \n    Material m;\n    vec3 touch, n, lightning;\n    float di, d;\n    \n    vec3 totalRad = vec3(0.), scaler = vec3(1.);\n    \n    bool poor = isPoor();\n    \n    for (int i = 0; i < 2; ++i) {\n        d = marching_castRay(ro, rd, m, touch, n);\n        \n        di = int_castRay(ro, rd, 1., lightning);\n        \n        if (d >= MAX_DIST) {\n            break;\n        }\n        \n        if (di < d) {\n            totalRad += scaler * lightning * 5.;\n        }\n        \n        if (touch.y > 9.) break;\n        \n        if (m.emission != vec3(0.)) {\n            totalRad += scaler * m.emission;\n        } else {\n            totalRad += m.diffuse * scaler * castLight(touch, n);\n        }\n        \n        if (m.specular != vec4(0.)) {\n            float specular = castLightningSpecular(touch, rd, n);\n            totalRad += scaler * m.specular.xyz * pow(specular, m.specular.w);\n        }\n        \n        if (poor) {\n            break;\n        }\n        \n        if (m.reflection == vec3(0.)) {\n            break;\n        }\n        \n        scaler *= m.reflection;\n        ro = touch + n * 0.01;\n        rd = reflect(rd, n);\n        \n        if (m.roughness > 0.) {\n            rd += m.roughness * (texture(iChannel0, touch.xy).xyz * 2. - 1.);\n            rd = normalize(rd);\n        }\n    }\n    \n    col = totalRad / 1.5;\n    \n    if (!poor) {\n        col *= vec3(0.65, 0.9, 1.);\n        col = mix(vec3(0.05), vec3(1.2), col);\n    }\n    \n    //col = texture(iChannel3, uv).xyz;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nstruct Quat { vec4 value; };\n\nconst vec3 up = vec3(0., 1., 0.);\nconst vec3 right = vec3(1., 0., 0.);\nconst vec3 forw = vec3(0., 0., 1.);\nconst float pi = 3.1415;\nconst float twopi = 2. * 3.1415;\nconst float sq3 = 1.7321;\nconst float angle90 = 1.5708;\nconst float angle60 = 1.0472;\nconst float angle30 = 0.5234;\nconst float angle15 = 0.2618;\nconst float angle120 = 2.0944;\nconst float angle45 = 0.7853;\nconst float angle225 = angle45 / 2.;\nconst float tan225 = 0.4142;\nconst vec2 rotMin15 = vec2(cos(-angle15), sin(-angle15));\nconst Quat qForwAngle45 = Quat(vec4(forw * 0.3827, 0.9239));\n\nstruct Material {\n    vec3 emission;\n    vec3 diffuse;\n    vec3 reflection;\n    vec4 specular;\n    float roughness;\n};\n\nconst Material mWhite = Material(\n    vec3(0.),\n    vec3(1.),\n    vec3(0.),\n    vec4(0.),\n    0.\n);\n\nvec3 getInitialRD(vec2 vp, vec3 origin, vec3 target, float d) {\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(up, forward));\n    vec3 up = cross(forward, right);\n    return normalize(d * forward + right * vp.x + up * vp.y);\n}\n\nvec2 rot2d(vec2 v, vec2 c) {\n    return vec2(v.x * c.x - v.y * c.y, v.x * c.y + v.y * c.x);\n}\n\n\n// State\n\n#define GRID_SIZE (10.)\n#define GRID_CELL (1. / GRID_SIZE)\n#define GRID_HALF vec2(GRID_CELL * 0.5)\n#define CLOSE(x, y) (abs(x - y) < 0.001)\n#define IS_CELL(c, a) (CLOSE(c.x, a.x) && CLOSE(c.y, a.y))\n#define CELL_CAMERA_POS (vec2(0., 0.))\n#define CELL_CAMERA_DIR (vec2(1., 0.))\n#define CELL_MOUSE_STATE (vec2(2., 0.))\n#define CELL_MOUSE_DIR (vec2(3., 0.))\n\nvec2 getGridCell(vec2 uv) {\n    vec2 scaled = uv * GRID_SIZE;\n    vec2 vertex = floor(scaled);\n    vec2 center = vertex + 0.5;\n    return distance(scaled, center) < 0.5 ? vertex : vec2(-1.);\n}\n\nvec4 sampleCell(sampler2D tex, vec2 index) {\n    return texture(tex, index / GRID_SIZE + GRID_HALF);\n}\n\n// Quaternions\n\nQuat qCreateRotation(vec3 axis, float angle) {\n    float ah = angle / 2.;\n    return Quat(vec4(axis.xyz * sin(ah), cos(ah)));\n}\n\nQuat qMul(Quat qa, Quat qb) {\n    vec4 a = qa.value;\n    vec4 b = qb.value;\n    return Quat(vec4(\n        a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz),\n        a.w * b.w - dot(a.xyz, b.xyz)\n    ));\n}\n\nQuat qConj(Quat q) {\n    return Quat(vec4(-q.value.xyz, q.value.w));\n}\n\nvec3 qRotate(vec3 v, Quat q) {\n    vec3 temp = cross(q.value.xyz, v) + q.value.w * v;\n    return v + 2. * cross(q.value.xyz, temp);\n}\n\nvec3 rot3d(vec3 v, vec3 axis, float angle) {\n    return qRotate(v, qCreateRotation(axis, angle));\n}\n\n\n#define KEY_W (87.0)\n#define KEY_A (65.0)\n#define KEY_S (83.0)\n#define KEY_D (68.0)\n#define KEY_R (82.0)\n#define KEY_F (70.0)\n#define KEY_G (71.0)\n\nbool isPressed(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}\n\nbool isToggled(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.75);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define INITIAL_POS (vec3(0., 1., 3.))\n#define INITIAL_DIR (vec3(0., 0.5, -1.))\n\nfloat getPlayerY(vec2 xz) {\n    float l = length(xz);\n    float theta = atan(xz.y, xz.x) + pi;\n\n    if (l > 4. && theta > angle225 && theta < angle90 + angle45 + angle225) {\n        return 2.;\n    }\n        \n    if (l > 3.6 && theta > angle90 + angle225 && theta < angle90 + angle45 + angle225) {\n        return 1.5;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    bool isInitial = iFrame == 0 || \n        isPressed(iChannel1, KEY_R);\n    \n    vec2 cell = getGridCell(uv);\n    if (cell.y > 1.) return;\n    \n    if (IS_CELL(cell, CELL_CAMERA_POS)) {\n        col = INITIAL_POS;\n        if (!isInitial) col = sampleCell(iChannel0, CELL_CAMERA_POS).xyz;\n        \n        if (isPressed(iChannel1, KEY_W)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            col += dir * 0.1;\n        } if (isPressed(iChannel1, KEY_S)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            col -= dir * 0.1;\n        } \n        \n        if (isPressed(iChannel1, KEY_D)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            vec3 right = cross(up, dir);\n            col += right * 0.1;\n        } else if (isPressed(iChannel1, KEY_A)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            vec3 right = cross(up, dir);\n            col -= right * 0.1;\n        }\n        \n        col.y = getPlayerY(col.xz);\n        \n        float theta = atan(col.z, col.x);\n        float l = length(col.xz);\n        l = min(5.5, l);\n        col.xz = vec2(cos(theta), sin(theta)) * l;\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    if (IS_CELL(cell, CELL_CAMERA_DIR)) {\n        col = INITIAL_DIR;\n        if (!isInitial) col = sampleCell(iChannel0, CELL_CAMERA_DIR).xyz;\n        \n        if (iMouse.z > 0.2) {\n            vec3 mouseState = vec3(0.);\n            if (!isInitial) mouseState = sampleCell(iChannel0, CELL_MOUSE_STATE).xyz;\n            vec3 mouseDir = vec3(0.);\n            if (!isInitial) mouseDir = sampleCell(iChannel0, CELL_MOUSE_DIR).xyz;\n            if (mouseState.z > 0.2) {\n                vec2 mdiff = iMouse.xy / iResolution.xy - mouseState.xy;\n                mdiff *= vec2(-1., 1.) * 10.;\n                float theta = atan(mouseDir.z, mouseDir.x) + mdiff.x;\n                float phi = atan(mouseDir.y, length(mouseDir.xz)) + mdiff.y;\n                phi = clamp(phi, -angle90, angle90);\n                col = vec3(cos(theta), sin(phi), sin(theta));\n            }\n        }\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    if (IS_CELL(cell, CELL_MOUSE_STATE)) {\n        col = vec3(0.);\n        if (!isInitial) col = sampleCell(iChannel0, CELL_MOUSE_STATE).xyz;\n        if (iMouse.z > 0.2) {\n            if (col.z < 0.2) {\n                col = vec3(iMouse.xy / iResolution.xy, 1.);\n            }\n        } else {\n            col = vec3(0.);\n        }\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    if (IS_CELL(cell, CELL_MOUSE_DIR)) {\n        col = vec3(0.);\n        if (!isInitial) col = sampleCell(iChannel0, CELL_MOUSE_DIR).xyz;\n        \n        vec3 mouseState = vec3(0.);\n        if (!isInitial) mouseState = sampleCell(iChannel0, CELL_MOUSE_STATE).xyz;\n        \n        if (iMouse.z > 0.2) {\n            if (mouseState.z < 0.2) {\n                vec3 cd = INITIAL_DIR;\n                if (!isInitial) cd = sampleCell(iChannel0, CELL_CAMERA_DIR).xyz;\n                col = vec3(cd);\n            }\n        } else {\n            col = vec3(0.);\n        }\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}