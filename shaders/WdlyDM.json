{
    "Shader": {
        "info": {
            "date": "1584912116",
            "description": "Mouse to zoom.\n1,2,3: toggle layers\nP: toggle points\nD: toggle debug rings",
            "flags": 16,
            "hasliked": 0,
            "id": "WdlyDM",
            "likes": 12,
            "name": "Endless Voronoi",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "zoom",
                "endless"
            ],
            "usePreview": 0,
            "username": "jerky",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "// This is free and unencumbered software released into the public domain.\n// https://unlicense.org/UNLICENSE\n\n#define RANK_1           6\n#define RANK_2           7\n#define RANK_3           9\n#define ZOOM_SPEED_1     2.\n#define ZOOM_SPEED_2     3.\n#define ZOOM_SPEED_3     5.\n#define ROTATE_SPEED_1  10.\n#define ROTATE_SPEED_2  -5.\n#define ROTATE_SPEED_3   3.\n#define SATURATION_1     1.0\n#define SATURATION_2     0.5\n#define SATURATION_3     0.75\n#define POINT_SIZE       0.0002\n\n/* library */\n\nconst float PI = radians(180.f);\nconst float TAU = radians(360.f);\n\nfloat length2(vec2 p) { return p.x * p.x + p.y * p.y; }\nint idiv(int a, int b) { return (a + (a > 0 ? b - 1 : 0)) / b; }\n\nvec3 hsv2rgb(float h, float s, float v) {\n    h = fract(h) * 6.;\n    float c = v * s;\n    float x = c * (1. - abs(mod(h, 2.) - 1.));\n    float m = v - c;\n    switch (int(h)) {\n        case 6:\n        case 0: return m + vec3(c, x, 0);\n        case 1: return m + vec3(x, c, 0);\n        case 2: return m + vec3(0, c, x);\n        case 3: return m + vec3(0, x, c);\n        case 4: return m + vec3(x, 0, c);\n        case 5: return m + vec3(c, 0, x);\n    }\n}\n\nbool keyToggle(int key) {\n    return texelFetch(iChannel0, ivec2(key, 2), 0).x > 0.;\n}\n\n/* voronoi */\n\nfloat res_d = 1./0.;\nvec3 res_color = vec3(0, 0, 0);\nvec2 p;\nint debug_rings = 0;\n\nvoid add_point(vec2 pos, vec3 color) {\n    float distance_from_center = length2(p);\n    float d = length2(pos - p.xy);\n    if (res_d < d)\n        return;\n    res_d = d;\n    res_color = !keyToggle(80/*p*/) && d < distance_from_center * POINT_SIZE\n        ? color * 0.8\n        : color * atan(distance_from_center / d / 2.) / PI * 2.;\n}\n\n// This function adds an infinity number of nested rings to the Voronoi Diagram.\n// The ring is a group of points at the same radius. Each ring consists of\n// `rank` points.\n//\n// The trick is, for each pixel, this function is checking only three possible\n// points: one in the ring above, one in the ring bellow, and one in two rings\n// bellow.\nvoid endless(int rank, float zoom, float rotation, float sat) {\n    if (rank <= 2) return;\n    float ring_dist = (1. + sin(PI / float(rank))) / cos(PI / float(rank));\n    zoom *= float(rank);\n\n    int center_ring = int(floor(log(length2(p)) / 2. / log(ring_dist) - zoom));\n    float alpha = (atan(p.y, p.x) / TAU - rotation) * float(rank);\n    float alpha1 = floor(alpha + 0.5) / float(rank);\n    float alpha2 = floor(alpha) / float(rank);\n\n    debug_rings += center_ring;\n    for (int ring = center_ring - 1; ring <= center_ring + 1; ring++) {\n        float shift = float(abs(ring) % 2) / 2. / float(rank);\n        float color_shift = float(idiv(3 * ring, 2)) / float(rank);\n        float d = abs(ring) % 2 == 0 ? alpha1 : alpha2;\n        float t = (rotation + shift + d) * TAU;\n        vec2 pos = pow(ring_dist, float(ring) + zoom) * vec2(cos(t), sin(t));\n        add_point(pos, hsv2rgb(d + color_shift, sat, 1.));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    p.xy = (fragCoord.xy - iResolution.xy / 2.) * pow(2., 20. * iMouse.x / iResolution.x);\n    float rot = iTime / 1000.;\n    float zoom = iTime / 100.;\n\n    if (!keyToggle(49/*1*/))\n        endless(RANK_1, zoom * ZOOM_SPEED_1, rot * ROTATE_SPEED_1, SATURATION_1);\n    if (!keyToggle(50/*2*/))\n        endless(RANK_2, zoom * ZOOM_SPEED_2, rot * ROTATE_SPEED_2, SATURATION_2);\n    if (keyToggle(51/*3*/))\n        endless(RANK_3, zoom * ZOOM_SPEED_3, rot * ROTATE_SPEED_3, SATURATION_3);\n\n    float debug_shade = keyToggle(68/*d*/) ? float(debug_rings % 2) / 4. + 0.5 : 1.;\n\n    fragColor = vec4(res_color, 1.) * debug_shade;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}