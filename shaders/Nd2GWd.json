{
    "Shader": {
        "info": {
            "date": "1618161896",
            "description": "Numerically finding the intersections with a quintic surface.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nd2GWd",
            "likes": 10,
            "name": "Quintic Surface Intersect I",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "raycasting",
                "surface",
                "intersect",
                "quintic",
                "numeric"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 196
        },
        "renderpass": [
            {
                "code": "#define ZERO min(iFrame, 0)\n\nstruct Params {\n    float bmin;\n    float bmax;\n    float epsilon;\n    bool wrap;\n    int searches;\n    int iters;\n};\n\nstruct Roots5 {\n    int nroots;\n    float[5] roots;\n};\n\nfloat evalQuintic(in float x, in float a, in float b, in float c, in float d, in float e, in float f) {\n    return ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n}\n\nfloat evalQuinticPrime(in float x, in float a, in float b, in float c, in float d, in float e, in float f) {\n    return (((5.0 * a * x + 4.0 * b) * x + 3.0 * c) * x + 2.0 * d) * x + e;\n}\n\n// Can be made much simpler if your only looking for the closest intersection\nRoots5 solveQuintic(in float a, in float b, in float c, in float d, in float e, in float f, in Params params) {\n    float[5] rootArray;\n    Roots5 roots = Roots5(0, rootArray);\n    float interval = 1.0 / float(params.searches);\n    float start = 0.0;\n    for (int search=ZERO; search < params.searches; search++) {\n        float root = mix(params.bmin, params.bmax, start);\n        for (int nrIter=ZERO; nrIter < params.iters; nrIter++) {\n            float nrStep = root -= evalQuintic(root, a, b, c, d, e, f) / evalQuinticPrime(root, a, b, c, d, e, f);\n            if (params.wrap) root = params.bmin + mod(root - params.bmin, params.bmax - params.bmin);\n            if (abs(nrStep) < params.epsilon) break;\n        }\n\n        bool unique = true;\n        for (int n=ZERO; n < roots.nroots; n++) {\n            if (abs(root - roots.roots[n]) < params.epsilon) {\n                unique = false;\n                break;\n            }\n        }\n\n        if (abs(evalQuintic(root, a, b, c, d, e, f)) < params.epsilon && unique) {\n            //roots.roots[roots.nroots] = root;\n            //roots.nroots++;\n            switch(roots.nroots) {\n                case 0: roots.roots[0] = root; break;\n                case 1: roots.roots[1] = root; break;\n                case 2: roots.roots[2] = root; break;\n                case 3: roots.roots[3] = root; break;\n                case 4: roots.roots[4] = root; break;\n            };\n\n            roots.nroots++;\n\n        }\n\n        start += interval; // Randomizing it works surprisingly well too\n    }\n\n    return roots;\n}\n\n// Intersection\n// Implicit equation: x^2 + y^2 + z^2 + x^2y^2z - 2\nRoots5 iQuintic(in vec3 ro, in vec3 rd) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Zero simplifications\n    float a = u * u * v * v * w;\n    float b = z * u * u * v * v + 2.0 * x * u * v * v * w + 2.0 * y * u * u * v * w;\n    float c = 2.0 * x * z * u * v * v + 2.0 * y * z * u * u * v + y * y * u * u * w + x * x * v * v * w + 4.0 * x * y * u * v * w;\n    float d = u * u + v * v + w * w + y * y * z * u * u + x * x * z * v * v + 4.0 * x * y * z * u * v + 2.0 * x * y * y * u * w + 2.0 * x * x * y * v * w;\n    float e = 2.0 * x * u + 2.0 * y * v + 2.0 * z * w + 2.0 * x * y * y * z * u + 2.0 * x * x * y * z * v + x * x * y * y * w;\n    float f = x * x + y * y + z * z + x * x * y * y * z - 2.0;\n\n    return solveQuintic(a, b, c, d, e, f, Params(3.0, 10.0, 0.001, true, 25, 10));\n}\n\n// Normal\nvec3 nQuintic(in vec3 p) {\n    return normalize(vec3(p.x + p.x * p.y * p.y * p.z, p.y + p.x * p.x * p.y * p.z, p.z + 0.5 * p.x * p.x * p.y * p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Animate\n    float radius = 2.0 + cos(iTime);\n    float thickness = 1.0 + 0.5 * sin(iTime);\n\n    // Find the closest hit in front of the camera\n    Roots5 hit = iQuintic(ro, rd);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit.nroots); n++) {\n        vec3 hitCandid = ro + rd * hit.roots[n];\n        if (hit.roots[n] > 0.0 && hit.roots[n] < t) {\n            t = hit.roots[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nQuintic(hitPos);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos * 2.0), vec3(1.0)), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}