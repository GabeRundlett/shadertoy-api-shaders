{
    "Shader": {
        "info": {
            "date": "1617818210",
            "description": "Testing hardware texture unit derivatives to see if it uses all 4 pixel quad UVs or only the usual \"coarse\" 3.\n\nEllipse in center shows what the texture looks like normally. Top right quadrant should match on desktop GPUs. Mobile GPUs though...",
            "flags": 0,
            "hasliked": 0,
            "id": "sdB3zd",
            "likes": 3,
            "name": "Hardware Texture Derivative Test",
            "published": 3,
            "tags": [
                "derivatives"
            ],
            "usePreview": 0,
            "username": "bgolus",
            "viewed": 845
        },
        "renderpass": [
            {
                "code": "// Hardware Texture Mapping Unit (TMU) Derivatives Test\n\n// =======================================================================================\n//\n// GPUs render pixels in 2x2 groups known as pixel quads. All 4 pixels within the quad are\n// rendered in parallel at all times. This existed purely so GPUs can use UV derivatives,\n// or the difference between one pixel and the one beside it, to calculate the mip level.\n// For performance reasons it's beneficial to use a constant mip level for the entire quad\n// as it reduces the memory bandwidth usage. If all pixels with in the pixel quad use the\n// same mip level it means it only needs to retreive the mip map(s) once per pixel quad.\n//\n// Each texture(uv) call in the quad is passing along a UV position, and the hardware TMU\n// is calculating the derivatives from those UV positions. This shader offsets one pixel's\n// UV within each pixel quad by 1.0 on the x and y to try to expose the underlying\n// hardware's derivative calculation method.\n//\n// Traditionally the derivatives were calculated using only three of the four UVs passed\n// to the TMU as an optimization. This is more formally referred to as \"coarse\"\n// derivatives. Most desktop GPUs still work this way, so one UV can be significantly\n// different from the other three and not affect the calculated mip level. On those GPUs\n// this shader will show one quadrant, likely the top right, as matching the center\n// ellipse. That center ellipse isn't modifying the UVs at all so should always show the\n// top mip. The other three quadrants should show as a solid grey color as the coarse\n// derivatives will \"see\" the offset UV and calculate a smaller mip, presumablly the 1x1\n// mip thus producing the solid grey.\n//\n// However many newer GPUs, like Mali and Apple's Bionic or M1 GPUs, use all four UVs to\n// calculate the mip level for the pixel quad. Apple seems to use the worse derivatives\n// on each axis, where as Mali is an average of the derivatives.\n//\n// Note, the OS or graphics API should not have any affect on the results of this shader,\n// and running WebGL via ANGLE to Direct3D or Vulkan should look the same as native WebGL.\n// Also the behaviour of derivative functions within the shader code aren't guaranteed to\n// match those used by the TMU. They happen to in Direct3D on some desktop GPUs, like AMD\n// and Nvidia, but they're different things.\n//\n// See this shader for more: https://www.shadertoy.com/view/7sSGWG\n//\n// =======================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 halfRes = floor(iResolution.xy * 0.25) * 2.0;\n    vec2 halfRes = iResolution.xy * 0.5;\n    \n    vec2 uv = fragCoord/64.0;   \n    \n    vec2 quadPos = mod(floor(fragCoord), 2.0);\n    \n    // kick one UV position in the quad way out to check which pixel\n    // is ignored by the texture unit, if any\n    float offset = 0.0;\n    \n    // top right\n    if (fragCoord.x > halfRes.x && fragCoord.y > halfRes.y)\n        offset = max(0.0, quadPos.x + quadPos.y - 1.0);\n    \n    // top left\n    else if (fragCoord.x < halfRes.x && fragCoord.y > halfRes.y)\n        offset = max(0.0, (1.0 - quadPos.x) + quadPos.y - 1.0);\n        \n    // bottom right\n    else if (fragCoord.x > halfRes.x && fragCoord.y < halfRes.y)\n        offset = max(0.0, quadPos.x + (1.0 - quadPos.y) - 1.0);\n        \n    // bottom left\n    else //if (fragCoord.x < halfRes.x && fragCoord.y < halfRes.y)\n        offset = max(0.0, (1.0 - quadPos.x) + (1.0 - quadPos.y) - 1.0);\n        \n    // no modifications to the uv for an ellipse in the middle\n    vec2 centeredUV = fragCoord/iResolution.xy - 0.5;\n    if (length(centeredUV) < 0.2)\n        offset = 0.0;\n        \n    uv += offset;\n\n    fragColor = texture(iChannel0, uv);\n    \n    // fragColor = vec4(offset);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}