{
    "Shader": {
        "info": {
            "date": "1634678539",
            "description": "some casual triangles",
            "flags": 0,
            "hasliked": 0,
            "id": "7dKXDW",
            "likes": 2,
            "name": "Color Experiment 001",
            "published": 3,
            "tags": [
                "color"
            ],
            "usePreview": 0,
            "username": "darknoon",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "\n// via iq\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 c0 = vec3(0.63, 0.5, 0.5);\nvec3 c1 = vec3(0.7, 0.8, 0.5);\nvec3 c2 = vec3(0.1, 0.1, 0.7);\n\n\nconst float PI = 3.14159;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat sinc( float x, float k )\n{\n    float a = PI*(k*x)+PI;\n    return saturate(sin(a) / x);\n}\n\n// cite https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n  const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nmat2 rotation(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n    \n\nvoid mainImage( out vec4 result, in vec2 fragCoord )\n{\n    \n    result.rgb = c2 * 0.5;\n    \n    float tile = 18.0;\n    float sharp = 2.0 / iResolution.x * tile;\n    \n\n    // iterate neighbors\n    for (int i=-2; i<=2; i++) {\n    for (int j=-2; j<=2; j++) {\n        vec2 uv = fragCoord/iResolution.xy * vec2(1.0, iResolution.y / iResolution.x);\n\n        // get grid id of current object\n        ivec2 id = ivec2(floor(uv*tile) + vec2(i,j));\n        vec2 idf = vec2(id) / tile;\n\n        uv = fract(uv * tile);\n        // account for coord in neighborhood\n        uv -= vec2(i,j);\n\n\n        vec2 tri = vec2(0.6, 0.8 + 0.5*sin(iTime));\n        float rndg = 0.1234;\n\n        // TODO: rotation matrix!\n\n        // offset even rows\n        float off = id.y % 2 == 0 ? 1.0/3.0 : 0.0;\n        // tile\n        vec2 ctr = 0.5 + vec2(off, 0.0);\n        float r = 0.125;\n        \n        uv = rotation(PI / 4.0 + sin(idf.x + iTime)) * (uv - 0.5);\n        \n        //float dist = length(uv-ctr) - r;\n        float dist = sdTriangleIsosceles(uv + vec2(off, 0.0), tri) - rndg;\n        \n        \n\n        float a = sinc(dist * 22.0, 2.0);\n        float a_ = 1.0 - a;\n        \n        vec3 col = id.x % 2 == 0 ? c0 : c1;\n        vec3 other = mix(hash(uvec3(id.xyx)), c2, 0.7);\n        col = mix(col, other, 1.0 - 2.0*idf.y);\n\n        // source-over\n        result.rgb = result.rgb * a_ + col.rgb * a;\n        result.a   = result.a * a_ + a;\n    }}\n\n    // Output to screen\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}