{
    "Shader": {
        "info": {
            "date": "1668292190",
            "description": "chrysalis redux",
            "flags": 0,
            "hasliked": 0,
            "id": "csB3Dt",
            "likes": 4,
            "name": "chrysalis redux",
            "published": 3,
            "tags": [
                "psychedelic",
                "trippy"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 243
        },
        "renderpass": [
            {
                "code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 rBox(vec3 p, vec3 b, float r, float matId)\n{\n\tvec3 q = abs(p) - b;\n\treturn vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r, matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = -iTime - iDate.y;\n    \n    for(float i = 0.; i < 11.; i++)\n    {   \n        p = abs(p) - vec3(((cos(.03*t) + .5) * .011*sin(t*.19)) + ((sin(.015*t) + .5) * .011*cos(t*.19)) + .05,\n                          ((sin(.05*t) + .5) * .011*cos(t*.29)) + ((cos(.017*t) + .5) * .011*sin(t*.29)) + .09,\n                          ((sin(.02*t) + .5) * .011*cos(t*.09)) + ((cos(.013*t) + .5) * .011*sin(t*.09)) + .07);\n    \n        p.xy *= rot(.031*t);\n        \n        p = abs(p.zxy) - vec3(((sin(.02*t) + .5) * .011*cos(t*.07)) + ((cos(.013*t) + .5) * .011*sin(t*.07)) + .09,\n                          ((cos(.03*t) + .5) * .011*sin(t*.17)) + ((sin(.015*t) + .5) * .011*cos(t*.17)) + .05,\n                          ((cos(.05*t) + .5) * .011*sin(t*.27)) + ((sin(.017*t) + .5) * .011*cos(t*.27)) + .07);\n                          \n        p.zx *= rot(-.029*t);\n\n        //p = abs(p.yzx) - vec3(((cos(.05*t) + .5) * .011*sin(t*.011)) + ((cos(.02*t) + .5) * .011*sin(t*.03)) + .09,\n        //                  ((sin(.03*t) + .5) * .011*cos(t*.07)) + ((cos(.07*t) + .5) * .011*sin(t*.011)) + .05,\n        //                  ((cos(.07*t) + .5) * .011*sin(t*.05)) + ((sin(.011*t) + .5) * .011*cos(t*.09)) + .07);\n                          \n        //p.yz *= rot(.017*t);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    float rCorner = .001;\n    \n    p.x = abs(p.x);\n    p = (60. + 4.*cos(.07*iTime)) * sin(p/dot(p,p));\n    p = kif(p);\n    \n    vec2 m1 = rBox(p, vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m2 = rBox(vec3(p.x - .05, p.yz), vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m3 = rBox(vec3(p.x - .02, p.yz), vec3(.04, .8, 1.), rCorner, 2.);\n    vec2 m4 = rBox(vec3(p.x - .2, p.yz), vec3(.03, .45, .55), .005, 1.);\n    vec2 m5 = rBox(vec3(p.x - .025, p.y + .5, p.z), vec3(.05, .01, 1.05), rCorner, 2.);\n    vec2 m6 = rBox(vec3(p.x - .025, p.y - .5, p.z), vec3(.05, .01, 1.05), rCorner, 2.);\n    vec2 m7 = rBox(vec3(p.x - .025, p.yz), vec3(.05, .01, 1.05), rCorner, 2.);\n    vec2 m8 = rBox(vec3(p.x - .3, p.yz), vec3(.005, .15, .1), rCorner, 3.);\n\n    vec2 m = add(add(add(add(add(add(add(m1, m2), m3), m4), m5), m6), m7), m8);\n    glo += .15 / (1.2 + m2.x*m2.x*m2.x);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 25.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 128; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .01 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .9;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nfloat sss(vec3 p, vec3 l, float d)\n{\n\treturn smoothstep(0., 1., map(p + l*d).x/d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.75*cos(-.1*iTime),\n                   .75*sin(-.1*iTime),\n                   -4.2);\n    float targDist = 8.;\n\tvec3 camTarget = vec3(ro.x + targDist*sin(.1*iTime),\n                          ro.y,\n                          ro.z + targDist*cos(.1*iTime));\n\tvec3 up = vec3(sin(iTime/10.), cos(iTime/10.), 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(2.5, 2.5, -5.);\n    vec3 lightPos2 = vec3(-2.5, -2.5, -5.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .05);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(.35*sin(.317*(iTime)),\n                       cos(.151*(iTime)),\n                       .35*cos(.227*(iTime))) + 1.2;\n\n    vec3 hit = ro + rd*t.x;\n    vec3 lightDir = normalize(lightPos - hit);\n    vec3 lightDir2 = normalize(lightPos2 - hit);\n\n    vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                                            map(hit - eps.xyx).x,\n                                            map(hit - eps.xxy).x));\n\n\n    float diff = max(0., dot(lightDir, norm));\n    float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 50.);\n    float spec2 = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 50.);\n    float ao = clamp(map(t.x + norm*.01).x / .5, 0., 1.);\n\n    vec3 col = vec3(.1);\n    col *= .1 * ao;\n\n    if(t.y == 1.)\n        colRot = vec3(.18);\n    else if(t.y == 3.)\n        col += glo*.035*colRot;\n    else\n    {\n        colRot = colRot.yzx;\n        col += glo*.035*colRot;\n    }    \n\n    col += .3 * diff * colRot;\n    col += 1. * spec * vec3(0., .7, 1.);\n    col += 1. * spec2 * vec3(0., .7, 1.);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}