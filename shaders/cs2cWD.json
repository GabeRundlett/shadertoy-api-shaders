{
    "Shader": {
        "info": {
            "date": "1687775856",
            "description": "Some firsts for me:\n  - Chromatic aberration\n  - Depth of field.\n  - Lens effects.\nDisable AA in Buffer A for performance.\n  - ...and a Stormtrooper helmet. :)",
            "flags": 32,
            "hasliked": 0,
            "id": "cs2cWD",
            "likes": 48,
            "name": "The Force Awakens",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "starwars",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 2085
        },
        "renderpass": [
            {
                "code": "// 'The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/cs2cWD (YouTube: https://youtu.be/sFD_L59Asgg)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Some firsts for me:\n//  - Chromatic aberration\n//  - Depth of field.\n//  - Lens effects.\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - SDF fine details only modelled when ray is near a surface.\n//   - Using bump maps over SDF displacement where possible.\n//     (Displacing an SDF is much more expensive at the code is\n//     ever time the ray moves, whereas a bump is only applied once\n//     when the ray has hit a surface.)\n//   - Relax accuracy as the ray moves further away from the camera.\n//   - AA only applied on pixels where the neighbouring\n//     pixel is a significantly different color.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define CHROMATIC 0.003\n\n// Thnx Dave_Hoskins\nvec2 h22(vec2 p)\n{\n\tvec3 v = fract(p.xyx * vec3(.1031, .1030, .0973));\n    v += dot(v, v.yzx + 333.33);\n    return fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n    p += 353.627;\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat film(vec2 uv) {\n    // Film grain.\n    float c = (h21(uv * iResolution.xy) - 0.5) / 32.;\n\n    // Lens dust.\n    uv *= 4.;\n    float sm = 0.1;\n    for (int i = 0; i < 3; i++, uv++) {\n        vec2 p = fract(uv) - 0.5, id = floor(uv);\n        float s = h21(id) * sm;\n        p += h22(id) * (1.0 - sm) * 0.5;\n        c = max(c, smoothstep(s, s * 0.5, length(p)) * 0.025);\n        sm *= 0.5;\n        uv *= 2.282;\n    }\n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Chromatic aberration.\n    vec2 ca = (uv - 0.5) * CHROMATIC;\n\n    fragColor = vec4(\n                    texture(iChannel0, uv + ca).r,\n                    texture(iChannel0, uv).g,\n                    texture(iChannel0, uv - ca).ba);\n                    \n    if (fragColor.w > 0.0)\n        fragColor.rgb += film(uv * vec2(1, iResolution.y / iResolution.x));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 'The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/cs2cWD (YouTube: https://youtu.be/sFD_L59Asgg)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Disable if your GPU is melting.\n#define AA\t\n\n#define LIGHT_RGB\tvec3(2.4, 1.92, 1.68)\n#define R\tiResolution\n#define Z0\tmin(-t, 0.)\n#define I0\tmin(int(iTime), 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S\tsmoothstep\n#define S01(a)\tS(0., 1., a)\n\nfloat t,\n      fade = 1.;\nvec3 lp;\nstruct Hit {\n\tfloat d, id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, float id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat mul2(vec2 v) { return v.x * v.y; }\n\n///////////////////////////////////////////////////////////////////////////////\n// Hash/noise functions (Thnx Dave_Hoskins, Shane)\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat n31(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( h31(i), \n                        h31(i+vec3(1,0,0)),f.x),\n                   mix( h31(i+vec3(0,1,0)), \n                        h31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( h31(i+vec3(0,0,1)), \n                        h31(i+vec3(1,0,1)),f.x),\n                   mix( h31(i+vec3(0,1,1)), \n                        h31(i+1.0),f.x),f.y),f.z);\n}\n\nfloat n21(vec2 v) { return n31(vec3(v, 1)); }\n\n// roughness: (0.0, 1.0], default: 0.5\n// Returns unsigned noise [0.0, 1.0]\nfloat fbm2(vec2 p, int octaves, float roughness) {\n\tfloat sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n21(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\n// roughness: (0.0, 1.0], default: 0.5\n// Returns unsigned noise [0.0, 1.0]\nfloat fbm(vec3 p, int octaves) {\n\tfloat roughness = .5,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nvec3 randomPos(float seed) {\n\tvec4 s = vec4(seed, 0, 1, 2);\n\treturn vec3(h21(s.xy), h21(s.xz), h21(s.xw)) * 1e2 + 1e2;\n}\n\n// Returns unsigned noise [0.0, 1.0]\nfloat fbmDistorted(vec3 p, float distortion) {\n\tp += (vec3(n31(p + randomPos(0.)), n31(p + randomPos(1.)), n31(p + randomPos(2.))) * 2. - 1.) * distortion;\n\treturn fbm(p, 2);\n}\n\n// 2D voronoi noise.\nfloat voronoi(vec2 p) {\n\tvec2 o,\n\t     f = floor(p);\n\tp -= f;\n\tvec3 d = vec3(2);\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\to = vec2(x, y);\n\t\t\to += h22(f + o) - p;\n\t\t\td.z = dot(o, o);\n\t\t\td.y = max(d.x, min(d.y, d.z));\n\t\t\td.x = min(d.x, d.z);\n\t\t}\n\t}\n\n\treturn d.y - d.x;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Math\n// Smooth abs()\nfloat sabs(float f, float s) { return sqrt(f * f + s); }\n\n// Smooth min()\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// 1D infinite repeat.\nfloat rep(float p) { return p - .06 * floor(p / .06 + .5); }\n\n// 1D limited repeat.\nfloat repLim(float p) { return p - .07 * clamp(floor(p / .07 + .5), -4., 4.); }\n\n///////////////////////////////////////////////////////////////////////////////\n// SDFs\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p) {\n\tvec2 q = abs(p) - vec2(0, .9);\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y += clamp(-p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p) {\n\treturn length(vec2(length(p.xz) - .07, p.y)) - .005;\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Environment/textures/materials.\n\n// Plain sky color.\nvec3 skyCol(float y) { return pow(vec3(max(1. - y * .5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1); }\n\n// Sky with clouds.\nvec3 sky(vec3 rd) {\n\tvec3 p,\n\t     col = skyCol(rd.y);\n\tfloat den,\n\t      d = 5. / rd.y;\n\tif (d < 0.) return col;\n\tp = rd * d + vec3(1, .2, 1) * t * .2;\n\tp.xz *= .2;\n\tden = 1.;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.06 * fbm(p, 4));\n\n\treturn mix(col, LIGHT_RGB, S(.9, 1., den) * (1. - sat(d / 42.)));\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) / 1.73205;\n}\n\nvec3 matSand(vec3 p, inout vec3 n, inout float shine) {\n\t// Bump.\n\tfloat s = fbmDistorted(p * 2.3, 1.);\n\tn.xz += s * .3 - .15;\n\tn = normalize(n);\n\n\t// Sand color (light/stones.)\n\tshine = fbmDistorted(p * 30.3, .5) * .3;\n\tvec3 c = mix(vec3(.11, .03, .002), vec3(.75, .5, .25), S(0., .08, shine));\n\n\t// Add grains.\n\treturn mix(c, vec3(.5, .3, .2), S(.5, 1.5, voronoi(p.xz * 40.)) * (1. - sat(p.z / 2.)));\n}\n\n// Returns scratchiness. See scratches().\nfloat texScratches(vec3 p) {\n\tfloat sh = S(.85, 1., n31(p * vec3(80, 12, 1)));\n\tp.xy = p.yx * mat2(.76031, .64956, -.64956, .76031);\n\treturn max(sh, S(.85, 1., n31(p * vec3(80, 10, 1))));\n}\n\n// Return scratchiness, and apply bump to normal.\nfloat scratches(vec3 p, inout vec3 n) {\n\tconst vec3 dt = vec3(.001, 0, 0);\n\tfloat s = texScratches(p);\n\tn = normalize(n + vec3(texScratches(p + dt.xyy), texScratches(p + dt.yxy), texScratches(p + dt.yyx)) - s);\n\treturn s;\n}\n\nfloat dunes(vec3 p) {\n\tp.y += 2.;\n\tp.z -= 20.;\n\tfloat d = length(sin(p.xz * vec2(.07, .136)) * 3.5);\n\td *= S(12., -8., p.x);\n\td *= step(p.z, -15.);\n\n\t// Sand bumps.\n\tif (d < 3.) {\n\t\t// Close enough - Add detail.\n\t\tfloat s = n21(vec2(p.z + p.x, length(p.xz * 3. + vec2(500, 200))));\n\t\ts = abs(s - .5) + .2;\n\t\td -= s * .15 * S(-18., -20., p.z);\n\t}\n\n\treturn p.y - d;\n}\n\nfloat darkSand(vec3 p) {\n\tp.y += 12.97;\n\tp.z -= 2.;\n\tfloat d = length(p) - 12.05;\n\tif (d < .5) d -= abs(fbm2(p.xz * .5, 6, .55) - .5); // Close enough - Add detail.\n\treturn d;\n}\n\nfloat mountains(vec3 p) {\n\tfloat d = length(p.yz - vec2(-2, 25.3));\n\tif (d < 3.) d -= fbm2(p.xz, 3, .5) * 2.; // Close enough - Add detail.\n\treturn d * .5;\n}\n\nHit helmet(vec3 p) {\n\t// Main head.\n\tp += vec3(.7, .4, -.4);\n\tp.xy *= mat2(.90475, .42594, -.42594, .90475);\n\tp.xz *= mat2(.79608, .60519, -.60519, .79608);\n    \n\tfloat d, ox, f, isVisor,\n\t      helmet = cap(p, 1.3, 1.8 * S(-3., -1.4, p.y));\n\tif (helmet > 2.) return Hit(helmet, 3., p); // Too far away - Bail early.\n\t\n    // ...minus a bit off the chin...\n\td = smin(helmet, length(p.yz) - 2.07, -.1);\n\n\t// Top crest.\n\tox = p.x;\n\tp.x = abs(p.x);\n\td -= .07 * S(.255, .2, p.x) * S(-.1, 0., p.z + 1.);\n\n\t// Brow rim.\n\tf = S(.12, .08, abs(p.y - .2));\n\tf *= S(-.7, -.8, p.z);\n\td -= .03 * f;\n\tfloat isBlack = f * (step(abs(p.y - .2), .03) + step(abs(p.y - .14), .01));\n\n\t// Ear things.\n\tvec3 q = p;\n\tq.y += .35;\n\tq.z += .65;\n\tf = length(q.yz) - .4;\n\tf = smin(f, max(-p.z - .55, p.y - .7), .4);\n\tq.y -= 1.1;\n\tf = smin(f, box(q, vec3(3, .1, .1)) - .1, .2);\n\td = smin(d, smin(f, helmet - .025, -.03), .02);\n\tq.y += 1.1;\n\tq.z += .2;\n\tf = length(q.yz);\n\td = smin(d, smin(helmet - .06 + .01 * S(.15, .1, f), f - .15, -.05), .03);\n\tq.x -= 1.654;\n\tq.xz *= mat2(.88699, -.46178, .46178, .88699);\n\tHit h = Hit(tor(q.yxz), 7., p);\n\n\t// Cheek patches.\n\tq = p + vec3(-1.18, .7, 1.27);\n\tq.xz *= mat2(.73712, -.67576, .67576, .73712);\n\tq.yz *= mat2(.76484, -.64422, .64422, .76484);\n\tq.y -= 1. - cos(q.z);\n\tf = box(q, vec3(.05 - .003 * S01(sin(q.z * 1e2)), .08, .2)) - .05;\n\tU(h, f, 4., p);\n\n\t// Visor glass.\n\tf = sabs(pow(p.x, 1.2) * 1.1, .22) - 1.;\n\tf = S(.5, .45, abs(f * f * 1.2 + p.y * p.y * .8 + .1));\n\tf *= S(0.08, 0.06, p.y);\n\td += f * .08;\n\tisBlack += step(.01, f);\n\tisVisor = step(1., f);\n\n\t// Nose bump.\n\td -= .4 * (.4 - p.y) * pow(abs(cos(p.x * .6)), 10.) * step(p.y, .2);\n\n\t// Nose band.\n\tf = S(.1, .08, abs((p.y + 1.32) - mix(cos(p.x * 5.) + .86, p.x * p.x - .5, step(.6, p.x)) * .25));\n\tisBlack += step(.5, f);\n\td += f * .02;\n\n\t// Lower node band.\n\tf = S(.02, 0., abs(2.2 + p.y - cos(p.x * 2.2)));\n\td += f * .01;\n\n\t// Jaws.\n\tq = p;\n\tq.x = sabs(ox, .05);\n\tq += vec3(-1.28, 1.5, .9);\n\tq.yz *= mat2(.43568, .9001, -.9001, .43568);\n\tq.xy *= mat2(.76484, -.64422, .64422, .76484);\n\td = smin(d, cap(q, 1.2, .5), .2);\n\n\t// Jaw slots.\n\tq += vec3(-.33, .45, .35);\n\tq.xz *= mat2(.69671, .71736, -.71736, .69671);\n\tq.x = abs(q.x) - .09;\n\tq.y = repLim(q.y);\n\td = max(d, -box(q, vec3(.08, .03, .07)));\n\n\t// Chin vent hole.\n\tq = p;\n\tq.x = ox;\n\tq.xz *= mat2(.95141, .30791, -.30791, .95141);\n\tq.yz *= mat2(.97865, .20552, -.20552, .97865);\n\tq += vec3(.08, 2.16, 1.83);\n\td = smin(d, -cyl(q, vec2(.15, .1)), -.05);\n\tU(h, d * .9, 3. + sat(isBlack) + isVisor, vec3(ox, p.yz));\n\n\t// Chin vent inside.\n\tq.z -= .14;\n\td = cyl(q, vec2(.15, .1));\n\tf = cyl(q, vec2(.1, .2));\n\td = max(d, -f);\n\tq.y = rep(q.y);\n\tq.z += .07;\n\td = min(d, max(f, length(q.yz) - .01));\n\tU(h, d, 7., q);\n\treturn h;\n}\n\nHit sdf(vec3 p) {\n\tHit h = helmet(p);\n\tU(h, dunes(p), 1., p);\n\tU(h, mountains(p), 6., p);\n\tU(h, darkSand(p), 2., p);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float d) {\n\tfloat h = d * .05;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat s = 1.,\n\t      l = .1;\n\tfor (float i = Z0; i < 30. && l < 4.; i++) {\n\t\tfloat d = sdf(l * ld + p).d;\n\t\ts = min(s, mix(50., 7., .5) * d / l);\n\t\tl += max(.05, d);\n\t\tif (s < .1) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(mul2(.5 + .5 * ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h, float fogAdjust) {\n\tif (h.id == 0.) return sky(rd);\n\tfloat _ao, sha,\n\t      shine = 1.;\n\tvec3 c, l, skyTop, col,\n\t     ld = normalize(lp - p);\n\n\t// Calculate ambient occlusion and shadows.\n\t_ao = ao(p, n);\n\tsha = shadow(p, ld, n);\n\tif (h.id <= 2.) {\n\t\tc = matSand(p, n, shine);\n\t\tif (h.id == 2.) {\n\t\t\tc = pow(c, vec3(1.36, 1.18, 1.18)) * .9;\n\t\t\tshine *= .5;\n\t\t}\n\t}\n\telse if (h.id == 3.) {\n\t\tc = vec3(.85);\n\t\tshine = .5;\n\n\t\t// Scratches.\n\t\tfloat _ns,\n\t\t      s = scratches(p, n);\n\t\tshine += s * 4.;\n\t\tc = mix(c, vec3(.1), s);\n\n\t\t// Sand (More in corners).\n\t\ts = sat(S(.6, .8, n31(h.p * 2.)) + S(1., .8, _ao));\n\t\ts *= n31(h.p * 5.);\n\t\tc = mix(c, vec3(.5, .331, .168), s);\n\t\tshine *= 1. - s;\n\n\t\t// Blood.\n\t\tvec2 uv = h.p.xy;\n\t\tuv.y -= (cos(uv.x * 3.) - 1.) * .4;\n\t\tuv *= mat2(.92106, .38942, -.38942, .92106);\n\t\tuv.x = abs(abs(uv.x - .5) - .15) - .14;\n\t\t_ns = n21(h.p.xy * 10.);\n\t\tc = mix(c, vec3(.15 - .12 * _ns, .001, .01), S(.03, 0., box2d(uv) - .04 - .02 * (h.p.y - 1.5 * _ns)));\n\t}\n\telse if (h.id == 5.) {\n\t\tc = vec3(.01);\n\t\tshine = .8;\n\t}\n\telse if (h.id == 4.) {\n\t\tc = vec3(.02);\n\t\tshine = .2;\n\t}\n\telse if (h.id == 6.) c = vec3(.25, .2, .18);\n\telse {\n\t\tc = vec3(.2);\n\t\tshine = 5.;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\tl.x *= fakeEnv(ld * 4.); // Light mask.\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl *= sat(_ao * vec3(1.2, 1, 1)); // Ambient occlusion.\n\tl *= vec3(1, .5, .2); // Light contributions (key, reverse, sky).\n    \n\t// Apply tinted shadows.\n\tl.x *= .1 + .9 * sha;\n\tskyTop = pow(vec3(max(.5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1);\n\tc += skyTop * (1. - sha) * .5;\n\n\t// Specular (Blinn-Phong)\n\tshine *= sha; // No specular in the shadows.\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), 10.) * shine;\n\n\t// Light falloff.\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\n\t// Fresnel.\n\t// Combine the lights (key, reverse, sky).\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * skyTop) * c, skyTop, S(.6, 1., 1. + dot(rd, n)) * .25);\n\n\t// Distance Fog.\n\treturn mix(pow(vec3(max(1., 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1), col, 1. - sat(1. - exp(dot3(p - ro) / -fogAdjust * mix(1e-4, .01, .02))));\n}\n\nfloat addFade() { return min(1., abs(t)); }\n\nvec4 march(vec3 ro, vec3 rd) {\n\tt = iTime;\n\tfade = addFade();\n\tlp = vec3(6, 19, 1);\n\n\t// March the scene.\n\tvec3 n,\n\t     p = ro,\n\t     col = vec3(0);\n\tfloat i, dof, refl,\n\t      d = 1.;\n\tHit h;\n\tfor (i = Z0; i < 96.; i++) {\n\t\tif (d > 42.) {\n\t\t\th.id = 0.;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tdof = sat(d / 42.);\n\n\t// Brighten scene when facing the sun.\n\tcol += .2 * dof * LIGHT_RGB * S(.5, 1., pow(sat(dot(rd, normalize(lp))), 3.));\n\tcol += lights(p, ro, rd, n = N(p, d), h, 1.);\n\trefl = h.id == 5. ? .03 : 0.;\n\tif (refl > 0.) {\n\t\t// We hit a reflective surface, so march reflections.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < 32.; i++) {\n\t\t\tif (d > 15.) {\n\t\t\t\th.id = 0.;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += refl * (1. - col) * lights(p, ro, rd, n = N(p, d), h, .2);\n\t}\n\n\treturn vec4(pow(max(vec3(0), col), vec3(.4545)), dof);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col,\n\t     ro = vec3(0, .001, -4.8);\n\tro.xz *= mat2(.92978, -.36811, .36811, .92978);\n\n\t// View bob\n\tro += vec3(.5, .1, .1) * sin(iTime * vec3(.4, .3, .1));\n\tvec4 rgbz = march(ro, rayDir(ro, uv));\n\tcol = rgbz.rgb;\n#ifdef AA\n\tif (fwidth(col.r) > .1) {\n\t\tfor (float dx = -.5; dx <= .5; dx++) {\n\t\t\tfor (float dy = -.5; dy <= .5; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, uv + vec2(dx, dy) / R.xy)).rgb;\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n\n#endif\n\n\t// Vignette.\n\tcol *= 1. - .3 * dot(uv, uv);\n\tfragColor = vec4(col * fade, sat(rgbz.w));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 'The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/cs2cWD (YouTube: https://youtu.be/sFD_L59Asgg)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUR 10.0\n#define LENS 0.005\n\nvec2 fisheye(vec2 uv) {\n    uv -= 0.5;\n    uv *= pow(dot(uv, uv), LENS);\n    return uv + 0.5;\n}\n\nfloat h31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 333.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Lens distortion.\n    uv = fisheye(uv);\n\n    // Apply basic depth of field blur.\n    vec4 col = texture(iChannel0, uv);\n    float blur = smoothstep(0.2, 0.3, col.w) * BLUR;\n    \n    if (blur > 0.0) {\n        float samples = 40.0;\n        for (float i = 0.0; i < samples; i++) {\n            float a = 3.1415 * 2.0 / samples * i;\n            //todo - rotate by constant each iteration\n            // todo - ...or use sin on vec2 to pick 2d -1...1\n            vec2 tuv = uv + vec2(blur * h31(vec3(uv, i)), 0) * mat2(cos(a), sin(a), -sin(a), cos(a)) / iResolution.xy;\n            col += texture(iChannel0, tuv);\n        }\n        \n        col /= samples + 1.0;\n    }\n    \n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}