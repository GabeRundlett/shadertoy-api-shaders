{
    "Shader": {
        "info": {
            "date": "1499675554",
            "description": "Look around using mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "4dBfzD",
            "likes": 18,
            "name": "Canal Ruins",
            "published": 3,
            "tags": [
                "reflection",
                "water",
                "voxel",
                "hexagon",
                "boat"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 1223
        },
        "renderpass": [
            {
                "code": "// \"Canal Ruins\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define SQRT3 1.73205\n\nmat3 bMat, boatMat[3];\nvec3 bPos, boatPos[3], qHit, trkF, trkA, vuPos, sunDir, cHit, cHitP, qnHit;\nfloat boatAng[3], bAng, tCur, dstFar;\nint idObj, idObjGrp;\nconst float hcScale = 1.8;\nconst vec3 hcSize = vec3 (0.5 * SQRT3, 1., 1.8);\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec2 c, r, dr;\n  c = vec2 ((2. / SQRT3) * p.x, p.y);\n  r = floor (c);\n  r += mod (vec2 (r.x, r.y + step (2., mod (r.x + 1., 4.))), 2.);\n  dr = c - r;\n  r += step (1., 0.5 * dot (abs (dr), vec2 (SQRT3, 1.))) * sign (dr) * vec2 (2., 1.);\n  return r;\n}\n\nbool HexCellFull (vec3 p)\n{\n  float hs, hb;\n  p = (p * hcSize).yzx / hcScale;\n  p.xy -= TrackPath (p.z).xy;\n  hs = - SmoothMin (length (p.xy * vec2 (0.9 - 0.35 * cos (p.z * pi / 20.), 0.3)) - 4.,\n    6.5 + 4.5 * dot (sin (p * pi / 16. - cos (p.yzx * pi / 12.)), vec3 (1.)) - p.y, 2.);\n  return (hs < 0.);\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, dy;\n  ro *= hcScale;\n  cHit = vec3 (PixToHex (ro.zx), floor (ro.y / hcSize.z + 0.5));\n  hv[0] = vec2 (0., 1.);\n  hv[1] = vec2 (1., 0.5);\n  hv[2] = vec2 (1., -0.5);\n  for (int k = 0; k < 3; k ++)\n     hv[k] *= sign (dot (hv[k], vec2 (0.5 * SQRT3 * rd.z, rd.x)));\n  if (rd.y == 0.) rd.y = 0.0001;\n  dy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar * hcScale + 0.01;\n  for (int j = 0; j < 300; j ++) {\n    w = ro - (cHit * hcSize).yzx;\n    ht.z = 1e6;\n    for (int k = 0; k < 3; k ++) {\n      ve = vec2 (0.5 * SQRT3 * hv[k].x, hv[k].y);\n      htt = vec3 (hv[k], (1. - dot (ve, w.zx)) / dot (ve, rd.zx));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * dy * hcSize.z - w.y) / rd.y;\n    cHitP = cHit;\n    if (ht.z < ty) cHit.xy += 2. * ht.xy;\n    else cHit.z += dy;\n    if (HexCellFull (cHit)) {\n      if (ht.z < ty) {\n        qnHit = - vec3 (0.5 * SQRT3 * ht.x, ht.y, 0.);\n        dHit = ht.z;\n      } else {\n        qnHit = - vec3 (0., 0., dy);\n        dHit = ty;\n      }\n      break;\n    }\n  }\n  return dHit / hcScale;\n}\n\nfloat HexFaceDist (vec3 p)\n{\n  vec4 h[4];\n  vec3 cNeb, vh;\n  float d;\n  p = p.zxy * hcScale - cHitP * hcSize;\n  p.z *= 2. / hcSize.z;\n  h[0] = vec4 (0., 1., 0., 1.);\n  h[1] = vec4 (1., 0.5, 0., 1.);\n  h[2] = vec4 (1., -0.5, 0., 1.);\n  h[3] = vec4 (0., 0., 0.5, 0.5 * hcSize.z);\n  d = 1e5;\n  for (int k = 0; k < 4; k ++) {\n    vh = h[k].xyz;\n    cNeb = cHitP + 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w - dot (vh * hcSize, p));\n    cNeb = cHitP - 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w + dot (vh * hcSize, p));\n  }\n  return d;\n}\n\nvec3 HexVolCol (vec3 p, float edgDist, float dHit)\n{\n  vec3 col;\n  col = vec3 (0.9, 0.85, 0.75);\n  col *= 0.8 + 0.2 * smoothstep (0., 0.05, abs (edgDist));\n  if (qnHit.z != 0.) col *= 0.7 + 0.3 * smoothstep (0., 0.7, abs (edgDist));\n  if (qnHit.z == 1.) col *= vec3 (0.4, 0.7, 0.4);\n  col *= (1.2 - 0.2 * smoothstep (0., 0.06 * sqrt (dHit), abs (edgDist) - 0.03)) *\n     (0.5 + 0.5 * smoothstep (0., 0.03 * sqrt (dHit), abs (edgDist) - 0.01));\n  return col;\n}\n\nfloat EdgeDist (vec3 p)\n{\n  vec2 dh;\n  float d;\n  p *= hcScale;\n  dh = p.zx - cHit.xy * vec2 (0.5 * SQRT3, 1.);\n  if (qnHit.z == 0.) {\n    d = abs (fract (p.y / hcSize.z) - 0.5) * hcSize.z;\n    dh -= qnHit.xy * dot (dh, qnHit.xy);\n    d = min (d, abs (length (dh) - 1. / SQRT3));\n  } else {\n    dh = abs (dh);\n    d = max (0.5 * dot (dh, vec2 (SQRT3, 1.)), dh.y) - 1.;\n  }\n  return d;\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 0.7;\n  q = p;\n  d = max (max (PrRCylDf (q, 1.2, 2., 3.5),\n     - max (PrRCylDf (q - vec3 (0., 0.1, 0.), 1.15, 2., 3.5),\n     max (q.y - 0.1, - q.y - 0.1))), max (q.y - 0., - q.y - 0.2));\n  q.y -= -0.2;\n  d = max (SmoothMin (d, max (PrRCylDf (q, 1., 2., 3.3), q.y), 0.1), q.z - 2.);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (-0.5, -0.2);\n  d = max (PrRCylDf (q, 1., 1.1, 2.3), max (0.4 - q.y, q.z - 1.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 2;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (1.3, -0.6);\n  d = PrCylDf (q.xzy, 0.04, 0.8);\n  q.y -= 0.2;\n  d = min (d, PrCylDf (q.yzx, 0.02, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 3; }\n  q.y -= 0.6;\n  d = PrCylDf (q.xzy, 0.15, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 4; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, -0.9, 2.);\n  d = PrRoundBoxDf (q, vec3 (0.02, 0.2, 0.1), 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 5; }\n  q.y -= -0.4;\n  d = PrCylAnDf (q, 0.1, 0.02, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (-1., 2.);\n  d = PrCylDf (q, 0.1, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (0.3, 1.9);\n  d = PrCylDf (q.xzy, 0.015, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 7; }\n  q.yz -= vec2 (0.38, 0.15);\n  d = PrBoxDf (q, vec3 (0.01, 0.1, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 8; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dLim;\n  const float szFac = 2.;\n  dLim = 0.2;\n  dMin = dstFar;\n  dMin *= szFac;\n  for (int k = 0; k < 3; k ++) {\n    q = szFac * (p - boatPos[k]);\n    idObjGrp = (k + 1) * 256;\n    d = PrCylDf (q.xzy, 3.5, 3.);\n    dMin = (d < dLim) ? BoatDf (boatMat[k] * q, dMin) : min (dMin, d);\n  }\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 BoatCol (vec3 n)\n{\n  vec3 col, nn, cc;\n  float spec;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (ig == 1) nn = boatMat[0] * n;\n  else if (ig == 2) nn = boatMat[1] * n;\n  else nn = boatMat[2] * n;\n  spec = 0.3;\n  if (id == 1) {\n    if (qHit.y < 0.1 && nn.y > 0.99) {\n      col = vec3 (0.8, 0.5, 0.3) *\n         (1. - 0.4 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.)));\n      spec = 0.1;\n    } else {\n      cc = vec3 (0.9, 0.3, 0.3);\n      if (qHit.y > -0.2) col = (ig == 1) ? cc :\n         ((ig == 2) ? cc.yzx : cc.zxy);\n      else col = vec3 (0.7, 0.7, 0.8);\n      spec = 0.7;\n    }\n  } else if (id == 2) {\n    if (abs (abs (qHit.x) - 0.24) < 0.22 && abs (qHit.y - 0.7) < 0.15 ||\n       abs (abs (qHit.z + 0.2) - 0.5) < 0.4 && abs (qHit.y - 0.7) < 0.15) {\n       col = vec3 (0., 0., 0.1);\n       spec = 1.;\n     } else col = vec3 (1.);\n  } else if (id == 3) col = vec3 (1., 1., 1.);\n  else if (id == 4) col = vec3 (1., 1., 0.4);\n  else if (id == 5) col = vec3 (0.4, 1., 0.4);\n  else if (id == 6) col = vec3 (1., 0.2, 0.);\n  else if (id == 7) col = vec3 (1., 1., 1.);\n  else if (id == 8) col = (ig == 1) ? vec3 (1., 0.4, 0.4) : vec3 (0.4, 1., 0.4);\n  return vec4 (col, spec);\n}\n\nfloat WakeFac (vec3 p)\n{\n  vec3 twa;\n  vec2 tw[3];\n  float twLen[3], wkFac;\n  for (int k = 0; k < 3; k ++) {\n    tw[k] = p.xz - (boatPos[k].xz - Rot2D (vec2 (0., 0.12), boatAng[k]));\n    twLen[k] = length (tw[k]);\n  }\n  if (twLen[0] < min (twLen[1], twLen[2])) twa = vec3 (tw[0], boatAng[0]);\n  else if (twLen[1] < twLen[2]) twa = vec3 (tw[1], boatAng[1]);\n  else twa = vec3 (tw[2], boatAng[2]);\n  twa.xy = Rot2D (twa.xy, - twa.z);\n  wkFac = clamp (1. - 2.5 * abs (twa.x), 0., 1.) * clamp (1. - 2. * twa.y, 0., 0.2) *\n     smoothstep (-5., -2., twa.y);\n  return wkFac;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (50. - ro.y) / (rd.y + 0.0001) + ro.xz));\n  col = vec3 (0., 0.2, 0.7) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) +\n     0.2 * pow (sd, 512.));\n  return mix (col, vec3 (0.9), clamp ((f - 0.05) * rd.y + 0.3, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, row, rdw;\n  float dstObj, dstWat, dstBlk, dEdge, diff, h, sh, reflCol, wkFac;\n  int idObjT;\n  reflCol = 1.;\n  dstBlk = HexVolRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstWat = - (ro.y + 2.) / rd.y;\n  if (rd.y * (min (dstBlk, dstObj) - dstWat) < 0.) {\n    ro += dstWat * rd;\n    row = ro;\n    wkFac = WakeFac (row);\n    vn = vec3 (0., 1., 0.);\n    if (wkFac > 0.) vn = VaryNf (100. * ro, vec3 (0., 1., 0.), 10. * wkFac);\n    else vn = VaryNf (2. * ro, vec3 (0., 1., 0.), 0.2);\n    rd = reflect (rd, vn);\n    rdw = rd;\n    dstBlk = HexVolRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    reflCol = 0.8;\n  }\n  bgCol = vec3 (0.2, 0.2, 0.3) * (1. + 0.2 * rd.y);\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      ro += rd * dstBlk;\n      vn = qnHit.yzx;\n      dEdge = EdgeDist (ro);\n      h = smoothstep (0., 0.1, HexFaceDist (ro));\n      col = HexVolCol (ro, dEdge, dstBlk) * (0.7 + 0.3 * h) *\n         (1. - 0.2 * Fbm3 (30. * ro));\n      col = mix (vec3 (0., 0.2, 0.), col, 0.5 + 0.5 * smoothstep (-2., -1.8, ro.y));\n      vn = VaryNf (5. * ro, vn, 2.);\n      diff = max (dot (sunDir, vn), 0.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.5 : 1.;\n      col = col * (0.2 + sh * (0.1 * max (vn.y, 0.) + 0.8 * diff)) + 0.2 * sh *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);        \n      col = mix (col, bgCol, smoothstep (0.2 * dstFar, 0.85 * dstFar, dstBlk));\n    } else {\n      ro += rd * dstObj;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      col4 = BoatCol (vn);\n      diff = max (dot (sunDir, vn), 0.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.5 : 1.;\n      col = col4.rgb * (0.3 + 0.7 * sh * diff) +\n         col4.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    }\n  } else col = SkyCol (ro, rd);\n  col *= reflCol;\n  if (reflCol < 1. && wkFac > 0.) col = mix (col, vec3 (0.9),\n     10. * wkFac * clamp (0.1 + 0.5 * Fbm3 (23. * row), 0., 1.));\n  return col;\n}\n\nvoid BoatPM (float t)\n{\n  vec3 v;\n  float c, s, bAz;\n  bPos = TrackPath (t);\n  bPos.y = -1.9;\n  bMat[2] = vec3 (1., 0., 0.);\n  bMat[0] = normalize (vec3 (0., 0.1, 1.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  v = TrackVel (t);\n  bAz = atan (v.z, - v.x);\n  bAng = 0.5 * pi - bAz;\n  c = cos (bAz);\n  s = sin (bAz);\n  bMat *= mat3 (c, 0., s, 0., 1., 0., - s, 0., c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, vMov, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  trkF = vec3 (0.029, 0.021, 0.016);\n  trkA = vec3 (15., 23., 34.);\n  vMov = 4.;\n  for (int k = 0; k < 3; k ++) {\n    BoatPM (vMov * tCur + 8. + 12. * float (k));\n    boatPos[k] = bPos;  boatMat[k] = bMat;  boatAng[k] = bAng;\n    boatPos[k].y += 0.1 * Fbm1 (5. * float (k) + tCur);\n  }\n  ro = TrackPath (vMov * tCur);\n  ro.y += 0.2;\n  vd = TrackVel (vMov * tCur);\n  el = 0.;\n  az = atan (vd.x, vd.z);\n  if (mPtr.z > 0.) {   \n    el += 0.7 * pi * mPtr.y;\n    az += 2. * pi * mPtr.x;\n  }\n  ori = vec2 (clamp (el, -0.5 * pi, 0.45 * pi), az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  dstFar = 250.;\n  a = 0.3 * pi * sin (0.02 * pi * tCur);\n  sunDir = normalize (vec3 (sin (a), 3., - cos (a)));\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p = 2. * p.yzx;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}