{
    "Shader": {
        "info": {
            "date": "1507032528",
            "description": "Utility functions to deal with second order surfaces: quadric transformation, point test, line intersection, plane intersection, volume/plane/line bounding, perspective contouring.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXcDl",
            "likes": 33,
            "name": "Quadric Toolkit",
            "published": 3,
            "tags": [
                "ray",
                "volume",
                "quadric",
                "intersection",
                "plane"
            ],
            "usePreview": 1,
            "username": "paniq",
            "viewed": 3757
        },
        "renderpass": [
            {
                "code": "// Quadric Toolkit\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\nstruct surface2x3 {\n    float c[10];\n};\n\nstruct surface2x2 {\n    float c[6];\n};\n    \n#define surface2x1 vec3\n\n// transform a quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + J\n// by a 4x3 matrix to yield a second order surface \n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\nvoid surface2x3_new(in vec4 quadric, in mat4 mtx, out surface2x3 surf) {\n    float A = quadric.x; float B = quadric.y; float C = quadric.z; float J = quadric.w;\n    vec3 ABC = vec3(A,B,C);\n    vec3 ABC2 = ABC*2.0;\n    surf.c[0] = dot(ABC, mtx[0].xyz*mtx[0].xyz);\n    surf.c[1] = dot(ABC, mtx[1].xyz*mtx[1].xyz);\n    surf.c[2] = dot(ABC, mtx[2].xyz*mtx[2].xyz);\n    surf.c[3] = dot(ABC2, mtx[0].xyz*mtx[1].xyz);\n    surf.c[4] = dot(ABC2, mtx[0].xyz*mtx[2].xyz);\n    surf.c[5] = dot(ABC2, mtx[1].xyz*mtx[2].xyz);\n    surf.c[6] = dot(ABC2, mtx[0].xyz*mtx[3].xyz);\n    surf.c[7] = dot(ABC2, mtx[1].xyz*mtx[3].xyz);\n    surf.c[8] = dot(ABC2, mtx[2].xyz*mtx[3].xyz);\n    surf.c[9] = dot(ABC, mtx[3].xyz*mtx[3].xyz) + J;\n}\n\n// for a quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D\n// compute the normal for the given position (x y z)\nvec3 quadric_normal(vec4 quadric, vec3 p) {\n\tfloat A = quadric.x; float B = quadric.y; float C = quadric.z;\n    return normalize(vec3(A,B,C)*p);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the partial differential for the given position (x y z)\nvec3 surface2x3_diff(surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];    \n    return vec3(\n        2.0*A*p.x + D*p.y + E*p.z + G,\n    \tD*p.x + 2.0*B*p.y + F*p.z + H,\n    \tE*p.x + F*p.y + 2.0*C*p.z + I);\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the partial differential for the given position (x y)\nvec2 surface2x2_diff(surface2x2 surf, vec2 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    return vec2(\n    \t2.0*A*p.x + C*p.y + D,\n    \tC*p.x + 2.0*B*p.y + E);    \n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and the given horizontal and vertical boundaries, \n// return the contact points along that boundary\nvec4 surface2x2_contacts(surface2x2 surf, vec4 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    vec2 p0 = (-vec2(D) - C*p.zw) / (2.0*A);\n\tvec2 p1 = (-vec2(E) - C*p.xy) / (2.0*B);\n    return vec4(p0, p1);\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and the given boundary points, \n// return the missing component along those boundaries\nvec3 surface2x3_contacts(surface2x3 surf, vec2 p_yz, vec2 p_zx, vec2 p_xy) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    \n    return vec3(\n    \t(-G - D*p_yz[0] - E*p_yz[1]) / (2.0*A),\n    \t(-H - F*p_zx[0] - D*p_zx[1]) / (2.0*B),\n    \t(-I - E*p_xy[0] - F*p_xy[1]) / (2.0*C));\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the value for the given position (x y z)\nfloat surface2x3_eval(surface2x3 surf, vec3\n                      p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];    \n    float J = surf.c[9];\n    return A*p.x*p.x + B*p.y*p.y + C*p.z*p.z \n        + D*p.x*p.y + E*p.x*p.z + F*p.y*p.z\n        + G*p.x + H*p.y + I*p.z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the value for the given position (x y)\nfloat surface2x2_eval(surface2x2 surf, vec2 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    return A*p.x*p.x + B*p.y*p.y + C*p.x*p.y + D*p.x + E*p.y + F;\n}\n\n// swizzle the components of a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// performing this twice selects zxy\nvoid surface2x3_swizzle_yzx(inout surface2x3 surf) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float XZ = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tsurf.c[0] = YY;\n\tsurf.c[1] = ZZ;\n\tsurf.c[2] = XX;\n\t\n    surf.c[3] = YZ;\n\tsurf.c[4] = XY;\n\tsurf.c[5] = XZ;\n\t\n    surf.c[6] = Y;\n\tsurf.c[7] = Z;\n\tsurf.c[8] = X;\n}\n\n// swap the x and y components of a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x2_swizzle_yx(inout surface2x2 surf) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1];\n\tfloat X = surf.c[3]; float Y = surf.c[4];\n    surf.c[0] = YY;\n    surf.c[1] = XX;\n    surf.c[3] = Y;\n    surf.c[4] = X;\n}\n\n// for two planes\n// f(x,y,z) = a.x*x + a.y*y + a.z*z + a.w\n// g(x,y,z) = b.x*x + b.y*y + b.z*z + b.w\n// with non-zero z coefficient (you may need to swap components of input arguments)\n// return a pair of line coefficients which are valid in f's and g's local space\nvoid plane_slice(in vec4 a, in vec4 b, out vec3 l0, out vec3 l1) {\n    vec3 q = vec3(\n        a.z*b.x - a.x*b.z,\n        a.z*b.y - a.y*b.z,\n        a.z*b.w - a.w*b.z\n        );\n    l0 = q / a.z;\n    l1 = -q / b.z;\n}\n\n// for a quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + J\n// and a plane\n// g(x,y,z) = nx*x + ny*y + nz*z + w\n// with a non-zero nz coefficient (you may need to swap components of input arguments)\n// return the general bivariate quadratic that represents a slice of\n// this surface in the plane in the form\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid quadric_slice(vec4 surf, vec4 plane, out surface2x2 slice) {\n\tfloat A = surf[0]; float B = surf[1]; float C = surf[2]; float J = surf[3];\n    vec3 n = plane.xyz;\n    float w = plane.w;\n\tfloat f = 1.0 / (n.z * n.z);    \n\tslice.c[0] = (C*n.x*n.x + A*n.z*n.z)*f;\n    slice.c[1] = (C*n.y*n.y + B*n.z*n.z)*f;\n\tslice.c[2] = 2.0*C*n.x*n.y*f;\n    slice.c[3] = 2.0*C*n.x*w*f;\n\tslice.c[4] = 2.0*C*n.y*w*f;\n    slice.c[5] = (J*n.z*n.z + C*w*w)*f;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the origin point projected to the xy plane at z=1\nvoid surface2x3_project_perspective_xy(surface2x3 surf, out surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n\tfloat J = surf.c[9];\n    J *= 4.0;\n    slice.c[0] = G*G - A*J;\n    slice.c[1] = H*H - B*J;\n    slice.c[2] = 2.0*G*H - D*J;\n    slice.c[3] = 2.0*G*I - E*J;\n    slice.c[4] = 2.0*H*I - F*J;\n    slice.c[5] = I*I - C*J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_xy(surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float XZ = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat C = surf.c[9];\n    ZZ *= 4.0;\n\tslice.c[0] = XZ*XZ - XX*ZZ;\n    slice.c[1] = YZ*YZ - YY*ZZ;\n    slice.c[2] = 2.0*XZ*YZ - ZZ*XY;\n    slice.c[3] = 2.0*XZ*Z - ZZ*X;\n    slice.c[4] = 2.0*YZ*Z - ZZ*Y;\n    slice.c[5] = Z*Z - ZZ*C;\n}\n\nvoid surface2x2_project_ortho_x(surface2x2 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n\tfloat X = surf.c[3]; float Y = surf.c[4]; float C = surf.c[5];\n    YY *= 4.0;\n\tslice[0] = XY*XY - XX*YY;\n    slice[1] = 2.0*XY*Y - YY*X;\n    slice[2] = Y*Y - YY*C;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a plane\n// g(x,y,z) = nx*x + ny*y + nz*z + w\n// with a non-zero nz coefficient (you may need to swap components of input arguments)\n// return the general bivariate quadratic that represents a slice of\n// this surface in the plane in the form\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_slice(in surface2x3 surf, vec4 plane, out surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n\tfloat J = surf.c[9];\n    vec3 n = plane.xyz;\n    float w = plane.w;\n    float f = 1.0 / (n.z * n.z);\n\tslice.c[0] = (A*n.z*n.z + C*n.x*n.x - E*n.x*n.z)*f;\n    slice.c[1] = (B*n.z*n.z + C*n.y*n.y - F*n.y*n.z)*f;\n\tslice.c[2] = (2.0*C*n.x*n.y + D*n.z*n.z - E*n.y*n.z - F*n.x*n.z)*f;\n    slice.c[3] = (2.0*C*n.x*w - E*n.z*w + G*n.z*n.z - I*n.x*n.z)*f;\n\tslice.c[4] = (2.0*C*n.y*w - F*n.z*w + H*n.z*n.z - I*n.y*n.z)*f;\n    slice.c[5] = (C*w*w - I*n.z*w + J*n.z*n.z)*f;\n}\n\n/*\nfor a screen plane of center c and size s\nthe vertical perspective planes (\"flaps\") are at\n2*(cx - sx)*z - 2*x == 0\n2*(cx + sx)*z - 2*x == 0\nand the horizontal ones are at\n2*(cy - sy)*z - 2*y == 0\n2*(cy + sy)*z - 2*y == 0\nlikewise, the vertical and horizontal quadratic slices have the format\nA*x0^2*z^2 + D*x0*y*z + E*x0*z^2 + B*y^2 + G*x0*z + F*y*z + C*z^2 + H*y + I*z + J\nB*y0^2*z^2 + D*x*y0*z + F*y0*z^2 + A*x^2 + E*x*z + H*y0*z + C*z^2 + G*x + I*z + J\n*/\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and x\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane(in surface2x3 surf, float x,\n\tout surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    // y -> y\n    // z -> x\n    slice.c[0] = (A*x + E)*x + C;\n    slice.c[1] = B;\n    slice.c[2] = D*x + F;\n    slice.c[3] = G*x + I;\n    slice.c[4] = H;\n    slice.c[5] = J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a projective line that goes through the origin and y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_perspective_plane(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n    slice[0] = (B*y + C)*y + A;\n    slice[1] = E*y + D;\n    slice[2] = F;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective ray that goes through the origin and (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_perspective_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = (A*p.x + E)*p.x + (D*p.x + B*p.y + F)*p.y + C;\n    slice[1] = G*p.x + H*p.y + I;\n    slice[2] = J;    \n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and an orthogonal plane that goes through x\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_ortho_plane(in surface2x3 surf, float x,\n\tout surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    // y -> y\n    // z -> x\n    slice.c[0] = C;\n    slice.c[1] = B;\n    slice.c[2] = F;\n    slice.c[3] = E*x + I;\n    slice.c[4] = D*x + H;\n    slice.c[5] = (A*x + G)*x + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and an orthogonal line that goes through y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n    slice[0] = A;\n    slice[1] = C*y + D;\n    slice[2] = (B*y + E)*y + F;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and an orthogonal ray that goes through (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_ortho_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n    \n    slice[0] = C;\n    slice[1] = E*p.x + F*p.y + I;\n    slice[2] = (A*p.x + G)*p.x + (D*p.x + B*p.y + H)*p.y + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a line\n// g(x,y) = G*x + H*y + I\n// with non-zero y coefficient (you may need to swap components of input arguments)\n// return the univariate quadratic function\n// h(x) = J*x^2 + K*x + L\n// along that line\nsurface2x1 surface2x2_slice(in surface2x2 surf, vec3 line) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    vec2 n = line.xy;\n    float w = line.z;\n    float f = 1.0 / (n.y*n.y);\n    return surface2x1(\n\t\tA*n.y*n.y + B*n.x*n.x - C*n.x*n.y,\n \t\t2.0*B*n.x*w - C*n.y*w + D*n.y*n.y - E*n.x*n.y,\n \t\tB*w*w - E*n.y*w + F*n.y*n.y)*f;\n}\n\n// for a convex quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + J\n// return the near and far points on the bounding interval parallel\n// to the plane normal n\nvoid quadric_bounds(vec4 surf, vec3 n, out vec3 d0, out vec3 d1) {\n\tfloat A = surf[0]; float B = surf[1]; float C = surf[2]; float J = surf[3];\n    float q = sqrt(-A*B*C*J/(B*C*n.x*n.x + A*C*n.y*n.y + A*B*n.z*n.z));\n\td0 = q*n/vec3(A, B, C);\n    d1 = -d0;\n}\n\n// for a convex second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the near and far points on the bounding interval along the z-plane\nvoid surface2x3_bounds(surface2x3 surf, out vec3 d0, out vec3 d1) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n\tfloat J = surf.c[9];\n\t\n    float q = sqrt((2.0*(2.0*(B*C*G*G - C*D*G*H + A*C*H*H\n        - B*E*G*I - A*F*H*I + A*B*I*I + C*D*D*J + B*E*E*J\n        - D*E*F*J + A*F*F*J - 4.0*A*B*C*J) + D*F*G*I + D*E*H*I + E*F*G*H)\n\t\t\t- D*D*I*I - E*E*H*H - F*F*G*G) / (4.0*A*B - D*D));\n    \n    float f = 0.5 / (4.0*A*B*C - C*D*D - B*E*E + D*E*F - A*F*F);\n    \n    vec3 t = vec3(\n        -4.0*B*C*G + F*F*G + 2.0*C*D*H - E*F*H + 2.0*B*E*I - D*F*I,\n        2.0*C*D*G - E*F*G - 4.0*A*C*H + E*E*H - D*E*I + 2.0*A*F*I,\n        2.0*B*E*G - D*F*G - D*E*H + 2.0*A*F*H - 4.0*A*B*I + D*D*I\n    )*f;\n    vec3 s = vec3(D*F - 2.0*B*E, D*E - 2.0*A*F, 4.0*A*B - D*D)*q*f;\n    d0 = t - s;\n    d1 = t + s;\n}\n\n// for a convex bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the near and far points on the bounding interval along the y-axis\nvoid surface2x2_bounds(surface2x2 surf, out vec2 d0, out vec2 d1) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    float q = sqrt(E*E - 4.0*B*F + (B*D*D + C*C*F - C*D*E)/A);\n    float f = 1.0 / (4.0*A*B - C*C);\n    vec2 s = q*vec2(-C, 2.0*A)*f;\n    vec2 t = vec2(C*E - 2.0*B*D, C*D - 2.0*A*E)*f;\n    d0 = t - s;\n    d1 = t + s;\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvoid surface2x1_bounds(surface2x1 surf, out float d0, out float d1) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n    float k = -0.5*B/A;\n    float q = sqrt(k*k - C/A);\n    d0 = k - q;\n    d1 = k + q;\n}\n\n// construct a quaternion from an axis and angle\nvec4 versor(vec3 w, float a) {\n    a *= 0.5;\n    return vec4(w * sin(a), cos(a));\n}\n\n// rotation matrix constructor from versor\nmat3 rotation (vec4 q) {\n    float n = dot(q,q);\n    vec4 qs = (n == 0.0)?vec4(0.0):(q * (2.0 / n));\n    vec3 w = qs.w * q.xyz;\n    vec3 x = qs.x * q.xyz;\n    vec3 y = qs.y * q.xyz;\n    float zz = qs.z * q.z;\n    return mat3(\n        1.0 - (y.y + zz), x.y + w.z, x.z - w.y,\n        x.y - w.z, 1.0 - (x.x + zz), y.z + w.x,\n        x.z + w.y, y.z - w.x, 1.0 - (x.x + y.y));\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nconst float max_frustum_depth = 5.0;\nconst vec3 light_dir = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 backlight_dir = normalize(vec3(0.8, 1.0, -1.0));\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\n// linear white point\nconst float W = 11.2;\n\nconst float T = 0.05;\nfloat filmic_reinhard_curve (float x) {\n    float q = (T + 1.0)*x*x;    \n\treturn q / (q + x + T);\n}\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nvoid paint() {\n    float t = iTime;\n       \n    \n    translate(-2.0, 0.0);\n    \n    float rdot = AAINV*4.0;\n    \n    float trange = mod(t, 3.0);\n    vec3 axis = normalize(vec3(1.0,1.0,1.0));\n\n    mat3 mtx_rot = rotation(versor(axis, t));\n    vec3 pos = vec3(lissajous(t*0.3, 5.0, 4.0)*0.3, sin(t*0.12)*0.5);\n    pos.x += 2.0;\n    \n    vec3 r = mix(vec3(0.1, 0.8, 0.5),vec3(0.5, 0.5, 1.0),sin(t*0.31)*0.5+0.5);\n#if 1\n    vec4 q = vec4(1.0/(r.x*r.x),1.0/(r.y*r.y),1.0/(r.z*r.z),-1.0);\n#else\n    vec4 q = vec4(1.0,1.0,-1.0,0.01);\n#endif\n \n    vec2 p = get_origin();\n    \n    vec4 plane0 = vec4(1.0,0.0,0.0,-p.x).yzxw;\n    vec4 plane1 = vec4(0.0,0.0,1.0,-p.y).yzxw;\n    \n    vec3 l0; vec3 l1;\n    plane_slice(plane0,plane1,l0,l1);\n    \n    mat4 mtx_offs = mat4(1.0);\n    mtx_offs[3] = vec4(-pos, 1.0);\n    mat4 mtx = mat4(mtx_rot) * mtx_offs;\n\tsurface2x3 surf3;\n    surface2x3_new(q, mtx, surf3);\n    \n    surface2x2 surf2o;\n    surface2x3_project_ortho_xy(surf3, surf2o);\n    \n    surface2x1 surf1o;\n    surface2x2_project_ortho_x(surf2o, surf1o);\n    float o0, o1, o2, o3;\n    surface2x1_bounds(surf1o, o0, o1);\n\tsurface2x2_swizzle_yx(surf2o);\n    surface2x2_project_ortho_x(surf2o, surf1o);\n    surface2x1_bounds(surf1o, o2, o3);\n    surface2x2_swizzle_yx(surf2o);\n    \n    float fov = 0.2;\n    \n    surface2x2 surf2z;\n    surface2x3_slice(surf3, vec4(0.0,0.0,1.0,0.0), surf2z);\n    surface2x3_swizzle_yzx(surf3);\n    \n    surface2x2 surf2c;\n    surface2x3_project_perspective_xy(surf3, surf2c);\n    surface2x2_swizzle_yx(surf2c);\n    \n    surface2x2 surf2;\n    surface2x3_slice(surf3, plane0, surf2);\n    surface2x2_swizzle_yx(surf2);\n    \n    surface2x1 surf1 = surface2x2_slice(surf2, l0);\n    \n    float z0; float z1;\n\tsurface2x1_bounds(surf1, z0, z1);\n    \n    vec4 rp0 = mtx * vec4(p.xy, z0, 1.0);\n    // viewspace normal\n    vec3 vn = normalize(surface2x3_diff(surf3, vec3(p.y, z0, p.x)).zxy);\n    // modelspace normal\n    vec3 n = quadric_normal(q, rp0.xyz);\n    \n    float lf = max(dot(vn,light_dir),0.0);\n    float lf2 = max(dot(vn,backlight_dir),0.0);\n    \n    vec3 albedo = texture(iChannel1, rp0.yz).rgb;\n    albedo *= albedo;\n    albedo += vec3(0.0,0.5,1.0) * (1.0 - clamp((abs(z0)-0.01)*80.0,0.0,1.0));\n    \n    vec3 lit = vec3(1.0,0.9,0.5) * lf * 8.0 + vec3(0.7,0.8,1.0) * lf2 * 1.0;\n    vec3 color = albedo * lit;\n    //color += 4.0*pow(1.0 - max(dot(vn, vec3(0.0,0.0,-1.0)),0.0), 8.0);\n    \n    color = filmic_reinhard(color);\n    color = pow(color, vec3(0.5));\n    color.rg = pow(color.rg, vec2(1.5,1.2));\n    \n    if (z0 == z0) {\n    \tset_source_rgb(color);\n    } else {\n        set_source_rgb(vec3(0.1,0.1,0.15));\n    }\n    clear();\n\n    vec3 v0, v1, v2, v3;\n    surface2x3_bounds(surf3, v0, v1);\n    surface2x3_swizzle_yzx(surf3);\n    surface2x3_bounds(surf3, v2, v3);\n    vec2 p0, p1, p2, p3;\n    surface2x2_bounds(surf2z, p0, p1);\n    surface2x2_swizzle_yx(surf2z);\n    surface2x2_bounds(surf2z, p2, p3);\n    surface2x2_swizzle_yx(surf2z);\n    \n    vec2 c0, c1;\n    surface2x2_bounds(surf2c, c0, c1);\n    \n    set_line_width_px(1.3);\n    v0 = v0.zxy;\n    v1 = v1.zxy;\n    \n    float dz;\n    dz = surface2x2_eval(surf2o, p) * 0.01;\n    if (dz < 0.0) {\n        set_source_rgba(vec4(vec3(0.5,0.0,1.0), 0.5 * (1.0 - min(abs(dz)*4.0,1.0))));\n        clear();\n    }\n    set_source_rgba(1.0,0.5,0.0,0.3);\n    move_to(o0, -1.0);\n    line_to(o0, 1.0);\n    move_to(o1, -1.0);\n    line_to(o1, 1.0);\n    stroke();\n    move_to( 0.0, o2);\n    line_to( 4.0, o2);\n    move_to( 0.0, o3);\n    line_to( 4.0, o3);\n    stroke();\n    {\n\t    set_source_rgb(1.0,0.5,0.0);\n        vec4 oc = surface2x2_contacts(surf2o, vec4(o0, o1, o2, o3));\n            \n        circle(o0, oc.z, rdot * 2.0);\n        circle(o1, oc.w, rdot * 2.0);\n        circle(oc.x, o2, rdot * 2.0);\n        circle(oc.y, o3, rdot * 2.0);\n        stroke();\n    }    \n#if 1\n    if (z0 > 0.0 || (z0 != z0)) {\n        dz = surface2x2_eval(surf2z, p);\n        set_source_rgba(vec4(vec3(1.0), 1.0 - min(abs(dz)*4.0,1.0)));\n        clear();\n        \n        set_source_rgb(vec3(0.0,0.5,1.0));\n        circle(p0.x, p0.y, rdot);\n        circle(p1.x, p1.y, rdot);\n        circle(p2.y, p2.x, rdot);\n        circle(p3.y, p3.x, rdot);\n        fill();        \n        if (p0.y == p0.y) {\n            float y0 = p0.y;\n            float y1 = p1.y;\n            float x0 = p2.y;\n            float x1 = p3.y;\n            rectangle(x0, y0, x1 - x0, y1 - y0);\n            stroke(); \n        }\n    }\n    \n    {\n        const float W = 0.15;\n        set_source_rgba(0.0,1.0,0.5,0.3);\n        move_to(0.0, 0.0);\n        line_to(4.0, -4.0*fov);\n        move_to(0.0, 0.0);\n        line_to(4.0, 4.0*fov);\n        stroke();\n        set_source_rgb(vec3(0.0,1.0,0.5));\n        move_to(0.0, 0.0);\n        line_to(4.0, 4.0*c0.y);\n        move_to(0.0, 0.0);\n        line_to(4.0, 4.0*c1.y);\n        stroke();\n        set_source_rgb(vec3(1.0,0.5,0.0));\n        circle(v0.x, v0.y, rdot);\n        circle(v1.x, v1.y, rdot);\n        circle(v2.y, v2.z, rdot);\n        circle(v3.y, v3.z, rdot);\n        fill();\n        float x0 = v0.x;\n        float x1 = v1.x;\n        float y0 = v2.z;\n        float y1 = v3.z;\n        rectangle(x0, y0, x1 - x0, y1 - y0);\n        stroke();        \n        \n    }\n#endif    \n\n    \n#if 0\n    set_source_rgb(vec3(1.0,0.0,0.0));\n    move_to(-1.0,-1.0);\n    line_to( 1.0,-1.0);\n    line_to( 1.0, 1.0);\n    line_to(-1.0, 1.0);\n    close_path();\n    stroke();\n#endif    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}