{
    "Shader": {
        "info": {
            "date": "1562787759",
            "description": "Blend between form and light",
            "flags": 0,
            "hasliked": 0,
            "id": "ttsSD8",
            "likes": 4,
            "name": "Ghost Chamber #15",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield",
                "ghost"
            ],
            "usePreview": 0,
            "username": "audiopixel",
            "viewed": 1050
        },
        "renderpass": [
            {
                "code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com | http://audiopixel.com\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 glow;\nfloat d1;\nfloat t1;\nfloat t2;\nvec3 b_8(vec3 c1, vec3 c2){\n    return (c1 + c2) - (c1 * c2);\n}\n\nvec3 b_6(vec3 c1, vec3 c2){\n    return (c1 + c2) - 1.0;\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = 3.14159265358979323846 * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mo(inout vec2 p, vec2 d) {\n    vec2 q = p;\n    q.x = abs(q.x) - d.x;\n    q.y = abs(q.y) - d.y;\n    if (q.y > q.x) q = q.yx;\n    return q;\n}\n\nfloat map(vec3 p) {\n    float d = 0.8194;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * -3.759);\n    p.xz *= r2d(sign(a) * sin(t2 * 7.) - 300.);\n    p.xz = mo(p.xz, vec2(-12.9879, -11.1065));\n    p.zx = mo(p.zx, vec2(5.4177, 2.3984));\n    p.xz = max(abs(p.xz) - -3.8964, -11.7321);\n    p.z = mod(p.z, 29.0)-(29.0 *.5);\n    p.x = mod(p.x, 66.4961)-(66.4961 *.5);\n    p.y = mod(p.y + d1, 29.0) - 5.;\n    p.zy = mo(p.zy, vec2(0.0, -9.6678));\n    p.xz = mo(p.xz, vec2(2.0, 11.1212));\n    p.yx = mo(p.yx, vec2(5.3815, 6.15875));\n    d = min(d, soc(max(abs(p) - 1.8368, -1.91 + (sin(d1 * .05) * 1.5))));\n    glow += vec3(0.8784314,0.8784314,0.8784314) * 0.0431 / (0.0539 + d*d);\n    return (length(p * -0.6424) - -0.7392) * 0.1944 - (d * -1.939);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = (iTime *.8) + 90.;\n    d1 = (-t1 * 11.) + 22.17;\n    t2 = t1 / 29.;\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.01 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 97.0);\n    vec3 rd = normalize(vec3(st + vec2(0.), -0.49671));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<92; i++) {\n        md = map(mp);\n        mp += (rd * 0.1784) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 1.6979 - (b * 0.1462) * -0.6102;\n    float dB = 0.9117 - (b * 0.1348) * -1.998;\n    dA = sinc(dA, 0.3252);\n    dB = sinc(dB, 0.2127);\n    float src1 = dA * -0.3094;\n    float src2 = dB * -1.0;\n    float src3 = dB * -1.0;\n    float src4 = dA * 0.4847;\n    vec3 c;\n    src1 *= 2.0;\n    src2 *= 0.9038;\n    c = b_6((mix(vec3(0.0,0.5882353,1.0), vec3(0.0), src1) * 1.0),(mix(vec3(0.0), vec3(1.0,0.0,0.9411765), src2) * 1.211));\n    c = c * vec3(src3);\n    c = b_6(c,vec3(src4));\n    vec3 gt = c + (glow * 0.1);\n    c = b_8(c,gt);\n    fragColor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}