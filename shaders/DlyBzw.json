{
    "Shader": {
        "info": {
            "date": "1702034131",
            "description": "press 'L' in fullscreen to restart render.\n'max_bounces' and 'aa_level' can be modified to change render quality.",
            "flags": 48,
            "hasliked": 0,
            "id": "DlyBzw",
            "likes": 11,
            "name": "flower of life",
            "published": 3,
            "tags": [
                "floweroflifelebensblumepathtracingmontecarloartreflectionmetal"
            ],
            "usePreview": 0,
            "username": "ich",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // gamma\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * ************** quality **************\n */\n \n#define max_bounces 4\n#define aa_level 0\n\n/*\n * ************** constants **************\n */\n\n#define max_dist 100.\n#define min_dist .001\n#define max_it 1000\n#define pi 3.1415926\n\n/*\n * ************** util **************\n */ \n\nfloat n21(vec2 s) {\n\treturn fract(9876. * sin(dot(s, vec2(987, 654))));\n}\n\nvec2 n22(vec2 s) {\n\tfloat n = n21(s);\n    return vec2(n, n21(s + n));\n}\n\nvec3 n33(vec3 s) {\n    return vec3(n21(s.xy), n21(s.yz), n21(s.zx));\n}\n\nmat3 look_at(vec3 d) {\n    vec3 u = vec3(0, 1, 0);\n    \n    // if u and d are similar, then use different algorithm\n    \n    if (abs(dot(d, u)) < .5) {\n        vec3 r = normalize(cross(d, u));\n        u = normalize(cross(r, d));\n        return mat3(r, u, d);\n    }\n    \n    u = normalize(cross(d, vec3(1, 0, 0)));\n    vec3 r = normalize(cross(d, u));\n    return mat3(r, u, d);\n}\n\n/*\n * ************** 2D SDF operations **************\n */ \n\nfloat extrude(vec3 p, float l, float h) {\n    vec2 w = vec2(l, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n/*\n * ************** 2D SDFs **************\n */ \n\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat ring(vec2 p, float r, float w) {\n    return abs(circle(p, r)) - w;\n}\n\nfloat infinite_hexagon(vec2 p, float r, float w) {\n    float l = 2.;\n    float h = r * cos(pi / 6.);\n    float v = r * sin(pi / 6.);\n    \n    p.x = abs(mod(p.x - h, h*2.) - h);\n    p.y = abs(mod(p.y - v, v*2.) - v);\n\n    l = min(l, ring(p - vec2(h, -v), r, w));\n    l = min(l, ring(p - vec2(0, r), r, w));\n    l = min(l, ring(p - vec2(-h, v), r, w));\n    l = min(l, ring(p - vec2(2.*h, 0), r, w));\n    \n    return l;\n}\n\nfloat lebensblume_region(vec2 p, float r, float w) {\n    float l = 2.;\n    float h = r * cos(pi / 6.);\n    float v = r * sin(pi / 6.);\n    \n    p = abs(p);\n    \n    l = min(l, circle(p, r));\n    l = min(l, circle(p - vec2(0, v*4.), r));\n    l = min(l, circle(p - vec2(h, v*3.), r));\n    l = min(l, circle(p - vec2(h*2., v*2.), r));\n    l = min(l, circle(p - vec2(h*2., 0), r));\n    \n    return l - w;\n}\n\nfloat lebensblume(vec2 p, float r, float w) {\n    return max(lebensblume_region(p, r, w), infinite_hexagon(p, r, w));\n}\n\n/*\n * ************** 3D SDFs **************\n */\n\nfloat plane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 r, float rc) {\n    vec3 q = abs(p) - r + rc;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rc;\n}\n\n/*\n * ************** scene **************\n */\n\nstruct Material {\n    bool light;\n    float rough;\n    vec3 color;\n};\n\nMaterial materials[] = Material[] (\n    Material (false, 0.35, vec3(.7, .9, .7)),\n    Material (true,  0.0, vec3(1)),\n    Material (false, 0.01, vec3(1)),\n    Material (false, 0.9, vec3(1, .1, .2)),\n    Material (false, 0.5, vec3(1))\n);\n\n#define SCENE \\\n    xmin(0, -box(p, vec3(3, 3, 5), .2)); \\\n    xmin(2, sphere(p - vec3(2, -2, 1), 1.)); \\\n    xmin(3, sphere(p - vec3(-2, -2, .5), 1.)); \\\n    xmin(3, sphere(p - vec3(2, -2, 4), 1.)); \\\n    xmin(4, extrude(p - vec3(0, 0, -2), lebensblume(p.xy, .9, .04), .1)); \\\n    xmin(1, plane(p - vec3(0, 0, -2), normalize(vec3(0, 0, 1)))); \\\n   \nfloat scene(vec3 p) {\n    float l = max_dist;\n    \n    #define xmin(I, lo) l = min(l, lo)\n    SCENE\n    #undef xmin\n    \n    return l;\n}\n\nint material_index(vec3 p) {\n    float l = max_dist;\n    int i = 0;\n    \n    #define xmin(I, lo) if (lo < l) { l = lo; i = I; }\n    SCENE\n    #undef xmin\n    \n    return i;\n}\n\nMaterial material(vec3 p) {\n    return materials[material_index(p)];\n}\n\n/*\n * ************** algorithm **************\n */\n\nbool march(vec3 ro, vec3 rd, out float lo) {\n    lo = 0.;\n    \n    for (int i = 0; i < max_it && lo < max_dist; ++i) {\n        float l = scene(ro);\n        lo += l;\n        ro += rd * l;\n        \n        if (l < min_dist)\n            return true;\n    }\n    \n    return false;\n}\n\nvec3 normal(vec3 p) {\n\tfloat l = scene(p);\n\tvec2 e = vec2(0, min_dist * .5);\n\treturn normalize(\n\t\tl - vec3(\n\t\t\tscene(p - e.yxx),\n\t\t\tscene(p - e.xyx),\n\t\t\tscene(p - e.xxy)\n\t));\n}\n\nvec3 reflect_diffuse(vec3 rd, vec3 n, float rough) {\n    vec3 n3 = n33(rd + iTime);\n    //n3 = n33(vec3(iTime, iTime+.1, iTime+.2));\n    float axy = n3.x * pi * 2.;\n    float az = n3.y * pi * .5;\n    \n    float x = cos(axy) * cos(az);\n    float y = sin(axy) * cos(az);\n    float z = sin(az);\n    vec3 dir = vec3(x, y, z);\n    \n    vec3 diffuse = look_at(n) * dir;\n    vec3 mirror = reflect(rd, n);\n    \n    //return n3.z < rough ? diffuse : mirror;\n    return mix(mirror, diffuse, rough);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 col = vec3(1);\n    \n    for (int i = 0; i < max_bounces; ++i) {\n        float l, rough;\n        if (!march(ro, rd, l))\n            break;\n            \n        vec3 p = ro + rd * l;\n        vec3 n = normal(p);\n        Material m = material(p);\n            \n        float atten = 1.0;\n        \n        // fade out into distance\n        //atten *= smoothstep(max_dist, max_dist*.5, l);\n        \n        // view normals\n        //return atten * abs(n);\n        \n        // view roughness\n        //return vec3(atten * m.rough);\n        \n        col *= m.color;\n        \n        if (m.light)\n            return col;\n        \n        ro = p + n * min_dist * 2.;\n        rd = reflect_diffuse(rd, n, m.rough);\n    }\n    \n    return vec3(0);\n}\n\nvec3 emit(vec3 view_pos, vec3 view_dir, float fov, vec2 fragCoord) {\n    vec3 col = vec3(0);\n    \n    float pixel = 1. / iResolution.y;\n    vec3 ro = view_pos;\n    \n    int aa = 1 << aa_level;\n    \n    for (int i = 0; i < aa; ++i) {\n        float a = float(i) / float(aa) * pi * 2.;\n        vec2 fragOffset = vec2(cos(a), sin(a)) * .5;\n        \n        vec2 uv = (fragCoord - fragOffset - iResolution.xy*.5) / iResolution.y;\n        vec3 rd = look_at(view_dir) * normalize(vec3(uv, fov));\n        \n        col += trace(ro, rd);\n    }\n    \n    return col / float(aa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 view_pos = vec3(0, -1, 4);\n    vec3 view_dir = normalize(vec3(0, 0, -1));\n    \n    col = emit(view_pos, view_dir, .7, fragCoord);\n    \n    const int KEY_L = 76;\n    bool reset = .5 < texelFetch(iChannel1, ivec2(KEY_L, 0), 0).r;\n    if (!reset)\n        col = mix(col, texture(iChannel0, uv).rgb, 0.99);\n    //col = col / (float(iFrame) + 1.) + texture(iChannel0, uv).rgb * (1. - 1. / (float(iFrame) + 1.));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}