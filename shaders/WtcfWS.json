{
    "Shader": {
        "info": {
            "date": "1613321333",
            "description": "A quick and simple scene inspired by the Resident Evil movie, with a fair bit of artistic license thrown in.\nNeeearly 4Kb...",
            "flags": 64,
            "hasliked": 0,
            "id": "WtcfWS",
            "likes": 13,
            "name": "T-Virus",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "evil",
                "umbrella",
                "movie",
                "resident",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 9713
        },
        "renderpass": [
            {
                "code": "// 'T-Virus' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WtcfWS\n//\n// Audio: https://soundcloud.com/chrisse/resident-evil-main-extended\n//\n// A quick and simple scene inspired by the Resident Evil\n// movie, with a fair bit of artistic license thrown in.\n//\n// I think in the future I'll spend some time trying\n// to improve my raymarching code when it has reflection\n// and refraction. I suspect there's a more performant\n// method.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUE vec3(.01, .48, .83)\n\n#define Z0 min(iTime, 0.)\n\nfloat T;\nbool inFluid;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF Distance\n\tint id;  // Material ID\n};\n\nfloat h31(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o)\n{\n\tfloat t = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x) + t + o, 2. * t) - t;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTwist(vec3 p, vec2 r, float g, float o) {\n\tfloat gb2 = g * .5,\n\t\t  a = abs((atan(p.x, p.z) + 3.141 * o) * gb2 - mod(p.y, 3.141 * g));\n\treturn length(vec2(length(p.xz) - r.x, a > 3.141 * gb2 ? 3.141 * g - a : a)) - r.y;\n}\n\nvec3 rayDir(vec3 ro, vec3 at, vec2 uv) {\n\tvec3 f = normalize(at - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat bblz(vec3 p) {\n\tp.x += sin(T * .2 + floor(p.z) * 22.34) * .4;\n\tp.y -= (T + 1.23) * (.3 + h31(floor(p.xzx)));\n\treturn max(length(fract(p - .1) - .5) - mix(.02, .1, h31(floor(p))), length(p.xz) - 6.);\n}\n\nfloat helix(vec3 p) {\n\tp.xz *= rot(1.57);\n\treturn min(sdTwist(p, vec2(4.8, 1), 3., 1.), sdTwist(p, vec2(4.8, 1), 3., 2.));\n}\n\nHit tube(vec3 p) {\n\tHit cyl = Hit(sdCyl(p, vec2(8, 18)), 3);\n\tif (cyl.d > 5.) return cyl;\n\n\tHit h = Hit(max(helix(p), cyl.d), 2);\n\n\tcyl.d = max(cyl.d - .5, abs(abs(p.y) - 18.) - 5.);\n\tminH(h, cyl);\n\n\treturn h;\n}\n\nvec3 tube2Map(vec3 p) {\n\tp.xz *= rot(.4);\n\tp.x -= 30.;\n\tp.y += 9.5;\n\tp.yz *= rot(1.57);\n\treturn p;\n}\n\nHit glass(vec3 p) {\n\tvec2 v = vec2(8, 13);\n\treturn Hit(min(sdCyl(p, v), sdCyl(tube2Map(p), v)), 4);\n}\n\nHit tubez(vec3 p) {\n\tHit h = tube(p);\n\tminH(h, tube(tube2Map(p)));\n\treturn h;\n}\n\nHit map(vec3 p) {\n\tif (inFluid)\n\t\treturn Hit(bblz(p), 1);\n\n\tHit h = Hit(abs(p.y + 18.5), 5);\n\tminH(h, tubez(p));\n\tminH(h, Hit(140. - length(p.xz), 6));\n\n\treturn h;\n}\n\nvec3 logo(vec3 p) {\n\tfloat a = atan(p.x, p.z) + 3.14;\n\n\tp.xz = opModPolar(p.xz, 8., .4);\n\tp.x -= 140.;\n\n\tvec3 rw = mix(vec3(1, 0, 0), vec3(1), mod(floor(a * 1.27), 2.));\n\treturn mix(vec3(.2), rw, step(80., length(p.xz)));\n}\n\nvec3 calcN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0026 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * t).d;\n\t}\n\n\treturn normalize(n);\n}\n\nvec3 glassN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0026 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * glass(p + e * t).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = Z0; i < 30.; i++)\n\t{\n\t\tfloat h = tubez(t * ld + p).d;\n\t\ts = min(s, 20. * h / t);\n\t\tt += h;\n\t\tif (s < .01 || t > 25.) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\tp += n * h;\n\treturn clamp(min(glass(p).d, map(p).d) / h, 0., 1.);\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 3, -10) - p),\n\t\t n = h.id == 4 ? glassN(p, d) : calcN(p, d),\n\t\t c = vec3(0);\n\tfloat ss = 0.;\n\n\tif (h.id == 1)\n\t\tc = BLUE;\n\telse if (h.id == 2) {\n\t\tc = BLUE;\n\n\t\t// Sub-surface scattering.\n\t\tss = smoothstep(0., 1., tubez(3. * ld + p).d / 3.);\n\t} else if (h.id == 3)\n\t\tc = vec3(1);\n\telse if (h.id == 5)\n\t\tc = logo(p);\n\telse c = vec3(.05, .1, .15);\n\n\t// Primary light.\n\tfloat l1 = max(0., .1 + .9 * dot(ld, n)),\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)),\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * 10.;\n\n\t// Bubblez/glass.\n\tif (h.id == 1 || h.id == 4)\n\t\treturn c + l2 + (spe + l1) * .15;\n\n\t// Fresnel.\n\tfloat fre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,\n\t\t  _ao = dot(vec2(ao(p, n, .2), ao(p, n, 2.)), vec2(.4, .6));\n\n\tif (h.id == 6)\n\t\treturn c + (l1 + spe) * .02;\n\n\tl1 *= (.3 + .7 * calcShadow(p, ld)) // ...with shadow.\n\t\t  * (.3 + .7 * _ao); // ...and _some_ AO.\n\n\t// Combine into final color.\n\tfloat lig = l1 + (l2 * .3 + spe) * _ao + ss;\n\treturn mix(lig * c * vec3(2, 1.8, 1.7), vec3(.1), fre);\n}\n\nvec3 march(vec3 ro, vec3 rd, float x) {\n\t// Raymarch.\n\tvec3 p = ro,\n\t\t col = vec3(0);\n\n\tfloat md = -1., d = .01, o = 1.;\n\n\tif (inFluid) {\n\t\tfloat bubbleO = 1.;\n\t\tcol = BLUE;\n\t\tfor (float i = Z0; i < 40.; i++) {\n\t\t\tp = d * rd + ro;\n\t\t\tHit h = Hit(bblz(p), 1);\n\n\t\t\tif (d > 15.)\n\t\t\t\tbreak;\n\n\t\t\tif (abs(h.d) < .0015) {\n\t\t\t\t// Not physically accurate, but looks ok.\n\t\t\t\td++;\n\t\t\t\tcol += lights(p, rd, d, h) * .3 * bubbleO;\n\t\t\t\tbubbleO *= .25;\n\t\t\t}\n\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\treturn col;\n\t}\n\n\tbool inGlass = false;\n\tfloat shine = 0.;\n\tfor (float i = Z0; i < 140.; i++) {\n\t\tp = d * rd + ro;\n\t\tHit gh, h = map(p);\n\n\t\tif (abs(h.d) < .0015) {\n\t\t\tcol += (lights(p, rd, d, h) + shine) * o;\n\t\t\tif (md < 0.)\n\t\t\t\tmd = d;\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t\to *= h.id == 6 ? .02 : .1;\n\t\t\tro = p;\n\t\t\trd = reflect(rd, calcN(ro, d));\n\t\t\td = .5;\n\t\t} else if (!inGlass && (gh = glass(p)).d < .0015) {\n\t\t\tinGlass = true;\n\t\t\tshine = lights(p, rd, d, gh).r;\n\t\t\tro = p + gh.d * rd;\n\t\t\trd = refract(rd, glassN(ro, d), .8);\n\t\t\td = .5;\n\t\t\tcontinue;\n\t\t}\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = iTime;\n\n\tfloat ph = smoothstep(16., 22., T) - smoothstep(40., 50., T);\n\tvec3 lookAt = mix(vec3(0, 2, 0), vec3(30, -5, 0), ph);\n\tfloat m = max((cos((T - 13.) * .25) + 1.) / 2., .01);\n\tvec3 ro = vec3(m * m * 40., 2. + m * m * 25., -2. - 60. * m)\n\t\t\t  - vec3(40, -25, 40) * ph;\n\n\tinFluid = length(ro.xz) < 6.5;\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, rayDir(ro, lookAt, uv), uv.x);\n\n#ifdef AA\n    // My attempt at 'quick' anti-aliasing...\n\tif (length(fwidth(col)) > .08) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - .5) / iResolution.xy), uv.x);\n\n\t\tcol /= 5.;\n\t}\n#endif\n\n\tfragColor = vec4(vignette(pow(col * min(iTime, 1.), vec3(.45)), fc), 0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 25425,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/chrisse/resident-evil-main-extended"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}