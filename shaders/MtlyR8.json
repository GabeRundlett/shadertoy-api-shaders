{
    "Shader": {
        "info": {
            "date": "1503488942",
            "description": "Manhattan / taxicab / Linfinity distance evaluates distances with max(|x2-x1|,|y2-y1|).\n\nYou can also play with L2 distance, L1 distance, octogonal distance by uncommenting lines.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtlyR8",
            "likes": 32,
            "name": "Manhattan Voronoi distance",
            "published": 3,
            "tags": [
                "2d",
                "worley",
                "bug",
                "pattern",
                "short",
                "voronoid"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2477
        },
        "renderpass": [
            {
                "code": "#define N 3   // tested neighborhood. Make it odd > 3 if R is high \n#define R .5  // jittering radius. .5 = anywhere in the tile. could be < or >\n\n// rand 1D, rand 2D, signed rand\n#define rnd(p)\tfract(sin( dot(p, vec2(12.9898, 78.233) )       ) * 43758.5453 )\n#define rnd2(p) fract(sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) * 43758.5453 )\n             // mat3( 127.1,311.7, 74.7, 269.5,183.3,246.1, 113.5,271.9,124.6))\n#define srnd(p)  ( 2.*rnd(p) -1. )\n#define srnd2(p) ( 2.*rnd(p) -1. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= 100.;\n    float m=1e9,m2, c=1e2, v,w;\n    \n    for (int k=0; k<N*N; k++) {          // --- visit 3x3 neighbor tiles ------------------\n        vec2 iU = floor(U)+.5,           // tile center \n              g = iU + vec2(k%N,k/N)-1., // neighbor cell\n              p =  g+ srnd2(g)*R -U     // vector to jittered cell node\n                 +.1*sin(iTime+vec2(1.6,0)+3.14*srnd(g)),         // time jittering\n              q = p * mat2(1,-1,1,1)*.707;                        // pi/4 rotation\n      //p *= 1.5+1.*srnd(g+.1);                                   // jittering scale\n      //q = p * mat2(sin(iTime+3.14*srnd(g)+1.57*vec4(1,2,0,1))); // jittering rotation. NB don't compile if in declaration\n        c = min(c,length(p));            // L2 distance to node (to display node)\n        \n                                         // --- choose distance kind ------------------\n      //v = length(p);                   // L2 distance\n      //v = abs(p.x)+abs(p.y);           // L1 distance\n        p = abs(p); v = max(p.x,p.y);    // Linfinity distance ( = Manhattan = taxicab distance)\n      //q = abs(q); w = max(q.x,q.y);    // rotated version\n      //v = w;\n      //v = max(v, w);                   // octogonal distance\n        if (v < m) m2 = m, m = v;        // keep 1st and 2nd min distances to node\n        else if (v < m2) m2 = v;        \n    }\n    \n  //v = m;                               // custom distance to node\n    v = m2-m;                            // distance to voronoi diagram\n\n    int t = int(2.+iTime/2.)%7;         // --- coloring scheme ------------------\n    O =   t==0 ? vec4(0,m2,m,0)          // display 1st and 2nd min distances\n        : t==1 ? vec4(sin(30.*v))        // iso-lines\n        : t==2 ? vec4( 1.-v )            // raw distance\n        : t==3 ? vec4(.025,.05,.1,0)/v   // Voronoi diagram + chromatic effect\n        : t==4 ? vec4(smoothstep(0.,2.,100.*v)) // Voronoi contours\n        : t==5 ? vec4(sin(30.*m))        // cell iso-lines\n        : t==6 ? vec4( 1.-m )            // cell raw distance\n        : O;\n\n    O.r +=  .03/c;                        // debug: display nodes\n  //U=fract(U); O.b += .01/min(U.x,U.y);  // debug: display tiles\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}