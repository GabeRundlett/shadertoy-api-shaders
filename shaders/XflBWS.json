{
    "Shader": {
        "info": {
            "date": "1725576117",
            "description": "Inspired by [this plot](https://commons.wikimedia.org/wiki/File:Gee_three_real.jpeg)\n\nMouse enabled!",
            "flags": 0,
            "hasliked": 0,
            "id": "XflBWS",
            "likes": 2,
            "name": "Modular Form Plot",
            "published": 3,
            "tags": [
                "2d",
                "math",
                "complex",
                "meromorphic"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 73
        },
        "renderpass": [
            {
                "code": "#define ITERATIONS 8\n#define AA 1\n//#define BLACK_AND_WHITE\n\nvec4 pi = vec4(0,2,4,8)*atan(1.0);\n\nvec2 cpow(vec2 z1, vec2 z2)\n{\n\tfloat a2b2 = z1.x * z1.x + z1.y * z1.y;\n\tfloat t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n\tfloat t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n\treturn vec2(t1 * cos(t2), t1 * sin(t2));\n}\n\nvec2 cmul(vec2 a, vec2 b){return mat2(a, -a.y, a.x)*b;}\nvec2 cinv(vec2 z){return vec2(z.x, -z.y)/dot(z, z);}\nvec2 cdiv(vec2 a, vec2 b){return cmul(a, cinv(b));}\nvec2 csqr(vec2 z){return cmul(z, z);}\nvec2 cquar(vec2 z){vec2 sqr = csqr(z); return csqr(sqr);}\nvec2 csix(vec2 z){return cmul(csqr(z), cquar(z));}\n\nfloat bump(float x, float a, float b){\n    return smoothstep(a, 0.5*(a + b), x)*smoothstep(0.0, 0.5*(b - a), b - x);\n}\n\nvec3 color(float r){\n    float s = step(0.0, r)*log(1.0 + 0.1*abs(r));\n    return vec3(smoothstep(8.0, 16.0, s), bump(s, 2.0, 16.0),  bump(s, 0.0, 6.0));\n}\n\nvec2 eisenstein(vec2 z){\n    vec2 result = vec2(0);\n\n    //prevent unroll lol\n    int iter = ITERATIONS + int(z.x * 0.0);\n    for(int m = -iter; m <= iter; m++) {\n        for(int n = -iter; n <= iter; n++) {\n            if(m != 0 || n != 0) {\n                result += cinv(csix(float(m)*z + vec2(n, 0)));\n            }\n        }\n    }\n    return result;\n}\n\nvec2 diskMap(vec2 z, vec2 a){//will be a bijection of the unit disk if |a|<1\n    return cmul(z-a, cinv(cmul(vec2(a.x, -a.y), z) - vec2(1.0, 0.0)));\n}\n\nvec3 render(vec2 fragCoord) {\n\n    vec2 p = 1.1*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    // mobius transformation that seems to work\n    vec2 z = p;\n    vec2 m =\n        iMouse.xy == vec2(0) ? vec2(0)\n        : 2.0*iMouse.xy/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    m *= 0.5;\n    if(length(m) > 1.0) m = normalize(m);\n    z = diskMap(z, m);\n    z.y += 1.0;\n    z = -cinv(z);\n    z.y -= 0.5;\n\n    #ifdef BLACK_AND_WHITE\n    if(length(p) < 1.0) {\n        return vec3(eisenstein(z).x < 0.0);\n    }\n    #else\n    if(length(p) < 1.0) {\n        return length(p) < 1.0 ? color(eisenstein(z).x) : vec3(0, 0, 1);\n    }\n    #endif\n    else {\n        return vec3(0, 0, 1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.rgb = render(fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}