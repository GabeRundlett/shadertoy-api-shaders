{
    "Shader": {
        "info": {
            "date": "1673187807",
            "description": "I asked chatGPT to add the actual field shape into an external function based on this shader it wrote just a moment ago.\nhttps://www.shadertoy.com/view/ctSGWh",
            "flags": 0,
            "hasliked": 0,
            "id": "clSGWh",
            "likes": 0,
            "name": "ChatGPT Rotating field box v.2",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "BitsnBobs",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "float sdBox(vec2 p, vec2 s)\n{\n    // Calculate the distance from the point to the box\n    return length(max(abs(p) - s, 0.0)) + min(max(abs(p.x), abs(p.y)), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Rotation angle (in radians)\n    float angle = iTime * 0.5;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Rotate the coordinate system\n    vec2 p = rot*uv;\n\n    // Box size\n    vec2 s = vec2(0.3, 0.4);\n\n    // Calculate the signed distance field\n    float d = sdBox(p, s);\n\n    // Convert the distance to a color\n    vec3 color = vec3(d);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n/*\nput the actual sdf shape into an external function in the above shader\nCertainly! Here is the modified version of the shader that puts the calculation of the signed distance field (SDF) into a separate function:\n\nCopy code\nfloat sdBox(vec2 p, vec2 s)\n{\n    // Calculate the distance from the point to the box\n    return length(max(abs(p) - s, 0.0)) + min(max(abs(p.x), abs(p.y)), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Rotation angle (in radians)\n    float angle = iTime * 0.5;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Rotate the coordinate system\n    vec2 p = rot*uv;\n\n    // Box size\n    vec2 s = vec2(0.3, 0.4);\n\n    // Calculate the signed distance field\n    float d = sdBox(p, s);\n\n    // Convert the distance to a color\n    vec3 color = vec3(d);\n\n    fragColor = vec4(color, 1.0);\n}\nIn this version of the shader, the sdBox function takes in a point p and a box size s, and returns the signed distance from the point to the box. The main image function then uses this function to calculate the signed distance field for each pixel on the screen.\n\nI hope this helps! Let me know if you have any questions.\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}