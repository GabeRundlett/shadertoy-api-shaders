{
    "Shader": {
        "info": {
            "date": "1652226332",
            "description": "Added Multisampling\n\nSee https://youtu.be/A2IAyXc0LuE and https://youtu.be/yrDbD90HXyo for videos on why there appear to be circles all over the sphere.\n\nDerived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4",
            "flags": 0,
            "hasliked": 0,
            "id": "sljBWW",
            "likes": 4,
            "name": "Sphere of cubes multisampled",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Ptyonic",
            "viewed": 328
        },
        "renderpass": [
            {
                "code": "// derived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n\n// added \"msaa\" to shadertoy.com/view/7ds3zB#\n \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t, out float t2) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   t2 = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool step_forward(in Ray R, inout float t, inout vec3 roundpoint, out int coord, in float max_t, in float cubeWidth, in float cubesRad){\n    vec3 point = R.Origin + t*R.Dir;\n    vec3 signDir = sign(R.Dir);\n    /// solve for param: point + param*Dir = roundpoint + 0.5*(signDir)*cubeWidth component by component\n    vec3 params = (roundpoint - point + 0.5*signDir*cubeWidth)/R.Dir;\n\n    // find out which wall we hit next\n    if(params.x < params.y){\n        if(params.x < params.z){ coord = 0;}\n        else{ coord = 2;}\n    }\n    else{\n        if(params.y < params.z){ coord = 1;}\n        else{ coord = 2;}\n    }\n    \n    t += params[coord];\n    vec3 move = vec3(0.0,0.0,0.0);\n    move[coord] += cubeWidth;\n    roundpoint += signDir*move;\n\n    if(length(roundpoint) < cubesRad){ \n        roundpoint -= signDir*move; // take a step back to the cube before we hit the solid cube\n        return false; } // we hit a cube \n    if(t > max_t){ coord = 3; \n        return false;\n    }  // meaning that we were tangent to the sphere of cubes and didnt hit anything\n \n    return true; // keep going\n}\n\nfloat mysmoothstep(in float x){\n    float t = clamp(x, 0.0, 1.0);\n    t = 1.0 - pow((1.0 - t),1.5); \n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float time = float(100 + iFrame)/100.0;\n   float cubeWidth = 1.0/time;  \n   //float cubeWidth = 0.2;\n   float sphereRad = 1.0;\n   float cubesRad = sphereRad - cubeWidth*0.5*sqrt(3.0); // cube with center within this rad is contained in sphere\n \n   vec3 red = vec3(1.0,0.0,0.0);\n   vec3 green = vec3(0.0,1.0,0.0);\n   vec3 blue = vec3(0.0,0.0,1.0);\n   \n   float beta = 3.14159 / 4.0 + 0.2; // * time; // * time;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera \n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.5),\n       vec3(0.0),\n       50.0       \n   );\n   \n   Sphere S = Sphere(vec3(0.0), sphereRad);\n\n   fragColor = vec4(0.0);\n   \n   int MULTISAMPLE = 16;\n   for (int yOff = 0; yOff < MULTISAMPLE; yOff++) {\n       for (int xOff = 0; xOff < MULTISAMPLE; xOff++) {\n           Ray R = launch(C, fragCoord + (vec2(xOff, yOff) / float(MULTISAMPLE)));\n\n           float t;\n           float max_t;\n           int coord;\n\n           vec3 col = vec3(0.0);\n           if(intersect_sphere(R,S,t,max_t)) {\n              vec3 point = R.Origin + t*R.Dir;\n              vec3 roundpoint = round(point/cubeWidth)*cubeWidth;\n\n              bool cont = true;\n              for(int i = 0; i <= 50; i++) { \n                  cont = step_forward(R, t, roundpoint, coord, max_t, cubeWidth, cubesRad);\n                  if(cont == false){break;}\n              }\n              if(coord <= 2) { // hit a solid cube\n                  col[coord] = 1.0;\n\n                  vec3 point = R.Origin + t*R.Dir;\n                  vec3 signOctant = -sign(point);\n                  point -= roundpoint; // now relative to the cube center we just hit\n                  point *= signOctant; // now moving in the positive direction sends us to potential solid cubes\n                  point /= cubeWidth; // now in (-0.5,0.5)^2\n\n                  float brightness = 1.0;\n                  float d = 0.3; // ambient occlusion darkness amount\n\n                  vec3 move1 = vec3(0.0,0.0,0.0);\n                  move1[(coord + 1) % 3] += cubeWidth;\n                  vec3 neighbour1 = signOctant*roundpoint + move1;\n                  vec3 move2 = vec3(0.0,0.0,0.0);\n                  move2[(coord + 2) % 3] += cubeWidth;\n                  vec3 neighbour2 = signOctant*roundpoint + move2;\n                  vec3 move3 = move1 + move2;\n                  vec3 neighbour3 = signOctant*roundpoint + move3;\n                  bool n1solid = (length(neighbour1) < cubesRad);\n                  bool n2solid = (length(neighbour2) < cubesRad);\n                  bool n3solid = (length(neighbour3) < cubesRad);\n\n                  if(n1solid){\n                      brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 1) % 3]);\n                  }\n                  if(n2solid){\n                      brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 2) % 3]);\n                  }\n\n                  if(n3solid && (!n1solid && !n2solid)){\n                      float s1 = mysmoothstep(0.5 - point[(coord + 1) % 3]);\n                      float s2 = mysmoothstep(0.5 - point[(coord + 2) % 3]);\n                      float foo = 1.0 - (1.0 - s1)*(1.0 - s2);\n                      brightness *= (1.0 - d) + d*foo;\n                  }\n\n                  col *= brightness;          \n                  fragColor += vec4(col, 1.0);\n              } else {\n                  fragColor += vec4(0.5, 0.5, 0.5, 1.0);\n              }\n           } else {\n               fragColor += vec4(0.5, 0.5, 0.5, 1.0);\n           }\n        }\n    }\n    fragColor /= fragColor.a;\n}\n \n ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}