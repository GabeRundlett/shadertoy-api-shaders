{
    "Shader": {
        "info": {
            "date": "1673470195",
            "description": "Draw as thin a spiral as possible, while minimizing aliasing artefacts. This one has colours and uses gamma correction as it makes colour bands wider and helps reduce artefacts ('x' to toggle). Colour palette is just an oblique line through RGB space.",
            "flags": 16,
            "hasliked": 0,
            "id": "mlS3RG",
            "likes": 12,
            "name": "Colourful Thin Spiral",
            "published": 3,
            "tags": [
                "spiral"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "// Colourful Thin Spiral, mla, 2023\n// Draw as thin a spiral as possible, while minimizing\n// aliasing artefacts. This one has colours and uses gamma\n// correction as it makes colour bands wider and helps\n// reduce artefacts.\n//\n// Colour palette is just an oblique line through RGB space.\n//\n// 'c': colours\n// 'x': gamma\n// 't': triangle wave (+ smoothstep)\n// 'z': disable mouse control\n\nfloat spiral = 2.0; // Number of arms on spiral, 0 for no spiral\nfloat scale = 1.0;  // This can be any value in fact\nfloat k = 0.55;     // Magic number, can be set with mouse-x\n\nvec3 palette(float t) {\n  vec3 col = t*vec3(0.414,0.618,1);\n  col = mod(col,2.0);\n  col = min(col,2.0-col);\n  //col = hsv2rgb(col);\n  if (!key(CHAR_X)) col *= col;\n  return col;\n}\n\nfloat wave(float t) {\n  if (!key(CHAR_T)) return 0.5*(1.0-cos(TWOPI*t));\n  // Triangle wave + smoothstep - without smoothing not enough\n  // at top and bottom & worse aliasing. With smoothing, I can't\n  // tell this from the cos curve though (smoothstep is a good\n  // approximation to an offset cosine).\n  t *= 2.0;\n  t = mod(t,2.0);\n  t = min(t,2.0-t);\n  t = smoothstep(0.0,1.0,t); // Cubic smoothing\n  return t;\n}\n\nvoid mainImage(out vec4 o, vec2 p) {\n    if (!key(CHAR_Z) && iMouse.x > 1.0) k = iMouse.x/iResolution.x; // Set k from mouse\n    p -= 0.5*iResolution.xy;\n    p /= scale;\n    float d = length(p);\n    float px = fwidth(p.x); // Same as 1.0/scale\n    float angle = spiral*atan(p.y,p.x)/TWOPI;\n    float h = 0.5*k*d/px;\n    h -= 1.0*iTime;\n    h += angle;\n    float h0 = h;\n    h = floor(h);\n    h -= angle;\n    //h -= 1.0*iTime; // How fast colours travel in the spiral\n    o = vec4(0.8);\n    if (!key(CHAR_C)) o.rgb = palette(h);\n    o *= wave(h0);\n    //o *= 2.0/(1.0+o); // tone mapping\n    float g = 0.4545;\n    //if (iMouse.y > 0.0) g = iMouse.y/iResolution.y;\n    if (!key(CHAR_X)) o = pow(o,vec4(g)); // Gamma correction if desired.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}