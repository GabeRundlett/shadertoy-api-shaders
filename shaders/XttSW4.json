{
    "Shader": {
        "info": {
            "date": "1479691215",
            "description": "wiener schnitzel shader - guten appetit! :-)",
            "flags": 0,
            "hasliked": 0,
            "id": "XttSW4",
            "likes": 26,
            "name": "schnitzel shader",
            "published": 3,
            "tags": [
                "schnitzel",
                "wien",
                "mjam",
                "mjamm"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1218
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define randSampler iChannel0\n#define randRes iChannelResolution[0]\n\n// this is a modified version of iq's noise in \"volcanic\"\n// (doesnt rely on the correlation between the color channels)\nvec4 getRand3DS(vec3 pos)\n{\n    vec3 x=pos;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture(randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture(randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nvec3 getFolding(vec3 pos)\n{ \n    pos*=.5;\n    vec2 xy=vec2(pos.x+1.*cos(2.*pos.x),pos.y+1.*cos(2.*pos.y));\n    return vec3(-xy*.2,sin(pos.x+1.5*sin(1.*pos.y))*sin(pos.y+1.5*sin(1.*pos.x)));\n    return vec3(xy,\n                sin(xy.x)+sin(xy.y));\n}\n\nfloat ellipsoidDist(vec3 size,vec3 pos)\n{\n    return (length( pos/size ) - 1.0) * min(min(size.x,size.y),size.z);\n}\n\nfloat schnitzelDist(vec3 pos)\n{\n    pos+=vec3(3,0,0);\n    vec3 pos2=pos\n        +1.5*getRand3DS(pos*.3).xyz\n        //+.4*getRand3DS(pos*.5*10.).xyz\n        //+.14*getRand3DS(pos*.5*33.333).xyz\n\t\t+.7*getFolding(pos*1.)\n\t\t+.3*getFolding(pos*2.)\n        ;\n    //return ellipsoidDist(vec3(15.,20.,1.5),pos2);\n    return ellipsoidDist(vec3(13.,18.,2.),pos2)\n        +.9 *getRand3DS(pos*.3).x\n        +.12*getRand3DS(pos*.5*10.).x\n        +.07*getRand3DS(pos*.5*33.333).x\n        ;\n}\n\n// iq - https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat diskDist(vec3 pos, float r, float d)\n{\n    float dplane = abs(pos.z)-.5*d;\n    float dtorus = length(vec2(r-length(pos.xy),pos.z))-.7*d;\n    float dcyl   = length(pos.xy)-r+.5*d;\n    return smin(max(dplane,dcyl),dtorus,.6);\n}\n    \nfloat plateDist(vec3 pos)\n{\n    float l=length(pos.xy);\n    float ang=atan(pos.y,pos.x);\n    pos.xy+=clamp((l-17.)/17.,0.,1.)*2.*normalize(pos.xy)*.05*(1.-pow(1.+sin(ang*8.),4.));\n    return diskDist(pos+vec3(0,0,1.5-.5*atan(3.*(length(pos.xy)-20.))),26.,.4);\n}\n\n// iq - https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylDist(vec3 pos, float h, float r)\n{\n    return sdCappedCylinder( pos.xzy, vec2(r*2.,h) );\n    float d = max(length(pos.xy)-r,pos.z-h*.5);\n    //d=max(d,torus);\n    return d;\n}\n\nfloat smoothbox(float x1, float x2, float w, float x)\n{\n    w*=.5;\n    return smoothstep(x1-w,x1+w,x)*(1.-smoothstep(x2-w,x2+w,x));\n}\n\n#define PI2 6.28318530717959\n\nvec2 lemonDistExt(vec3 pos)\n{\n    pos+=vec3(3,0,0);\n    pos+=.65*getRand3DS(pos*.3).xyz;\n    float lemRadius=4.;\n    float ang=atan(pos.y,pos.x);\n    float d=cylDist(pos+vec3(0,0,-2.5),.2,2.);\n    // mat:\n    // 0...white tissue\n    // 1...yellow peel\n    // 2...fruit pulp\n    float segNum =9.;\n    float l=length(pos.xy);\n    float sn=2.*l*sin(ang*segNum/2.);\n    float pulp=smoothbox(.1*lemRadius,.87*lemRadius,.05*lemRadius,l)*(1.-clamp(exp(-sn*sn)*1.,0.,1.));\n    float mat=mix(mix(0.,1.,smoothstep(lemRadius-.2,lemRadius-.1,l)),2.,pulp+.001);\n    float angQ = -(floor(ang*segNum/PI2)+.5)/segNum*PI2;\n    vec2 cs=vec2(cos(angQ),sin(angQ));\n    mat2 segRot = mat2(cs.xy,cs.yx*vec2(-1,1));\n    d += pulp*.06*getRand3DS( vec3(segRot*pos.xy,pos.z)*10.*vec3(.2,1,1) ).x;\n    d += pulp*.05;\n    return vec2(d,mat);\n}\n\nvec2 getDistExt(vec3 pos) // x=dist, y=material\n{\n    float dS = schnitzelDist(pos);\n    float dP = plateDist(pos);\n    vec2  dL = lemonDistExt(pos);\n    vec2 d=vec2(1.e6,0);\n    if(dS<d.x)   d=vec2(dS,1);\n    if(dP<d.x)   d=vec2(dP,2);\n    if(dL.x<d.x) d=vec2(dL.x,3.+.1*dL.y);\n    return d;\n}\n\nfloat getDist(vec3 pos) // x=dist, y=material\n{\n    return getDistExt(pos).x;\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec3 d=vec3(eps,0,0);\n    return vec3(\n        getDist(pos+d.xyy)-getDist(pos),\n        getDist(pos+d.yxy)-getDist(pos),\n        getDist(pos+d.yyx)-getDist(pos)\n    )/eps;\n}\n\nvec3 shadeBg()\n{\n    return vec3(.7,.8,.9);\n}\n\nvec3 raymarch(vec3 pos, vec3 dir)\n{\n    vec3  eye=pos;\n    float eps=.02;\n    float mat=0.;\n    float num=0.;\n    for(int i=0;i<150;i++)\n    {\n        vec2 d=getDistExt(pos);\n        pos+=dir*.6*d.x;\n        num=float(i);\n        if(d.x<eps) { mat=d.y; num+=eps/d.x; break; }\n    }\n\n    vec3 light = vec3(30,30,100);\n    vec3 ldir=normalize(light-pos);\n\tvec3 spos=pos+.05*ldir;\n    float shadow=0.;\n    for(int i=0;i<50;i++)\n    {\n        float d=getDist(spos);\n        spos+=ldir*d/*+getRand3DS(spos*10.).xyz*.05*/;\n        if(d<eps) { shadow=1.; break; }\n    }\n    \n    vec3 n=normalize(getGrad(pos,.01));\n    vec3 nC=normalize(getGrad(pos,1.));  // coarse grained normal\n\n    //shadow *= abs(dot(nC,ldir));\n    shadow *= clamp(1./length(pos-spos),0.,1.);\n    shadow = 1.-.3*shadow;\n\n    float ao=1.;\n    ao *= (1.-num/200.);\n    vec3 spec = texture(iChannel1,reflect(pos-eye,n).yzx*vec3(1,-1,1)).xyz;\n    vec3 specC = texture(iChannel1,reflect(pos-eye,nC).yzx*vec3(1,-1,1)).xyz;  // coarse grained normal\n    //spec*=spec;\n    //specC*=specC;\n    float fresnel = 1.-clamp(dot(n,normalize(eye)),0.,1.);\n    fresnel=.04+.96*pow(fresnel,7.);\n    float fresnelC = 1.-clamp(dot(nC,normalize(eye)),0.,1.);\n    fresnelC=.04+.96*pow(fresnelC,7.);\n    \n    float diff=clamp(dot(n,normalize(light-pos)),.8,1.);\n    diff*=shadow;\n    \n    //return vec3(ao);\n    \n    // lemon\n    if(mat>=3.)\n    {\n        vec3 c2 = diff * vec3(1,1,0.)*.9*ao+4.*spec*fresnel;\n\t    vec3 c1 = diff * vec3(1,1,0.)*1.3*ao;\n        vec3 c0 = diff * vec3(1,1,1)*1.2*ao;\n        return mix(\n            mix(c0,c1,clamp(10.*(mat-3.0),0.,1.)),\n            c2,\n            clamp(10.*(mat-3.1),0.,1.)\n        );\n    }\n    // plate\n    if(mat>=2.) return diff*ao*1.+3.*spec*fresnel;\n    // schnitzel\n    if(mat>=1.) \n        return diff*vec3(1,.57,0)*1.1*ao*.7*(.9+clamp(.3*pos.z,0.,.6))\n        \t+1.*specC*fresnelC;\n    \n    return shadeBg();\n}\n\n\nfloat getVign(vec2 fragCoord)\n{\n\tfloat rs=length(fragCoord-iResolution.xy*.5)/iResolution.x;\n    return 1.-1.5*rs*rs*rs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m=(iMouse.xy/iResolution.y)*1.5+vec2(0,.1);\n    if(iMouse.y==0.) m.y=.6;\n    float ang=iTime*.3+m.x*2.;\n    vec3 pos=vec3(cos(ang)*cos(m.y),sin(ang)*cos(m.y),sin(m.y))*65.;\n    vec2 scoord = (fragCoord-iResolution.xy*.5)/iResolution.x;\n    vec3 dir0 = normalize(-pos-vec3(0,0,6));\n    vec3 right = normalize(vec3(dir0.yx*vec2(1,-1),0));\n    vec3 up=cross(right,dir0);\n    vec3 dir = dir0 + right*scoord.x + up*scoord.y;\n    \n\tfragColor = vec4(raymarch(pos,dir),1)*1.1*getVign(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}