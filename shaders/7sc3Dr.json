{
    "Shader": {
        "info": {
            "date": "1629557432",
            "description": "easing cheat sheet",
            "flags": 0,
            "hasliked": 0,
            "id": "7sc3Dr",
            "likes": 19,
            "name": "easing cheat sheet",
            "published": 3,
            "tags": [
                "easing"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 645
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n#define S(p,d,b) smoothstep(fwidth(uv.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\n// easing functions:https://github.com/glslify/glsl-easings\nfloat linear(float t) {\n  return t;\n}\n\nfloat backInOut(float t) {\n  float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n  float g = pow(f, 3.0) - f * sin(f * PI);\n\n  return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n  \nfloat quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n\nvec3 testGraphic(vec2 uv, vec3 col, float ease, float y){\n    float r = 0.03;\n    \n    vec2 pos = vec2(0.0,y);\n    float d = B(uv+pos,vec2(2.0,0.001));\n    col = mix(col,vec3(0.2),S(uv,d,0.0));    \n    \n    pos = vec2(0.0,y);\n    d = B(uv+pos,vec2(ease,0.001));\n    col = mix(col,vec3(0.8),S(uv,d,0.0));    \n    \n    pos = vec2(ease,y);\n    d = length(uv+pos)-r;\n    col = mix(col,vec3(1),S(uv,d,0.0));    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float endTime = 4.0;\n    float t = mod(iTime,endTime);\n    float dist = 1.4;\n    float end = dist;\n    float time = t;\n    float start = -(dist*0.5);\n    if(t>=1.0 && t<2.0){\n        time = 1.0;\n    }\n    if(t>=2.0 && t<3.0){\n        end = -dist;\n        time = 1.0-(3.0-t);\n        start = dist*0.5;\n    }\n    if(t>=3.0){\n        end = -dist;\n        time = 1.0;\n        start = dist*0.5;\n    }\n    \n    // backInOut\n    float ease = start+backInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.4);\n    \n    // cubicInOut\n    ease = start+cubicInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.32);   \n    \n    // quarticInOut\n    ease = start+quarticInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.24);     \n        \n    // exponentialInOut\n    ease = start+exponentialInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.16);   \n            \n    // sineInOut\n    ease = start+sineInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.08);  \n                \n    // elasticInOut\n    ease = start+elasticInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.0);  \n                    \n    // quadraticInOut\n    ease = start+quadraticInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.08); \n                        \n    // qinticInOut\n    ease = start+qinticInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.16); \n                            \n    // circularInOut\n    ease = start+circularInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.24);\n                            \n    // bounceOut\n    ease = start+bounceOut(time)*end;\n    col = testGraphic(uv,col,ease,0.32);    \n                                \n    // linear\n    ease = start+linear(time)*end;\n    col = testGraphic(uv,col,ease,0.4);  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}