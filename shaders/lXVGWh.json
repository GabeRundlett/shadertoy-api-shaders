{
    "Shader": {
        "info": {
            "date": "1717673055",
            "description": "An implementation of Dekker arithmetic in GLSL.",
            "flags": 0,
            "hasliked": 0,
            "id": "lXVGWh",
            "likes": 5,
            "name": "GLSL Dekker arithmetic",
            "published": 3,
            "tags": [
                "glsl",
                "double",
                "ieee754",
                "dekker"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// An implementation of Dekker arithmetic in GLSL.\n\n// Sometimes one wants to use double precision floating\n// point, but the platfrom simply doesn't provide it.\n// One option is to use Dekker arithmetic, i.e. represent each\n// value as an unevaluated sum of floating point terms.\n//\n// This shader provides a GLSL implementation of 2*float32 arithmetic,\n// with ~48 bits of precision (compared to 24 bits for float32\n// and 53 bits for float64). The values are represented as vec(high,low).\n// The implementation largely follows Dekker's original ALGOL 60 code.\n// Only 5 operations are provided: +, -, *, /, sqrt. In particular,\n// Dekker-powered FMA is not implemented. The functions are not\n// faithfully-rounded: the accuracy is several units in the\n// last place (ULP), as mentioned in algorithms' descriptions. In the\n// error bounds below, the quantity\n//     u = 2^(-24) = 5.96...e-8\n// is ULP(1.0f)/2.\n//\n// The code is, of course, considerably slower than just using float,\n// but, perhaps, not prohibitively so, at least for some purposes.\n//\n// NOTE: the implementation relies on rounding mode being round-to-nearest.\n// NOTE: only precision is improved, the exponent range is still that of float32.\n// NOTE: this implementation  breaks horribly on overflow. E.g. you can\n// get NaN instead of expected inf.\n\n// References:\n//     [1] Dekker, T. J. (1971). A floating-point technique for extending the available precision. Numerische Mathematik, 18(3), 224–242. doi:10.1007/bf01397083\n//     [2] D.H. Bailey. A Fortran-90 based multiprecision system. ACM Trans. Math. Software, 21(4):379–387, 1995.\n//     [3] M. Joldes, J.-M. Muller, and V. Popescu. Tight and rigorous error bounds for basic building blocks of double-word arithmetic. ACM Trans. Math. Softw., 44(2):1–27, 2017.\n//             https://hal.science/hal-01351529v3/document\n//     [4] Muller, Jean-Michel & Brisebarre, Nicolas & Dinechin, Florent & Jeannerod, Claude-Pierre & Lefèvre, Vincent & Melquiond, Guillaume & Revol, Nathalie & Stehlé, Damien & Torres, Serge. (2010). Handbook of Floating-Point Arithmetic. 10.1007/978-0-8176-4705-6.\n\n//==============================================================================\n\n// Force the exact evaluation, avoiding optimizations such as\n// reordering (x+y)-y, which, of course, break the algorithm.\n// In GLSL, \"precise\" qualifier may serve the same purpose, when available.\n// In C, volatile temporary may be used for this purpose.\n// Empirically, simple uintBitsToFloat(floatBitsToUint(x)) does\n// not work.\n// This implementation is laaaaame (but less lame now, thanks to @spalmer).\nfloat force(float x)\n{\n    return uintBitsToFloat(floatBitsToUint(x*(1.0+min(0.0,iTime))));\n}\n\n// NOTE: we cannot just naively split the bitwise\n// representation into two 12-bit halves, and so we\n// use Veltkamp’s algorithm instead.\nvec2 split(float x)\n{\n    const float C=4097.0; // 2^12+1. In double it would be 2^27+1.\n    float g=force(C*x);\n    float d=force(x-g);\n    float h=force(g+d);\n    float l=force(x-h);\n    return vec2(h,l);\n}\n\n// Exact sum of x and y assuming |x|>=|y|.\nvec2 Fast2Sum(float x,float y)\n{\n    float s=force(x+y);\n    float z=force(s-x);\n    float t=force(y-z);\n    return vec2(s,t);\n}\n\n// Exact sum of x and y.\nvec2 TwoSum(float x,float y)\n{\n#if 0\n    // Branchless 6-op version.\n    float s=force(x+y);\n    float A=force(s-y);\n    float B=force(s-A);\n    float da=force(x-A);\n    float db=force(y-B);\n    float t=force(da+db);\n    return vec2(s,t);\n#else\n    // Swap if needed, then call Fast2Sum.\n    // May be slower than above, normally,\n    // but our force() is rather slow.\n    if(abs(x)<abs(y)) {float t=x; x=y; y=t;}\n    return Fast2Sum(x,y);\n#endif\n}\n\n#if 0\n// Dekker's original add2 algorithm, equivalent to SloppyDWPlusDW\n// from [3].\n// Absolute error bound: (|x|+|y|)*4*u^2.\n// Relative error is ~unbound under cancellation.\nvec2 add2(vec2 x,vec2 y)\n{\n    float r=force(x.x+y.x);\n    float s=(abs(x.x)>abs(y.x)?\n        force(force(force(force(x.x-r)+y.x)+y.y)+x.y):\n        force(force(force(force(y.x-r)+x.x)+x.y)+y.y));\n    float z=force(r+s);\n    float zz=force(force(r-z)+s);\n    return vec2(z,zz);\n}\n#else\n// AccurateDWPlusDW from [3].\n// Relative error bound: 3*u^2+13*u^3.\nvec2 add2(vec2 x,vec2 y)\n{\n    vec2 s=TwoSum(x.x,y.x);\n    vec2 t=TwoSum(x.y,y.y);\n    float c=force(s.y+t.x);\n    vec2 v=Fast2Sum(s.x,c);\n    float w=force(t.y+v.y);\n    vec2 z=Fast2Sum(v.x,w);\n    return z;\n}\n#endif\n\nvec2 sub2(vec2 x,vec2 y) {return add2(x,-y);}\n\n// Exact product of x and y.\nvec2 mul12(float x,float y)\n{\n    vec2 X=split(x),Y=split(y);\n    float p=force(X.x*Y.x);\n    float q=force(force(X.x*Y.y)+force(X.y*Y.x));\n    float z=force(p+q);\n    float zz=force(force(force(p-z)+q)+force(X.y*Y.y));\n    return vec2(z,zz);\n}\n\n// Dekker's original mul2 algorithm.\n// Relative error bound: 7*u^2.\nvec2 mul2(vec2 x,vec2 y)\n{\n    vec2 c=mul12(x.x,y.x);\n    c.y=force(force(force(x.x*y.y)+force(x.y*y.x))+c.y);\n    float z=force(c.x+c.y);\n    float zz=force(force(c.x-z)+c.y);\n    return vec2(z,zz);\n}\n\n// Dekker's original div2 algorithm.\n// Relative error bound: 22*u^2.\n// NOTE: undefined if y.x==0.0.\nvec2 div2(vec2 x,vec2 y)\n{\n    float c=force(x.x/y.x);\n    vec2 u=mul12(c,y.x);\n    float cc=force(force(force(force(force(x.x-u.x)-u.y)+x.y)-force(c*y.y))/y.x);\n    float z=force(c+cc);\n    float zz=force(force(c-z)+cc);\n    return vec2(z,zz);\n}\n\n// Dekker's original sqrt2 algorithm.\n// Relative error bound: 13*u^2.\n// NOTE: returns vec2(0.0,0.0) for inputs <= 0.\nvec2 sqrt2(vec2 x)\n{\n    if(x.x>0.0)\n    {\n        float c=force(sqrt(x.x));\n        vec2 u=mul12(c,c);\n        float cc=force(force(force(force(force(x.x-u.x)-u.y)+x.y)*0.5)/c);\n        float y=force(c+cc);\n        float yy=force(force(c-y)+cc);\n        return vec2(y,yy);\n    }\n    else return vec2(0.0,0.0);\n}\n\n//==============================================================================\n\nvec3 plot(vec3 bg,vec3 fg,float x,bool border)\n{\n    float a=smoothstep(2.5*fwidth(x),0.0,abs(x));\n    if(border) fg*=a;\n    return mix(bg,fg,a);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    float x=1e-3*uv.r,y=1e-6*uv.g;\n    vec3 col=vec3(0.5);\n    vec2 one=vec2(1.0,0.0),X=vec2(x,0.0);\n    // Naive evaluation in float32, demonstrating loss of precision.\n    col=plot(col,vec3(0.7,0.2,0.2),(1.0-1.0/sqrt(1.0+x*x))-y,true);\n    // Naive evaluation in Dekker arithmetic, with enough precision for float32.\n    col=plot(col,vec3(0.2,0.2,0.7),sub2(one,div2(one,sqrt2(add2(one,mul2(X,X))))).r-y,true);\n    // Alternative analytical expression.\n    col=mix(col,plot(col,vec3(0.2,0.7,0.2),x*x/(1.0+x*x+sqrt(1.0+x*x))-y,true),0.5+0.5*tanh(1e2*sin(1e5*x)));\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}