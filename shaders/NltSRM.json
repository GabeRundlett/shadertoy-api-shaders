{
    "Shader": {
        "info": {
            "date": "1638902173",
            "description": "It seems in this case that IQ's voronoit edges method makes more sense than Tomkh's. If we want to find borders so we can find the nearest intersection, we actually need to find all the borders around pointA, NOT around the uv (or in this case the ro).",
            "flags": 0,
            "hasliked": 0,
            "id": "NltSRM",
            "likes": 12,
            "name": "Voronoi Traversal [comments]",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "commented",
                "borders",
                "edges",
                "comments",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n\n=============================================================\n\nAn important discorvery I made, assuming I am understanding\ntomkh's and Iq's work correctly is that actually:\n\nIQ's method makes more sense than tomkh's here. \nIf we want to find borders \nso we can find the nearest intersection, we actually \nneed to find all the borders around pointA, NOT around \nthe uv (or in this case the ro).\n\nThis way we are garanteed that the edges will be \nthe ones that fully enclose the cell.\n    \nIf you check for borders around ro, you will get borders\nclose to ro for the 3x3 loop which may not find the borders\nin the direction ro+rd*t is even going. So you would then need \na 5x5 loop to do that which is super slow.\n\n==========================================================\n\nHere is a voronoi traversal algorithm I came up with.\nThere are a few hacks involved:\n\n1. When I check edges for a hit I actually check a 5x5 neighborhood\nbecause otherwise the way I do things there are times when not all\nthe correct edges are drawn.\n\n2. The weirdest thing. I find I can't use a constant value \n(such as ray origin) as an input to this algorithm. It has to \nbe moving even a little bit so I jitter with sin(iTime)*0.001\n\nNo idea why. A mouse position will work find and give me the edges, \nbut a set value like vec2(1.,0.) will not. \n\nEDIT: The jitter can be a constant value, we just need to \nbe a tiny bit off from pointA when we checkk pointB for some reason.\n\n*/\n\n/*/////////////////////////////////////////\n\n                  UPDATE\n                  \n    I found a way to make voronoi traversal close to x2 faster!\n    https://www.shadertoy.com/view/7tcSDn\n        \n\n\n////////////////////////////////////////*/\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\n//a method for finding the intersection between\n//two rays. Not effienct but very memorable.\nfloat seg_seg(vec2 ro1, vec2 rd1, vec2 A, vec2 B){\n    vec2 ro2 = A;\n    vec2 rd2 = normalize(B-A);\n    float maxABLange = length(B-A);\n    \n    vec2 perp = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perp) - dot(ro2,perp))/dot(rd2,perp);\n    perp = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perp) - dot(ro1,perp))/dot(rd1,perp);\n    return t >= 0. && s >= 0.? t : 100.;\n}\n\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n/***************************************************\n\nHere is the actual voronoi traversal algorithm\n\n*************************************************** */\nfloat voronoiEdgeHit(vec2 uv, vec2 ro, vec2 rd){\n\n    vec2 st = fract(ro);\n    vec2 stFL = floor(ro);\n    vec2 d = vec2(10.);\n\n    vec2 pointA;\n    vec2 pointB;\n\n\n    float minT = 100.;\n    float t;\n\n    \n    //in this loop we are just looking for the closest point\n    //to the curent ro. It's a standard voronoi but instead of uv\n    //for every pixel we just have ro (the same value) being looked at\n    //every pixel (you wont see \"ro\" here because of what I did above.\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testA = stFL + coords;\n        float c = length(coords.xy - st);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            pointA = testA;\n            \n            }\n        }\n    }    \n    \n    //In this loop I am finding every edge based on Iq's article\n    //meaning I get a new st an stFLoor based on pointA\n    //and find borders around pointA based on that.\n    \n    //so for each edge I check to see where it intersects \n    //with the ray based on ro and rd. We look at 25 edges\n    //around our pointA and the edge that we hit first (minimum t value)\n    //is what we hit so we return that t value and traverse that amount\n    //along the ray.\n    \n    //get a new st and stFL based on the point in this cell that\n    //we've found. This way we are garanteed that the edges will be \n    //the ones that fully enclose the cell!\n    st = fract(pointA);\n    stFL = floor(pointA+0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testB = stFL + coords;\n        \n        float distAB = length(testB-pointA);\n        if( distAB > 0.001 && distAB < 2.){\n            vec2 edgePoint =(pointA+testB)/2.;\n            vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n            vec2 edgeSideA = edgePoint - perp;\n            vec2 edgeSideB = edgePoint + perp;\n          \n          \n          //Check where we intersect the current found edge\n          minT = min(minT, seg_seg(ro,rd,edgeSideA,edgeSideB));\n          //faster version\n          //minT = min(minT, seg_seg_new(ro,rd,edgeSideA,edgeSideB));\n         \n        }\n      }\n    }\n    return minT;\n}\n\n\n\n\n//Basic Voronoi for coloring\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float globalScale = 4.;\n    uv*=globalScale ;\n\n    //get a voronoi for coloring cells an edges\n    vec4 voronoXY = voronoi(uv);\n    \n    //set basic color for all voronoi cells\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    //col.zy *= rot(.1);\n\n    //add some color to the eddges of the voronoi\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.), smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n   //define ro, rd, and set default rotation of rd\n   vec2 ro = vec2(0.,0.);\n   vec2 rd = vec2(1.,0.);\n   rd *= rot(iTime/2.);\n   \n   //adust mouse\n   vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n   //rotate ray based on mouse if mouse press\n   if(iMouse.z > 0.5){rd = normalize(m.xy+ro);}\n   \n   //draw Ray\n   col = mix(col, vec3(1.), line(uv, ro, ro + rd*30., 0.04));\n\n   //Draw RO\n   col = mix(col, vec3(.0,.4,.9),point(uv-ro,0.1));\n   \n   //t value for traversing\n   float t;\n   \n   /****************************************************\n\n                  THIS IS THE MAIN EVENT\n   \n   ****************************************************/\n   \n\n    //we can do 40 x 8 seg-seg intersections without getting slow.\n   for(float i = 0.; i < 15.; i++){\n       t = voronoiEdgeHit(uv,ro,rd);\n       ro += rd*t*1.001;\n       col = mix(col, vec3(1.0,.0,.0),point(uv-ro,0.1));\n       col = mix(col, vec3(1.0,.0,.0),\n           ring(uv-ro,0.24+sin(iTime*4.+i/10.)*0.07));\n   }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}