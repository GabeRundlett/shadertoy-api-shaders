{
    "Shader": {
        "info": {
            "date": "1533052466",
            "description": "Aimaina-chan (with a surprise guest?)\nShoutouts to IQ, PinocchioP and Myo-chan (@forgetfulsubs)",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml3cWN",
            "likes": 12,
            "name": "Aimaina",
            "published": 3,
            "tags": [
                "3d",
                "39"
            ],
            "usePreview": 0,
            "username": "CLPB",
            "viewed": 809
        },
        "renderpass": [
            {
                "code": "// Starting point https://www.shadertoy.com/view/Xds3zN\n\n#define AA 0\n#define PI 3.14159265\n#define FIXED 1\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n// From https://www.shadertoy.com/view/4sXXRN ---\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n// ---\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// From https://www.shadertoy.com/view/ld3Gz2 ---\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n// ---\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// from IQ\nvec2 opUsmin( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opUsmin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// From http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\nfloat aizu(vec2 uv){\n    float sep=.64, si=.4;\n    \n    float d = length(uv-vec2(.5-sep,0.5))-si;\n    d = min(d, length(uv-vec2(.5+sep,0.5))-si);\n    \n    float m = d < 0.0 ? 6.1 : 5.1;\n    \n    d = length(uv-vec2(.5-sep,0.5))-si*.85;\n    d = min(d, length(uv-vec2(.5+sep,0.5))-si*.85);\n    \n    m = d < 0.0 ? 7.1 : m;\n    \n    d = length((uv - vec2(.5-sep,.5))*vec2(6.0,1.0))-si*.7;\n    d = min(d,length((uv - vec2(.5+sep,.5))*vec2(6.0,1.0))-si*.7);\n    \n    m = d < 0.0 ? 6.1: m;\n    \n    return m;\n}\n\nvec2 aimaina( vec3 p )\n{\n    // Dress\n    float dgrad = min(3.0 + ((p.y)+.9), 4.0);\n    \n    vec2 res = opUsmin(\n        \tvec2(sdSphere(p-vec3(0.0,0.14,0.0), .2), dgrad ),\n        \tvec2(sdConeSection( p, .25, .32, 0.15 ), dgrad ),\n        \t0.1\n        );\n    \n    // head\n    res = opU(res,\n              vec2(\n                  length( (p-vec3(0.0,0.55,0.0))/vec3(1.25,1.0,1.2) )-.3, \n                   dot( p, vec3(0.0,0.0,1.0) ) > 0.0 ? \n                   aizu((p.xy-vec2(-0.15,0.4))*3.7)\n                   : 5.1));\n    \n    // arms\n    res = opU(res,\n              vec2(sdCapsule(vec3(abs(p.x),p.yz), vec3(0.18,0.23,0.0), vec3(0.46,.14,.0), 0.05),5.1)\n              );\n    \n    // legs\n    res = opU(res,\n              opU(vec2(sdCapsule(p, vec3(0.12,-0.1,0.0), vec3(.08,-.4,.0), 0.06),5.1),\n                  vec2(sdCapsule(p, vec3(-0.12,-0.1,0.0), vec3(-.08,-.4,.0), 0.06),5.1))\n              );\n    \n    float hgrad = 8.0+((p.y)*1.5+0.5);\n    // hair semidome\n    res = opU(res,\n              vec2(\n                  min(\n                      min(\n                        min(\n                          // Hair semidome\n                          opS(\n                          sdSphere((p-vec3(0.0,0.6,-0.01))/vec3(1.25,1.0,1.1),0.35),\n                          sdSphere((p-vec3(0.0,-0.1,0.4))/vec3(1.0,1.25,1.0),0.7)\n                          ),\n                          // hairblade left\n                          udTriangle(vec3(0.0,0.79,0.33),vec3(0.3,0.7,0.28),vec3(0.35,0.4,0.3), p)-0.003\n                        ),\n                        // hairblade mid\n                        udTriangle(vec3(-0.19,0.75,0.31),vec3(0.0,0.78,0.35),vec3(0.0, 0.5, 0.39), p)-0.003\n                      ),\n                      // side hairblades\n                      min(\n                          min(\n                            udTriangle(vec3(0.4,0.6,0.1),vec3(0.4,0.5,0.0),vec3(.35,.33,.0),vec3(abs(p.x),p.yz))-0.003,\n                            udTriangle(vec3(0.3,0.65,0.24),vec3(0.4,0.6,0.15),vec3(.35,.35,.15),vec3(abs(p.x),p.yz))-0.003\n                          ),\n                          udTriangle(vec3(0.38,0.55,0.17),vec3(0.41,0.5,0.07),vec3(.4,.4,.09),vec3(abs(p.x),p.yz))-0.003\n                      )\n                  ),\n                  hgrad));\n    \n    // pigtails\n\tvec4 b1 = sdBezier( vec3(0.4,0.75,-.1), vec3(0.55,0.3,-0.5), vec3(0.55,-0.15,-0.2), vec3( abs(p.x),p.yz));\n    float d1 = b1.x - b1.y*0.1-0.065;\n    d1 = opS(d1, sdSphere((vec3(abs(p.x),p.yz)-vec3(0.26,0.2,-0.2))*vec3(1.0,0.5,1.0),0.25));\n    res = opU(res, vec2(d1, hgrad));\n    \n    \n    // hairpins\n    mat3 rot1 = rotAxis(vec3(0.0,0.0,1.0),PI*.6);\n    res = opU(res,\n    \tvec2(\n                sdTorus(rot1*(vec3(abs(p.x),p.yz)-vec3( 0.4, 0.75, -0.1)), vec2(0.1,0.05) ), \n        10.1)\n    \t);\n    \n    \n    return res;\n}\n\nfloat doushitex(vec2 uv){\n    float sep=.28, si=.16;\n    uv.x -= .5;\n    \n    // eye outline\n    float d = length(vec2(abs(uv.x),uv.y)-vec2(sep,0.7))-si;\n    \n    // 5.0: skin grey\n    // 11.0: black\n    // 6.0: white\n    // 12.0: mouth\n    // 15.0: mouth 2\n    float m = d < 0.0 ? 11.1 : 5.1;\n    \n    // eye white\n    d = length(vec2(abs(uv.x),uv.y)-vec2(sep,0.7))-si*.8;\n    m = d < 0.0 ? 6.1 : m;\n    \n    float jud = sin(iTime*70.0)*0.008;\n    \n    // iris outer\n    d = length(vec2(abs(uv.x)+jud,uv.y)-vec2(sep,0.7))-si*.6;\n    m = d < 0.0 ? 11.1 : m;\n    // iris white inner\n    d = length(vec2(abs(uv.x)+jud,uv.y)-vec2(sep,0.7))-si*.28;\n    m = d < 0.0 ? 6.1 : m;\n    // iris black inner\n    d = length(vec2(abs(uv.x)+jud,uv.y)-vec2(sep,0.7))-si*.2;\n    m = d < 0.0 ? 11.1 : m;\n    \n    // mouth\n    d = length(uv*vec2(1.0,0.77)-vec2(.0,.31))-0.12;\n    m = d < 0.0 ? 11.1 : m;\n    d = length(uv-vec2(0.0,0.41))-0.1;\n    m = d < 0.0 ? (uv.y+3.0*uv.x*uv.x<.4? 12.1 : 15.1) : m;\n    \n    // highlight\n    d = length(uv-vec2(sep-si*.4-jud, 0.7+si*0.4))-0.03;\n    m = d < 0.0 ? 6.1 : m;\n    d = length(uv-vec2(-sep-si*.4+jud, 0.7+si*0.4))-0.03;\n    m = d < 0.0 ? 6.1 : m;\n    \n    return m;\n}\n\nfloat dLine(in vec2 a, in vec2 b, in vec2 p)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\treturn length(pa-ba*h);\n}\n\nfloat razor(vec2 uv, float th){\n    float res = dLine(vec2(0.1,0.9), vec2(0.16,0.84),uv);\n    \n    res = min(res,dLine(vec2(.3,.8),vec2(.4,.9),uv));\n    res = min(res,dLine(vec2(.05,.8),vec2(.45,.8),uv));\n    res = min(res,dLine(vec2(.45,.8),vec2(.45,.65),uv));\n    res = min(res,dLine(vec2(.05,.65),vec2(.45,.65),uv));\n    res = min(res,dLine(vec2(.05,.65),vec2(.05,.5),uv));\n    res = min(res,dLine(vec2(.05,.5),vec2(.45,.5),uv));\n    res = min(res,dLine(vec2(.45,.5),vec2(.45,.3),uv));\n    res = min(res,dLine(vec2(.25,.8),vec2(.25,.2),uv));\n    res = min(res,dLine(vec2(.25,.5),vec2(.0,.3),uv));\n    res = min(res,dLine(vec2(.6,.78),vec2(.6,.55),uv));\n    res = min(res,dLine(vec2(.75,.8),vec2(.75,.3),uv));\n    res = min(res,dLine(vec2(.63,.32),vec2(.75,.3),uv));\n    \n    return res-th;\n}\n\nvec2 doushite(vec3 p){\n    // Dress\n    float dgrad = min(13.0 + (p.y)*1.9+0.5, 14.0);\n    dgrad = dot( p, vec3(0.0,0.0,1.0) ) > 0.0 ? mix(dgrad,11.1,(razor(p.xy*3.3-vec2(-0.35,-0.3),0.03)<0.0?1.0:0.0)) : dgrad;\n    \n    vec2 res = opUsmin(\n        \tvec2(sdSphere(p-vec3(0.0,0.15,0.0), .2), dgrad ),\n        \tvec2(sdConeSection( p, .25, .3, 0.15 ), dgrad ),\n        \t0.1\n        );\n    \n    // head\n    res = opU(res,\n              vec2(opS(\n                  \tlength( (p-vec3(0.0,0.55,0.0))/vec3(1.2,1.0,1.1) )-.33,\n                    length(p-vec3(0.0,0.43,0.32))-.07), //mouth\n                   dot( p, vec3(0.0,0.0,1.0) ) > 0.0 ? \n                   doushitex( ( p.xy - vec2(-0.33,0.15) )*1.5)\n                   : 5.1));\n    \n    // arms\n    res = opU(res,\n              opU(vec2(sdCapsule(p, vec3(0.18,0.23,0.0), vec3(0.38,.0,.0), 0.05),5.1),\n                  vec2(sdCapsule(p, vec3(-0.18,0.23,0.0), vec3(-0.46,sin(iTime*40.0)*.1+0.25,.0), 0.05),5.1))\n              );\n    \n    // legs\n    res = opU(res,\n              opU(vec2(sdCapsule(p, vec3(0.12,-0.1,0.0), vec3(.08,-.4,.0), 0.06),5.1),\n                  vec2(sdCapsule(p, vec3(-0.12,-0.1,0.0), vec3(-.08,-.4,.0), 0.06),5.1))\n              );\n    \n    \n    \n    // pigtails\n    float hgrad = 14.0+((p.y+0.33)*0.95);\n    \n\tvec4 b1 = sdBezier( vec3(0.33,0.72,-.01), vec3(0.59,0.4,-0.5), vec3(0.55,-0.15,-0.1), vec3( abs(p.x),p.yz));\n    float d1 = b1.x - b1.y*0.15-0.02;\n    d1 = opS(d1, sdSphere((vec3(abs(p.x),p.yz)-vec3(0.21,0.1,-0.3))*vec3(1.0,0.6,1.0),0.32));\n    res = opU(res, vec2(d1, hgrad));\n    \n    \n    // hairpins ( use bezier )\n    b1 = sdBezier( vec3(0.3,0.72,-.04), vec3(0.3,0.77,-0.08), vec3(0.3,0.9,-0.1), vec3( abs(p.x),p.yz));\n    d1 = b1.x + b1.y*0.08-0.1;\n    d1 = opS(d1, sdSphere((vec3(abs(p.x),p.yz)-vec3(0.21,0.1,-0.3))*vec3(1.0,0.6,1.0),0.32));\n    res = opU(res, vec2(d1, 5.1));\n    \n    // teeth\n    res = opU(res, vec2(length(vec3(abs(p.x)-0.05,p.y-0.45,p.z-0.33))-.01,6.1));\n    \n    // razor\n    res = opU(res,\n              vec2(sdCapsule(p, vec3(0.38,0.0,0.0), vec3(.8,1.3,0.0), 0.008),5.1)\n              );\n    \n    \n    mat3 brot = rotAxis(vec3(0.0,0.0,1.0), PI*0.4);\n    \n    res = opU(res,\n              vec2(\n                  opS( sdCylinder(brot*(p-vec3(0.65,0.8,-0.1)),vec2(.5,0.001)),\n                      sdBox(brot*(p-vec3(0.65,0.8,-0.5)),vec3(0.8,0.1,0.5)) ), \n              5.1)\n             );\n    \n    return res;\n}\n\n// from IQ\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(0.009*p.z)*1.0;\n    float s = sin(0.008*p.z)*1.0;\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y).xzy;\n    return q;\n}\n\nvec2 map( in vec3 pos )\n{   \n    vec3 q = opCheapBend(pos.xyz);\n    float r =.5+pos.x*0.0025;\n    mat2 rothoz = mat2(cos(PI*r), -sin(PI*r), sin(PI*r), cos(PI*r) );\n    q = opCheapBend(q.yxz).yxz;\n    vec3 lrep = vec3(rothoz*pos.xz,pos.y).xzy-vec3(-32.0,-18.0,0.0);\n    q = (pos.y>-10.0)? q : lrep;\n    \n    float a = 1.2;\n    float sep = 3.0;\n    float nthorder = 19.0;\n    float mv = floor(iTime/a) + smoothstep(0.0,1.0,1.5*(mod(iTime,a)/a))-sep*(nthorder-2.0)*.5;\n    mv *= sep;\n    \n    float zrep = mod(q.z-mv,sep)-sep*0.5;\n    \n    // FIXME: Repeating domain such that even values work\n    float drep = mod(q.z-mv, sep*nthorder) - (sep*nthorder)*.5;\n    \n    vec2 aimai = aimaina(vec3(q.x, q.y, zrep));\n    vec2 res =  vec2(opS(aimai.x,\n                       sdSphere(vec3(q.xy,drep),sep*0.5) ), \n                   aimai.y);\n    \n    mat3 rot = rotAxis(vec3(0.0,1.0,0.0),-PI*0.15);\n    res = opU(res,doushite(rot*vec3(q.xy,drep)));\n    \n    // tracks\n    mat3 rotS = rotAxis(vec3(0.0,0.0,1.0),PI*0.5);\n    res = opU(res, \n        \tvec2(\n        \tsdCylinder(\n        \t\trotS*(vec3(q.x,q.y,mod(q.z,0.2)-0.1)-vec3(0.0,-0.65,0.0)),vec2(0.1,0.6)\n        \t), 6.0));\n    //rails\n    res = opU(res, vec2(\n        sdBox(vec3(abs(q.x), q.y, mod(q.z,1.0)) - vec3(0.8,-0.5,0.0), \n              vec3(0.06,0.3,5.0)),6.1));\n    \n    //box\n    res = opU(res,\n             vec2(opS(\n                     sdBox(vec3(q.xy,zrep)-vec3(0.0,-0.4,0.0), vec3(0.6,0.1,0.8)),\n                     sdBox(vec3(q.xy,zrep)-vec3(0.0,-0.17,0.0), vec3(0.55,0.3,0.75))\n             \t),\n                 6.1));\n    \n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 70.0;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.00001*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = mix(vec3(0.02,0.0,0.0), vec3(.1,.05,.3), rd.y*rd.y);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        //vec3 ref = reflect( rd, nor );\n        \n        // TODO: Handle all if statements with 1 gradient function (assuming uniform material and lighting model?)\n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*m );\n        if( m<1.5 )\n        {\n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n        \n        // aimaina dress gradient (3.0-4.0)\n        if (m>3.0)\n        {\n            col = mix(vec3(0.3,0.8,.8), vec3(.3,.8,.8)*.2, m-3.0);\n        }\n        \n        // aimaina skin (5.0)\n        if (m>5.0){\n            col = vec3(0.8);\n        }\n        \n        // aimaina eye white (6.0)\n        if (m>6.0){\n            col = vec3(1.,1.,1.);\n        }\n        \n        // aimaina sclera (7.0)\n        if (m>7.0){\n            col = vec3(1.,0.,0.);\n        }\n        \n        // aimaina hair gradient (8.0-9.0)\n        if (m>8.0){\n            col = mix(vec3(.1,.2,0.4), vec3(.3,.8,.8),m-8.0);\n        }\n        \n        // aimaina hairpin (10.0 - 11.0)\n        if (m>10.0){\n            col = mix(vec3(0.7,0.0,0.8), vec3(0.0,0.2,0.1),\n                      pow( abs(dot(normalize(vec3(0.5,0.5,0.0)), vec3(abs(nor.x),nor.yz))) , 2.0)\n                     );\n        }\n        \n        // doushite black\n        if (m>11.0){\n            col = vec3(0.0);\n        }\n        // doushite mouth red 1\n        if (m>12.0){\n            col = vec3(0.5,0.0,0.0);\n        }\n        \n        // doushite dress gradient\n        if (m>13.0){\n            col = mix(vec3(0.7), vec3(0.3), (m-13.0));\n        }\n        \n        // doushite hair gradient\n        if (m>14.0){\n            col = mix(vec3(.3,.1,0.3), vec3(.9,.4,.6),m-14.0);\n        }\n        \n        // doushite mouth red 2\n        if (m>15.0){\n            col = vec3(0.2,0.0,0.0);\n        }\n\n        // lighting\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        fre = fre*fre*fre;\n\n\t\tvec3 lin = vec3(0.0);\n        col -= fre;\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n\n\t\t// camera\n#if FIXED<1\n        vec3 ro = vec3( 8.0*cos(0.1 + 6.0*mo.x+3.1), \n                       -2.0 + 10.0*mo.y, \n                       8.0*sin(0.1 + 6.0*mo.x+3.1) );\n        float zoom = 1.0;\n#else\n        vec3 ro = vec3( 8.0*cos(PI*.6), \n                       3.0, \n                       8.0*sin(PI*.6) );\n        float zoom = 0.5;\n#endif\n        vec3 ta = vec3( -0.0, -0.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy*zoom,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}