{
    "Shader": {
        "info": {
            "date": "1661528406",
            "description": "asdgasdg",
            "flags": 32,
            "hasliked": 0,
            "id": "ftycWw",
            "likes": 12,
            "name": "Day 981",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/1255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/155.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    \n    vec4 t = Tb(uv);\n    \n    vec2 x = unpackS16(t.x);\n    vec2 y = unpackS16(t.y);\n    vec2 w = unpackU16(t.w)*vec2(100,1500.);\n    \n    vec3 n = normalize(vec3(x.xy,y.x));\n    \n    \n    vec2 st = (1.)/R.xy;\n\n    vec2 l = \n        unpackU16(  Tb(uv+vec2(st.x,0)).w  )-unpackU16(Tb(uv - vec2(st.x,0)).w) +\n        unpackU16(Tb(uv + vec2(0,st.y)).w)-unpackU16(Tb(uv - vec2(0,st.y)).w) +\n        unpackU16(Tb(uv + vec2(st.xy)).w) -unpackU16(Tb(uv - vec2(st.xy)).w) +\n        unpackU16(Tb(uv + vec2(st.x,-st.y)).w)-unpackU16(Tb(uv - vec2(st.x,-st.y)).w)\n    ;\n    \n    l = clamp(abs((l*vec2(100,1500.)).xx)*6.,0.,1.);\n    \n    //t.xyz = unpackS8(t.x).xyz;\n    //C = 1.*t.xyzz + 0.4;\n    C = max(dot(normalize(vec3(1,-1.5,-7)),-n),0.04)*vec4(1);\n    \n    C.xyz *= pow(palAppleII[int(w.y*1111.)%16],vec3(2.));\n    \n    \n    C = mix(C,C*0.,l.x);\n    \n    \n    C = mix(C,vec4(0.9),smoothstep(1.4,2.,w.x*0.3));\n    //max((sin(n.xyzz*0. + w.y*2101110. +vec4(3.,2,0.,1))*0.5 + 0.6),0.1);\n    \n    C = abs(C);\n    C = 1.-exp(-C*1.3);\n    //C = 1.-C*1.;\n    C *=1.5;\n    \n    \n    if(w.x<0.2)\n        C *=0.;\n    \n    C = pow(max(C,0.),vec4(0.454545));\n    //C = vec4(1)*sin(Tb(uv).x*15. + iTime)*0.5 + 0.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define iTime (iTime + 70. + 0.)\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(right,dir));\n    float fov = 2.;\n    return normalize(dir + right*uv.x*fov + up * uv.y*fov);\n}\n\n// 8bit\nhighp uint packU8(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackU8(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packU8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackU8(float a) { return vec4(unpackU8(floatBitsToUint(a))) / 255.; }\nfloat packS8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackS8(float a) { return clamp((vec4(unpackU8(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n\n// 16bit\nhighp uint packU16(highp uvec2 a) {\n    return uint( (a.x << 16)\n               | (a.y << 0)); }\nmediump uvec2 unpackU16(highp uint a) {\n    return uvec2( (a & 0xFFFF0000u) >> 16\n                , (a & 0x0000FFFFu) >> 0   ); }\nfloat packU16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec2  unpackU16(float a) { return vec2(unpackU16(floatBitsToUint(a))) / (pow(2.,16.) - 1.); }\n\n#define S16SZ (pow(2.,16.) - 1.)\n#define halfS16SZ S16SZ/2.\nfloat packS16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, -1., 1.)*halfS16SZ + halfS16SZ)))); }\nvec2  unpackS16(float a) { return clamp((vec2(unpackU16(floatBitsToUint(a))) - halfS16SZ) / halfS16SZ, -1., 1.); }\n\n\n\n//float pack16(  vec3  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\n\n#define R iResolution.xy\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( const vec3 ro, const vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n            \n            vec4 hash42(vec2 p)\n            {\n                vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n                p4 += dot(p4, p4.wzxy+33.33);\n                return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n            }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    \n    vec2 w;\n    \n    if(iFrame == 0){\n        C = vec4(0);\n    } else{\n        C = texture(iChannel0,uv);\n        w = unpackU16(C.w);\n    \n    }\n    \n    \n    \n    float t = w.y;\n    \n    \n    t += 1.;\n    \n    if(C.w > 10.){\n        C.w = 0.;\n        C.x = 1.;\n    }\n    \n    \n    //C.xy = packU16(C.w);\n    \n    // xy - pos\n    // zw - rot, scale, it\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    //vec2 uv = U/R.xy;\n    vec2 uv = (U-0.5*R.xy)/R.y;\n    vec2 uvn = U/R.xy;\n    \n    vec3 ro = vec3(2.,2.4,0)*0.4;\n    \n    \n    if(fract(iTime/4.) < 0.5){\n        ro.y = -1.2;\n        ro.xz *= rot(iTime*4.);\n    }\n    \n    \n    vec3 rd = getRd(ro, vec3(0.4,-0.2,0) + sin(vec3(3,2,1)*iTime*0.1)*0.1, uv );\n    \n    \n    float depth;\n    float hitIt;\n    //vec3 normal = unpackU16(C.w).xyz;\n    \n    if(iFrame == 0){\n        C = vec4(110);\n        depth=100.;\n        hitIt=0.;\n    } else{\n        C = Tb(uvn);\n        \n        depth = unpackU16(C.w).x*100.;\n        hitIt = unpackU16(C.w).y*1500.;\n        \n        depth = abs(depth);\n        \n        \n        depth = min(depth+0.004*2.*(1.+sin(iTime)) + 0.*exp(-abs(depth)*2.1),100.);\n        \n        depth += smoothstep(0.1,0.,depth);\n        //C = vec4(110);\n    }\n    for(float part=0.; part < 1.; part++){\n        vec3 p = vec3(0);\n        float r = 0.;\n        vec3 rvec = vec3(0,0,-1);\n        float s = float(0.1);\n        vec3 n;\n        const float iiters = 115.;\n        const float iitersrecip = 1./iiters;\n        \n        \n        float cnt = 0.;\n        float mode = 0.;\n        float rtdir = 1.;\n        for(float i=0.; i < iiters; i++){\n                \n                \n            //mat4 rot = rotationAxisAngle( normalize(vec3(0.,1.,0.0)), r );\n            //mat4 tra = translate( p.x, p.y, p.z );\n            //mat4 txi = tra * rot; \n            //mat4 txx = inverse( txi );\n            \n            //ip.xz *= rot(r);\n            //float t = boxIntersection( ip, rd, vec3(s), n ).x;\n            \n            //vec4 t = iBox( ro, rd, txx, txi, vec3(s) );\n            vec4 t;\n            vec3 offs = vec3(0,0.,0.);\n            t.x = sphIntersect( ro, rd, p + offs, s ).x;\n            \n            //t = cylIntersect( ro, rd, p, p - vec3(0,200.,0), s);\n            \n            if(t.x != -1. && t.x < depth){\n                \n                depth = t.x;\n                hitIt = i;\n                t.yzw = normalize(ro+rd*t.x - p);\n                \n                if(abs(t.y) < 0.004)\n                    t.y += 0.1;\n                //t. += 0.;\n                \n                \n                //C.x = packS8(vec4(t.yzww));\n                C.x = packS16(t.yz);\n                C.y = packS16(t.wz);\n                \n                //C.xyz = t.yzw;\n                \n                //float packU16(  vec2  a);\n\n            }\n               \n            vec4 r = hash42(vec2(i*0.51256 + float(iFrame)*0.25 + part*15.125 + 100.));\n            \n            float _rt;\n            float _sc;\n            float _st;\n            \n            if(mode == 0.){\n                _st = 1.5 + sin(iTime*0. + sin(iTime))*0.5;\n                _rt = 0.2 + sin( i/iiters*12. + 11. + iTime*0.5 + sin(i/iiters*5. + iTime*0.2)*1.)*0.1;\n                _sc = mix(0.97,0.9,1.-exp(-i/iiters));\n                p.y += sin(iTime + i/iiters)*0.3*(i/iiters)*_st;\n                if(mod(cnt+2.,5.) == 0. && r.x < 0.1){\n                    mode = 1.;\n                    _rt = 4.;\n                    _sc = 0.5;\n                    if(r.z < 0.5)\n                        _rt *= -1.;\n                    cnt = 0.;\n                } else  if(mod(cnt+0.,5.) == 0. && r.w < 0.1){\n                    mode = 1.;\n                    _rt = -1.;\n                    _sc = 1.;\n                    rtdir = -1.;\n                    if(r.z < 0.5)\n                        _rt *= -1.;\n                    cnt = 0.;\n                }\n                if(cnt>1230.)\n                    break;\n                \n            } else if(mode == 1.){\n                _rt = .2*rtdir;\n                _sc = 0.9;\n                _st = 1.;\n                p.y -= 0.01*(1.-i/iiters);\n                if(mod(cnt+4.,3.) == 0. && r.x < 0.1){\n                    mode = 1.;\n                    _rt = 2.;\n                    _sc = 0.5;\n                    if(r.z < 0.5)\n                        _rt *= -1.;\n                    cnt = 0.;\n                //    cnt = 0.;\n                //}\n                }\n                if(cnt>30.)\n                    break;\n            }\n            \n            if(s<0.001)\n                break;\n            \n            cnt += 1.;\n            /*\n            if(r.x < 0.2){\n                _rt = 0.2;\n            } else if(r.x < 0.5){\n            \n                _rt = -0.2;\n            } else {\n                _rt = 11.2;\n                _sc = 0.95;\n            }\n            */\n            r += _rt;\n            rvec.xz *= rot(_rt);\n            p += rvec*s*_st;\n            //p.xz *= rot(r + part);\n            s *= _sc;\n        }\n    }\n    \n    depth = clamp(depth,0.,100.);\n    C.w = packU16(vec2(depth,hitIt)/vec2(100.,1500.));\n                \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}