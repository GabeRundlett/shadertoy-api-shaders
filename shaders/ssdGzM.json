{
    "Shader": {
        "info": {
            "date": "1629459096",
            "description": "WIP\n  Right: naive tiling of the woobly torus\n  Left: vaguely conformal mapping\nThere is no strict conformal mapping on this things.\nI just separately reparameterize the u and v as in https://shadertoy.com/view/sdd3R4\n( tuned for mid crown on top view )",
            "flags": 0,
            "hasliked": 0,
            "id": "ssdGzM",
            "likes": 29,
            "name": "~Conformal Woobly Torus Mapping3",
            "published": 3,
            "tags": [
                "torus",
                "uv",
                "conformal",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 497
        },
        "renderpass": [
            {
                "code": "//variant of https://shadertoy.com/view/sdd3R4\n\nfloat  R0 = 20., R1 = 10.,                                    // large and small radii\n        k = 2., // .9                                         // tile multiplier\n        S = .4;\n  #define T 0.\n//#define T iTime\n#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n#define SQR(x)  ( (x)*(x) )\n\n#define f(x)  DX * sqrt( 1. + SQR( S*6.*R1/R0*cos(6.*x+T) ) )  \\\n                 / mix( 1.,sin(6.*x+T), S );\n\nfloat intX( float a ) {                                       // --- antiderivative of large circumference\n    a = mod(a,6.2832);   // if you know a close form ( or good approx ), welcome ! :-)\n // return  2.808*a + .32  *(cos(6.*a) -1.); // fitting for S = .4, N=6  https://www.desmos.com/calculator/uepjhnpyap\n // return  1.85 *a + .129 *(cos(6.*a) -1.); //             S = .3 \n // return  1.40 *a + .057 *(cos(6.*a) -1.); //             S = .2 \n // return  1.143*a + .002 *(cos(6.*a) -1.); //             S = .1 \n // return  2.516*a + .45  *(cos(6.*a) -1.); //             S = .4, N=4 \n    float x, s = 0., DX = 0.01;  // indeed, approx above better than DX=.01\n    for( x = 0.; x < a; x += DX )\n        s += f(x);\n    return s += ( a - (x-DX) )/DX * f(x) ;                    // smooth integral\n}\n\nfloat a,b,r1,d; vec3 M;\n\nfloat map(vec3 q) {                                           // --- shape\n    q.yz *= rot( .5+6.*M.y),                                  // rotations\n    q.xz *= rot( 2.-6.*M.x),\n    a = atan(q.z,q.x),\n    b = atan(q.y,d),\n    r1 = R1* mix( 1., sin(6.*a+T) , S);\n    return min( 9., length(vec2(d=length(q.xz)-R0,q.y)) - r1 ); // abs for inside + outside\n}\n\nvec3 normal( vec3 p ) { // --- smart gradient  https://iquilezles.org/articles/normalsSDF\n    float h = 1e-4; \n    vec2 k = vec2(1,-1);\n    return normalize( k.xyy* map( p + k.xyy*h ) + \n                      k.yyx* map( p + k.yyx*h ) + \n                      k.yxy* map( p + k.yxy*h ) + \n                      k.xxx* map( p + k.xxx*h ) );\n}\n\nvoid mainImage(out vec4 O, vec2 U) {    // ===================================\n    float t=9.;\n\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q;                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .01 ; O+=.01 )\n        t = map(p), // also set a,b,r1,d\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/4.);                  // luminance (depth + pseudo-shading )\n    if ( U.x < R.x/2. ) {                                     // left: conformal mapping\n        a = intX(a); \n        float// s = S*6.*cos(6.*a+T),\n             // r = r1/R0, //*sqrt(1.+s*s), \n                r = R1/R0,\n               ir = sqrt(1.-r*r);                   // antiderivative of 1/circonf(b) \n        b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );        \n     //                                NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n    } \n    \n    if (O.x>0.) {\n        O = hue( mod(floor(k*R0*a/6.283),floor(k*R0*intX(-1e-5)/6.283)) \n                + 17.*mod(round(k*R1*b/6.283), floor(k*R1)) ); // colored tiles \n        a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n        O *= sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) );// tiles borders\n        O *= .3 + .7*max(0.,dot(normal(p),vec3(.58))); // shading\n    }\n    if (int(U)==int(R/2.) ) O++;                              // vertical separator\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}