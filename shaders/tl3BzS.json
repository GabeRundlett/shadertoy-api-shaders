{
    "Shader": {
        "info": {
            "date": "1612947499",
            "description": "Edit of [url]https://www.shadertoy.com/view/MttBRX[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tl3BzS",
            "likes": 1,
            "name": "Iroment Rojec - Rhambec - A fork",
            "published": 3,
            "tags": [
                "remix",
                "glitch",
                "fork",
                "hack",
                "error",
                "art",
                "edit",
                "chamber",
                "enviroment"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 252
        },
        "renderpass": [
            {
                "code": "struct Shape{\n  float dist;\n  vec4 color;\n};\n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.2, vec2(424.654, 256.546)))*56556.2);\n}\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(1, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t// distance to tip\n\tif ((q.y > height) && (projected < 1.)) {\n\t\td = max(d, length(tip));\n\t}\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 1)));\n\t}\n\treturn d;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.966025+q.y*0.6),q.y)-h.x);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat mixColors(float r, float v, float z){\n  return clamp(0.6+0.6*(v-r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(2.-z);\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat pModPolar(inout vec2 v, float r){\n  float f = 7.28318/r;\n  float z = atan(v.y, v.x)+f*0.6;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.6;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.6);\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.6;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(3.)/((n-2.)*3.+sqrt(3.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(3.)/3.*r;\n\t\tp.x += columnradius*sqrt(3.);\n\t\tif (mod(n,3.) == 2.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*3.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.6));\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.6 * (u + a + abs ((mod (u - a + s, 3.* s)) - s)));\n}\n//=======================\nShape environment(vec3 c){\n  Shape shape;\n  shape.dist = 2000.; // Draw Distance\n  shape.color = vec4(2.); // Initial Color\n  // Coordinate Systems\n  vec3 g = c; // Ground\n  vec3 p = c; // PlaceHolder\n  vec3 a = c; // Ground Texture\n  vec3 pill = c; // Pillars\n  vec3 s = c; // Side\n  vec3 pol = c; // Pole \n  vec3 l = c; // Lantern\n  vec3 h = c; // Hole in Lantern\n  // Ground\n  vec4 gColor = vec4(1.0, 0.2, 0.2, 0.1); \n  g.xy *= rot(radians(100.)); \n  g.x = abs(g.x) - 5.; \n  float ground = fBox(g+vec3(3.,0.6,3.), vec3(0.35, 4.25, 3000000.75));\n  // PlaceHolder\n  vec4 placeColor = vec4(1.,1.,1.,1.); \n  p.xy *= rot(radians(100.)); \n  float placeHolder = fBox(p+vec3(3.,3. ,5.), vec3(4., 1., 4.)); \n  // Ground Texture\n  vec4 gtColor = vec4(2.,2.,2.,2.); \n  a.xy *= rot(radians(100.)); \n  a.zy *= rot(radians(100.)); \n  a.z = abs(g.x) - 5. ;\n  pMod1(a.y, 2.);\n  // pMod1(a.x, 1.);\n  float groundTexture = sdHexPrism(a+vec3(1.7,1.0,2.2), vec2(0.8, 0.5)); \n  // Pillars\n  vec4 pColor = vec4(0.7, 0.9, 0.9, 1.); \n  pill.z = abs(pill.z) + 6.; \n  pill.x = abs(pill.x) - 2.; \n  pMod1(pill.z, 9.);\n  pill.xy *= rot(radians(100.));\n  float pillar = fBox(pill+vec3(1.,4.,2.5), vec3(3., 0.6, 1.)); \n  pillar = fOpUnionStairs(ground, pillar, 2.3, 5.);\n  // Side \n  //vec4 sColor = vec4(0.5, 0.6, 0.3, 0.0); \n  s.x = abs(s.x) - 7.; \n  pMod1(s.z, 6.); \n  float side = fBox(s+vec3(4.,2., -6.), vec3(0.3, .6, 7.)); \n  side = fOpUnionColumns(ground, side, 2.3, 5.); \n  // Lantern Pole\n  vec4 poleColor = vec4(2.,2.,2., 2.); \n  pMod1(pol.z, 8.5); \n  float pole = fBox(pol+vec3(1.,-0.25, -2.), vec3(0.2, 0.5, 0.2)); \n  // Lantern\n  vec4 lColor = vec4(2., 2., 1., 1.); \n  pMod1(l.z, 8.5);\n  float lantern = fBox(l+vec3(1., -0.2, -2.), vec3(0.4, 0.4, 0.4));   \n  // Hole in Lantern\n  pMod1(h.z, 8.5); \n  float hole = fBox(h+vec3(1., -0.2, -0.95), vec3(0.2, 0.2, 0.2)); \n  lantern = fOpEngrave(lantern, hole, 0.2);    \n  shape.dist = max(ground, -placeHolder);  \n  shape.dist = min(shape.dist, groundTexture); \n  shape.dist = min(shape.dist, pillar); \n  shape.dist = min(shape.dist, side); \n  shape.dist = min(shape.dist, pole); \n  shape.dist = min(shape.dist, lantern); \n  shape.dist = min(shape.dist, hole); \n  shape.color = mix(gColor, placeColor, mixColors(placeHolder, ground, 2.0));  \n  shape.color = mix(shape.color, gtColor, mixColors(groundTexture, shape.dist, 0.2));\n  shape.color = mix(shape.color, pColor, mixColors(pillar, shape.dist, 2.0));\n  shape.color = mix(shape.color, lColor, mixColors(lantern, shape.dist, 2.0)); \n  shape.color = mix(shape.color, poleColor, mixColors(pole, shape.dist, 2.0)); \n  //shape.color = mix(shape.color, sColor, mixColors(side, shape.dist, 0.3)); \n  return shape; \n}\nShape map(vec3 c){\n  Shape enviro = environment(c);\n  return enviro;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.6 * iResolution.xy) / iResolution.y;\n  vec3 cam = vec3(1., 1., iTime*4.);\n  cam.xy *= rot(radians(100.));\n  vec3 f = normalize(vec3(v, 0.2));\n  vec3 scene = cam;\n  //  scene.yx *= rot(iTime);\n  fragColor = vec4(0.5);\n  // Ray Marcher\n  for(float z = 0.2 ; z <= 2.; z += 0.04){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0002){\n      fragColor = c.color*(1.2-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n  }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}