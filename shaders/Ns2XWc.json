{
    "Shader": {
        "info": {
            "date": "1621175258",
            "description": "CC0: Reflecting toruses\nNumerous examples on shadertoy already on how to do repeating toruses so nothing ground breaking.\nPart of an Amiga tribute demo released earlier. Every late Amiga demo had rotating toruses\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns2XWc",
            "likes": 44,
            "name": "Reflecting toruses",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "torus"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 747
        },
        "renderpass": [
            {
                "code": "// CC0: Reflecting toruses\n//  Numerous examples on shadertoy already on how to do repeating toruses so nothing ground breaking.\n//  Part of an Amiga tribute demo released earlier. Every late Amiga demo had rotating toruses\n\n// Repeats itself after 20 sec\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MISS            1E6\n\n#define BB_TOLERANCE            0.0001\n#define BB_NORM_OFF             0.001\n#define BB_MAX_RAY_LENGTH       15.0\n#define BB_MAX_RAY_MARCHES      60\n#define BB_MAX_SHADOW_MARCHES   15\n#define BB_MAX_REFLECTIONS      3\n\nconst mat2 rot0            = ROT(0.0);\nconst vec3 std_gamma       = vec3(2.2);\n\nconst vec3 bb_lightPos     = 2.0*vec3(4.0, 3.0, 1.5);\nconst vec3 bb_backLightPos = bb_lightPos.x*vec3(-1.0, 1.0, -1.0);\nconst vec3 bb_skyCol1      = vec3(0.2, 0.4, 0.6);\nconst vec3 bb_skyCol2      = vec3(0.4, 0.7, 1.0);\nconst vec3 bb_sunCol       = vec3(8.0,7.0,6.0)/8.0;\nconst vec3 bb_sunDir       = normalize(bb_lightPos);\nconst float bb_period      = 20.0;\n\nconst float bb_bottom      = -.85;\n\nvec3   bb_g_baseColor      = vec3(0.0);\nfloat  bb_g_refFactor      = 0.0;\n\nmat2   bb_g_rot            = rot0;\nfloat  bb_g_fi             = 0.0;\nfloat  bb_g_fo             = 0.0;\nfloat  bb_g_fi13           = 0.0;\nfloat  bb_g_fi23           = 0.0;\n\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// IQ's smooth min: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's box distance function: https://iquilezles.org/articles/distfunctions\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// IQ's torus distance function: https://iquilezles.org/articles/distfunctions\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// From: http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat bb_planeIntersect(vec3 ro, vec3 rd, float mint) {\n  vec3 p = ro + rd*mint;\n  return (bb_bottom-p.y)/rd.y;\n}\n\nvec3 bb_skyColor(vec3 rd) {\n  float sunDot = max(dot(rd, bb_sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.5, 0.5),0.0))-0.1;\n  final += vec3(0.75)* pow(saturate(1.0 - roundBox*0.5), 9.0);\n  \n  final += mix(bb_skyCol1, bb_skyCol2, rd.y);\n  final += 0.5*bb_sunCol*pow(sunDot, 20.0);\n  final += 4.0*bb_sunCol*pow(sunDot, 400.0);    \n  return final;\n}\n\nfloat bb_df(vec3 p) {\n  float fi   = bb_g_fi;\n  float fo   = bb_g_fo;\n  mat2  rot  = bb_g_rot;\n  float fi13 = bb_g_fi13;\n  float fi23 = bb_g_fi23;\n  \n  float oo = mix(2.5, 0.5, fi*fo);\n  float ss = mix(0.05, 0.4, fi13*fo);\n  float rr = mix(0.125, 0.75, fi23*fo);\n  \n  vec3 p0 = p;\n  p0.y -= 0.5;\n  p0.zy *= rot;\n  p0.xy *= rot;\n  float d0 = box(p0, vec3(0.65));\n  \n  vec3 p1 = p;\n  p1.y -= oo;\n\n  float s = 1.0;\n\n  float d1 = torus(p1, s*vec2(1.0, 0.125));\n\n  vec3 c1 = vec3(0.125);\n\n  float trf = 0.75;\n  \n  for (int i = 0; i < 3; ++i) {\n    p1.xz *= rot;\n    p1.xyz = p1.zxy;\n\n    float pr = length(p1.xy);\n    float pa = atan(p1.y, p1.x);\n  \n    float n = mod1(pa, TAU/8.0);\n    \n    p1.xy = pr*vec2(cos(pa), sin(pa));\n    p1.x -= s;\n    s *= ss;\n    float dd = torus(p1, s*vec2(1.0, rr));\n\n\n    d1 = pmax(d1, -dd, 0.75*s);\n    trf = dd < d1 ? trf = 1.0-trf : trf;\n    d1 = min(d1, dd);\n  }\n  \n\n  float rf = 0.35;\n  vec3 bc = vec3(0.5);\n\n  float d = d0;\n\n  d = d0;    \n  \n  d = pmax(d, -d1, 0.1);\n\n  if (d1 < d) {\n    bc = c1;\n    rf = trf;\n    d = d1; \n  }\n\n  bb_g_refFactor = rf;\n  bb_g_baseColor = bc;\n\n  return d;\n}\n\nvec3 bb_normal(vec3 pos) {\n  vec3 eps = vec3(BB_NORM_OFF, 0.0, 0.0);\n  vec3 nor;\n  \n  nor.x = bb_df(pos+eps.xyy) - bb_df(pos-eps.xyy);\n  nor.y = bb_df(pos+eps.yxy) - bb_df(pos-eps.yxy);\n  nor.z = bb_df(pos+eps.yyx) - bb_df(pos-eps.yyx);\n  \n  return normalize(nor);\n}\n \nfloat bb_rayMarch(vec3 ro, vec3 rd, float initial, out float nearest, out int iter) {\n  float t = initial;\n\n  float n = 1E6;\n  int ii = 0;\n\n  for (int i = 0; i < BB_MAX_RAY_MARCHES; ++i) {\n    ii = i;\n    vec3 p = ro + rd*t;\n    \n    float d = bb_df(p);\n    n = min(n, d);\n    \n    if (d < BB_TOLERANCE || t >= BB_MAX_RAY_LENGTH) break;\n    \n    t += d;\n  }\n  \n  iter = ii;\n  nearest = n;\n  \n  return t < BB_MAX_RAY_LENGTH ? t : MISS;\n}\n\nfloat bb_softShadow(vec3 ps, vec3 ld, float mint, float k) {\n\n  float res = 1.0;\n  float t = mint*6.0;\n  int mat;\n  for (int i=0; i < BB_MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = bb_df(p);\n    res = min(res, k*d/t);\n    if (res < BB_TOLERANCE) break;\n    \n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 bb_render(vec3 ro, vec3 rd) { \n  vec3 finalCol = vec3(0.0);\n\n  float aggRefFactor = 1.0;\n\n  vec3 bg = bb_skyColor(rd);\n  int titer = 0;\n  int tref = 0;\n  \n  for (int rc = 0; rc < BB_MAX_REFLECTIONS; ++rc) {  \n      if (aggRefFactor < 0.05) break;\n  \n      vec3 sky = bb_skyColor(rd);\n  \n      const float mint = 0.05;\n      float tp = bb_planeIntersect(ro, rd, mint);\n\n      int iter;\n      float nearest;\n      float tm = bb_rayMarch(ro, rd, mint, nearest, iter);\n      titer += iter;\n      ++tref;\n      \n      vec3 baseColor  = bb_g_baseColor;\n      float refFactor = bb_g_refFactor;\n      \n      float shine = exp(-5.0*nearest);\n      const float shinef = 0.125;\n      const vec3 shineCol = vec3(1.25).zyx;\n      shine *= shinef;\n\n      if(tm >= MISS && tp <= 0.0) {\n        // We hit the sky\n        finalCol += aggRefFactor*mix(sky, shineCol, shine);\n        break;\n      }\n\n      vec3 p = ro + tm*rd;\n      vec3 nor = bb_normal(p);\n      float fakeAo = 1.0 - smoothstep(0.5, 1.2, float(iter)/float(BB_MAX_RAY_MARCHES));\n      \n      vec3 pp = ro + tp*rd;\n      vec2 pp1 = pp.xz;\n\n      pp1.x -= -2.0*TIME*0.5;\n      pp1 *= sqrt(0.5);\n      vec2 np1 = mod2_1(pp1);\n      \n      if (tp < tm && tp >= 0.0) {\n        // Hit plane\n        p = pp;\n        float dd = min(abs(pp1.x), abs(pp1.y));\n        baseColor = vec3(0.75)-0.25*exp(-50.0*dd);\n        refFactor = 0.8;\n        nor = vec3(0.0, 1.0, 0.0);\n        fakeAo = 1.0;\n      }\n      \n      refFactor *= pow(abs(dot(nor, rd)), 0.25);\n      vec3 ld  = normalize(bb_lightPos - p);\n      vec3 bld = normalize(bb_backLightPos - p);\n  \n          \n      float dif  = max(dot(nor, ld), 0.0);\n      float bdif = max(dot(nor, bld), 0.0);\n      float spe  = pow(max(dot(reflect(ld, nor), rd), 0.0), 40.0);\n      float sha  = bb_softShadow(p, ld, 0.1, 4.0);\n      vec3 col = 0.8*baseColor*mix(0.2, 1.0, dif*sha*fakeAo) + 0.25*spe;\n      col += baseColor*mix(0.0, 0.2, bdif);\n      col *= refFactor;\n\n      float yy = 1.0-exp(-4.0*float(iter)/float(BB_MAX_RAY_MARCHES));\n      \n      col = mix(col, shineCol, max(shine, yy*shinef));\n      // Very very random code\n      col *= mix(0.95, -1.0, abs(dot(nor,rd)));\n\n      finalCol += aggRefFactor*(col);\n\n      aggRefFactor *= (1.0 - refFactor);\n      \n      ro = p;\n      rd = reflect(rd, nor);\n  }\n\n  return finalCol;\n}\n\nvec3 bb_effect(vec2 p, vec2 q) {\n  float gtime = TIME;\n  float ltime = mod(gtime, bb_period);\n\n  bb_g_rot    = ROT(TAU*TIME*0.75/4.0);\n  bb_g_fi     = smoothstep(0.0, 1.0, ltime);\n  bb_g_fo     = 1.0-smoothstep(bb_period-1.25, bb_period-0.25, ltime);\n  bb_g_fi13   = smoothstep(bb_period*1.0/3.0-0.5, bb_period*1.0/3.0+0.5, ltime);\n  bb_g_fi23   = smoothstep(bb_period*2.0/3.0-0.5, bb_period*2.0/3.0+0.5, ltime);\n  \n  vec3 ro = 0.6*vec3(6.0, 5.0, -2.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  ro.xz *= ROT(sin(TIME*sqrt(0.3)));\n\n  vec3 la  = vec3(0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = bb_render(ro, rd);\n\n  return col;  \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = bb_effect(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}