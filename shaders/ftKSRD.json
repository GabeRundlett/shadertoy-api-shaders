{
    "Shader": {
        "info": {
            "date": "1640271150",
            "description": "I'll never describe my shaders..... EVER! I'm not a part of your system!",
            "flags": 0,
            "hasliked": 0,
            "id": "ftKSRD",
            "likes": 1,
            "name": "eindacor_cmykwaves",
            "published": 3,
            "tags": [
                "cmyk"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define TWOPI 6.28318530718f\n\n#define NORMALIZE_SIN false\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    float distMultiplier = getHoldTransitionValue(2., 50., 5., 40., iTime);\n    float radialSineModifier = 12.;\n    float radiasSineDistModifier = getHoldTransitionValue(0., 2., 5., 10., iTime);\n    \n    vec2 cyanCenter = vec2(.5 * aspectRatio, .5);\n    float cyanAngle = atan((uv.y - cyanCenter.y)/(uv.x - cyanCenter.x));\n    float cyanVal = sin(iTime + \n        distMultiplier * distance(uv, cyanCenter) + sin(cyanAngle * radialSineModifier) * radiasSineDistModifier);\n    if (NORMALIZE_SIN) {\n        cyanVal = (cyanVal + 1.) / 2.;\n    }\n    vec3 cyan = mix(vec3(1.), CYAN, cyanVal);\n    \n    vec2 magentaCenter = vec2(.25 * aspectRatio, .75);\n    mat2x2 magentaRotation = createRotationMatrix(-iTime * .01);    \n    magentaCenter = (magentaCenter - cyanCenter) * magentaRotation + cyanCenter;\n    float magentaAngle = atan((uv.y - magentaCenter.y)/(uv.x - magentaCenter.x));\n    float magentaVal = sin(iTime + \n        distMultiplier * distance(uv, magentaCenter) + sin(magentaAngle * radialSineModifier) * radiasSineDistModifier);\n    if (NORMALIZE_SIN) {\n        magentaVal = (magentaVal + 1.) / 2.;\n    }\n    vec3 magenta = mix(vec3(1.), MAGENTA, magentaVal);\n    \n    vec2 yellowCenter = vec2(.75 * aspectRatio, .25);\n    mat2x2 yellowRotation = createRotationMatrix(iTime * .03);\n    yellowCenter = (yellowCenter - cyanCenter) * yellowRotation + cyanCenter;\n    float yellowAngle = atan((uv.y - yellowCenter.y)/(uv.x - yellowCenter.x));\n    float yellowVal = sin(iTime + \n        distMultiplier * distance(uv, yellowCenter) + sin(yellowAngle * radialSineModifier) * radiasSineDistModifier);\n    if (NORMALIZE_SIN) {\n        yellowVal = (yellowVal + 1.) / 2.;\n    }\n    vec3 yellow = mix(vec3(1.), YELLOW, yellowVal);\n\n    // Output to screen\n    fragColor = vec4(cyan * magenta * yellow, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}