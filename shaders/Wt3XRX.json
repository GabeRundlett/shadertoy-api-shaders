{
    "Shader": {
        "info": {
            "date": "1581380776",
            "description": "Real time path tracing, except this time only the GI gets reprojected for a sharper result, it also makes room to add more effects such as volume rendering as demonstrated here",
            "flags": 32,
            "hasliked": 0,
            "id": "Wt3XRX",
            "likes": 127,
            "name": "Path traced GI",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "volume",
                "gi",
                "dof",
                "volumetric",
                "fog",
                "pathtracing",
                "ao",
                "reprojection",
                "volumetrics"
            ],
            "usePreview": 1,
            "username": "loicvdb",
            "viewed": 4433
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0.);\n    float frd = iResolution.y*cam.aperture*DoFClamping;\n    int rd = int(ceil(frd - .5));\n    for(int y = -rd; y <= rd; y++){\n        int ln = int(ceil(sqrt(frd*frd-float(y*y)) - .5));\n        for(int x = -ln; x <= ln; x++){\n            vec4 p = texelFetch(iChannel0, ivec2(clamp(fragCoord + vec2(x, y), vec2(0), iResolution.xy-1.)), 0);\n            float dof = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping) * iResolution.y*cam.aperture;\n            p.a = 1.;\n            p *= clamp((dof - length(vec2(x, y))) + .5, 0.0, 1.0) / (dof*dof+.5);\n            col += p;\n    \t}\n    }\n    \n    col /= col.a;\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.07 * iResolution.y, .0, fragCoord) * .06;\n    \n    fragColor = vec4(ACESFilm(col.rgb + bloomSum), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool trace(inout vec3 pos, in vec3 dir){\n    pos += dir*sdf(pos);\n    pos += dir*sdf(pos);\n    for(int i = 0; i < MaxStepsDirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            pos -= (2.*MinDist-dist) * dir;\n            pos -= (2.*MinDist-sdf(pos)) * dir;\n            pos -= (2.*MinDist-sdf(pos)) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    fragColor = vec4(0.);\n    vec3 pos = cam.pos;\n    if(trace(pos, dir)) fragColor = vec4(pos, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float seed;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\nvec3 background(vec3 dir){\n    return LightColor * Density * 8. * henyeyGreenstein(-LightDir, dir);\n}\n\nvec3 directBackground(vec3 dir){\n    return LightColor * Density * 1.;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < MaxStepsIndirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir;\n    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;\n    for(int i = 0; i < Bounces; i++){\n        dir = getCosineWeightedSample(normal);\n        if(!trace(pos, dir, normal)) return light + abso*background(dir);\n        sdf(pos, dc, ec);\n        light += abso * (ec + dc*directLight(pos, normal));\n        abso *= dc;\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MaxDist;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = MaxDist;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = .256435865*fragCoord.x+.316548465*fragCoord.y+sin(iTime)*16886.3158915;\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(directBackground(uv2dir(cam, uv)), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal = normalEstimation(hit.xyz);\n        \n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        \n        fragColor = previousSample(hit);\n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        iLight = clamp(iLight, vec3(.0), vec3(fragColor.a/10.)); // clamp gi for low sample count\n        fragColor.rgb = mix(fragColor.rgb, iLight, 1.0/(fragColor.a/float(IndirectSamples)));\n        #endif\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 tx = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 finalPos = tx.rgb;\n    col.a = length(cam.pos-finalPos);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    \n    if(tx.a != 0.) {\n        vec3 dc, ec;\n        sdf(finalPos, dc, ec);\n        col.rgb = ec + dc * (col.rgb + directLight(finalPos, normalEstimation(finalPos)));\n    } else {\n        finalPos = cam.pos + dir * 100.;\n    }\n    \n    vec3 volCol = vec3(0.), volAbs = vec3(1.), pos = cam.pos;\n    float stepDist = (tx.a == 0. ? FogRange : min(FogRange, col.a))/float(FogSteps);\n    vec3 stepAbs = exp(-Density*stepDist);\n    vec3 stepCol = (vec3(1.) - stepAbs) * henyeyGreenstein(-LightDir, dir);\n    pos += stepDist * dir * texture(iChannel2, fragCoord/vec2(1024)).a;\n    for(int i = 0; i < FogSteps; i++){\n        volAbs *= stepAbs;\n        volCol += stepCol*volAbs*directLight(pos, -LightDir);\n        pos += dir * stepDist;\n    }\n    \n    col.rgb = col.rgb*volAbs + volCol;\n\t\n    \n\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//increase this number for a better GI\n#define IndirectSamples 1\n\n//increase to remove more noise, but might make the result blurrier\n#define SamplesLimit 150\n\n//GI bounces\n#define Bounces 1\n\n\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .5\n\n\n\n#define Pi 3.14159265359\n\n#define MaxStepsDirect 128\n#define MaxStepsIndirect 32\n#define MaxShadowSteps 32\n#define FogSteps 8\n\n#define MaxDist 4.\n#define MinDist .015\n\n#define DoFClamping .3\n#define DoFSamples 128\n\n#define Density vec3(.0025, .0045, .006)\n#define Anisotropy .4\n#define FogRange 13.\n\n\nvec3 LightDir = normalize(vec3(.0, .0, -1));\nvec3 LightColor = vec3(1.) * 6.;\nfloat LightRadius = .02;\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    //time = 0.;\n    vec3 rot = vec3(cos(time*.4)/6., 1. + time*.2 + sin(time*.2)/4., .5);\n    return Camera(vec3(0., 0., -10.) * rotationMatrix(rot), rot, 1., 7.5, .025);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n\nfloat sdf(vec3 position, out vec3 diffuseColor, out vec3 emissionColor){\n    diffuseColor = vec3(1.);\n    emissionColor = vec3(0.);\n    float Scale = 2.25;\n    float Radius = .25;\n    mat3 Rotation;\n    \n    float time = 15.;\n    \n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1- /*iterations*/7));\n\tvec4 p = vec4(position.xyz*Rotation, 1.0), p0 = p;\n\tfor (int i = 0; i<7; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 3) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n    /*diffuseColor = fract(p0.x)<.1 ? vec3(.2) : vec3(1.);\n    emissionColor = fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.);*/\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat sdf(vec3 position){\n    vec3 dc, ec;\n    return sdf(position, dc, ec);\n}\n\nvec3 normalEstimation(vec3 pos){\n  vec2 k = vec2(MinDist, 0);\n  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),\n\t  \t\t\t\t\tsdf(pos + k.yxy) - sdf(pos - k.yxy),\n  \t\t\t\t\t\tsdf(pos + k.yyx) - sdf(pos - k.yyx)));\n}\n\nfloat henyeyGreenstein(vec3 dirI, vec3 dirO){\n\tfloat cosTheta = dot(dirI, dirO);\n \treturn Pi/4.0 * (1.0-Anisotropy*Anisotropy) / pow(1.0 + Anisotropy*Anisotropy - 2.0*Anisotropy*cosTheta, 3.0/2.0);\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    //return vec3(0.);\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 2.5;\t//goes 2.5 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}