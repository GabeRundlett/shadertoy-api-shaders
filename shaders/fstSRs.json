{
    "Shader": {
        "info": {
            "date": "1644020749",
            "description": "jak wyzej cwiczonko kurwa po co mi to kazecie pisac",
            "flags": 0,
            "hasliked": 0,
            "id": "fstSRs",
            "likes": 3,
            "name": "noise playground2",
            "published": 3,
            "tags": [
                "lalalala"
            ],
            "usePreview": 0,
            "username": "gunzes",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "//rand(vec2 coord)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y)-vec2(0.888888,0.5);\n    //vec2 uv = (fragCoord/iResolution.y);\n    vec2 uv2 = uv;\n    //zmienne\n    //uv.x += iTime;\n    float czasSin = sin(iTime*.5)*1.;\n    float time = iTime;\n    float rotTime = iTime;\n    time *= .1;\n    rotTime *= .06;\n    \n    vec3 col = vec3(.0);\n    float gridScale = 6.;\n    float noiseStrength =.45;\n    float borderSize = 0.;\n    float color = 1.;\n    float blurStep = 1.;\n    \n    vec2 offset = vec2(.25,.0);\n    \n    //vec2 uv2 = (vec2(uv.x+czas,uv.y))*gridScale;\n    vec2 uvTime1 = (vec2(uv.x+time,uv.y+time)) * gridScale;\n    vec2 uvTime2 = (vec2(uv.x-time,uv.y+time)) * gridScale;\n    vec2 uvTime3 = (vec2(uv.x-time,uv.y-time)) * gridScale;\n    vec2 uvTime4 = (vec2(uv.x+time,uv.y-time)) * gridScale;\n   \n    float noise2d =  noise2D(uvTime1) * noiseStrength *\n                     noise2D(uvTime2) * noiseStrength *\n                     noise2D(uvTime3) * noiseStrength *\n                     noise2D(uvTime4) * noiseStrength ;\n    //noise2d *= time*5.;\n    \n    //czas *= noise2d*.5;\n    float angle = fract(rotTime*.5)*PI*2.;\n    \n    //move square position\n    //uv -= offset*czasSin;\n    //rotation\n    \n    uv *= rotate(angle);\n    uv2 *= rotate(-angle);\n    //move rotation center\n    //uv += 0.2;\n    //col += drawSquare(uv, noise2d * 5. + .036 + borderSize+.02, noise2d * 5.+.01);\n    \n    for (int i = 0; i < 35; i++){\n    \n        uv *= rotate(angle)*.9;\n        uv2 *= rotate(-angle);\n        \n        float square = drawSquare(uv, noise2d * 5. + .05 + borderSize, noise2d * 25.) -\n                       drawSquare(uv, noise2d * 5. + .047 + borderSize, noise2d * blurStep);  \n                       \n        borderSize += .003*((sin(iTime)*.5)+.5);\n        blurStep += .3;\n        \n        col += vec3(square*color);\n        color -= (1./25.)*((sin(iTime)*.5)+.5);\n        //col -= (1./30.*.5);\n        //col -= 1./20.;\n    }\n    \n    //col = 1.-col;\n    col = vec3(pow(col.x,1.5));\n    col *= vec3(2.,1.,1.);\n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}*/\n#define PI 3.14159265359\n\n//random\n\nfloat rand(vec2 coord){\n    return fract(sin(dot(coord,vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//rotation\n\nmat2 rotate(float angle){\n    \n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n\n}\n\n//noise 1d\n\nfloat noise1D(float cellId, float cellFraction){\n    return clamp(mix(rand(vec2(cellId)),rand(vec2(cellId+1.)),smoothstep(0.,1.,cellFraction)),0.,1.);\n    //return mix(rand(vec2(cellId)),rand(vec2(cellId+1.)),cellFraction);\n    //return rand(vec2(cellId));\n}\n\n//noise2d\n\nfloat noise2D(vec2 coord){\n    vec2 id = floor(coord);\n    vec2 fraction = fract(coord);\n    //4 punkty kwadratu\n    float a = rand(id);\n    float b = rand(id + vec2(1.,0.));\n    float c = rand(id + vec2(0.,1.));\n    float d = rand(id + vec2(1.,1.));\n    \n    //interpolacja\n    vec2 smoothCorners = smoothstep(0.,1.,fraction);\n    //vec2 smoothCorners = fraction*fraction*(3.0-2.0*fraction)\n    \n    //mix kornerow\n    return mix(a,b,smoothCorners.x) +\n           (c - a) * smoothCorners.y * (1.- smoothCorners.x) +\n           (d - b) * smoothCorners.x * smoothCorners.y;\n}\n\n//okrag smooth\n\nfloat drawCircleSmooth(vec2 coord, float borderThickness, float radius, float color){\n\n    return (1.-smoothstep(0.,borderThickness,abs(radius-sqrt(dot(coord,coord)))))*color;\n}\n//dysk\nfloat drawDisc(vec2 coord,float radiusOut){\n    return smoothstep(radiusOut,radiusOut*1.015,length(coord));\n}\n\n//kwadrat smooth\nfloat drawSquare (vec2 coord, float a, float blur){\n    float band1 = smoothstep(a+blur,a-blur,coord.x);\n    float band2 = smoothstep(-a-blur,-a+blur,coord.x);\n    float band3 = smoothstep(a+blur,a-blur,coord.y);\n    float band4 = smoothstep(-a-blur,-a+blur,coord.y);\n    return band1*band2*band3*band4;\n}\n\n\n\n\n\n//float randomNumber      = 43758.5453123;\n//vec2 randomVecNumber    = vec2(12.9898,78.233);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}