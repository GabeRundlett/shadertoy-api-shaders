{
    "Shader": {
        "info": {
            "date": "1650302411",
            "description": "4k exegfx entry for revision 2022",
            "flags": 32,
            "hasliked": 0,
            "id": "flBcWc",
            "likes": 33,
            "name": "grazing",
            "published": 3,
            "tags": [
                "4kexegfx"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 814
        },
        "renderpass": [
            {
                "code": "//old code to match transfer function used by exrdisplay\n// GOTO BUFFER A TO ENABLE THE PUMPJACS (SLOW COMPILATION)\n\n#if 0\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat knee (float x, float f)\n{\n    return log (x * f + 1.) / f;\n}\n\nvec3 gamma (vec3 h, float exposure)\n{\n    //\n    // Conversion from half to unsigned char pixel data,\n    // with gamma correction.  The conversion is the same\n    // as in the exrdisplay program's ImageView class,\n    // except with defog, kneeLow, and kneeHigh fixed\n    // at 0.0, 0.0, and 5.0 respectively.\n    //\n    float m = pow (\n        2.f, clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    vec3 x = max (h * m, 0.);\n\n    if (x.x > 1.) x.x = 1. + knee (x.x - 1., 0.184874f);\n    if (x.y > 1.) x.y = 1. + knee (x.y - 1., 0.184874f);\n    if (x.z > 1.) x.z = 1. + knee (x.z - 1., 0.184874f);\n\n    return (clamp (\n        pow (x, vec3(.4545f)) * 84.66f, 0.f, 255.f))/255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfragColor /= fragColor.w;\n    fragColor.xyz = gamma(fragColor.xyz,-1.);\n\t//fragColor *= 1.0 - dot(uv,uv)*0.5; //vingetting lol\n    //fragColor = log(fragColor+1.);\n\t//fragColor = smoothstep(0.09,0.99,sqrt(fragColor))+.02; //colour grading\n\t//fragColor += hash(uv.x,uv.y)*.015;\n}\n#else\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfragColor /= fragColor.w*4.; //\"film grain\"\n\tfragColor *= 1.0 - dot(uv,uv)*0.5; //vingetting lol\n\tfragColor = smoothstep(-0.2,1.2,sqrt(fragColor)); //colour grading\n    //fragColor.xyz*=mat3(1.7,-.2,-.4,-.3,1.4,-.1,-.1,-.1,1.2);\n\t//fragColor += hash(uv.x,uv.y)*.015;\n}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//define this for an extremely slow compile time\n//#define PUMPJACKS\n\n//uncomment for fun\n//#define COWS\n\n\n//axis rotation functions. maybe there's a better way\nvec3 xy(vec3 p,float r){p.xy*=mat2(cos(r),sin(r),-sin(r),cos(r));return p;}\nvec3 yz(vec3 p,float r){p.yz*=mat2(cos(r),sin(r),-sin(r),cos(r));return p;}\nvec3 xz(vec3 p,float r){p.xz*=mat2(cos(r),sin(r),-sin(r),cos(r));return p;}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n//fancy repetition to make the dictionary compressor happy :3\nfloat mx(vec2 p) {\n    return max(p.x,p.y);\n}\nfloat mx(vec3 p) {\n    return max(p.x,mx(p.yz));\n}\nfloat mx(vec4 p) {\n    return max(p.x,mx(p.yzw));\n}\n#define cn(p) (length(max(p,0.)) + min(0.,mx(p)))\n#define bx(p,d) cn(abs(p)-(d/2.))\n#define tr(p,r) (asin(sin((p)*r))/r)\n\nfloat hex(vec2 p, vec3 rad) {\n    vec3 p2 = vec3(.81,-.4,-.4)*p.y + vec3(0,-.71,.71)*p.x;\n    return bx(p2,vec3(rad));\n}\n\nfloat feature(vec3 p, float d, float w, float t) {\n    float body = cn(p.xy-vec2(-t,d)/2.); // main body or nothing\n    float perp = bx(p.xy,vec2(t,w)); // perpendicular beam\n    float supp = cn(vec3(p.x,abs(p.yz))-vec3(-t,mix(w,d,.3),t)/2.); // supporting beam\n    return smin(min(supp,body),perp,t/2.)-0.0100;\n}\n\n//d.x = I extrusion depth, d.yz = body dimensions\n//dp = depth of webbing\n//t = I extrusion thickness\n//y = greeble dimension\n//o = 45deg cut offset\nfloat obj(vec3 p, vec3 d, float dp, float t, float y, float o) {\n    float body = -smin(-bx(p.yz,d.yz),(o+p.y-p.z)*.71,0.0500);\n    return feature(vec3(body,abs(p.x),y),dp,d.x,t);\n}\n\n\nfloat walking_beam(vec3 p) {\n    float d = length(p.yz);\n    p.z -= .15;\n    vec3 p2 = p;\n    p2.y=abs(p2.y+2.3)-2.3;\n    float bearing = bx(vec2(length(p2.yz),p2.x),vec2(0.1600,0.7000))-0.0200;\n    p2.z+=mx(-abs(p2.xy))*.4;\n    bearing = min(bearing, bx(p2,vec3(0.4000,0.7000,0.2000))-0.0200);\n    //bearing = min(bearing, bx(p+vec3(0,4.6,mx(-abs(p.xy))*.4),vec3(0.4000,0.7000,0.2000))-0.0200);\n    bearing=-smin(abs(p.x)-0.1000,-bearing,0.0100);\n    \n    p.z -= .80;\n    float beam = obj(p,vec3(0.5000,10.,1.2),\n        0.02,0.02,abs(abs(p.y)-.7)-.5,4.8);\n    \n    p.y -= 4.5;\n    float headsh = -smin(-abs(p.z+1.+p.y*.2)+3.,-max(d-6., -p.y),0.1000); //todo: make head better with better greebles\n    //feature(vec3(head,abs(abs(p.x)-0.3600),0.),0.1000,0.02,0.02);\n    float head=cn(vec2(headsh,abs(abs(p.x)-0.3600)))-0.02;\n    head=min(head,cn(vec3(abs(headsh+0.0500),abs(p.x)-0.4200,-tr(p.z-0.5000,2.8))))-0.02;\n    p.y -= .4;\n    p.z = abs(p.z)-.4;\n    head=min(head,bx(vec2(length(p.yz),p.x),vec2(0.0800,1.0000))-0.0100);\n    p.z-=3.2;p.y-=0.0500;\n    head=-smin(-head,length(p.yz)-0.1000,0.0200);\n    return min(min(bearing, beam),head);\n\n}\n\n// float ladder(vec3 p) {\n//     return obj(p,vec3(0.0700,10.5,.4),\n//         -0.0800,0.02,tr(p.y,10.),1e4);\n// }\n\nfloat ladder_all(vec3 p) {\n    vec3 p2 = p.yzx;\n    p-=vec3(0,0.3000,2.);\n    p=vec3(length(p.xy)-0.3500,atan(p.x,p.y)/3.2,p.z);\n    return min(obj(p2,vec3(0.0700,10.5,.4),\n        -0.0800,0.02,tr(p2.y,10.),1e4),\n        obj(p,vec3(0.0700,1.5,8.),\n        -0.1700,0.02,min(abs(tr(p.y,10.)),abs(tr(p.z,3.))),1e4));\n    // return obj(p2,vec3(0.0700,10.5,.4),\n    //     -0.0800,0.02,tr(p2.y,10.),1e4);\n    // return obj(p,vec3(0.0700,1.5,8.),\n    //     -0.1700,0.02,min(abs(tr(p.y,10.)),abs(tr(p.z,3.))),1e4);\n}\n\n// float ladder_all(vec3 p) {\n//     float l = ladder(p.yzx);\n//     float c = cage(p);\n//     return min(c,l);\n// }\n\nfloat chonker(vec3 p) {\n    p.y-=2.7;\n    p.z-=2.02;\n    return obj(p,vec3(1.5,3.,2.3),\n        1.3,0.02,abs(tr(p.y,4.3))-0.1400,1.6);\n}\n\nfloat base(vec3 p) {\n    p.z -= 0.3800;\n    float front = obj(p.yxz-vec3(-3.9,0,0),vec3(0.3600,2.9,0.9500),\n        0.02,0.02,p.y,1e4);\n    p.x=abs(p.x);\n    p.xy-=vec2(0.5500, 1.);\n    float sides = obj(p.xyz,vec3(0.3300,9.3,0.900),\n        0.02,0.02,p.y-1.,1e4);\n    return min(front,sides);\n}\n\nfloat legs(vec3 p) {\n    vec3 p2 = p;\n    vec3 p3 = p;\n    p.x = abs(p.x)-.77;\n    p.y -= -2.93;\n    p.z -= 5.5;\n    p.y -= p.z*.22;\n    p.x -= p.z*-.11;\n    float leg = obj(p,vec3(0.3000,0.3600,9.2),\n        0.02,0.02,p.y,1e4);\n    p2.y -= 0.2;\n    p2.z -= 6.4;\n    p2=yz(p2,.45);\n    float otherleg = obj(p2,vec3(0.3000,0.3600,8.2),\n        0.02,0.02,p2.z,1e4);\n    p3.z-=10.17;p3.y-=-1.7;\n    float base = bx(p3,vec3(0.8000,0.8000,0.06))-0.0100;\n    //todo: bearing between beam and legs\n    float oz = p3.z;\n    p3=yz(p3,.78);\n    p3.z-=0.1000;p3.x=abs(abs(p3.x)-0.1500)-0.1500;\n    float bearing=max(-oz,bx(p3,vec3(0.1000,0.6000,0.6000)))-0.0100;\n    return min(min(min(base,bearing),otherleg),leg);\n}\n\n// float back_bench(vec3 p) {\n//     //float k = length(vec2(length(p.xz-vec2(.5,1.6))-0.2000,p.y-6.1))-0.0150; //random ring for visual interest\n//     float ox = p.x;\n//     p.x = abs(p.x)-.5;\n//     p.y -= 5.;\n//     p.z -= 1.8;\n//     p.y=-abs(p.y);\n//     p.yz-=min(dot(p.yz,vec2(-.4,.85))*2.,0.)*vec2(-.4,.85);\n//     float b = bx(p,vec3(0.2000,2.3,0.02));\n//     p.z-=0.0500;p.y=abs(p.y)-0.7000;p.y=abs(p.y)-0.2000;p.x+=0.4000;\n//     b = min(b, bx(p,vec3(1.,0.2000,0.02)) );\n//     //p.x-=0.4000;\n//     //vec2 crds = vec2(length(p.xy),p.z+0.0200);\n//     //b = min(b, bx(crds,vec2(0.0200,0.1200)) );\n//     return b-0.0100;\n//     //return min(b-0.0100,k);\n// }\nfloat fence(vec3 p) {\n    float oy = p.y;\n    p.z -= 1.1; p.y -= 2.;p.xy=abs(p.xy);p.z*=-1.;\n    vec3 crds = vec3(bx(p.xy,vec2(4.4,10.)),atan(p.x,p.y)*4.3,p.z);\n    float rep =-mx(-abs(tr(p,vec3(2.1,2.53,8.))));\n    return obj(crds, vec3(0.0500, 50., 2.3), -0.1500, 0.02, rep,oy*.2);\n}\n\nfloat gearbx(vec3 p) {\n    p.yz -= vec2(3.4,4.1);\n    //return bx(p,vec3(1.4,3.,2.));\n    float b = cn(vec2(hex(p.yz,vec3(1)),abs(p.x)-.5))-0.1000;\n    b = smin(bx(vec2(length(p.yz),p.x),vec2(0.4000,2.2)),b,0.6000);\n    p.z -= -.83;\n    float c = bx(p,vec3(1.2, 1.6, 0.0800))-0.0500;\n    p.y -= 1.;\n    p.z -= .5;\n    p.x-=0.0500;\n    b = smin(b, cn(vec2(hex(p.yz,vec3(.5)),abs(p.x)-.3))-0.1000, 0.2000);\n    b = smin(bx(vec2(length(p.yz),p.x),vec2(0.2500,1.3))-0.0500,b,0.3000);\n    b = smin(b,c,0.4000);\n    //b = -smin(-b,abs(p.z),0.0200);\n    //p.z-=.6;\n    //b = -smin(-b,abs(p.z),0.0200);\n    vec3 p2 = p,p3=p;\n    p.y=abs(p.y)-.4;\n    p.x = abs(p.x)-0.1300;\n    b = -smin(-b,length(p.yx)-0.0500,0.0200);\n    p2.x-=.7;\n    p2=yz(p2,-.9);\n    p2.y-=1.;\n    b = min(b, cn(vec2(hex(p2.yz,vec3(.5-p2.y*.2,1.8,1.8))-.2,abs(p2.x)-.15))-0.0100);\n    p3.y-=1.0;\n    p3.z+=1.6;\n    p3.x+=.1;\n    b = min(b, cn(vec2(length(p3.yz)-.35+sin(atan(p3.y,p3.z)*20.)*.01,abs(p3.x)-.55))-0.05);\n    b = min(b, max(p3.z,length(abs(p3.xy)-vec2(.55,.3))-.1));\n    return b;\n}\n//https://twitter.com/AmigaBeanbag/status/1510713873799786503\nfloat tex(vec3 x) {\n  return dot(vec3(.3),sin(mat3(sin(x*32.),sin(x.zxy*43.),sin(x.yzx*52.))*vec3(3.)));\n}\n\nfloat counterweights(vec3 p, float ang) {\n    p.yz -= vec2(3.4,4.1);\n    p.x = abs(p.x)-1.2;\n    p=yz(p,ang);\n    float oy = p.y;\n    float oz = p.z;\n    p.z=abs(p.z);\n    float l = length(p.yz);\n    float cw = -smin(-2.-p.y, -(l-3.5), 0.4000);\n    cw = -smin(-cw,-abs(p.z-1.3)+.84, 0.4000);\n    cw = cn(vec2(cw, abs(p.x)-0.1500))-0.0400;\n    vec3 p3 = p;\n    p3.yz = tr(p3.yz,3.95);\n    cw = -smin(length(p3.yz)-0.1000,-cw,0.0100);\n    vec3 p2 = p;\n    p2.y = abs(p.y+1.)-1.;\n    float b2 = bx(vec2(length(p2.yz)-0.3500,p.x-0.0500),vec2(0.2200,.45))-0.0200;\n    b2 = min(b2,bx(vec2(length(p2.yz),p.x),vec2(0.2900,.5))-0.0200);\n    p.y+=1.6;\n    float b = obj(p, vec3(0.3000, 4., .7), 0.3000-0.06, 0.1000,  tr(p.y, 2.), 2.1);\n    p.z = oz-.8;\n    p.y-=.7;\n    b = -smin(length(p.yz)-0.5500, -b, 0.0600);\n    b = smin(b, b2, 0.2000);\n    b=-smin(abs(oy),-b,0.0500);\n    return min(b, cw);\n}\n\n\n\nfloat equalizer(vec3 p) {\n    p.yx=p.xy;\n    float bearing=bx(vec2(length(p.xz),p.y),vec2(0.6000,0.0900))-0.0200;\n    p.z-=.5;\n    p.y=-abs(p.y);\n    float oz=p.z;\n    float eq = smin(obj(p,vec3(0.2500,3.5,.8),\n        0.02,0.02,-p.y-.5,1.5), bearing,0.0500);\n    p.z -= 2.8;\n    p.y += 1.7;\n    float arm = obj(p.yxz,vec3(0.2500,.4,6.9),\n        0.02,0.02,p.x,1e4);\n    p.z -= 3.1;\n    arm = min(arm,bx(p,.4)-0.0100);\n    arm = -smin(-arm,abs(p.z),0.0300);\n    return min(max((-.45-oz<0.?.08:.02)-eq,arm),eq);\n}\n\n\nfloat wireline(vec3 p, float bz) {\n    p -= vec3(0,-7.8,10.5);\n    float carrierz = -16.+bz;\n    float polish = max(length(p.xy)-0.0300,-0.5000-carrierz+p.z);\n    float carrier = bx(vec2(length(p.xy),p.z-carrierz),vec2(0.3000,0.2000));\n    p.x = abs(p.x)-0.2700;\n    float bridle = max(length(p.xy)-0.0300,max(p.z,carrierz-p.z));\n    p.z=abs(p.z-carrierz-0.1000)-0.1000;\n    carrier=smin(carrier, bx(vec2(length(p.xy),p.z),vec2(0.2000,0.1000)),0.2000);\n    return min(carrier-0.0100,min(bridle,polish));\n}\n\nvec2 poop(vec2 a, vec2 b, float d1, float d3) {\n    float d2 = length(b-a);\n    float p = (d1*d1+d2*d2-d3*d3)/d2/2.;\n    float o = sqrt(d1*d1-p*p);\n    return a + mat4x2(-p,-o,o,-p,p,o,-o,p)*vec4(a,b)/d2;\n}\n\nfloat scene(vec3 p) {\n    //p += tex(p*2.5)*.001;\n    p += sin(p).yzx*.01;\n    p -= sin(p).zxy*.01;\n    p += sin(p*3.).yzx*.001;\n    p -= sin(p*3.).zxy*.001;\n    vec2 id = round(p.xy/60.)*60.;\n    p.xy -= id;\n#ifdef PUMPJACKS\n    float ang = sin(dot(id,vec2(5e4,3e3)))*2e3+2.;\n    p=xy(p,sin(ang)*.1);\n    p.xy+=fract(ang)*8.-4.;\n    vec2 sprocket = vec2(3.4,4.1) - vec2(cos(ang),sin(ang))*2.1;\n    vec2 bearing = poop(vec2(-1.8,10.5500), sprocket, 4.6,6.4);\n    vec2 cable = mix(bearing,vec2(-1.8,10.5500),2.32);\n    vec2 rel = bearing-vec2(-1.8,10.5500);\n    vec2 rel2 = sprocket-bearing;\n    float ang2 = atan(-rel.y,rel.x);\n    float ang3 = -atan(rel2.x,rel2.y);\n\n    //return min(walking_beam(p), ladder_all(yz(p,.1)-vec3(0.8000,1.,-6.)));\n    float pumpjack = base(p);\n    pumpjack = min(pumpjack, chonker(p));\n    pumpjack=min(pumpjack,ladder_all(yz(p*vec3(1,-1,1),.2)-vec3(1.,4.3,4.75))); //todo: flip inside ladder_all..?\n    vec3 pbeam = (p-vec3(0,vec2(-1.8,10.5500)))*vec3(1,-1,1);\n    pbeam=yz(pbeam,ang2);\n    pumpjack=min(pumpjack,walking_beam(pbeam));\n    pumpjack=min(pumpjack,legs(p));\n    // pumpjack=min(pumpjack,back_bench(p));\n    pumpjack=min(pumpjack,fence(p));\n    pumpjack=min(pumpjack,gearbx(p));\n    vec3 epos = p-vec3(0.,bearing);\n    epos = yz(epos,ang3);\n    pumpjack=min(pumpjack,counterweights(p, ang));\n    pumpjack=min(pumpjack,equalizer(epos));\n    return min(pumpjack,wireline(p,cable.y));\n    \n    /*debugging for linkage positions\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,sprocket))-.2);\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,bearing))-.2);\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,vec2(-1.8,10.5500)))-.2);\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,vec2(3.4,4.1)))-.2);\n    */\n#else\n    return length(p);\n#endif\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n//todo: replace with smaller hashfunc\nfloat hash(float a, float b) {\n    // return fract(100.*fract(sin(a) * 1e4) + fract(sin(b) * 1e4))*2.-1.;\n    // return fract(sin(a*12.9898+b*4.1414) * 43758.5453)*2.-1.;\n    int x = floatBitsToInt(a/7.);//^floatBitsToInt(a+.1);\n    int y = floatBitsToInt(b/7.);//^floatBitsToInt(b+.1);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat rnd1,rnd2,rnd3;\nfloat blades(vec2 p,float o) {\n    // p.x -= (floor(p.x/40.)+.5)*40.;\n    // float id = pow(floor(sqrt(abs(p.x*40.))),2.);\n    // id = sign(p.x)*(id+sqrt(id))/40.;\n    float id = (floor(p.x*1.8)+.5)/1.8;\n    p.x -= id;\n    //p.x = sgn*(p.x*4.-sign(p.x)*(id+sqrt(id)))/4.;\n\n    rnd1 =fract(sin(id*777.+o)*1e5);\n    rnd2 =fract(sin(id*999.+o)*1e4);\n    rnd3 =fract(sin(id*555.+o)*1e3);\n    p.x += pow(p.y,2.)*(pow(rnd2,3.)*sign(rnd1-.5))*2.;\n    return bx(p,vec2(.004-p.y*.02,.5-pow(rnd3,2.)*.5))-.005;\n}\nvec2 blades_norm(vec2 p,float o) {\n    mat2 k = mat2(p,p)-mat2(0.0001);\n    return normalize(blades(p,o) - vec2(blades(k[0],o), blades(k[1],o)));\n}\n\nvec3 pixel_color( vec2 uv )\n{\n    //uv /=1.5;\n    //uv-=vec2(-.0,.5);\n    vec3 cam = normalize(vec3(1.1,uv));\n    vec3 init = vec3(-25,0,1.7);\n    cam=xz(cam,-.19);\n    //init=xz(init,-.1);\n    cam=xy(cam,.81);\n    init=xy(init,.73);\n    // init.y-=-1.;\n    //cam = vec3(1,0,0);\n    //uv.x=-uv.x;\n    //init = vec3(-10,uv*15.);\n    \n    vec3 p = init;\n    bool hit = false;\n    int i;\n    for (i=0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-7;\n        p += dist*cam;\n        //cam = normalize(cam+tex(p*.05)*dist*vec3(0,0,0.00005));\n        if(length(p-init)>550.)break;\n    }\n    float warp = cos(cam.z*10.+cam.x*5.)*.1;\n    float tnear = (.25-init.z+warp) / cam.z;\n    float tfar = (-init.z+warp) / cam.z;\n    vec3 dir = normalize(vec3(-1,-1,1));\n    vec3 n = norm(p);\n    bool gnd = false;\n    float atten = 1.;\n    \n    //float oz = 0.;\n    if (tnear > 0.) {\n        float bbscale = .01;\n        float dx = length(cam.xy)*tnear;\n        float at = atan(cam.x,cam.y);\n        for (int pl = 0; pl < 150; pl++) {\n            int bbid = int(ceil(dx/bbscale)) + pl;\n            float bbx = float(bbid)*bbscale;\n            float off =  fract(sin(bbx*668.)*500.)*500.-250.;\n            float tt = (bbx-dx)/length(cam.xy);\n            vec2 crds = vec2(at*bbx+off,.25+cam.z*tt);\n            //t += tt;\n            vec3 p2 = init+cam*(tnear+tt);\n            //blheight = cos(p2.x*.5)*cos(p2.y*.5)*.5+.5;\n            if (blades(crds,off)>tnear*.0001) continue;\n            if ((tnear+tt) < length(p-init) || !hit) {\n                p = p2;\n                //todo: better normal calc\n                //this is so hilariously silly idk why it works\n                vec2 bn = blades_norm(crds,off);\n                n = normalize(vec3(-cam.xy,(fract(rnd2*1e4)*8.-4.)*crds.y)+(bn.x+rnd2*2.-1.)*vec3(cam.y,-cam.x,0));\n                atten *= crds.y/.25;\n                hit = true;\n                gnd = true;\n                //oz=length(p.xy-init.xy);\n            }\n            break;\n        }\n        if (tfar<length(p-init) || !hit) {\n            p = init+cam*tfar;\n            n = vec3(0,0,1);\n            hit = true;\n            gnd = true;\n            atten = .01;\n        }\n    }\n    vec3 op = p;\n    //if (!hit) return vec3(.86,1.35,2.44);\n    float cloud = tex(cam*.1+cam.z)*.015;\n    if (!hit) return mix(vec3(.4,1.5,2.8),vec3(4.3,5.9,6.6),pow(1.-smoothstep(-0.1,1.1,cam.z-cloud),10.));//*smoothstep(100.,400.,length(p-init));\n    vec3 r = reflect(cam, n);\n    vec3 h = normalize(cam-dir);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1))*smoothstep(-.5,.5,scene(p+n*.5))*smoothstep(-1.,1.,scene(p+n));\n\n    // vec3 ground = vec3(.04,.05,.01);\n    // vec3 sky = vec3(.04,.04,.045);\n    // float fres=1.-abs(dot(cam,n))*.98;\n\n    float sunnordt = max(0.,dot(dir,n));\n    float sunnordtr = max(0.,-dot(dir,n));\n    float sunrefdt = dot(n,h);//*.5+.5;\n    float ggx = .05/(0.99+cos(sunrefdt*2.92));\n    //float roug = step(0.,tex(p.xy*.05));\n    //float ggx = mix(.05/(0.99+cos(sunrefdt*2.92)),.1/(0.96 + cos(sunrefdt*2.7)),roug);\n\n    \n    // vec3 skydiff = mix(ground,sky,n.z*.5+.5)*sqrt(ao);\n    // vec3 sundiff = sunnordt*vec3(5);\n    \n    vec3 skyspec = mix(mix(vec3(0),vec3(.05,.05,.01),smoothstep(-1.1,-.7,n.z)),vec3(.04,.045,.045),smoothstep(-.6,.6,r.z))*sqrt(ao);\n    vec3 sunspec = ggx*sqrt(sunnordt)*.3*vec3(2.2,1.8,1.5);//ggx approximation\n    \n    \n    init = p;\n    p += dir*.001;\n    float minn = 1e4;\n    for (int j = 0; j < 60; j++) {\n        float dist = scene(p);\n        minn=min(minn,dist/length(p-init));\n        if (dist < 0.0001) {minn=0.; break;}\n        p += dist*dir;\n        if(length(p-init)>50.)break;\n    }\n\n    minn = pow(max(minn,0.),.1);\n    vec3 col = (sunspec*minn+skyspec)\n#ifdef COWS\n    *(step(0.1, tex(op*.03))*5.+.25)\n#endif\n    ;\n    \n    vec3 grasscol = rnd3<.5?vec3(.52,.57,.1):vec3(0.322,0.137,0.137);\n    //this grass material has no physical basis\n    if (gnd) col = grasscol*mix(.01,(sunnordt*5.+sunnordtr*.5+ggx*2.)*minn+.4,atten*ao*(minn*.5+.5));//minn*vec3(.1,.2,.05);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfloat sd = float(iFrame);\n\tsd = hash(sd, hash(uv.x,uv.y));\n\tvec2 h2 = tan(vec2(hash(sd, 6.7), hash(sd, 3.6)))*.8;\n\tvec2 uv2 = uv + h2/iResolution.y;//*(iFrame%3==2?2.5:1.);\n\tfragColor += vec4(pixel_color(uv2), 1);//*(iFrame%3==2?-1.:1.);\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}