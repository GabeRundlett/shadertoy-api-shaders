{
    "Shader": {
        "info": {
            "date": "1495618447",
            "description": "mixing 16*vec4, down to 1*vec4, by a pointer, branchless.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldXBDn",
            "likes": 2,
            "name": "mix 16 textures branchless",
            "published": 3,
            "tags": [
                "texture",
                "demo",
                "mis",
                "branchless",
                "step",
                "pipeline"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 659
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/ldXBDn\n\n#define time iTime\n//above is for fancy movement, below is static and focusing on what matters:\n//#define time 0.\n//being too lazy to rewind!\n\n//set degree of theponynomial that is used to blend between 2 colors.\n//higher polynomials than 0 are \"experimental and not good.\n#define poninomial 2\n//#define poninomial 0, simple step() \n//#define poninomial 1, I failed to get linear interpolation to work as intended.\n//#define poninomial 2, smoothstep() with an ugly but expected modulo discontinuity at 0\n\n//This is about mixing 16 textures down to 1 texture, \n//possibly more efficiently in the long run.\n\n//This is more a proof of concept with potential that I may not see now.\n//I am not sure if this speeds up things in the long run or not.\n//I know this is just one of many solutions and my sorting is not ideal.\n\n//The issue:\n//I see a function a lot that selects one of 2 vec4\n//...depending on which of their .x or .y or .z or .w values is smaller:\nvec4 select(vec4 a,vec4 b){if (a.w<b.w)return a;return b;}\n/*\nIs a common z-buffer branch, used when you only return one of two .xyz textures, \n...depending on their .w distance.\n\nbut your if() branch will likely be compiled into a jump() instruction \n...and every jump() instruction halts (or interrupts) a pipeline.\nModern hardware increasingly supports longer pipelines \n...that perform as fast as its slowest subroutine, \n...and the performance culpit (even for the most dedicated alu)\n...is usually pow(a,b)==exp(log(a)*b)\nA jump() \"breaks\" a pipeline in 2 shorter pipelines.\nA jump() can make sense to skip a slow pipeline, \n...but that diminishes over time with hardware being more in support of long pipellines.\n*/\n//A branchless vesion of select() is:\nvec4 selectBranchless(vec4 a,vec4 b){return mix(a,b,step(a.w,b.w));}\n//rather than worring about order or sign, within the step() part, I just fix it by trial.\n/*\nyou can substitute step(a.x,a.y)==step(a.w-b.w,0), \n...and make its inherent differential apparent.\n\nRenaming selectBranchless to bm() and make the step() part of it less dependent,\nthe fun part is the option of doing a (base2) recursion of bm*(), as below;\n*/\n\n//concept, to alias a small function, to swap a function in multiple places.\n#if (poninomial==0)\n float mt(float a){return step(a,0.);}//do step interpolation. 0deg polynomial\n#elif (poninomial==1)\n float mt(float a){return abs(fract(a/16.)-.5)*4.;}//do linear interpolation. 1deg polynomial\n //this totally fails to be usefull to me.\n //i wanted it to be more like fract?\n //return fract(a/16.); sure looks \"interestring\" somehow\n#else\n float mt(float a){float blur=acos(1.)-cos(time*(sqrt(5.)*.5+.5))*.5+.5;\n  return smoothstep(+blur,-blur,a);}//do cubic interpolation. 2deg polynomial\n  //yeah , smoothstep() is a 3rd deg polynomial, but only x*x*x and x*x are nonZero.\n#endif\n//the other 2 above are not too usefull for now, just concepts for extensions:\n\n//https://en.wikipedia.org/wiki/Smoothstep\n//returns binomial coefficient without explicit factorials, which can't be used with negative integers\nfloat pascalTriangle(float a,int b){float r=1.;for(int i=0;i<b; i++){\n float f=float(i);r *=(a-f)/(f+1.);}return r;}\n//Generalized smoothstep\nfloat smoothstepN(float x,int N){x=clamp(x,0.,1.);float result=0.;float M=float(N);\n for(int n=0;n<=N;n++){float m=float(n);\n   result +=(pascalTriangle(-M-1., n)*pascalTriangle(2.*M+1., N-n)*pow(x,M+m+1.));\n }return result;}\n\n\n\n\n//exponential recursion makes things exponentially repetitive:\n#define bm0i float a,vec4 b,vec4 c\n#define bm1i bm0i ,vec4 d,vec4 e\n#define bm2i bm1i ,vec4 f,vec4 g,vec4 h,vec4 i\n#define bm3i bm2i ,vec4 j,vec4 k,vec4 l,vec4 m,vec4 n,vec4 o,vec4 p,vec4 q\n//bmN() ==Boolean_Mix_N== branchless mix of N vec4:, using step() instead of a boolean branch. \n//N=base2_exponent of number-of_mixed_colors.\nvec4 bm0(bm0i){return mix(b                        ,c                        ,mt(a));}//depending on [a], return one of  2 vec4 [b,c]\nvec4 bm1(bm1i){return mix(bm0(a-2.,b,c            ),bm0(a+2.,d,e            ),mt(a));}//depending on [a], return one of  4 vec4 [b,c,d,e]\nvec4 bm2(bm2i){return mix(bm1(a-4.,b,c,d,e        ),bm1(a+4.,f,g,h,i        ),mt(a));}//depending on [a], return one of  8 vec4 [b,..,i]\nvec4 bm3(bm3i){return mix(bm2(a-8.,b,c,d,e,f,g,h,i),bm2(a+8.,j,k,l,m,n,o,p,q),mt(a));}//depending on [a], return one of 16 vec4 [b,..,q]\n//bm1() does 2*bm0()                           (             3*mt(),            1*sub).  \n//bm2() does 2*bm1(),does 4*bm0()              (             7*mt(),            3*sub). \n//bm3() does 2*bm1(),does 4*bm0(),does 8*bm0() (            15*mt(),            7*sub).\n//bmN() does                                   ((pow(2,N+1)-1)*mt(), (pow(2,N)-1)*sub).\n\n//For when you really do not trust branches and have a long array of vec4 to select from, \n//...but do not want to use arrays.\n//branchless, because you are in a deep subroutine that gets iterated over quite a lot \n//...within a pipeline and you do not want to branch (jump) the pipeline.\n//vec4, because you realized that mat4 is 6x as efficient as float[16], \n//...because arrays are very memory inefficient in webGL.\n\n//The above ordering of variables [b..q] and the a-N a+N offsets are VERY arbituary,\n//...just one of many was to \"sort\" things\"\n//...and likely not too intuitive (unsorted) in its results, \n//...but it LOOKS simple and computes fast.\n//\n//the problem with the above ordering is \n//...how bm3() on its own appears to \"shuffle\" the colors of bmDemo():\n//...which is adjusted by a=mod(a,32.);a-=16.;a=-a; within bmDemo()\n//... which is possibly not the best workaround for sorting this out.\n//\n//You have fun SORTING that one out, by swapping parameters of bm3() and its subroutines.\n//because I am fine with this \"inefficient solution\" as a proof of concept.\n//any any utility (including optimization) is up to you!\n\nvec4 bmDemo(vec2 u,float a){\n //16 textures [b...q] are \"procedural\", and NOT wasting memory by being in an array.\n //16 textures are close to being the \"good old 4bit=16colors palette\".\n vec4 \n b=vec4(0,0,0,1)+texture(iChannel0,u),//+vec4(0,0,0,1)\n c=vec4(0,0,0,1)+texture(iChannel1,u),//+vec4(0,0,1,1)\n d=vec4(0,0,0,1)+texture(iChannel2,u),//+vec4(0,1,0,1)\n e=vec4(0,0,0,1)+texture(iChannel3,u);//+vec4(0,1,1,1)\n //or they could be const (or even global), a bit pointless, but can compile faster.\n const vec4\n f=vec4(1,0,0,1),\n g=vec4(1,0,1,1),\n h=vec4(1,1,0,1),//yellow\n i=vec4(1,1,1,1),//white\n j=vec4(.8,.3,.0,1),//brown \"=yellow.dark\"\n k=vec4(.0,.0,.5,1),//blue.dark\n l=vec4(.0,.5,.0,1),\n m=vec4(.0,.5,.5,1),\n n=vec4(.5,.0,.0,1),\n o=vec4(.5,.0,.5,1),\n p=vec4(.5,.5,.0,1),\n q=vec4(.5,.5,.5,1); \n a=abs(a);//otional abs (makes no difference due to how this demo is used)\n a=mod(a,32.);//likely optional modulo.\n //a=floor(a);//very optional flooring\n a-=16.;//the offset sadly seems essential;\n a=-a;//sort from left to right, except that i and j are swapped.\n //return bm0(a,b,c);\n //return bm1(a,b,c,d,e);\n //return bm2(a,b,c,d,e,f,g,h,j,i);\n return bm3(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);//branchlessly select between one of 16 textures, set by a;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n U=U/iResolution.xy;//u is needed for texture() coordinates.\n float u=U.x;//u sets what \"testure\" of 16 tetures will be shown.\n u*=32.+sin(time)*9.;//scale slice width\n O=bmDemo(U,u+time);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}