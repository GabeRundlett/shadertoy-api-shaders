{
    "Shader": {
        "info": {
            "date": "1585918944",
            "description": "Creating a looping magnetized block animation using basic motion tweening techniques. ",
            "flags": 0,
            "hasliked": 0,
            "id": "wslcDS",
            "likes": 66,
            "name": "Motion Tweening",
            "published": 3,
            "tags": [
                "motion",
                "tweening",
                "keyframe"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1430
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tMotion Tweening\n\t---------------\n\n\tCreating a looping animation with magnetized blocks utilizing basic motion \n    tweening techniques. The animation sequence itself is a rough recreation \n    of a sequence I've seen around in GIF form on the internet. I'm not sure \n    where the original came from, but if I were to take a guess, I'd say it was \n    created by Andreas Wannerstedt, who produces a lot of mesmerizing looping \n    animations... but I wouldn't quote me on it.\n\n    I've been away for a while, so wanted to start with something relatively\n\tsimple. Motion tweening requires a bit of effort, but is relatively easy\n\trepetitive work. Demosceners do stuff like this all the time, but for those \n\tnot familar with the process, you just choose a total looping time \n    (tm = mod(iTime, totalTime)), then partition it into individual time segments \n    using a case statement, or some if-elseif statements. The segment intervals \n    themselves are filled with interpolated motion, distortion, morphing, etc.\n\n    As you can see, none of the individual movements are particularly complex;\n    rotations, pivots, translations, etc -- A lot of it was made up on the fly,\n\tso I'd imagine there'd be more efficient ways to achieve the same. One thing\n\tto note is that the colored cube moves in conjunction with the larger one, \n    which might throw some people off, but that's just a simple case of moving \n    the chrome looking box, setting the cube coordinates to the chrome box \n\tcoordinate system (p = pPrevious), then peforming more simple operations.\n\t\n    I seem to say this a lot, but apologies in advance for the extended compile\n\ttime. This should run pretty quickly, but the lengthy decision-making logic\n\tinside the raymarching loop taxes the compiler, which is amplified with the \n\treflection pass. By the way, you could simplify the objects and use IQ's \n    raytraced rounded-box intersection formulas to make this way, way more\n\tefficient. However, keeping track of the rotations for normal calculations, \n    and so forth, would get pretty tiresome... It's the kind of thing I'll leave \n    for Dr2 to do. :)\n\n\n\n    Other examples:\n\n\n    // This is one of the most clever and innovative examples on here.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n#define FAR 30.\n\nvec4 vObjID;\nint objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Time variables.\nfloat tm, t, t2;\n\n// Animation segment ID.\nint segID = 0;\n\n// The motion tween block. There's another withing the raymarching loop. \n// We're performing whatever nonpositional lengthy calculations we can outside \n// the raymarching loop. Usually, declaring things locally can help speed things\n// up, but there is a point where precalculation is necessary. In any case, taking\n// things outside the raymarching loop should reduce compile time... Although,\n// with GPUs, who knows. A lot of it's hit and miss.\n//\nvoid doTweenTime(){\n    \n    \n    // The total loop time. We're starting after the ten second mark.\n    tm = mod(iTime + 10., 10.25);\n    \n    if(tm<1.){ // if(tm>=0. && tm<1.)\n        \n        // Normalize to the zero to one range: Time minus start time, divide total time;\n        t = tm;//(tm - 0.)/(1. - 0.);\n        // At this point, you can perform whatever kind of easing function, etc, on the \n        // normalized figures. \n        t = bounceOut(t);\n          \n        // Afterwards, adjust according to start value and end value.\n        // In this case, we wish to rotate from zero to PI/2.\n        t = mix(0., PI/2., t);\n        \n        // Setting a segment ID. This isn't really necessary, but I wanted the logic\n        // inside the raymarching loop as simple as possible. The theory being that\n        // \"if(segID == 0)\" should compile better than \"if(tm<1.),\" but it also allows\n        // for \"switch\" statement usage.\n        segID = 0;\n        \n    }\n    else if(tm<2.){ // if(tm>=1. && tm<2.)\n        \n        t = tm - 1.; // (tm - 1.)/(2. - 1.);\n        t2 = exponentialInOut(t);\n        t = easeInOutCubic(t);\n        \n        segID = 1;\n      \n    }      \n    else if(tm<3.){\n        \n        t = tm - 2.; // (tm - 2.)/(3. - 2.);\n        t2 = t;\n        t = exponentialOut(t);\n        \n        \n        segID = 2;\n  \n    }    \n    else if(tm<4.){\n         \n        // Normalize to the zero to one range: Time minus start time, divide total time;\n        t = tm - 3.; // (tm - 3.)/(4. - 3.);\n        t2 = t; // easeOutQuad(t);\n        t = bounceOut(t);\n        t = mix(0., PI/2., t);\n        \n        segID = 3;\n    }\n    else if(tm<5.){\n        \n        t = tm - 4.; // (tm - 4.)/(5. - 4.);\n        t2 = easeInQuad(t);\n        t = easeInOutCubic(t);\n        t = mix(PI/2., 0., t);\n        \n        segID = 4;\n        \n     }\n    else if(tm<6.){\n        \n        // Time minus start time, divide total time;\n        t = tm - 5.; // (tm - 5.)/(6. - 5.);\n        t2 = t;\n        // Easing.\n        t = easeInOutCubic(t);\n        // We're performing a half turn.\n        t = mix(0., PI/1., t);\n        \n         segID = 5;\n \n    }\n    else if(tm<7.){\n       \n        // Time minus start time, divide total time;\n        t = tm - 6.; // (tm - 6.)/(7. - 6.);\n        // Easing.\n        t = bounceOut(t);\n        // We're performing a half turn.\n        t = mix(0., -PI/2., t);\n        \n        segID = 6;\n    }\n    else if(tm<8.){\n       \n        // Gold cube pivot to join the left leaning larger block.\n        t = tm - 7.; // (tm - 7.)/(8. - 7.);\n        t = easeInOutCubic(t);\n        t2 = t;\n        \n        segID = 7;\n       \n    }\n    else if(tm<9.){\n       \n        t = tm - 8.; // (tm - 8.)/(9. - 8.);\n        t2 = t;\n        t = easeInOutCubic(t);\n        t = mix(PI/2., 0., t);\n        \n        segID = 8;\n        \n     }  \n    else if(tm<10.){\n       \n        t = tm - 9.; // (tm - 9.)/(10. - 9.);\n        t2 = easeOutQuad(t);\n        \n        segID = 9;\n           \n    }\n    else if(tm<10.25){\n     \n        segID = 10;\n    }    \n    \n    \n}\n\n\nvoid move(in vec3 p, inout vec3 q, inout vec3 q2, inout vec3 svDim, in vec3 bDim2){\n\n    // Make a copy of the large box dimensions to account for varying length.\n    vec3 bDim = svDim;\n    \n        // I debated over whether to use a switch statement versus the else-if mess you see here. \n    // They say switches are faster with more that a few items, but for whatever reason, my \n    // compiler hated the switch statement... When all's said and done, I know of a much,\n    // much faster way, but it'll require some considerable restructuring.\n    \n    if(segID == 0){\n        \n        \n        // \"segID == 0\" corresponds to the time period between zero and one second. The\n        //  time, \"t,\" has been normalized to the zero to one range (trivial, in this case)\n        // and has been passed through an easing function. Which easing function is chosen \n        // depends on the movement style you're after; ease-in, exponential-out, bounce, etc. \n\n        \n        \n        // Begin with the large box at floor level.\n        q.y -= bDim.y;\n        \n        // Lean down right.\n        // This is a pivot motion. Basically, you offset the position to the pivot point,\n        // whilst rotating and offsetting by the pivot amount. In this case, the pivot\n        // point is at moved from the middle pivot position, vec3(0) to vec3(bDim.x, bDim.y, 0),\n        // which represents the middle of the lower left edge, and we're rotating about the\n        // XY plane. By the way, 3D rotations could be utilized, but I'm trying to stick to\n        // the basics.\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube pivotal flip, with respect to the larger cube's preoriented transform.\n        //\n        // Set the colored cube coordinates to the chrome boxes coordinats. Using a second \n        // variable for the second objects coordinates isn't absolutely necessary, but I think\n        // it reads better.\n        q2 = q; \n        q2.y -= -bDim2.y; // Move into position with respect to the chrome cube.\n        // Pivot -- See the pivot explanation above.\n        q2.xy = rot2(-t)*(q2.xy - vec2(-bDim2.x, bDim2.y)) - vec2(-bDim2.x, -bDim2.y);\n   \n        \n    }\n    else if(segID == 1){\n        \n        \n        // Slide and shrink the height.\n        q.x -= mix(0., -bDim.x*3., t);\n        q.y -= bDim.y;\n        svDim.y = mix(bDim.y, bDim.y/2., t);\n        \n        q.xy = rot2(-PI/2.)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube slide.\n        // Move the cube relative to the large block position, q.\n        q2 = q;\n        q2.x -= -bDim.x*2.; \n        q2.y -= mix(bDim.x, 0., t);\n\n        // Spinning relative to the q axes -- The global XZ axes to the viewer, but the\n        // YZ axes from the perspective of the chrome cube.\n        q2.yz = rot2(t2*PI*2.)*q2.yz;\n     \n    }      \n    else if(segID == 2){\n        \n        // Grow taller.\n        svDim.y = mix(bDim.y/2., bDim.y, t);\n        \n        q.y -= svDim.y;\n        q.xy = rot2(0.)*(q.xy - vec2(bDim.x, -svDim.y)) - vec2(-bDim.x, svDim.y);\n        \n        \n         \n        // Gold cube jump and flip.\n        q2 = p;\n        q2.y -= svDim.y*2. + bDim2.y;//mix(bDim.y/2., bDim.y, t)*2.; // Grow with the bottom object.\n        \n        \n        if(t2<.35) q2.y -= t2/.35*bDim.y*.7; // Ascend from the top of the object below.\n        else q2.y -= (bDim.y - bounceOut((t2 - .35)/.65)*bDim.y)*.7; // Decend back to the top.\n              \n       \n        q2.yz = rot2(-t2*PI/1.)*(q2.yz); // Front flip.\n  \n  \n    }    \n    else if(segID == 3){\n       \n\n        \n        // Lean down right.\n        q.y -= svDim.y;\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        q2 = q;\n        q2.y -= bDim.y + bDim2.y;\n        // Pivot the gold cube anticlockwise from the top by 2 PI.\n        q2.xy = rot2(t*2.)*(q2.xy - vec2(-bDim2.x, -bDim2.y)) - vec2(bDim2.x, bDim2.y);\n \n        //\n    }\n    else if(segID == 4){\n        \n        \n        // Lean up left.\n        q.y -= bDim.y;\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube: Slide from top to bottom.\n        q2 = q;\n        q2.x -= -bDim2.x*2.;\n        q2.y -= mix(bDim2.y, -bDim2.y, t2);\n        \n    }\n    else if(segID == 5){\n        \n        \n        q.y -= bDim.y;\n        q.xz = rot2(t)*(q.xz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n        \n        \n        // Gold cube.\n        q2 = q;\n        q2.y -= -bDim2.y; // Move into position.\n        q2.x -= -bDim2.x*2.; // Move into position.\n        \n        q2.xz = rot2(-t)*(q2.xz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n\n    }\n    else if(segID == 6){\n        \n        \n        //Lean down left (one cell up).\n        q.y -= bDim.y;\n        q.x -= bDim.x*2.;\n        q.z -= bDim.z*2.;\n        q.xy = rot2(-t)*(q.xy - vec2(-bDim.x, -bDim.y)) - vec2(bDim.x, bDim.y);\n        //q.z -= bDim.z;\n        \n        // Gold cube: Leave stationary.\n        q2 = p; // Detatch from the larger box coordinate system, and use the global one.\n        q2.y -= bDim2.y; // Move into position.\n        q2.x -= bDim2.x*2.;\n        \n    }\n    else if(segID == 7){\n       \n       \n        //From a down left position (one cell up), slide to the right.\n        q.y -= bDim.y;\n        //q.x -= bDim.x*2.;\n        q.x -= mix(bDim.x*2., bDim.x*4., t);\n        q.z -= bDim.z*2.;\n        q.xy = rot2(PI/2.)*(q.xy - vec2(-bDim.x, -bDim.y)) - vec2(bDim.x, bDim.y);\n        \n        // Gold cube.\n        q2 = q; \n        q2.y -= -bDim2.y*3.; \n        q2.z -= -bDim2.z*2.; \n        \n        // Whilst sliding, pivot the gold cube to the top of the larger object.\n        q2.yz = rot2(-t2*PI/2.)*(q2.yz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n       \n    }\n    else if(segID == 8){\n       \n        \n        // Move the chrome cube into this frame's position.\n        q.y -= bDim.y;\n        q.x -= -bDim.x*2.;\n        q.z -= bDim.z*2.;\n        \n        // Pivot about XZ.\n   \t\tq.xz = rot2(t2*PI/1.)*(q.xz - vec2(bDim.x, -bDim.z)) - vec2(-bDim.x, bDim.z);           \n        // Pivot about XY.\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n \n        \n        // Gold cube flip back down a level.\n        q2 = q; \n        \n        q2.xy = rot2(t2*PI)*(q2.xy - vec2(-bDim.x, bDim.y)) - vec2(bDim.x, -bDim.y);\n        q2.y -= bDim2.y*3.;\n        \n    }  \n    else if(segID == 9){\n       \n         \n        //Rotate and slide back to the original position.\n        q.y -= bDim.y;\n       \n        // Rotate about XZ with no pivoting.\n        q.xz = rot2(t*PI/2.)*(q.xz);           \n         \n        \n        // Pivot the gold cube about XZ whilst sliding back down to the ground.\n        q2 = q;\n        q2.x -= bDim.x*2.;\n        q2.y -= mix(bDim2.y, -bDim2.y, t2);\n      \n        q2.xz = rot2(t*PI)*(q2.xz - vec2(-bDim.x, bDim.z)) - vec2(bDim.x, -bDim.z);\n          \n    }\n    else {\n        \n        // Pause briefly before continuing the looping process again.\n        q.y -= bDim.y;\n        \n        q2 = q;\n        q2.y -= -bDim2.y;\n        q2.x -= -bDim.x*2.;\n        \n    }\n\n}\n\n// Distance function: This one is pretty simple.\nfloat map(vec3 p){\n\n\n    // Floor.\n    float fl = p.y;  //-sBoxS(p - vec3(0, 3, 0), vec3(6, 3, 6),.04);//min(p.y, -p.y + 3.8);\n    \n    \n\n    // Object dimensions.\n    vec3 bDim = vec3(.25, .5, .25); // Large box.\n    const vec3 bDim2 = vec3(.25, .25, .25); // Small cube.\n   \n    // Local coordinates for each moving object.\n    vec3 q = p, q2 = p;\n    \n    // Move the objects.\n    move(p, q, q2, bDim, bDim2);\n \n    \n    // The rendering portion is the easy bit; Just some standard distance\n    // field operations with IQ's box formula.\n    \n    \n    // The chrome box.\n    float obj = sBox(q, bDim, .04);\n    \n    // The colored cube.\n    float obj2 = sBox(q2, bDim2, .04); \n    \n    // Chrome box grooves.\n    //obj = max(obj, -sBox(q, bDim*vec3(.25, .667, 1.2), .04));   \n    //obj = max(obj, -sBox(q, bDim*vec3(.25, 1.2, .25), .04)); \n    //obj = max(obj, -sBox(q, bDim*vec3(1.2, .667, .25), .04)); \n    obj = max(obj, -sBox(q.xy, bDim.xy*vec2(.25, .667), .04));   \n    obj = max(obj, -sBox(q.xz, bDim.xz*vec2(.25, .25), .04)); \n    obj = max(obj, -sBox(q.yz, bDim.yz*vec2(.667, .25), .04)); \n    \n    // Colored box nodules.\n    obj = min(obj, sBox(q2, bDim2*vec3(.25, .25, 1.2), .04));   \n    obj = min(obj, sBox(q2, bDim2*vec3(.25, 1.2, .25), .04)); \n    obj = min(obj, sBox(q2, bDim2*vec3(1.2, .25, .25), .04));\n    \n    // Center of the chrome box.\n    obj = min(obj, sBox(q, bDim*vec3(.833), .04)); \n\n \n\n    // Store the floor, chrome box and gold cube positions for sorting\n    // and surface identification outside the loop.\n    vObjID = vec4(fl, obj, obj2, 0);\n    \n    \n    // Return the minimum object.\n    return min(min(fl, obj), obj2);\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(0, iFrame); i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .01, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.25/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        if(occ>1e5) break; // Fake break to get compile time down.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n\n// The floor, chrome cube, and colored cube materials. These ones are pretty\n// basic, but you could put more effort in.\n//\nvec3 getObjectColor(vec3 p, vec3 r, vec3 n){\n    \n    \n    vec3 col;\n        \n    if(objID == 0) {\n       \n        // The floor.\n        vec3 tx = texture(iChannel0, p.xz/4.).xyz; tx *= tx;\n        col = tx*vec3(1, .7, .5)*.5;\n        \n    }\n    else if(objID == 1) {\n        \n        // The chrome colored box. It's something I tend to get, but tinging\n        // things blue can help bring about a metallic color... kind of. :)\n        col = vec3(.65, .85, 1);\n    }\n    else {\n        \n        // The cube. \n        col = vec3(2, .9, .45); // Redish gold.\n        //col = vec3(.7, 1.2, .3); // Green.\n        //col = vec3(2, .35, .85); // Pink.\n        //col = vec3(.3, 1, 2.5); // Blue.\n        //col = vec3(.3); // Grey\n    }\n    \n\n    // Adding some fake cube mapping information. The science is terrible, but it \n    // adds a bit of shine. :)\n    vec3 cTx = tex3D(iChannel0, reflect(r, n)/1.5, n);\n    cTx *= vec3(1, .8, .6);\n    \n    // Add a dose of fake reflection to the box and cube, and just a bit to the floor.\n    if(objID>0) col *= cTx*2.;\n    else col += cTx*.1;\n    \n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    \n    // Initiate the scene color to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), .0001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        float ao = calcAO(sp, sn);\n\n        // Attenuating the light, based on distance.\n        float atten = 1./(1. + lDist*.2 + lDist*lDist*.05);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n        \n        // Ramp up the diffuse value. Sometimes, it can help things look metallic.\n        diff = pow(diff, 4.)*2.;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, rd, sn);\n        \n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*((diff + ao*.2) + vec3(1, .97, .92)*spec*4.);\n        \n        // Apply the attenuation and ambient occlusion.\n        sceneCol *= atten*ao;\n        \n    }\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .9, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\nvec3 getRd(vec2 u, vec3 ro){\n   \n    // Camera Setup.     \n    vec3 lk = vec3(0, .5, 0);  // \"Look At\" position.\n\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    // Warping the ray to give that curved lens effect.\n    //rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    return rd;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Slight barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .2*(r*r + r);\n    \n    float cTm = iTime/2.;\n    vec3 ro = vec3(sin(cTm)*2.65, cos(tm)*sin(cTm)*.25 + 2.25, cos(cTm)*2.65);//vec3(0, 0, 0);\n    //vec3 ro = vec3(sin(cTm)*.75, cos(tm)*sin(cTm)*.25 + 2.25, -2.65);//vec3(0, 0, 0);\n \n    \n    vec3 rd = getRd(uv, ro);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n\n    vec3 lp = vec3(1, 3, -1); // Light position. Set in the vicinity the ray origin.\n\n \n    // Movement calculations -- Outside the loop, in an attempt to save on compiler time.\n    doTweenTime();\n    \n    \n    \n    // FIRST PASS.\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n \n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! Better call the shadow police. :)\n    float sh = softShadow(ro +  sn*.0015, lp, 12.);\n    sh = min(sh + .3, 1.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  sn*.003, rd);\n    \n\n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    //sceneColor += doColor(ro, rd, sn, lp, t)*.5;\n    // Other combinations... depending what you're trying to achieve.\n    vec3 rCol = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor + rCol*.75;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \n    // Extra coloring.\n    //sceneColor *= vec3(1.1, 1, .9);\n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Easing functions are their own topic, but a lot of it is straight forward.\n// Usage is easy. Normalize the time between zero and one, then choose the \n// one you're after.\n\nconst float PI = 3.14159265358979;\n\n// Robert Penner's easing functions in GLSL.\n// Available as a module for glslify. http://stack.gl/glsl-easings/\n\nfloat easeInOutCubic(float t){\n\n    return t<0.5 ? 4.*t*t*t : (t - 1.)*(2.*t - 2.)*(2.*t - 2.) + 1.;\n}\n\nfloat easeInOutQuint(float t){\n\n    return t<.5 ? 16.*t*t*t*t*t : 1. +16.*(--t)*t*t*t*t;\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\n \nfloat bounceOut(float t) {\n    \n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI/2.) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n// IQ's unsigned box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned rectangle formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}