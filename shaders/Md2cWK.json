{
    "Shader": {
        "info": {
            "date": "1494079862",
            "description": "A slight variation on an old tile flipping technique.",
            "flags": 0,
            "hasliked": 0,
            "id": "Md2cWK",
            "likes": 51,
            "name": "Overlap Tiling",
            "published": 3,
            "tags": [
                "circle",
                "pattern",
                "polar",
                "tile",
                "flip"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2136
        },
        "renderpass": [
            {
                "code": "/*\n\n\tOverlap Tiling\n\t--------------\n\n\tIf I were to give this a longer descriptive title, I'd probably call it tile\n\tquadrant overlap flipping... which is not a catchy title either. :) I'm not \n\treally sure what you'd technically call the process, but it's just some basic \n\ttile flipping that you may have seen around. Fabrice Neyret makes use of it in \n\tsome of his examples, but this particular one was inspired by one of Cexlearning's \n\tpostings - I've provided the link below.\n\n\tThe trick behind this is pretty simple: Partition space into a grid, then \n\tsubdivide the grid into quadrants. In each quadrant (top left, top right, bottom\n\tleft, bottom right), draw two overlapping symmetrical quarter shapes - Circles are\n\tthe most common. Randomly overlap the top one or the bottom one, depending on the \n\thash ID for that quadrant... \n\n\tOK, this is the point where I'd have difficulty visualizing, which is why I've \n\tprovided a \"SHOW_GRID\" define below. Look at the way the shapes overlap in each\n\tquadrant cell. There's also a \"SHOW_FLIPPED\" define that displays which quadrants\n    have been flipped. Hopefully, those should make the description much clearer.\n\n\tThe rest is just some polar coordinate-based decoration. For anyone not familiar\n\twith that part of the process, it's worth taking some time out to draw something\n\talong the lines of a clock face with circles, squares, etc, in place of the \n\tnumbers.\n\n\n\t// A nice example - especially if you want to see a much less bloated version.\n\tSketch_Discs3 - cexlearning\n    https://www.shadertoy.com/view/4d2yDh\n    Based on this: Keijiro - https://github.com/keijiro/ShaderSketches\n\n*/\n\n// A visual aid to see the overlapping shapes in each quadrant. \n//#define SHOW_GRID\n// Shows which quadrants have been flipped. Only shows when \"SHOW_GRID\" is defined.\n//#define SHOW_FLIPPED\n\n// Gives the pattern shapes a polynomial feel. Try 3, 4, 5, 9, etc.\nconst float sides = 5.; \n\n// vec2 to float hash.\nfloat hash21( vec2 p ){ return fract(cos(dot(p, vec2(41.31, 289.97)))*45758.5453); }\n\n// Fabrices consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Drawing a shape of radius \"w\" with falloff factor \"fo.\"\nfloat ci(vec2 p, float w, float fo){\n    \n    p = fract(p) - .5; // Grid partition.\n    float a = atan(p.y, p.x); // Used to vary the radius to give a polynomial look.\n    float circ = -length(p)*(cos(a*sides)*.035 + .965) + w;     \n    return smoothstep(0., fo*2.*.333/450./max(circ, 0.001), circ); // Less interference than \"fwidth.\"\n    //return smoothstep(0., fwidth(circ-.015)*2., circ-.015); \n    \n}\n \n// The indivdual shape gradient. Basically the same as above, but without the smoothstepping.\nfloat ciGrad(vec2 p, float w){\n    \n    p = fract(p) - .5; // Grid partition. \n    float a = atan(p.y, p.x); // Used to vary the radius to give a polynomial look.\n    return -length(p)*(cos(a*sides)*.035 + .965) + w;  \n    \n}\n\n// The shape patterns. It's all pretty easy, but it's fiddly... which is just another way to say that\n// it's really annoying to code. :) Honestly, you could pretty much ignore this.\nfloat ciPat(vec2 p, float w, float dir){\n   \n    // Subdivide the grid.\n    p = fract(p) - .5; \n    \n    // Converting to polar coordinates:\n    // r = length(p), a = atan(p.y, p.x), p = p*rot(a).\n    // Ie: p.x = r*cos(a), p.y = r*sin(a).\n    \n    // To make this slightly more complica... interesting, I've multiplied the radius\n    // by a sinusoidal term to give the circles a rounded polynomial looking shape. \n    \n    \n    // Some prerotation (is that a word?) for a bit of animation.\n    p *= r2(iTime*.25*dir);\n    // Matching the shape mutation.\n    p *= cos((atan(p.y, p.x) + iTime*.25*dir)*sides)*.035 + .965;\n    \n    // The single center circle. Not sure why I called it \"dt.\" ...\n    // Short for dot, which is a reserved word. :)\n    float dt = -length(p) + .05;\n    dt = min(dt, -dt + .035);\n    dt = smoothstep(0., fwidth(dt)*1., dt);\n\n    \n    // Converting the grid positions to polar coordinates, as described above.\n    // The \"cos\" term is some aditional circle mutation. Change the global variable \"sides\" \n    // to something like 4 or 5, then you'll see the effect more clearly.\n    //float r = length(p)*(cos(atan(p.y, p.x)*sides)*.035 + .965);\n    float a = atan(p.y, p.x);\n    \n    \n    \n    // Calculating the the radial centers of each cell. It's a pretty standard way to get\n    // it done.\n    float cellDots = 9.;\n    float ia = floor(a/6.2831853*cellDots);\n    ia = (ia + .5)/cellDots*6.2831853;\n    \n    // Converting the radial centers to their positions within the circular looking shape.\n    p *= r2(ia);\n    \n    // Moving the points out a bit along the radial line.\n    float q = p.x - .18; //fract(p.x) - .5; // Radial repetion.\n    q = abs(abs(q) - .09); // Repeat trick to double up on points.\n    \n    // Drawing the two sets of nine dots.\n    float circ = -length(vec2(q, p.y)) + .03;\n    circ = min(circ, -circ + .0275);  // Taking the inner portions out to show just the outlines.\n    float c = smoothstep(0., fwidth(circ)*1., circ);\n    \n    // Drawing the lines within the slice shapes.\n    q = p.x - .27; // Radius.\n    float line = -max(abs(abs(p.y) - .05) - .1/8., abs(q) - .6/8.);\n    line = max(line, -max(abs(abs(p.y) - .015) - .1/8., abs(q + .1/8.) - .8/8.));\n    float c1 = smoothstep(0., fwidth(line)*1., line)*.5; // Lighten the lines.\n    \n    // I must have had fruit on my mind with doing this, hence the \"slice\" name.\n    // Anyway, this is the nine... abstrace fruit slice objects.\n    float slice = -length(vec2(q*.8, p.y))*(cos(atan(p.y, q)*3.)*.15 + .85) + .085;\n    slice = min(slice, -slice + .025); // Taking the inner chunks out to show just the outlines.\n    float c2 = smoothstep(0., fwidth(slice)*1., slice);\n    \n    // Combining the individual elements for the overall pattern.\n    return max(max(c, c2), max(c1, dt));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    // A bit of fake screen coordinate distortion for that fish-eye look.\n    uv *= sqrt(1. + dot(uv*iResolution.y/iResolution.x, uv)*.25);\n    \n    // Right to left scrolling.\n    float tm = iTime/8.;\n    // Slowing things down at larger resolutions - Based on Flockaroo's observation.\n    if(iResolution.x>800.) tm *= 800./iResolution.x;\n    uv += vec2(tm, 0);\n    \n    \n    // Subdivding the grid. I wanted the shapes to be the same size, regardless of\n    // resolution. Not sure whether that was the right choise or not. :)\n    vec2 p = uv*3.5*iResolution.y/450.;\n    \n    // The two colors. One for the top circle, and the other for the bottom. Which is top\n    // and bottom, depends on the random quadrand ID.\n    vec3 col1 = vec3(1);\n    vec3 col2 = vec3(1);\n    \n    // The shape radius - relative to maximum grid width. \".5\" is the maximum. In fact, I'm not\n    // sure why I coded this in, because \".5\" is pretty much the only setting that looks acceptable. :)\n    const float w = .5;\n    \n    // In regards to the following mask, overlays, etc. If you just want to put a simple example\n    // together without borders, decorations, etc, only one set is necessary. I could probably group\n    // a few together, but the calculations are relatively cheap, so I'm leaving them in a more\n    // legible state.\n    \n    // Inner shapes.\n    float c1Inner = ci(p, w - .075, 1.);\n    float c2Inner = ci(p + .5, w - .075, 1.); \n    \n    // Shape borders.\n    float c1Bord = ci(p, w + .025 - .075, 1.);\n    float c2Bord = ci(p + .5, w + .025 - .075, 1.); \n    \n    // Shadow masks.\n    float c1Sh = ci(p, w + .075 - .075, 2.);\n    float c2Sh = ci(p + .5, w + .075 - .075, 2.); \n    \n    // Shape pattern for decoration.\n    float c1Pat = ciPat(p, w - .075, 1.);\n    float c2Pat = ciPat(p + .5, w - .075, -1.);\n    \n    // Reverse the pattern on random shapes to add a bit more variance.\n    if(hash21(floor(p) + .71)>.65) c1Pat = 1. - c1Pat;\n    if(hash21(floor(p + .5) + .41)>.65) c2Pat = 1. - c2Pat;\n\n    \n    // Random shape colors.\n    if(hash21(floor(p) + .37)>.65) col1 *= mix(col1, vec3(.65, 1, .3), c1Inner);\n    if(hash21(floor(p + .5) + .53)>.65) col2 *= mix(col2, vec3(1, .75, .65), c2Inner);\n    \n    \n    // Applying the design pattern to the individual grid shapes.\n    col1 = mix(col1, vec3(0), c1Pat*.7);\n    col2 = mix(col2, vec3(0), c2Pat*.7);\n \n    // Shading the grid shapes with a circular gradient.\n    col1 = mix(vec3(0), col1, min(pow(ciGrad(p, w - .075)/(w - .075), 3.)*3. + .35, 1.));\n    col2 = mix(vec3(0), col2, min(pow(ciGrad(p + .5, w - .075)/(w - .075), 3.)*3. + .35, 1.));\n    \n\n    // Dark borders and edges. I did this in a hurry, so there'd be a better way for sure.\n    // The functions are cheap enough, so I'll leave them be, for now.\n    col1 = mix(vec3(.0), col1, c1Bord);\n    col2 = mix(vec3(.0), col2, c2Bord);\n    col1 =  mix(col1, vec3(0), c1Bord - c1Inner);\n    col2 =  mix(col2, vec3(0), c2Bord - c2Inner);  \n \n     \n    \n    // Applying the shadow masks, according to the random quadrant ID.\n    vec3 col;\n    if(hash21(floor(p*2.))>.5) col = mix(col1*c1Sh, col2, c2Sh);\n    else col = mix(col2*c2Sh, col1, c1Sh);\n    \n\n    \n    // The grid lines, to show each quadrant. The bottom shape is either on the top or the bottom,\n    // depending on the random ID for the quadrant. If you can understand that concept and know how\n    // to draw circles, you can pretty much ignore this bloated example in its entirety. :)\n    #ifdef SHOW_GRID\n    \n    vec2 ln;\n    \n    // Displays the flipped quadrants. Look at the shape encompassed by the red grid lines. Note that\n    // the flipped quadrants are drawn on top - relative to the central shape bounded by the four \n    // quadrant grid cell. \n    #ifdef SHOW_FLIPPED\n    if(hash21(floor(p*2.))>.5) col *= vec3(1., .5, 2);\n    ln = abs(fract(p + .5) - .5) - 3./450.;\n    col *= smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y)*.9 + .1;  \n    #else\n    ln = abs(fract(p + .5) - .5) - 7./450.;\n    col *= smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y)*.9 + .1;\n    ln = abs(fract(p + .5) - .5) - 2.5/450.;\n    col += (1. - smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y))*vec3(.5);\n    #endif\n    \n    ln = abs(fract(p) - .5) - 8./450.;\n    col *= smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y)*.85 + .15;\n\n    ln = abs(fract(p) - .5) - 2.5/450.;\n    col += (1. - smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y))*vec3(1, .0, .1);\n    \n    #endif\n    \n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored varation.\n    col = mix(pow(min(vec3(1.5, 1, 1)*col, 1.), vec3(1, 3, 16)), col, \n                     pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .2)*.75 + .25);\n    \n    \n    // Mild LCD overlay. It's very subtle, but it's there. :)\n    vec2 rg = mix(mod(fragCoord, vec2(2))*col.xy, col.xy, .5);\n    col = vec3(rg, col.z - mix(col.x - rg.x, col.y - rg.y, .5));\n \n   \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}