{
    "Shader": {
        "info": {
            "date": "1629122476",
            "description": "HIRC Julia Set Fractal Visualizer\n\nJoin the Research Collective!\ndiscord.gg/dKEWzPxaPP",
            "flags": 32,
            "hasliked": 0,
            "id": "ssc3R8",
            "likes": 2,
            "name": "Julia Set (HIRC)",
            "published": 3,
            "tags": [
                "fractal",
                "research"
            ],
            "usePreview": 0,
            "username": "hyperborean_rs_collective",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 OutColor, in vec2 InCoord) {\n\n    // SECTION: Input generation\n    vec2 UV = InCoord.xy / iResolution.xy;\n    vec4 BufferA = texture(iChannel0, UV);\n    vec3 Color = BufferA.rgb;\n\n    // SECTION: Lighting\n    \n    // NOTE: Lighting can be created using Integration.\n    // vec2 Eps = vec2(1e-1, 0.0);\n    // Integrate the angles using UV + Eps.xy, UV + Eps.yx, etc!\n    // TODO: Poisson sampling\n\n    // SECTION: Produce colour\n    OutColor = vec4(Color, 1.0);\n        \n    \n    // SECTION: Apply image effects\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Re-Names\n#define BufferA mainImage\n#define OutColor fragColor\n#define InCoord fragCoord\n\n#define ZOOM 1.0\n#define SCALE exp(ZOOM)\n\nvoid BufferA(out vec4 OutColor, in vec2 InCoord) {\n    float AspectRatio = iResolution.x / iResolution.y;\n    vec2 AspectRatioCorrector = vec2(AspectRatio, 1.0);\n    \n    // In range [0..1]\n    vec2 UV = fragCoord / iResolution.xy;\n    \n    // In range [-1..1]\n    vec2 NDC = RemapUVtoNDC(UV);\n    \n    // In range [-AspectRatio .. AspectRatio, -1.0, 1.0]\n    vec2 NDC_AR_Corrected = NDC * AspectRatioCorrector;\n    \n    // Current Point\n    vec2 Z = SCALE * NDC_AR_Corrected;\n    \n    // Seed value\n    vec2 C = SCALE * GetC(iTime);\n   \n    // (Real, Imag, Radius Squared) \n    // These values are set in the 'Compute the Fractal' section\n    vec3 Calculation;\n    vec3 PreviousCalculation;\n\n    int IterationsRemaining = BASE_ITERATIONS;\n    \n    do { /* SECTION: Compute the fractal */\n        PreviousCalculation = Calculation;\n        Calculation = Calculate(Z, C, PreviousCalculation);\n        // Z = Z^2 + C\n        Z = Calculation.xy;\n        \n        IterationsRemaining--;\n    } while (IterationsRemaining > 0);\n\n    vec2 PreviousZ = PreviousCalculation.xy;\n    float Angle = AngleBetweenPoints2D(Z, PreviousZ); \n    \n    \n    /*\n        Angle /= Calculation.z + PreviousCalculation.z;\n    */\n    vec3 Spectrum = Colorize(Angle);\n\n    // Output to the Buffer A texture\n    OutColor = vec4(Spectrum, Angle);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Common functions, constants and Compile options\n\n// Compile options:\n\n// For this Shader, the less iterations are best for visualization\n#define BASE_ITERATIONS (3)\n\n// Remaps a [0..1] point to [-1.0..1.0]\nvec2 RemapUVtoNDC(vec2 point) {\n    return -1.0 + 2.0 * point;\n}\n\nvec2 CModifier(vec2 C, float Time) {\n    return C * 1.0;\n}\n\n// Creates a value of C based on the Time parameter given\nvec2 GetC(float Time) {\n    vec2 C = vec2(cos(Time), sin(Time)) * 0.5;\n    // C = CModifier(C, Time);\n    return C;\n}\n\nvec2 ExpressionA(vec2 Z, vec3 PreviousResult) {\n    return abs(Z);\n}\n\nvec2 ExpressionModifier(vec2 Z, vec3 PreviousResult) {\n    //return abs(Z);\n    return Z;\n}\n\n// Returns: (Real, Imag, Radius Squared)\nvec3 Calculate(vec2 Z, vec2 C, vec3 PreviousResult) {\n    float Real = Z.x;\n    float RealSq = Real * Real;\n    \n    float Imag = Z.y;\n    float ImagSq = Imag * Imag;\n\n    vec2 Complex = vec2(RealSq - ImagSq, 2.0 * Real * Imag) + C;\n    Complex = ExpressionModifier(Complex, PreviousResult);\n    \n    \n    float RadiusSq = RealSq + ImagSq;\n    return vec3(Complex, RadiusSq);\n}\n\n\n// Returns: The angle between two 2D points in Radians\nfloat AngleBetweenPoints2D(vec2 A, vec2 B) {\n    vec2 Difference = A - B;\n    return atan(Difference.y, Difference.x);\n}\n\nvec3 Colorize(float AngleRads) {\n    const float PhaseDifference = radians(120.0); // 1 + 2 + 0 = 3. A key to the universe.\n    vec3 Sines = vec3(sin(AngleRads), sin(AngleRads + PhaseDifference), sin(AngleRads - PhaseDifference));   \n    vec3 Transform = 0.5 + 0.5 * Sines;\n    return Transform;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}