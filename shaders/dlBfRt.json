{
    "Shader": {
        "info": {
            "date": "1694978131",
            "description": "sdf",
            "flags": 32,
            "hasliked": 0,
            "id": "dlBfRt",
            "likes": 4,
            "name": "Cup SDF by Lurker",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "lurker",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "const int MAXSTEP = 500;\nconst float MAXDIST = 200.0;\nconst float TOL = 0.001;\nconst float PI = 3.1415;\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n\treturn triW / (triW.x + triW.y + triW.z);\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Camera matrix.\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(cameraPos - lookAtPoint); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\n\treturn mat3(cr, cu, cd);\n}\n\nstruct sdfCol\n{\n    float sdf;\n    vec4 col;\n};\n\nfloat sdSphere( in vec3 p, in float r, in vec3 offset )\n{\n    return length( p - offset ) - r;\n}\n\nfloat sdFloor( in vec3 p )\n{\n    return p.y + 3.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x, p.z);\n  return length(q)-t.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat length2( vec3 p ) { p=p*p; return sqrt(p.x+p.y+p.z); }\nfloat length2( vec2 p ) { p=p*p; return sqrt(p.x+p.y); }\n\nfloat length4( vec3 p ) { p=p*p; p=p*p; return pow(p.x+p.y+p.z, 1.0/4.0); }\nfloat length4( vec2 p ) { p=p*p; p=p*p; return pow(p.x+p.y, 1.0/4.0); }\n\nfloat length6( vec3 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y+p.z, 1.0/6.0); }\nfloat length6( vec2 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y, 1.0/6.0); }\n\nfloat length8( vec3 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y+p.z, 1.0/8.0); }\nfloat length8( vec2 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y, 1.0/8.0); }\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length4(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length4(max(d,0.0)) - 0.05;\n}\n\nfloat sdf( in vec3 p )\n{\n    float cyl1 = sdCappedCylinder( p + vec3(0.0, 0.0, 1.0), 0.5, 0.5 );\n    float cyl2 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.38, 0.4 );\n    \n    float cyl3 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.2, 0.4 );\n    float water = cyl3 + 0.02*sin(2.0*p.x + 3.0*p.y + 4.0*p.z + iTime*2.0);\n    \n    float cup = opSmoothSubtraction(cyl2, cyl1, 0.1);\n    \n    float handle = sdTorus( p + vec3(-0.5, 0.0, 1.0), vec2(0.38, 0.08) );\n    handle = opSmoothSubtraction(cyl1, handle, 0.08);\n    \n    float contents = max(water, cyl2);\n    \n    float bgfloor = sdFloor(p);\n    \n    return min(min(opSmoothUnion(cup, handle, 0.08), contents), bgfloor);\n}\n\nsdfCol sdfWithCol( in vec3 p )\n{\n    float cyl1 = sdCappedCylinder( p + vec3(0.0, 0.0, 1.0), 0.5, 0.5 );\n    float cyl2 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.38, 0.4 );\n    \n    float cyl3 = sdCappedCylinder( p + vec3(0.0, -0.1, 1.0), 0.2, 0.4 );\n    float water = cyl3 + 0.02*sin(2.0*p.x + 3.0*p.y + 4.0*p.z + iTime*2.0);\n    \n    float cup = opSmoothSubtraction(cyl2, cyl1, 0.1);\n    \n    float handle = sdTorus( p + vec3(-0.5, 0.0, 1.0), vec2(0.38, 0.08) );\n    handle = opSmoothSubtraction(cyl1, handle, 0.08);\n    \n    // three main components\n    float cuphandle = opSmoothUnion(cup, handle, 0.08);\n    float contents = max(water, cyl2);\n    float bgfloor = sdFloor(p);\n    \n    vec4 col = vec4( 0.0, 0.0, 0.0, 1.0 );\n    float curMin = 0.0;\n    // step 1\n    if (cuphandle < contents)\n    {\n        col = vec4( 1.0, 0.0, 0.0, 1.0 );\n        curMin = cuphandle;\n    }\n    else\n    {\n        col = vec4( 0.0, 0.0, 1.0, 1.0 );\n        curMin = contents;\n    }\n\n    return sdfCol( curMin, col );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    float e = 0.0005;\n    float dx = sdf(vec3( p.x + e, p.y, p.z )) - sdf(vec3( p.x - e, p.y, p.z ));\n    float dy = sdf(vec3( p.x, p.y + e, p.z )) - sdf(vec3( p.x, p.y - e, p.z ));\n    float dz = sdf(vec3( p.x, p.y, p.z + e )) - sdf(vec3( p.x, p.y, p.z - e ));\n    return normalize(vec3( dx, dy, dz ));\n}\n\nvec3 trace( in vec3 org, in vec3 dir, out bool hit )\n{\n    hit = false;\n    float totalDist = 0.0;\n    float dist = 0.0;\n    vec3 p = org;\n    for ( int step = 0; step < MAXSTEP; step++ )\n    {\n        dist = sdf( p );\n        if ( dist < TOL )\n        {\n            hit = true;\n            break;\n        }\n        \n        p += dir * dist;\n        totalDist += dist;\n        if ( totalDist > MAXDIST )\n        {\n            break;\n        }\n    }\n    \n    return p;\n}\n\nvec3 traceWithCol( in vec3 org, in vec3 dir, out bool hit, out vec4 col )\n{\n    hit = false;\n    float totalDist = 0.0;\n    sdfCol dist;\n    vec3 p = org;\n    for ( int step = 0; step < MAXSTEP; step++ )\n    {\n        sdfCol dist = sdfWithCol( p );\n        if ( dist.sdf < TOL )\n        {\n            hit = true;\n            col = dist.col;\n            break;\n        }\n        \n        p += dir * dist.sdf;\n        totalDist += dist.sdf;\n        if ( totalDist > MAXDIST )\n        {\n            col = vec4( 1.0, 0.0, 1.0, 1.0 );\n            break;\n        }\n    }\n\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 mouse = iMouse;\n    mouse.xy = (mouse.xy / iResolution.xy);\n    \n    \n    vec4 col = vec4( 0.0, 0.0, 0.0, 1.0 );\n    vec3 lightPos = vec3( 2.0, 4.0, 4.0 );\n    \n    vec3 lp = vec3( 0.0, 0.0, -1.0 );\n    vec3 ro = vec3( 1.0, 1.5, 1.0 );\n    \n    // Camera rotation with mouse\n    if ( mouse.z > 0.0 )\n    {\n        ro = vec3( 0.0, 0.0, 3.5 );\n        ro.xz = lp.xz + rotate2d(mix(-PI/2.0, PI/2.0, mouse.x)) * ro.xz;\n        ro.yz = lp.yz + rotate2d(mix(-PI/6.0, PI/2.0, mouse.y)) * ro.yz;\n    }\n    \n    \n    vec3 dir = camera( ro, lp ) * normalize( vec3( uv.xy, -1.0 ) );\n    bool hit = false;\n    float todist = 0.0;\n    // vec3 p = trace( ro, dir, hit );\n    vec3 p = traceWithCol( ro, dir, hit, col );\n    if ( hit )\n    {\n        \n        // lighting\n        vec3 lightDir = normalize( lightPos - p );\n        vec3 normal = calcNormal( p );\n        float dif = clamp( dot( normal, lightDir ), 0.2, 1.0 );\n        \n        vec3 tx = getTriplanarWeights( normal );\n        if ( col == vec4( 0.0, 0.0, 1.0, 1.0 ) )\n        {\n            // water texture\n            vec4 cx = texture( iChannel0, p.yz );\n            vec4 cy = texture( iChannel0, p.zx );\n            vec4 cz = texture( iChannel0, p.xy );\n            col = dif * (tx.x * cx + tx.y + cy + tx.z * cz);\n        }\n        else\n        {\n            // cup wood texture\n            vec4 cx = texture( iChannel1, p.yz );\n            vec4 cy = texture( iChannel1, p.zx );\n            vec4 cz = texture( iChannel1, p.xy );\n            col = dif * (tx.x * cx + tx.y + cy + tx.z * cz);\n        }\n    }\n    else\n        col = texture( iChannel2, dir );\n\n\n    fragColor = col;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Water caustics by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .3;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 p = mod(uv*TAU*1.0, TAU)-250.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.6), 0.0, 1.0);\n    \n\tfragColor = vec4(colour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}