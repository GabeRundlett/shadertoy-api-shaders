{
    "Shader": {
        "info": {
            "date": "1554082151",
            "description": "A strange noisy flower.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdjXDw",
            "likes": 22,
            "name": "Recursive Clover",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "flower",
                "zoomer",
                "loopless",
                "logspherical"
            ],
            "usePreview": 0,
            "username": "dracusa",
            "viewed": 827
        },
        "renderpass": [
            {
                "code": "/*\n\nAnother flower, possibly inspired by John Edmark's sculptures.\n\nThe code is probably inefficient and lacks documentation, but if you want to\ncheck out code and understand the log-spherical mapping that's used here, look\nat \"Recursive Lotus\" instead: https://www.shadertoy.com/view/3d2Szm\n\nChange the AA to 1 if laggy, or 3 if your graphics card can handle it!\n\n*/\n\n#define AA 2\n#define ITER 60\n#define M_PI 3.1415926535897932384626433832795\n\nfloat fov;\nfloat cam_ty;\nfloat cam_incl;\nfloat ctrl;\nfloat cam_azi;\nvec3 cam_pos;\nfloat timein = 0.;\nvec2 AAradius;\nfloat azrep = M_PI/6.;\nfloat rrep = 2.;\nfloat cam_dist = 2.25;\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Modified from https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat opUsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// From https://www.osar.fr/notes/logspherical/\nvec3 logspherical(in vec3 p)\n{\n\treturn vec3(\n\t\tlog(length(p)),\n\t\tacos(p.z / length(p)),\n\t\tatan(p.y, p.x)\n\t);\n}\n\nfloat kk(float x) {\n\treturn x>1.?x:exp(x-1.)+0.;\n}\n\nfloat sphFlower(in vec3 p, in float eradius)\n{\n\tp.y -= p.x*M_PI/5.; // azimuth transform\n\tp.y = fract(p.y/azrep+0.5*azrep)*azrep-0.5*azrep; // azimuth rep\n\tfloat unsquish = (1.+1./(M_PI-p.z));\n\tp.y /= sqrt(unsquish);\n\t\n\tp.x = fract((p.x)*rrep+0.25)/rrep-0.25; // radius rep\n\tp.z -= 1.6+0.25*eradius; // inclination transform\n\t\n\t// stem\n\tfloat ret = sdCylinder(p.xzy-vec3(-0.03,1.,0.), vec2(0.02, 1.));\n\t\n\t// rotate for petal and cap stem\n\tfloat sub = -p.z;\n\tpR(p.yz, 0.6);\n\tpR(p.xz, 0.4);\n\tret = max(ret, -p.x+0.07+sub*0.3);\n\t\n\t// petal\n\tret = opUsmin(ret, sdBox(p, vec3(-0.3, 0.04, 0.04))-0.32, 0.1);\n\treturn ret;\n\t\n}\n\nfloat sdf(in vec3 p)\n{\n    float fix = length(p+vec3(0.,0.35,0.))-0.3;\n    if (fix<0.05) fix = 10.;\n\tp *= 1. - 0.02*kk(length(p));\n\t\n\tp.xzy = logspherical(p.xzy);\n\tfloat eradius = exp(p.x-0.25);\n\tp.x -= timein;\n\t\n\tfloat sd = sphFlower(p, eradius);\n\tp.x += 0.25;\n\tsd = min(sd, sphFlower(p, eradius));\n\t\n\tsd *= eradius;\n\treturn min(sd, fix);\n}\n\nfloat iqhash(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n\tfloat rmul = iqhash(rd.x*0.1+rd.y*10.+rd.z*100.+fract(timein))*0.05;\n\tro += rd * rmul*2.;\n\tfloat tmin = 0.2;\n\tfloat tmax = 30.0;\n\t\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfloat i2;\n\t\n\tfor(int i=0; i<ITER; i++)\n\t{\n\t\ti2 = float(i);\n\t    float precis = 0.0004*t;\n\t\tvec3 pos = ro+rd*t;\n\t    vec2 res = vec2(sdf(pos), 53.);\n\t\tif(res.x<precis || t>tmax) break;\n\t\tt += res.x*(0.8+rmul);\n\t    m = res.y;\n\t}\n\n\tif( t>tmax ) {\n\t\ti2 = float(ITER);\n\t\tm=-1.0;\n\t}\n\tvec3 pt = ro+rd*t;\n\treturn vec3(t, m, i2);\n}\n\n// Adapted from https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\nvoid getray(in vec2 pos, out vec3 ro, out vec3 rd)\n{\n\t//pos = pos*-1.333+0.677;\n\tvec3 ta = vec3(0., cam_ty, 0.);\n\tro = cam_pos;\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\trd = normalize(pos.x*uu + pos.y*vv + fov*ww);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 scrpos)\n{\n\tvec3 bg = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n\tvec3 col = bg;\n\tvec3 res = castRay(ro,rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tvec3 pos = ro + t*rd;\n\n\tvec3 ipt = vec3(0.);\n\t\n\tif( m>-0.5 )\n\t{\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n\t\t// lighting        \n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 0.40*amb*vec3(0.40,0.60,1.00);\n\t\tlin += 0.50*bac*vec3(0.25,0.25,0.25);\n\t\tlin += 0.25*fre*vec3(1.00,1.00,1.00);\n\t\tcol = col*lin;\n\t}\n\n\tfloat fogf = pos.y<0. ? -(pos.y * pos.y * 3.): 0.;\n\tcol = mix( col, bg, 1.0-exp( -0.006*t*t + fogf) );\n\t\n\tvec3 inice = vec3(res.z/float(ITER));\n\tinice *= inice;\n\tinice = mix( inice, vec3(1.), 1.0-exp( -0.0002*t*t*t ) );\n\tcol = col*(inice)*1.2 + bg*(inice)*0.4;\n\n\t//return inice;\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n// From https://iquilezles.org/articles/functions\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(\n\t\tgain(v.x, k),\n\t\tgain(v.y, k),\n\t\tgain(v.z, k)\n\t);\n}\n\nvec3 pillow(in vec3 col, in vec2 uv)\n{\n\tuv -= 0.5;\n\tfloat mpow = 5.;\n\tfloat d = pow(pow(abs(uv.x),mpow)+pow(abs(uv.y),mpow),1./mpow);\n\td = smoothstep(0., 1., d*2.-0.64);\n\treturn mix(col, vec3(0.), d);\n}\n\n// Based on https://iquilezles.org/articles/raymarchingdf\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\ttimein = iTime*0.08*1.8+4.;\n\tctrl = iTime*0.1+0.1;\n\n\tfloat t2 = ctrl * M_PI + 0.3;\n\tvec3 shot1 = vec3(0.75, -0.7, cos(t2)*0.3+1.1);\n\tvec3 shot2 = vec3(0.75, -0.7, cos(t2)*0.25+2.4);\n\tvec3 shot3 = vec3(cos(t2)*0.392+0.952, -3.0, 0.1);\n\tvec3 shot = shot3;\n\tif (mod(ctrl, 3.) <= 2.) shot = shot2;\n\tif (mod(ctrl, 3.) <= 1.) shot = shot1;\n\tfov = shot.x;\n\tcam_ty = shot.y;\n\tcam_incl = shot.z;\n\n\n\tcam_azi = M_PI * timein / (1.5 * 5.) + 0.12;\n\tcam_pos = vec3(\n\t\tcam_dist*sin(cam_incl)*cos(cam_azi), \n\t\tcam_dist*cos(cam_incl),\n\t\tcam_dist*sin(cam_incl)*sin(cam_azi) );\n\n\tAAradius  = vec2(1.) / iResolution.xy;\n\tvec3 tot = vec3(0.);\n\n\t// centered ratio-corrected UV\n\tvec2 cUV = uv-vec2(0.5);\n\tcUV.x *= iResolution.x/iResolution.y;\n\t\n\t#if AA > 1\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{    \t\n\t\t// pixel coordinates\n\t\tvec2 ofs = AAradius*(vec2(float(m),float(n)) / float(AA) - 0.5);\n\t\tvec2 pos = cUV+ofs;\n\t#else    \n\t\tvec2 pos = cUV;\n\t#endif\n\t\tvec3 ro, rd;\n\t\tgetray(pos, ro, rd);\n\t\t\n\t\tvec3 col = render(ro, rd, pos);\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\ttot = pow(tot, vec3(0.4545));\n\ttot = gain(tot, 1.5);\n\ttot = pillow(tot, uv);\n\ttot *= 1.-pow(cos(ctrl*M_PI*2.)*0.5+0.5, 200.);\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}