{
    "Shader": {
        "info": {
            "date": "1588779076",
            "description": "#define NOISE :  0: base Perlin  1: flamme 2: blobs\nUncomment line 40 for spirals\nNB: could use narrower rings (smooth(3)), but here it manage the donuts borders smoothing as well. ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "Wslfzf",
            "likes": 9,
            "name": "polar Perlin noise",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "perlin",
                "polar",
                "anisotropy",
                "short",
                "cyclical"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 625
        },
        "renderpass": [
            {
                "code": "#define NOISE 0     // 0: base Perlin  1: flamme 2: blobs\n\n#define hash(p) (2.*fract(sin(mod(.5+p,C)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)-1.)\n\n// --- cyclical base Perlin in [-1,1] \nfloat noise(vec2 U, vec2 C) {\n    vec2 I = floor(U),\n         F = fract(U), \n         S = F*F*(3. - 2.*F),\n#define H(x,y)  dot( hash(I+vec2(x,y)) , F-vec2(x,y) )   \n         V = mix(vec2(H(0,0),H(0,1)),vec2(H(1,0),H(1,1)),S.xx);\n    return mix(V.x,V.y,S.y);\n}\n\n// --- Perlin modulator \nfloat noiseT(vec2 U, vec2 C) {\n    return   NOISE == 0 ?       noise(U,C)             // bozo ( pass-through )\n           : NOISE == 1 ? 1./3. - abs(noise(U,C))      // flamme\n           :              abs(noise(U,C)) - 1./5.;     // blobs\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) /R.y,\n         P = vec2( 6.*atan(U.y,U.x)/6.283, length(U)); // polar coords\n    float l = P.y,\n          S = 1., s = 60.,                      // noise scaling, aspect ratio\n          v = 0.,w;\n#if 0                                           // --- tests    \n  //v = noise(10.*U,vec2(10));                  //  cartesian noise\n  //v = noise(10.*P,vec2(10));                  //  brute polar noise\n  //v = noise(10.*P*vec2(P.y,1),vec2(10));      // naive perimetric param 1\n  //v = noise(P*vec2(floor(10.*P.y),10),vec2(10));   // naive perimetric param 2\n#else                                           // --- the true thing\n    float T, t = 3.*iTime; // 20.*iMouse.y/R.y; // --- tune aspect \n    t = mod(floor(t),20.); t = min(t,20.-t);\n    S=5.,s=10.; T = exp2(.5*(t-5.)); S = ceil(S*sqrt(T)), s /= T;\n\n  //P *= mat2(cos(.5+vec4(0,11,33,0)));         // spiral\n  //float r = 5.;                               // to test one single ring\n    for (float r=5.; r<15.; r++) {              // --- combine rings with adapted scaling\n        w = smoothstep(3.,0.,abs(10.*l-r));     // smooth rings\n        if (w>0.)  //   ...  ring coords   ...   seed     ...    cycling ... ring mask\n            v += noiseT( P*S/6.*vec2(r,s) -r*vec2(117,119), vec2(r*S,1024) ) * w ;\n         // R =  sin(6.28*P*S/6.*vec2(r,s)) , v+= R.x*R.y * w; // test grid\n    }\n#endif \n    O = vec4(.5+.5*v); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}