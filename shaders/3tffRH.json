{
    "Shader": {
        "info": {
            "date": "1595936584",
            "description": "in 2d view:\ndrag dots, klick to add dot. drag to lower left to erase.\n\nin 3d view:\nESDF+mouse to move\nT pauses time\nG freezes mouse input for other modes\n\nparent:    https://www.shadertoy.com/view/WtfBRH\ngrandparent: https://www.shadertoy.com/view/Wt2yDV\n",
            "flags": 48,
            "hasliked": 0,
            "id": "3tffRH",
            "likes": 2,
            "name": "ReTrAdUi amalgations6 ad37",
            "published": 3,
            "tags": [
                "gradient",
                "csg",
                "ik",
                "derivative",
                "ui",
                "trace",
                "ad",
                "automaticdifferentiation",
                "superprim",
                "bayeeps",
                "barycentricfrustumcull"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "/*\nReTrAdUi\n=[Re]Relativistic Epsilon          (buffC relativisic marcher with performance optimizations)\n,[Tr]Temporal     Reprojection     (buffD is still on its own)\n,[Ad]Automatic    Differentiation  (BuffB hopefully 3 derivatives in 4d)\n,[Ui]User         Interface        (BuffA drag and drop)\n\nthis amalgation is a bit messy, it can only go uphill from here.\nthe CommonTab has toggles between 3 scenes; Temporal Reprojection, Automatic Differentiation, and a 2d UI-focused Scene.\nbelow test is mostly about the [automatic differentiation] scene\nthe Image-MainImage function on the bottom here toggles between Re7 (relativityEngine) and all else.\nThe goal here is to unify concepts of 4 other shaders, where ever that makes sense and evades conflicts.\n*/\n\n/*\nin 3d space \n- keys [ESDF] moves camera\n- Mouse drag rotates camera (while not in edit mode)\n\n- key [t] toggles pausedTime                (camera unaffected)\n- key [g] toggles editMode (and halts Time) (mouse drag no longer rotates camera)\n\n\n\n*/\n\n//bayemode =0 has a period of 1 second //good to visualize the effect \n//bayemode =1 has a period of 1 frame, but may flicker way too much\n//bayemode =2 has a period of 1 frame, averages 7 averages of iTimeDelta (over intervals up to 1,2,4,8,1632,64,128)\n//bayemode =2 is extra slow for loading 2 fragments values of another buffer\n//bayemode =2 sucks for being way too slow without fragmentshader providing the values\n//bayemode =1 sucks while the player gives any inputs (second intgerval lags)\n//bayemode =0 sucks for maybe flickering like crazy \n#define BayeMode 2\n\n//but it should automatically adjust nicely to most resolutions (up to 1900x1000 px)\n//to maintain the same framerate at any resolution, it will automatically adjust the LoD\n//(LoD for now just the epsilon of the raymarrching)\n//BUT it does NOT predict the processing power of your gpu well\n//and that needs to be manually scaled to that by a divisor:\n\n//if you have a modern graphic card with like 6 GB vram (like geforce 1660)\n//these values are for a 1900x1000ish resolutuion) (nd smaller cones scale pretty well)\n//#define FPStarget pow(30./7.,1.68)  //60 fps\n\n//#define FPStarget (60.*3.)    //60 fps\n//#define FPStarget (50.*3.)    //50 fps\n//#define FPStarget (40.*3.)    //40 fps\n#define FPStarget (30.*3.)    //30 fps\n//#define FPStarget (20.*3.)    //20 fps\n//#define FPStarget (15.*3.)    //15 fps\n\n//#define FPStarget (1./500.)    //testing the [mie] limits for minimum epsilon\n\n//if you have an older graphic card with like 2 GB vram (geforce 0960)\n//chose any of the below, firstvalue is the fps you want (disregarding any LoD)\n\n//this one is old, the pow is likely not needed\n//you likely only change the divisor of /5.\n//#define FPStarget pow(60.,1.68) //60 fps\n//#define FPStarget pow(50.,1.68) //50 fps\n//#define FPStarget pow(40.,1.68) //40 fps\n//#define FPStarget pow(30.,1.68) //30 fps\n//#define FPStarget pow(20.,1.68) //20 fps //this integer fraction of 60 seems fine\n//#define FPStarget pow(10.,1.68) //10 fps\n//#define FPStarget pow(5.,1.68)\n\n//error to fix: a very small epsilon (hight LoD) results in noisy black dots\n//its a rough estimate, wobbly, more noticable while rotating the camera \n// on larger resolutions with lower fps\n//i did not even doisplay the fps result, and only did \"by feel\"\n\n\nvec4 Get(float a,sampler2D b\n){return texture(b,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\nvec4 Get(float a){return Get(a,iRe);}\n//return texture(iRe,vec2(varWdth*.5+a*varWdth,.2)/iResolution.xy);}\n\n/* \ndrag dots to see effect of dotPosition.xy\nclick screenspace-void to add a dot (dot params overwrite (animated) default parames)\nerase dots by moving them into the red square\n- Erasing a dot that is not the last dot may cause confusion (no LinkedList structure)\n-, because dots will stay in place, but their indexes may decrease by -1\n- , and the effect of a dot is set by its index, with parameters from its position. \n\ntodo: if(dot gets ersed) properrly rearrange dot indizies)\n\ndot[0] is left dot, sets camera position|angle marameters (naive dumb camera matrix)\ndot[1] is top Left, sets object0 scale.xy\ndot[2] is bottom  , sets object0 scale.z and hole-parameter.y  (klick to add dot)\ndot[3] sets object0 2 roundness parameters (torus/lathe like)\ndot[4] sets object1 scale.xy\ndot[5] sets object1 scale.z and hole-parameter.y  (klick to add dot)\ndot[6] sets object1 2 roundness parameters (torus/lathe like)\ndot[6] sets object1 offset.xy\ndot[7] sets object1 offset.z and a UnionRoundness\n\nSurface normals are analytic [automatic differentiation] \nfirst derivatives over 3 domains, faster and more precise (near sharp corners)\nDebugging of [AD] just needs a merger with [UI], so here it is:\nan easly release of an incomplete merger of [AD26] with [AD33]\n\n- - tags:\n- 4 tabs are 4 plugins, with a shared commonTab library.\n\nAD,UI,IK,superprim,CSGsuperprim,calculus,filter,gradient,derivative,automaticdifferentiation\nsuperprim,uberprim\nUI,diegetic,mouse,parametric,ui,widget,draganddrop,spartial,canvas\nAD,calculus,filter,partialDerivative,TotalDerivative,normal,curvature,laplache\nIK,parabola,bezier,root,projection,\nCA,arclength,calligraphy,sweepAmt,EliteBeatAgents,OsuTatakaeOuendan\nRE,RelativityEngine,TargetFps\nTR,TemporalReprojection\n\n/WtfGDM screenshots:\nhttps://twitter.com/ollj/status/1123090411814379520\n\nself UI2TARD38: https://www.shadertoy.com/view/3l2GDR (amalgations2)\nparent UI2AD37: https://www.shadertoy.com/view/3tSGDz (slow progress)\nparent UI2AD36: https://www.shadertoy.com/view/ttfGRB (skippable)\nparent UI2AD35: https://www.shadertoy.com/view/WtfGRS (milestone)\nparent UI2AD26: https://www.shadertoy.com/view/WtfGDM (4d 3rd derivatives & dragAndDropUi)\nparent    AD33: https://www.shadertoy.com/view/ttX3D8 (1d 3rd derivatives)\nparent    AD26: https://www.shadertoy.com/view/WtXGW4 (3d 1st derivatives)\nparent UI1    : https://www.shadertoy.com/view/Xt3BzX (dragAndDropUi)\nparent UI0    : https://www.shadertoy.com/view/4dtSRn (dragAndDropUi origin)\n\nThe image tab only cares to explain the final composition\nand on very abstract descriptions of the amalgation:\n\nThis is an amalgation of multiple plugins.\nWhos (shared) components mix mostly into the CommonTab\nand into some (remote) compositing/debugging calls from the imageTab.\nJust like a [frankensteins monster] has only one brain and one heart.\n\nEach plugin has its own family tree history and context/tags\nBut these often overlap a lot.\ntherefore all of that is moved to the CommonTab, over time.\n*/\n\n\n//tags:\n//lod,blackhole,redshift,relativity,compatibility,dilation,bayesian,simultaneouity,bayeEp\n/*\nself    RE7 : https://www.shadertoy.com/view/tlf3zj\nparent0 RE6 : https://www.shadertoy.com/view/WtfGRj\nparent1 RE5?: https://www.shadertoy.com/view/tdfXDl\n/**/\n//todo, hide thes BaeysTheorem-oscillations in \n//- temporal reprojection\n//- a screenspace noisy-offset of parameters (uv stays unaffected)\n//- - 16x16BayerMatrix should be good enoug here\n//- all of the above\n//- a lower  FPStarget causes lessfps and better images\n//- a higher FPStarget causes higher and worse images\n//enter target fps as base below, and see it oscillate till it hopefully approaches the target fps\n//its a kind of magic of the logn() core function:\n//testing sclaing of resolutions is hard. the fps dispolay is a big overheat\n//, that tends to cost -5% of the fps.\n//the fun part, FPStarget is INDEPENDENT from the parameter below\n#define maxStepRayMarching 2000\n// within maxStepRayMarching[50..200], which mostly depends on the average scene curvature\n//which is hard to estimate becuase it has a black hole inside of it!!!\n//thats right, you enter 200 maxSteps, and   FPStarget pow(40.,1.68), and iut will reach 40 fps!\n//\"as you wish milord\"\n//initially FPStarget mapped to a targetFPS one to one (esponent was initially close to 1), \n//so yo you could enter what fps you wanted, and it would almost reach it.\n//but the more complex this gets, the worse your scales and estimates become\n//andd the overhead accumulates, and has problems to estimate its own cost.\n//currently the overhead is roughly an exponent of 1.6 to 1.7 ?\n//nonetheless, all the DIRECTIONS of the interpolations and bijections are correct\n//and with that exponent, you can enter the target fos as basis\n//it is optimized for the 500px-wide preview, may not scale too well to larger resolutions\n//i tried, this is VERY twittly.\n//this really needs BoundingVolumes, so that not all viewing angles have roughly the same complexity!!!\n//so yeah, if there ever was a shader that needed lobeps added to it...\n//but fitst let me fix compatibility iassues of this shader...\n/*\ncore idea here is, you set a target fps, and the renderer tries to just reach that FPS count.\nit may increase epsilon, if it was overperforming previously (fps was above FPStarget)\nit may decrease epsilon, if it was underperforming previously (fps was below FPStarget)\nstill, there exists a clamp() to the epsilon values\n, and a lot of of smoothened interpolation ramps and logarythms.\n, because an extreley huge epsilon makes little sense in 60fps\n, because an extremely tiny epsilon makes little sense, just to stay at a lower FPStarget\nThis begs for a better [BayesTheorem over time], but i have yet to implkement the necessary state for that.\nit does not just do this for epsilon, but also for [ReciprocalLipschitz]\n, ==[the amount you understep by]\n, ==[the interval of your volumeMarching]\nIt has a bias in vafor of the ScreenCenter \n- smaller reciprocalLipschitz near screencenter than near screen corner\n- smaller epsilon near screencenter than near screen corner\n- - the epsolon oscillations in a 1 second interval are more noticable near screen corners\n- - damnit this is inverse fovea!\nthis might be much more useful in a set with\n- Proper (axis aligned)BoundingVolume(hierarchy), may be great with fractals with simple escapeTime conditions\n- very different sceneries, a long beach horiton and a small simple box.\n- logatythmic epsilon marching\n- SoC marching\nnegative side effect;\n- it goes into the right directions, but it fails to estimate any half decent taylor series, and therfore misses the target a lot\n- , unles you add more exponents to twiddle with.\n- in too high resolutions (or at 15 or 30fps) , It may heavily oscillate between 2-4 states where it keeps being [too fast] , [too slow]\n- without proper [bayes theorem over time with buffer states] i fail to twiddle parameters to work with multiple resolutions/settings.\nbut so far the proof of concept holds up for this set, and it kinda works\n,while in     512.*384. px resolution\nmost of its magic comes from its bijective subroutine: (r2l2Ws(logn()))\n\n2020-08-02, i finally implemented the averaging over 8 averages of iTimeDelta\neach of them accumulates the incremental averave over the (up to) \nmost recent 1,2,4,8,16,32,64,128 frames, and the (non weighted) average of that\nis a pretty smooth alternative to just feedign iTimedelta or iFrameRate/60.\n*/\n\n//[from 0 to zFar or 1./zFar and within]\n//i got bored of infinity and infinitessimals and with the assertion of [infinity=zFar] you get [infinitessimal=1/zfar]\n//now, if only we could translate these 2 ratios into one single linear scale, //this has great potential in improving spheretracking logeps():\n//we use logn():\n//logN(x) to logE(x)=log(x) (conversion by division), log(n) is a log() in any EXPLICIT base \nfloat logn(float base,float x){return log(x)/log(base);}//log2(x)/log2(base) has any utility? possibly slower or less precise or both, just test it!\n//as long as base=zFar is constant, we only do 1 runtime log() here; else use a LookUpTable of a list of log([zfar0,zFar2,zFar2...]) as divisor\n//nope, i did not gain anything too useful from sucstituting for log2(x)/log2(bae), so far, i tried here, its just not pretty.\n//4 functions below convert bijectively between a 2d-Ratio [from infinitessimal to infinity] and a 1d-linear scale [from  0 to 1]\n//its top 2/4 are subroutines of its bottom 2/4 (with different InOut scaling)\n//[b] is a [bijective constant] that is [uniform within its context] (to uphold a bijection in 2 directions)\n//here: b=zFar>0  (or our lookup table of zFar values)\n//b can be large, because b is always wrapped within log(b) these functions are fast and precise 1x pow() is its slowest\nfloat l2r2(float a,float b){return pow(b,a)/b;}                  //[  0..2] <= [1/b..b] //read this like F# syntax\nfloat r2l2Ws(float a,float b){return logn(b,clamp(a,1./b,b)*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nfloat l2r(float a,float b){return l2r2(a*2.,b);}          //a[  0..1] <= a[1/b..b]\nfloat r2l(float a,float b){return r2l2Ws(a,b)/2.;}        //a[1/b..b] <= a[  0..1]\n//just like carthesian2polar()&&polar2carthesian() (BUT it deals with [zFar and 1/zFar] instead)\n//, you may apply the above bijection to the gratient and bake both into a faster/specific (sub) form, that somehow incooperates 1/x\n//bayesEps concept\n//use BayesTheorem to adjust epsilon over time, to reach a target FPS\n//if you look along the horizon, expect epxsilon to increase, to maintain fps\n//if you look into a small box, expect epsilon to derase, for more precision\n//input current epsilon and TATGET fps\n//return an epsilon, in hopes to adjust epsilon, to get [[f] fps] with the next frames.\n\nfloat getEpsToFps(float e,float f   //f>0.\n){//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.5\n //.75 is a pretty high max epsilon, but its the easiest way to get performance\n //, especially further away from the camera or behind an occuder or near a black hole\n ;//mie=.00085*.8 has many dots in the spinning fractal balls on lightspeed=2.1 \n //when between blackhole of 2 and balls\n ;mie=.0009 //.00085 is ALMOST artefact free mie with recLipschitz==1.\n            //mie=.0009 is artefact free\n            //mie<.00085 makes the blackh hole looks smoother, but distant flat walls look worse.\n ;float i=pow(iResolution.x/512.,2.5)\n #if BayeMode==2\n  //changes loD every frame, smoothly, but does +7 divisions per frame\n  ;vec4 reTime=Get(ReTime);//vec3 reTimE=Get(ReTimE).xyz//7 invremental averages\n  ;float a=suv(reTime)/4.  // divide by 4 to average 4\n  ;//float a=(suv(reTime)+suv(reTimE))/7.//average of 7 invremental averages (of different lengths)\n  ;//do NOT include iTimedelta into the above average, this just causes 1frape flickers\n  ;//im not sure if i even want the averaged 2 frames long flicker of reTime.x\n  ;i*=a/8.  //somehow a /8 modifier is needed //very smooth\n #elif BayeMode==1   \n  ;i*=iTimeDelta//changes LoD every frame, cheapest, very flickery\n #else\n  ;i/=iFrameRate//changes LoD every 60 seconds, cheap \n #endif\n ;i=i*FPStarget*6e3/(iResolution.x*iResolution.y) //6000=800*450/60\n ;e=r2l(i,6.)\n ;e=e//pow(e,2.)//sqrt(e)\n ;//e=log(e)\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae)\n ;//it seems i need a good sigmoid function here, maybe even hust atan1()\n ;return e\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not twiddle-account for many unknowns, without BayesTheorem.\n//the rotating fractal is evil here, because smaller epsilon result in BETTER lipschitz continuty AND better performance\n//so, some shapes are exceptions to general rules of optimitation-flow, with a shitty local extrema!\n//a minor drawbeck to the overall greatness of Naesian methods in sphertrackers.\n//or maybe just a bug to be fixed.\n\n//the fun of the above is, worst case is that it oscilates a bit\n//now, we can have 2 parameters independently modified in this way\n//both likely oscillate differently, and not the same (which woulc link them inapropriattrly)\n//so, lets also modify reciprocalLipschitz just like that:\n/**/\nfloat getReLipschitzToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.8//just do not make  mae>1., unless you are in logeps() marching territory.\n ;mie=.3 //mie<.3 has bad black lines in concave 90def corners\n ;//mie>.6 is already too large, for shapes\n ;//, that move with [half the speed of light][near a black hole]\n ;//- yes, these are my quality merasures for lipschitz continuity by now.\n ;//- once you have logeps()-marched a double [tensor] with lipschitz>5 \n ;//- with no continuity or performance problems\n ;//- , you kinda run out of challenges.\n ;float N=6.\n ;float i=pow(iResolution.x/512.,2.5)\n #if BayeMode ==1   \n  ;float tt=pow(FPStarget,1./1.68)\n  ;tt=pow(tt*300./40.,1.68)\n  ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n  ;i*=tt/60.\n #else\n  ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n  ;i*=FPStarget/60.\n #endif     \n ;i=clamp(i,1./N,N)//worksave bound\n ;e=r2l(i,N)\n ;//a 1/N ratio maps to 0\n ;//a 1/1 ratio maps to 1\n ;//a N/1 ratio maps to 2 , so, this transforms a ratio into something to mix with:\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae);\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\n\n\nfloat sscocS=32.;//how better near screencenter than near screenborders\n\nfloat getReLipschitzToFps(){return getReLipschitzToFps(.25,FPStarget);}\n//our baseline is still a targetPFS\n//#define dd(a) dot(a,a)\n//now, lets make it better near the screen center\n//lets weight them over how oval-distant they are to screenspace center\n//of course the oval is scaled by sqrt(2) and is a smoothstep and all the good stuf\n\nfloat getEpsToFps(float sscoc//here it makes sense, i suppose\n){sscoc=mix(FPStarget/sscocS,FPStarget*sscocS,sscoc)//larger epsilon neart screenspace borders, smaller near center\n  ;return getEpsToFps(.001,sscoc);}\n\nfloat getReLipschitzToFps(float sscoc){//return 1.\n   ;sscoc=mix(FPStarget/sscocS,FPStarget,sscoc)//lefr value near corner, right value near center\n   ;return getReLipschitzToFps(.25,FPStarget);}\n#define reciprocalLipschitz getReLipschitzToFps()\n\nvoid drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.\n){v0 f=0.\n ;for(v0 i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;f=dd(u-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}\n ;}\n\n//ESSENTIAL instant feedback: highlight what is dragged\nvec4 dotColor(vec4 s,v0 r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))//highlight last klicked/dragged\n ;return vec4(.5,.5,1,1);}//all other dots\n\nvec4 iDiegeticUIshow(vec2 u){\n ;vec4 c=vec4(0),s=bufDrag(statePos)\n ;vec2 e=vec2(0.,UiDotRadius+UiDotBorder)\n //e.x is the inner bound of a dot's black border\n //e.y is the outer bound of a dot's black border \n ;drawDragDots(s,u,e)\n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(u,deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n/*\ntags:\nbezier,quadratic,parabola,\n\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bÃ©zier-curves\nis tricky but usseful\n*/\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n//#define viewzoom  (1./(cos(iTime)*.5+.75))\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n\n//#define sat(a) clamp(a,0.,1.)\n\n\n//bool rea(v0 s,v0 b,v0 e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n\n\n//#define Aa min(iResolution.x,iResolution.y)\n\nv1 sort(v1 a){return v1(min(a.x,a.y),max(a.x,a.y));}\n\n\n//the old version of this was not ALL bad\n//it may be revivable, IF merged with \n//equicenter of : https://www.shadertoy.com/view/tlKcDz\n//IFF you do not need zFar.\n//and when points are swapped in some cases, to fold many cases.\n\n\n//barycentric triangle tracing speedup\n//+1 float division +1 float sqrt to  calculate what segments are being intersected.\n//of ray and triangle\n//the division only needs to be done once, every time RayTarget changed.\n//getPosSmallV() getPosLargeV() is a lot of min()max() branching tree though.\n//generates pseudo-bvec2 that stores what of the 2 segments are intersected.\n//then +1 sqrt and +1 div foreach segment , can be times (0,1 or 2)\nvec4 baryTriangleOldSemiObsolete(float t,vec2 u,vec3 r,vec4 m,vec2 p3,vec2 p4,vec2 p0,vec2 p1,vec2 p2,vec4 c){\n ;float h=line(u,p0,p1)-.01\n ;h=min(h,line(u,p1,p2)-.01)\n ;h=min(h,line(u,p2,p0)-.01)\n ;c.w=min(h,ray(u,p3,p4)-.01) //draw ray and triangle\n ;c.x=h\n ;c.z=sdTriangle(p0,p1,p2,u)-.04\n ;float carthesianDet=c2bdet(p0,p1,p2)//+1 div (preferred)\n ;vec3 uu=c2b(u,p0,p1,p2,carthesianDet)//+0 div foreach each c2b() with carthesianDet\n ;vec3 ssu=sat(sign(uu))\n ;float uus=suv(ssu)\n ;//return vec4(ssu,1.)\n ;mat3 n=mat3(p0,0,p1,0,p2,0)\n ;float ddd=0.\n ;float gpl=float(getPosLarge(ssu))\n\n ;vec3 oo=c2b(p3,p0,p1,p2,carthesianDet)\n ;vec3 tt=c2b(p4,p0,p1,p2,carthesianDet) //ray points transformed from carthesian to barycentric\n ;vec3 vs=oo-tt \n ;vec3 l=vec3(dd(p1-p2),dd(p2-p0),dd(p0-p1))//squared side length\n ;float radius=dd(lengthBary(oo-tt,l))//vector (oo-tt) length*length from barycentric vector\n //;vec3 vv=c2b(p4-p3,p0,p1,p2)\n ;float center=sqrt(lengthBary(oo-uu,l))//vector (oo-uu) length from barycentric vector\n ;c.w=min(c.w,abs(center-radius))//;c.w=min(c.w,abs(length(u-p3)-radius))\n //;c.w=min(h,ray(u,p3,p4)-.01)\n ;vec3 os=sat(floor(oo+1.))\n ;vec3 ts=sat(floor(tt+1.))//sat is needed for scale (large distances to the triangle are cheap)\n ;float ooo=suv(os)\n ;float ttt=suv(ts)//sum of vector components now points at 7 different segments:\n     //1* insideTriangle\n     //3* largeBorderTile(adjacent) \n     //3* cornerBorder   (only touches triangle corners) \n ;vec3 linesToCheck=vec3(0)\n ;if(ooo==2.//case 2: origin is in largeBorderTile\n ){if(ttt<2.&&os!=1.-ts)linesToCheck=vec3(0)\n  ;else{linesToCheck=getPosSmallV(os)//this one is simple, either misses all, or hits only one.\n      //nope nope nope,(vs) doesnt ALWAYS work HERE: \n      //but sure, there are other ways to do this, removed for now\n ;}}else if(ooo==1.){//case 1: origin is in cornerBorder\n  ;if(ttt<2.&&os!=ts)linesToCheck=vec3(0)//only the other 2 outer corners miss the triangle\n  ;else if(ttt==2.&&os!=1.-ts)linesToCheck=getPosSmallV(ts)//from cornerBorder to ADJACENT largeBorderTile, has 1 border\n      ;else{linesToCheck=1.-getPosLargeV(os);\n      ;if(1.-getPosLargeV(vs)!=linesToCheck)linesToCheck=vec3(0.)\n ;}}else //if(os==vec3(1) )//case 0: origin is in insideTriangle\n  {if(ttt==2.)linesToCheck=getPosSmallV(ts) //target is in any largeBorderTile /single border)\n  ;else linesToCheck=1.-getPosSmallV(vs)\n ;}  \n ;if(linesToCheck.x>0.)c.y=min(c.y,segment(u,p1,p2)-.04)//indicating segments that are hit.\n ;if(linesToCheck.y>0.)c.y=min(c.y,segment(u,p2,p0)-.04)//indicating segments that are hit.\n ;if(linesToCheck.z>0.)c.y=min(c.y,segment(u,p1,p0)-.04)//indicating segments that are hit.\n\n //the faces that are still in may only return the NEAR intersection.\n //there is no case where there is a far intersection, the firt positive intersection can be returned as nearest.\n //i have not implemented a function that takes (linesToCheck), to trace this triangle/prism.   \n //on tracing a triangle/prism efficiently.\n //triangles imply barycentric coordinates, converters exist, but they are not too fast, and should be avoided.\n //just start in barycentric coordinates\n     //how about one moore domain, doing a 3d simplex (skewable triangle pyramid)\n\n //below code is from its canvas source function\n //;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs \n ;//m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;//c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=9./Aa(t,u,r,m) //line thickness\n ;c.xw-=2./Aa(t,u,r,m) \n ;c.y -=4./Aa(t,u,r,m)\n ;return c;}\n\n//rotation of multiple inputs of same type for tpyes; vec4,vec3,vec2,float\n//rotate2by1(a,b) is a tripple swap\n#define rot2by1D(D) void rotate2by1(inout D a,inout D b){D s=a;a=b;b=s;}\n#define rot3by1D(D) void rotate3by1(inout D a,inout D b,inout D c){D s=a;a=b;b=c;c=s;}\n#define rot6by1D(D) void rotate6by1(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){D s=a;a=b;b=c;c=d;d=e;e=f;f=s;}\n#define rot4by2D(D) void rotate4by2(inout D a,inout D b,inout D c,inout D d                    ){rotate2by1(a,c  );rotate2by1(b,d  );}\n#define rot6by2D(D) void rotate6by2(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){rotate3by1(a,c,e);rotate3by1(b,d,f);}\n#define rot6by3D(D) void rotate6by3(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){rotate2by1(a,d);rotate2by1(b,e);rotate2by1(c,f);}\n#define rotND(a) a(v0)a(v1)a(v2)a(v3)\nrotND(rot2by1D)rotND(rot3by1D)rotND(rot6by1D)\nrotND(rot4by2D)rotND(rot6by2D)\nrotND(rot6by3D) \n\n#define hxl0(a,b) z=gLLxXP(a,b,o,t);if(sat(z)==z)return a-(a-b)*z\n#define hxl1(a,b) return a-(a-b)*gLLxXP(a,b,o,t)\n#define hxl2(a,b,c) float hxl0(a,b);hxl1(b,c)\n#define hxl3(a,b,c,d) float hxl0(a,b);hxl0(b,c);hxl1(d,c)\n    \nvec2 hxL1(vec3 a,vec3 b,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y)\n ,b.xy=b2c(b,X,Y)\n ;return a.xy-(a.xy-b.xy)*gLLxXP(a.xy,b.xy,o,t);}\n\nvec2 hxL2(vec3 a,vec3 b,vec3 c,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y),b.xy=b2c(b,X,Y)\n ;a.z=gLLxXP(a.xy,b.xy,o,t)\n ;if(sat(a.z)==a.z)return a.xy-(a.xy-b.xy)*a.z\n ;c.xy=b2c(c,X,Y)\n ;return b.xy-(b.xy-c.xy)*gLLxXP(b.xy,c.xy,o,t);}\n\nvec2 hxL3(vec3 a,vec3 b,vec3 c,vec3 d,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y),b.xy=b2c(b,X,Y)\n ;a.z=gLLxXP(a.xy,b.xy,o,t)\n ;if(sat(a.z)==a.z)return a.xy-(a.xy-b.xy)*a.z\n ;c.xy=b2c(c,X,Y)\n ;a.z=gLLxXP(b.xy,c.xy,o,t)\n ;if(sat(a.z)==a.z)return b.xy-(b.xy-c.xy)*a.z\n ;d.xy=b2c(d,X,Y)\n ;return c.xy-(c.xy-d.xy)*gLLxXP(c.xy,d.xy,o,t);}\n\n//X,Y set triangle of barycentric\n//all other params are in barycentric coords\n//origin,target,6CornersOfHex\nvec3  traceHexBaryInside(vec3 uu,vec3 oo,vec3 tt,vec3 b1,vec3 b2,vec3 b3,vec3 b4,vec3 b5,vec3 b6,vec3 X,vec3 Y\n){vec2 o=b2c(oo,X,Y)\n ;vec2 t=b2c(tt,X,Y)\n ;vec2 p1=b2c(b1,X,Y)\n ;//vec2 p2=b2c(b2,X,Y)\n ;vec2 p3=b2c(b3,X,Y)\n ;vec2 p4=b2c(b4,X,Y)\n ;vec2 p5=b2c(b5,X,Y)\n ;vec2 p6=b2c(b6,X,Y)\n ;//return sat(floor(uu+1.)) //main triangle is white\n ;//r ia a vec4 with 1 of each color set to >0 foreach linesegment to test\n ;vec4 r=vec4(0)\n ;//uu=tt //for debug mode toggle\n //barycentric culling hell\n ;//if(uu.y<uu.z)uu.yz=uu.zy //mirror\n     \n ;if(\n     getPosSmall(floor(oo-tt))==2\n     //sign(oo.x)==sign(tt.x)\n    \n    )uu.yz=uu.zy\n ;if(uu.x<0.)r.x=1.\n ;if(uu.z>0.)r.x=1.\n ;if(uu.z<=0.&&uu.x<=1.)r.y=1.//right shade\n ;if(uu.x>0.){ \n  ;if(uu.x<1.)r.y=1.//horizontal\n  ;if(uu.y>1.)r.y=1.//right shade\n  ;if(uu.y>0.&&uu.y<1.)r.z=1.\n  ;if(uu.y<0.)r.w=1.\n  ;if(uu.z>uu.y-1.&&uu.z<uu.y+1.)r.w=1.\n  ;if(uu.x>1.&&uu.z<uu.y-1.)r.z=1.\n ;} \n ;return 1.-r.xyz //debug output a\n ;//return r.yzw //debug output a\n  ;//r=r.wxyz\n  ;float s=suv(r)     \n\n           /*\n  ;if(s==4.//if in main triangle, we have this small exclusion method\n \n  ){vec3 vs=getPos0V(floor(tt-oo))\n   ;//return vs\n       //.x points up   OR to the bottom corner\n       //.y boints side\n       //.z points down\n    //;r=vec4(0,0,0,1)\n    //;return hxL2(b3,b4,b5,o,t,X,Y).xyy\n    /*\n    ;if(vs.x==1.){\n        ;//return hxL3(b3,b4,b5,b6,o,t,X,Y).xyy\n        ;                    r=vec4(1,1,0,0)\n        ;}\n   else if(vs.y==1.)return hxL3(b2b3,b4,b5,o,t,X,Y).xyy \n   ;else return hxL3(b3,b4,b5,b6,o,t,X,Y).xyy\n   ;s=suv(r) \n  ;}\n/**/\n\n ;if(s==3.//test 3\n ){if(r.x==1.)return hxL3(b2,b1,b6,b5,o,t,X,Y).xyy//1110\n  ;           return hxL3(b1,b6,b5,b4,o,t,X,Y).xyy//0111\n ;}else if(s==2.//test 2\n ){if(r.x==1.)return hxL2(b2,b1,b6,o,t,X,Y).xyy//1100 b2,b1,b6\n  ;if(r.y==1.)return hxL2(b1,b6,b5,o,t,X,Y).xyy//0110 b1,b6,b5\n  ;           return hxL2(b6,b5,b4,o,t,X,Y).xyy//0011 b6,b5,b4\n ;}////test 1 \n ;s=suv(r.xy)\n ;if(s==1.\n ){if(r.x==1.)return hxL1(b2,b1,o,t,X,Y).xyy  //1000==b2,b1\n  ;           return hxL1(b1,b6,o,t,X,Y).xyy;}//0100==b1,b6\n ; if(r.z==1.)return hxL1(b6,b5,o,t,X,Y).xyy  //0010==b4,b5\n ;            return hxL1(b5,b4,o,t,X,Y).xyy;}//0001==b5,b4\n\n\nvec2 traceHexBaryOutside(vec3 o,vec3 t,vec3 b1,vec3 b2,vec3 b3,vec3 b4,vec3 b5,vec3 b6,vec3 X,vec3 Y\n){return b2c(b1,X,Y)+vec2(.1)\n ;return vec2(.1,0);}\n\n//innerFrustrum() returns cakeslices, that cut trought (o) and all hex corners\n//no undefined cases via kerning-frustrums\nbool innF(vec2 u,vec2 o){return u.y*suv(o)>o.y*suv(u);}\nbool innS(vec2 u,vec2 o,vec2 a,vec2 b){return innF(u+a,o+a)||innF(o+b,u+b);}\nvec3 innerFrustrum(vec2 u,vec2 o//inputs are .yz of carthesian points\n){return vec3(ivec3(innS(u,o,vec2(0,-1),vec2( 0,1))\n                   ,innS(u,o,vec2(1, 0),vec2(-1,0))\n                  ,!innS(u,o,vec2(1,-1),vec2(-1,1))));}\n//110 top    center\n//010 top    right\n//011 bottom right\n//001 bottom center\n\n//return intersection of ray(ot) and barycentricHex (p0,p1,p2) (p0 is hex center)\nvec4 paintHexBary(vec2 u,vec2 o,vec2 t,vec2 p0,vec2 p1,vec2 p2\n){float cd=c2bdet(p0,p1,p2)\n ;vec4 c=vec4(1)     \n ;vec2 pro=p1-p0\n ;vec2 prt=p2-p0\n ;vec2 p3=p2-pro\n ;vec2 p4=p0-pro\n ;vec2 p5=p0-prt\n ;vec2 p6=p1-prt\n\n  //corners in barycentric (makes skew and flip simpler\n ;vec3 b0=vec3(1,0,0)\n ,b1=vec3(0,1,0)\n ,b2=vec3(0,0,1)\n ,b3=vec3(1,-1,1)\n ,b4=vec3(2,-1,0)\n ,b5=vec3(2,0,-1)\n ,b6=vec3(1,1,-1)\n     \n ;vec3 uu=c2b(u,p0,p1,p2,cd)//only for visualization\n ;vec3 oo=c2b(o,p0,p1,p2,cd)\n ;vec3 tt=c2b(t,p0,p1,p2,cd)\n ;float rotations=0.\n ;if(oo.x>1.){rotations=3.  //half rotation\n  ;uu=r36bary(uu-vec3(1,-1,0))\n  ;oo=r36bary(oo-vec3(1,-1,0))\n  ;tt=r36bary(tt-vec3(1,-1,0))\n ;}if(oo.y<0.){rotations++ //sixt rotation //rotate corner points by +1\n  ;uu=r16bary(uu-vec3(1,-1,0))\n  ;oo=r16bary(oo-vec3(1,-1,0))\n  ;tt=r16bary(tt-vec3(1,-1,0))\n ;}else if(oo.z<0.){rotations-- //negative sixt rotation //rotate corner points by -1\n  ;uu=r56bary(uu-vec3(0,1,-1))\n  ;oo=r56bary(oo-vec3(0,1,-1))\n  ;tt=r56bary(tt-vec3(0,1,-1));}//rotations range[-1..4]\n         \n ;if(rotations==-1.) rotate6by1(p6,p5,p4,p3,p2,p1)//reversed\n ;if(rotations== 4.) rotate6by2(p6,p5,p4,p3,p2,p1)//reversed \n ;if(rotations== 3.) rotate6by3(p1,p2,p3,p4,p5,p6)\n ;if(rotations== 2.) rotate6by2(p1,p2,p3,p4,p5,p6)\n ;if(rotations== 1.) rotate6by1(p1,p2,p3,p4,p5,p6)\n //;if(rotations==1.||rotations==3.||rotations==-1.){\n     //half of all cases are skewed the other way\n     //instead of flipping our shit, we just do pur pN in barycentric coordinates\n //;}\n ;vec3 vs=c2b(o,p0,p1,p2,cd)\n ;vec3 center=sat((floor(uu+vec3(0,1,1))))\n\n ;c.y=min(c.y,ray(u,o,t)-.005)//green ray\n ;c.y=min(c.y,abs(segment(u,o,t)-.02))//green ray segment\n\n //;o=b2c(oo,p0,p1,p2)\n //;t=b2c(tt,p0,p1,p2)\n\n ;float bariOdet=c2bdet(o,p1,p2)//triangle with o instead of p0\n ;vec3 baryO=c2b(t,o,p1,p2,bariOdet)//triangles bariOcentric coords\n ;vec2 sect=intersectB2c(o,t,p1,p2)\n     \n //;vec2 sect=p1-(p1-p2)*tt.z/(tt.z+tt.y)//projection of o on outer border (from center)\n     //;vec2 sect=(oo.z*(tt.z+tt.y)-tt.z*(oo.z+oo.y))\n ;//c.y=uu.z*(oo.z+oo.y)-oo.z*(uu.z+uu.y) // iahas a line from corner to point\n      \n ;//return mix(c,floor(1.-vec4(frustrumX,frustrumY,frustrumZ,0)),.5)\n     \n ;//c.y=min(c.y,abs(sqrt(dd(u-sect))-.02))//intersection fail\n  \n;if(tt.z*(oo.z+oo.y)>oo.z*(tt.z+tt.y) //oh great its 2 ratios, and dividents flip sdes so its only mults\n//;if(tt.z*(oo.z+oo.x)>oo.z*(tt.z+tt.x) //oh great its 2 ratios, and dividents flip sdes so its only mults\n//;if(tt.y*(oo.y+oo.x)>oo.y*(tt.y+tt.x) //oh great its 2 ratios, and dividents flip sdes so its only mults\n\n //tt.y>oo.y//tt.z>tt.y//mirror symmetry on the whole thing\n ){uu.zy=uu.yz\n  ;oo.zy=oo.yz\n  ;tt.zy=tt.yz\n  ;rotate6by3(p1,p3,p5,p2,p6,p4)//strided half rotation == mirror\n  ;\n  ;}  \n/**/\n     \n  ;//projecting 2 points onto the axis is warely worth it\n  ;//, only where we have 2 caes to check and within some other constrrains\n  ;//p2=p1+(p2-p1)*.5\n  ;//p4=p5+(p4-p5)*.5\n     \n ;c.z=min(c.z,abs(length(u-p0)-.03))\n ;c.z=min(c.z,abs(length(u-p1)-.05))//blue circles\n ;c.z=min(c.z,abs(length(u-p2)-.07))//to distinguish inputs (handedness)\n ;c.z=min(c.z,abs(length(u-p3)-.08))//to distinguish inputs (handedness)\n ;c.z=min(c.z,abs(length(u-p4)-.09))//to distinguish inputs (handedness)\n ;c.w=min(c.w,abs(length(u-p5)-.09 ))//to distinguish inputs (handedness)\n     \n ;vec3 X=vec3(p0.x,p1.x,p2.x)\n ;vec3 Y=vec3(p0.y,p1.y,p2.y)\n ;p1=b2c(b1,X,Y)    \n ;p2=b2c(b2,X,Y)    \n ;p3=b2c(b3,X,Y)   \n ;p4=b2c(b4,X,Y)  \n ;p5=b2c(b5,X,Y)  \n ;p6=b2c(b6,X,Y)  //testing bN \n ;c.x=min(c.x,segment(u,p2,p1))\n ;c.x=min(c.x,segment(u,p3,p2))\n ;c.x=min(c.x,segment(u,p4,p3))\n ;c.x=min(c.x,segment(u,p5,p4))\n ;c.x=min(c.x,segment(u,p6,p5))\n ;c.x=min(c.x,segment(u,p1,p6))//red hexagon\n ;c.z=min(c.z,segment(u,p0,p1))\n ;c.z=min(c.z,segment(u,p0,p2))\n ;c.z=min(c.z,segment(u,p1,p2))//blue triangle (indicates pieslice or (o)\n     \n\n     \n ;//all mirroring and showing of it is done; \n ;//all casting pout of the target is done\n     \n ;float outU=min(floor(mav(abs(vec3(1,0,0)-uu))),1.)\n ;float outO=min(floor(mav(abs(vec3(1,0,0)-oo))),1.)\n     \n\n ;vec2 intersection=vec2(0)\n ;//if(outO>0.)intersection=traceHexBaryOutside(oo,tt,b1,b2,b3,b4,b5,b6,X,Y)\n ;//else       intersection=traceHexBaryInside(uu,oo,tt,b1,b2,b3,b4,b5,b6,X,Y).xy\n    \n \n ;c.w=min(c.w,abs(abs(length(u-intersection)-.03)-.01))//mark intersections\n \n ;c=smoothstep(.01,-.01,c)-.01\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n\n ;vec3 cake=(floor(uu)+vec3(0,1,1))\n ;cake=sat(floor(cake))\n ;//c.xyz=cake\n ;//if(cake.x>0.&&cake.y>0.)c.xyz=cake\n ;//if(cake.x>0.&&cake.y==0.)c.xyz=cake\n ;//c.xyz=mix(c.xyz,sat(cake-vec3(outU*.7)),.5)//inside\n  \n ;//c.xyz+=sat(floor(uu+1.))//upper triangle is white\n ;//c.xyz+=suv(sat(floor(uu+1.)))*.33//upper triangle is white 4sect\n                   /*\n ;//c.xyz+=sat(floor(uu+vec3(-1,1,1)))*.4 //opposing triangle is black\n ;//c.xyz+=suv(sat(floor(uu+vec3(-1,1,1))))*.5//opposing trianggle 4sected\n ;//c.xyz+=sat(floor(uu+1.))*.4 //upper triangle is white\n ;float sect4low=suv(sat(floor(uu+vec3(-1,1,1))))\n ;//float alowerT=suv(sat(floor(uu+vec3(-1,1,1))))\n  //;c*=alowerT  \n ;float uIsInside=mav(abs(uu-vec3(1,0,0)))\n ;float aa=suv(sat(floor(uu+vec3(0,1,1))))\n ;float needsPush=float(aa<1.||uIsInside>1.)//bool(inT))\n   /**/\n ;//float isSimple=float(suv(sat(floor(uu+vec3(-1,1,1))))==0.||mav(abs(uu-vec3(1,0,0)))>1.)//bool(inT))\n ;//c.xyz=mix(c.xyz,vec3(isSimple),.5)  \n     /**/\n ;//branching case wether oo is outside or inside \n  \n ;//c.xyz=mix(c.xyz,traceHexBaryInside(uu,oo,tt,b1,b2,b3,b4,b5,b6,X,Y),5.)//to debug oo is uu\n ;vec3 fuck=innerFrustrum(uu.yz,oo.yz)\n ;c.xyz=mix(c.xyz,fuck,.5)\n     \n  \n ;return c;}\n\nbvec3 getFustrumTri(vec3 tt,vec3 oo\n){bvec3 i=bvec3(false)//3 fustrums over 3 lineSegments, each in 2 signs.\n ;if(sign(oo.x)<0.)i.x=innS(tt.yz,oo.yz,vec2(0,-1),vec2(-1,0))     \n ;else             i.x=innS(tt.yz,oo.yz,vec2(-1,0),vec2(0,-1))\n ;if(sign(oo.y)<0.)i.y=innS(tt.yz,oo.yz,vec2(0,0),vec2(0,-1))  \n ;else             i.y=innS(tt.yz,oo.yz,vec2(0,-1),vec2(0,0))\n ;if(sign(oo.z)<0.)i.z=innS(tt.yz,oo.yz,vec2(-1,0),vec2(0,0))       \n ;else             i.z=innS(tt.yz,oo.yz,vec2(0,0),vec2(-1,0))\n ;return not(i);}\n\n\n//baryTriangleOLD() was a naive version (worse culling, only dies zNear)\n//baryTriangleOLD() can still be useful? (though it does extra divisions)\n//nah, looking closer into it, this fustrum solution seems most elegant\n//:\n//does 1 division for baricentric determinant (just like baryTriangleOLD())\n//each inB2c2N() is 1 division, BUT only iff there is an intersection\n//it also cheaply checks is there are 1 or 2 intersections in total.\nvec3 traceTriangle(vec2 u,vec2 o,vec2 t,vec2 a,vec2 b,vec2 c\n){vec4 r=vec4(1)\n ;r.x=min(r.x,segment(u,a,b))//red triangle border\n ;r.x=min(r.x,segment(u,b,c))//red triangle border\n ;r.x=min(r.x,segment(u,c,a))//red triangle border\n ;r.y=min(r.y,ray(u,o,t))//show ray and triangle\n ;float det=c2bdet(transp23)//by using det() we only need 1 division for all ctb(*,abc))\n ;vec3 uu=c2b(u,a,b,c,det)//+0 division (det variant) //uu is only for visualization\n ;vec3 oo=c2b(o,a,b,c,det)//+0 division (det variant)\n ;vec3 tt=c2b(t,a,b,c,det)//+0 division (det variant)\n ;bvec3 i=getFustrumTri(tt,oo)//+1 div, small branching tree\n ;if(!any(lessThan(oo,vec3(0)))//o is in triangle ->one intersection, zNear is o\n ){vec2 hit=vec2(0)\n  ;     if(i.x)hit=inB2c2N(o,t,c,b)\n  ;else if(i.y)hit=inB2c2N(o,t,c,a)\n  ;else        hit=inB2c2N(o,t,a,b)\n  ;r.w=min(r.w,segment(u,o,hit)-.01)//visualize      intersections\n  ;r.w=min(r.w,segment(u,o,o)-.03)  //visualize near intersection (origin)\n ;}else{//we miss all OR [12] segments\n  ;vec2 hit0=vec2(0),hit1=vec2(0)     \n  ;if(suv(vec3(i))<2.){hit0=o;hit1=o\n ;}else if(!i.x){hit0=inB2c2N(o,t,a,b);hit1=inB2c2N(o,t,c,a);if(oo.y<0.)rotate2by1(hit0,hit1)//rotate2by1()==strided swap/rotation library\n ;}else if(!i.y){hit0=inB2c2N(o,t,c,b);hit1=inB2c2N(o,t,a,b);if(oo.z<0.)rotate2by1(hit0,hit1)\n ;}else         {hit0=inB2c2N(o,t,c,a);hit1=inB2c2N(o,t,c,b);if(oo.x<0.)rotate2by1(hit0,hit1)\n ;}r.w=min(r.w,segment(u,hit0,hit1)-.01);//visualize     intersections\n  ;r.w=min(r.w,segment(u,hit0,hit0)-.03);//visualize far intersection\n ;}\n ;//compose visualizations\n ;r=smoothstep(.005,-.005,r)-.01 //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;r=pdOver(pdOver(v3(1,0,0,1)*r.x,v3(0,1,0,1)*r.y)\n          ,pdOver(v3(0,0,1,1)*r.z,v3(1,1,0,1)*r.w))\n ;r.xyz+=vec3(i)*.3\n //below visualizates fustrums\n ;i=getFustrumTri(uu,oo)\n ;r.xyz+=vec3(i)*.3\n ;return r.xyz;}\n\n\n\nv3 demoBezierQuad(v0 t,v1 u,v2 r,v3 m//iCanBez (iCanvas iBezieer merged in UI2AD37)\n){v3 c=v3(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y      \n ;if(m.z<=0.)m.xy=v1(cos(t),sin(t*1.61))\n ;v3 o=v3(0,0,0,1)\n ;v1 p0=v1(-cos(t*.5),sin(t*0.9))*.4\n ,p1=v1(-cos(t*2.3),sin(t*1.1))\n ,p2=v1(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*viewzoom//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*viewzoom//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*viewzoom\n ;}  \n //if (4 points exist) 4th points .y overwrites m.y\n ;v1 p3\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;p3=fra(t,bufDrag(3.).xy,r,m)*viewzoom\n  ;m.x=mix(.5,1.,p3.y/viewzoom+.5)\n  ;//m.x=(m.x*2.)\n  ;//c.w=segment(u,p3,mix(p0,p2,p3.y/viewzoom+.5))//c.w for a yellow line for an  associative connection\n  ;//c.w=segment(u,p3,v1(0))//c.w for a yellow line for an  associative connection\n  ;} \n ;v1 p4\n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){p4=fra(t,bufDrag(4.).xy,r,m)*viewzoom\n  ;m.y=mix(.5,1.,p4.y/viewzoom+.5)\n  ;//c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y/viewzoom+.5)))//c.w for a yellow line for an  associative connection\n ;}\n ;c.x=segment(u,vec2(0),vec2(0))\n\n ;c.y=1.\n ;c.z=1.\n   \n\n ;//c=baryTriangle(t,u,r,m,p3,p4,p0,p1,p2,c) //trace triangle barycentric\n ;//vec2 p=TraceHexInsideBary(u,p3,p4,p0,p1,p2)\n ;//c.y=min(c.y,segment(u,p,p)-.05)\n \n\n  \n ;c=smoothstep(2./Aa(t,u,r,m),-2./Aa(t,u,r,m),c) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;vec3 j=vec3(fract(abs(p1.x*2.)),1./7.,1./6.)\n \n ;//c=paintHexBary(u,p3,p4,p0,p1,p2)\n \n     /*\n ;u*=3.\n ;p4*=4.\n ;p4.y=-p4.y\n ;p2*=2.\n ;//p3*=sign(-p4)\n  ;if(mav(abs(u))<.75){\n         ; c.xyz+=.5*(simplexRotD(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   ;//c.y  +=.5*(simplexRot(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   //above 2 have periodic tiling.xy, below not:\n   ;//c.xyz+=.5*((simplexRotD(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n   ;//c.y  +=.5*((simplexRot(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n }else if(u.x<0.\n ){vec2 cel\n  ;if(u.y>0.)cel=cellular(     u/p3.xy      +     p4.xy      ,j)\n  ;else      cel=cellular(vec3(u/p3.xy,p2.x)+vec3(p4.xy,p2.y),j) \n  ;//c.x=snoise(u/p3.xy*2.+p4.xy*9.)*.5+.5;\n  ;c.xy+=cel.xy*.6\n ;}else{\n  ;if(u.y>0.\n  ){     c.y+=.6*(snoise(     u/p3.xy+p4           )*.5+.5)\n  ;}else c.y+=.6*(snoise(vec3(u/p3.xy+p4,p2.x+p2.y))*.5+.5)\n\n ;}/**/\n ;c.xyz=traceTriangle(u,p3,p4,p0,p1,p2)\n ;return c;}\n\n/**/\n\nv3 demoProject(v0 t,v1 u,v2 r,v3 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v3 c=v3(1)\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 p0=v1(.5,-.5)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;}\n ;//l0=v1(0)\n ;v0 d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;v1 p10=projectS(p0-l0,l1-l0)+l0//projected point (p0) on line (l0,l1)\n ;c.x=length(u-p10)//red projected point\n ;v1 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n     //fuck it erased a line here, dumb UI\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d\n ;//c.z-=.01  \n ;c.x-=.05\n ;c=abs(c-.02)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.4\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(v1 rs,v1 r2,v1 ls,v1 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;v1 ll=le-ls\n ;v0 c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nv1 InterWall(v1 rs,v1 r2,v1 ls,v1 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;v1 j=(ls+le)*.5//midpoint\n ;v1 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nv3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 r0=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;//c.z=abs(c.z-.05)-.02\n ;//c.w=abs(c.w-.1)-.03\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=1.\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;//c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\nvec4 iCB(out v3 o,v1 u //wrapper for bezier +appolonean demo\n){o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;//o=ltj3Wc(o,u,iResolution,iMouse)//previously called iCanvas\n /*\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;     if(pointCount< 7.)o=(demoBezierQuad   (iTime,u,iResolution,iMouse))//,o)\n ;else if(pointCount< 9.)o=(demoProject      (iTime,u,iResolution,iMouse))//,o)                  \n ;else                   o=(demoIkBezier     (iTime,u,iResolution,iMouse))//,o)\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)\n ;//o=demoProject(iTime,u,iResolution,iMouse)//not correct for many cases, sign-ignorant\n ;//o=sat(o)*/\n ;return o\n ;}\n\n//temporal reprojection  MainImage\n//self  : https://www.shadertoy.com/view/wlf3RB\n//parent: https://www.shadertoy.com/view/Xd2fzR\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\nvec4 mTR(vec4 o,vec2 u\n){vec3 c=tf3(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;//vec2 q=u/iResolution.xy\n ;//c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;return vec4(c,1);}\n\n#define pDoOver(a) pdOver(o,texture(a,u/iResolution.xy, -100.0 ))\n\n\n//below code is: RE7 [[BayesianEpsilon targetFPS] [Image]]\n//iRe refers to the ichannel buffer locale of [relativistic camera movement]\n//the type of camera mkovement where [time slows down, reciprocal to the speed of light].\n//that is, reaching the speed of light is impossible, because that halts the speed of time.\n//and any 2 observers with no relative movement hate time between them pass with the speedOfLight.\n\n#define iRe iChannel2\n\nstruct Ray\n {vec3 dir\n ;vec3 b\n ;vec3 surfaceNorm\n ;int iter\n ;float time\n ;float dist\n ;int object\n ;vec3 closestObject;};\nvec3 GetMaterialsColor(Ray r, int matID\n){if(matID>7)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*float(matID*2))*fakeOA\n ;}\nvec3 GetMaterialsColor(Ray r, float i){return GetMaterialsColor(r,int(i));}\n\n//lod,ray,start,zFar\nvoid MarchLight(float sscoc,inout Ray r, float startTime, float f//relkativistic raymarcher\n){float acc = 0.\n ;float eps=getEpsToFps(sscoc)\n ;float lip=getReLipschitzToFps(sscoc)\n ;vec3 origin = r.b\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){r.time = startTime\n  ;SetTime(r.time)\n  ;r.dist=map(r.b,-1)\n  ;acc+=r.dist*lip\n  ;r.b+=r.dir*(r.dist)\n  ;if(abs(r.dist)<eps||acc>f)break;}}\n\nvoid MarchPOV(inout Ray r, float startTime,float sscoc\n){//dpos = vec3(-2.2,0,0)\n ;//lorentzF = LorentzFactor(length(dpos))\n ;float speedC = length(dpos)/cSpe\n ;vec3 nDpos = vec3(1,0,0)\n ;if(length(dpos)>0.)nDpos = normalize(dpos)\n ;//shrink space along vel axis (length contraction of field of view)\n ;float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)))\n ;vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos\n ;r.dir = normalize(newDir)\n ;float dDirDpos = dot(dpos,r.dir)\n ;// Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n ;// tan(a') = sin(a)/(Y*(v/c + cos(a)))\n ;// velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n ;float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC)\n ;r.dir=mix(r.dir\n           ,normalize((r.dir-nDpos*dot(nDpos,r.dir))-lightDistortion*nDpos)\n           ,FOVAberrationOfLight)\n ;//Classical Newtown Mechanic instead would be\n ;//r.dir = normalize(r.dir-dpos/cSpe)\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){float camDist = length(r.b - objPos[oCam])\n  //;float photonDelay = -camDist*cLag/cSpe\n  //takes dilated distance x/Y and find the time in map frame with :\n  // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n  // Y = lorentzFactor\n  // t' = Y(t-v*(x/Y)/cÂ²)\n  // t' = Y(0-v*(x/Y)/cÂ²)\n  // t' = Y(v*x/Y)/cÂ²\n  // t' = vx/cÂ²\n  ;r.time = startTime\n  ;r.time += mix(simultaneouity*dDirDpos*camDist/(cSpe*cSpe),-camDist*cLag/cSpe,cLag)\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;//Gravitational lens\n  ;vec3 blackHoleDirection=(objPos[oBlackHole]-r.b)\n  ;r.dir+=(1./RayPrecision)*r.dist*reciprocalLipschitz\n      *normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*cSpe*cSpe)\n  ;r.dir = normalize(r.dir)\n  ;if(abs(r.dist)<getEpsToFps(sscoc))break\n  ;r.b+= (1./RayPrecision)*(r.dist)*reciprocalLipschitz*(r.dir);}\n ;//r.b = origin + r.dir*min(length(r.b-origin),maxDist)\n ;r.surfaceNorm = GetNormal(r.b).xyz;}\n\nvec3 accHalo(vec3 oliPos,vec3 lightRelVel,float halo,vec3 lightColor){\n  ;vec3 camLightDir=normalize(oliPos-pos)\n  ;float cds=dot(camLightDir,dpos)//camDirCamSpeed \n  ;float cdl=dot(camLightDir,lightRelVel)//camDirLightSpeed\n  ;return halo*dsf(lightColor,(cSpe/(cSpe\n                      \n                                         \n     -(cds-cdl)/(1.-(cds*cdl/(cSpe*cSpe)))//haloRel\n                                         *dopplerF))*lorentzF)\n;}\n\nvec3 GetDiffuse(float sscoc, Ray r\n){vec3 cDiff=vec3(0)\n ;Ray tmpRay = r\n ;float vma2=vma;//accretion disk before recalculation\n ;float mat=float(rayMat)//trippy bug caused by copying/moving this linefurther down.\n ;//if(mat==8.)return vec3(0)//black holes are just black\n ;vec3 objVel=objVel[rayObj]\n ;vec3 lHalo =vec3(0)\n ;float[numLights] halos\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0;i<10;i++\n  ){lightLate=cLag*length(oliPos[L]-r.b)/cSpe;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos=          oliPos[L]-r.b\n  ;ProcessLightValue(r.time-lightLate+.01)\n  ;vec3  lightVel   =((oliPos[L]-r.b)-lightRelPos)/.01\n  ;vec3  lightRelVel=lightVel-objVel\n  ;float lightLorentzF   =LorentzFactor(length(lightVel))\n  ;vec3 lightDir   =normalize(lightRelPos)\n  ;vec3 camDir     =normalize(pos-r.b)\n  ;vec3 camRelVel  =dpos-objVel\n  //;float halo            =halos[L]\n  ;SetTime(r.time)\n  #ifdef CauseMaterialColoredShadowsBug\n   #define basicBug \n   #ifdef basicBug\n   ;mat=float(rayMat) //trippy bug-> shadows in ID.color\n   #else\n    //might want to floor because mat sets hue on a goldenSpiral\n    //floor()not needed above , while rayMat is type int\n    //above is simple bug case\n    //below oscilates the effect over [player time]==Get(ReTime).x\n   ;//mat=mix(float(mat),float(rayMat),cos(Get(ReTime).x)*.5+.5)\n       //might want to floor because mat sets hue on a goldenSpiral\n   ;mat=floor(mix(float(mat),float(rayMat),cos(Get(ReTime).x*.3)))\n   #endif    \n  #endif\n  ;Ray shadow\n  ;shadow.b = r.b + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(sscoc,shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-r.b) < (length(lightRelPos)-.5))dropShadowAtten=.4\n  #ifdef redshiftdT\n  ;SetTime(r.time)\n  ;float speed=map(r.b,int(mat))\n  ;SetTime(r.time+.01)//1/100 time delta\n  ;speed-=map(r.b,int(mat))//now is propper differential\n  ;speed*=100.//scale by 100\n  //blackholes are tinted in Re0 wven without this bracket.\n  #else\n  ;float speed=0.\n  #endif\n  ;//speed += LorentzFactor(cSpe)//commented out in the original\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;vec3 lightColor =          oliCol[L].rgb \n  ;lorentzF/=mix(lorentzF,lightLorentzF,relativisticDoppler)\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;cDiff+=     dsf(lightColor*matCol*atten,(cSpe/(cSpe-speed  *dopplerF))*lorentzF)\n  ;if(mat==8.)lHalo+=halos[L]//black holes suck upp all ambient and skipp dopplerShoift\n  ;else       lHalo+=accHalo(oliPos[L],lightRelVel,halos[L],lightColor)\n  ;}\n  ;if(mat==8.)return lHalo+vma2\n  ;return  cDiff+(lHalo+vma2)*(1.-cDiff);}\n\nvec3 GetSampleColor(float sscoc,vec2 uv\n){Ray r\n ;r.dir = vec3(0,0,1)\n ;if (fishEye\n ){vec3 crossv=cross(r.dir,vec3(uv,0))\n  ;r.dir=qr(aa2q(length(uv)*FOV,normalize(crossv)),r.dir)\n  ;}else r.dir = vec3(uv.xy*FOV,1.)\n ;//apply look dir\n ;r.b = objPos[oCam]\n ;r.dir = qr(objRot[oCam],r.dir)\n ;MarchPOV(r,playerTime,sscoc)\n ;return GetDiffuse(sscoc,r);}\n\nvec4 mainImageRe8(vec4 o, in vec2 u\n){//vec2 u=fra(uv,iResolution)//(uv/iResolution.xy+.5)/iResolution.y\n ;float sscoc=length(u/iResolution.xy-.5) //length(u/iResolution.xy*+.5)/sqrt(2.)\n ;sscoc=smoothstep(.75,0.,sscoc)//full btight in the center, pitch black at the cotner, oval\n ;vec2 v=(u-iResolution.xy*0.5)/iResolution.yy\n ;float edit=Get(ReEdit).x\n ;if(edit>0.//if in edit mode\n ){if(length(abs(v)-.5)-.02<0.)return vec4(1)//circles filled\n ;}\n ;vec4 timE=Get(ReTimE)\n ;if(timE.w<0.&&abs(length(abs(v)-.5)-.03)-.003<0.)return vec4(1)//circles rings\n ;\n ;//int tuu=6%5\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;playerTime=abs(timE.w)\n ;lorentzF = LorentzFactor(length(dpos))\n ;SetTime(playerTime)\n ;oCamSet(Get(RePos).xyz,Get(ReQua))\n ;vec3 color = GetSampleColor(sscoc,v)\n ;//float ao = 1.-float(r.iter)/float(maxStepRayMarching)\n ;o = vec4(color*1.5,1)\n ;//o *= length(Get(D_POS).xyz)/SpeedOfLight //differential debug\n ;o+=(texture(iRe,u/iResolution.xy).rgba )//debug buffer of iRe\n ;return o;}\n\n/*\nbuffa buffers many params for diegeticUI\nbuffc buffers params for a relativistic camera\n\ni want a 3d UI, but\n- i can only rotate the head while left dragging\n- double klicking may get you out of the canvas\n\n- nomode solution, not good for direct feedback\nonMouseRelease; buffer the objectID of the object where mouse was released\ninKeyPresss: object properties of buffered objectID may change\n\n- editMode\nonKeypress, may toggle to editmode\nin editmode, mouse drag no longer moves camera\n\nonKeypress, may toggle to timeFreezesMode\n\n\ntime freeze and edit mode work in re8, but nothing is being edited\n*/\n\n\n//below is a very basic toggle-wrapper, showing what 2 shaders have been hodgepodged\n//this completes step2, fixing all namespace conflicts. (was easy for once)\n//step 2 is to clean up mainImageRe7() and its subroutines. - done re8()\n//step 3 is trckier\n//all these buffers store properties, an array of vec4 \n//and I need them to evade any conflict between them\n//so I can merge thzem into a single buffer\n//- (lets exclude BufferD for being a screenspace incrementalAveraging buffer)\n\n\n#define Scene2D\n\n//#if 1\nvec4 mainImageUI2AD37(out vec4 o, in vec2 u\n){o=vec4(0)\n #ifdef Scene2D\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d srawing\n #else\n  #ifdef SceneTR\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  #else\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pDoOver(iAD)  //backdrop is marched 3d scene (automatic Differentiation)\n  #endif\n #endif\n ;return o;}\n/**/\n//#else\n/*\nvoid mainImage(out vec4 o,vec2 u\n){o=mTR(o,u)//temporal reprojection\n;}*/\n//#endif\n/**/\n\nvec4 spin(vec4 o,vec2 u\n){vec2 v=fra(iTime,u,iResolution,iMouse)\n ;o=vec4(0)\n   \n    \n ;//o=pdOver(iDiegeticUIshow(u),o)//ui dots\n ;//o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n ;v*=rot2D(u5(cos(iTime/9.)*99.))\n ;if(v.x>0.){if(v.y>.0){\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;//o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n   ;return o;\n   ;}\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n  ;//o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  ;return o\n  ;}\n ;if(v.y>0.){\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d drawing\n  ;return o\n ;}\n ;return o\n //;return mainImageRe8(o,u)\n ;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){\n /*vec2 i=u/iResolution.y\n ;if(i.x<.15&&i.y>.95){\n ;//o=mainImage2(o,i)\n     ;return;//number overlay\n ;}*/\n \n //;o=spin(o,u)\n    \n #if 1\n ;o=mainImageUI2AD37(o,u)\n #else\n ;o=mainImageRe8(o,u)\n #endif\n //;o=(texture(iRe,u/iResolution.xy).rgba );\n/**/\n ;}\n\n\n/*\nI like my code modular, evading namespace conflicts, while having short namespaces.\nI heavily advocate for compatibility, performance and diegetic UI.\nIO see this ignored too often\nThe acronym \"ReTrAdUi\" makes fun of bad UI design, namespaces and typos.\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n#define phi (sqrt(5.)*.5+.5)\n\n#define tiny .00001\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n//#define u2(a) su(mu(a,2.), 1.)\n#define u3(a) su(mu(a,2.),-1.)\n//#define u5(a) su(mu(a,.5),.5)\n#define u5cos(a) (u5(cos(a))\n//below is needed for old code, that i failed to update so that su() and mu() work on the right inpout types.\n#define u5cos2(a) ((cos(a))*.5+.5)\n//#define cosu5(a) u5(co(a))\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n/**///--start: iDiegeticUI v2:\n/*\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n/**/\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a) (-(miv(-(a))))\nconst vec3 vs=vec3(-1,0,1);\nv1 perp(v1 a){return a.yx*vs.xz;}\nv1 perp2(v1 a,v1 b){return vec2(a.x*b.y,-a.y*b.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\nv0 perpdot(v1 a,v1 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//v0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n\n/*\nrelativistic engine, with mutable/slower speedOfLight\n\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\n\nDoes not simulate doppler correctly\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- objects changing in size may not doppler its light bounces correctly?\n\nblatantly false shadows&gravity\n- no gravity by object masses (camera does not orbit)\n- shadows are unaffected by mass (except for black hole)\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow?\n- object rotations may result in faster than light speeds of object vertex?\n\n\n/**/\n\n\n/**///--start: RelativityEngineParams\n\n//ESDF keyboard layout is tmore compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//above for movement\n//below toggles pausing of time\n#define KEY_T 84.5\n//below toggles grabEdit mode (mouse no longer rotates camera)\n#define KEY_G 71.5\n\n//fishEyeCam sucks\n#define fishEye false\n//FieldOfView 1.57 = 90deg\n#define FOV 1.57\n//take relative velocity of photons to camera & distort field of view\n#define FOVAberrationOfLight 1.\n\n//SpeedOfLight in m/s divides by /(cSpe*cSpe), so do not make it too large!\n#define cSpe 2.5\n//do not go over speed of light it breaks time & space\n#define maxSpeed (cSpe*2.2/2.5)\n//camera acceleration =24.\n#define thrustForce (cSpe*5./2.5)\n//known bug, bouncing off something too easily accellerates you faster than light\n//iff the speed of light is high\n//for no good reason, any bounce accellerates me without constrain\n\n//PhotonLatency [0..1]; 0.=instant vision\n#define cLag 1.\n//simultaneouity==1 to pretend that simultaneouity exists\n//Then you could see the future in front of you at high speeds.\n//r.time += mix(simultaneouity*dDirDpos*camDist/(cSpe*cSpe),-camDist*cLag/cSpe,cLag)\n#define simultaneouity 1.\n\n//take player/object/light vel to shift color\n#define dopplerF .5\n//take light source speed into account and their own time dilation\n#define relativisticDoppler .2\n//shrink map along velocity vector at high speed\n#define LgthContraction  1.\n//speed map frame time at high speed\n#define TimeDilation 1.\n\n//do +1 FAST (objectID-filtered) march measure how much a hit surface moves towards camera\n//important for realistic redshift, but only adffects diffuse.\n#define redshiftdT\n//higher rayprecision makes glow more bloomy, WHYYY\n#define RayPrecision 1.\n//repeatDoppler==1 seems nonsensical (just tints all in pink)\n#define repeatDoppler 0\n\n#define MaxRayDist 9.0\n\n//set by world\n#define numMats 7\n\n//black hole mass \n#define BlackHoleMassFactor 2.\n//.*cSpe)\n#define AccretionDisk 2.\n\n#define gravity vec3(0.,0.,0.)\n//end of relativity params\n\n/**///--end__: RelativityEngineParams\n\n//do not modify:\n#define pi acos(-1.)\n#define vec1 float\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n\n//#define fra(u,r) (u-.5*r.xy) /r.y\n\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos  = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n/**///--end__: iDiegeticUI v2:\n/**///--\n/**///--start: iChannel-Buffer-pattern\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**///--end__: iChannel-Buffer-pattern\n/**///--\n/**///--start: compatibilityCore \n\n\n/*\ntodo, all the trigonometry functions with glES100 to gles300 porting\nseems to be prettyx fine\n*/\n\n\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\n\n\n//every 2d determinant has a perpendicular dotproduct\n\n//nul function is needed for cases, where the same function is defined 2 times\n//eg: once with sat and once without sat (with nul instead of with sat) => difference between segment() and line()\n#define nUl(b) b nul(b a){return a;}\nnUl(v0)\nnUl(v1)\nnUl(v2)\nnUl(v3)\n    \n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\n\n/**///--end__: compatibilityCore\n/**///--\n/**///--start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created #.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**///--end__: openGl NaN-precision\n/**///--\n/**///--start: AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dtÂ²=+2th derivative (and dt)\n[d***]dtÂ³=+3th derivative (and dt adnd dtÂ²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n\nstruct d(v0 a;);//just use v0 instead of a [d]  struct\nthe whole DA set is pretty consistent, and i tried domain/ds the other way around and that sucked.\nthe first value is a float, because thats what the function returns, a length.\nAND most shapes apply the same functions to a value (no branching, all domains are NOT independent functionWise)\nbut many functions over 2d or 3d should be independent, and can be branching!\n...as a result, the d*** structs are nonsense, and i may need a BIG rewrite.\n\nso, what we may utilize here (to format an UV.xyz to give to any distanceField) is something like:\nc22 da_domain2(v2 p){return c22\n (d22(p.x,v2(1,0,0),v2(1,0,0))\n ,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n ,d22(p.y,v2(0,0,1),v2(0,0,1)));}\n//so the c22 struct first seperates by number of domains, seperating into 3 sub scructs, one foreach domain.\n//each derivative VECTOR has as many domains as the whole struct.\n//i actually wonder, WHY this is not always a type float.\n*/\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dtÂ²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dtÂ²,dtÂ³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dtÂ²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dtÂ²,dtÂ³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dtÂ²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dtÂ²,dtÂ³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dtÂ²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dtÂ²,dtÂ³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00   D00(v2   a){return d00(a.x,a.y,a.z);}\nv2     V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0     D0(v1   a){return d0(a.x,a.y);}\nv1     V1(d00  a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\n//the c* structs are used by the uv inputs, c2 is for 3d, with 1 derivative\n//a distance field is itterated over by: DAMValue s=df(da_domain1(o+i*t))\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dtÂ²\nST c000{d000 x                     ;};//1 domains t,dtÂ²dtÂ³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dtÂ² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dtÂ²dtÂ³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dtÂ² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dtÂ²dtÂ³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dtÂ²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dtÂ²,dtÂ³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//the weirdness, that the first value is always a float, is based on the output of the function, with a scalar distance\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\n//v2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\n//the da_domain*() functions orhtogonally proiject the derivatives onto an matrix.\n//the inpput point o is spread among as many d*** structs as there are domains.\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.z,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0 da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example:\n/*the [c*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(c2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n\n/**///--end__: AD structure\n/**///--\n/**///--start: AD functions \n\n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\n//AD uses these prexisNotation Namespaces and is defined for these domains):\n//[d0..d333] means, it is defined for up..3 derivatives over up..4 domains (but also any lesser permutation)\n//[c...] are some extended struct special cases (higher dimensional)\n//\n//ne()       0-a ,[d0..d333], also [c0..c333]\n//fl() floor(a  ),[d0..d333]\n//fr() fract(a  ),[d0..d333] <= su(1.,fl(a))==mod(a,1.) //complement..floor()\n//mo()   mod(a,b),[d0..d333] <= su(a,mu(b,fl(di(a,b)))) (true_basis_modulo)\n//si()   sin(a  ),[d0..d333]\n//co()   cos(a  ),[d0..d333]\n//ex()   exp(a  ),[d0..d333] //inverse of log()\n//ln()   log(a  ),[d0..d333]\n//sg()  sign(a  ),[d0..d333]\n//ab()   abs(a  ),[d0..d333],[c2]\n//su()        a-b,[d0..d333],[c0..c3]\n//ad()        a+b,[d0..d333],[c0..c3] <== su(a,ne(b))\n//mu()        a*b,[d0..d333],[c0..c3]\n//di()        a/b,[d0..d333]\n//po()   pow(a,b),[d0..d333] <= ex(mu(ln(x),x))\n//mi()   min(a,b),[d0..d333],[c2]\n//sr()  sqrt(a  ),[d0..d333]\n//p2()   pow(a,2),[d0..d333],[c0..c2] <=mu(a,a)\n//p3()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),a)\n//p4()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),mu(a,a))  //because for AD, mu() recursion is faster than pow(a,b)\n//dt()   dot(a,b),[d0..d333],[c0..c3] <=ad(mu(),mu()...)\n//dd()   dot(a,a),[d0..d333],[c0..c3] <= dt(a,a)\n//sd()  length(a),[d0..d333] <=po(dd(a),1./2.) == sq(dd(a))\n//cd()           , <=po(dd(a),1./3.)\n//qd()           , <=po(dd(a),1./4.)   \n//ud()           , <=po(dd(a),1./5.)\n//ata()          ,[d0..d333]\n//cl()  clamp()               <=mi(ma(a.,0.),1.)\n//st()   sat()                <=clamp(a.,0.,1.)\n//suab()         , [d0..d333] <=ab(sub(a))\n//\n//ab derivatives may be false/naive (3rd derivative is most likely nonsense)\n/**/\n\n//max(a,b)=-min(-a,-b), requires ne()\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n\n//floor(a) is a basis-function for mod() and fract() (all complement each other)\n//calculus on floor() is simpler than on fract() or mod() , so we defien fract() as 1.-floor(), and not as mod(a,1.)\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies automaticDiffernetiation (and it fixes mod())\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to multiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n//mod(a,1.) NEVER returns 1 (its a halfopen interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\nd00 AD(d00 a,v2 o){v0 O=a.c*o.x\n ;return D00(o.xyy*v2(1.,a.b,a.c)\n +v2(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\nv3 siD(v0 a){return v3(si(a),co(a),-si(a),-co(a));}//because derivatives of cin/cos have a periodicity of 4 derivatives,\nv2 siD2(v0 a){return v2(si(a),co(a),-si(a));}      //but we may also want just 2 derivatives (+base)\n\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\nd00 si(d00 a){return AD(a,siD2(a.a));}//sin()dxdxdx\nd00 co(d00 a){return AD(a,siD2(a.a).yzx);}//cos()dxdxdx\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\n\nd11 si(d11 a){d00 Omg(si,x);d00 Omg(si,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 si(d22 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 si(d33 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z);d00 Omg(si,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 si(d111 a){d000 OMg(si,x);d000 OMg(si,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 si(d333 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z);d000 OMg(si,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd11 co(d11 a){d00 Omg(co,x);d00 Omg(co,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 co(d22 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 co(d33 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z);d00 Omg(co,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 co(d111 a){d000 OMg(co,x);d000 OMg(co,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 co(d222 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 co(d333 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z);d000 OMg(co,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//once more a clear sign of my structure extending poorly HERE\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n\n\n//single parameter operations are MUCH simpler here:\n\n//ex(d000) seems to be fine\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n//ex(d00) seems to be fine\nd00  ex(d00  a){return d00 (ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c);}//(tripple) productRule\nd000 ex(d000 a){return d000(ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}//3rd derivative\nd11 ex(d11 a){d00 Omg(ex,x);d00 Omg(ex,y)              ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);d00 Omg(ex,w)\n    ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ln seems to be fine\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd00 ln(d00 a){return d00(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dtdt\nd000 ln(d000 a){return d000(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dtdt\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))/(a.a*a.a*a.a*a.a)//dtdtdt\n //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() is a special case of di() == one antiderivative higher.\nd1 ln(d1 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));return d1(x.a,v1(x.b,y.b));}\nd2 ln(d2 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z))\n ;return d2(x.a,v2(x.b,y.b,z.b));}\nd3 ln(d3 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z));d0 w=ln(d0(a.a,a.b.z))\n ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd11 ln(d11 a){d00 Omg(ln,x);d00 Omg(ln,y)              ;return d11(x.a,v1(x.b,y.b)    ,v1(x.c,y.c));}\nd22 ln(d22 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ln(d33 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);d00 Omg(ln,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//sg() seems to be fine\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0 sg(d0 a){return d0(sign(a.a),0.);}\nd1 sg(d1 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;return d1(x.a,v1(x.b,y.b));}\nd2 sg(d2 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))\n   ;return d2(x.a,v2(x.b,y.b,z.b));}//this one is needed by sdUnterprim()\nd3 sg(d3 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z));d0 w=sg(d0(a.a,a.b.z))\n   ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd11 sg(d11 a){d00 Omg(sg,x);d00 Omg(sg,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 sg(d22 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 sg(d33 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z);d00 Omg(sg,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ab() 3rd derivative seems nonsensical, to check through!\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}//i am a bit suspicious about the derivatives here,not sure if it is THAT simple.\nd11 ab(d11 a){d00 Omg(ab,x);d00 Omg(ab,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ab(d22 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ab(d33 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z);d00 Omg(ab,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nc0   ab(c0   a){return c0  (ab(a.x));}\nc00  ab(c00  a){return c00 (ab(a.x));}\nc000 ab(c000 a){return c000(ab(a.x));}\nc1   ab(c1   a){return c1  (ab(a.x),ab(a.y));}\nc11  ab(c11  a){return c11 (ab(a.x),ab(a.y));}\nc111 ab(c111 a){return c111(ab(a.x),ab(a.y));}\nc2   ab(c2   a){return c2  (ab(a.x),ab(a.y),ab(a.z));}\nc22  ab(c22  a){return c22 (ab(a.x),ab(a.y),ab(a.z));}\nc222 ab(c222 a){return c222(ab(a.x),ab(a.y),ab(a.z));}\nc3   ab(c3   a){return c3  (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc33  ab(c33  a){return c33 (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc333 ab(c333 a){return c333(ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n//su() ad() seem to be fine\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\n#define oMg(f,x) f(d00(a.a,a.b.x,a.c.x),d00(b.a,b.b.x,b.c.x))\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)\nv0 su(v0 a,v0 sux\n//v1 su(v1 a,v0 sux\n//v1 su(v0 a,v1 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\nd00 su(d00 a,d00 b){return d00(a.a-b.a,a.b-b.b,a.c-b.c);}\nd11 su(d11 a,d11 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd22 su(d22 a,d22 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd33 su(d33 a,d33 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z);d00 wa=oMg(su,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dtÂ²,dtÂ³\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd333 su(d333 a,d333 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z);d000 wa=omG(su,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\n      \nd33 su(d33 p,v3 s){return su(p,d33(s.x,v3(0),v3(0)));}\nd22 su(d22 p,v2 s){return su(p,d22(s.x,v2(0),v2(0)));}\nd11 su(d11 p,v1 s){return su(p,d11(s.x,v1(0),v1(0)));}\nd00 su(d00 p,v0 s){return su(p,d00(s  ,v0(0),v0(0)));}//this seems VERY nonsensical, to only store .x\n\nd33 su(d33 p,v0 s){return su(p,d33(s,v3(0),v3(0)));}\nd22 su(d22 p,v0 s){return su(p,d22(s,v2(0),v2(0)));}\nd11 su(d11 p,v0 s){return su(p,d11(s,v1(0),v1(0)));}\n      \n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\n\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd3 mu(d3 a,v0 b){return d3(atb\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nd00  mu(d00  a,d00  b){return d00 (a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b);}//dxdx\nd000 mu(d000 a,d000 b){return d000(a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b//dxdx\n,a.c*b.b+a.b*b.c+a.b*b.c+a.a*b.d+a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c);}//dxdxdx\nd11 mu(d11 a,d11 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mu(d22 a,d22 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mu(d33 a,d33 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z);d00 wa=oMg(mu,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mu(d333 a,d333 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z);d000 wa=omG(mu,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}    \nd00  mu(d00  a,v0 b){return mu(a,d00 (b,0.,0.));}\nd000 mu(d000 a,v0 b){return mu(a,d000(b,0.,0.,0.));}\nd11  mu(d11  a,v0 b){return mu(a,d11 (b,v1(0),v1(0)));}\nd111 mu(d111 a,v0 b){return mu(a,d111(b,v1(0),v1(0),v1(0)));}\nd22  mu(d22  a,v0 b){return mu(a,d22 (b,v2(0),v2(0)));}\nd222 mu(d222 a,v0 b){return mu(a,d222(b,v2(0),v2(0),v2(0)));}\nd33  mu(d33  a,v0 b){return mu(a,d33 (b,v3(0),v3(0)));}\nd333 mu(d333 a,v0 b){return mu(a,d333(b,v3(0),v3(0),v3(0)));}//multiply by constant, needed for sqrt()\nc3 mu(c3 p,v3 s){return c3(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z),mu(p.w,s.w));}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\n//special utility cases come last\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}\n    \n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n\n//di() seems to be fine()\nd00  di(d00  a,d00  b){return d00 (a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a));}//dxdx\nd000 di(d000 a,d000 b){return d000(a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a) //dxdx\n//...\n,((((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a)\n+(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b)\n+(a.b*b.a-a.a*b.b)*(b.b*b.b+b.a*b.c)))*(b.a*b.a*b.a*b.a)\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n*4.*(b.b*b.a*b.a*b.a))/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a));}//dxdxdx //3rd derivative quotient rule sure is something\nd11 di(d11 a,d11 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 di(d22 a,d22 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 di(d33 a,d33 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z);d00 wa=oMg(di,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}                          \nd333 di(d333 a,d333 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z);d000 wa=omG(di,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\nd00  di(d00  a,v0 b){return di(a,d00 (b,0.,0.));}//needed for min()\nd000 di(d000 a,v0 b){return di(a,d000(b,0.,0.,0.));}//needed for min()\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),y))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n#define ma2(a,b,c) ma(ma(a,b),c)\n#define ma3fffff(a,b,c,d) ma(ma(a,b),ma(c,d))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n//min(x,y) = (x+y-abs(x-y))/2 == di(ad(x,su(y,ab(su(x,y)))),2.)\n//max(x,y) = (x+y+abs(x-y))/2 == di(ad(x,ad(y,ab(su(x,y)))),2.)\nd00  mi(d00  a,d00  b){return di(ad(a,su(b,ab(su(a,b)))),2.);}\nd000 mi(d000 a,d000 b){return di(ad(a,su(b,ab(su(a,b)))),2.);}     \nd11 mi(d11 a,d11 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mi(d22 a,d22 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mi(d33 a,d33 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z);d00 wa=oMg(mi,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mi(d333 a,d333 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z);d000 wa=omG(mi,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n//dot() takes vectors as input, so we take this one differently, dot() is only defined for c1(vec2) c22(vec3) c33(vec4)\n//dot()always returns a d0(float)\n//the function is ad( (ad(mu(),mu()),  ad(mu(),mu()) )\n//the function is ad( (ad(mu(),mu()),     mu()       )\n//the function is      ad(mu(),mu())\n//and multiplied terms are of type v0\n\n//ST c1  {d1   x;d1   y              ;};//2 domains t,dt   \n//ST d1  {v0   a;v1   b              ;};//2 domains t,dt\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n      \n//the c* inputs can be da_domain1(v*) outputs\nd0   dt(c0   a,c0   b){return       mu(a.x,b.x);}//dotproduct in 2d with 1 derivative (is just mu())\nd00  dt(c00  a,c00  b){return       mu(a.x,b.x);}//dotproduct in 2d with 2 derivative\nd000 dt(c000 a,c000 b){return       mu(a.x,b.x);}//dotproduct in 2d with 3 derivative   \nd1   dt(c1   a,c1   b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 1 derivative\nd11  dt(c11  a,c11  b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 2 derivative\nd111 dt(c111 a,c111 b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 3 derivative   \nd2   dt(c2   a,c2   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 1 derivative\nd22  dt(c22  a,c22  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 2 derivative\nd222 dt(c222 a,c222 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 3 derivative\nd3   dt(c3   a,c3   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 1 derivative\nd33  dt(c33  a,c33  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 2 derivative\nd333 dt(c333 a,c333 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 3 derivative\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\n#define dd(a) dt(a,a)\n//explicit dd() dual type (for uberprim)\n#define dd2(a,b) ad(p2(a),p2(b))\n//multi-dd() (muliple lengths at once)\n#define d2d(a,b)    v1(   dd(a),dd(b))\n#define d3d(a,b,c)  v2(d2d(a,b),dd(c))\n#define d4d(a,b,c,d)v3(d2d(a,b),d2d(c,d))\n         \nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\nv0 sr(v0 a){return sqrt(a);}v1 sr(v1 a){return sqrt(a);}v2 sr(v2 a){return sqrt(a);}v3 sr(v3 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\nd3 sr(d3 a){v0 q=sqrt(a.a);return d3(q,.5*rec(q)*a.b);}//first derivative shortcut is near\nd00  sr(d00  a){return ex(mu(ln(a),.5));}//2nd and 3rd derivative i do not bother with.,\nd000 sr(d000 a){return ex(mu(ln(a),.5));}\nd11  sr(d11  a){return ex(mu(ln(a),.5));}\nd111 sr(d111 a){return ex(mu(ln(a),.5));}\nd22  sr(d22  a){return ex(mu(ln(a),.5));}\nd222 sr(d222 a){return ex(mu(ln(a),.5));}\nd33  sr(d33  a){return ex(mu(ln(a),.5));}\nd333 sr(d333 a){return ex(mu(ln(a),.5));}\n\n/**///--end__: AD functions                    \n/**///--\n/**///--start: analysis common subroutines\n\n\n//compare [a] with [0.0] to return [b]==true or [c]==false\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n  #define    more(a,b,c) ((a> 0.)?b:c)\n//#define    more(a,b,c)             mix(a,b,step(c,0.))\n  #define    less(a,b,c) ((a< 0.)?b:c)\n//#define    less(a,b,c)             mix(a,b,step(0.,c))\n  #define   equal(a,b,c) ((a==0.)?b:c)\n//#define   equal(a,b,c)             mix(b,a,step2\n  #define unequal(a,b,c) ((a!=0.)?b:c)\n//#define unequal(a,b,c)             mix(a,b,step2\n  #define  unless(a,b,c) ((a>=0.)?b:c) \n//#define  unless(a,b,c)             mix(b,a,step(0.,c)) //==greater OR equal\n  #define  unmore(a,b,c) ((a<=0.)?b:c)\n//#define  unmore(a,b,c)             mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n/**///--end__: analysis common subroutines                  \n/**///--\n/**///--start: analysis Hue Gradient Gamma \n\n//rgba colorspace matrices\n      \n#define ut(a,b) (a*(1.-b))          \nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\n//Re7 Re8 rainbow (do not change or doppler shifts get skewed)\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\nvec3 rainbow(vec1 a,vec1 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(vec1 a,vec1 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(vec1 a){return rainbow(a,1./3.);}\nvec3 rainbow2(vec1 a){return rainbow2(a,1./3.);}\n                              \n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\n                      \n/**///--end__: analysis Hue Gradient Gamma \n/**///--\n/**///--start: analysis smin smax smoothing functions  \n//\n//               smin smax smex variants collection: \n//in prefix-form for compatibility with AutomaticDifferentiation and whatnot.\n//\n//1th letter of thre is m for all smoothing fucntions\n//\n//2th letter sets 1of3 boolean fuzzy-union\n//a=max, i=min=-max(-a,-b), 3=mEx()==max(a,-b) is a semi-nonsense label, literally-in-between-vowel\n//\"mex\" is usually called \"difference\", coined by hg_df\n//, but mex() is often a smaller basis-function-subroutine for min(mex()) and max(mex))\n//\n//3th letter sets type of smoothing union (usually different exponents/complexity)\n//\n//\n//--- sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal and buffer the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))                   //sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)                       //sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\n//w11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n//);}//somehow almost correct, but almost is not good enough. uncommented this extension into a different type.\n//\n//\n//--- SminPPolynomial [m*s] by IQ is fast but not commutative;\n//mis2() is subroutine for SminPPolynomial\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//\n//\n//sMinQuadratic [m*r] use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\n//               \n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(-(a)))  \n//                      \nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n//\nfloat recsum(vec2 a){return 1./(1./(a.x+a.y));}\n//\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n//\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n//\n// demo for smin/smax collection, from https://www.shadertoy.com/view/3t2XzW\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;//d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n//\n// honorable mention:\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n//\n//note, when your function has asymptotes\n//, you may want to evade a divisionBy or LogarythmOf small numbers (epecially by 0).\n//for this [almostIdentity] is oftrmn a faster special subroutine fucntion\n//than offsetting all PRECISE asymptotes with an smin/smax.\n//see https://iquilezles.org/articles/functions/\n//BUT if you can predict all asymptotes PRECISELY (and if this is worth calculating)\n//, any smin(asymptiote) call may just look much smoother than smin(AlmostIdentity())\n//also, some asymptotes are nonlinear or even 3d planes.\n\n/**///--end__: analysis smin \n/**///--           \n/**///--start: analysis sabs smoothstep windowfunction hulls\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/**///--end__: analysis sabs smoothstep windowfunction hulls \n/**///--           \n/**///--start: pattern debug\n                               \n//todo,, wallpaper tiling\n                               \n//needed to debug complex (number) functions.\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\n                      \n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n \n\n#define sm(a,b)smoothstep(a-10./500.,a,b)\nfloat PatternCircles(vec2 p,float m//giraffe bubbles of\n){p.x-=m*.5*step(0.,sin(pi*p.y/m)) //https://www.shadertoy.com/view/MsSyRz\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n              \n/**///--end__: pattern debug\n/**///--\n/**///--start: pattern hash  \n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(v0 a){return vec3(a);}                        \nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(v0 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos2,p.zy),perm2(u5cos2,p.zx),perm2(u5cos2,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+      spd);b*=1.8;z*=1.5;p*=1.2\n//;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos2,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//voronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\n\n// Salt is added to limit the x,y values. No matter what you input,\n// it returns a float [0-5900]\n// may not be a great hash\nfloat salt(float seed){float a=mod(seed,5901.); //coords=vec3(vec2(seed(1.)),0)\n float b=mod(a,2.)==.0?-.01:.11;return a+4179./sqrt(a*5.)*b+1001.*a/seed;}\n      \n/**///--end__: pattern hash            \n/**///--\n/**///--start: pattern noise\n\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL. #version 120\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo without a division\nvec3 mod7(vec3 x){return x-floor(x*(1./7.))*7.;}\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec2 mod289(vec2 x){return  x-floor(x*(1./289.))*289.;}\nfloat mod289(float x){return x-floor(x*(1./289.))*289.;}\nvec3 permute(vec3 x){return mod289((34.*x+1.)*x);}//(34*x*34*x+x)mod 289\nfloat permute(float x){return mod289((34.*x+1.)*x);}\nvec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n      \n      \n//simplex noise:\nfloat snoise(vec2 v\n){const vec4 C=vec4(.211324865405187 //(3.-sqrt(3.))/6.\n                  , .366025403784439 //sqrt(3.0)*.5-.5\n                  ,-.577350269189626 //C.x*2.-1.\n                  , .024390243902439)//1./41.\n ;vec2 i=floor(v+dot(v,C.yy))\n ;vec2 x0=v-i+dot(i,C.xx)\n ;vec2 ii1=(x0.x>x0.y)?vec2(1,0):vec2(0,1)\n ;vec4 x12=x0.xyxy+C.xxzz\n ;x12.xy-=ii1\n ;i=mod289(i)\n ;vec3 p=permute(permute(i.y+vec3(0,ii1.y,1))+i.x+vec3(0, ii1.x,1))\n ;vec3 m=max(.5-vec3(dd(x0),dd(x12.xy),dd(x12.zw)),0.)\n ;m*=m;m*=m\n ;// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n ;// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n ;vec3 x=2.*fract(p*C.www)-1.\n ;vec3 h=abs(x)-.5\n ;vec3 ox=floor(x+.5)\n ;vec3 a0=x-ox\n ;//Normalise gradients implicitly by scaling m\n ;//Approximation of: m *= inversesqrt( a0*a0 + h*h )\n ;m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\n ;a0=vec3(a0.x*x0.x+h.x*x0.y,a0.yz*x12.xz+h.yz*x12.yw)\n ;return 130.*dot(m,a0);}\n     \n\nfloat snoise(vec3 v\n){const vec2 C=vec2(1,2)/6.\n ;const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy))\n ;vec3 x0=v-i+dot(i,C.xxx)\n ;vec3 g=step(x0.yzx,x0.xyz)\n ;vec3 l=1.-g\n ;vec3 j1=min(g.xyz,l.zxy)\n ;vec3 i2=max(g.xyz,l.zxy)\n ;vec3 x1=x0-j1+C.xxx\n ;vec3 x2=x0-i2+C.yyy\n ;vec3 x3=x0-D.yyy\n ;i=mod289(i)\n ;vec4 p=vec4(0)\n ;p=permute(p+i.z+vec4(0,j1.z,i2.z,1))\n ;p=permute(p+i.y+vec4(0,j1.y,i2.y,1)) \n ;p=permute(p+i.x+vec4(0,j1.x,i2.x,1))\n ;//Gradients: 7x7 points over a square, mapped onto an octahedron.\n ;//ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n ;float n_=1./7.\n ;vec3 ns=n_*D.wyz-D.xzx\n ;vec4 j=p-49.*floor(p*ns.z*ns.z)\n ;vec4 x_=floor(j*ns.z);\n ;vec4 y_=floor(j-7.*x_)\n ;vec4 x =x_*ns.x+ns.yyyy\n ;vec4 y =y_*ns.x+ns.yyyy\n ;vec4 h =1.-abs(x)-abs(y)\n ;vec4 b0=vec4(x.xy,y.xy)\n ;vec4 b1=vec4(x.zw,y.zw)\n ;vec4 s0=u3(floor(b0))\n ;vec4 s1=u3(floor(b1))\n ;vec4 sh=-step(h,vec4(0))\n ;vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy\n ;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww\n ;vec3 p0=vec3(a0.xy,h.x)\n ;vec3 p1=vec3(a0.zw,h.y)\n ;vec3 p2=vec3(a1.xy,h.z)\n ;vec3 p3=vec3(a1.zw,h.w)\n ;a0=taylorInvSqrt(vec4(dd(p0),dd(p1),dd(p2),dd(p3)))\n ;p0*=a0.x;\n ;p1*=a0.y;\n ;p2*=a0.z;\n ;p3*=a0.w\n ;vec4 m=max(.6-vec4(dd(x0),dd(x1),dd(x2),dd(x3)),0.)\n ;m*=m\n ;return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\n\n//fbm around 3d simplex  https://www.shadertoy.com/view/ldByDy\nfloat snoiseFbm(int octaves,float persistence,float freq,vec3 coords){\n float amp=1.,maxamp=0.,sum=0.;for(int i=0;i<octaves;++i){\n  sum+=amp*snoise(coords*freq);freq*=2.;maxamp+=amp;amp*=persistence;}\n return(sum/maxamp)*.5+.5;}\n      \n//Cellular noise (Worley noise) in 3D in GLSL.\n//returni F1 and F2 (closest and second closest)of Cellular noise (3er neighborhood)\n//subroutines\nvoid twosmolS(inout vec3 a,inout vec3 b,inout vec3 c\n){vec3 d=min(a,b);b=max(a,b);a=min(d,c);c=max(d,c);b=min(b,c);}\nvoid twosmolC(inout vec3 a\n){a.xy=(a.x<a.y)?a.xy:a.yx;a.xz=(a.x<a.z)?a.xz:a.zx;}\nvec2 twosmolE(inout vec3 a,vec3 b\n){a.yz=min(a.yz,b.xy);a.y=miv(vec3(a.yz,b.z));return a.xy;}\nvec2 twoSmallest(vec3 a,vec3 b,vec3 c\n){twosmolS(a,b,c);twosmolC(a);return twosmolE(a,b);}                      \nvec2 twoSmallest(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i\n){twosmolS(a,b,c);twosmolS(d,e,f);twosmolS(g,h,i)\n ;twosmolS(a,d,g);twosmolC(a)\n ;b=min(b,min(min(d,e),min(g,h)));return twosmolE(a,b);}                      \nvec2 twoSmallest(mat3 a,mat3 b,mat3 c\n){return twoSmallest(a[0],a[1],a[2],b[0],b[1],b[2],c[0],c[1],c[2]);}\n\nvec3 makeC(vec3 u,vec2 f,vec3 o,float g,vec3 j){u*=j.y\n ;vec3 x=f.x-g+j.x*(     fract(u)     -j.z)\n ;     u=f.y-o+j.x*(mod7(floor(u))*j.y-j.z);return x*x+u*u;}\n//above makeC() is for 2d, below makeC()&makeB() are for 3d\n//u is permuted hash\n//f,g,w is shift a along (sub)domain\n//o is heretic dark magic\n//j,k are modifiable scalars; j.x sets straightness, range [0..1]\nvec3 makeC(vec3 u,vec2 f,vec3 o,vec3 k,vec3 j){vec3 l=u*k.x   \n ;vec3 a=o  +j.x*     fract(l)        -k.z;\n ;vec3 b=f.x+j.x*mod7(floor(l)   )*k.x-k.z;\n ;vec3 c=f.y+j.x*     floor(u*k.y)*j.y-j.z; \n ;return a*a+b*b+c*c;}\nmat3 makeB(vec3 u,vec4 f,vec3 x,vec3 w,vec3 k,vec3 j\n){vec3 a=makeC(permute(u+w.x),f.wx,x,k,j)\n ;vec3 b=makeC(permute(u+w.y),f.wy,x,k,j)\n ;vec3 c=makeC(permute(u+w.z),f.wz,x,k,j)//3d has one more permute() iteration\n ;return mat3(a,b,c);}\n\n//j.x==straightmess[0..] j.y is like 1/7 j.z is like 1/6\nvec2 cellular(vec2 u,vec3 j\n){vec2 m=mod289(floor(u));u=fract(u)\n ;vec3 w=vec3(-1,0,1)\n ;vec3 v=vec3(-1,1,3)*.5\n ;vec3 r=permute(m.x+w)+m.y\n ;vec3\n  p=permute(r.x+w);vec3 a=makeC(p,u,v,v.x,j)\n ;p=permute(r.y+w);vec3 b=makeC(p,u,v,v.y,j)\n ;p=permute(r.z+w);     p=makeC(p,u,v,v.z,j)\n ;return sqrt(twoSmallest(a,b,p));}              \n//above is 2d, below is 3d vellular noise with 2 shortest distances in 3x neigborhood\nvec2 cellular(vec3 u,vec3 j \n){vec3 k=vec3(j.y,j.y*j.y,.5-j.y)    //this param comes with 2 derivatives\n ;     j=vec3(j.x,j.z,.5*(1.-j.z))//jitter and 1 other param (and one derivative of it)\n ;vec3 m=mod289(floor(u));u=fract(u)-.5\n ;vec3 w=vec3(-1,0,1)\n ;vec3 x=u.x-w;vec3 y=u.y-w;u=u.z-w\n ;vec3 p=permute(m.x+w)+m.y\n ;mat3 a=makeB(permute(p+w.x)+m.z,vec4(u,y.x),x,w,k,j)\n ;mat3 b=makeB(permute(p+w.y)+m.z,vec4(u,y.y),x,w,k,j)     \n ;mat3 c=makeB(permute(p+w.z)+m.z,vec4(u,y.z),x,w,k,j)\n ;return sqrt(twoSmallest(a,b,c));}\n\n// Periodic (tiling) 2-D simplex noise (hexa lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n// axis-aligned and stretched in the y direction for rectangular tiling.\n//\n// periods (p) should be EVEN integers\n// ODD periods for y will automatically be doubled.\n//\n// (rd) makes \"flow noise\" effects\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the uv\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n//\n//  return.yz are .xy derivatives\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise                \n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// TODO: One-pixel wide artefacts used to occur due to precision issues with\n// the gradient indexing. This is specific to this variant of noise, because\n// one axis of the simplex grid is perfectly aligned with the input x axis.\n// The errors were rare, and they are now very unlikely to ever be visible\n// after a quick fix was introduced: a small offset is added to the y coordinate.\n// A proper fix would involve using round() instead of floor() in selected\n// places, but the quick fix works fine.\n// (If you run into problems with this, please let me know.)\n\n      \n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p,float rot){\n#if 0\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;\n  u=4.*fract(u)-2.;\n  // (This vector could be normalized, exactly or approximately.)\n  return vec2(abs(u)-1.,abs(abs(u+1.)-2.)-1.);}\n#else\n  float u = permute(permute(p.x)+p.y)*.0243902439+rot;\n  u = fract(u) * 2.*pi; // 2*pi\n  return vec2(cos(u), sin(u));}\n#endif\n                      \nfloat NoiseNoDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec3 w=vec3(dot(rgrad2(vec2(iuw.x,ivw.x),rot),a)\n             ,dot(rgrad2(vec2(iuw.y,ivw.y),rot),b)\n             ,dot(rgrad2(vec2(iuw.z,ivw.z),rot),c))     \n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c));t*=t\n ;return 11.*dot(t*t,w);}\n//above and below are TAIL subroutines, wuith or without derivatives       \nvec3 NoiseDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec2 d=rgrad2(vec2(iuw.x,ivw.x),rot)\n ;vec2 e=rgrad2(vec2(iuw.y,ivw.y),rot)\n ;vec2 f=rgrad2(vec2(iuw.z,ivw.z),rot)\n ;vec3 w=vec3(dot(d,a),dot(e,b),dot(f,c))\n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c))\n ;if(t.x<0.){a.x=0.;a.y=0.;t.x=0.;}\n ;if(t.y<0.){b.x=0.;b.y=0.;t.y=0.;}\n ;if(t.z<0.){c.x=0.;c.y=0.;t.z=0.;}\n ;vec3 t3=t*t*t;t*=t;t*=t\n ;a=a*8.*t3.x;a=t.x*d-a*w.x\n ;b=b*8.*t3.y;b=t.y*e-b*w.y\n ;c=c*8.*t3.z;c=t.z*f-c*w.z\n ;return 11.*vec3(dot(t,w),a+b+c);;}\n\nvoid NoiseHead(vec2 u,inout vec3 x,inout vec3 y\n       ,inout vec2 d0,inout vec2 d1,inout vec2 d2\n       ,inout vec2 p0,inout vec2 p1,inout vec2 p2\n){u.y+=.001\n ;vec2 uv=vec2(u.x + u.y*0.5, u.y)\n ;vec2 j0=floor(uv)\n ;vec2 f0=fract(uv)\n ;vec2 j1=(f0.x>f0.y)?vec2(1,0):vec2(0,1)\n ;p0=vec2(j0.x-j0.y*.5,j0.y)\n ;p1=vec2(p0.x+j1.x- j1.y*.5,p0.y+j1.y)\n ;p2=vec2(p0.x+.5,p0.y +1.)\n ;j1=j0+j1\n ;vec2 i2 = j0 + vec2(1)\n ;d0=u-p0;d1=u-p1;d2=u-p2\n ;x=vec3(p0.x, p1.x, p2.x)\n ;y=vec3(p0.y, p1.y, p2.y);}\n\n//4 comboinations with rotation\nvec3 simplexRotD(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nvec3 simplexRotD(vec2 u,float rot\n){vec2 d0,d1,d2,p0,p1,p2;vec3 x,y;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)        //without TilingPeriod \n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nfloat simplexRot(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}   //without Detivatives               \nfloat simplexRot(vec2 u, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)       //without TilingPeriod\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}  //without Detivative   (.yz)\n//without rotation\nvec3  simplexRotD(vec2 u,vec2 p){return simplexRotD(u,p,0.);}//tiling derivative\nvec3  simplexRotD(vec2 u       ){return simplexRotD(u  ,0.);}//       derivative\nfloat simplexRot (vec2 u,vec2 p){return simplexRot (u,p,0.);}//tiling\nfloat simplexRot (vec2 u       ){return simplexRot (u  ,0.);}\n\n/**///--end__: pattern noise\n/**///--                         \n/**///--start: complex-number (including triginometry)\n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c22(c)-(c.a-c.b*i)\n#define c22(a)c4(anaa(a)).xy  //namespace conflict\nvec2 cs(v1 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(v0 a){return cs(vec2(a,a));}    \n                               \n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\nd000 ata(d000 a){v0 b=a.a*a.a+1.;v0 c=b*b;return d000(atan(a.a),a.a/b,-(b-2.)/b,2.*a.a*(a.a-4.)/(b*c));}\nd00  ata(d00  a){v0 b=a.a*a.a+1.;v0 c=b*b;return d00 (atan(a.a),a.a/b,-(b-2.)/b);}\nd0   ata(d0   a){v0 b=a.a*a.a+1.;v0 c=b*b;return d0  (atan(a.a),a.a/b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}\n\n/*\nd00 atand(d00 x,d00 y){//return atan(y,x);//2 branches, goes full circle.\n if(x.a >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}/**/\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\nv0 su(v1 a){return a.x-a.y;}\n\n#define le(a) sqrt(dd(a))\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2  \n//real and imaginary parts for polar z\nv0 arg(v1 a){return atan(a.y,a.x);}\nv1 p2c(v1 a){return v1(co(a.x),si(a.x))*a.y;}     //return carthesian of polar\nv1 c2p(v1 a){return v1(arg(a),le(a));}            //return polar      of carthesian\nv0 real(v1 z){return p2c(z).x;return z.s*co(z.t);}//return real       of carthesian\nv0 imag(v1 z){return p2c(z).y;return z.s*si(z.t);}//return imaginary  of carthesian\n\n//2 common subroutines:\nv1 crCo(v1 a){return sqrt(length(a)+c22(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nv1 ciCo(v1 u,v1 z,v0 r){return v1(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//[param2&2*x] == complex number arithmetic (annotations updated in 2022-09)\n//v1 c2p(v1 a){return v1(arg(a),lenth(a));} is how i store polar coordinates in a vec2==v1\n//a.x==angle==argument , a.yzw = length\n//if [a] is a vec4==v3, it does an operation with multiple complex numbers that all have the same angle, and i call this [parallel complex numbers, they are colinear in hyperbolic space] and this made sense to define as subroutine, i suppose.\n//\n//[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\n//see https://en.wikipedia.org/wiki/Principal_branch\nv1 sqc(v1 a){v0 n=a.x+length(a);return v1(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i, == complex square root (a.x must be positive!!!)\nv3 sqc(v3 a){v3 c=v3(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\n//v1 sqc(v1 z){v1 c=sqrt((length(z)+c22(z.x))*.5);c.y*=sign(z.y);return c;}//this alternative has significantly worse precision near [.y=0.&&x>0]\nv1 po2c(v1 c){v1 d=c*c;return v1(d.x-d.y,2.*c.x*c.y);}//v1 po2c(v1 a){return muc(a,a);return v1(sub(a*a),2.*a.x*a.y);}//==complex square\nv1 po3c(v1 z){v0 p=z.x*z.x,q=z.y*z.y;return z*v1(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i, ==complex cube\nv1 recc(v1 a){if(a.x==0.)return v1(1e10);return c22(a)/dd(a);}//reciprocal/inverse of z ; 1/z=(a-b*i)/(a*a+b*b),inverse of z;\nv1 lgc(v1 a){a=c2p(a);a.x=log(a.x);return a;}//return v1(log(dd(a))*.5,arg(a)); == complex natural logarythm\nv3 lgc(v3 a){return v3(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nv1 suc(v1 a,v1 b){return a-b;}v1 adc(v1 a,v1 b){return a+b;}///complex addition=complexSum is trivial\nv1 muc(v1 a,v1 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multplication\nv1 muc(v1 a,v1 b,v1 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex multimplication of 3 factors\nv1 muc(v3 a){return muc(a.xy,a.zw);}//parallel mult\nv1 dic(v1 a,v1 b){if(a.x==0.)return v1(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nv1 lgc(v1 a,v1 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z, b is a complex numbr;\nv1 lgc(v1 a,v0 c){return v1(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nv1 exc(v1 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i)) == complex exp(c) == NATURAL exp() (inverse to natural log)\n//v1 lgc(v1 a,v0 c){a=c2p(a);return v1(log(a.x),a.y+c*tau);}//should be the same!\nv1 poc(v1 a,v1 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nv1 poc(v1 w,v1 z,v0 c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nv1 lgc(v1 a,v1 b,v0 c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nv1 wrtc(v1 a,v1 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nv1 wrtc(v1 a,v1 b,v0 c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n\nv1 sic(v1 z){return .5*cs(z.x).yx*(exp(z.y)+c22(exp(-z.y)));}//v1 sic(v1 z){return v1(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  v1 sic(v1 c){v1 d=exp(c2(c.y));return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 si2c(v1 c){v1 d=v1(exp(c.y),1);return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 coc(v1 z){return .5*c22(cs(z.x))*(exp(z.y)+c22(exp(-z.y)));}\n\n//obsoleted v1 coc(v1 z){ return v1(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted v1 coc(v1 c){v1 d=exp(c2(c.y));return v1(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nv1 ta2c(v1 c){v1 d=exp(c22(c.y));v0 e=cos(c.x),s=(d.x-d.y)*.5;return v1(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nv1 tac(v1 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nv1 cotc(v1 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nv1 sihc(v1 z){return .5*cs(z.y)*(exp(z.x)+c22(exp(-z.x)).yx);}//v1 sinh(v1 z){ return 0.5*v1((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//v1 sinh2c(v1 z){z=c22(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nv1 cohc(v1 z){return coc(c22(z.yx));}//v1 cosh(v1 z){ return v1(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 v1 tahc(v1 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 v1 cothc(v1 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(v1 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 v1 cschc(v1 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nv1 arsic(v1 z){return c22(lgc(perp(z)+sqc(c22(po2c(z.yx)))+v1(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//v1 arsic(v1 z){v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(-z.y+a.x,z.x+a.y));return v1(a.y,-a.x);}\nv1 arcoc(v1 z){return-c22(lgc(z+c22(sqc(po2c(z.yx)+v1(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//v1 arcoc(v1 z){ v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(z.x+a.y,z.y-a.x));return v1(-a.y,a.x);}\nv1 csec(v1 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nv1 ccsc(v1 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nv1 arcotc(v1 z){v0 r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((v3(z.yx,-z.yx)+v3(r,0,r,0)).yxzw/r)))*.5;}//v1 arcotc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=lgc(v1(p+q-z.y,-z.x)/r);v1 b=lgc(v1(p+q+z.y,z.x)/r);return v1(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nv1 artac(v1 z){return sub2(c4(lgc(v3(1,0,1,0)-c22(z.yx).xyxy).yxwz))*.5;}//v1 artac(v1 z){ v1 a=lgc(v1(1.0+z.y,-z.x));v1 b=lgc(v1(1.0-z.y,z.x));return v1(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nv1 arcsec(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(sub2(c4(v3(z,sqc(ciCo(u,z,r)).yx)))).yx)+v1(0.,log(r));}//v1 arcsec(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(z.x-a.y,a.x-z.y));return v1(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nv1 arccsc(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+v1(0.,log(r));}//v1 arccsc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(a.x+z.y,a.y+z.x));return v1(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nv1 arcsch(v1 z){v1 u=z*z;v0 r=su(u);return lgc(c22(z)+sqc(ciCo(u.yx,z,r)))-v1(0,log(r));}//v1 arcsch(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r+p-q,-2.0*z.x*z.y));a=lgc(v1(a.x+z.x,a.y-z.y));return v1(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nv1 arsinh(v1 z){return lgc(z+sqc(po2c(z)+v1(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nv1 arcosh(v1 z){return lgc(z+muc(sqc(z.xyxy+v3(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nv1 artanh(v1 z){v0 r=1.-su(z*z);z*=2.;return .5*lgc(-v1(r,z.y)/(r+z.x));}//v1 artanh(v1 z){v0 r=z.x*z.x+z.y*z.y;return lgc(v1(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nv1 arcoth(v1 z){;v0 r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(v1(r,z.y)/(r+2.+z.x));}//v1 arcoth(v1 z){ v0 r=z.x*z.x+z.y*z.y;return lgc(v1(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nv1 arsech(v1 z){v0 r=su(z*z);return lgc(c22(z)+muc(sqc(v3(-r,0,r,0)+c22(z).xyxy)))-v1(log(r),0);}//ok, tested by-ollj\n                \nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a;}                         \n                \n//maybe use a different complex number arithmetic visualizer like\n//https://www.shadertoy.com/view/NtcBDn\n\n\n/**///--end__: complex-number (including triginometry)\n/**///--\n/**///--start: sort\n                               \n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){const float twothirds=2./3.\n   ;if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\nvec3 getPos0V(vec3 a){vec3 r=vec3(0);r[getPos0(a)]=1.;return r;}\nvec3 getPos1V(vec3 a){vec3 r=vec3(0);r[getPos1(a)]=1.;return r;}\n//may wanrt to use getPos0() instead of getPosSmall()\nint getPosLarge(vec3 a//return position of largest  value [0..2]          \n){if(a.x>a.y){if(a.x>a.z)return 0;if(a.y>a.z)return 1;return 2\n       ;}else{if(a.y>a.z)return 1;return 3;}}\nint getPosSmall(vec3 a//return position of smallest value [0..2]          \n){if(a.x<a.y){if(a.x<a.z)return 0;if(a.y<a.z)return 1;return 2\n       ;}else{if(a.y<a.z)return 1;return 2;}}\nint getPosMid(vec3 a//return position of middle value [0..2]          \n){if(a.x<a.y){if(a.y<a.z)return 1;if(a.z<a.x)return 0;return 1  \n       ;}else{if(a.z<a.y)return 1;if(a.x<a.z)return 1;return 3;}}\nvec3 getPosLargeV(vec3 a){vec3 r=vec3(0);r[getPosLarge(a)]=1.;return r;}//return vector that indicates smalles value with a [1]   \nvec3 getPosSmallV(vec3 a){vec3 r=vec3(0);r[getPosSmall(a)]=1.;return r;}//return vector that indicates smalles value with a [1]\n//vec3 getPosMidV  (vec3 a){return vec3(1)-getPosLargeV(a)-getPosSmallV(a);}//dumb and slow but works\n      \n\n      \nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n\n                 \n//project point [a] onto line trough vecN(0) and vecN([b])  b!=0.\n//project(u-a,b-a)+a((project u on line(a,b)\n\n//return [0..1] for projection being on [a..b]\nv0 project0(v1 a,v1 b\n){float c=dd(b)\n ;if(c==0.)return -1.//projecting onto a point is nonsense, [-1] tends to be parsed as a miss\n ;return dot(a,b)/dd(b);}\n      \n\n\n//(project(o-p1,p2-p1)+p1)-o//==vector from o to projection of o on on line\n//project(p-a,b-a)+a//projected point (p) on line (a,b) (not clamped)\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest vector from point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\nv1 projectBary(v1 a,v1 b,v1 c){return b*dot(a,b)/dd(c);}//skewed mirror\n      \n     \nd3 suab(d3 p,v0 s){return su(ab((p)),s);}\nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\nd33 suab(d33 p,d33 s){return su(ab((p)),s);}           \nd22 suab(d22 p,d22 s){return su(ab((p)),s);}\nd11 suab(d11 p,d11 s){return su(ab((p)),s);}\nd00 suab(d00 p,d00 s){return su(ab((p)),s);}\nd333 suab(d333 p,d333 s){return su(ab((p)),s);}           \nd222 suab(d222 p,d222 s){return su(ab((p)),s);}\nd111 suab(d111 p,d111 s){return su(ab((p)),s);}\nd000 suab(d000 p,d000 s){return su(ab((p)),s);}\n//suab extendsions have been frustrating and halted                    \n                      \nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z),suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//c22 suab(c22 p,v2 s){return c22(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\n\n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return mi(b.z-b.x,b.y-b.w)<mi(b) ;}\n      \n/**///--end__: common aliases\n/**///\n/**///--start: linear hulls smoothstep\n\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\n      \n#define fsaa 2.\n//#define fsaa 2, (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n/**///--end__: linear hulls smoothstep\n/**///\n/**///--start: Reflect and rotate            \n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\nv1 r4(v1 r){return v1(r.y,-r.x);}//perpendicular quater rotation\n                      \nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\n\n//return distance to 1/24th rotated axis (for super fast arrow shape)\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\n\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(v0 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(v0 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n        \n//modify inputs to abs(.x) == mirror vertically\nvoid mirror(inout vec2 u,inout vec2 m){m.x=abs(m.x);u.x=abs(u.x);}\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r1(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n//float angleBetween(v1 a,v1 b){return acos(dt(a,b);}\n\n//Quaternion\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dd(a)! \nv3 qn(v3 q){return q/dd(q);}\n/**/\n      /*\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n*/\n                      \n/**///--end__: Reflect and rotate  \n/**///--\n/**///--start: analytic closed-form  solutions \n\n\n//(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}//used to get closest point on ellipse: https://www.shadertoy.com/view/XttyWN\n\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  suv(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n \n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n/**///--end__: analytic solutions  \n/**///--\n/**///--start: tracing and project (euclidena and bary)\n\n\n//--start: barycentric\n\n//return transposed 2x3 matrix (vector form)\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant\nfloat c2bdetR(vec3 X,vec3 Y){return suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec3 X,vec3 Y){return 1./c2bdetR(X,Y);}     \nfloat c2bdetR(vec2 a,vec2 b,vec2 c){return c2bdetR(transp23);}\nfloat c2bdet (vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//c2bdet  for cached   division (by fragment shader) (more common)\n//c2bdetR for deferred division (intersectB2b() carthesian intersection)\n//\n//return barycentric of carthesian point (t) over triangle (a,b,c)==(X,Y)\n#define c2bCore vec4 c=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*(t-vec2(X.z,Y.z)).xyxy;c.xy=vec2(suv(c.xy),suv(c.zw))\nvec3 c2b(vec2 t,vec3 X,vec3 Y,float d){c2bCore\n    ;c.xy*=d;return vec3(c.xy,1.-c.x-c.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}\n\n//float suv(vec2 a){return a.x+a.y;}\n//float suv(vec3 a){return a.x+a.y+a.z;}\n\n//barycentric tracing is great, it gives you a frustrum for free!\n\n//barycentric lineLine intersection CORE (in barycentric coords);\n//functionally identical to Intersection of ray(o,t) with RaySegmentLine(a,b)\n//but division is deferred AFTER checking if it hits\n//barycentric triangle corners are o=vec3(1,0,0)   a=vec3(0,1,0)   b=vec3(0,1,0)\n//carthesian  triangle corners are o=vec2(X.x,Y.x) a=vec2(X.y,Y.y) b=vec2(X.z,Y.z)\n//t=barycentricRayTarget   = c2b(carthesianRayTarget,X,Y,d)\n//d=barycentricDeterminant = c2bdetR(X,Y)\n//very deferred division\nvec3 intersectB2bN(vec3 t,float d\n){t.y=t.y/(d-t.x);return vec3(0,t.y,1.-t.y);}//intersection just scales a ratio\nvec3 intersectB2b(vec3 t,vec3 X,vec3 Y,float d\n){//if(d==0.)return vec3(1,0,0)//triangle (o,a,b) is a line, therefore o is on line (ab)\n ;if(t.x==d)return vec3(1,0,0)//poorly evade division by 0 case (of parallel lines)\n ;//we can do cases before the first division\n ;//if( t.x             >abs(d))return vec3(1,0,0)//miss when looking away\n ;//the one above is only needed when one of the 2 below is NOT active\n ;if((t.x+t.y)*sign(d)>abs(d))return vec3(1,0,0)//miss <a (rayRay intersection)\n ;if(0.  >t.y *sign(d)       )return vec3(1,0,0)//miss >b (rayRay intersection)\n ;//set both above for (a<x<b) raySegment intersection\n ;//below is identical to above, BUT each side of (ab) may behave differently.\n ;if(d<0.){\n  ;//if(t.x<d    )return vec3(1,0,0)//miss when looking away from sideA\n  ;//the one above is only needed when one of the 2 below is NOT active\n  ;//if(t.x<d-t.y)return vec3(1,0,0)//miss <a                from sideA\n  ;//if(0. <  t.y)return vec3(1,0,0)//miss >b                from sideA\n ;}else{//if(d>0.){\n  ;//if(t.x>d    )return vec3(1,0,0)//miss when looking away from sideB\n  ;//the one above is only needed when one of the 2 below is NOT active\n  ;//if(t.x>d-t.y)return vec3(1,0,0)//miss <a                from sideB\n  ;//if(0. >  t.y)return vec3(1,0,0)//miss >b                from sideB \n ;}\n ;//if you only need a boolean if it hits, return it here, and skip the only division\n ;return intersectB2bN(t,d);}\n //;t.y=t.y/(d-t.x)//division deferred AFTER tracing if it hits\n //;return vec3(0,t.y,1.-t.y);}\n//wrappers:\nvec3 intersectB2b(vec3 t,vec3 X,vec3 Y){return intersectB2b(t,X,Y,c2bdetR(X,Y));}\nvec3 intersectB2b(vec3 o,vec3 t,vec3 a,vec3 b,vec3 c// intersect segment (ab)\n){vec3 X=vec3(o.x,a.x,b.x),Y=vec3(o.y,a.y,b.y)\n ;return intersectB2b(t,X,Y,c2bdetR(X,Y));}\n//carthesian lineLine intersection (in barycentric coords);\nvec2 intersectB2c(vec2 o,vec2 t,vec2 a,vec2 b\n){//identical to: g=gLLxXP(a,b,o,t);if(sat(g)==g)return a-(a-b)*g\n ;vec3 X=vec3(o.x,a.x,b.x)\n ;vec3 Y=vec3(o.y,a.y,b.y)//barycentrics of triangle (0,a,b)\n ;float d=c2bdetR(X,Y)//barycentric triangle determinant\n ;if(d==0.)return o//triangle (o,a,b) is a line, therefore o is on line (ab)\n ;c2bCore;//barycentric to carthesian BUT c.z is irrelevant \n ;c.xyz=intersectB2b(c.xyz,X,Y,d)//barycentric tracing\n ;return b2c(c.xyz,X,Y);}//outout as carthesian\n \n//N version knows that it hits, (within fustrum culling)\nvec2 inB2c2N(vec2 o,vec2 t,vec2 a,vec2 b\n){vec3 X=vec3(o.x,a.x,b.x),Y=vec3(o.y,a.y,b.y)\n ;c2bCore;return b2c(intersectB2bN(c.xyz,c2bdetR(X,Y)),X,Y);}\n\n//return 3 squared lengths of triangle sides of triangle (a,b,c)\nvec3 getSqoaredLengths(vec2 a,vec2 b,vec2 c){return d3d(a-b,b-c,c-a);}\n//return SQUARED length of vector (p) in barycentric coordinates\n//t=getSqoaredLengths(a,b,c) is intended to be buffered\nfloat lengthBary(vec3 p,vec3 t){return -suv(t*p.yxx*p.zzy);}\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Distance_between_points               \n\n     \n//shortest carthesian distance may be different than euclidean. even to the 3 points??\n//anyways, this is buggy, and i cant find the bug.\n\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\n      \nfloat segmentB(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\n\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float cd=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //c2bdet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //c2bdet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,cd)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segmentB(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n /*\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{/**/\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segmentB(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}\n  //min of 3 line distances only inside the triangle\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}\n/**///--end__: barycentric\n \n//lineLineIntersection (carthesian 2d)\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection of lines AB and CD; http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x //==perpdot() function (same order of operands?)\n ;if (dotperp==0.)return A//worksave for parallel case\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x //==perpdot() function (same order of operands?)\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return iAlong of segment(AB) with ray(CD) (beware that segment comes first!)\n//asserts that ray points towards segment !!! (that needs a second pass with swapped parameters)\n//if (sat(iAlong)==iAlong)//ray(CD) intersects the segment(AB)\n//if (sat(iAlong)>=iAlong)//ray(CD) intersects the ray(AB)\n//intersectionPoint == A+B*iAlong\nv0 gLLxXP(v1 A,v1 B,v1 C,v1 D\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 e=dot(d,perp(b)) //==perpdot() function (same order of operands?)\n ;if(e==0.)return -.1//worksave for parallel case\n ;v0 t=-dot(c,perp(d))/e\n ;return t;}//gLLxXP(a,b,o,t) tests if ray hits segment (asserting way looks towards segment)\n//intersection points:\n\nvec2 mirror(vec2 o,vec2 a,vec2 b){ //return o, mirrored on ab\n ;vec2 m=project(o-a,b)+a-o\n ;return o+m*2.;}\n\n//mirror o along the axis (x,a+(b-a)*.5) == sqap 2 parycentric components\nvec3 mirrorBaryYZ(vec3 o,vec2 a,vec2 b,vec2 c){ //return o, mirrored on ab (triangle abc)\n ;return o.yxz\n ;//vec2 ass=gLLxX(o,o+b-a,a+(b-a)*.5,c)//hard and dumb carthesian within bary\n ;//return o+(ass-o)*2.//hard and dumb carthesian within bary\n ;}\n\n//mirror o along the axis (p2,p1)\nvec3 mirrorBaryZ(vec3 o){return vec3(o.xy+o.z,-o.z);}\nvec3 mirrorBaryY(vec3 o){return mirrorBaryZ(o.xzy).xzy;}\nvec3 mirrorBaryX(vec3 o){return mirrorBaryZ(o.zyx).zyx;}\n\n//vec2 or=b2c(oo-vec3(-1,0,1).xyz,p2,p0,p1)//third rotation barycentric (but around what point?)\n//barycentrically rotate around vec3(0,0,1) by N/6 full rotations\nvec3 r16bary(vec3 o){return mirrorBaryX(o).yxz;}//oo=r16bary(oo-vec3(1,-1,0))\nvec3 r56bary(vec3 o){return mirrorBaryY(o).yxz;}//oo=r56bary(oo-vec3(0,1,-1))\nvec3 r36bary(vec3 o){return mirrorBaryZ(o).yxz;}//oo=r36bary(oo-vec3(1,-1,0))\n\n//return how far (p) is in front of ray/normal (ut), [>0],or on (u)[=0], or behind (u)[<0] (along the ray)\nfloat isInfront(vec2 u,vec2 t,vec2 p){return dot(p-u,t-u);}\n//isInfront doesnt care for zFar,isWithin asserts (t] to be zfar\n//use isWithin to check if a lineLineIntersection is within a segment.   [<]0for false, >=0 true\nfloat isWithin(vec2 u,vec2 t,float r\n){if(r>=0.){\n ;if(dd(t-u)<=r*r)return r;\n };return -1.;}\n//above already has a cached dotproduct.\nfloat isWithin(vec2 u,vec2 t,vec2 r){r.x=isInfront(u,t,r);return isWithin(u,t,r.x);}\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his MIT licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n//The MIT License\n//Copyright Â© 2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 vv0,vec3 vv1,vec3 vv2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=vv0-vv1\n ;vec3 b=vv2-vv0\n ;vec3 p=vv0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright Â© 2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(miv(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n// Slightly improved version of a Trapezoid primitive without flicking.\nfloat sdTrapezoidFixed(vec2 u,vec2 a,vec2 b,float ra,float rb\n){u-=a;b-=a;float c=dd(b)\n ;a=vec2(abs(dot(perp(u),b))/sqrt(c),dot(u,b)/c)\n ;b.x=rb-ra;b.y=sat((b.x*(a.x-ra)+a.y*c)/(b.x*b.x+c))\n ;vec4 r=vec4(ma0(a.x-((a.y<.5)?ra:rb)),abs(a.y-.5)-.5,a.x-ra-b.y*b.x,a.y-b.y)\n ;a.x=sign(mav(r.zy));r*=r;r.yw*=c;r.xz+=r.yw\n ;return a.x*sqrt(miv(r.xz));}//https://www.shadertoy.com/view/wtSyWc\n\n      \n/**///--end__: euclidean tracing\n/**///--\n/**///--start: AD-/mercury.sexy/hd_sdf\n\n//SIMPLE old source lib of mercury.sexy/hd_sdf is: https://www.shadertoy.com/view/Xs3GRB\n//Below are translations of the hg_sdf library into a compressed AND generalized form\n//to be more parametic/modular/pipelined\n//to use the above [Derivative Arithmetic] with hg_sdf\n//\n//mostly just in prefix-notation, but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics/libraties.\n//\n//note: euclidean tracing [line-line-intersection] is needed for some shapes here.\n                                 \n//mod()-extensions must be on top of all hg_sdf unions, that include mod() (which is almost all of them)\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefit from my improved pmod() code\n\n//pmod() got killed by su() incompatibility\n//#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\n////frflpm(v00,c00)  frflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)  //high domain su() incompatibility\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n                      \n//float ma(vec4 a){return 0.;}\n\nconst vec1 _1=.57735026919; // sqrt(3)/3.\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\n     /* killed by incompatibility                 \nfloat Blob(vec3 p){p=abs(p);p=mix(p,p.yzx,step(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n/**/\n#define fPlane(p,n,d) ad(dt(p,n),d)\n      \n      \n      \nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz continuity.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\n/*  old struct fr() incompatibility\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fr(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}*/\n\n           \n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\n\nconst float eRm=.0001;\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n\n//https://en.wikipedia.org/wiki/Moss%27s_Egg\n#define EarVagEgg moss\n#define CylEarVagEgg cylMoss\n//moss() is still far from standardized. rac is the central radius, should be parametric.\nfloat moss(vec2 u,vec3 m//m.x+m.xy<=1. is relevant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (lineInfbbb(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(lineInfbbb(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //cylMoss() is capped cylinder to extrude it to 3d.\nfloat moss(vec2 u,vec2 m){return moss(u,vec3(m,mix(.5,3.,sin(1.)*.5+.5)));} //ain(1.) was iTime\n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(moss(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\n//cylMoss() is capped cylinder to extrude it to 3d.\nfloat cylMoss(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02);}\n//todo lathe this one for a 3d ear-shape\n\n//distance from (u) to lenss nut hourglass (rd) (radius,circleCenterDistances)\nfloat vesica(vec2 u,float r,float d\n){u=abs(u);float b=(r*r-d*d);vec2 a=vec2(u.y*d,u.x+d);a*=a*sign(a)\n ;return((a.x/b>a.y))?length(u-vec2(0,sqrt(b)))*sign(d)\n                     :length(u+vec2(d,0))-r;}//https://www.shadertoy.com/view/XtVfRW\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat sdHorseshoe(vec2 p,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;p.x=abs(p.x)\n ;float l=length(p)\n ;p=mat2(-c.x,c.y,c.y,c.x)*p\n ;p=vec2((p.y>0.)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l )\n ;p=vec2(p.x,abs(p.y-r))-w.xy\n ;return length(max(p,0.)+min(mav(p),0.))   -w.z;\n ;//return length(ma0(p))+mi0(mav(p))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n\n      \n                      /*\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n/**/\nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}  \n\n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n\n){float s=r/n\n ;float u=b-r\n ;return mi(mi(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\n      \n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n\n\n/**///--end__: AD mercury.sexy/hd_sdf\n/**///--\n/**///--start: projections\n                      \n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv22 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=vec2(0)//-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*1.)//autopilot //*iTime\n ;m=vec2(1)//mx(n,m,step(0.,iMouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v22(pos,dir);}\n\n//Phong+debugPlanes\n//todo (fix df() nonsense\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n                      \n                      \n/**///--end__: projections  \n/**///--\n/**///--start: AD Superprims\n      \nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n//odsoleted by cir()\n/*\n#define abm(a,b) (abs(a)-b)  //ditance taxicap   -b\n#define lbm(a,b) (length(a)-b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))   //==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a)) //i am not convinced by this one\n//#define box(a,b) roundit(abm(a,b))\n/**/\n      \n//cir()  return distance of (u) to (rounded) box/circle/AxisAlignedLineSegment\n//yes, thats a lot of basic shapes\n//called cir() because all lowest LOD are boxes.\n//cirS() seperates polynomials to allow to delay the sqrt() \n//       of ALL boxes with the same thickness (if tree-branch-thicknesses are uniform)\n//       by getting sqrt(min(multiple squared values))\n//cirS() header exists with and without stretching(&automatic offset)\n//\n//u=uv point\n//b.x=thickness\n//b.y=cornerRoundness [0..1] interpolates between circle and boxRounded\n//lod=LoD lod==0 is always a square\nvec2 cirCore(vec2 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\nvec2 cirCore(vec3 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\n\n//cir header without stretch\nvec2 cirS(vec2 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\n\n//cir header with stretch option\n//s=size stretch\n//positibes are useful for segments/boxes\n//negative inputs create ray/wedge (wedge interiors (2 negative domains) are only good within +-b.x)\n//s=vec2(0,-1) creates an upwards ray, af moves the base up, till vec2(0) touches the bottom\n//s=vec2(1,0) stretches by 1 along .x and moves to the right till vec2(0) is on the surface.\n//any s>0 will create a line segment, where vec2(0) is on the surface, iff one other domain of s==0\nvec2 cirS(vec2 u,vec2 b,float l,vec2 s\n){bvec2 e=lessThan(s,vec2(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;e=greaterThan(s,vec2(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l,vec3 s\n){bvec3 e=lessThan(s,vec3(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;if(e.z){u.z-=b.y*.5;s.z=0.;u.z=min((u.z),0.);}\n ;e=greaterThan(s,vec3(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;if(e.z)u.z-=(s.z+b.y)*.5 \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\n\nfloat cir(vec2 u,vec2 b,float l,vec2 s){u   =cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec2 u,vec2 b,float l       ){u   =cirS(u,b,l  );return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l,vec3 s){u.xy=cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l       ){u.xy=cirS(u,  b,l);return more(u.x,sqrt(u.x),0.)+u.y;}\n\n//without LoD (default to 1.)\nfloat cir(vec2 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec2 u,vec2 b,vec2 s){return cir(u,b,1.,s);}\nfloat cir(vec3 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec3 u,vec2 b,vec3 s){return cir(u,b,1.,s);}\n\n//without lod & with maximum roundness (b and s swapped to avoid namespace conflict with self)\nfloat cir(vec2 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec2 u,float b,vec2 s){return cir(u,vec2(b,1.),s);}\nfloat cir(vec3 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec3 u,float b,vec3 s){return cir(u,vec2(b,1.),s);}\n//cir was tested in 2d, but 3d may have typos?)\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat horseshoe(vec2 u,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;float circle=length(u)-w.z\n ;u.x=abs(u.x)\n ;u=mat2(-c.x,c.y,c.y,c.x)*u\n ;float l=length(u)\n ;u=vec2((u.y>0.)?u.x:l*sign(-c.x),(u.x>0.)?u.y:l)\n ;u=vec2(u.x,abs(u.y-r))-w.xy;\n ;return length(max(u,0.))+ min(0.,max(u.x,u.y))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n      \n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=vec2(0)//iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1]);y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(mav(dt(p,y))-o.x*3.,sqrt(miv(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\n                      \nstruct v14{float a;vec4 b;};\n                      \nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//guessing this was what this one does\n                      \nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=.5 //iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n                      \n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n             \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\n\n                      //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r){return max(box(u,vec3(r)),fOctahedron(u,r));}\n\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\n //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n                      \n/**///--end__: AD Superprims\n/**///--\n/**///--start: Glyphs\n\nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n                      \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n/**///--end__: Glyphs\n/**///--\n/**///--start: AD march RayMarchingPrimitivesBasic                 \n                      \n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);}\n\n//#u,o,t) distance between (u) and segment  from   (o) to     (t)   (strethed dot always does sqrt)\n//    ray(u,o,t) distance between (u) and ray      from   (o) trough (t)   \n//   line(u,o,t) distance between (u) and line     though (o) trough (t)  \n//    ray(u)     distance between (u) and ray      from (0,0) trough (0,1) \n#define segment2(a,c,d) dd(su(a,mu(c,d(di(dt(a,c),dd(c))))))      \n#define segments(u,o,t,d) (segment2(su(u,o),su(t,o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n#define    line(u,o,t) sqrt(segments(u,o,t,nul))\n#define rAy(c) float ray(c u,c o,c t){if(dot(u-o,t-o)<0.)return length(u-o);return line(u,o,t);}\nrAy(v0)rAy(v1)rAy(v2)rAy(v3)\nfloat ray(v1 u){if(u.x>0.)return length(u);return u.y;}   \n\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\n/**///--end__: march RayMarchingPrimitivesBasic\n/**///follows:\n/**///--start: march bezier \n\n//[follows], because segment() is special case of bezier()\n   \n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n                      \n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b));}\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L){v1 l=p2-p0;float s=L*L//https://www.shadertoy.com/view/4ltyWr\n ;return .5*((p0+p2)+sqrt(max(0.,s-dot(l,l)))*sign(L)*norma(v1(-l.y,l.x)));}\n\n/**///--end__: march bezier \n/**///--\n/**///--start: RE mach RayMarchingPrimitivesBasic               \n\n                           \n\n\n//c.xy=sin/cos of angle. r is the radius //uppr segment is always round\nfloat pieSlice(vec2 u,vec2 c,float r //a simple packman\n){u.x=abs(u.x)\n ;v0 l=length(u)-r\n ;v0 m=length(u-c*clamp(dot(u,c),0.,r) )\n ;return max(l,m*sign(c.y*u.x-c.x*u.y));}//https://www.shadertoy.com/view/3l23RK\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he\n){vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dd(k2), 0., 1. );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0\n   ;return s*sqrt( min(dd(ca),dd(cb)));}//https://www.shadertoy.com/view/MlycD3\n\n//polygon distance does crossingCumbers, has better (rounded) interios than windingnumbers.\nconst int N = 5;\nfloat sdPoly(vec2[N] v, in vec2 p\n){const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }return s*sqrt(d);}//https://www.shadertoy.com/view/wdBXRW\n      \n/**///--end__: RayMarchingPrimitivesBasic\n/**///--\n/**///--start: Relativity\n\n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\nint nextMat;\nint rayMat;\nint rayObj;\nfloat matSize;\nfloat lastrDist;\nfloat lastrDistObj;\nvec4 volumetricCol;\n\n//camera buffer data of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer)\n//- 0<=x<Resolution.xy\n#define RePos   0.  \n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n//ReTime.xyzw store the averages of the (up to) most recent 2,4,8,16  iTimeDelta\n//ReTimE.xyz  store the averages of the (up to) most recent 32,64,128 iTimeDelta\n//ReTimE   .w stores relativistic cameraTime, if (.w<0) time is paused\n#define ReTime  5.  \n#define ReTimE  6.  //\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\n#define ReEdit  9.  //not yet used by Image\nfloat varWdth=1.; //scale up visually\n\n//relativity made compatible: ?\n//RE7 uses a lot of structs in arrays.\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays struct params\n//(arrays of struct params, addressed by struct enum) \n//objectOfStruct.param -> param[objectOfStruct]\n//this mage Re7 gles100 compatible, but now we need an enum foreach object.\n#define objNum 7\n//for below object properties;\nvec4 [objNum] objRot;//rotation\nvec3 [objNum] objPos;//position\nvec3 [objNum] objVel;//velocity\nvec3 [objNum] objSca;//scale\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n\n//float[objNum] objRad;//radius optimization\n#define numLights 3\nvec4 [numLights] oliCol;//colorIntensity;\nvec3 [numLights] oliPos;//position\nfloat[numLights] oliHal;//HaloResult\n//float[numLights] oliSiz;//size\n//lights have no labels\n\n//some global accumulators (some reset each frame, some dont)\n//float mGI;//avccumulator for globalIllumination?\nfloat lorentzF;\n//mat3x3 LZLgthContract;\nvec3 pos; //campos.xyz\nvec3 dpos;//relevant for each pixel of [RE] and [Image] \nfloat playerTime;\n//volume marching accumulator, used for blackHoleAccretionDisk\nfloat vma=0.; \nint curObj = 0;\nint minObjDepth=-1; \n\n\n//point,radius\nv0 sphere(v2 u,v0 r){return length(u.xyz)-r;}\n//point,size\nv0 cube(v2 u, v0 s){return mav(abs(u)-s);}\nv0 box (v2 u, v2 s){return mav(abs(u)-s);}\n//point,radius,height\nv0 cylinderZ(v2 u,v0 r,v0 h){return max(length(u.xy)-r,abs(u.z)-h);}  \nv0 cylinderY(v2 u,v0 r,v0 h){return cylinderZ(u.xzy,r,h);}\nv0 cylinderX(v2 u,v0 r,v0 h){return cylinderZ(u.zyx,r,h);}\n\n//DopplerShift //col,shiftedFreq,targetFreq\nv0 dsf(v2 c,v2 s,v0 t \n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;return suv(c*max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.))  ;}\n #else\n ;return suv(c*max(v2(0),1.-abs(s)*3.))  ;}\n #endif\n\n//dopplerShiftFactor\nvec3 dsf(vec3 c,vec3 f//all values of f are identical.\n){f*=vec3(1.,1.257,1.58)\n ;vec3 r=vec3(1,2,4)/3.\n ;return vec3(dsf(c,f,0. )+dsf(c,f,1.)*.3+dsf(c,f,-r.x)*.2\n             ,dsf(c,f,r.x) \n             ,dsf(c,f,r.y)+dsf(c,f,1.)*.5+dsf(c,f,r.z)*.25);}\nvec3 dsf(vec3 c,float f){return dsf(c,vec3(f));}\n\n//Quaternion  //pushed up a lot by RE7\n/*\n//asserting that length of quaternions are close to 1\n//we can normalize() by dividing by the squaredLength dot(a,a)! \nvec4 qn(vec4 q){return q/dot(q,q);}\n/**/\nvec4 qn(vec4 q){return q/dot(q,q);}\nvec4 aa2q(float b,vec3 a// b must be normalized!\n){b*=.5;return qn(vec4(a*sin(b),cos(b)));}\n\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nvec4 q2aa(vec4 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nvec4 qm(vec4 a, vec4 b\n){vec4 res= vec4(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return normalize(res);}\nvec3 qr(vec4 q,vec3 v\n){vec3 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n\nvec4 Transform(int i,vec4 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(vec3(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\n\nvoid oCamSet(vec3 u,vec4 rot){objPos[oCam]=u;objRot[oCam]=rot;}\n\nfloat LorentzFactor(float v){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\n\nvoid ProcessLightValue(float t\n){oliPos[0]=vec3(6.,1.,sin(t))\n ;oliCol[0]=3.*vec4(0.2,1.,.2,1)\n ;oliPos[1]=vec3(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*vec4(1,1,0.5,1)\n ;oliPos[2]=vec3(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*vec4(1,.2,1,1);}\nvoid SetTime(float t){\n ;ProcessLightValue(t)//also called in final pass\n ;objPos[oCubeMy]=vec3(0) \n ;objRot[oCubeMy]=aa2q(t*2.,vec3(0,1,0))\n ;objSca[oCubeMy]=vec3(.8)\n ;objPos[oBlackHole]=vec3(5.,sin(t*0.2),-5.)\n ;objRot[oBlackHole]=aa2q(t*2.,vec3(0,1,0))\n ;objSca[oBlackHole]=vec3(1)\n ;objPos[oCubeChil]=vec3(1)\n ;objRot[oCubeChil]=aa2q(t*1.,normalize(objPos[oCubeChil]))\n ;objSca[oCubeChil]=vec3(.4)\n ;float trainV = 2.2\n ;objVel[oTrain]= vec3((floor(mod(trainV*t/16.,2.))*2.-1.)*trainV,0,0)\n ;float trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.\n ;objPos[oTrain]=vec3(abs(1.-mod(trainV*t/16.,2.))*16.-8.,-.8,9.)\n ;objRot[oTrain]=aa2q(pi*.5,vec3(0,1,0))\n ;objSca[oTrain]= vec3(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;objPos[oTunnel]=vec3(0,-.8,9.)\n ;objRot[oTunnel]=aa2q(pi*.5,vec3(0,1,0))\n ;objSca[oTunnel]=vec3(1.,1.,1)\n ;objPos[oTunnelDoor]=objPos[oTunnel]\n ;objRot[oTunnelDoor]=objRot[oTunnel]\n ;float open = sat((1.-abs(3.*objPos[oTrain].x))*2.)\n ;objSca[oTunnelDoor]= vec3(open,open,1);}\n\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n\n\n//the DF still lacks boundingVolumes\n//to collide well with BVs (woth offset) we must add a summand to BV size\n//this optionally enlarges BVs, so we can calculate larger epsilon for collisons.\n//also. collisions should ee done in much hicher precision (small epsilon, small lipschitz stuff\n      \n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID==processedMaterial||processedMaterial==-1){nextMat=matID;lastrDist=o;\n#define endMaterial() } if (o != lastrDist) rayMat=nextMat;\n//marchlight() MarchPOV() do map(r.b,-1) , it marches the whole set\n//object groups are assigned to a materialID\n//defined as N of beginMaterial(N)\n//if map(r.b,-1) ray hits material of an id, rayMat stores that ID\n//a second pass can then march  ONLY against a subset geomety of a previously measured materialId\n//getDiffuse may do map(r.b,mat)\n//this is used to see how fast the hit object moves to the camera\n     //but that assumes that the same way will also hit the moved object\n     //and thats a VERY silly assumption, and also, it is disabled, and may have always been.\n     //this was likely a dubm idea of the maker of this, never completely edited out.\n\n//this is cute and all, but not compatible with my infiniteReflections\n//as my infiniteReflections loop accumulates on each reflection, there is no second pass\n//groups of materials may still be useful.\n\n//to be very clear, map() so far is ALWAYS called with second parameter set to -1\n//while other inpputs wozuld only trace a subset of the DF.\nfloat map(vec3 u, int processedMaterial\n){float o=0.//0. if first operation is a SUB(), 1e10 otherwise\n ;rayObj=0\n ;vec4 w=vec4(u,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(w.w*box(w.xyz-vec3(0),vec3(10,2.5,10)))\n ;ADD(w.w*cylinderY(w.xyz-vec3(-6,0,-2.),0.1,3.))\n ;ADD(w.w*cylinderY(w.xyz-vec3( 5,0,-2.),0.1,3.))\n ;endMaterial()     \n ;vec4 c=beginObj(oCubeMy,w)//cubespace, not color\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(c.w*sphere(c.xyz,1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;vec4 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(blackHoleSpace.w*sphere(blackHoleSpace.xyz,.5))\n ;endMaterial()\n ;vec4 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0, .5,0),vec3(.2,.1,1.5)))\n ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0,-.5,0),vec3(.2,.1,1.5)))\n ;endMaterial()\n ;vec4 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0, 1.4),vec3(.2,.4,0.1)))\n ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0,-1.4),vec3(.2,.4,0.1)))\n ;endMaterial()\n ;vec4 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.8),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.4),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,0),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.4),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.68),vec3(.1,.1,.06)))\n ;ADD(trainSpace.w*cylinderZ(trainSpace.xyz-vec3(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;float tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0;L<3;L++\n ){ADD(w.w*sphere(w.xyz-oliPos[L],.001))\n  ;vec3 relPos=oliPos[L]-pos\n  ;oliHal[L]+=o*(0.02/(dot(relPos,relPos)+.01));}\n ;return o;}\n\nvec4 GetNormal(vec3 u//4tap derivative\n){vec2 e=vec2(.003,0.)\n ;float o=map(u,-1)\n ;return vec4(normalize(vec3(map(u+e.xyy,-1)\n                            ,map(u+e.yxy,-1)\n                            ,map(u+e.yyx,-1))-o),o);}\n\n\n\n/**///--end__: Relativity\n/**///--\n/**///--start: memo\n                      \n             \n//solving with linear equations (and not with perlendicular doorproduct rhombus)\n\n/*getting the linear function of a line (o,t) //2 points on a line\ny=m*x+b\nm=(o.y-t.y)/(o.x-t.x) //slpe == rate of change over one domain (x)\nb=t.y-m*t.x           //f(0)\n\nm=(o.x-t.x)/(o.y-t.y)  //is constant\neither enter o.xy or t.xy\no.y      =m*o.x+b    \nt.y      =m*t.x+b\nt.y-m*t.x=     +b   //b is f(0)\n\nm=(o.x-t.x)/(o.y-t.y) //slope\nb=t.y-m*t.x           //f(0)  (this is a vec2 in 3d)\n\n//the above is odd for barycentric coordinates.\n//theres no y=m*x+b pointSlope form\n//sure, the slope is simple\n//oh wait, i just assert a skewed 2d coordinate system.\n\n//where ever 2 things intersect, they are the same, there they are equal.\n//this equation is a linear equation system, with as mnany lines as domains\n//substract factors to get all constants on one side\n                      \n/*  solving lonear equations with inverse matrix:\nhttps://courses.lumenlearning.com/ivytech-collegealgebra/chapter/solving-a-system-of-linear-equations-using-the-inverse-of-a-matrix/\n\n  a*x=b\n    x=b/a\n    x=b*inverse(a)\n\na is a matrix\nx are coefficients (one foreach domain)\nb may be zero vector, usually only contains constanty.\n                      \nexample (2d line intersection)\nA linear function is visible as a line where f(x)=y\ncos(x)  =y\ncos(x)-y=0\n\nany intersection of 2 things may have an intersection, where both functions are equal\n3*a+ 8*b=5\n4*a+11*by7\n\nA=mat2(vec2(3,8),vec2(4,11)\nX=vec2(a,b)\nB=vec2(5,7)\nA*X=B\ninverse(A)==mat2(11,-8,-4,3)\ninverse(A)*B==vec2(-1,1)  \nBEWARE that matrix multiplication is not commutative  inverse(A)*B != b*inverse(A)\n->\nvec2(x,y)==vec2(-1,1)\n/**/\n                      \n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n/*\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n/**/\n                      \n/*\ntodo\nget RE included\n\nfix duplicates with the hg_sdf segment\n\nfix vNNN struct incompatibles (is simple)\n\nfix all that relies on high domain su() functions. (incompatibility\n- hash noise errors  , re-copy from   https://www.shadertoy.com/view/XlVyDK\n\ninclude debugHg2() marcher from       https://www.shadertoy.com/view/XlVyDK\n\na lot of hg sdf uses higher doimkensional mod mo(), which fails here an is from  /XlVyDK\n*/\n                      \n/*\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n/**/\n                      \n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dls(a,b,c) ls(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return lsY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return ls(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\nfloat addToAverage(float a,float b,float l//remove b from incremental average a of length l\n){return ((a*l)+b)/(l+1.);}//assert l to be -=1\n\n//assume a stores an average of 2 and is 2 long, thats a*l=4\n//and b is a slow frame that is 3 long:\n//the 3 iframes long segment is 2+2+3\n//we divide by 3 for the new average\n      \n//assume a stores an average of 2 and is 2 long\n//and b is a slow frame that is 3 long\n//(2+3)/2\n  \n/**///-- start incrementalAveraging (for bayesian performance)\n      \n//[a] stores an average of [c] inputs of [t]\n//initially          a= 0\n//after first  call, a= t       /1\n//after second call, a=(t+t2   )/2\n//after second call, a=(t+t2+t3)/3 ...\n//incremental averaging //a==0 before the first call of ia()\nfloat ia(float a,float t,float c\n){return ((a*c)+t)/c;}//update average a by input t,c==number of function calls\n //assuming ia() is called every frame, and the initial frame has iFrame==0 :\n //c=1.+iFrame         accumulates a to the average of every frame\n //c=1.+min(iFrame,2.) keeps storing the averages of the 2 most recent calls\n //c=1.+min(iFrame,4.) keeps storing the averages of the 4 most recent calls\n\n//t=iTimeDelta,i=iFrame\n//a.xyzw stores 4 short term averages\nvoid performance(inout vec4 a,inout vec3 b,float t,float i){\n ;vec4 c=vec4(i)\n ;vec3 d=min(c.xyz,vec3(2,4,8))+1.  //+1 outside the () asserts initial iFrame==0\n ;     c=min(c,vec4(16,32,64,128))+1.\n ;ia(a.x,t,c.x)//a.y stores an average i of up to 2 most recent frames\n ;ia(a.y,t,c.y)//a.z stores an average i of up to 4 most recent frames\n ;ia(a.z,t,c.z)//a.w stores an average i of up to 8\n ;ia(a.w,t,c.w)  //b.x stores an average i of up to 16\n ;ia(b.x,t,d.x)  //b.y stores an average i of up to 32\n ;ia(b.y,t,d.y)  //b.z stores an average i of up to 64\n ;ia(b.z,t,d.z);}//b.w stores an average i of up to 128\n\n//now, instead of feeding the average of 60 fps to bayeps\n//or just iTimeDelta\n//we feed it the average of multiple average iTimeDeltas \n//the first frame it asserts the idela of 1/targetfps pperformance\n//the frames fter this it has averages of averages of iTimeDelta segments\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/**/ //start plugin notes:\n/*\n\npluginName= iDiegeticUI v2\n\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n- scale inout to storage data by iResolution.xy (or your scaling will just be off)\n\n\nThese plugin specific subroutines of this shader are only used in this shader:\n-   addInit() //initial state == onInit() dot[x] positions\n- clickLoop()\n-   branchi()\nShared Common Subroutines\n- see CommonTab: modifiables for diecetic_UI_2\n- const v3 deleteRect  AxisAlignedBound (red deletion rectangle)\n- inRect(uv,deleteRect) //contextBoundFilter\niDiegeticUI has lots of visualization code, likely only needed in ImageTab\n- drawDragDots()\n\n--- pseudocode structure:\nmainImage(){\n ;//...\n ;if (iFrame==0\n ){v0 count=0.//init\n  ;addInit()\n  ;}\n ;//...\n ;     if(max(state.z,-iMouse.z)<0.)clickLoop(...)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect\n ){branchi(...)\n  ;//...\n  ;}\n ;}\n\niDiegeticUI buffers a list of dot[x]\n, for a dragAndDrop UI (in screenspace)\n, and one fragment buffers [number of dots]\n\nAny other shader can read these dot-coordinates\n, commonly used to modify parameters of parametricFunctions:\n- parametric CSG (debug/demo frustrumCulling or AutomaticDifferentiation)\n- - [megaprm]\n- - \"implicit\" splines/isosurfaces\n\nthis buffer stors states that set:\n- number of stored states\n-.xy coordinate of points for [diecetic UI]\n\n/**/ //end__ plugin notes:\n\n\n/*\ndiecetic /screenspace UI = reusable drag&drop\n, as basis for some non-screenspace diegetic-UI\n, like in a FlightSim, [BattleTech], [DeathSpace] or [Astroneer]\n\nparent     : https://www.shadertoy.com/view/Xt3BzX\nparent     : https://www.shadertoy.com/view/4dtSRn\nInspired by: https://www.shadertoy.com/view/MdKGRw\nreusable drag and drop framework; by mhnewman\n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\nbuffOfDot(v0(floor(x))) function returns parameters of dot[x]\n- THIS shader should not contain buffOfDot()\n- , but instead most likely just the [ImageTab] for a screenspace UI\n\nmaxCount := the maximum number of objects that can be represented.\nBuffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n  * .x := the object's x coordinate.\n  * .y := the object's y coordinate.\n\n Buffer pixel (maxCount, 0) := the current state.\n  * .x := the index of the currently selected object.\n  * .y := the number of active objects.\n  * .z := the mouse state.\n\n Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n/**/\n\n//alias for an initial state:\n#define addInit(xPos, yPos) {if(u.x==count)o=v3((xPos),(yPos),0.,0.);count+=1.;}\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m){if(d<r){r=d;state.x=f;o=center-m;}}//for iDiegeticUI\n\nvoid  clickLoop(inout v3 state,v3 o,v3 m\n){v0 r=clickPointRadius+1.\n ;for(v0 i=0.;i<maxCount;++i\n ){v0 f=i\n  ;if(f>=state.y)break\n  ;v3 center=texture(iDiegeticUI ,v1(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(v1(2.*statePos,state.y),state.yy+v1(0,1),step(state.y,statePos));}\n\nvoid branchi(inout v3 o, v1 u,v0 S,v3 s,v1 U//out,uv,statepos,state,U\n){     if(u.x==S )o=v3(2.*S,s.y-1.,iMouse.z,1)\n ;else if(u.x<s.x)o=texture(iDiegeticUI, U/iResolution.xy)\n ;else            o=texture(iDiegeticUI,(U+v1(1,0))/iResolution.xy);}\n\nvoid mainImage(out v3 o,in v1 U\n){v1 u=U-.5\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;if(u.y>0.||u.x>offsetPos){o=v3(0);return;}\n ;if(iFrame==0\n ){v0 count=0.//init\n  ;addInit(.35*iResolution.x,.4 *iResolution.y)//initial iFrame==0 dot placement\n  ;addInit(.75*iResolution.x,.7 *iResolution.y)\n  ;addInit(.5 *iResolution.x,.1 *iResolution.y)\n  ;addInit(.4 *iResolution.x,.7 *iResolution.y)\n  ;addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(u.x==statePos)o=v3(2.*statePos,count,0.,0.);return;}\n ;v3 s=texture(iDiegeticUI,v1(.5+ statePos,.5)/r.xy)\n ;     o=texture(iDiegeticUI,v1(.5+offsetPos,.5)/r.xy)\n ;     if(max(s.z,-m.z)<0.)clickLoop(s,o,m)\n ;else if(min(s.z,-m.z)>0.&&inRect(m.xy,deleteRect)\n ){branchi(o,u,statePos,s,U);return\n ;}if(u.x==statePos)o=v3(s.xy,m.z,s.w)\n ;else if(u.x==offsetPos)o=o\n ;else if(u.x==s.x&&m.z>0.)o=m+o\n ;else o=texture(iDiegeticUI,U/iResolution.xy)\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//pluginName= iAD\n/*\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n*/\n\n/**/ //--- srart AD-Modifiers \n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 2\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n\n/**/ //--- end__ AD-Modifiers\n     //\n/**/ //--- start AD-calculus-Intro\n/*\n\nThis demoes [AutomaticDifferentiation]==[AD]\n-,that automatically calculates the NthDerivative of (m)any function(s)\n- , by implementing:\n- -    chainRule (top level function)\n- -  productRule (arises out of chainRule 2nd derivative)\n- - quotientRule (reciprocal productRule)\n- -    powerRule:\n\nself   AD35 : https://www.shadertoy.com/view/WtfGRS\nparent AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD34 : https://www.shadertoy.com/view/Wlf3WN\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\naunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\nThe details/axiomes/rules of this are explained in the CommonTab implementation\nYou do not need to know ALL its rules to know how to use it\nBut it helps oif you are good in physics, and know what [Inertia] means/models.\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function\n, with something like:    https://www.integral-calculator.com/\n, And then use AD to derive that precalculated integral back to its original, for:\n- precise/analytic [filter] [anti-alasing] (by starting from a DoubleIntegral)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\nSpecific analytic filters are done regularily by InigoQuilez\n, mostly noise with analytic first derivatives:\n-  iquilezles.org/articles/morecheckerfiltering\n-  https://iquilezles.org/articles/filtering\n-  https://iquilezles.org/articles/filterableprocedurals\n-  https://iquilezles.org/articles/gradientnoise\n-  https://iquilezles.org/articles/morenoise\n- - IQ stateless (no LookUpTable/texture/VBO) 2d and 3d noise (with analytic derivatives) \n  - - Value    Noise 2d 1st Derivative:  https://www.shadertoy.com/view/4dXBRH\n  - - Gradient Noise 2d 1st Derivative:  https://www.shadertoy.com/view/XdXBRH\n  - - Value    Noise 3d 1st Derivative:  https://www.shadertoy.com/view/XsXfRH\n  - - Gradient Noise 3d 1st Derivative:  https://www.shadertoy.com/view/4dffRH\n  - - Value    Noise 2d 0th Derivative:  https://www.shadertoy.com/view/lsf3WH\n  - - Value    Noise 3d 0th Derivative:  https://www.shadertoy.com/view/4sfGzS\n  - - Gradient Noise 2d 0th Derivative:  https://www.shadertoy.com/view/XdXGW8\n  - - Gradient Noise 3d 0th Derivative:  https://www.shadertoy.com/view/Xsl3Dl\n  - - Simplex  Noise 2d 0th Derivative:  https://www.shadertoy.com/view/Msf3WH\n- - \nAD allows you to automate this, with up to a 3th derivative, over up to 4 domains.\nYou calculate thedouble Integral of any function, and AD calculates you 3 derivatves for a [filter]\nThis works over up to 4 domains, this is multivariate-calculis, right?\n\nI mean, tthis can solve for optimization problems of a\n  https://en.wikipedia.org/wiki/Partial_derivative\n, right?\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision or performance increases more\n- near sharp corners\n- with shapes|functions, that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nhow about some fast lacplachians:\nhttps://en.wikipedia.org/wiki/Laplace_operator\n\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n\n/**/ //--- end__ AD-calculus-Intro\n     //\n/**/ //--- start AD-calculus-Overview\n/*\n\nr=f(a); is the general form of a function f(a), something like:\nv0 f(v0 a){return 3.*a*a*a+2.*a*a-a+7.;}\n;\nAutomaticDifferentiation calculates the derivatives of f(a):\n;\nA [deritative of [f(a)] over [a]]\nis the INSTANTANEOUS [rate of change] of [f(a)] over [a]\nThe lazy approach is to measure different 2 points of f(a)\nand calculate the slope between these points\n- This is how most shaders on shadertoy calculate a surfaceNormal\n- - They commonly measure 2x3 points, 2 points along each of the 3 orrthogonal axes in 3d\n- - - That is not the INSTANTANEOUS [rate of change], but more like a lowPrecisionAverage [rate of change]\nA [deritative of [f(a)] is the limit of this slope-angle when length(slope) approaches 0.\n;\nA [derivative of a [    derivative]] is a [2nd derivative], aka [gradient]\nA [derivative of a [2nd derivative]] is a [3nd derivative]\n;\nexmaple speed_velocity:\nA function, that returns the position of something for any time-input\n, returns a [pos=position(time) over [time]]:\nv0 position(v0 t){return 3.*a*a*a+2.*a*a-a+7.;}//input time returns position\n;\nThe derivative of the position() function returns the speed(time) (or velocity in more than 1d)\nv0 speed(v0 t){return  9.*a*a+4.*a-1.;}//input time returns speed\n;\nThe derivative of the speed() function returns the Accelleration(time)\nv0 speed(v0 t){return 18.*a+4;}//input time returns Accelleration\n;\nThe derivative of the Accelleration() function returns the Jounce(time) (the rate of change of accelleration)\nv0 speed(v0 t){return 18.;}//input time returns Jounce\n\n\"Jounce\" is by far not the strangest derived-SI-unit's properNoun here:\n\n/**/ //--- end__ AD-calculus-Overview\n     //\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives.\n/*\n\nWhen we derive over something, we derive over (compositions of)\nhttps://en.wikipedia.org/wiki/International_System_of_Units\nhttps://en.wikipedia.org/wiki/SI_derived_unit\n\nIt helps to define common properNouns\n, to talk about concepts/predictions and correlations\nI shortened some terms (to single-glyph-length), for better monospaced-text\nUppercase labels [T,L,M,I,K,N,J] are nameOfDomain\nLowercase labels [s,m,g,a,e,o,c] are nameOfInitial\nSorted, by how commonly we derive ofer these units:\n-       time()SIunit==[T]==[s]Second\n-     length()SIunit==[L]==[m]Meter\n-       mass()SIunit==[M]==[g](kilo)Gramm  //aka [linear inertia]\n-    current()SIunit==[I]==[a]Ampere\n-temperature()SIunit==[K]==[e]kElvin       //[K] may also be [capitalized \"omega\"]\n-     amount()SIunit==[N]==[o]mOle\n-luminousity()SIunit==[J]==[c]Candela\n\nhttps://en.wikipedia.org/wiki/Metrology#Legal_metrology\n\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives\n     //\n/**/ //--- start AD-common-derivatives over time,dT,T^(n-1)\n/*\nSome labels are only scalar, or only linear, or only angular\nThe lists below do not care much about that, for now it is a hot mess\n, and it is up to you to properly calculate in carthesian or polar space.\n\nSometimes some notations/labels are more intuitive than others\nFor a simple start, we assert that \n- Time is scalar and measured in seconds=[s]\n- Time has only one dimension (at least true for past experiences)\n- - Otherwise causality is an [arbitiary field] and math of that gets a bit too [statistic]al\n;\nfor simpler syntax, we first to derive over [s] and label [Nth derivatives over s] as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=dsÂ²=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=dsÂ³=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\n- what domain you derive over\n\nutility:\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate any TERM below (into an up to 3lines-Lower-TERM)\n ;//and then a higher-TERM can be used to [filter] a lower-TERM\n ;//  https://www.shadertoy.com/results?query=filter\n ;//this is done (without AD or calculus) in many shaders about motionBlur\n ;//  https://www.shadertoy.com/results?query=blur\n;}\n;\nITIT*==[double integral   over time   of[*]]\n  IT*==       [integral   over time   of[*]]\n  DT*==       [derivative over time   of[*]]\n  DL*==       [derivative over length of[*]]\n  RE*==                   [reciprocal of[*]]\n\n--- position|displacement-integrals (over time|s) are:  \n\nITITtime =1.*s*s*s //[double integral over time of [time]]\n  ITtime =1.*s*s   //       [integral over time of [time]]\n    time =1.*s     //                              [time]\n     unit=1.       //     [derivative over time of [time]]\nfrequency=1./s     //     [derivative over time of [unit]]            aka[becquerel] aka [[fluxion]==initially proposed term for [dt]]\n    phase=1./s/s   //     [derivative over time of [frequency]] ==IADMtesla aka[frequencyDrift] https://en.wikipedia.org/wiki/Instantaneous_phase\n  DTphase=1./s/s/s //     [derivative over time of [phase]]\n;\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n;\n(wave)length ==1.*m      //beware: [relativistic length-contraction]\n      Speed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n;\nhttps://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\n;\nlength|speed are implicitly scalar,single-dimensional; length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are implicitly defined as VECTORS, with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\n- They include a relative direction; length()*(angles|UnitQuaternion)\n- They include all angular reference points\n- ,as a polar transformation implies 2 dimensions.\n- - linear/carthesian vectors are identified by starting with [ 1.*] or [ 1./]\n- - polar /complex    vectors are identified by starting with [rad*] or [rad/]\n- - - This often does NOT care wether you are in carthesian or polar coordinates (sometimes the labels are just mixed up)\n- - - sorry, this first version of the list likely mixes terms that are not to be mixed into the same context/bucket.\n- This is quite a messy collection of many nouns, some contexts are lost, some identities are typos.\n- They include all issues of periodic/circular displacement\n- ,where you can do a lot of work, and can end up exactly where you started, plus some entropy\n- - https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n;\n      âfarnessâ=1.*m*s*s*s*s*s*s*s*s*s*s*s*s\n         absput=1.*m*s*s*s*s*s*s*s*s*s*s*s\n         abshot=1.*m*s*s*s*s*s*s*s*s*s*s\n         absrop=1.*m*s*s*s*s*s*s*s*s*s\n         absock=1.*m*s*s*s*s*s*s*s*s\n          absop=1.*m*s*s*s*s*s*s*s\n      absrackle=1.*m*s*s*s*s*s*s\n       absounce=1.*m*s*s*s*s*s\n         abserk=1.*m*s*s*s*s\n   abseleration=1.*m*s*s*s\n         absity=1.*m*s*s \n       absement=1.*m*s        = [maintenance cost] of [long distance communication]\n   displacement=1.*m           //beware: [relativistic length-contraction]\n       velocity=1.*m/s\n  accelleration=1.*m/s/s\n           snap=1.*m/s/s/s        aka[jounce]\n        crackle=1.*m/s/s/s/s\n            pop=1.*m/s/s/s/s/s \n           lock=1.*m/s/s/s/s/s/s\n           drop=1.*m/s/s/s/s/s/s/s \n           shot=1.*m/s/s/s/s/s/s/s/s\n            put=1.*m/s/s/s/s/s/s/s/s/s\n    âswiftnessâ=1.*m/s/s/s/s/s/s/s/s/s/s\n;\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure ânearnessâ.\n;\n     ânearnessâ=1./m*s*s*s*s*s*s*s*s*s*s*s*s\n        presput=1./m*s*s*s*s*s*s*s*s*s*s*s\n        preshot=1./m*s*s*s*s*s*s*s*s*s*s\n        presrop=1./m*s*s*s*s*s*s*s*s*s\n        presock=1./m*s*s*s*s*s*s*s*s\n         presop=1./m*s*s*s*s*s*s*s\n      presackle=1./m*s*s*s*s*s*s\n      presounce=1./m*s*s*s*s*s\n        preserk=1./m*s*s*s*s\n  preseleration=1./m*s*s*s\n        presity=1./m*s*s\n      presement=1./m*s\n      placement=1./m             ==REdisplacement\n     REvelocity=1./m/s         [velocity reciprocal]\nREaccelleration=1./m/s/s\n         REsnap=1./m/s/s/s \n;\n              ?=1.*g*m*s*s*s*s\n  spectralPower=1.*g*m*s*s*s\n              ?=1.*g*m*s*s \n              ?=1.*g*m*s\n              ?=1.*g*m\n        impulse=1.*g*m/s          aka[momentum]\n          force=1.*g*m/s/s        aka [weight,Newton,torque,action|actergy]\n           yank=1.*g*m/s/s/s      aka [Joule,NewtonMetre,linear work]\n            tug=1.*g*m/s/s/s/s    aka [linear power]\n         snatch=1.*g*m/s/s/s/s/s\n          shake=1.*g*m/s/s/s/s/s/s\n    âforcenessâ=1.*g*m/s/s/s/s/s/s/s\n;\nabove are \"real vectors\" of below \"pseudo vectors\"\nThe difference between [linear] and [angular] vector(derivative)s is a [coreolis effect]\n- commonly experienced as wind/twister/hurricanes/tensor\nrad=radians, where acos(-1.)*2.==1 full rotation indicate PolarCoordinates via c2p() transformation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below lists mix lot of things together, disregards coordinateSystem, as long as they have the same SI-derivative\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware, I confuse [nouns] for [nouns of quanitities], because i really do not care for now\n;\n    angularDisplacement=rad\n        angularVelocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\n    angularAcceleration=rad/s/s\n            angularJerk=rad/s/s/s\n;\n                   area= 1.*m*m\nspecificAngularMomentum= 1.*m*m/s     [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n                   gray= 1.*m*m/s/s   aka [sievert]\n       absorbedDoseRate= 1.*m*m/s/s/s  \n;\n                   mass= 1.*g\n           massFlowRate= 1.*g/s\n         surfaceTension= 1.*g/s/s    aka [stiffness ,radiantExposure]\n               radiance= 1.*g/s/s/s  aka [irradiance, energyflux density,heat flux density]\n;\n         angularRotatum=rad*g*m*s*s*s    aka [spectralPower, spectral intensity]\n                Inertia=rad*g*m*m*s      \n        MomentOfInertia=rad*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\n                   spin=rad*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n          angularEnergy=rad*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n           angularPower=rad*g*m*m/s/s/s  [watt] [radiant  intensity]\n;\nangularMomentum|Impulse=rad*g*m/s \n      linearMassDensity=rad*g/m \n       dynamicViscosity=rad*g/m/s\n          energyDensity=rad*g/m/s/s     [pascal] ???\n           powerDensity=rad*g/m/s/s/s    aka: [spectral irradiance]\n;\n                coulomb= 1.*a*s\n                 charge= 1.*a\n                current= 1.*a/s\n;\n                  weber= 1./a*g*m*m/s/s\n                   volt= 1./a*g*m*m/s/s/s\n;\n                  henry= 1./a/a*g*m*m/s/s\n                    ohm= 1./a/a*g*m*m/s/s/s\n;\n                  farad= 1./g*a*a/m/m*s*s*s*s\n                siemens= 1./g*a*a/m/m*s*s*s\n;\n        compressibility= 1./g*m*s*s\n      DTcompressibility= 1./g*m*s\n;\n     ITspectralRadiance= 1.*g/m/s/s\n       spectralRadiance= 1.*g/m/s/s/s\n;\n                    mol= 1.*o\n                  katal= 1.*o/s\n;\n            molarVolume= 1./o*m*m*m\n    catalyticEfficiency= 1./o*m*m*m/s\n;\n                 volume= 1.*m*m*m\n     VolumetricFlowRate= 1.*m*m*m/s     //Rate of change of volume with respect to time \t\n\n\n/**/ //--- end__ AD-common-derivatives over time,dT,T^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over space|length,dL,L^(n-1)\n/*\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\nvolumetricFlowRate= 1./s*m*m*m\n         viscosity= 1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n;\n  absorbedRoseRate= 1./s/s/s*m*m\nDLabsorbedRoseRate= 1./s/s/s*m\n;\n              gray= 1./s/s*m*m  =ILILphase  aka[sievert] \n            DLgray= 1./s/s*m    =  ILphase\n             phase= 1./s/s      =DLDLgray\n;\n                 ?= 1.*m*m*m*m*m\n       hyperVolume= 1.*m*m*m*m\n            volume= 1.*m*m*m\n              area= 1.*m*m\n      displacement= 1.*m    (displacement or SCALAR length)\n              unit= 1.\n         placement= 1./m    aka [curvature,wavenumber,opticalPower,spatialFrequency]\n            REarea= 1./m/m      //copied from stranger online places\n          REvolume= 1./m/m/m\n;\n   momentOfInertia= 1.*g*m*m \n                 ?= 1.*g*m\n              mass= 1.*g\n linearMassDensity= 1.*g/m\n;\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\n    angularRotatum= 1.*g/s/s/s*m\n   weber, radiance= 1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\n  spectralRadiance= 1.*g/s/s/s/m    aka[spectral power]\n   radiantUntertua= 1.*g/s/s/s/m/m\n;\n              spin=rad*g/s*m*m [angular torque  |moment] [energy density] [action]\n   angularMomentum=rad*g/s*m   [angular Impulse]\n      massFlowRate=rad*g/s\n  dynamicViscosity=rad*g/s/m\n;\n     angularEnergy=rad*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                 ?=rad*g/s/s*m\n    SurfaceTension=rad*g/s/s       aka [spring constant, stiffness]\n;\n             joule= 1.*g/s/s*m*m\n           DLjoule= 1.*g/s/s*m\n   radiantExposure= 1.*g/s/s\n;\n       AreaDensity= 1.*g/m/m\n       Massdensity= 1.*g/m/m/m \n\n   MomentOfInertia= 1.*g*s*m*m\n DLMomentOfInertia= 1.*g*s*m\n\n    specificVolume= 1./g*m*m*m\n      specificArea= 1./g*m*m\n    DLspecificArea= 1./g*m\n\n   compressibility= 1./g*s*s*m\n DLcompressibility= 1./g*s*s\n\n    ILpowerDensity= 1.*g/s/s/s\n      powerDensity= 1.*g/s/s/s/m   aka: [spectral irradiance]\n;\n           ILILlux= steradian*cd\n             ILlux= steradian*cd/m\n               lux= steradian*cd/m/m\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dL,L^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mass,dM,M^(n-1)\n/*\n                 IMmass= 1.*g*g\n                   mass= 1.*g\n                   unit= 1.\n                 REmass= 1./g\n;\n               radiance= 1./s/s/s*g  aka[irradiance,weber,energy|heat flux density]\n                DTphase= 1./s/s/s    [derivative over time of [phase]]\n;\n         SurfaceTension= 1./s/s*g     aka [stiffness ,radiant exposure]==[integral of [tesla] over Ampere]\n                  Phase= 1./s/s       ==IADMtesla\n;\n           massFlowRate= 1./s*g\n              frequency= 1./s\n;\n                      ?= 1.*m*g\n           displacement= 1.*m\n;\n        momentOfInertia= 1.*m*m*g\n                   area= 1.*m*m\n;\n                 volume= 1.*m*m*m\n         specificvolume= 1.*m*m*m/g\n;\n                impulse= 1.*m/s*g       aka[momentum,dynamicViscosity]\n               velocity= 1.*m/s\n;\n                  force= 1.*m/s/s*g        aka [Newton,weight,action,actergy,torque]\n          accelleration= 1.*m/s/s\n;\n                   yank= 1.*m/s/s/s*g\n                   snap= 1.*m/s/s/s       aka[Jounce]\n;\n                    tug= 1.*m/s/s/s/s*g    aka [linear power]\n                crackle= 1.*m/s/s/s/s\n;\n                   spin= 1.*m*m/s*g      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nspecificAngularMomentum= 1.*m*m/s\n;\n          angularEnergy= 1.*m*m/s/s*g    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                   gray= 1.*m*m/s/s      [sievert]\n;\n                   watt= 1.*m*m/s/s/s*g   [angular power] [radiant  intensity]\n       absorbedDoseRate= 1.*m*m/s/s/s\n;\n                 absity= 1.*m*s*s \n        compressibility= 1.*m*s*s/g\n;\n           spectralPower=1.*m*s*s*s*g\n            abseleration=1.*m*s*s*s\n;\n                Inertia= 1.*m*m*s*g      https://en.wikipedia.org/wiki/Moment_of_inertia\n                 ITarea= 1.*m*m*s\n;\n      linearMassDensity= 1./m*g\n              placement= 1./m\n;\n       dynamicViscosity= 1./m/s*g\n             REvelocity= 1./m/s         [reciprocal of velocity]\n;\n          energyDensity= 1./m/s/s*g     [pascal] ???\n        REaccelleration= 1./m/s/s\n;\n           powerDensity= 1./m/s/s/s*g   aka: [spectral(Ir)Radiance|power|intensity,angularRotatum]\n                 REsnap= 1./m/s/s/s\n;\n        radiantUntertua= 1./m/m/s/s/s*g\n      DMradiantUntertua= 1./m/m/s/s/s*\n;\n            areaDensity= 1./m/m*g\n          REarea       = 1./m/m\n;\n            massDensity= 1./m/m/m*g\n               REvolume= 1./m/m/m\n;\n                   mole= 1.*o\n               molality= 1.*o/g  [==molarMassRec]\n;\n                 REmole= 1./o\n              molarMass= 1./o*g  [==molalityRec] \n;\n    molarHeatCapacityIN= 1./e*m*m/s/s*g   aka[molar entropy]\n  DMmolarHeatCapacityIN= 1./e*m*m/s/s\n\n\n\n\n/**/ //--- end__ AD-common-derivatives over mass,dM,M^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over ampere,dA,A^(n-1)\n/*\n\n          watt= 1.*g*m*m/s/s/s\n          volt= 1.*g*m*m/s/s/s/a\n           ohm= 1.*g*m*m/s/s/s/a/a\n;\n angularEnergy= 1.*g/s/s*m*m\n         weber= 1.*g/s/s*m*m/a\n         henry= 1.*g/s/s*m*m/a/a\n;\n     coulombIA= 1.*s*a*a\n       coulomb= 1.*s*a\n          Time= 1.*s\n;\n         farad= 1./g/m/m*s*s*s*s*a*a\n       DAfarad= 1./g/m/m*s*s*s*s*a\n     DADAfarad= 1./g/m/m*s*s*s*s\n;\n       siemens= 1./g/m/m*s*s*s*a*a\n     DAsiemens= 1./g/m/m*s*s*s*a\n;\n      TeslaRec= 1./g*s*s*a   //                [reciprocal of [tesla]]\n       PhaseDM= 1./g*s*s     // [derivative of [reciprocal of [tesla]] over mass] == PhaseDM == [derivative of [Phase] over mass]\n;\nSurfaceTension= 1.*g/s/s       aka [stiffness ,radiantExposure]==[integral of [tesla] over Ampere]\n         tesla= 1.*g/s/s/a\n       DAtesla= 1.*g/s/s/a/a\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dA,A^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mole,dN,N^(n-1)\n/*\n\nall terms that I find with an [o] for mOle in it, are in this section\neven if the derivative chains of it are short\nIn that case i derive my orn term with *D* or *I*\n\nmole              =1.*o\n;\n     Mass         =1.*g\nmolarMass         =1.*g/o  [molalityRec]\n;\nmolality          =1.*o/g  [molarMassRec]\n;\nmolarity          =1./m/m/m*o\nmolarityDN        =1./m/m/m      //its odd that we have no proper noun for this\n;\nangularEnergyIN    =1.*g*m*m/s/s*o\nangularEnergy      =1.*g*m*m/s/s\n  molarEnergy      =1.*g*m*m/s/s/o\n;\nmolarHeatCapacityIN=g/e*m*m/s/s\nmolarHeatCapacity  =g/e*m*m/s/s/o   aka[molar entropy]\n;\nINmolarConductivity=a*a/g*s*s*s\n  molarConductivity=a*a/g*s*s*s/o\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dN,N^(n-1)\n     //\n/**/ //--- start AD-demo\n/*\n\nAD converts ALL operands into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(c2 a, c2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n/**/\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperPrim(c2 p, v3 s,v1 r\n){//v1 r=v1(.2,.5);\n  //v3 s=v3(1.5,.5,1.5,.5);\n  //v3 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=v3(0);dz=v3(0);d=v3(0);\n  //e=v3(0);f=v3(0);q=v3(0);\n  //a=v3(0);b=v3(0);c=v3(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out v3 s,out v1 r\n){     if(i==0){s=v3(1)           ;r=v1(0)     ;//cube\n }else if(i==1){s=v3(v2(1),.25)   ;r=v1(0)     ;//corridor\n }else if(i==2){s=v3(v2(1),.25)   ;r=v1(1)     ;//pipe\n }else if(i==3){s=v3(1)           ;r=v1(1,0)   ;//cylinder\n }else if(i==4){s=v3(1,1,2,1)     ;r=v1(1)     ;//pill\n }else if(i==5){s=v3(1)           ;r=v1(1)     ;//sphere\n }else if(i==6){s=v3(1,1,.25,1)   ;r=v1(1,.25) ;//pellet\n }else if(i==7){s=v3(1,1,.25,.25) ;r=v1(1,.25) ;//torus\n }else if(i==8){s=v3(2,.5,.25,.25);r=v1(.5,.25);//sausage mouth\n }else if(i==9){s=v3(.7,1,1,.25)  ;r=v1(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n            \n\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;v0 m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\n\n\n\nDAMValue df(c2 p\n){d2 D\n ;v0 t=iTime//u=ss01(ss01(fract(t)))\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount,0.)+.5)/iResolution.xy).y  \n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces\n ;//m.x=cos(iTime)*r.x\n     \n ;//if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)*r.xy;} \n ;m=iMouseZwFix(m,false)\n ;D=sdGoursat(p,r,m)\n     //aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,v2(1))\n ;//r=fBoxCheap(p,v2(1))\n ;//v0 holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;//d2 s=fSphere(mu(p,v2(holesize)))\n ;//r=ma(r,ne(s))//nope way too bad lipschitz, got to fix this shit!\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;v3 a,b,c,d;v1 e,f,g,h\n     \n     \n ;getfactor(imsc(t   ),a,e);getfactor(imsc(t+1.),b,f)//params for superprim0\n ;getfactor(imsc(t+2.),c,g);getfactor(imsc(t+3.),d,h)//params for superprim1\n ;v0 v=ss01(fract(t))\n ;a=mix(a,b,v);e=mix(e,f,v)//params for superprim0\n ;c=mix(c,d,v);g=mix(g,h,v)//params for superprim1\n //above getfacvtor sets v3 a,b and v1 c,d into a cyclic mix\n //below overwrites these parameters with iUI data  \n//#define bufDrag(x) texture(iDiegeticUI,(v1(x,0.)+.5)/iResolution.xy)\n  \n ;v1 sdUberprimZ=v1(cos(iTime)*.5)\n //UIdots overwrite superprim params             \n ;if(pointCount>1.){a.xy=(fra(t,bufDrag(+1.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>2.){a.zw=(fra(t,bufDrag(+2.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>3.){e.xy=(fra(t,bufDrag(+3.).xy,r,m)*viewzoom*2.+1.);} \n  //above is 6 params for superprim0, below is 6 params for superprim1\n ;if(pointCount>4.){c.xy=(fra(t,bufDrag(+4.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>5.){c.zw=(fra(t,bufDrag(+5.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>6.){g.xy=(fra(t,bufDrag(+6.).xy,r,m)*viewzoom*2.+1.);}\n                    //below are 2 more params for offset and CSGunion\n ;v3 o=v3(1,2,1,.3)//offset of one of the shapes  and .z uis Union-parameter\n ;if(pointCount>7.){o.xy=(fra(t,bufDrag(+7.).xy,r,m)*viewzoom*2.+1.);}\n ;if(pointCount>8.){v1 O=(fra(t,bufDrag(+8.).xy,r,m)*viewzoom*2.+1.)\n     ;o.zw=O.xy;}\n ;if(pointCount>10.){sdUberprimZ=(fra(t,bufDrag(+10.).xy,r,m)*viewzoom*2.+1.);}\n\n ;//debug corner cases\n  /* ;a.x=1. ;a.y=1. ;a.z=1.*/\n    \n ;//struct for AD, 2 points to 2 shapes.\n ;c2 q=c2(   su(p.y,0.)     ,   p.z     ,   p.x     )\n ;c2 Q=c2(su(p.x,o.y),su(p.y,o.z),su(p.z,o.x))//offset and swivel\n  \n     \n  \n  // a,c: (width, height, depth, thickness)\n  // e,g: (xy corner radius, z corner radius, bottom radius offset (sdUberprim Only))\n ;D     =sdSuperPrim(q,a,e)//superprim0 \n\n ;\n ;d2 box=sdUberprim(Q,c,v2(g,sdUberprimZ.x))\n ;//d2 box=sdSuperPrim(Q,c,g)//superprim1\n ;//box=su(box,o.w)//use o.w to offset shape thickness.\n     \n     //fBoxCheap(su(p,v2(-1.,1,-.5)),v2(.61))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//D=box2=fBox(p,v2(1))\n ;//D=mind(box,box2);//(box or     box2)\n ;//D=maxd(box,box2);//(box and     box2)\n ;//D=maxd(box,-box2);//(box and not box2)\n ;D=fOpUnionRound(D,box,o.w*3.)\n ;//D=fOpIntersectionRound(box,box2,o.w)\n ;//D=fOpDifferenceRound(box,box2,o.w)\n ;//D=box   \n ;//v0 holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;//d2 s=di(((fSphere(mu(mi(p,v2(.5,.61,-.4)),v2(holesize))))),holesize)\n ;//D=ma(D,ne(s))  //hole(unionround())==bad lipschitz!\n \n     \n  ;if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)\n                    ;m.x=1.-m.x\n                    ;v0 scaleT=1./.5\n                    ;v2 o=v2(sdUberprimZ.y+1.,0,-3)/scaleT\n                    ;p=su(p,o) //yep. the offset must be scaled,too\n                    ;c2 q=c2(   p.y ,   p.z  ,  p.x  )\n                        \n                    ;//q=ad(q,v2(sdUberprimZ.y))\n                  \n                    ;q=mu(p,scaleT)\n  \n                    ;d2 G=sdGoursat(q,m)\n                    ;G.a*=scaleT\n                    ;D=fOpUnionRound(D,G,m.y)\n                     ;}\n /**/     \n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(D,0.));}\n\n\n\n\n\n\n//return distance & materialID\nv1 dm(v2 p){DAMValue d=df(da_domain1(p));return v1(d.d.a,d.m);}\n//return material at p with normal n\nv3 material(v2 p,v2 n ){d2 d=df(da_domain1(v2(p.x,0.,p.z))).d\n ;return mix(v3(n*.5+.5,.1)\n            ,v3(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nv0 shadow(v2 o,v2 i\n){const v0 a=32.//shadow hardnes\n ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const v0 it=clamp(IterSh,0.,64.)\n ;for(v0 j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(v2 p,v2 n,v2 i,v0 d,v3 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=v2(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nv0 rm(v2 o,v2 i\n){const v0 m=20.//distance.Max\n ;v0 e=.0,h=e,t=0.//intersection.precission\n ;const v0 irm=clamp(IterRm,1.,256.)\n ;for(v0 j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;v0 r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in v2 o,in v2 i,in v0 r ){\n   v2 w=normalize(i-o);v2 u=normalize(cross(w,v2(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nv2 getDt1(in v2 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a v3. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\n//set camera position & target\n//first rotate around vertical axis bny t\n//then loop up/down by m\nvoid setCam(out v2 o,out v2 i,v0 t,v0 m\n){\n o=v2(4.*sin(t),m*9.-2.,4.*cos(t));i=v2(0);}\n                               \nv3 in3d(v0 t,v1 u,v2 r,v3 m\n){\n ;v1 v=(u   -r.xy*.5)/r.y\n ;v3 n=v3((m.xy-r.xy*.5)/r.y,(m.zw-r.xy*.5)/r.y)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;v1 zo=v1(t,cos(t)*.5+.5)\n ;if(pointCount >0.//this point sets camera parameters (2 angles)\n ){zo=v1(fra(t,bufDrag(0.).xy,r,n))\n  ;zo=v1(-zo.x*acos(-1.)*2.,cos(clamp(zo.y*2.-1.,-1.65,1.)))//bufDrag(+0.).xy\n ;}\n ;u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;//v1 zo=v1(iMouse.xy/iResolution.xy)  //mouse\n ;v2 o,i,c=v2(0)\n ;setCam(o,i,zo.x,zo.y+.2)//camMovement\n ;v2 d=normalize(calcLookAtMatrix(o,i,camRoll)*v2(u.xy,camLens))//ray.direction\n ;v0 T=rm(o,d)//Distance.raymarched\n ;if(T>-.5\n ){v2 p=o+T*d,n=getDt1(p)//position & normal\n  ;v3 ma=material(p,n)  //material\n  ;c=light(p,n,d,T,ma);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), v2(0.4545) )\n ;return v3(c,1.);}                          \n                                    \n//v3 in2d(v1 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){v1 m=fra(iTime,iMouse.xy,iResolution.xyz,iMouse)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;c1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;v0 outlineThickness=iResolution.y*.5\n ;v0 i=length(v1(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;v0 ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//v0 r=1.-f.x.x\n ;v0 r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//v0 b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//v0 div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(v0 t,v1 u,v2 r,v3 m\n ){u=fra(t,u,r,m)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  v0 h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n                               \n//demoIKBezier is now a dreidelDebugger for iDiegeticUI                        \nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(smoothstep(c.xyzw,-c.xyzw,vec4(viewzoom/Aa(t,u,r,m))),fract(c.xyzw*9.),.2)\n ;//c.xy+=c.w*.2//fold w as yellow\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,0)*c.w))\n ;return c\n ;}\n                               \nvoid mainImage( out v3 O,in v1 u\n){v0 t=iTime\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;m=iMouseZwFix(m,false)\n #if (scene==3)\n ;O=mix(in3d(t,u,r,m),in2d(t,u,r,m),.1)\n #elif (scene==2)\n ;O=in3d(t,u,r,m)\n #elif (scene==1)\n ;O=in2d(t,u,r,m)\n #elif (scene==0)\n ;O=in1d(t,u,r,m)\n #endif \n    \n ;//O=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !\n\n\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//[Re]= [Relativity Engine] v8\n\n//parent  Re7 : https://www.shadertoy.com/view/tlf3zj    (BayesianEpsilon targetFPS)\n//parent  Re0 : https://www.shadertoy.com/view/tdfXDl\n//this seems to have brighter lights than the oldest parent Re0\n//but the diffuse calculation seems to be still identical between Re0 and Re8\n\n//press t to toggle pausing time\n//(note that telativistic effects are also paused\n//, moving closer to an object will fadstForward it to its present state\n//, moving away from an ovject, will have you see its state further in the past.\n\n//the DF still lacks boundingVolumes\n//to collide well with BVs (woth offset) we must add a summand to BV size\n//this optionally enlarges BVs, so we can calculate larger epsilon for collisons.\n//also. collisions should ee done in much hicher precision (small epsilon, small lipschitz stuff\n\n\n/*\nthis initially only rared for camera and cameraCollision\nbut now it may just buffer a lot more\n- some bayeps values\n- object properties for a UI\n- some bayeEps memory to average over (average of last few rendertimes)\n/**/\n\n\n\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\nfloat keyRe(float a){return texture(iChannel1,vec2(a,.5)).x;}//key released\nfloat keyDn(float a){return texture(iChannel1,vec2(a,.2)).x;}//key down\nfloat keyDn(vec2 a){return keyDn(a.x)-keyDn(a.y);}\n\n\nbool Proc(float c,float d,float w){return(abs(d-c*w-.5*w)*2.<w);}\nbool ProcessingOldest(float a, float pos\n){return  (pos>a*varWdth)        //-a*varWdth\n        &&(pos<(a+1.)*varWdth);} //-a*varWdth\n\n\n\n\n/**///---\n/**///---start: fps counter\n\n//https://www.shadertoy.com/view/Ms2cWz\n//this is improving\n//https://www.shadertoy.com/view/lsjyzR#\n//in precision and performance\n//it dares to such the boundaries of floating point percission.\n//way past 5 decimals, \n//which is were reasonable people would stop using only 16 bit float.\n//got a performance boost with code from https://www.shadertoy.com/view/MtyXDV\n//this code is bad at displaying large values in the 2billions.\n//because it insists on tpe float for large values, \n//resulting in rounding such large integers down.\n//\n//this is becase i assume most fragment shader impllementations \n//will do type float FASTER than integer divisions of integers >1million.\n//and i just do not use type int anywhere in here.\n//this funcion is important to avoid SOME rounding errors \n//that can result in \"out of bound\" glyphs that will be caught by clamp(digit,0,9))\n//but then still display the wrong glyph due to \"cascading rounding up\".\n//at roughly the 5th decmal place of values like -78987.8889999999;\nfloat powf(float i){\n //if (i<-8.)return pow(10.,floor(i));\n //line makes makes no difference because for that range you have MUCH different issues first.\n if (i>-1.){\n  if(i>3.){\n   if(i>5.){\n    if(i>6.)return 1e7;return 1e6;}else{\n    if(i>4.)return 1e5;return 1e4;}}else{\n   if(i>1.){\n    if(i>2.)return 1e3;return 1e2;}else{\n    if(i>0.)return 1e1;return 1e0;}}}else{\n  if(i>-5.){\n   if(i>-3.){\n    if (i>-2.)return 1e-1;return 1e-2;}else{\n    if (i>-4.)return 1e-3;return 1e-4;}}else{\n   if(i>-6.){\n    if (i>-6.)return 1e-5;return 1e-6;}else{\n    if (i>-8.)return 1e-7;return 1e-8;}}}}\n//based on \n//https://www.shadertoy.com/view/XsfyDl          =leading zeroes, other precision boons\n//https://www.shadertoy.com/view/lsfcRX          =bufferless bitmap-font version\n//https://www.shadertoy.com/view/4ltXDf          =font texture\n//https://www.shadertoy.com/view/MsXyzX          =less branching for above\n//based on https://www.shadertoy.com/view/Mt2GWD =log10 stuff for decimal spacing\n//\n//core function is floatShow()\n//should be easy to modify to show cursor.xy or values of matrices.\n//\n//only shows [glyphs] decimals left of the decimal point.\n//only shows min(4,[glyphs]) decimals right of the decimal point. (5th rounds poorly)\nconst float glyphs =11.;//max glyphs\n//Sets loop iterations.\n//is used in 2 loops, cycling that often,\n//..once for whats left of the decimal point, once for whats right of the decimal point\n//\n//transparent border around glyphs that\n//replaces thin border of glyph with transparency, does not add whitespace.\nconst float marginT=1.;//if (marginG==1. && small text scale) neigbors can bleed trough.\n//marginT gets obsoleted by [p<-clamp(p,0.,1.)] within char()\n//\n//some compilers may just cry and may refuse to compile shit or just return a black screen.\n#ifdef div0\n//for openGl division by 0 case handling of type float.\nconst float NaN= 0./0.;\nconst float Inf= 1./0.;\nconst float NIn=-1./0.;\nconst float Po0= pow(0.,0.);\n//pow(0.,0.) should be \"ndef\" or \"NaN\", but is \"0.\" (or \"1.\") depending on hardware.\n#endif\n#define lt(a) lessThan(vec2(-1.),a)\nbool whiteRectangle(vec2 u){\n bvec2 a=lessThan(vec2(-1.),-abs(u));//bvec2 a=greaterThan(vec2(.1), uv); \n return (a.x&&a.y);}//inspired by https://www.shadertoy.com/view/ldScRm\n//bool whiteRectangle2(vec2 i){bvec2 a=lt(-i),b=lt(i);//symmetry--:\n// return (a.x&&a.y)&&(b.x&&b.y);}//inspired by https://www.shadertoy.com/view/ldScRm\nbool isInside3(vec2 p){return !whiteRectangle(p*2.-1.);}\n// --- access to the image of ascii code c\nvec4 char(vec2 p,float c){\n  if(isInside3(p*marginT))return vec4(0,0,0,1e5); //optional shortcut...\n    //+3fps max, boost declines over time down to +1 fps (base fps is 50 fps)\n  return texture(iChannel0,clamp(p,0.,1.)/16.+fract(floor(vec2(c,16.-(1e-6)-floor(c)/16.))/16.));\n}//via https://www.shadertoy.com/view/MtyXDV\n//p=fragment, n=float value\nvec4 print_number(vec2 p,float n){return char(p,clamp(mod(n,10.),0.,9.)+48.);}\n//#define logb(b,x) log(x)/log(b)\nconst float l10=(1./log(10.));//precalc for speed\n#define log10(x) log(x)*l10\n//#define log10(x) logb(10.,x)//would be slower, log() is slow.\n//http://stackoverflow.com/questions/14081024/opengl-using-a-logarithmic-coordinates-axis\n//return number of digits left of decimal point\nfloat getWholeDigits(float f){if(abs(f)==0.)return 0.;return floor(log10(max(abs(f),0.0000001)))+1.;}\n//see http://stackoverflow.com/questions/1068849/how-do-i-determine-the-number-of-digits-of-an-integer-in-c\n//to remember that dumb|raw solutions can often outperform smart solutions.\n#define ch(n) char(p,n).x;p.x-=.5;\n//left==digits left to the decimal point, relevant for other text being left-endian.\n//commonly left=getWholeDigits(abs(number));\n//and you can add one leading zero by \n// left=getWholeDigits(abs(number))+1.;\n//right==digits right of the decimal point (todo, fix pathethic rounding errors)\n//w returns the total width of the float in glyphs.\nvec4 floatShow(vec2 p,float f,float left,float right,out float w){vec4 o=vec4(0); \n w=p.x;\n#ifdef div0\n #define ro w-=p.x;return o;}\n if(f==NaN){     o+=ch( 78)o+=ch( 97)o+=ch( 78)ro//Nan //  0./0.\n else if(f==Inf){o+=ch( 73)o+=ch(110)o+=ch(102)ro//Inf // +1./0.;\n else if(f==NIn){o+=ch(126)o+=ch( 73)o+=ch(110)ro//~In // -1./0.\n#endif\n if(f<.0){f=abs(f);o+=ch(45.)}//negative number handling:\n float n=left;           \n for(float i=glyphs;i>-1.;i--){ \n  if(left<1.){o+=print_number(p,0.).x;p.x-=.5;break;}\n  float ex=-i-n+glyphs+1.;\n  //ex=max(0.,ex);\n  float n=pow(10.,ex);if(abs(n)>0.){\n   o+=print_number(p,f*n).x;p.x-=.5;}\n  left--;if(left<=0.)break;}\n //decimal point shifting,making \".\" non-fixedwidth:\n f=fract(f);//=mod(f,1.);//=1.-floor(f);//adds rounding errors.\n p.x+=.1;\n o+=char(p,46.).x;p.x-=2.5-.1; //44->\",\" :: 46->\".\"\n p.x+=2.;\n //digits right of the decimal point:\n float decimals=right;\n for(float i=decimals;i>0.;i--){\n  float n=\n  //pow(10.,decimals-i+1.);\n    powf(   decimals-i+1.);\n    //n=1e9;//this overwrite shows that above function is not the culpit.\n  o+=print_number(p,f*n).x;p.x-=.5;\n }w-=p.x;return o;}         \nvec4 fpsTopLeftCorner(vec4 o,vec2 p\n){p.y-=.94\n ;p.x+=.01\n ;p *= 16.2\n ;float w=0.\n ;float left=0.\n ;float fpsFrame=iTimeDelta\n ;if(abs(fpsFrame)>0.\n ){fpsFrame=1./fpsFrame\n  ;left=getWholeDigits(abs(fpsFrame))\n  ;o+=floatShow(p,fpsFrame,left,2.,w).x\n ;}else fpsFrame=0.000001;left=2.\n ;o*=.5*(smoothstep(0.,1.,o.w))\n ;o=max(o,vec4(0))\n ;o=sqrt(o)//cheap cubic bloom    \n ;return o;}\n/**/\n/*            \nvoid mainImage(out vec4 o,vec2 u\n){vec32i =u/iResolution.y\n ;if(i.x<.15&&i.y>.95){\n ;o=mainImage2(o,i);//number overlay\n ;}}\n/**///---end__: fps counter\n/**///\n/**///---start: BufferModifiers (camera movement) \n\nvoid mainImage(out vec4 o,in vec2 u\n){vec2 i=u/iResolution.y\n ;if(i.x<.15&&i.y>.95){o=fpsTopLeftCorner(o,i);return;}//number overlay\n ;if(u.y>1.||u.x>varWdth*10.){o=vec4(0.);return;}\n ;float v=u.x    \n ;float w=varWdth\n ;if(iFrame<5//init\n ){if(Proc(ReTimE,v,w))o=vec4(0,1,iTimeDelta,0)//set speed of time to 1\n ;}else{\n ;vec2 edit =Get(ReEdit).xy\n ;pos       =Get(RePos).xyz\n ;dpos      =Get(RePosD).xyz\n ;vec4 quat =Get(ReQua)\n ;//vec4 dquat=Get(ReQuaD)\n ;vec4 time =Get(ReTime)//time stores 4 short term averages of iTimeDeltas\n                        //timE.xyz stores 3 long term averges of iTimeDeltas\n ;vec4 timE =Get(ReTimE)//timE.w stores cameraTime (is negative when time is paused\n ;performance(time,timE.xyz,iTimeDelta,float(iFrame))\n //accumulate 7 incremental averages of iTimeDelta\n //time.xyxz averages (up to) 2,4,8,16  most recent iTimeDelta\n //timE.xyz  averages (up to) 32,64,128 most recent iTimeDelta\n //the (non weighted) average of these 7 values smooths (most recent) performance holes?\n ;float deltaT=iTimeDelta\n ;float plf   =LorentzFactor(length(dpos))\n ;if(timE.w>=0.)timE.w+=deltaT* mix(1.,plf,TimeDilation)\n ;SetTime(abs(timE.w))\n ;oCamSet(pos,quat)\n ;mat3 m=mat3(1)\n ;vec3 acc=vec3(0)\n ,right  =qr(quat,m[0])\n ,up     =qr(quat,m[1])\n ,forward=qr(quat,m[2])\n ,velDir         =normalize(dpos)\n ;vec4 normDist  =GetNormal(pos+vec3(0.,-2.,0.))\n ;vec3 norm      =normDist.xyz\n ;float proxAlert=normDist.w\n ;//grav += normalize(norm-grav) * iTimeDelta\n ;//collisions\n ;float collisionViolence = dot(velDir,-norm)\n //2020-11 new imouse.zw fix\n ;vec4 mouse=iMouse;mouse=iMouseZwFix(mouse,true)\n ;vec2 e=vec2(.002,0)\n ,pitchYaw = Get(ReCamR).xy\n ,joystick=(mouse.xy-mouse.zw)/iResolution.yy\n ;if(mouse.x == 0. && mouse.y == 0.)joystick *= 0.\n ;joystick*=max(1.,joystick.x)\n ;joystick*=8.\n ;if(!(mouse.w <=0.)//if mouse should have an effect\n ){if(edit.x>0.\n  ){ //edit mode mouse==march the scene at the mouse cursor direction\n   ;\n  ;}else{//mouse rotates camera\n   ;pitchYaw += joystick*deltaT\n   ;pitchYaw.y = clamp(pitchYaw.y,-pi*.5,pi*.5)\n ;}}//end of case, cause we can still move, while not rotating the camera\n ;quat =aa2q(pitchYaw.x,vec3(0,1,0))\n ;right=qr(quat,vec3(1.,0.,0.))\n ;quat =qm(aa2q(-pitchYaw.y,right),quat)\n ;vec3 groundForwardDir = cross(right,vec3(0,1,0))  \n ;acc+=keyDn(vec2(KEY_E,KEY_D)/255.)*groundForwardDir*thrustForce\n ;acc+=keyDn(vec2(KEY_F,KEY_S)/255.)*right*thrustForce\n ;if(length(acc)>thrustForce)acc=normalize(acc)*thrustForce\n ;acc+= gravity;// * abs(dot(norm,forward));   //gravity\n ;acc-=(dpos/maxSpeed)*thrustForce  //drag\n ;//add acceleration\n ;//dpos +=  deltaT*acc\n ;dpos +=  (deltaT*acc);///(plf*plf);\n ;//properDpos += (deltaT*acc)/(plf*plf);\n ;if(length(dpos)>maxSpeed)dpos=normalize(dpos)*0.999*maxSpeed\n ;if(proxAlert <=0.\n ){//if (collisionViolence > 0.)\n  ;//dpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n  ;dpos.y =0.\n  ;//pos.y=0.\n  ;//pos  =vec3(0.,0.,-4.)\n  ;}\n ;vec4 wallCollision = GetNormal(pos)\n ;//velDir = normalize(dpos)\n ;//nosefall/stall\n ;//quat=MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat)\n ;//add derivatives\n ;pos+=deltaT*dpos*mix(1.,plf,TimeDilation)\n ;if(wallCollision.w<.5\n ){dpos.xz-=max(0.,dot(dpos.xz,-wallCollision.xz))*dpos.xz\n  ;pos.xz+=(wallCollision.xz)*(.5-wallCollision.w);}\n ;if (iFrame == 0\n ){dpos=vec3(0)\n  ;pos =vec3(0,0,-4.)\n  ;quat=vec4(0,0,0,1)//BuildQuat(vec3(1.,0.,0.),1.57)\n  ;}\n ;     if(Proc(RePos    ,v,w))o=vec4(pos,1.) //camPos\n ;else if(Proc(RePosD   ,v,w))o=vec4(dpos,1.)//camMovement\n ;else if(Proc(ReQua    ,v,w))o=quat         //camRotation\n //;else if(Proc(ReQuaD   ,v,w))o=dquat        //camRotationChange\n ;else if(Proc(RePosDD  ,v,w))o=vec4(acc,1.) //camAccelleration\n ;else if(Proc(ReCamR   ,v,w))o=vec4(pitchYaw,0,0)\n\n ;else{\n  ;float kG=keyRe(KEY_G/255.)\n      //if (G is not pressed && T is pressed) == !(G||(!T))\n  ;if(!(kG>0.||!(keyRe(KEY_T/255.)>0.)))timE.w=-timE.w //pausingTime always toggles independently\n  ;//this way you may press g and t at the same time\n  ;if(kG>0.\n  ){if(edit.x<1.){timE.w=-abs(timE.w);edit.x=1.//key-G overwrites the unpausing of T into pausing\n   ;}else edit.x=0.;}//if edit mode is entered, time also pauses\n                     //but if edit mode ends, time stays as it is\n  ;     if(Proc(ReTimE   ,v,w))o=timE          //store state of time\n  ;else if(Proc(ReTime   ,v,w))o=time          //store state of time\n  ;else if(Proc(ReEdit   ,v,w))o=vec4(edit,0,0)//store state of editMode\n ;}}}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//iTR  TemporalReprojection\n\n// almost entirely:\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n//ichan0=wood\n//ichan1=self C (optional for blur instead of celshaded black outlines)\n//ichan3=void\n//ichan3=self C\n//other ichannels may cause silly artefacts (ppixels with 0-vallues seem to create nans, that then make white dots in dark areas)\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel0, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel0, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n #ifndef SceneTR\n ;fragColor=vec4(1);return\n #endif\n ;vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf3(vec2(0,0),r)\n                  ,tf3(vec2(1,0),r)\n                  ,tf3(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf3(ipos,r)\n  ;vec4 odata2=tf3(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf3(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf3(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}