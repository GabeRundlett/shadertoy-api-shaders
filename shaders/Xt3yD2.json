{
    "Shader": {
        "info": {
            "date": "1534009711",
            "description": "Today is a day for a picnic.",
            "flags": 96,
            "hasliked": 0,
            "id": "Xt3yD2",
            "likes": 43,
            "name": "[SH18] PICNIC",
            "published": 3,
            "tags": [
                "human",
                "picnic",
                "sh18"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 1093
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////////////////////////////////////////////////\n//   ___    _  ___    _   _  _  __\n//  (  _`\\ (_)(  _`\\ ( ) ( )(_)(  _`\\\n//  | |_) )| || ( (_)| `\\| || || ( (_)\n//  | ,__/'| || |  _ | , ` || || |  _\n//  | |    | || (_( )| |`\\ || || (_( )\n//  (_)    (_)(____/'(_) (_)(_)(____/'\n//\n//  [SH18] PICNIC by iY0Yi\n//  https://www.shadertoy.com/view/Xt3yD2\n//\n//  Created by Atsushi Hashimoto 2018\n//\n//  Soundtrack by Shojiro Nakaoka\n//  https://www.shojironakaoka.com/\n//  Check out his New Album! https://shojironakaoka.bandcamp.com/album/e\n//\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired shaders:\n//  \"Sparse grid marching\" by nimitz:\n//  https://www.shadertoy.com/view/XlfGDs\n//  \"Shepherd Drone\" by eiffie:\n//  https://www.shadertoy.com/view/XsG3Rd\n//  \"Boids\" by aytekaman:\n//  https://www.shadertoy.com/view/Mlc3Rl\n//  and many others...\n//\n//  You can tweak rendering quality in \"Common\" tab.\n//  \"SPLIT_NUM\"/\"SHRINK_RENDER\"/\"FULLSCREEN_RESOLUTION\"\n//\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    commonalizeUniforms(iTime, iTimeDelta, iFrame, iResolution, iDate);\n    vec3 col0 = texfilter(fragCoord, iChannel0, iChannelResolution[0].xy);\n    vec3 col1 = texsample(0, 0, fragCoord, iChannel0, iChannelResolution[0].xy);\n    vec3 col = (col0*0.75+col1*0.25);\n    col*=camEase(smoothstep(0.0,1.0,cTime));\n    col*=camEase(1.0-smoothstep(DURATION-10.0, DURATION, cTime));\n    \n    col=smoothstep(0.05,1.,col1);\n    col = ACESFilm(col);\n    col=pow(col,vec3(0.75));\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 15771,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user-261508398/picnic-01-05"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   ___\n//  (  _`\\\n//  | ( (_)   _     ___ ___    ___ ___     _     ___\n//  | |  _  /'_`\\ /' _ ` _ `\\/' _ ` _ `\\ /'_`\\ /' _ `\\\n//  | (_( )( (_) )| ( ) ( ) || ( ) ( ) |( (_) )| ( ) |\n//  (____/'`\\___/'(_) (_) (_)(_) (_) (_)`\\___/'(_) (_)\n//\n\n//#######################################\n//#                                     #\n//#  Useful tools to render SDF scenes  #\n//#                                     #\n//#######################################\n\n#define DURATION 192.0\n\n// For Blender\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//#define BLENDER\n#ifdef BLENDER\nuniform float iTime;\nuniform vec2 iResolution;\nuniform float iDebugAlpha;\nuniform float fov;\nuniform vec3 eye;\nuniform vec3 lookat;\nvarying vec2 fragCoord;\n#define fragColor gl_FragColor\n#endif\n\n// Constants\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define SQRT2 1.41421356237\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Commonalized uniforms\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cTime=0.0;\nfloat cTimeDelta=0.0;\nint cFrame=0;\nvec3 cResolution=vec3(0.0);\nvec4 cDate=vec4(0);\nvec4 cMouse=vec4(0);\nvoid commonalizeUniforms(float time, float timeDelta, int frame, vec3 resolution, vec4 date)\n{cTime=mod(time, DURATION);cTimeDelta=timeDelta;cFrame=frame;cResolution=resolution;cDate=date;}\n\n// Random Generators\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"Hash without Sine\" by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n// #define HASHSCALE1 .1031 /*Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.*/\n#define HASHSCALE1 443.8975 /*For smaller input rangers like audio tick or 0-1 UVs use these...*/\nfloat hash11(float p){vec3 p3 = fract(vec3(p) * HASHSCALE1);p3 += dot(p3, p3.yzx + 19.19);return fract((p3.x + p3.y) * p3.z);}\nfloat hash12(vec2 p){vec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);p3 += dot(p3, p3.yzx + 19.19);return fract((p3.x + p3.y) * p3.z);}\nfloat hash13(vec3 p3){p3 = fract(p3 * HASHSCALE1);p3 += dot(p3, p3.yzx + 19.19);return fract((p3.x + p3.y) * p3.z);}\n// \"Random number generator\"\n// https://www.ci.i.u-tokyo.ac.jp/~hachisuka/tdf2015.pdf\nvec4 seed = vec4(0);\nfloat rnd(inout vec4 n){const vec4 q=vec4(1225.0,1585.0,2457.0,2098.0);const vec4 r=vec4(1112.0,367.0,92.0,265.0);const vec4 a=vec4(3423.0,2646.0,1707.0,1999.0);const vec4 m=vec4(4194287.0,4194277.0,4194191.0,4194167.0);vec4 beta=floor(n/q);vec4 p=a*(n-beta*q)-beta*r;beta=(sign(-p)+vec4(1.0))*vec4(0.5)*m;n=(p+beta);return fract(dot(n/m,vec4(1.0,-1.0,1.0,-1.0)));}\n// FBM\nfloat hash( vec2 p ){float h = dot(p,vec2(127.1,311.7));return -1.0 + 2.0*fract(sin(h)*43758.5453123);}\nfloat noise(vec2 p){vec2 i = floor( p );vec2 f = fract( p );vec2 u = f*f*(3.0-2.0*f);return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),mix( hash( i + vec2(0.0,1.0)), hash( i + vec2(1.0,1.0) ), u.x), u.y);}\nfloat fbm(vec2 p){const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );float f = 0.0;f += 0.5000*noise( p ); p = m*p*2.02;f += 0.2500*noise( p ); p = m*p*2.03;f += 0.1250*noise( p ); p = m*p*2.01;f += 0.0625*noise( p );return f/0.9375;}\nvec2 fbm2(vec2 p){return vec2( fbm(p.xy), fbm(p.yx));}\nvec3 fbm3(vec3 p){return vec3( fbm(p.xy), fbm(p.zx), fbm(p.yz));}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticOut(float t){return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n#define camEase(x) sineInOut(x)\n// Other Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//vec3 rX(vec3 p,float rx){float sinx=sin(rx);float cosx=cos(rx);return mat3(1.,0.,0.,0.,cosx,sinx,0.,-sinx,cosx)*p;}\n//vec3 rY(vec3 p,float ry){float sinx=sin(ry);float cosx=cos(ry);return mat3(cosx,0.,-sinx,0.,1.,0.,sinx,0.,cosx)*p;}\n//vec3 rZ(vec3 p,float rz){float sinx=sin(rz);float cosx=cos(rz);return mat3(cosx,sinx,0.,-sinx,cosx,0.,0.,0.,1.)*p;}\n//vec3 rXY(vec3 p,vec2 r){return rX(rY(p,r.y),r.x);}\n//vec3 rXZ(vec3 p,vec2 r){return rX(rZ(p,r.y),r.x);}\n//vec3 rYZ(vec3 p,vec2 r){return rY(rZ(p,r.y),r.y);}\n//vec3 rXYZ(vec3 p,vec3 r){return rX(rY(rZ(p,r.z),r.y),r.x);}\n\n// SDFs\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sgn(float x){return(x<0.0)?-1.0:1.0;}\nvec2 sgn(vec2 v){return vec2((v.x<0.0)?-1.0:1.0,(v.y<0.0)?-1.0:1.0);}\nfloat vmax(vec3 v){return max(max(v.x, v.y), v.z);}\nfloat sdPlane(in vec3 p){return p.y;}\nfloat sdSphere(in vec3 p,in float r){return length(p)-r;}\nfloat sdEllipsoid(in vec3 p, in vec3 r){return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);}\nfloat sdCapsule(vec3 p, float r, float c) {return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));}\nfloat udBox(vec3 p,vec3 b){return length(max(abs(p)-b*0.5,0.0));}\nfloat udRoundBox( vec3 p,vec3 b,float r){return length(max(abs(p)-b,0.0))-r;}\nfloat sdTorus( vec3 p, vec2 t ){vec2 q = vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\nfloat sdCappedCylinder( vec3 p, vec2 h ){vec2 d = abs(vec2(length(p.xz),p.y)) - h;return (min(max(d.x,d.y),0.0) + length(max(d,0.0)));}\nfloat sdConeSection(in vec3 p,in float h, in float r1,in float r2){float d1=-p.y-h; float q=p.y-h; float si=0.5*(r1-r2)/h; float d2=max(sqrt(dot(p.xz,p.xz)*(1.0-si*si))+q*si-r2,q); return length(max(vec2(d1,d2),0.0))+min(max(d1,d2),0.);}\nfloat sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(max(d,vec3(0)))+vmax(min(d,vec3(0)));}\n\nfloat opU(in float a,in float b){return a<b?a:b;}\nfloat opSU(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return mix(b,a,h)-k*h*(1.0-h);}\nfloat opS(in float a,in float b){return max(-a, b);}\nfloat opSS( float a,float b,float k){return opSU(-a, b, -k);}\nfloat opI(in float a,in float b){return max(a, b);}\nfloat opSI( float a,float b,float k){return opSU(a, b, -k);}\n\nvec2 opU(in vec2 a,in vec2 b){return a.x<b.x?a:b;}\nvec2 opSU(vec2 a,vec2 b,float k){float h=clamp(0.5+0.5*(b.x-a.x)/k,0.0,1.0);return mix(b,a,h)-k*h*(1.0-h);}\nvec2 opS(in vec2 a,in vec2 b){float res = max(-a.x, b.x); return (res==-a.x)?vec2(-a.x, a.y):b;}\nvec2 opSS( vec2 a,vec2 b,float k){return opSU(vec2(-a.x,a.y), b, -k);}\nvec2 opI(in vec2 a,in vec2 b){float res = max(a.x, b.x); return (res==a.x)?a:b;}\nvec2 opSI( vec2 a,vec2 b,float k){return opSU(a, b, -k);}\n\n// Debugging\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sampleFont (vec4 size, vec2 character, vec2 uv, in sampler2D texSlot){if(uv.x>size.x&&uv.y>size.y&&uv.x<size.x+size.z&&uv.y<size.y+size.w)return smoothstep(0.0,0.8, texture(texSlot, (vec2((uv.x-size.x)/size.z, (uv.y-size.y)/size.w)+character)/16.).r);}\n#define t(x) fill = max(fill,sampleFont(vec4(align, size), x, uv, texSlot));\nvec3 text(in float num, in vec3 dest, in vec2 uv, in sampler2D texSlot){vec3 col=vec3(1.0,1.0,1.0);int digits = 5;vec2 size = vec2(0.05);vec2 spacing = vec2(size.x*0.44, 0.0);vec2 align = vec2(0.0, -size.y/2.);vec2 coord = vec2(0.0, -1.0);uv+=coord; uv.y+=size.x;vec2 sgn = vec2((num<0.0)?13:0,13);num=abs(num);vec2 hundreds = vec2(floor(mod(num/100., 10.)), 12);vec2 tens = vec2(floor(mod(num/10., 10.)), 12);vec2 ones = vec2(floor(mod(num, 10.)), 12);vec2 tenths = vec2(floor(mod(num*10., 10.)), 12);vec2 hundredths = vec2(floor(mod(num*100., 10.)), 12);vec2 dp=vec2(14,13);float fill = 0.; align+=spacing;t(sgn)t(hundreds)t(tens)t(ones)t(dp)t(tenths)t(hundredths)return mix(dest,col,fill);}\n\n\n\n\n\n\n//################\n//#              #\n//#  For PICNIC  #\n//#              #\n//################\n\n\n// Refferenced Functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"Shepherd Drone\" by eiffie: https://www.shadertoy.com/view/XsG3Rd\nvec2 bx_cos(vec2 a) {return clamp(abs(mod(a, 8.0) - 4.0) - 2.0, -1.0, 1.0);}\nvec2 bx_cossin(float a) {return bx_cos(vec2(a, a - 2.0));}\nfloat bx_length(vec2 p) {return max(abs(p.x), abs(p.y));}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\n// \"bicubic\" by simesgreen: https://www.shadertoy.com/view/4df3Dn\nfloat w0(float a){return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);}\nfloat w1(float a){return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);}\nfloat w2(float a){return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);}\nfloat w3(float a){return (1.0/6.0)*(a*a*a);}\nfloat g0(float a){return w0(a) + w1(a);}\nfloat g1(float a){return w2(a) + w3(a);}\nfloat h0(float a){return -1.0 + w1(a) / (w0(a) + w1(a));}\nfloat h1(float a){return 1.0 + w3(a) / (w2(a) + w3(a));}\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize){uv = uv*texelSize.zw + 0.5;vec2 iuv = floor( uv );vec2 fuv = fract( uv );float g0x = g0(fuv.x);float g1x = g1(fuv.x);float h0x = h0(fuv.x);float h1x = h1(fuv.x);float h0y = h0(fuv.y);float h1y = h1(fuv.y);vec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;vec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;vec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;vec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;return g0(fuv.y) * (g0x * texture(tex, p0)  +g1x * texture(tex, p1)) +g1(fuv.y) * (g0x * texture(tex, p2)  +g1x * texture(tex, p3));}\n\n//\"poisson-disc-blur-fs.glsl\" by spite: https://github.com/spite/Wagner/blob/master/fragment-shaders/poisson-disc-blur-fs.glsl\nconst int NUM_TAPS=27;\nconst float rcp_maxdist=1.0/4.22244;\nvec3 poissonSampling(sampler2D buffer, vec2 uv, float max_siz){vec2 fTaps_Poisson[NUM_TAPS];fTaps_Poisson[0]=rcp_maxdist*vec2(-0.8835609,2.523391);fTaps_Poisson[1]=rcp_maxdist*vec2(-1.387375,1.056318);fTaps_Poisson[2]=rcp_maxdist*vec2(-2.854452,1.313645);fTaps_Poisson[3]=rcp_maxdist*vec2(0.6326182,1.14569);fTaps_Poisson[4]=rcp_maxdist*vec2(1.331515,3.637297);fTaps_Poisson[5]=rcp_maxdist*vec2(-2.175307,3.885795);fTaps_Poisson[6]=rcp_maxdist*vec2(-0.5396664,4.1938);fTaps_Poisson[7]=rcp_maxdist*vec2(-0.6708734,-0.36875);fTaps_Poisson[8]=rcp_maxdist*vec2(-2.083908,-0.6921188);fTaps_Poisson[9]=rcp_maxdist*vec2(-3.219028,2.85465);fTaps_Poisson[10]=rcp_maxdist*vec2(-1.863933,-2.742254);fTaps_Poisson[11]=rcp_maxdist*vec2(-4.125739,-1.283028);fTaps_Poisson[12]=rcp_maxdist*vec2(-3.376766,-2.81844);fTaps_Poisson[13]=rcp_maxdist*vec2(-3.974553,0.5459405);fTaps_Poisson[14]=rcp_maxdist*vec2(3.102514,1.717692);fTaps_Poisson[15]=rcp_maxdist*vec2(2.951887,3.186624);fTaps_Poisson[16]=rcp_maxdist*vec2(1.33941,-0.166395);fTaps_Poisson[17]=rcp_maxdist*vec2(2.814727,-0.3216669);fTaps_Poisson[18]=rcp_maxdist*vec2(0.7786853,-2.235639);fTaps_Poisson[19]=rcp_maxdist*vec2(-0.7396695,-1.702466);fTaps_Poisson[20]=rcp_maxdist*vec2(0.4621856,-3.62525);fTaps_Poisson[21]=rcp_maxdist*vec2(4.181541,0.5883132);fTaps_Poisson[22]=rcp_maxdist*vec2(4.22244,-1.11029);fTaps_Poisson[23]=rcp_maxdist*vec2(2.116917,-1.789436);fTaps_Poisson[24]=rcp_maxdist*vec2(1.915774,-3.425885);fTaps_Poisson[25]=rcp_maxdist*vec2(3.142686,-2.656329);fTaps_Poisson[26]=rcp_maxdist*vec2(-1.108632,-4.023479);vec4 sum = vec4(0);vec2 seed = uv;seed += fract( cTime);float rnd = 6.28*hash12(seed);vec4 basis = vec4( rotate(vec2(1,0),rnd), rotate(vec2(0,1),rnd));for (int i=0; i < NUM_TAPS; i++){vec2 ofs = fTaps_Poisson[i]; ofs = vec2(dot(ofs,basis.xz),dot(ofs,basis.yw));vec2 texcoord = uv + max_siz*ofs /cResolution.xy;sum += texture(buffer, texcoord, -10.0);}return vec4(sum / vec4(NUM_TAPS)).xyz;}\n\n//\"\" by 4rknova: https://www.shadertoy.com/view/llXGWf\nvec3 texsample(const int x, const int y, in vec2 fragCoord, in sampler2D tex, in vec2 texSize){vec2 uv = fragCoord.xy / cResolution.xy * texSize.xy;uv = (uv + vec2(x, y)) / texSize.xy;return texture(tex, uv).xyz;}\nvec3 texfilter(in vec2 fragCoord, in sampler2D tex, in vec2 texSize){return texsample(-1, -1, fragCoord, tex, texSize) * -1.+texsample(-1,  0, fragCoord, tex, texSize) * -1.+texsample(-1,  1, fragCoord, tex, texSize) * -1.+texsample( 0, -1, fragCoord, tex, texSize) * -1.+texsample( 0,  0, fragCoord, tex, texSize) *  9.+texsample( 0,  1, fragCoord, tex, texSize) * -1.+texsample( 1, -1, fragCoord, tex, texSize) * -1.+texsample( 1,  0, fragCoord, tex, texSize) * -1.+texsample( 1,  1, fragCoord, tex, texSize) * -1.;}\n\n// Split/Shrink rendering\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define SPLIT_RENDER\n\n// Should be x8.0 number.\n#define WAVEFRONT_UNIT 256.0\n\n// 1.0:60.0fps / 2.0:30.0fps / 3.0:20.0fps...\n#define SPLIT_NUM 3.0\n\n// 1.0 is full quality.\n#define SHRINK_RENDER 1.\n\n#define FULLSCREEN_RESOLUTION 1200.0\nvec2 getDrawRes(vec2 res){float drawWidth=min(FULLSCREEN_RESOLUTION, WAVEFRONT_UNIT*floor((res.x*SHRINK_RENDER)/WAVEFRONT_UNIT));return vec2(drawWidth, floor(res.y*(drawWidth/res.x)));}\n\n\n// Scene Settings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.0005\n#define MAX_DIST 800.0\n#define DATABLOCK_SIZE 150.0\n#define GRID_SIZE 8.0\n#define TREE_MARGIN 30.0\n#define ITERATION 300\n\nvec3 gro = vec3(0);\nvec3 grd = vec3(0);\nfloat dBox( in vec3 ro, in float center){vec3 m = 1.2 / grd;vec3 t = -m * ro + abs(m) * (center*0.5+0.01);return min(min(t.x, t.y), t.z);}\nfloat dBox2D( in vec2 ro, in float center){vec2 m = 1.2 / grd.xz;vec2 t = -m * ro + abs(m) * (center*0.5+0.01);return min(t.x, t.y);}\n\nstruct ObjData\n{\n    vec2 position;\n    vec2 velocity;\n\n    vec2 ids;\n    float state;\n    float timer;\n};\n\n#define STATE_WALK 1.0\n#define STATE_HAPPY 2.0\n#define STATE_CAMERA -1.0\n\n#define TIMER_MAX_DUR 5.0\n\n#define EMPTY -9.0\n#define TREE vec4(5.0, -5.0, 5.0, 5.0)\n#define VOID vec4(-0.5, 0.5, 0.0, 0.0)\n#define NO_TREE vec2(-20.0)\n\n#define loopCoord(coord) (mod(coord, DATABLOCK_SIZE));\n\nObjData fetchObjData(vec2 u, in sampler2D buffer)\n{\n    ObjData objData;\n    vec4 packedObjData;\n    packedObjData = texelFetch(buffer, ivec2(u),0);\n    objData.position = packedObjData.xy;\n    objData.velocity = packedObjData.zw;\n    packedObjData = texelFetch(buffer, ivec2(u.x+DATABLOCK_SIZE, u.y),0);\n    objData.ids = packedObjData.xy;\n    objData.state = packedObjData.z;\n    objData.timer = packedObjData.w;\n    return objData;\n}\nObjData fetchCameraData(vec2 u, in sampler2D buffer)\n{\n    ObjData objData;\n    vec4 packedObjData;\n    packedObjData = texelFetch(buffer, ivec2(u),0);\n    objData.position = packedObjData.xy;\n    objData.velocity = packedObjData.zw;\n    packedObjData = texelFetch(buffer, ivec2(u.x+1.0, u.y),0);\n    objData.ids = packedObjData.xy;\n    objData.state = packedObjData.z;\n    objData.timer = packedObjData.w;\n    return objData;\n}\nbool isMan(ObjData obj) {return (obj.position.y > -1.5);}\nbool isTree(ObjData obj) {return (obj.position.xy == TREE.xy);}\nbool isCamera(ObjData obj) {return (obj.state == STATE_CAMERA);}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//   _____                              _\n//  (  _  )        _                   ( )_  _\n//  | (_) |  ___  (_)  ___ ___     _ _ | ,_)(_)   _     ___\n//  |  _  |/' _ `\\| |/' _ ` _ `\\ /'_` )| |  | | /'_`\\ /' _ `\\\n//  | | | || ( ) || || ( ) ( ) |( (_| || |_ | |( (_) )| ( ) |\n//  (_) (_)(_) (_)(_)(_) (_) (_)`\\__,_)`\\__)(_)`\\___/'(_) (_)\n//   ___                  _                _\n//  (  _`\\               ( )_             (_ )\n//  | ( (_)   _     ___  | ,_) _ __   _    | |\n//  | |  _  /'_`\\ /' _ `\\| |  ( '__)/'_`\\  | |\n//  | (_( )( (_) )| ( ) || |_ | |  ( (_) ) | |\n//  (____/'`\\___/'(_) (_)`\\__)(_)  `\\___/'(___)\n//\n\n\n//Consts & utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define FPS 60.0\n#define WRITE_DATA(data) fragColor = data\n\n#define BOID_DENSITY 0.25\n#define NEIGHBOR_DIST 4\n#define DESIRED_SEPERATION 3.5\n#define MAX_SPEED 0.2\n#define MAX_ACC 2.5\n#define MAX_FORCE 0.0025\n\n#define NEIGHBOR_DIST_SQR (NEIGHBOR_DIST * NEIGHBOR_DIST)\n#define DESIRED_SEPERATION_SQR (DESIRED_SEPERATION * DESIRED_SEPERATION)\n\nvec4 packObjData( in ObjData objData, in int datablock)\n{\n    if (datablock == 2)\n    {return vec4(objData.position, objData.velocity);}\n    else\n    {return vec4(objData.ids, objData.state, objData.timer);}\n}\n\n\n// Data manager\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid setEmpty(inout ObjData obj)\n{\n    obj.position = vec2(EMPTY);\n    obj.velocity = vec2(EMPTY);\n    obj.ids = vec2(EMPTY);\n    obj.state = EMPTY;\n    obj.timer = EMPTY;\n}\n\nObjData initObjData(vec2 coord)\n{\n    ObjData obj;\n    setEmpty(obj);\n\n    highp float born = hash(floor(coord.yx) * 123.6578);\n\n    if(hash(coord) > 1.0 - BOID_DENSITY)\n    {\n        obj.position = fbm2(coord);\n        obj.velocity = fbm2(coord+obj.position);\n        obj.ids = fbm2(coord)*4.0;\n        obj.state = 1.0;\n        obj.timer = (hash(obj.position) * 0.5 + 0.5) * TIMER_MAX_DUR;\n    }\n    return obj;\n}\n\nvoid updateObj(inout ObjData obj, vec2 gCoord)\n{\n    vec2 cPos = loopCoord(obj.position+gCoord);\n    vec2 cVel = obj.velocity;\n\n    int nCount = 0;\n    int sCount = 0;\n\n    vec2 alignment = vec2(0);\n    vec2 cohesion = vec2(0);\n    vec2 seperation = vec2(0);\n\n    float neartree=1.0;\n    vec2 dirtree=vec2(0.0);\n\n    for (int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++)\n    {\n        for (int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++)\n        {\n            // get neighber data\n            if((i == 0 && j == 0) || (i * i + j * j > NEIGHBOR_DIST_SQR)){continue;}\n            vec2 offset = vec2(i,j);\n            vec2 lCoord = loopCoord(gCoord + offset);\n            ObjData nobj = fetchObjData(lCoord, iChannel0);\n\n            if (isMan(nobj))\n            {\n                vec2 nPos = nobj.position+lCoord;\n                vec2 nVel = nobj.velocity;\n\n                vec2 toBoid = cPos - nPos;\n                float distSqr = dot(toBoid, toBoid);\n\n                if (distSqr < float(DESIRED_SEPERATION_SQR))\n                {\n                    toBoid /= distSqr;\n                    seperation += toBoid;\n                    sCount++;\n                }\n\n                if (distSqr < float(NEIGHBOR_DIST_SQR))\n                {\n                    alignment += nVel;\n                    cohesion += nPos;\n                    nCount++;\n                }\n                if(distSqr<4.0 && nobj.state==STATE_HAPPY)// && obj.timer<=0.0)\n                {\n                    //neartree=0.0;\n                    //obj.state = STATE_SIT;\n                }\n            }\n            else\n            if(isTree(nobj))\n            {\n                vec2 tPos = lCoord;\n                vec2 tVel = vec2(0);\n\n                vec2 toTree = cPos - tPos;\n                float distSqr = dot(toTree, toTree);\n\n                if (distSqr < float(DESIRED_SEPERATION_SQR))\n                {\n                    // toBoid /= distSqr;\n                    // seperation += toBoid;\n                    // sCount++;\n                }\n\n                dirtree=normalize(cPos-tPos);\n\n                if(length(toTree)<2.0)// && obj.timer<=0.0)\n                {\n                    //neartree=0.0;\n                    //obj.velocity=toTree*0.1;\n                    //obj.state = STATE_CHATTING;\n                }\n            }\n        }\n    }\n\n    if (nCount > 0)\n    {\n        cohesion /= float(nCount);\n\n        vec2 s = vec2(0);\n        vec2 toTarget = cohesion - cPos;\n        float dist = length(toTarget);\n\n        if (dist > 0.0)\n        {\n            toTarget *= MAX_SPEED / dist;\n\n            s = toTarget - cVel;\n\n            float l = length(s);\n\n            if (l > MAX_FORCE)\n            {\n                s *= MAX_FORCE / l;\n            }\n        }\n\n        cohesion = s;\n\n        alignment = normalize(alignment);\n        alignment *= MAX_SPEED;\n        alignment -= cVel;\n\n        float l = length(alignment);\n\n        if (l > MAX_FORCE)\n        {\n            alignment *= MAX_FORCE / l;\n        }\n    }\n\n    if (sCount > 0)\n    {\n        seperation = normalize(seperation);\n        seperation *= MAX_SPEED;\n        seperation -= cVel;\n\n        float l = length(seperation);\n\n        if (l > MAX_FORCE)\n        {\n            seperation *= MAX_FORCE / l;\n        }\n    }\n\n    vec2 acc = alignment + seperation * MAX_ACC + cohesion;\n\n    cVel += acc;\n\n    float l = length(cVel);\n    if (l > MAX_SPEED)\n    {\n        cVel *= MAX_SPEED/l;\n    }\n    cVel*=neartree;\n    cPos += cVel;\n    obj.position=cPos-gCoord;\n    obj.velocity=cVel;\n\n    obj.timer=obj.timer-1.0/FPS;\n\n    if(obj.timer>0.0)\n        obj.velocity+=dirtree*0.001;\n\n    if(obj.timer<-10.0)\n        obj.timer=10.0;\n}\n\n\n// Main\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define OUT_OF_DATABLOCKS if((c_coord.x > DATABLOCK_SIZE*2.0 || c_coord.y > DATABLOCK_SIZE) && !((c_coord.x <= DATABLOCK_SIZE/GRID_SIZE && c_coord.y <= DATABLOCK_SIZE + DATABLOCK_SIZE/GRID_SIZE)) && !(c_coord.y > DATABLOCK_SIZE && c_coord.y <= DATABLOCK_SIZE + 1.0 && c_coord.x > DATABLOCK_SIZE/GRID_SIZE && c_coord.x <= DATABLOCK_SIZE/GRID_SIZE + 2.0))\n#define DATABLOCKS else\n#define DATABLOCK0 if (c_coord.y > DATABLOCK_SIZE && c_coord.y <= DATABLOCK_SIZE + DATABLOCK_SIZE/GRID_SIZE && c_coord.x <= DATABLOCK_SIZE/GRID_SIZE)\n#define DATABLOCK1 else if (c_coord.y > DATABLOCK_SIZE && c_coord.y <= DATABLOCK_SIZE + 1.0 && c_coord.x > DATABLOCK_SIZE/GRID_SIZE && c_coord.x <= DATABLOCK_SIZE/GRID_SIZE + 2.0)\n#define DATABLOCK2_3 else\n#define OBJ_INIT if (iFrame <= 3)\n#define OBJ_UPDATE else\n#define DATA_IS_TREE vec2 t_coord=mod(c_coord,TREE_MARGIN)-TREE_MARGIN*0.5;if (t_coord.x == 0.5&&t_coord.y == 0.5)\n#define ELSE else\n//#define DEBUG\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    commonalizeUniforms(iTime, iTimeDelta, iFrame, iResolution, iDate);\n\n#ifdef SPLIT_RENDER\n    bool isFilled=mod(float(iFrame), SPLIT_NUM)==0.0;//SPLIT_NUM-1.0;\n    if(!isFilled)\n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor=texture(iChannel0,uv);\n        return;\n    }\n#endif\n\n    vec2 c_coord=fragCoord;\n\n    OUT_OF_DATABLOCKS\n    {\n        #ifdef DEBUG\n            float scl = 1.0/DATABLOCK_SIZE;\n            vec2 uv = fragCoord.xy/iResolution.xy;\n            // uv.y*=iResolution.y/iResolution.x;\n            vec2 uuv = mod(uv, scl)-scl*0.5;\n            const float HALF_GRID = DATABLOCK_SIZE*0.5;\n            ObjData obj=fetchObjData(uv*DATABLOCK_SIZE, iChannel0);\n            vec3 c = vec3(1.0);\n\n            if(isMan(obj))\n            {\n                c*=vec3((length(uuv-obj.position*scl)));\n            }\n\n            if(isTree(obj))\n            {\n                c*=vec3((length(uuv-obj.position*scl)),0.0,0.0);\n            }\n\n            for(float i=0.0; i<8.0; i+=1.0)\n            {\n                vec2 offset = bx_cossin(i);\n                vec2 coord = uv+offset*scl;\n                ObjData nobj=fetchObjData(coord*DATABLOCK_SIZE, iChannel0);\n                if(isMan(nobj))\n                {\n                    vec2 uuvv = uuv;\n                    uuvv-=offset*scl;\n                    uuvv-=nobj.position*scl;\n                    c=min(c,vec3((length(uuvv))));\n                }\n            }\n            float s=1.0/DATABLOCK_SIZE*40.0;\n            c=smoothstep(0.01*s,0.0125*s,saturate(c));\n            c*=0.5+step(0.00125, min(uuv.x, uuv.y)+0.5*scl);\n\n            fragColor = vec4(c, 1.0);\n\n            if(mod(floor(cTime),2.0)==0.0)\n            {\n                ObjData o=fetchObjData(uv*DATABLOCK_SIZE, iChannel0);\n                bool emp=(o.position==vec2(EMPTY) || o.velocity==vec2(EMPTY) || o.ids==vec2(EMPTY) || o.state==EMPTY || o.timer==EMPTY);\n                if(emp)\n                {\n                    fragColor=vec4(1);\n                }\n                else\n                {\n                    fragColor=vec4(0,1,0,1);\n                }\n                if(isTree(o))\n                {\n                    fragColor=vec4(0,0,1,1);\n                }\n\n                if(isMan(o))\n                {\n                    fragColor=vec4(1,0,1,1);\n                    if(o.state==STATE_HAPPY)\n                    {\n                        fragColor=vec4(0);\n                    }\n                }\n            }\n        #else\n            WRITE_DATA(VOID);\n        #endif\n        return;\n    }\n\n    DATABLOCKS\n    {\n        vec2 cameraCoord=vec2(0,0);\n        /*\n        ---------\n        | 0 | 1 |\n        |---|---|\n        | 2 | 3 |\n        ---------\n        */\n\n        // 0 ----------------------------------------------------\n        DATABLOCK0\n        {\n            c_coord.y -= DATABLOCK_SIZE;\n            vec2 iq = floor(c_coord / 1.0);\n            c_coord = iq;\n\n            float rndx = hash12(iq.xy);\n            float rndy = hash12(iq.yx);\n            vec2 treePos = mod(c_coord, 1.0) - 0.5;\n            treePos.x += rndx  * 2.25;\n            treePos.y += rndy  * 2.25;\n            if((treePos.x>0.5 || treePos.x<-0.5 || treePos.y>0.5 || treePos.y<-0.5))\n            {\n                treePos=NO_TREE;\n            }\n            WRITE_DATA(vec4(treePos,0,0));\n\n            return;\n        }\n\n        // 1 ----------------------------------------------------\n        DATABLOCK1\n        {\n            int DATABLOCK = 2;\n            if (c_coord.x > DATABLOCK_SIZE/GRID_SIZE+0.5)\n            {\n                DATABLOCK = 3;\n                c_coord.x -= 1.0;\n            }\n            ObjData camera;\n            setEmpty(camera);\n\n            OBJ_INIT\n            {\n\n                camera.position = vec2(DATABLOCK_SIZE/2.0);\n                camera.velocity = vec2(0.25);//fbm2(c_coord+camera.position);\n                camera.ids = fbm2(c_coord)*4.0;\n                camera.state = STATE_CAMERA;\n                camera.timer = (hash(camera.position) * 0.5 + 0.5) * TIMER_MAX_DUR;\n            }\n            ELSE\n            {\n                camera = fetchCameraData(c_coord, iChannel0);\n                vec2 gPos = floor(camera.position);\n                camera.position-=gPos;\n\n                updateObj(camera, gPos);\n                camera.position+=gPos;\n                //camera.position=vec2(sin(iTime)*20.0,cos(iTime)*20.0);\n            }\n            //\n            //camera.velocity=vec2(sin(iTime*2.0)*20.0,cos(iTime*2.0)*20.0);\n            WRITE_DATA(packObjData(camera, DATABLOCK));\n            return;\n        }\n\n        // 2 or 3 -----------------------------------------------\n        DATABLOCK2_3\n        {\n            int DATABLOCK = 2;\n            if (c_coord.x > DATABLOCK_SIZE)\n            {\n                DATABLOCK = 3;\n                c_coord.x -= DATABLOCK_SIZE;\n            }\n\n            DATA_IS_TREE\n            {\n                WRITE_DATA(TREE);\n                return;\n            }\n            ELSE\n            {\n\n                ObjData c_obj;\n                OBJ_INIT\n                {\n                    c_obj = initObjData(c_coord);\n                }\n\n\n                OBJ_UPDATE\n                {\n\n                    //* Write camera data\n                    ObjData camera=fetchCameraData(vec2(int(DATABLOCK_SIZE/GRID_SIZE), int(DATABLOCK_SIZE+1.0-0.5)),iChannel0);\n                    vec2 gPos = floor(camera.position);\n                    camera.position-=gPos;\n                    updateObj(camera, gPos);\n                    //camera.position+=gPos;\n\n                    if(gPos.x==c_coord.x-0.5 && gPos.y==c_coord.y-0.5)\n                    {\n                        //camera.position+=gPos;\n                        //WRITE_DATA(vec4(sin(iTime*50.0)*0.5+0.5,0,1,1));\n                        WRITE_DATA(packObjData(camera, DATABLOCK));\n                        return;\n                    }\n                    //*/\n                    c_obj = fetchObjData(c_coord, iChannel0);\n                    bool manIs = isMan(c_obj);\n                    bool cameraIs = (c_obj.state==STATE_CAMERA);\n                    if(cameraIs)\n                    {\n                        manIs = false;\n                        setEmpty(c_obj);\n                    }\n\n                    if (manIs && c_obj.state==STATE_WALK)\n                    {// update man position\n                        updateObj(c_obj, c_coord);\n                        if (bx_length(c_obj.position) > 0.5)\n                        {\n                            manIs = false;\n                            setEmpty(c_obj);\n                        }\n                    }\n\n                    if (!manIs)\n                    {// swap with neighber pixels\n\n                        setEmpty(c_obj);\n\n                        for (int i=-1; i<=1; i++)\n                        {\n                            for (int j=-1; j<=1; j++)\n                            {\n                                if(i == 0 && j == 0){continue;}\n\n                                vec2 offset = vec2(i,j);\n                                vec2 n_coord = loopCoord(c_coord + offset);\n                                ObjData n_obj = fetchObjData(n_coord, iChannel0);\n\n                                if (isMan(n_obj))\n                                {\n                                    updateObj(n_obj, n_coord);\n                                    n_obj.position = offset + n_obj.position;\n                                    if (bx_length(n_obj.position) < 0.5)\n                                    {\n                                        c_obj=n_obj;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                WRITE_DATA(packObjData(c_obj, DATABLOCK));\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//   ___    ___    ___\n//  (  _`\\ (  _`\\ (  _`\\\n//  | (_(_)| | ) || (_(_)\n//  `\\__ \\ | | | )|  _)\n//  ( )_) || |_) || |\n//  `\\____)(____/'(_)\n//\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MAT_VOID -1.0\n#define BAND_MUL 0.6\n#define rm(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))    \nfloat tmin = MIN_DIST;\nfloat tmax = MAX_DIST;\nvec3 LIGHT_DIR = vec3(0);\nfloat bTime=0.0;\n\n// Terrain\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat terrainHeight(vec2 coord)\n{\n    float speed = 0.05;\n    float h=15.0;\n    float scl0=(cos(cTime*0.012)*0.5+0.5)*0.1;\n    float scl1=(cos(cTime*0.005)*0.5+0.5)*0.03;\n    scl0=.075;\n    scl1=.0125;\n    return\n    noise(coord * scl0) * sin(cTime * speed) * h +\n    noise(coord * scl1) * cos(cTime * speed * 0.1) * h;\n    \n}\nvec3 calcTerrainNormal( in vec3 p)\n{\n    float eps = MIN_DIST*2.0;\n    #define f terrainHeight\n    return normalize(vec3(f(vec2(p.x-eps,p.z)) - f(vec2(p.x+eps,p.z)),\n                    2.0*eps,\n                    f(vec2(p.x,p.z-eps)) - f(vec2(p.x,p.z+eps))));\n}\n\n// Tree\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MAT_GREEN 0.8\n#define MAT_TRUNK 0.8\nvec2 sdTree( vec3 p, float idx, float idz, vec3 gp)\n{\n    float scl=saturate(hash11((idx+idz)*123.0)*hash11(idz*idz*123.0)*1.0+0.05);\n\tp.y-=terrainHeight(gp.xz);\n    \n\tfloat band=0.0;\n    float c=1.0;\n    float mat=0.0;\n    \n    p.y -= 0.125*scl;\n    float h=30.0*scl;\n\tvec3 q=p;\n    band=abs(mod(q.y*13.0,c)-c*0.5);\n    band=smoothstep(0.2,0.201,band);\n    mat=band*(BAND_MUL-0.2)+MAT_GREEN-BAND_MUL;\n    vec2 res=vec2(sdCappedCylinder(p+vec3(0,h*0.5,0), vec2(0.75*scl, h)), mat);\n\n    float r=7.8;\n    p.y-=+h*0.5-r*scl;\n    vec2 gres=vec2(tmax,MAT_VOID);\n    \n    float bx=abs(mod(p.y*4.0+sin(p.x*16.0)*0.125,c)-c*0.5);\n    float bz=abs(mod(p.y*4.0+sin(p.z*16.0)*0.125,c)-c*0.5);\n    band=mix(bx,bz,abs(sin(p.x)));\n    band=smoothstep(0.25,0.255,band);\n    mat=band*BAND_MUL+MAT_GREEN-BAND_MUL;\n    gres = opSU(gres, vec2(sdEllipsoid(p+vec3(0,-r*0.5,0)*scl, vec3(r*scl,r*0.7*scl,r*scl)), mat ),0.25 );\n\n    res=opU(res, gres);\n    return res;\n}\n\n// Man\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nObjData a_obj;\n#define MAT_MAN 0.8\n#define MAT_MAN_BK 0.1\nvec2 sdMan(vec3 p)\n{\n    /*\n    vec3 BB = vec3(0.45,2.5,0.65);\n\tfloat bd = udBox(p-vec3(0,1.25,0), BB);\n\tif (bd > 0.9)\n\t{\n\t\treturn vec2(bd, MAT_VOID);\n\t}\n\t//*/\n    \n    float d = tmax;\n    vec2 res = vec2(tmax, MAT_VOID);\n#if 0\n    float h=1.8;\n    d = opSU(sdEllipsoid((p+vec3(0,-h*0.5,0)), vec3(h*0.25, h, h*0.25)), d, 0.133);\n    res = opU(vec2(d,MAT_MAN), res);\n#else\n    vec3 cp_head,cp_chest,cp_torso,cp_butt,cp_shoulderL,cp_shoulderR,cp_elbowL,cp_elbowR,cp_groinL,cp_groinR,cp_kneeL,cp_kneeR,cp_ankleL,cp_ankleR,cp_toeL,cp_toeR;\n\n    #define m(i) (float(i)/800.0)\n    \n    float idx=hash11(a_obj.ids.x)*1.23;\n    float idy=hash11(a_obj.ids.y)*4.56;\n    float T=mod(bTime+idx+idy,PI)*10.0;\n\tT+=sineInOut(T/HALF_PI)*0.25;\n\n    cp_torso = p+vec3( 0.00000,-1.34620, 0.02069);\n    cp_chest=cp_torso+vec3(0,cos((T+HALF_PI)*2.0)*0.05,0);\n    cp_chest.xz*=rm(-cos(T)*0.2);\n    \n    cp_butt=cp_torso+vec3(0,cos((T-HALF_PI)*2.0)*0.05,0);\n    cp_butt.xz*=rm(cos(T-PI)*0.15);\n    cp_butt.xy*=rm(cos(T)*0.15);\n    \n    cp_head = cp_chest+vec3( 0.00000,-1.16336, 0.00000);\n\tcp_head.yz*=rm(sin(T)*(0.35+idx*0.025));\n    \n    cp_shoulderL = cp_chest+vec3(-0.30000,-0.94579, -0.00000);\n    cp_shoulderL.yz*=rm(sin(T)*(0.25+idy*0.125));\n    cp_shoulderL.xy*=rm(-0.15);\n    \n    cp_elbowL = cp_shoulderL-vec3(-0.52479, 0.00047,-0.00290).zxy;\n    cp_elbowL.yz*=rm(cos(T)*0.5-0.5);\n\n    cp_groinL = cp_torso+vec3(-0.20026,-0.03269, 0.10731);\n    cp_groinL.yz*=rm(sin(T-PI)*(0.25+idx*0.125));\n    cp_kneeL  = cp_groinL+vec3( 0.00000, 0.62153, 0.00000);\n    cp_kneeL.yz*=rm(sin(T-PI)*0.3+0.35);\n    cp_ankleL = cp_kneeL+vec3( 0.00000, 0.68572,-0.00366);\n    cp_ankleL.yz*=rm(cos(T)*0.2);\n    cp_toeL   = cp_ankleL+vec3( 0.00003, 0.05016, 0.09153);\n    cp_toeL.yz*=rm(cos(T-PI)*0.4-0.2);\n\n    cp_shoulderR = cp_chest+vec3( 0.30000,-0.94579, 0.00000);\n    cp_shoulderR.yz*=rm(sin(T-PI)*(0.25+idy*0.125));\n    cp_shoulderR.xy*=rm(0.15);\n    \n    cp_elbowR = cp_shoulderR+vec3( 0.52479, 0.00047,-0.00290).zxy;\n    cp_elbowR.yz*=rm(cos(T-PI)*0.5-0.5);\n\n    cp_groinR = cp_torso+vec3( 0.20026,-0.03269, 0.10731);\n    cp_groinR.yz*=rm(sin(T)*(0.25+idx*0.125));\n    cp_kneeR  = cp_groinR+vec3( 0.00000, 0.62153, 0.00000);\n    cp_kneeR.yz*=rm(sin(T)*0.3+0.35);\n    cp_ankleR = cp_kneeR+vec3( 0.00000, 0.68572,-0.00366);\n    cp_ankleR.yz*=rm(cos(T-PI)*0.2);\n    cp_toeR   = cp_ankleR+vec3( 0.00003, 0.05015, 0.09158);\n    cp_toeR.yz*=rm(cos(T)*0.4-0.2);\n    \n    float c=1.0;\n    float band=0.0;\n    band=smoothstep(0.25,0.27,abs(mod((cp_chest.y-0.085)*8.0,c)-c*0.5));\n    float border=band*BAND_MUL+MAT_MAN-BAND_MUL;\n    \n    vec3 tp=vec3(0);\n    tp=cp_torso+vec3(-0.00000, -0.42881, 0.02082);\n    tp.yz*=rm(-0.03862);\n    d = opU(sdEllipsoid(tp, vec3(0.30724, 0.59165, 0.20865)), d);\n    tp=cp_chest+vec3(-0.00000, -0.19441, -0.00000);\n    tp.yz*=rm(-0.07554);\n    d = opSS(sdPlane(tp), d, 0.03066);\n    tp=cp_chest+vec3(-0.00000, -0.81557, 0.02124);\n    tp.yz*=rm(-0.12160);\n    d = opSU(sdEllipsoid(tp, vec3(0.35721, 0.31644, 0.19771)), d, 0.05788);\n    tp=cp_chest+vec3(-0.00000, 0.0825, -0.1537);\n    tp.yz*=rm(1.47);\n    d = opSS(sdPlane(tp), d, 0.18);\n    tp=cp_chest+vec3(-0.00000, -1.11196, -0.00166);\n    tp.yz*=rm(0.13239);\n    d = opSU(sdTorus(tp, vec2(0.07368, 0.01627)), d, 0.01984);\n    tp=cp_chest+vec3(-0.02067, -1.07469, -0.00662);\n    tp.yz*=rm(0.15081);\n    tp.xy*=rm(-0.49783);\n    d = opSU(sdTorus(tp, vec2(0.07052, 0.01557)), d, 0.01984);\n    tp=cp_chest+vec3(0.00003, -1.15282, 0.00378);\n    tp.yz*=rm(0.09133);\n    d = opSU(sdTorus(tp, vec2(0.06372, 0.01216)), d, 0.01232);\n    res = opSU(vec2(d,border), res, 0.01);\n    \n    d = tmax;\n    tp=cp_toeL+vec3(0.00038, -0.01739, 0.06235);\n    tp.yz*=rm(0.43263);\n    tp.xy*=rm(-0.14210);\n    d = opSU(sdEllipsoid(tp, vec3(0.09964, 0.05089, 0.11483)), d, 0.14882);\n    tp=cp_ankleL+vec3(-0.00001, -0.04710, 0.01851);\n    tp.yz*=rm(-0.66345);\n    tp.xy*=rm(0.12901);\n    d = opSU(sdEllipsoid(tp, vec3(0.05411, 0.06251, 0.07096)), d, 0.14546);\n    res = opSU(vec2(d,MAT_MAN), res, 0.15026);\n    d = tmax;\n    tp=cp_toeR+vec3(0.00195, -0.01777, 0.06192);\n    tp.yz*=rm(0.42622);\n    d = opSU(sdEllipsoid(tp, vec3(0.09964, 0.05089, 0.11483)), d, 0.07202);\n    tp=cp_ankleR+vec3(0.00000, -0.04724, 0.01822);\n    tp.yz*=rm(-0.66345);\n    d = opSU(sdEllipsoid(tp, vec3(0.05411, 0.06251, 0.07096)), d, 0.15026);\n    res = opSU(vec2(d,MAT_MAN), res, 0.01832);\n    d = tmax;\n\n    d = opSU(sdEllipsoid((cp_shoulderL+vec3(-0.00000, 0.28279, -0.00000)), vec3(0.09412, 0.30027, 0.10527)), d, 0.10344);\n    d = opSU(sdEllipsoid((cp_shoulderR+vec3(-0.00000, 0.28279, -0.00000)), vec3(0.09412, 0.30027, 0.10527)), d, 0.09864);\n    \n    res = opSU(vec2(d,border), res, 0.0432);\n    d = tmax;\n    d = opSU(sdEllipsoid((cp_elbowR+vec3(-0.00000, 0.22539, -0.00000)), vec3(0.08887, 0.26141, 0.08887)), d, 0.0832);\n    d = opSU(sdEllipsoid((cp_elbowL+vec3(-0.00000, 0.22539, -0.00000)), vec3(0.08887, 0.26141, 0.08887)), d, 0.01832);\n    d = opSU(sdTorus((cp_elbowL+vec3(-0.00000, 0.49466, -0.00000)), vec2(0.04836, 0.00471)), d, 0.01936);\n    d = opSU(sdTorus((cp_elbowR+vec3(-0.00000, 0.49466, -0.00000)), vec2(0.04836, 0.00591)), d, 0.02368);\n    \n    res = opSU(vec2(d,border), res, 0.02832);\n    d = tmax;\n\n    d = opSU(sdEllipsoid((cp_kneeL+vec3(-0.00000, 0.23600, -0.00000)), vec3(0.11554, 0.29908, 0.11554)), d, 0.00658);\n    d = opSU(sdEllipsoid((cp_kneeR+vec3(-0.00000, 0.23600, -0.00000)), vec3(0.11554, 0.29908, 0.11554)), d, 0.00658);\n    d = opSU(sdCappedCylinder((cp_kneeL+vec3(-0.00000, 0.39710, -0.00000)), vec2(0.05821, 0.13053)), d, 0.00962);\n    d = opU(sdCappedCylinder((cp_kneeR+vec3(-0.00000, 0.39710, -0.00000)), vec2(0.05821, 0.13053)), d);\n    d = opSU(sdEllipsoid((cp_groinL+vec3(-0.00000, 0.25660, -0.00000)), vec3(0.14814, 0.40112, 0.15947)), d, 0.07344);\n    d = opSU(sdEllipsoid((cp_groinR+vec3(-0.00000, 0.25660, -0.00000)), vec3(0.14814, 0.40112, 0.15947)), d, 0.07344);\n    tp=cp_butt+vec3(0.00023, -0.05979, 0.01034);\n    tp.xy*=rm(1.57080);\n    d = opSU(sdCapsule(tp, 0.10256, 0.19623), d, 0.10480);\n    tp=cp_torso+vec3(-0.00000, -0.10164, 0.06840);\n    tp.yz*=rm(-0.02004);\n    d = opSU(sdEllipsoid(tp, vec3(0.12460, 0.16398, 0.13065)), d, 0.19394);\n    res = opSU(vec2(d,MAT_MAN), res, 0.02832);\n    d = tmax;\n\n    d = opSU(sdCappedCylinder((cp_elbowL+vec3(-0.00000, 0.43264, -0.00000)), vec2(0.04109, 0.06522)), d, 0.03168);\n    d = opSU(sdCappedCylinder((cp_elbowR+vec3(-0.00000, 0.43264, -0.00000)), vec2(0.04109, 0.06522)), d, 0.03200);\n    res = opSU(vec2(d,MAT_MAN), res, 0.014882);\n    d = tmax;\n\n    d = opU(sdSphere(cp_elbowL+vec3(-0.00000, 0.59976, -0.00000), 0.07043), d);\n    d = opU(sdSphere(cp_elbowR+vec3(-0.00000, 0.59976, 0.00000), 0.07043), d);\n    d = opU(sdSphere(cp_head+vec3(-0.00000, -0.12666, -0.00000), 0.07), d);\n    res = opU(vec2(d,MAT_MAN), res);\n    res.x*=0.85;\n    #endif\n    return res;\n}\n\n// The map\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MAT_GROUND 0.8\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(tmax, MAT_VOID);\n    vec3 BB=vec3(0);\n    float bd=0.0;\n\t/*\n    BB = vec3(400.0,70.0,400.0);\n\tbd = udBox(p-vec3(0,33.0,0), BB);\n\tif (bd > 0.9)\n\t{\n\t\treturn vec2(bd, MAT_VOID);\n\t}\n    //*/\n    const float HALF_GRID = DATABLOCK_SIZE*0.5;\n    p.xz+=HALF_GRID;\n    vec3 gp=p;\n    \n    p.y+=terrainHeight(p.xz);\n\n    vec3 q = p;\n    q.xz = mod(q.xz, 1.0)-0.5;\n    vec3 cq = vec3(0);\n    vec3 nq = vec3(0);\n\n    //float f=min(-grd.y,0.0)*180.0;\n    float f=max(0.0,dot(grd, vec3(0,1,0)))*80.0;\n    ObjData objData;\n    BB = vec3(1.0+f*0.0025,10.0+f,1.0+f*0.0025);\n    bd = udBox(q, BB);\n\n    vec3 qp = p;\n    qp.xz=mod(qp.xz, DATABLOCK_SIZE);\n    \n\tres.x = dBox2D(q.xz, 3.0);\n    if(bd < 0.1)\n    {\n        objData = fetchObjData(qp.xz, iChannel0);\n        if(isMan(objData))\n        {\n            cq=q;\n            a_obj=objData;\n            cq.xz-=objData.position;\n            cq.xz=rotate(cq.xz,PI-atan(objData.velocity.x,objData.velocity.y));\n            res = opU(sdMan(cq),res);\n        }\n\n        for(float i=0.0; i<8.0; i+=1.0)\n        {\n            vec2 offset = bx_cossin(i);\n            ObjData nobjData = fetchObjData((qp.xz-offset), iChannel0);\n            if(isMan(nobjData))\n            {\n                a_obj=nobjData;\n                nq = q;\n                nq.xz+=offset;\n                nq.xz-=nobjData.position;\n                nq.xz=rotate(nq.xz,PI-atan(nobjData.velocity.x,nobjData.velocity.y));\n                res = opU(sdMan(nq),res);\n            }\n\n        }\n    }\n\n    // Tree\n    q=p;\n    float iidx = hash11(floor(q.x / TREE_MARGIN)) + 0.01;\n    float iidz = hash11(floor(q.z / TREE_MARGIN)) + 0.01;\n    q.xz=mod(q.xz,TREE_MARGIN)-TREE_MARGIN*0.5;\n    \n    if(hash11(iidz+iidx)>0.5)\n    {\n        res = opU(sdTree(q+vec3(0,-1.5,0), iidx, iidz, gp),res);\n    }\n    \n    // Terrain\n    float c=1.0;\n    //float band=smoothstep(0.25,0.255,abs(mod(p.x+sin(p.z*8.0)*0.125,c)-c*0.5));\n    float band=smoothstep(0.25,0.27,abs(mod(p.x*4.0+sin(p.z*6.0)*0.125,c)-c*0.5));\n    //float band=smoothstep(0.025,0.0265,abs(mod(p.x,c)-c*0.5))*smoothstep(0.025,0.0265,abs(mod(p.z,c)-c*0.5));\n    res = opU(vec2(0.3*sdPlane(p), band*BAND_MUL+MAT_GROUND-BAND_MUL),res);\n\n    res.x+=hash11(p.x+p.y+p.z*res.x)*(36.0/800.0)*0.005;\n    return res;\n}\n\n// Ray marching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec2 march( in vec3 ro, in vec3 rd)\n{\n    gro=ro;\n    grd=rd;\n\n    // Bounding Volume: \"Raymarching - Primitives\" by iq\n    // https://www.shadertoy.com/view/Xds3zN\n    const float mi = -20.0;\n    const float ma = 300.0;\n\n    float tp1 = (mi-ro.y)/rd.y;\n    if( tp1>mi )\n        tmax = min( tmax, tp1 );\n\n    float tp2 = (ma-ro.y)/rd.y;\n    if( tp2>mi )\n    {\n        if( ro.y>ma )\n            tmin = max( tmin, tp2 );\n        else\n            tmax = min( tmax, tp2 );\n    }\n    //tmin=MIN_DIST;\n\t//tmax=MAX_DIST;\n    \n    float t = tmin;\n    float m = -1.0;\n\n    int i=0;\n    for(; i<ITERATION; i++ )\n    {\n        //float precis = MIN_DIST;\n        vec2 res = map( ro+rd*t );\n        if( res.x<MIN_DIST || t>tmax ) break;\n        t += res.x;\n        m = res.y;\n    }\n    m*=(m<0.0)?1.0:smoothstep(0.1,0.5,(1.0-float(i)/float(ITERATION)*(1.0-t/tmax))*1.0);\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n#define ZERO (min(iFrame, 0))\n#if 0\nvec3 calcNormal(vec3 p, float t)\n{\n\tfloat c=map(p).x;\n\tfloat e=MIN_DIST*t*2.0;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).x-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).x-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).x-c));\n}\n#else\nvec3 calcNormal(vec3 pos, float t) {\n    vec3 n = vec3(0.0);\n\tfloat eps=MIN_DIST*t*0.1;\n\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0;\n        n += e * map(pos + eps * e).x;\n    }\n    return normalize(n);\n}\n#endif\n/*\nvec3 calcNormal(vec3 p)\n{\n    const vec2 e = vec2(1.0,-1.0)*MIN_DIST;\n    return normalize( e.xyy*map( p + e.xyy ).x +\n                      e.yyx*map( p + e.yyx ).x +\n                      e.yxy*map( p + e.yxy ).x +\n                      e.xxx*map( p + e.xxx ).x );\n}\n//*/\nfloat calcShadow( in vec3 ro, in vec3 rd)\n{\n    float t=0.25;\n    for(int i=0; i<100; i++)\n    {\n        float precis=MIN_DIST*t;\n        float h=map(ro+rd*t).x;\n        if(h<precis)return 0.0;\n        t+=h;\n        if(t>tmax)return 1.0;\n    }\n    return 1.0;\n}\n\nfloat render( in vec3 ro, in vec3 rd)\n{\n    vec3 p = vec3(0), n = vec3(0);\n    float col = 1.0, mat = 1.0;\n\n    vec2 res = march(ro, rd);\n\n\tconst float baseSky = 0.5;\n\tfloat sun = clamp(pow(max(0.0,dot(LIGHT_DIR, rd)),30.0)*10.5, 0.0,50.0);\n    float sky = baseSky;\n    sky*=clamp(smoothstep(0.2,0.65, rd.y+0.5),0.0,1.0);\n    sky+=sun;\n    \n    if (res.y==-1.0)\n    {\n        return sky;\n    }\n    else\n    {\n        mat = res.y;\n        p = ro + res.x * rd;\n        n = calcNormal(p,res.x);\n        vec3 pOffset = n * MIN_DIST*15.0;\n        float shadow = calcShadow(p+pOffset, LIGHT_DIR);\n        float light1 = pow(clamp(dot(n+pOffset, LIGHT_DIR), 0.0, 1.0), 0.7);\n        float light2 = pow(clamp(dot(n+pOffset, -LIGHT_DIR), 0.0, 1.0), 1.8);\n\n        float shade = 0.0;\n        shade += 1.0 * min(1.0,light1);// *0.975+0.025);\n        shade = shade*(shadow*0.875+0.125);\n        //shade+=0.15;\n        col = mat*shade;\n        //if(res.y < 0.5)\n          //  col *=(0.7+f*0.25)*0.2, pow(distance(ro, p) * 1.0 / MAX_DIST, 0.25);\n        col = mix(col, sky, pow(distance(ro, p) * 1.0 / MAX_DIST, 3.5));\n    }\n    return col;\n}\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd)\n{\n\tvec2 drawResolution=getDrawRes(iResolution.xy);\n    vec2 uv = pix.xy / drawResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= drawResolution.x / drawResolution.y;\n\n    float camDist = (sin(cTime*0.001)*0.5+0.5+0.1)*10.0+30.0;\n    float camT = (cTime)*0.15;\n    resRo = vec3(sin(camT), 0.0, cos(camT)) * camDist;\n    resRo.y=-terrainHeight(resRo.xz)+13.5;\n    vec3 tn=calcTerrainNormal(resRo);\n    //resRo+=tn*10.0+tn*(cos(cTime)*0.5+0.5)*15.0;\n    vec3 look = vec3((cos(cTime*0.1)*0.5+0.5)*25.0, cos(cTime*0.2)*25.0-12.0, (sin(cTime*0.1)*0.5+0.5)*25.0);\n    look=mix(vec3(0,-20,0), look, camEase(smoothstep(0.0, 5.0, cTime)));\n    vec3 up = vec3(sin(cTime*0.001)*0.5, 1.0, cos(cTime*0.001)*0.5);\n    vec3 w = normalize(look - resRo);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u, w));\n    float fov=((cos((camT-35.0)*0.01)*0.5+0.5)*8.0+2.0);\n    fov = mix(20.0,fov,camEase(smoothstep(0.0, 10.0, bTime)));\n    resRd = normalize(p.x*u + p.y*v + fov*w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    commonalizeUniforms(iTime, iTimeDelta, iFrame, iResolution, iDate);\n    vec2 drawResolution=getDrawRes(iResolution.xy);\n    if(!(fragCoord.x<=drawResolution.x&&fragCoord.y<=drawResolution.y))\n    {\n        discard;\n    }\n\n    vec2 uv = fragCoord.xy/drawResolution.xy;\n\n    float timeOffset = mod(float(iFrame), SPLIT_NUM)*WAVEFRONT_UNIT;\n    float line = mod((fragCoord.y+timeOffset)/WAVEFRONT_UNIT, SPLIT_NUM);\n    if(line<SPLIT_NUM-1.0)\n    {\n        fragColor = texture(iChannel1,fragCoord.xy/iResolution.xy);\n        return;\n    }\n    float frame=floor(float(iFrame)/1.0);\n    float F=floor(float(frame)-mod(float(frame),SPLIT_NUM));\n    cTime=bTime=(F/60.0);\n\n    LIGHT_DIR = normalize(vec3(0.5, 0.65, 0.5));\n\n    calcRayForPixel(fragCoord, gro, grd);\n    gro.xy+=(vec2(hash11(F),hash11(F+12.0))-0.5)*0.1;\n\tvec3 col = vec3(render(gro, grd));\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//   ___           _       _\n//  (  _`\\        (_ )  _ ( )_\n//  | (_(_) _ _    | | (_)| ,_)\n//  `\\__ \\ ( '_`\\  | | | || |\n//  ( )_) || (_) ) | | | || |_\n//  `\\____)| ,__/'(___)(_)`\\__)\n//   ___   | |                _\n//  |  _`\\ (_)               ( )\n//  | (_) )   __    ___     _| |   __   _ __\n//  | ,  /  /'__`\\/' _ `\\ /'_` | /'__`\\( '__)\n//  | |\\ \\ (  ___/| ( ) |( (_| |(  ___/| |\n//  (_) (_)`\\____)(_) (_)`\\__,_)`\\____)(_)\n//\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    commonalizeUniforms(iTime, iTimeDelta, iFrame, iResolution, iDate);\n    vec2 drawResolution=getDrawRes(iResolution.xy);\n    if(!(fragCoord.x<=drawResolution.x && fragCoord.y<=drawResolution.y))\n    {\n        discard;\n    }\n\n    bool isFilled=mod(float(iFrame), SPLIT_NUM)==SPLIT_NUM-1.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor=(isFilled)?texture(iChannel0,uv):texture(iChannel1,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//   _   _                             _\n//  ( ) ( )                           (_ )  _\n//  | | | | _ _     ___    ___    _ _  | | (_)  ___     __\n//  | | | |( '_`\\ /',__) /'___) /'_` ) | | | |/' _ `\\ /'_ `\\\n//  | (_) || (_) )\\__, \\( (___ ( (_| | | | | || ( ) |( (_) |\n//  (_____)| ,__/'(____/`\\____)`\\__,_)(___)(_)(_) (_)`\\__  |\n//         | |                                       ( )_) |\n//         (_)                                        \\___/'\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool isFilled=mod(float(iFrame), SPLIT_NUM)==SPLIT_NUM-1.0;\n    if(!isFilled)\n    {\n        fragColor = texture(iChannel1,fragCoord.xy/iResolution.xy);\n        return;\n    }\n    \n    commonalizeUniforms(iTime, iTimeDelta, iFrame, iResolution, iDate);\n    vec2 drawResolution=getDrawRes(iResolution.xy);\n    vec2 uv = fragCoord/iResolution.xy*(drawResolution.x/iResolution.x);\n    vec3 col = vec4(poissonSampling(iChannel0, uv, 1.6),1.0).xyz;\n    \n    //vignet\n    uv = fragCoord/iResolution.xy;\n    col.xyz *= pow(2.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.1);\n    \n    //col=vec3(1.0);\n    float flicker = saturate(clamp((hash11(cTime*300.0))*1000.0, 100.0, 300.0)*0.001);\n    col.xyz *= 1.0-flicker*.1;\n    \n    //brightness & contrast\n    col.xyz = col.xyz * 1.8;\n    col.xyz = col.xyz + -0.15;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}