{
    "Shader": {
        "info": {
            "date": "1680900246",
            "description": "A corridor scene created using infinitely repeating analytic raytraced primitives.\n\nClick and drag to look around\nDon't look behind you",
            "flags": 0,
            "hasliked": 0,
            "id": "csjXDh",
            "likes": 22,
            "name": "Infinite Corridor",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "infinite",
                "corridor",
                "flickering",
                "repetiton"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 366
        },
        "renderpass": [
            {
                "code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2022-12-05 00:34:31\n\n/*\n * A corridor scene created using infinitely repeating\n * analytic raytraced primitives. \n *\n * Click and drag to look around\n * Don't look behind you\n * \n * T'was initially made as a proof of concept for the infinitely repeating primitives,\n * apologies for the messy code v _ v\n * \n * Thanks to sebbi and demofox for the inspiration\n * \n * Infinite quad grid - sebbi\n * https://www.shadertoy.com/view/lly3Rc\n * \n * Infinite Plane Shape Raytracing - demofox \n * https://www.shadertoy.com/view/MlK3zt\n * \n */\n\n#define AA\n\n#define FOG\n#define FOG_STRENGTH 0.225\n\n//#define SHOW_MATERIALS\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 n)\n{\n    float d = dot(rd, n);\n    if (d == 0.0) return MAX_DIST;\n    float t = -dot(ro, n) / d;\n    if (t < 0.0) t = MAX_DIST;\n    return t;\n}\n\nfloat RayCorridor(vec3 ro, vec3 rd, vec2 s, out vec3 normal)\n{\n    vec2 m = 1.0 / rd.xy; // can precompute if traversing a set of aligned boxes\n    vec2 n = m * ro.xy;   // can precompute if traversing a set of aligned boxes\n    vec2 k = abs(m) * s;\n    vec2 t2 = -n + k;\n    float t = min(t2.x, t2.y);\n    normal.x = float(t2.x <= t);\n    normal.y = float(t2.y < t2.x);\n    normal.xy *= -sign(rd.xy);\n    \n    return t;\n}\n\n// Repeating Planes with Rectangular Hole aligned at Z\nfloat RayPlaneRectHoleRepeat(vec3 ro, vec3 rd, vec3 s)\n{\n    if (rd.z == 0.0)\n        return MAX_DIST;\n    ro.z = fract(ro.z / s.z) * s.z;\n    float o = fract(ro.z / s.z) * s.z;\n    if (rd.z < 0.0)\n    {\n        ro.z = s.z - ro.z;\n        rd.z = -rd.z;\n    }\n    float t = -(ro.z - s.z) / rd.z;\n    vec3 p = ro + rd * t;\n    vec2 st = s.z * -rd.xy / rd.z;\n    \n    if (abs(p.x) < s.x && abs(p.y) < s.y)\n    {\n        vec2 sp = (s.xy + p.xy * sign(st)) / abs(st);\n        t += s.z * ceil(min(sp.x, sp.y)) / rd.z;\n    }\n    \n    return t;\n}\n\nfloat RayPlaneSlabRepeatX(vec3 ro, vec3 rd, vec2 s)\n{\n    if (rd.z == 0.0)\n        return MAX_DIST;\n    ro.z = fract(ro.z / s.y) * s.y;\n    float o = fract(ro.z / s.y) * s.y;\n    if (rd.z < 0.0)\n    {\n        ro.z = s.y - ro.z;\n        rd.z = -rd.z;\n    }\n    float t = -(ro.z - s.y) / rd.z;\n    vec3 p = ro + rd * t;\n    float st = s.y * -rd.x / rd.z;\n    \n    if (abs(p.x) < s.x)\n    {\n        float sp = (s.x + p.x * sign(st)) / abs(st);\n        t += s.y * ceil(sp) / rd.z;\n    }\n    \n    return t;\n}\n\nfloat RayPlaneSlabRepeatY(vec3 ro, vec3 rd, vec2 s)\n{\n    if (rd.z == 0.0)\n        return MAX_DIST;\n    ro.z = fract(ro.z / s.y) * s.y;\n    float o = fract(ro.z / s.y) * s.y;\n    if (rd.z < 0.0)\n    {\n        ro.z = s.y - ro.z;\n        rd.z = -rd.z;\n    }\n    float t = -(ro.z - s.y) / rd.z;\n    vec3 p = ro + rd * t;\n    float st = s.y * -rd.y / rd.z;\n    \n    if (abs(p.y) < s.y)\n    {\n        float sp = (s.x + p.y * sign(st)) / abs(st);\n        t += s.y * ceil(sp) / rd.z;\n    }\n    \n    return t;\n}\n\nvec3 getTexture(vec2 uv, int mat)\n{\n    if (mat == 0)\n        return sRGBToLinear(texture(iChannel0, uv).rgb);\n    else if (mat == 1)\n        return sRGBToLinear(texture(iChannel1, uv).rgb);\n    else if (mat == 2)\n        return sRGBToLinear(texture(iChannel2, uv).rgb);\n    else if (mat == 4)\n        return sRGBToLinear(texture(iChannel3, uv).rgb);\n        \n    return sRGBToLinear(texture(iChannel0, uv).rgb);\n}\n\nvec3 getTexture(vec2 uv, vec2 ddx, vec2 ddy, int mat)\n{\n    if (mat == 0)\n        return sRGBToLinear(textureGrad(iChannel0, uv, ddx, ddy).rgb);\n    else if (mat == 1)\n        return sRGBToLinear(textureGrad(iChannel1, uv, ddx, ddy).rgb);\n    else if (mat == 2)\n        return sRGBToLinear(textureGrad(iChannel2, uv, ddx, ddy).rgb);\n    else if (mat == 4)\n        return sRGBToLinear(textureGrad(iChannel3, uv, ddx, ddy).rgb);\n        \n    return sRGBToLinear(textureGrad(iChannel0, uv, ddx, ddy).rgb);\n}\n\nvec3 triplanar(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 cw = pow(abs(n) / dot(abs(n), vec3(1)), vec3(1.0));\n    \n    vec3 cx = texture(iChannel0, p.yz).rgb;\n    vec3 cy = texture(iChannel0, -p.xz).rgb;\n    vec3 cz = texture(iChannel0, p.xy).rgb;\n    \n    vec3 alb = cx * cw.x + cy * cw.y + cz * cw.z;\n    \n    return sRGBToLinear(alb);\n}\n\nfloat getFlicker(int i)\n{\n    return float((28273198 >> (i%25)) & 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0);\n    \n#ifdef AA\n    for (int x = 0; x < 4; x++)\n    {\n    \n    const vec2[] offsets = vec2[](\n        vec2(1.0/8.0, 3.0/8.0),\n        vec2(3.0/8.0, -1.0/8.0),\n        vec2(-1.0/8.0, -3.0/8.0),\n        vec2(-3.0/8.0, 1.0/8.0)\n    );\n    vec2 o = offsets[x];\n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    vec2 pvdx = (2. * (fragCoord + o + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 pvdy = (2. * (fragCoord + o + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n#else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 pvdx = (2. * (fragCoord + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 pvdy = (2. * (fragCoord + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n#endif\n\n    float bd0 = 0.08;\n    pv *= 1.0 + dot(pv, pv) * bd0;\n    pvdx *= 1.0 + dot(pvdx, pvdx) * bd0;\n    pvdy *= 1.0 + dot(pvdy, pvdy) * bd0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, -0.3, 0);\n    \n    ro.x += sin(iTime * 0.5) * 0.02;\n    ro.y += sin(iTime * 6.0) * 0.05;\n    ro.z += (iTime + cos(iTime * 0.8) * 0.12 + sin(iTime * PI) * 0.03) * 2.25;\n\n    vec3 lo = vec3(0, 0, 1.5);\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? 0.0 : -m.x * TAU;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? 0.0 : -(m.y * PI + PI * .5);\n    \n    //ax = PI / 2.0;\n    //ro -= lo;\n    lo.yz *= rot2D(ay);\n    lo.xz *= rot2D(ax);\n    lo += ro;\n    \n    mat3 cmat = getCameraMatrix(ro, lo, sin(iTime * 3.0) * 0.025);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    vec3 rddx = normalize(cmat * vec3(pvdx, 2));\n    vec3 rddy = normalize(cmat * vec3(pvdy, 2));\n    vec3 srd = sign(rd);\n    \n    int mat = 1;\n\n    float occRad = 0.3;\n    float occ = 1.0;\n    \n    const float corridorWidth = 1.3;\n    const float corridorHeight = 1.5;\n    const vec2 corridorSize = vec2(1.3, 1.5);\n    const vec2 columnSize = vec2(0.4, 0.3);\n    const float columnSpacing = 3.0;\n    const float columnDepth = 0.5;\n\n    // Column sides Z\n    float t = RayPlaneRectHoleRepeat(ro + vec3(0, 0, columnDepth * step(0.0, rd.z)), rd, vec3(corridorSize - columnSize, columnSpacing));\n    \n    vec3 tp = ro + rd * t;\n    \n    vec3 n = vec3(0, 0, -sign(rd.z));\n    occ = min(corridorSize.x - abs(tp.x), min(corridorSize.y - abs(tp.y), corridorSize.y - abs(tp.y -  columnSize.y ))) / 0.5;\n    \n    // Column side X\n    vec3 cn;\n    float c = RayCorridor(ro, rd, corridorSize - columnSize, cn);\n    \n    tp = ro + rd * c;\n    \n    if (c < t && fract(tp.z / columnSpacing) * columnSpacing > columnSpacing - columnDepth)\n    {\n        t = c;\n        n = cn;\n        occ = max(corridorSize.x - columnSize.x - abs(tp.x), corridorSize.y - columnSize.y - abs(tp.y)) / occRad;\n        mat = 1;\n    }\n    \n    // Walls/floor/ceiling\n    float c2 = RayCorridor(ro, rd, corridorSize, cn);\n    if (c2 < t)\n    {\n        t = c2;\n        n = cn;\n        tp = ro + rd * c2;\n        occ = max(corridorSize.x - abs(tp.x), corridorSize.y - columnSize.y - abs(tp.y));\n        occ = min(occ, abs(0.8 - tp.y));\n        float g = fract(tp.z / columnSpacing) * columnSpacing;\n        occ = min(occ, min(g, columnSpacing - columnDepth - g));\n        occ *= 2.;\n        \n        mat = 0;\n        if (cn.y > 0.0)\n            mat = 2;\n        else if (cn.y < 0.0)\n            mat = 1;\n    }\n    \n    // Slanted ceiling\n    vec3 s1n = vec3(-1, -1, 0);\n    if (rd.x < 0.0)\n        s1n.x = -s1n.x;\n    s1n = normalize(s1n);\n    vec3 s2n = vec3(0, -1, 0);\n    float s1 = RayPlane(ro - vec3(srd.x * 0.2, corridorHeight, 0), rd, s1n);\n    float s2 = RayPlane(ro - vec3(0, 0.8, 0), rd, s2n);\n    if (s2 > s1)\n    {\n        s1 = s2;\n        s1n = s2n;\n    }\n    \n    tp = ro + rd * s1;\n    if (fract(tp.z / columnSpacing) * columnSpacing > columnSpacing - columnDepth)\n    {\n        tp.z = fract(tp.z / columnSpacing) * columnSpacing - columnSpacing + columnDepth * step(rd.z, 0.0);\n        s1 += RayPlane(tp, rd, vec3(0, 0, -srd.z));\n        s1n = vec3(0, 0, -srd.z);\n    }\n    \n    if (s1 < t)\n    {\n        t = s1;\n        n = s1n;\n        occ = corridorSize.x - abs(tp.x);\n        mat = 0;\n    }\n    \n    vec3 fp = vec3(0, -(corridorHeight - columnSize.y) + EPS, 0);\n    float fl = RayPlane(ro - fp, rd, vec3(0, 1, 0));\n    tp = ro + rd * fl;\n    if (fl < t)\n    {\n        t = fl;\n        n = vec3(0, 1, 0);\n        float occ0 = fract(tp.z / columnSpacing) * columnSpacing;\n        float occ1 = columnSpacing - columnDepth - occ0;\n        occ = max(min(occ0, occ1), corridorSize.x - columnSize.x - abs(tp.x)) * 2.;\n        occ = min(occ, (corridorSize.x - abs(tp.x)) * 2.0);\n        mat = 2;\n    }\n    \n    \n    const float bof = 0.1;\n    const float bsp = 3.0;\n    const float bbf = 0.1;\n    float bp1 = RayPlaneSlabRepeatY(ro - fp + vec3(0, 0, mix(bbf, columnDepth - bbf, step(0.0, rd.z))), rd, vec2(corridorHeight + bof, columnSpacing * bsp));\n    \n    tp = ro + rd * bp1;\n    if (bp1 < t)\n    {\n        t = bp1;\n        n = vec3(0, 0, -srd.z);\n        mat = 0;\n        occ = min(corridorSize.x - columnSize.x - abs(tp.x), corridorSize.y - columnSize.y - abs(tp.y));\n        occ *= 2.0;\n    }\n    \n    float bp = RayPlane(ro - fp - vec3(0, corridorHeight + bof, 0), rd, vec3(0, -1, 0));\n    tp = ro + rd * bp;\n    if (bp < t && fract((tp.z + bbf) / (columnSpacing*bsp)) * columnSpacing*bsp > columnSpacing*bsp - columnDepth + bbf*2.0)\n    {\n        t = bp;\n        n = vec3(0, -1, 0);\n        occ = (corridorSize.x - columnSize.x - abs(tp.x)) * 2.0;\n        mat = 0;\n    }\n    \n    float np = RayPlane(ro * vec3(1, 1, 0) + vec3(0, 0, 5.0 + sin(iTime * 0.3) * 3.5), rd, vec3(0, 0, 1));\n    \n    tp = ro + rd * np;\n    tp.x *= hash22(vec2(floor(iTime*12.0), 3)).x < 0.5 ? -1.0 : 1.0;\n    vec4 tex = texture(iChannel3, (tp.xy + vec2(0.5 + 1.0*mod(floor(iTime * 12.0), 6.0), 0.9)) * vec2(240.0/256.0/6.0, 1));\n    if (np < t && tex.a > 0.5 && tp.x < 240.0/256.0/2.0 && tp.x > -240.0/256.0/2.)\n    {\n        t = np;\n        n = vec3(0, 0, 1);\n        mat = 4;\n        occ = 1.0;\n    }\n    \n    \n    float r = 0.15;\n    float s = columnSpacing;\n    float lightHeight = corridorSize.y + 0.02;\n    \n    vec3 cp = ro - vec3(0, lightHeight, columnSpacing * 0.5);\n    cp.z = fract(cp.z / s) * s;\n    vec2 cyl = RayCylinder(cp, rd, r);\n    \n    float ct = max(cyl.x, 0.0);\n    \n    tp = cp + rd * ct;\n    \n    float ip = floor(tp.z / s) * s;\n    \n    vec3 of = vec3(0, 0, ip);\n    vec3 of2 = vec3(0, 0, ip + s);\n    vec2 sph0 = RaySphere(cp - of, rd, r);\n    vec2 sph1 = RaySphere(cp - of2, rd, r);\n    \n    float sph = sph0.x;\n    \n    if (sph1.x < sph)\n    {\n        sph = sph1.x;\n        of = of2;\n    }\n    \n    ct = sph > ct - EPS ? sph : MAX_DIST;\n    \n    tp = cp + rd * ct;\n    \n    if (ct < t)\n    {\n        t = ct;\n        n = normalize(tp - of);\n        occ = 1.0;\n        mat = 3;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 pdx = ro - rddx * dot(ro - p, n) / dot(rddx, n);\n    vec3 pdy = ro - rddy * dot(ro - p, n) / dot(rddy, n);\n    \n    float i = (floor((p.z) / s - EPS)) * s;\n    float f = p.z - i;\n    \n    vec3 tn, bn;\n    basis(n, tn, bn);\n    \n    vec3 col = vec3(p);\n    \n    float sc = mat == 0 ? 0.8 : mat == 1 ? 0.4 : 0.1;\n    vec2 st = vec2(dot(p, tn), dot(p, bn));\n    vec2 ddx = vec2(dot(pdx, tn), dot(pdx, bn)) - st;\n    vec2 ddy = vec2(dot(pdy, tn), dot(pdy, bn)) - st;\n    \n    if (mat == 1 || mat == 0)\n    {\n        st += hash22(vec2(i, 5)) * 3.0;\n    }\n    if (mat == 0 && rd.x < 0.0 && abs(n.z) < 0.5)\n    {\n        st += hash22(vec2(3.5, 2.5));\n    }\n    st *= sc;\n    ddx *= sc;\n    ddy *= sc;\n    \n    float eps = EPS * sc;\n    vec3 alb = getTexture(st, ddx, ddy, mat);\n    vec3 albDx = getTexture(st + vec2(eps, 0), ddx, ddy, mat);\n    vec3 albDy = getTexture(st + vec2(0, eps), ddx, ddy, mat);\n    \n    float h = luminance(alb);\n    float hx = luminance(albDx);\n    float hy = luminance(albDy);\n    \n    if (mat != 3)\n        n = normalize(n * 50.0 + (tn * (h - hx) + bn * (h - hy)) / eps);\n    \n    float dif = 1.0;\n    float spec = 1.0;\n    if (mat == 0)\n    {\n        alb = alb*alb*(3.0 - 2.0 * alb);\n        alb = RGBtoHSV(alb);\n\n        alb.x += 0.55 + (hash21(floor(i / 16.0)).x - 0.5) * 0.05;\n        alb.y *= 0.4;\n        alb.z *= 0.8;\n\n        alb = HSVtoRGB(saturate(alb));\n        spec = 0.7;\n    } else if (mat == 1)\n    {\n        alb = alb*alb*(3.0 - 2.0 * alb);\n        //alb *= 0.8;\n        spec = 1.5;\n    } else if (mat == 2) {\n        alb = RGBtoHSV(alb);\n        \n        alb.y *= 0.8;\n        alb.z *= 0.8;\n\n        alb = HSVtoRGB(saturate(alb));\n        \n        spec = 0.2;\n    } else if (mat == 3) {\n        alb = vec3(5.0);\n    } else if (mat == 4) {\n        alb = sRGBToLinear(tex.rgb);\n    }\n    \n    vec3 ldir = rd;\n    float dif0 = max(dot(n, -ldir), 0.0);\n    float spec0 = pow(max(dot(reflect(-ldir, n), rd), 0.0), 5.0);\n    vec3 spotDir = normalize(cmat[2] + vec3(0, 0.01, 0) * sin(iTime * 7.0));\n    float atten0 = 0.4 * saturate((1.0 - (1.0 - dot(spotDir, rd)) / (1.0 - 0.85)));\n    atten0 *= 0.7 + 0.3 * getFlicker(int(iTime * 16.0));\n    atten0 += 0.005;\n    \n    dif0 *= atten0;\n    spec0 *= atten0;\n    \n    vec3 lpos = vec3(0, lightHeight, columnSpacing * 0.5);\n    lpos.z += (floor((p.z) / s - EPS)) * s;\n    \n    ldir = p - lpos;\n    float ldist = length(ldir);\n    ldir /= ldist;\n    \n    float dif1 = max(dot(n, -ldir), 0.0);\n    float spec1 = pow(max(dot(reflect(-ldir, n), rd), 0.0), 25.0);\n    float atten1 = 2.0 / max(ldist*ldist * 4.0 + 8.0 * ldist, EPS);\n    float flk = getFlicker(int(iTime * 8.0 + i * 3.0));\n    float flkt = (p.z - i) / columnSpacing - 0.5;\n    float flk1 = getFlicker(int(iTime * 8.0 + (i + sign(flkt) * s) * 3.0));\n    //flkt = abs(flkt) * 2.0;//smoothstep(0.0, 1.0, abs(flkt))\n    flkt = (abs(flkt) * 2.0 - 0.7) / 0.3;\n    flkt = smoothstep(0.0, 1.0, flkt) * 0.5;\n    flk = mix(flk, flk1, flkt);\n    \n    atten1 *= flk * 0.9 + 0.1;\n    dif1 *= atten1;\n    spec1 *= atten1;\n    \n    dif *= dif0 + dif1;\n    spec *= spec0 + spec1;\n    \n    occ = saturate(occ / occRad);\n    occ = mix(occ, 1.0, 0.1);\n    \n#ifdef SHOW_MATERIALS\n    col = uv.x < 0.25 ? vec3(alb * occ)  :\n          uv.x < 0.5  ? vec3(dif * occ)  :\n          uv.x < 0.75 ? vec3(spec * occ) :\n                        vec3(n);\n#else\n    col = alb * (dif + spec * 2.0) * occ;\n    \n    if (mat == 3)\n    {\n        col = mix(col * 0.2, alb, flk);\n    }\n    \n    vec3 fogCol = vec3(0.05, 0.18, 0.2) * 0.12;\n#ifdef FOG\n    col = mix(col, fogCol, 1.0 - exp(-t * FOG_STRENGTH));\n#endif\n#endif\n    \n    col = max(col, vec3(0));\n    //col = col / (1. + col);\n    //col = Tonemap_Uchimura(col);\n    col = mix(col / (1. + col), ACESFilm(col), 0.5);\n    \n    col *= 0.5 + 0.5 / (1.0 + dot(pv, pv) * 0.5);\n    \n    tot += col;\n    \n#ifdef AA\n    }\n    tot /= 4.0;\n#endif\n\n    fragColor = vec4(linearTosRGB(tot), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n\n// Orthonormal basis\n// https://www.shadertoy.com/view/tlVczh\n#define METHOD 1\n#if METHOD == 0\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  // MBR method 2a variant, seems similiar to pixar\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n}\n#elif METHOD == 1\n// Goofy ahh basis but Z-aligned\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n    vec3 u = abs(n.y) > 0.9999 ? vec3(0, 0, 1) : vec3(0, 1, 0);\n    xp = normalize(cross(n, u));\n    yp = cross(n, xp);\n}\n#endif\n\n\n// https://iquilezles.org/articles/intersectors/\nvec2 RaySphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( b > 0.0 || h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 RayCylinder( in vec3 ro, in vec3 rd, float cr )\n{\n    vec3 ca = vec3(0, 0, 1);\n    vec3  oc = ro;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(MAX_DIST); //no intersection\n    h = sqrt(h);\n    if (-b+h < 0.0) return vec2(MAX_DIST);\n    return vec2(-b-h,-b+h)/a;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo, float a)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(sin(a), cos(a), 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0), vec2(0));\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat luminance(vec3 c)\n{\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// RGB to HSV conversion from\n// https://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + 1e-5) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + 1e-5);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n  \nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.76;//2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nfloat Tonemap_Uchimura(float x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n    return Tonemap_Uchimura(x, P, a, m, l, c, b);\n}\n\nvec3 Tonemap_Uchimura(vec3 c)\n{\n    return vec3(Tonemap_Uchimura(c.x), Tonemap_Uchimura(c.y), Tonemap_Uchimura(c.z));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}