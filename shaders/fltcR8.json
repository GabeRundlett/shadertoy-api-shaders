{
    "Shader": {
        "info": {
            "date": "1659262992",
            "description": "low-iq bruteforce approach for raytracing a bunch of spheres with AA, DOF, shadows and GI",
            "flags": 0,
            "hasliked": 0,
            "id": "fltcR8",
            "likes": 1,
            "name": "iterative-tracer",
            "published": 3,
            "tags": [
                "raytracer",
                "iterative"
            ],
            "usePreview": 0,
            "username": "elementbound",
            "viewed": 243
        },
        "renderpass": [
            {
                "code": "#define MAX_RAY_DEPTH 4\n#define SAMPLE_COUNT 16\n\n#define SPHERE_COUNT 5\n\ncamera_t camera;\nsphere_t spheres[SPHERE_COUNT];\n\nrayStep_t raySteps[MAX_RAY_DEPTH];\n\nvoid setupCamera(float time) {\n    float yaw = iTime / 15.0;\n    float roll = (1.0 + sin(mod(iTime / 30.0, 1.0) * 2.0 * PI)) / 2.0;\n    roll = mix(-30.0f, 60.0f, roll) * DEG2RAD;\n    \n    camera.from = yawroll(yaw, roll) * 4.0;\n    camera.to = vec3(0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    \n    camera.r = 0.005;\n    camera.fov = 60. * DEG2RAD;\n    \n    camera.from.y = abs(camera.from.y);\n}\n\nvoid setupScene(float time) {\n    setupCamera(time);\n    \n    for (int i = 0; i < SPHERE_COUNT - 2; ++i) {\n        float sf = float(i) / float(SPHERE_COUNT - 2);\n        spheres[i].pos = yawroll(sf * 360. * DEG2RAD, 0.);\n        spheres[i].r = 0.375;\n    \n        spheres[i].material.albedo = (1.0 + normalize(spheres[i].pos)) / 2.0;\n        spheres[i].material.emissive = vec3(0.);\n        spheres[i].material.metallic = (1.0 + spheres[i].pos.x) / 2.;\n        spheres[i].material.roughness = (1.0 + spheres[i].pos.z) / 2.;\n    }\n    \n    // Top light sphere\n    spheres[SPHERE_COUNT - 1].pos = vec3(0., 4., 0.);\n    spheres[SPHERE_COUNT - 1].r = 1.;\n    \n    spheres[SPHERE_COUNT - 1].material.albedo = vec3(0);\n    spheres[SPHERE_COUNT - 1].material.emissive = vec3(2);\n    \n    \n    // Bottom floor sphere\n    spheres[SPHERE_COUNT - 2].pos = vec3(0., -512. - spheres[0].r, 0.);\n    spheres[SPHERE_COUNT - 2].r = 512.;\n    \n    spheres[SPHERE_COUNT - 2].material.albedo = vec3(1.0);\n    spheres[SPHERE_COUNT - 2].material.emissive = vec3(0.);\n    spheres[SPHERE_COUNT - 2].material.roughness = 0.05;\n    spheres[SPHERE_COUNT - 2].material.metallic = 1.;\n}\n\nfloat raycastScene(ray_t ray, out vec3 p, out vec3 n, out material_t material) {\n    float rt = -32768.;\n    vec3 rp, rn;\n    material_t rm;\n    \n    vec3 tp, tn;\n    \n    for (int i = 0; i < SPHERE_COUNT; ++i) {\n        float t = raycastSphere(ray, spheres[i], tp, tn);\n        \n        if (t >= 0. && t < abs(rt)) {\n            rt = t;\n            rp = tp;\n            rn = tn;\n            rm = spheres[i].material;\n        }\n    }\n    \n    if (rt >= 0.) {\n        p = rp;\n        n = rn;\n        material = rm;\n    }\n    \n    return rt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMin = min(iResolution.x, iResolution.y);\n    float resMax = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/resMin;\n    uv.x -= (resMax - resMin) / resMin / 2.;\n    \n    // Setup scene\n    setupScene(iTime);\n    \n    fragColor = vec4(0.);\n    \n    for (int j = 0; j < SAMPLE_COUNT; ++j) {\n        vec4 seed = vec4(fragCoord, iFrame, j);\n        ray_t ray = getRay(camera, uv, seed);\n\n        float t;\n        vec3 p, n;\n        material_t m;\n        vec3 radiance = vec3(0.);\n\n        int rayDepth = 0;\n        \n        for (int i = 0; i < MAX_RAY_DEPTH; ++i) {\n            t = raycastScene(ray, p, n, m);\n            raySteps[i].ray = ray;\n            raySteps[i].t = t;\n            raySteps[i].color = vec3(0.);\n            \n            rayDepth++;\n\n            if (t >= 0.) {\n                raySteps[i].material = m;\n                raySteps[i].p = p;\n                raySteps[i].n = n;\n                \n                ray.origin = p + n * 0.0001;\n                vec3 offset = hash44(vec4(fragCoord.xy, iFrame, 17 + i * 27 + j * 37)).xyz;\n                offset = normalize(2. * offset - 1.);\n                ray.d = reflect(ray.d, normalize(n + offset * m.roughness));\n            } else {\n                break;\n            }\n        }\n        \n        raySteps[rayDepth - 1].color = texture(iChannel0, raySteps[rayDepth - 1].ray.d).rgb;\n        \n        for (int i = rayDepth - 2; i >= 0; i -= 1) {\n            vec3 albedoMultiplier = mix(\n                vec3(length(raySteps[i+1].color)),\n                raySteps[i+1].color,\n                raySteps[i].material.metallic\n            );\n        \n            raySteps[i].color =\n                raySteps[i].material.albedo * albedoMultiplier +\n                raySteps[i].material.emissive;\n        }\n        \n        fragColor += vec4(raySteps[0].color, 1.);\n    }\n    \n    fragColor /= float(SAMPLE_COUNT);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ================================================================================================\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// ================================================================================================\n// Useful constants\n\n#define DEG2RAD 0.01745329251994329576923690768489\n#define PI 3.1415926535897932384626433832795\n\n// ================================================================================================\n// Common structs\n\nstruct ray_t {\n    vec3 origin;\n    vec3 d;\n};\n\nstruct material_t {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float metallic;\n};\n\nstruct sphere_t {\n    vec3 pos; \n    float r;\n    material_t material;\n};\n  \nstruct rayStep_t {\n    ray_t ray;\n    material_t material;\n    vec3 color;\n    \n    float t;\n    vec3 p;\n    vec3 n;\n};\n  \nstruct camera_t {\n\tvec3 from; \n\tvec3 to;\n\tvec3 up;\n    \n    float fov;\n    float r;\n};\n\n// ================================================================================================\n// Raycasting\n\nfloat raycastSphere(ray_t ray, sphere_t sphere, out vec3 p, out vec3 n)\n{\n    // Based on:\n    // https://gdbooks.gitbooks.io/3dcollisions/content/Chapter3/raycast_sphere.html\n\n\tvec3 p0 = ray.origin;\n    vec3 d = ray.d;\n    vec3 c = sphere.pos;\n    float r = sphere.r;\n    \n    vec3 e = c - p0;\n    float Esq = dot(e, e);\n    float a = dot(e, d);\n    float b = sqrt(Esq - a*a);\n    float f = sqrt(r*r - b*b);\n    \n    float D = r*r - Esq + a*a;\n    float t = 0.;\n    \n    if (D < 0.)\n        return -1.;\n\n    if (Esq < r*r)\n        t = a + f;\n    else\n        t = a - f;\n        \n    p = ray.origin + t * ray.d;\n    n = normalize(p - c);\n        \n    return t;\n}\n\n// ================================================================================================\n// Camera\n\n// Based on: \n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\nmat4 lookAt(vec3 from, vec3 to, vec3 up) {\n    up = normalize(up);\n    \n    vec3 forward = to - from;\n    forward = normalize(forward);\n    \n    vec3 side = normalize(cross(forward, up));\n    up = cross(side, forward); \n    up = normalize(up);\n    \n    return mat4(vec4(side, 0.0), vec4(up, 0.0), vec4(forward, 0.0), vec4(0.,0.,0.,1.));\n}\n\nvec3 yawroll(float yaw, float roll) {\n    float d = cos(roll);\n    return vec3(cos(yaw)*d, sin(roll), sin(yaw)*d);\n}\n\nray_t getRay(camera_t camera, vec2 uv, vec4 seed) {\n    vec3 offset = hash44(seed).xyz;\n    offset = 2. * offset - 1.;\n    offset *= camera.r;\n    \n    mat4 view = lookAt(camera.from + offset, camera.to, camera.up);\n    float znear = 1.0 / tan(camera.fov / 2.0f);\n    \n    vec3 d = normalize(vec3(2. * uv - 1., znear));\n    d = (view * vec4(d, 0.0)).xyz;\n    \n    ray_t result;\n    result.origin = camera.from;\n    result.d = d;\n    \n    return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}