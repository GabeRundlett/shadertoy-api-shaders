{
    "Shader": {
        "info": {
            "date": "1487927893",
            "description": "Cool plumbus. How they do it? https://www.youtube.com/watch?v=eMJk4y9NGvE",
            "flags": 0,
            "hasliked": 0,
            "id": "ldfyD8",
            "likes": 8,
            "name": "Plumbus",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Nesvi7",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float normal_step = 0.02;\nconst float clip_far = 2000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,-1.0));\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opUS( vec2 d1, vec2 d2, float smoothv )\n{\n\treturn vec2(smin(d1.x,d2.x, smoothv), (d1.x<d2.x)?d1.y:d2.y);\n}\n\nfloat rand(float value){\n    vec2 co = vec2(sin(value*0.234871),cos(value*0.9834723) );\n    return ((sin(dot(co.xy ,vec2(2.99/*iTime*/,78.233)))))*1.0;\n}\n\n//Primitives\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Map\nvec2 PlumbusPlumber(vec3 p){\n\tfloat minDist = length(p)-0.75;\n    const float dbpt = 0.75;\n    for(int i = 0; i < 15; i++){\n        vec3 offset = normalize(vec3(rand(float(i*i)),rand(float(i*i*i)),rand(float(i))))*dbpt;\n    \tminDist = smin(length(p+offset)-0.5,minDist,8.0);\n    }\n    \n    return vec2(minDist,1.0);\n}\n\nvec2 PlumbusStick(vec3 p){\n\treturn vec2(sdCapsule(p,vec3(0.0,0.0,0.0),vec3(0.0,2.5,0.0),0.35),0.0);\n}\n\nvec2 PlumbusCylinder(vec3 p ){\n    vec3 position = p+vec3(0.0,-4.0,0.0);\n    position = rotate(position,vec3(PI/2.0,0.0,0.0));\n    float theDist = sdTorus(position,vec2(0.8,1.0));\n    theDist = smin(theDist,length(position*vec3(0.7,1.0,0.7))-1.2,8.0);\n\treturn vec2( theDist, 0.0);\n}\n\nvec2 PlumbusActivator(vec3 p){\n    float activatorMovement = sin(iTime*2.0)*0.6;\n    activatorMovement *= (p.z-3.5)/5.0;\n    vec3 position = p+vec3(0.0,-3.5,1.4);\n    position = rotate(position,vec3(PI/2.0,0.0,0.0));\n    float theDist = sdTorus(position,vec2(0.2,0.2));\n    theDist = smin(theDist,sdCapsule(p,vec3(0.0,3.5,-1.4),vec3(0.0,3.5+activatorMovement,-2.3),0.1),8.0);\n    theDist = smin(theDist,length(p-vec3(0.0,3.5+activatorMovement,-2.3))-0.2,8.0);\n    return vec2( theDist, 0.0);\n}\n\nvec2 PlumbusBack(vec3 p){\n    p -= vec3(0.0,0.0,-1.0);\n    vec3 position = p+vec3(0.0,-3.5,-2.0);\n    float minDist = length(position*vec3(1.0,1.0,0.2))-0.2;\n    for(int i = 0; i < 10; i++){\n        position = p;\n        \n        position = p+vec3(0.0,-3.5,-2.0);\n  \t\tposition = rotate(position, vec3(rand(float(i)),rand(float(i)+1.0),rand(float(i)+2.0))*1.0);\n        position *= vec3(1.0,1.0,0.2);      \n        position += vec3(0.0,0.0,-0.2);\n    \tminDist = smin(minDist,length(position)-0.2,8.0);\n    }\n    return vec2(minDist,2.0);\n}\nvec2 map( vec3 p) {\n    vec2 result = PlumbusPlumber(p);\n\tresult = opUS(PlumbusStick(p),result,8.0);\n\tresult = opUS(PlumbusCylinder(p),result,8.0);\n\tresult = opUS(PlumbusActivator(p),result,8.0);\n    result = opUS(PlumbusBack(p),result,8.0);\n    return result;\n}\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( normal_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, normal_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, normal_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nfloat calculateAmbientOcclusion(vec3 p, vec3 n, const float stepDistance){\n\n    float ao = 0.0;\n    float difference = 0.0;\n    float depth = 0.0;\n    for(float i = 0.0; i < 10.0; i++){\n        ao += map(p+depth*n).x;\n        depth += stepDistance;\n    }\n    \n    return ao / 10.0;\n}\n\nvec3 material( vec3 v, vec3 n, vec3 eye ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    vec3 albedo = vec3(0.5,0.0,0.0);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float lambert = pow(max(0.0,(dot(sunDir,n)+1.0)*0.5),2.0);\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    float ao = calculateAmbientOcclusion(v,n,0.25);\n\tvec3 reflectionColor = texture(iChannel0,reflect(viewDir,n)).xyz*0.03;\n    \n    vec3 light = vec3(0.98, 0.85, 0.78);\n    vec3 dark = vec3(0.92, 0.67, 0.59);\n    \n    return mix(dark,light,lambert*ao)+reflectionColor;\n}\n\nvec3 materialPlumber( vec3 v, vec3 n, vec3 eye ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    vec3 albedo = vec3(0.5,0.0,0.0);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float lambert = pow(max(0.0,(dot(sunDir,n)+1.0)*0.5),2.0);\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    float ao = calculateAmbientOcclusion(v,n,0.25);\n\tvec3 reflectionColor = texture(iChannel0,reflect(viewDir,n)).xyz*0.03;\n    \n    vec3 light = vec3(0.70, 0.33, 0.33);\n    vec3 dark = vec3(0.98, 0.60, 0.61);\n    \n    return mix(dark,light,lambert*ao)+reflectionColor;\n}\n\nvec3 materialPlumBack( vec3 v, vec3 n, vec3 eye ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    vec3 albedo = vec3(0.5,0.0,0.0);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor =vec3(0.87, 0.24, 0.40) * fresnel(n,viewDir,2.0);    \n    \n    float lambert = pow(max(0.0,(dot(sunDir,n)+1.0)*0.5),2.0);\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    float ao = calculateAmbientOcclusion(v,n,0.25);\n\tvec3 reflectionColor = texture(iChannel0,reflect(viewDir,n)).xyz*0.03;\n    \n    vec3 light = vec3(0.87, 0.24, 0.40);\n    vec3 dark = vec3(0.87, 0.24, 0.40)*0.8;\n    \n    return mix(dark,light,lambert*ao)+reflectionColor+fresnelColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 2.2, 10.0 );\n\n\t// rotate camera\n    mat3 rot = rotationXY( vec2(0,iMouse.x/iResolution.x*PI+PI*0.5));//vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(mix(vec3(0.64, 0.94, 0.88),vec3(0.33, 0.47, 0.54),pow(abs(dot(dir,vec3(0.0,1.0,0.0))),0.5)),1.0);//vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    vec3 fogColor = vec3(0.3,0.3,0.3);\n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(material( pos, n, eye ), 1);\n    else if( rayResult.y == 1.0 )\n        fragColor = vec4(materialPlumber( pos, n, eye ), 1);\n    else \n        fragColor = vec4(materialPlumBack( pos, n, eye ), 1);\n        \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}