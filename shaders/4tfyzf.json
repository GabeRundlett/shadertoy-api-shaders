{
    "Shader": {
        "info": {
            "date": "1617152451",
            "description": "#makeYourShadersPublic\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "4tfyzf",
            "likes": 20,
            "name": "Wreck Scanners",
            "published": 3,
            "tags": [
                "2d",
                "3d"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "#define T texture(iChannel0, uv\n#define W vec2\n\n#define BLOOM\n\n#define time iTime\n#define res iResolution\n\nfloat alpha;\n\nvec4\n     bloom = vec4(0),\n     blur = vec4(0);\n\n#define GA 2.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.001*8./6.,.001, 0) * .05;\n\n\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// \tsimplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(0,rad);\n    rad=1.;\n    float bc = 1.;\n\tfor (int j=0;j<70;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        vec4 col=texture(tex,uv+pixel.xy*(rad-1.)*angle);\n        if (intensity(col) > .9) {            \n\t\t\tbloom += col; \n            bc++;\n        }\n        blur += col;\n\t}\n\tblur /= 96.;\n    \n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    \n    vec4 orgColor = (\n        texture(iChannel0,uv) \n    \t+ (texture(iChannel0,uv + pixel.xz)\n        \t+ texture(iChannel0,uv + pixel.zx)\n        \t+ texture(iChannel0,uv - pixel.xz)\n        \t+ texture(iChannel0,uv - pixel.zx)\n         ) * .25\n    ) / 2.,\n        \n    oo = orgColor;\n    \n    alpha = texture(iChannel0,uv).a;\n    \n    dof(iChannel0,uv, 20., orgColor);\n    \n    #ifdef BLOOM\n    \n    orgColor += bloom * 0.003;\n    #endif\n    \n    float df = min(1., pow(abs(alpha - .7) * 3., 2.));\n    \n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tdf,\n            0.,\n            1.\n        )\n    );\n    \n    \n    orgColor = mix(\n        orgColor * 2., \n        blur, \n        clamp(\n        \tmin(1., pow((uv.y-.2) * .4, 1.)),\n            0.,\n            1.\n        )\n    );\n    \n \t\n    fragColor = orgColor;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define getNormal getNormalCube\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 50.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat noiseShort(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1., .5, 0.)); \n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\ngeometry DE(vec3 p, float c)\n{\n    \n \tconst float scale = 2.8;\n\tconst float offset = 9.0;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(19.3, -3., 3.2);\n\n    for(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n        p = abs(p);\n        \n\t\tp.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n\t\tp.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n        p.x += 90.;\n        pR(p.xy, .725 );\n        p.zy += 22.;\n        \n        p.xyz = scale* p.xyz - offset*(scale - .3) * modifier.xyz;\n        \n\t}\n \tgeometry obj, obj2;\n    \n    obj.dist = fBox(p, vec3(10., 199., 0.1)) * (pow(scale, -float(FRACTALITERATIONS))); \n\tobj.material = vec2(1., 0.);\n    \n    obj.space = p;\n    return obj;\n}\n\n// Repeat in two dimensions\n\ngeometry map(vec3 p) {\n    vec3 bp = p;\n    \n    p.zyx = mod(p.zyx, vec3(150., 150., 50.)) - vec3(75., 75, 25);\n \n    geometry obj;\n    obj = DE(p, 1.);\n    \n    obj.space = p;\n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 640.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n        minDist = min(minDist, mp.dist * 3.);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 1.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n\n\n\n#define EPSILON .00001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).dist - map( pos - delta.xyy ).dist;\n   n.y = map( pos + delta.yxy ).dist - map( pos - delta.yxy ).dist;\n   n.z = map( pos + delta.yyx ).dist - map( pos - delta.yyx ).dist;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n\n    if (obj.material.x == 1.0) { \n        col = vec3(.0, .0, 0.);// + abs(sin(obj.space.x + obj.space.z + iTime * 3.) );\n        //col *= noiseShort(p * .02) *14.;\n    }\n    //col += fract(obj.space.z * -0.1 + t) * 10.;\n    return col;//* fract(p.y / 10.) * 10.;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 2.1); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 10.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .1);// atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv = ouv - .5;\n   // uv.y /= iResolution.x/ iResolution.y;\n    vol = 1.;//length(texture(iChannel0, vec2(.42, .25)).rgb);\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .4) * 6.0, \n        ck = cos(-t2 * .4) * 2.0,\n        \n        mat = 0.;\n    \n    light = vec3(.0, 0., -310.);        \n\n    vec3 \n        vuv = vec3(0., 1.,0.), // up\n    \tro = vec3(121., -14., 73.);// + vec3(sin(t) * 1. + 60., -20. - cos(t / 9.) * 1., 13.);//iMouse.y / 2. - 100., 10.); // pos\n\tro.x -= t * 10.;    \n    light =+ro;\n    \n    vec3 oro = ro;\n    vec3\n        vrp =  vec3(-t * 10., 0. , 0.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n\t\n    vec3 sceneColor = vec3(0.);\n    vec3 lp = light;// + ro;\n\tlightDir = lp;\n\t\n    geometry tr = trace(ro, rd);    \n    \n    tr.hit = ro + rd * tr.dist;\n    tr.sn = getNormal(tr.hit);\t\n    \n    float sh = softShadow(tr.hit, light + ro, 1.);\n    \n    float \n        ao = getAO(tr.hit, tr.sn, 9.1);\n\t\n   if (tr.dist < FAR) { \n        vec3 col = (doColor(tr.hit, rd, tr.sn, light, tr) * 1.) * 1.;\n        sceneColor = col;\n        sceneColor *= sh;        \n        \n        sceneColor = mix(sceneColor, vec3(0.), saturate(tr.dist * 1.3 / FAR));\n    } else {\n    \ttr.dist = FAR;\n    }\n    \n    float flareDist = 1e9;\n    vec3 flareCol = vec3(0.), flareCol_B = vec3(0.);\n    for (float k = 0.; k < 256.; k++) {\n        vec3 flarePos = \n            vec3(\n                 sin(k / 32.) * 35. - t * 10. + 10.,\n                -6.-cos(k / 6. - t / 3.) * sin(k - k * 0.1 + sin(t / 13.) * 2.) * 12.,\n                cos( t /  14. + k / 12.) * 35. * (sin(t * .2+ k) / 2. + .8)\n            );\n\t\tflareDist = min(distance(tr.hit, flarePos), flareDist); \n        if (tr.dist > distance(flarePos, ro)) {\n            flareCol_B += abs(vec3(1., 0.2, 0.)) * pow(max(0., dot(normalize(-ro + flarePos) * 0.99, rd) * 1.0), 400.) * 0.94;\n            flareCol += abs(vec3(1., .2, 0.)) * pow(pow(max(0., dot(normalize(-ro + flarePos), rd) * 1.0), 52200. - distance(ro, flarePos) * 50.) / distance(ro, flarePos) * 100., 5.) * abs(sin(t + k));\n        }\n        \n    }\n    if (flareCol.r > 0.2) {\n        tr.dist = .7 * 210.;\n    }\n    \n    flareCol += flareCol_B;\n    \n    sceneColor += pow(vec3(1., 0.2, 0.) / (flareDist / 4.), vec3(4.) * .4);\n    \n    sceneColor *= ao; \n    sceneColor = mix(sceneColor, vec3(.1, .1, .1), clamp(tr.dist / 210., 0. ,1.)); \n\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), tr.dist / 160.);\n    fragColor.rgb += flareCol;\n    fragColor.rgb += pow(flareCol, vec3(1.0)) * 1.4;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}