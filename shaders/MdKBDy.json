{
    "Shader": {
        "info": {
            "date": "1531470717",
            "description": "Playing at 3D; I'm sure this is pretty awful code but I'm learning!",
            "flags": 0,
            "hasliked": 0,
            "id": "MdKBDy",
            "likes": 2,
            "name": "Playtracing",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "_polymath",
            "viewed": 529
        },
        "renderpass": [
            {
                "code": "#define BALLCOUNT 5\n\nstruct ball {\n\tvec3 position;\n    float radius;\n    float radiusSq;\n};\nball newBall(vec3 pos, float rad) {\n\treturn ball(pos, rad, rad*rad);\n}\n\n// if you want a camera position, subtract it from both inputs\nfloat point2rayDistSq(vec3 p, vec3 ray) {\n    vec3 dd = p - dot(p, ray) / dot(ray, ray) * ray;\n    return dot(dd, dd);\n}\n\nvec4 sky(vec3 ray, vec3 light) {\n    float l = dot(ray, light) * 0.3;\n    return texture(iChannel1, ray) +\n        vec4(l, l, l, 0.0);\n}\n\nvec4 floorColor(vec2 floorUv, ball[BALLCOUNT] balls, float floorH, vec3 light) {\n    vec4 fragColor = texture(iChannel0, floorUv * 0.2)\n        * (pow(length(floorUv), -0.1)) * 1.2;\n    \n    // shadow\n    for (int i = 0; i < BALLCOUNT; ++i)\n    \tif (point2rayDistSq(\n        \tballs[i].position - vec3(floorUv.x, floorH, floorUv.y),\n            light) < balls[i].radiusSq) {\n        return fragColor *= 0.7;\n    }\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float floorH = sin(iTime * 0.32) * 0.4 - 1.;\n    \n    ball[] balls = ball[] (\n        newBall(vec3(\n            sin(iTime * 0.2) + 1.0,\n            cos(iTime * 0.7) + 1.2,\n            sin(iTime * 0.2) + 8.0),\n            cos(iTime * 0.3) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.4) + 1.0,\n            cos(iTime * 0.5) + 1.2,\n            sin(iTime * 0.6) + 8.0),\n            cos(iTime * 0.5) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.2) + 1.0,\n            cos(iTime * 0.4) + 1.2,\n            sin(iTime * 0.4) + 8.0),\n            cos(iTime * 0.4) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.3) + 1.0,\n            cos(iTime * 0.2) + 1.2,\n            sin(iTime * 0.1) + 8.0),\n            cos(iTime * 0.6) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.45) + 1.0,\n            cos(iTime * 0.7) + 1.2,\n            sin(iTime * 0.3) + 8.0),\n            cos(iTime * 0.7) * 0.3 + 1.3));\n\n    vec3 light = vec3(cos(iTime * 0.5), 1., sin(iTime * 0.5));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.) *2.0 / iResolution.yy;\n    vec3 ray = normalize(vec3(uv, 3.5));\n    vec3 cam = vec3(0.,0.,0.);\n    fragColor = vec4(0.,0.,0.,1.);\n    float rayLeft = 1.;\n\n    while (rayLeft > 0.001) {\n        //balls\n        int bId = -1;\n        float minBallDist = 10000000000.0;\n        for (int i = 0; i < BALLCOUNT; ++i) {\n        \tvec3 b = balls[i].position - cam;\n        \tfloat d = point2rayDistSq(b, ray);\n        \tif (d < balls[i].radiusSq) {\n            \tfloat distanceToBall = \n                    dot(b, ray) - sqrt(1. - d/balls[i].radiusSq);\n                if (distanceToBall > 0. && distanceToBall < minBallDist) {\n                    minBallDist = distanceToBall;\n                    bId = i;\n                }\n        \t}\n        }\n        if (bId >= 0) {\n            vec3 intersection = cam + ray * minBallDist;\n            if (intersection.y > floorH) {\n                vec3 normal = normalize(intersection - balls[bId].position),\n                    reflection = ray - 2. * dot(ray, normal) * normal;\n                float l = dot(normal, light) * 0.2;\n                fragColor += vec4(l,l,l,0.) * rayLeft;\n                ray = reflection;\n                cam = intersection;\n                rayLeft *= 0.8;\n                continue;\n            }\n        }\n\n        if (ray.y > 0.) {\n            // we escaped so we're done here\n            fragColor += sky(ray, light) * rayLeft;\n            break;\n        }\n        \n        // floor\n        vec2 floorUv = cam.xz + ray.xz / ray.y * (floorH - cam.y);\n        fragColor += floorColor(floorUv,\n             balls, floorH, light) * rayLeft * 0.7;\n        \n        // reflect\n        cam = vec3(floorUv.x, floorH, floorUv.y);\n        ray.y *= -1.;\n        rayLeft *= 0.3;\n    }\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}