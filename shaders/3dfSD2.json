{
    "Shader": {
        "info": {
            "date": "1552249590",
            "description": "And Happy Soft Shadows! \n\nPress buttons to watch bonus effects.\n\nMy Task1 in mashgraph course.\nArtur B., 316",
            "flags": 16,
            "hasliked": 0,
            "id": "3dfSD2",
            "likes": 1,
            "name": "Merry Ray Marching!",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "shadows"
            ],
            "usePreview": 0,
            "username": "ooptyp",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 300;\nconst int SHADOW_STEPS = 128;\nconst float MAX_MARCH_DIST = 120.0;\nconst float EPS = 0.0001;\nconst float SHININESS = 10.0;\n\nconst float KEY_F  = 70.5/256.0;\nconst float KEY_T  = 84.5/256.0;\n\n//---------------------------------------------------------------------------------\n/*\n\nEffects:\n\nPress F to watch fractal \"star\"\nPress T to change shadow type (sharp / soft)\n\n*/\n//---------------------------------------------------------------------------------\n\nstruct Figure \n{\n    float dist;\n    vec3 color;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 power;\n};\n\n\nFigure Unite(Figure f1, Figure f2)\n{\n    if (f1.dist < f2.dist) return f1;\n        else return f2;\n}\n\nFigure Carve(Figure f1, Figure f2)\n{\n    if (f1.dist > -f2.dist) return f1;\n    else {\n        f2.dist *= -1.;\n        return f2;\n    }\n}\n\nFigure Plane(vec3 p)\n{\n    Figure f;\n    vec4 n = vec4(0.0, 1.0, 0.0, 1.5);\n    f.dist = dot(p,n.xyz) + n.w;\n    f.color = vec3(0.4, 0.6, 1.0);\n    return f;\n}\n\nFigure Sphere1(vec3 p)\n{\n    Figure f;\n    p += vec3(-25.0, 0.0, -11.0);\n    f.dist = length(p) - 4.0;\n    f.color = vec3(0.4, 0.8, 1.0);\n    return f;\n}\n\nFigure Sphere2(vec3 p)\n{\n    Figure f;\n    p += vec3(-25.0, -5.75, -11.0);\n    f.dist = length(p) - 3.0;\n    f.color = vec3(0.4, 0.8, 1.0);\n    return f;\n}\n\nFigure Sphere3(vec3 p)\n{\n    Figure f;\n    p += vec3(-25.0, -9.5, -11.0);\n    f.dist = length(p) - 2.0;\n    f.color = vec3(0.4, 0.8, 1.0);\n    return f;\n}\n\nFigure Eyes(vec3 p)\n{\n    Figure f;\n    vec3 c1 = vec3(23.0, 10, 12.5);\n    vec3 c2 = vec3(25.0, 10, 13.0);\n    float d1 = length(p - c1) - 0.5;\n    float d2 = length(p - c2) - 0.5;\n    f.dist = min(d1, d2);\n    f.color = vec3(0.0);\n    return f;\n}\n\nFigure Box1(vec3 p)\n{\n    Figure f;\n    p += vec3(15.0, -5.0, -16.0);\n    vec3 d = abs(p) - vec3(4.0, 3.0, 2.0);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 0.0, 1.0);\n    return f;\n}\n\nFigure Box2(vec3 p)\n{\n    Figure f;\n    p += vec3(15.0, -5.0, -16.0);\n    vec3 d = abs(p) - vec3(4.5, 3.5, 0.5);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 1.0, 0.0);\n    return f;\n}\n\nFigure Box3(vec3 p)\n{\n    Figure f;\n    p += vec3(15.0, -5.0, -16.0);\n    vec3 d = abs(p) - vec3(0.5, 3.5, 2.5);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 1.0, 0.0);\n    return f;\n}\n\nFigure Stick(vec3 p)\n{\n    Figure f;\n    vec3 a = vec3(15.0, -3.0, 0.0);\n    vec3 b = vec3(15.0, 13.0, 0.0);\n    float r = 1.5;\n    \n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    f.dist = length( pa - ba*h ) - r;\n    if (mod(p.y, 2.) < 1.0) f.color = vec3(1.0, 0.0, 0.0);\n        else f.color = vec3(1.0, 0.8, 0.8);\n    return f;\n}\n\nFigure halfTorus(vec3 p)\n{\n    Figure f;\n    p -= vec3(12.0, 13.0, 0.0);\n    if (p.y < -1.0) {\n        f.dist = MAX_MARCH_DIST;\n        return f;\n    }\n    vec2 t = vec2(3.0, 1.5);\n    vec2 q = vec2(length(p.xy)-t.x, p.z);\n    f.dist = length(q)-t.y;\n    if (mod(p.y, 2.) < 1.0) f.color = vec3(1.0, 0.0, 0.0);\n        else f.color = vec3(1.0, 0.8, 0.8);\n    return f;\n}\n\n// FRACTAL STAR\n// (The Mandelbulb fractal)\nFigure Star(vec3 p) {\n\tFigure f;\n    p -= vec3(-8.0, 14.0, 0.0);\n\n    vec3 point = p;\n    float dz = 1.0;   \n    for (int j=0; j<4; j++) {      \n        float r = length(point);\n        float o = acos(point.z/r);\n        float i = atan(point.y/point.x);\n        \n        dz = 8.0 * pow(r, 7.0) * dz + 1.0;\n        r = pow(r, 8.0);\n        o *= 8.0;\n        i *= 8.0;\n\n        point = vec3( r*sin(o)*cos(i), r*sin(o)*sin(i), r*cos(o)) + p;\n        if (dot(point,point) > 4.0) break;\n    }\n    float z = length(point);\n    f.dist = 0.5 *z*log(z)/dz;\n    f.color = vec3(1.0, 1.0, 0.0);\n\treturn f;\n}\n\n// COMPLEX FIGURES\nFigure Tree( vec3 p)\n{\n    Figure f;\n    p -= vec3(-8.0, 0.0, 0.0);\n    vec2 d1 = abs(vec2(length(p.xz),p.y)) - vec2(8.0, 4.0);\n    p -= vec3(0.0, 6.0, 0.0);\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - vec2(6.0, 3.0);\n    p -= vec3(0.0, 4.0, 0.0);\n    vec2 d3 = abs(vec2(length(p.xz),p.y)) - vec2(3.5, 2.5);\n\n    float dd1 = min(max(d1.x,d1.y),0.0) + length(max(d1,0.0));\n    float dd2 = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    float dd3 = min(max(d3.x,d3.y),0.0) + length(max(d3,0.0));\n    f.dist = min(min(dd1, dd2), dd3);\n    f.color = vec3(0.0, 1.0, 0.2);\n    return f;\n}\n\nFigure Snowman(vec3 p)\n{\n    return\n        Unite(\n            Sphere1(p), Unite(\n                Sphere2(p), Unite(\n                    Sphere3(p), Eyes(p)\n                )\n            )\n        );\n}\n\nFigure Bench(vec3 p)\n{\n    Figure f, g;\n    p -= vec3(-30.0, 0.0, 10.0);\n    vec3 d = abs(p) - vec3(4.0, 6.0, 5.0);\n    f.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    f.color = vec3(1.0, 0.5, 0.0);\n    p -= vec3(2.0, 4.0, 0.0);\n    g.dist = length(p) - 5.0;\n    return Carve(f, g);\n}\n\nFigure ChristmasTree(vec3 p)\n{\n    return Unite(Tree(p), Star(p));\n}\n\nFigure Gift(vec3 p)\n{\n    return Unite(Box1(p), Unite(Box2(p), Box3(p)));\n}\n\nFigure Candy(vec3 p)\n{\n    return Unite(Stick(p), halfTorus(p));\n}\n\n\nFigure Map(vec3 p)\n{\n    return\n        Unite(\n            Plane(p), Unite(\n                Snowman(p), Unite(\n                    ChristmasTree(p), Unite(\n                        Gift(p), Unite(\n                            Candy(p), Bench(p)\n                        )\n                    )\n                )\n            )\n        );          \n}\n// Map is built!\n\n// Ray Marching begins here\nFigure RayMarching(vec3 eye, vec3 dir)\n{\n    float depth = 0.0;\n    float end = MAX_MARCH_DIST;\n    Figure f;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        f = Map(eye + depth * dir);\n        if (f.dist < EPS) {\n            f.dist = depth;\n            return f;\n        }\n        depth += f.dist;\n        if (depth >= end) {\n            f.dist = end;\n            return f;\n        }\n    }\n    f.dist = end;\n    return f;\n}\n\nvec3 NormEstimate(vec3 p) {\n    vec3 dp;\n    dp.x = Map(p + vec3(EPS, 0.0, 0.0)).dist - Map(p - vec3(EPS, 0.0, 0.0)).dist;\n    dp.y = Map(p + vec3(0.0, EPS, 0.0)).dist - Map(p - vec3(0.0, EPS, 0.0)).dist;\n    dp.z = Map(p + vec3(0.0, 0.0, EPS)).dist - Map(p - vec3(0.0, 0.0, EPS)).dist;\n    return normalize(dp);\n}       \n\nvec3 LightEffect(vec3 p, vec3 eye, Light light, vec3 k_a, vec3 k_d, vec3 k_s) \n{\n    vec3 N = NormEstimate(p);\n    vec3 L = normalize(light.pos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float len = length(light.pos - p);\n    \n    if (dot(L, N) < 0.0) {\n        return vec3(0.0);\n    } \n    if (dot(R, V) < 0.0) {\n        return 400.* light.power * (k_d * dot(L, N)) /len/len  + k_a/len;\n    }\n    return  400.* light.power * \n            (k_d * dot(L, N) + k_s * pow(dot(V, R), SHININESS)) /len/len + k_a/len;\n}\n\nfloat shadowSharp(vec3 p, vec3 rd, float dist)\n{\n    float t = 0.1;\n    for (int i = 0; i < SHADOW_STEPS; ++i)\n    {\n        float h = Map(p + rd * t ).dist;\n        if (h < EPS)\n            return 0.0;\n        t += h;\n        if (t > dist)\n            break;\n    }\n    return 1.0;\n}\n\nfloat shadowSoft(vec3 p, vec3 rd, float dist, float k)\n{\n    float t = 0.1;\n    float res = 1.0;\n    for ( int i = 0; i < SHADOW_STEPS; ++i )\n    {\n        float h = Map(p + rd * t ).dist;\n        if (h < EPS)\n            return 0.0;\n        res = min( res, k * h / t );\n        t += h;\n        if (t > dist)\n            break;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p, Light light, float shadepower, bool isSoftShadow)\n{\n    vec3 N = NormEstimate(p);\n    vec3 L = normalize(light.pos - p);\n    \n    float len = length(light.pos - p);\n    \n    float res = 0.1;\n    float type = shadowSoft(p, L, len, 8.0);\n\n    if (isSoftShadow == false) {\n        type = shadowSharp(p, L, len);\n    } \n    \n    if (type > 0.0) {\n        float behind = 1.0 * max( 0.0, dot(L, N));\n        float near = 1.0 - pow(min(1.0, len/shadepower), 2.0 );\n        res += behind * near * type;\n    }\n    return vec3(res);\n}\n\n\nvec3 Illumination(vec3 p, vec3 eye, vec3 k_a, vec3 k_d, vec3 k_s, bool isSoftShadow) \n{\n    vec3 color = vec3(0.0);\n    \n    Light light1, light2;\n    light1.pos = vec3(50.0, 70.0 + 20.0*cos(iTime), 10.0);\n    light1.power = vec3(12);\n    light2.pos = vec3(50.0 *sin(0.22*iTime), 15.0, 5.0 + 15.0 * cos(0.22*iTime));\n    light2.power = vec3(0.7);\n\n    color += vec3(0.5) * shade(p, light1, 100.0, isSoftShadow);\n    color += vec3(0.5) * shade(p, light2, 30.0, isSoftShadow);\n    color += LightEffect(p, eye, light1, k_a, k_d, k_s);\n    color += LightEffect(p, eye, light2, k_a, k_d, k_s);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 coord = fragCoord / iResolution.x - 0.5;\n\n    vec3 eye = vec3(0.0 + 10.*cos(0.3*t), 35.0, 75.0);\n    vec3 dir = normalize(vec3(coord.x, coord.y - 0.3, -1.0));\n    \n    if (texture(iChannel0, vec2(KEY_F, 0.75)).x > 0.) {\n        vec3 C = vec3(-8, 14.0, 0.0);\n        eye = vec3(-8.0, 15.0, -5.0);\n        dir = normalize(vec3(coord.x, coord.y - 0.07, 1.0));\n        t *= 0.2;\n        mat2 rmat = mat2(cos(t),sin(t),-sin(t),cos(t));\n        eye.xz = (eye.xz - C.xz) *rmat + C.xz;\n        dir.xz *= rmat;\n    }\n    \n    Figure f = RayMarching(eye, dir);\n    \n    if (f.dist > MAX_MARCH_DIST - EPS) {\n        fragColor = vec4(vec3(0.5, 0.7, 1.0), 1.0);\n        fragColor.r = fragCoord.y / iResolution.y;\n        return;\n    }\n    \n    vec3 p = eye + f.dist * dir;\n    \n    vec3 K_a = f.color;\n    vec3 K_d = f.color;\n    vec3 K_s;\n    if (f.color.r < 0.5) K_s = vec3(0.0);\n        else K_s = vec3(1.0);\n\n    bool isSoftShadow = true;\n    if (texture(iChannel0, vec2(KEY_T, 0.75)).x > 0.) {\n        isSoftShadow = false;\n    }\n\n    vec3 color = Illumination(p, eye, K_a, K_d, K_s, isSoftShadow);\n    fragColor = vec4(color, 1.0);\n}\n       ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}