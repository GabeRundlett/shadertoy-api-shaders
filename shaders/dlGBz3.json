{
    "Shader": {
        "info": {
            "date": "1704008103",
            "description": "Just practice.\nInspired by the first scene of \"EMIX by Epoch ft. Trio Tampere\" https://www.youtube.com/watch?v=SYG9zU_bd6U",
            "flags": 96,
            "hasliked": 0,
            "id": "dlGBz3",
            "likes": 11,
            "name": "amagi: Wobbly Tunnel",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "amagitakayosi",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "#define zoom(uv, x) ((uv - .5) * x + .5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Aberration\n    vec4 c = vec4(\n        texture(iChannel0, zoom(uv, 1.0)).r,\n        texture(iChannel0, zoom(uv, .985)).g,\n        texture(iChannel0, zoom(uv, .97)).b,\n        1.\n    );\n    \n    // Vignette\n    c -= pow(length(p), 2.) * .1;\n    // c.rgb *= mix(vec3(1), vec3(.1, .0, .7), pow(length(p), 2.) * .1);    \n\n    // colorize\n    c.r = smoothstep(-.1, 1., c.r);\n    c.b = smoothstep(.0, .6, c.b);    \n    \n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Wobbly Tunnel\n// Inspired by the first scene of \"EMIX by Epoch ft. Trio Tampere\" https://www.youtube.com/watch?v=SYG9zU_bd6U\n// \n// Music: \"Malta 6AM\" by NÃ¸rbak\n// https://soundcloud.com/hate_music/premiere-norbak-malta-6am-hysep49\n\n\n// Constants\n#define EPS 1e-3\n#define BPM 138.\n#define phase ((60. / BPM) * 4.)\n#define phaseCount 4.\n#define TIME_OFFSET 0.2\n    \n// Global vars\nfloat time;\nfloat modetime;\nfloat light;\nfloat lightK = 1.;\n\nmat2 rot(float t) {\n    float c = cos(t), s = sin(t);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdTunnel(vec3 p) {\n    float t = time;\n    p.xy *= .5;    \n    p.z -= time * .3;\n\n    p.xy *= 1. + (\n        cos((p.z * 7. + p.x + 7. + p.y * 5.) - t * 2.) *\n        cos((p.z * -2. + + p.x * 0.5 + p.y * -6.) - t * 2.) *\n        cos((p.z * 3. + + p.x * 2.1 + p.y * -3.7) - t * 1.3) *\n        cos((p.z * -.9 + + p.x * 1.7 + p.y * 8.7) - t * .9)  \n    ) * 0.2;\n    \n\n    return 1. - length(p.xy);    \n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    return length(vec2(length(p.xy) - r.y, p.z)) - r.x;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) - min(max(max(q.x, q.y), q.z), 0.);\n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLight(vec3 p) {\n    p.xy *= rot(sin(time * .7 + 2.) * 1.);\n    p.xz *= rot(time * 1.2 + 3.);\n\n    // mode change noise\n    float change = smoothstep(.07, 0., modetime / phase) + smoothstep(.93, 1., modetime / phase);        \n    p += vec3(\n        sin(p.y * 3.7 + iTime) * sin(p.y * 17. + iTime) * sin(p.y * 29. - iTime * .7),        \n        sin(p.x * 5.1 + iTime) * sin(p.y * 13. + iTime) * sin(p.y * 23. - iTime * .6),\n        0\n    ) * change;\n\n    float d;\n    float mode = floor(mod(time,  phase * phaseCount) / phase);\n    if (mode == 0.) {    \n        // Double ring\n        vec3 q = p;    \n        p.x += .23;\n        q.xy -= .1;\n        q.xy *= rot(5.);\n        q.xz *= rot(5. + sin(time + 2.) * .1);        \n        vec2 r =  vec2(0.001, .8);\n        d = min(sdTorus(p, r), sdTorus(q, r));\n    } else if (mode == 1.) {\n        // Cross\n        float x = 0.02 * (.3 + 1. * abs(sin(p.y)));\n        \n        p.x += .2;\n        d = sdBox(p, vec3(x, x, .8));\n        \n        p.xy -= .1;        \n        p.xy *= rot(1.);\n        d = min(d, sdBox(p, vec3(x, .9, x)));\n       \n        p.xy *= rot(3.);\n        d = min(d, sdBox(p, vec3(.4, x, x)));\n    } else if (mode == 2.) {\n        // Twist\n        p.xz *= rot(p.y * 1.2);    \n        float a = atan(p.y, p.x);\n        p.xy *= 1.1 + sin(a * 3.) * .2;\n        d = sdTorus(p, vec2(0.02, 1.));\n    } else {    \n        // spheres\n        float r = .3;\n        float r2 = .14;       \n        d = sdSphere(p + vec3(1) * r, r2);\n        d = min(d, sdSphere(p + vec3(1, -1, -1) * r, r2));        \n        d = min(d, sdSphere(p + vec3(-1, 1, -1) * r, r2));        \n        d = min(d, sdSphere(p + vec3(-1, -1, 1) * r, r2));                                             \n    }\n    \n    return d;\n}\n\nvec2 map(vec3 p) {\n    float d1 = sdTunnel(p);\n    \n    float d2 = sdLight(p);    \n    float glow = .015 / d2;\n    float wall = exp(d2 * -1.) * smoothstep(0., 2., length(p)) * .03; // add light for walls\n    light += (glow + wall) * .84;\n    \n    return d1 < d2 ? vec2(d1, 1) : vec2(d2, 2);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 d = vec2(0, 0.001);\n    return normalize(vec3(\n        (map(p + d.yxx) - map(p - d.yxx)).x,\n        (map(p + d.xyx) - map(p - d.xyx)).x,\n        (map(p + d.xxy) - map(p - d.xxy)).x\n    ));\n}\n\nfloat noise(float t) {\n    return sin(t * 3.) * sin (t  * 7.1) * sin(t * 19.3) * sin(t * 37.9);\n}\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(348., 481.))) *948.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;    \n    float l = length(p);\n    \n    p *= 1. + pow(l, 2.) * 0.2; // distort\n        \n    // update globals\n    time = iTime + TIME_OFFSET;\n    modetime = mod(time, phase);\n    lightK = .7 + noise(time) * 0.3;\n                \n    // bokeh\n    p += vec2(hash(p + time), hash(p + time + 2.)) * smoothstep(.4, 8., l) * 2.;\n                        \n    // camera wiggle\n    vec3 ro = vec3(0, 0, 2.2);    \n    ro.xy += vec2(\n        noise(time * .07 + 3.),     \n        noise(time * .03 + 7.)        \n    ) * .17;\n    \n    // define ray\n    vec3 rt = vec3(0);\n    vec3 cf = normalize(ro - rt);        \n    vec3 cu = vec3(0, 1, 0);\n    vec3 cr = cross(cf, cu);    \n    vec3 rd = normalize(p.x * cr + p.y * cu + -1. * cf);\n    \n    \n    vec3 rp;\n    float t, fi;\n    vec2 hit;\n   \n    \n    for (int i = 0; i < 99; i++) {\n        rp = ro + rd * t;\n        hit = map(rp);\n        \n        if (hit.x < EPS) {\n            fi = float(i);\n            break;\n        }\n        t += hit.x * .7;\n    }   \n\n    vec3 col;\n    vec3 ld = normalize(vec3(2,3,1));\n    vec3 ld2 = normalize(vec3(-1,-3,1));    \n    vec3 ld3 = normalize(vec3(-5,-2,0));\n    vec3 n = getNormal(rp);    \n    if (hit.y == 1.) {    \n        col += .8 * (\n            pow(max(0., dot(n, ld)), 110.) + \n            pow(max(0., dot(n, ld2)), 210.) +\n            pow(max(0., dot(n, ld3)), 310.)              \n        ) * lightK;        \n        col *= 0.;\n        \n        vec3 ldd = normalize(-rp);\n        \n        col += .3 * pow(max(0., dot(n, ldd)), 300.) * lightK; // diffuse\n        col += .5 * pow(max(0., dot(n, normalize(ldd - rd))), 30.) * lightK; // specular\n        \n        col += .3; // amb\n                \n        col += light * lightK;\n        col -= .003 * fi; // AO\n        col -= .2 * pow(t, .7);  // dark fog\n    } else if (hit.y == 2.) {\n        col += lightK * 2.;\n    }    \n\n    // it didn't make the look better...\n    // col = pow(col, vec3(.4545));\n\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 35603,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/hate_music/premiere-norbak-malta-6am-hysep49"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}