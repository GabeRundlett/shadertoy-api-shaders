{
    "Shader": {
        "info": {
            "date": "1593278130",
            "description": "First attempt at a water effect.\nStarted off making a 'day time' scene, but by happy accident made a 'night scene' instead!",
            "flags": 0,
            "hasliked": 0,
            "id": "WtlcWX",
            "likes": 16,
            "name": "Moon and Sea",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sea",
                "water",
                "moon"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "// Processed by 'GLSL Shader Shrinker' (2,112 to 1,707 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nfloat sdWaves(vec3 p) {\n\tfloat t,\n\t      h = 0.,\n\t      a = 1.,\n\t      f = 1.1;\n\tmat2 r = rot(3.7692);\n\tt = iTime / -3.;\n\tfor (float i = 0.; i < 6.; i++) {\n\t\tp.xz *= r;\n\t\th += 1. - abs(sin(f * ((p.x + sin(p.z * a)) + t))) * a;\n\t\ta /= 1.97;\n\t\tf *= 2.02;\n\t\tt *= -.95;\n\t}\n\n\treturn p.y - h / 7.;\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst vec2 e = vec2(1, -1) * .0005;\n\treturn normalize(e.xyy * sdWaves(p + e.xyy) + e.yyx * sdWaves(p + e.yyx) + e.yxy * sdWaves(p + e.yxy) + e.xxx * sdWaves(p + e.xxx));\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n\tvec3 rd = normalize(lightPos - p);\n\tfloat h,\n\t      minH = 1.,\n\t      d = .1;\n\tfor (int i = 0; i < 16; i++) {\n\t\th = sdWaves(p + rd * d);\n\t\tminH = abs(h / d);\n\t\tif (minH < .01) return 0.;\n\t\td += h;\n\t}\n\n\treturn minH * sharpness;\n}\n\nfloat glow = 0.;\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col;\n\t{\n\t\tvec3 p,\n\t\t     rd = getRayDir(vec3(0, 1.5, -10), vec3(0), uv);\n\t\tbool hit = false;\n\t\tfloat d = .01;\n\t\tfor (float steps = 0.; steps < 128.; steps++) {\n\t\t\tp = vec3(0, 1.5, -10) + rd * d;\n\t\t\tfloat h = sdWaves(p),\n\t\t\t      dd = length(p - vec3(.1, 2, -2));\n\t\t\tglow += .1 / (.1 + dd * dd * 5.);\n\t\t\tif (dd < h) h = dd;\n\t\t\tif (h < .005 * d) {\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td += h;\n\t\t}\n\n\t\tif (hit) {\n\t\t\tvec3 n = calcNormal(p),\n\t\t\t     lightToPoint = normalize(vec3(4, 20, 10) - p);\n\t\t\tfloat sha = calcShadow(p, vec3(4, 20, 10), 5.),\n\t\t\t      mainLight = max(0., dot(n, lightToPoint)),\n\t\t\t      fog = 1. - exp(-d * .02);\n\t\t\tcol = mix((mainLight * sha + 2.) * vec3(1, .9, .8), vec3(.15, .2, .25), (1. - .98 * max(0., dot(rd, n))));\n\t\t\tcol *= vec3(.2, .32, .41);\n\t\t\tcol = mix(col, vec3(.15, .2, .25), fog);\n\t\t}\n\t\telse col = vec3(.15, .2, .25);\n\t}\n\tfragColor = vec4(pow(vignette(clamp(col + max(0., glow), 0., 1.), fragCoord), vec3(.4545)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}