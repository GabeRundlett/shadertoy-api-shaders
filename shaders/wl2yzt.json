{
    "Shader": {
        "info": {
            "date": "1595152447",
            "description": "License CC0: Flying through psychedelic mist\nMessing around with colors and FBM. \nSet BPM to some value that match your music.",
            "flags": 0,
            "hasliked": 0,
            "id": "wl2yzt",
            "likes": 39,
            "name": "Flying through psychedelic mist",
            "published": 3,
            "tags": [
                "2d",
                "fbm",
                "colorful"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 1429
        },
        "renderpass": [
            {
                "code": "// License CC0: Flying through psychedelic mist\n// Messing around with colors and FBM. \n\n// Set BPM to some value that match your music.\n#define BPM             30.0\n\n#define GAMMAWEIRDNESS\n#define QUINTIC\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rotSome          = MROT(1.0);\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#ifdef QUINTIC\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nvec3 alphaBlendGamma(vec3 back, vec4 front, vec3 gamma) {\n  vec3 colb = max(back.xyz, 0.0);\n  vec3 colf = max(front.xyz, 0.0);;\n  \n  colb = pow(colb, gamma);\n  colf = pow(colf, gamma);\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return pow(xyz, 1.0/gamma);\n}\n\nvec3 offset_0(float z) {\n  float a = z;\n  vec2 p = vec2(0.0);\n  return vec3(p, z);\n}\n\nvec3 offset_1(float z) {\n  float a = z/3.0;\n  vec2 p = -2.0*0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 offset(float z) {\n  return offset_1(z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return mix(1.5*vec3(0.75, 0.75, 1.0), vec3(0.0), length(2.0*rd.xy));\n}\n\nfloat height(vec2 p, float n, out vec2 diff) {\n  const float aan = 0.45;\n  const float ppn = 2.0+0.2;\n  \n  float s = 0.0;\n  float d = 0.0;\n  float an = 1.0;\n  vec2 pn = 4.0*p+n*10.0;\n  vec2 opn = pn;\n\n  const int md = 1;\n  const int mx = 4;\n  \n  for (int i = 0; i < md; ++i) {\n    s += an*(vnoise(pn)); \n    d += abs(an);\n    pn *= ppn*rotSome;\n    an *= aan; \n  }\n\n  for (int i = md; i < mx; ++i) {\n    s += an*(vnoise(pn)); \n    d += abs(an);\n    pn *= ppn*rotSome;\n    an *= aan; \n    pn += (3.0*float(i+1))*s-TIME*5.5;     // Fake warp FBM\n  }\n\n  s /= d;\n\n  diff = (pn - opn);\n\n  return s;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float aa, float n) {\n  vec2 p = pp.xy;\n  float z = pp.z;\n  float nz = pp.z-ro.z;\n  \n  vec2 diff;\n  vec2 hp = p;\n  hp -= nz*0.125*0.5*vec2(1.0, -0.5);\n  hp -= n;\n  float h = height(hp, n, diff);\n  float gh = (vnoise(0.25*(p+vec2(n))));\n  h *= mix(0.75, 1.0, gh);\n  h = abs(h);\n  \n  vec3 col = vec3(0.0);\n  col = vec3(h);\n  float huen = (length(diff)/200.0);\n  float satn = 1.0;\n  float brin = h;\n  col = hsv2rgb(vec3(huen, satn, brin));\n  \n  float t = sqrt(h)*(smoothstep(0.0, 0.5, length(pp - ro)))*smoothstep(0.0, mix(0.4, 0.75, pow(psin(TIME*TAU*BPM/60.0), 4.0)), length(p));\n  return vec4(col, t);\n}\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n//  vec3 rd = normalize(p.x*uu + p.y*vv + (3.00-1.0*tanh(lp))*ww);\n  vec3 rd = normalize(p.x*uu + p.y*vv + (2.00+tanh(lp))*ww);\n\n  float planeDist = 1.0-0.25;\n  const int furthest = 6;\n  const int fadeFrom = furthest-4;\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);  \n  \n  vec3 col = skyCol;\n\n  for (int i = furthest; i >= 1 ; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n    \n    float pd = (pz - ro.z)/rd.z;\n    \n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n   \n      float aa = length(dFdy(pp));\n\n      vec4 pcol = plane(ro, rd, pp, aa, nz+float(i));\n      float nz = pp.z-ro.z;\n      float fadeIn = (1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), nz));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      vec3 gamma = std_gamma;\n#ifdef GAMMAWEIRDNESS\n      float ga = pp.z;\n      vec3 gg = vec3(psin(ga), psin(ga*sqrt(0.5)), psin(ga*2.0));\n      gamma *= mix(vec3(0.1), vec3(10.0), gg);\n#endif\n      col = alphaBlendGamma(col, pcol, gamma);\n    } else {\n      break;\n    }\n    \n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm = TIME;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}