{
    "Shader": {
        "info": {
            "date": "1542207802",
            "description": "raymarching concentric rings",
            "flags": 0,
            "hasliked": 0,
            "id": "llyfDR",
            "likes": 0,
            "name": "concentric rings",
            "published": 3,
            "tags": [
                "raymarching",
                "rings"
            ],
            "usePreview": 0,
            "username": "anneka",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "#define repeat(p,r) (mod(p,r)-r/2.)\n#define PI 3.14159265358979323846\n\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1./freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\nvec3 eye() {\n    return vec3(sin(iTime)*.2, .5, 2.);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nmat2 rotation(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdf(vec3 pos) {\n    float scene = 100.;\n    vec3 eye = eye();\n    pos.x += .25;\n    //pos.xz *= rotation(iTime*.1);\n    //\n    pos.yz *= rotation(iTime*.1);\n    vec3 p = pos;\n    vec3 r = pos;\n    \n    //p = repeat(pos, 1.);\n    vec2 t = vec2(.2, .05);\n    vec2 c = vec2(0.25, .25);\n    \n    //scene = sdTorus(p, t);\n   \n   \t//scene = min(scene, sdTriPrism(pos, c));\n    \n    //scene = min(scene, sdBox(p, vec3(.4)));\n    //scene = max(length(p.xy)-.1, abs(p.y-.5));\n    \n    //scene = min(scene, p.y);\n    \n    \n    //scene = sdBox(p, vec3(.4));\n    \n    const float count = 6.;\n    \n    for (float i = count; i > 0.; --i) {\n        float ratio = i / count;\n        p = abs(p) - .2*ratio;\n        p.xz *= rotation(iTime);\n        p.yz *= rotation(1.14);\n        scene = min(scene, max(p.x,max(p.y,p.z)));\n        //scene = min(scene, length(p.xz)-.05*ratio);\n        scene = min(scene, sdTorus(p,t*ratio));\n        //scene = min(scene, max(length(p.xz)-0.5, abs(p.y)-.5));\n    }\n    \n    scene = max(-scene, sdTorus(pos, vec2(.5,.1)));\n    \n    r.xz *= rotation((iTime*.1) - .5);\n    r.yz *= rotation((iTime*.1) - .5);\n    \n    //scene = max(scene, sdTorus(r, vec2(.5,.1))); \n    \n    scene = max(scene, -sdSphere(eye-pos, .5));\n    return scene;\n}\n\nfloat sdf2(vec3 pos) {\n    float scene = 100.;\n    vec3 eye = eye();\n    pos.x -= .25;\n    //pos.xz *= rotation((iTime*-.1)-1.);\n    pos.yz *= rotation((iTime*.1)-1.);\n    vec3 p = pos;\n    vec3 r = pos;\n    \n    //p = repeat(pos, 1.);\n    vec2 t = vec2(.2, .05);\n    vec2 c = vec2(0.25, .25);\n    \n    //scene = sdTorus(p, t);\n   \n   \t//scene = min(scene, sdTriPrism(pos, c));\n    \n    //scene = min(scene, sdBox(p, vec3(.4)));\n    //scene = max(length(p.xy)-.1, abs(p.y-.5));\n    \n    //scene = min(scene, p.y);\n    \n    \n    //scene = sdBox(p, vec3(.4));\n    \n    const float count = 6.;\n    \n    for (float i = count; i > 0.; --i) {\n        float ratio = i / count;\n        p = abs(p) - .2*ratio;\n        p.xz *= rotation(iTime);\n        p.yz *= rotation(-1.14);\n        scene = min(scene, max(p.x,max(p.y,p.z)));\n        //scene = min(scene, length(p.xz)-.05*ratio);\n        scene = min(scene, sdTorus(p,t/ratio*4.));\n        //scene = min(scene, max(length(p.xz)-0.5, abs(p.y)-.5));\n    }\n    \n    scene = max(-scene, sdTorus(pos, vec2(.5,.1)));\n    \n    r.xz *= rotation((iTime*.1) - .5);\n    r.yz *= rotation((iTime*.1) - .5);\n    \n    //scene = max(scene, sdTorus(r, vec2(.5,.1))); \n    \n    scene = max(scene, -sdSphere(eye-pos, .5));\n    return scene;\n}\n\nvec3 lookAt (vec3 from, vec3 target, vec2 uv) {\n    vec3 forward = normalize(target - from);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward * .75 + uv.x * right + uv.y * up);\n}\n\nvec3 getNormal(vec3 pos) {\n    vec2 e = vec2(.001, 0.);\n    return normalize(vec3(\n        sdf(pos + e.xyy)-sdf(pos-e.xyy),\n        sdf(pos + e.yxy)-sdf(pos-e.yxy),\n        sdf(pos + e.yyx)-sdf(pos-e.yyx)\n    ));\n}\n\nvec3 getNormal2(vec3 pos) {\n    vec2 e = vec2(.001, 0.);\n    return normalize(vec3(\n        sdf2(pos + e.xyy)-sdf2(pos-e.xyy),\n        sdf2(pos + e.yxy)-sdf2(pos-e.yxy),\n        sdf2(pos + e.yyx)-sdf2(pos-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv-.5) / 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 color = vec4(0.);\n \n    float shade = 0.;\n    float shade2 = 0.;\n    float distTotal = 0.;\n    \n    // vec3 eye = vec3(1, .5, 2);\n    vec3 eye = eye();\n    // vec3 target = vec3(sin(iTime) * 8.0, sin(iTime) * 8.0, 0.);\n    vec3 target = vec3(0);\n\n    // vec3 ray = normalize(vec3(uv, 1.));\n    vec3 ray = lookAt(eye, target, uv);\n    const float count = 200.;\n    \n    for (float i = count; i > 0.; --i) {\n        \n        // float dist = length(eye) - .5; // Sphere\n        \n        float dist1 = sdf(eye);\n        float dist2 = sdf2(eye);\n        \n        //float dist = dist1 * dist2;\n        \n        if (dist1 < .001) {\n            shade = i/count;\n            break;\n        }\n        \n        if (dist2 < .001) {\n            shade2 = i/count;\n            break;\n        }\n        \n        float newDist;\n        \n        if (dist1 < dist2) {\n            newDist = dist1;\n        } else {\n            newDist = dist2;\n        }\n        \n        eye += ray * newDist;\n        distTotal += newDist;\n    }\n    \n    color = vec4(0., 0., 0, 1.) + (vec4(vec3(pow(shade,4.)), 1) - vec4(vec3(pow(shade2,2.)), 1) + vec4(vec3(pow(1.-shade,4.)), 1));\n    color = mix(color, vec4(.5, .5, .5,1), smoothstep(2., 20., distTotal));\n    vec3 normal = getNormal(eye);\n    vec3 normal2 = getNormal2(eye);\n    \n    vec3 lightColor1 = vec3(1,0,0);\n    vec3 lightColor2 = vec3(1,1,1);\n    vec3 lightDir1 = normalize(vec3(1, 1, 1));\n    vec3 lightDir2 = normalize(vec3(0, -1, 0));\n    //color.rbg = lightColor1 * clamp(dot(normal, lightDir1), 0., 1.);\n    \n    // float colorShader = sin(iTime*.1);\n    \n    //color.rgb = mix(color.rgb,lightColor2 * clamp(pow(dot(normal, lightDir2), 32.), 0., 1.), colorShader);\n    //color.rgb += mix(color.rgb,lightColor2 * clamp(pow(dot(normal2, lightDir2), 32.), 0., 1.), 1. - colorShader);\n    \n    \n    //color.rbg = lightColor1 * clamp(dot(normal2, lightDir1), 0., 1.);\n    //color.rgb += lightColor2 * clamp(dot(normal2, lightDir2), 0., 1.);\n    \n    //color.rbg = normal*.5+.5;\n    \n    //color.rgb += vec3(noise(uv*100.));\n    \n    //color.rgb += vec3(pNoise(repeat(uv, .1), 100));\n    color.rgb += rand(uv+vec2(iTime*.00001))*.075;\n    //color.rgb -= 1.-vec3(length(uv)*10.);\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}