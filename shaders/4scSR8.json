{
    "Shader": {
        "info": {
            "date": "1457919629",
            "description": "Fork of @TimothyLottes' FixingPixelArt https://www.shadertoy.com/view/XsjSzR",
            "flags": 32,
            "hasliked": 0,
            "id": "4scSR8",
            "likes": 30,
            "name": "capnslipp - FixingPixelArt",
            "published": 3,
            "tags": [
                "scanlines",
                "crt",
                "postprocess",
                "fork",
                "pixelart",
                "shadowmask"
            ],
            "usePreview": 0,
            "username": "capnslipp",
            "viewed": 4210
        },
        "renderpass": [
            {
                "code": "//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//\t by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n#define RGBA(r, g, b, a)\tvec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, float(a)/255.0)\n\nconst vec3 kBackgroundColor = RGBA(0x00, 0x60, 0xb8, 0xff).rgb; // medium-blue sky\n//const vec3 kBackgroundColor = RGBA(0xff, 0x00, 0xff, 0xff).rgb; // test magenta\n\n// Emulated input resolution.\n#if 1\n\t// Fix resolution to set amount.\n\t// Note: 256x224 is the most common resolution of the SNES, and that of Super Mario World.\n\tvec2 res = vec2(\n\t\t256.0 / 1.0,\n\t\t224.0 / 1.0\n\t);\n#else\n\t// Optimize for resize.\n\tvec2 res = iResolution.xy / 6.0;\n#endif\n\n// Hardness of scanline.\n//\t-8.0 = soft\n// -16.0 = medium\nfloat sHardScan = -8.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nconst float kHardPix = -3.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0 / 8.0 = extreme\nconst vec2 kWarp = vec2(1.0 / 32.0, 1.0 / 24.0);\n//const vec2 kWarp = vec2(0);\n\n// Amount of shadow mask.\nfloat kMaskDark = 0.5;\nfloat kMaskLight = 1.5;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat toLinear1(float c) {\n\treturn (c <= 0.04045) ?\n\t\t(c / 12.92) :\n\t\tpow((c + 0.055) / 1.055, 2.4);\n}\nvec3 toLinear(vec3 c) {\n\treturn vec3(toLinear1(c.r), toLinear1(c.g), toLinear1(c.b));\n}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat toSrgb1(float c) {\n\treturn(c < 0.0031308 ?\n\t\t(c * 12.92) :\n\t\t(1.055 * pow(c, 0.41666) - 0.055));\n}\nvec3 toSrgb(vec3 c) {\n\treturn vec3(toSrgb1(c.r), toSrgb1(c.g), toSrgb1(c.b));\n}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec4 fetch(vec2 pos, vec2 off)\n{\n\tpos = floor(pos * res + off) / res;\n\tif (max(abs(pos.x - 0.5), abs(pos.y - 0.5)) > 0.5)\n\t\treturn vec4(vec3(0.0), 0.0);\n   \t\n    vec4 sampledColor = texture(iChannel0, pos.xy, -16.0);\n    \n    sampledColor = vec4(\n        (sampledColor.rgb * sampledColor.a) +\n        \t(kBackgroundColor * (1.0 - sampledColor.a)),\n        1.0\n    );\n    \n\treturn vec4(\n        toLinear(sampledColor.rgb),\n        sampledColor.a\n    );\n}\n\n// Distance in emulated pixels to nearest texel.\nvec2 dist(vec2 pos) {\n\tpos = pos * res;\n\treturn -((pos - floor(pos)) - vec2(0.5));\n}\n\n// 1D Gaussian.\nfloat gaus(float pos, float scale) {\n\treturn exp2(scale * pos * pos);\n}\n\n// 3-tap Gaussian filter along horz line.\nvec3 horz3(vec2 pos, float off)\n{\n\tvec3 b = fetch(pos, vec2(-1.0, off)).rgb;\n\tvec3 c = fetch(pos, vec2( 0.0, off)).rgb;\n\tvec3 d = fetch(pos, vec2(+1.0, off)).rgb;\n\tfloat dst = dist(pos).x;\n\t// Convert distance to weight.\n\tfloat scale = kHardPix;\n\tfloat wb = gaus(dst - 1.0, scale);\n\tfloat wc = gaus(dst + 0.0, scale);\n\tfloat wd = gaus(dst + 1.0, scale);\n\t// Return filtered sample.\n\treturn (b * wb + c * wc + d * wd) / (wb + wc + wd);\n}\n\n// 5-tap Gaussian filter along horz line.\nvec3 horz5(vec2 pos, float off)\n{\n\tvec3 a = fetch(pos, vec2(-2.0, off)).rgb;\n\tvec3 b = fetch(pos, vec2(-1.0, off)).rgb;\n\tvec3 c = fetch(pos, vec2( 0.0, off)).rgb;\n\tvec3 d = fetch(pos, vec2(+1.0, off)).rgb;\n\tvec3 e = fetch(pos, vec2(+2.0, off)).rgb;\n\tfloat dst = dist(pos).x;\n\t// Convert distance to weight.\n\tfloat scale = kHardPix;\n\tfloat wa = gaus(dst - 2.0, scale);\n\tfloat wb = gaus(dst - 1.0, scale);\n\tfloat wc = gaus(dst + 0.0, scale);\n\tfloat wd = gaus(dst + 1.0, scale);\n\tfloat we = gaus(dst + 2.0, scale);\n\t// Return filtered sample.\n\treturn (a * wa + b * wb + c * wc + d * wd + e * we) / (wa + wb + wc + wd + we);\n}\n\n// Return scanline weight.\nfloat scan(vec2 pos, float off) {\n\tfloat dst = dist(pos).y;\n\treturn gaus(dst + off, sHardScan);\n}\n\n// Allow nearest three lines to effect pixel.\nvec3 tri(vec2 pos)\n{\n\tvec3 a = horz3(pos, -1.0);\n\tvec3 b = horz5(pos,  0.0);\n\tvec3 c = horz3(pos, +1.0);\n\tfloat wa = scan(pos, -1.0);\n\tfloat wb = scan(pos,  0.0);\n\tfloat wc = scan(pos, +1.0);\n\treturn a * wa + b * wb + c * wc;}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 warp(vec2 pos)\n{\n\tpos = pos * 2.0 - 1.0;\n\tpos *= vec2(\n\t\t1.0 + (pos.y * pos.y) * kWarp.x,\n\t\t1.0 + (pos.x * pos.x) * kWarp.y\n\t);\n\treturn pos * 0.5 + 0.5;\n}\n\n// Shadow mask.\nvec3 mask(vec2 pos)\n{\n\tpos.x += pos.y * 3.0;\n\tvec3 mask = vec3(kMaskDark, kMaskDark, kMaskDark);\n\tpos.x = fract(pos.x / 6.0);\n\tif (pos.x < 0.333)\n\t\tmask.r = kMaskLight;\n\telse if (pos.x < 0.666)\n\t\tmask.g = kMaskLight;\n\telse\n\t\tmask.b = kMaskLight;\n\treturn mask;\n}\n\n// Draw dividing bars.\nfloat bar(float pos, float bar) {\n\tpos -= bar;\n\treturn (pos * pos < 4.0) ? 0.0 : 1.0;\n}\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Entry.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = warp(fragCoord.xy / iResolution.xy);\n    vec4 unmodifiedColor = fetch(pos, vec2(0));\n    \n\t// Unmodified.\n\tif (fragCoord.x < iResolution.x * 0.333)\n\t{\n\t\tfragColor.rgb = unmodifiedColor.rgb;\n\t}\n\telse\n\t{\n\t\tif (fragCoord.x < iResolution.x * 0.666) {\n\t\t\tsHardScan = -12.0;\n\t\t\tkMaskDark = kMaskLight = 1.0;\n\t\t}\n\t\tfragColor.rgb = tri(pos) * mask(fragCoord.xy);\n\t}\n\t//fragColor.rgb *=\n\t//\tbar(fragCoord.x, iResolution.x * 0.333) *\n\t//\tbar(fragCoord.x, iResolution.x * 0.666);\n\tfragColor = vec4(\n        toSrgb(fragColor.rgb),\n        1.0\n    );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hard-coded texture\n\n\nvec2 round2(vec2 value) {\n    return floor(value + 0.5);\n}\n\n#define RGBA(r, g, b, a)\tvec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, float(a)/255.0)\nstruct ImageDataRow_w16 {\n\tint p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,\n\t\tp10, p11, p12, p13, p14, p15;\n};\nint getPixelFromImageDataRow(ImageDataRow_w16 row, int i) {\n\tif (i == 0) return row.p0;\n\tif (i == 1) return row.p1;\n\tif (i == 2) return row.p2;\n\tif (i == 3) return row.p3;\n\tif (i == 4) return row.p4;\n\tif (i == 5) return row.p5;\n\tif (i == 6) return row.p6;\n\tif (i == 7) return row.p7;\n\tif (i == 8) return row.p8;\n\tif (i == 9) return row.p9;\n\tif (i == 10) return row.p10;\n\tif (i == 11) return row.p11;\n\tif (i == 12) return row.p12;\n\tif (i == 13) return row.p13;\n\tif (i == 14) return row.p14;\n\tif (i == 15) return row.p15;\n\treturn -1;\n}\nstruct ImageData_16x28 {\n\tImageDataRow_w16 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,\n\t\tr10, r11, r12, r13, r14, r15, r16, r17, r18, r19,\n\t\tr20, r21, r22, r23, r24, r25, r26, r27;\n};\nImageDataRow_w16 getRowFromImageData(ImageData_16x28 data, int i) {\n\tif (i == 0) return data.r0;\n\tif (i == 1) return data.r1;\n\tif (i == 2) return data.r2;\n\tif (i == 3) return data.r3;\n\tif (i == 4) return data.r4;\n\tif (i == 5) return data.r5;\n\tif (i == 6) return data.r6;\n\tif (i == 7) return data.r7;\n\tif (i == 8) return data.r8;\n\tif (i == 9) return data.r9;\n\tif (i == 10) return data.r10;\n\tif (i == 11) return data.r11;\n\tif (i == 12) return data.r12;\n\tif (i == 13) return data.r13;\n\tif (i == 14) return data.r14;\n\tif (i == 15) return data.r15;\n\tif (i == 16) return data.r16;\n\tif (i == 17) return data.r17;\n\tif (i == 18) return data.r18;\n\tif (i == 19) return data.r19;\n\tif (i == 20) return data.r20;\n\tif (i == 21) return data.r21;\n\tif (i == 22) return data.r22;\n\tif (i == 23) return data.r23;\n\tif (i == 24) return data.r24;\n\tif (i == 25) return data.r25;\n\tif (i == 26) return data.r26;\n\tif (i == 27) return data.r27;\n\treturn ImageDataRow_w16( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 );\n}\nstruct PaletteData_13 {\n\tvec4 c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n\t\tc10, c11, c12;\n};\nvec4 getColorFromPaletteData(PaletteData_13 palette, int i) {\n\tif (i == 0) return palette.c0;\n\tif (i == 1) return palette.c1;\n\tif (i == 2) return palette.c2;\n\tif (i == 3) return palette.c3;\n\tif (i == 4) return palette.c4;\n\tif (i == 5) return palette.c5;\n\tif (i == 6) return palette.c6;\n\tif (i == 7) return palette.c7;\n\tif (i == 8) return palette.c8;\n\tif (i == 9) return palette.c9;\n\tif (i == 10) return palette.c10;\n\tif (i == 11) return palette.c11;\n\tif (i == 12) return palette.c12;\n\treturn vec4(0.0);\n}\n\nconst ImageData_16x28 kMarioImage = ImageData_16x28(\n\tImageDataRow_w16(\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t-1,\t10,\t10,\t10,\t10,\t-1,\t-1,\t-1,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t12,\t12,\t-1,\t12,\t12,\t10,\t0,\t7,\t6,\t0,\t10,\t10,\t-1,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t12,\t2,\t12,\t2,\t12,\t0,\t7,\t2,\t2,\t7,\t0,\t1,\t10,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t12,\t2,\t2,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t0,\t1,\t10,\t-1\t),\n\tImageDataRow_w16(\t-1,\t12,\t12,\t12,\t2,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t1,\t10,\t-1\t),\n\tImageDataRow_w16(\t12,\t2,\t2,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t10,\t-1\t),\n\tImageDataRow_w16(\t12,\t2,\t12,\t2,\t2,\t12,\t2,\t2,\t11,\t11,\t2,\t2,\t12,\t12,\t10,\t-1\t),\n\tImageDataRow_w16(\t12,\t12,\t12,\t12,\t2,\t12,\t2,\t12,\t9,\t9,\t12,\t2,\t9,\t11,\t12,\t11\t),\n\tImageDataRow_w16(\t12,\t2,\t2,\t2,\t2,\t12,\t2,\t12,\t9,\t9,\t12,\t2,\t9,\t9,\t12,\t11\t),\n\tImageDataRow_w16(\t-1,\t10,\t10,\t10,\t10,\t9,\t11,\t9,\t9,\t9,\t9,\t11,\t9,\t12,\t12,\t11\t),\n\tImageDataRow_w16(\t-1,\t10,\t0,\t1,\t10,\t12,\t12,\t11,\t11,\t11,\t11,\t12,\t12,\t9,\t12,\t11\t),\n\tImageDataRow_w16(\t-1,\t10,\t0,\t1,\t10,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t12,\t9,\t8,\t-1\t),\n\tImageDataRow_w16(\t-1,\t10,\t0,\t1,\t10,\t9,\t12,\t12,\t12,\t12,\t12,\t12,\t9,\t8,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t10,\t0,\t1,\t1,\t10,\t11,\t11,\t11,\t11,\t11,\t8,\t8,\t-1,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t10,\t0,\t1,\t8,\t8,\t8,\t8,\t8,\t8,\t0,\t10,\t-1,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t10,\t0,\t0,\t0,\t4,\t4,\t1,\t1,\t4,\t4,\t0,\t10,\t-1,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t10,\t1,\t0,\t0,\t4,\t5,\t10,\t10,\t5,\t4,\t1,\t12,\t12,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t-1,\t1,\t3,\t4,\t5,\t5,\t5,\t5,\t5,\t5,\t4,\t2,\t2,\t12\t),\n\tImageDataRow_w16(\t-1,\t-1,\t-1,\t3,\t5,\t2,\t2,\t5,\t5,\t5,\t5,\t2,\t2,\t3,\t2,\t12\t),\n\tImageDataRow_w16(\t-1,\t-1,\t-1,\t3,\t5,\t2,\t2,\t5,\t5,\t5,\t5,\t2,\t2,\t3,\t2,\t12\t),\n\tImageDataRow_w16(\t-1,\t-1,\t-1,\t3,\t5,\t5,\t5,\t5,\t5,\t5,\t5,\t5,\t4,\t3,\t12,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t3,\t4,\t5,\t5,\t5,\t4,\t4,\t4,\t4,\t5,\t5,\t4,\t3,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t3,\t4,\t5,\t5,\t4,\t3,\t3,\t3,\t3,\t4,\t5,\t4,\t3,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t3,\t4,\t4,\t4,\t3,\t-1,\t-1,\t-1,\t3,\t4,\t4,\t4,\t3,\t-1\t),\n\tImageDataRow_w16(\t-1,\t-1,\t3,\t3,\t3,\t3,\t-1,\t-1,\t-1,\t-1,\t3,\t3,\t3,\t3,\t3,\t-1\t),\n\tImageDataRow_w16(\t-1,\t12,\t8,\t8,\t8,\t12,\t-1,\t-1,\t-1,\t-1,\t12,\t8,\t8,\t8,\t12,\t-1\t),\n\tImageDataRow_w16(\t12,\t9,\t8,\t8,\t8,\t12,\t-1,\t-1,\t-1,\t-1,\t12,\t8,\t8,\t8,\t9,\t12\t),\n\tImageDataRow_w16(\t12,\t12,\t12,\t12,\t12,\t12,\t-1,\t-1,\t-1,\t-1,\t12,\t12,\t12,\t12,\t12,\t12\t)\n);\nconst PaletteData_13 kMarioPalette = PaletteData_13(\n\tRGBA(0xFF,0x40,0x70,0xFF), // pink\n\tRGBA(0xB0,0x28,0x60,0xFF), // magenta\n\tRGBA(0xFF,0xF8,0xFF,0xFF), // white\n\tRGBA(0x20,0x30,0x8F,0xFF), // blue\n\tRGBA(0x40,0x80,0x9F,0xFF), // teal\n\tRGBA(0x80,0xD8,0xCF,0xFF), // light teal\n\tRGBA(0xFF,0xD8,0x70,0xFF), // yellow\n\tRGBA(0xDF,0xA0,0x3F,0xFF), // golden\n\tRGBA(0x8F,0x58,0x1F,0xFF), // brown\n\tRGBA(0xFF,0xD0,0xC0,0xFF), // flesh-tone\n\tRGBA(0x50,0x00,0x00,0xFF), // burgundy\n\tRGBA(0xFF,0x70,0x6F,0xFF), // peach (shaded flesh-tone)\n\tRGBA(0x00,0x00,0x00,0xFF) // black\n);\nconst vec2 kMarioSize = vec2(16, 28);\nconst vec2 kMarioPadding = vec2(2);\nconst vec2 kScreenOffset = vec2(+1);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    coord.y = 1.0 - coord.y;\n    \n    vec2 marioDrawSize = kMarioSize + kMarioPadding;\n    \n    float marioAspectRatio = marioDrawSize.x / marioDrawSize.y;\n    float screenAspectRatio = iResolution.x / iResolution.y;\n    if (screenAspectRatio > marioAspectRatio) {\n        float xCorrection = marioAspectRatio / screenAspectRatio;\n        coord.x = mod(coord.x, xCorrection) / xCorrection;\n    }\n    else if (screenAspectRatio < marioAspectRatio) {\n        float yCorrection = screenAspectRatio / marioAspectRatio;\n        coord.y = mod(coord.y, yCorrection) / yCorrection;\n    }\n    \n\tivec2 iCoord = ivec2(round2(\n        coord * marioDrawSize - kScreenOffset - vec2(0.5)\n    ));\n\tint paletteIndex = getPixelFromImageDataRow(getRowFromImageData(kMarioImage, iCoord.y), iCoord.x); \n    fragColor = getColorFromPaletteData(kMarioPalette, paletteIndex);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}