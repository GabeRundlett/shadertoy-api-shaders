{
    "Shader": {
        "info": {
            "date": "1524030611",
            "description": "Featuring improved spectrogram logic, and hack to obtain sample-perfect synth (no mainSound of floating point!)",
            "flags": 40,
            "hasliked": 0,
            "id": "ldcBRH",
            "likes": 5,
            "name": "Sequencing 2018-04-17",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "sampleprecise"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 731
        },
        "renderpass": [
            {
                "code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\n//#define POLAR\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  int shift = int(fsf.x*timescale*(iTime))+1;\n\n  int rshift = 0;\n  rshift = (shift)%fs.x;\n  f = texelFetch(iChannel0, ivec2((d.x+rshift)%fs.x,d.y), 0);\n  f = clamp(f,0.,2.);\n  f*=1.-exp(-2.*(-0.05+float((fs.x+d.x-(shift-rshift)%fs.x)%fs.x)/float(fs.x)));\n#ifdef POLAR\n  vec2 uv = (df-0.5*iResolution.xy)/iResolution.y*2.;\n  float r = length(uv);\n  float a = atan(uv.y, uv.x);\n  f = texture(iChannel0, vec2(a/6.2832+0.5, r));\n  if (r>1.) f*=0.;\n#endif\n  if (d.x<80) f = vec4(0.);\n  if (d.x<20) {\n    f = texelFetch(iChannel0, ivec2((shift-1)%fs.x,d.y), 0);\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nSequencing 2018-04-17\nCopyright 2018 Theron Tarigo\n*/\n\nconst float pi = 3.141592653589793;\n\nfloat intfract(int s, float n) {\n  int sn = int(n);\n  float fn = fract(n);\n  return float(s%sn)/n+fract(float((s/sn)*sn)/n);\n}\n\nfloat syntime;\nint synsamp;\n\nstruct syn4p {\n  float freq;\n  float freq2;\n  float decay;\n  float shape1;\n  float shape2;\n  float attack;\n};\n\nfloat synth4(syn4p p, float reltime, float maxtime) {\n  float v = 0.;\n  int relsamp = int(reltime*iSampleRate+0.5);\n  int samp = synsamp+relsamp;\n  float time = float(samp)/iSampleRate;\n  float rtime = time/maxtime;\n  if (time < 0. || rtime > 1.) return 0.;\n  float srt = iSampleRate;\n  for (float n=1.; n<15.; n+=1.00) {\n    if (p.freq*n>iSampleRate*0.4) break;\n    v += 0.2/pow(n,p.shape2)*sin(2.*pi*(intfract(synsamp, srt/(n*p.freq))+p.shape1*sin(2.*pi*intfract(samp, srt/(n*p.freq2)))));\n  }\n  v*=1.-exp((min(-time,0.))/p.attack);\n  v*=exp(-time/p.decay);\n  v*=1.-exp((min(rtime-1.,0.))*8.);\n  return v;\n}\n\nvoid play_seq1(inout float f, float ampl, float time, float clk) {\n  for (int i = max(0,int((syntime+time-6.)/clk)-2); i < int((syntime+time)/clk)+2; i++) {\n\n    syn4p syn;\n    float freq = 128.;\n    freq = freq*(float[](1.,1.,1.,3./2.,4./3.,1.,1.,5./4.,10./9.))[((i/8)^(i/(8*9)))%9];\n    syn.freq = freq;\n    syn.freq2 = syn.freq/2.;\n    syn.decay = 1./16.;\n    syn.attack = 1./32.;\n    syn.shape1 = 0.1;\n    syn.shape2 = 1.5;\n    f += 0.5*synth4(syn, time-float(i)*clk, 2.);\n    syn.freq2*=2.;\n    f += 0.25*synth4(syn, time-float(i/2*2)*clk, 2.);\n    syn.freq2*=3./2.;\n    f += 0.5*synth4(syn, time-float(i)*clk, 2.);\n\n    if (i%8==0) {\n      syn.decay = 2.;\n      syn.attack = 1./2.;\n      syn.freq = freq/8.;\n      syn.freq2 = freq*8.;\n      f += 0.0625*synth4(syn, time-(float(i)+0.0)*clk, 6.);\n      syn.freq = freq*8.;\n      syn.freq2 = freq/8.;\n      f += 0.0625*synth4(syn, time-(float(i)+0.0)*clk, 6.);\n    }\n\n    syn.freq = freq*(float[](1.,1.,5./4.,1.,1.,3./2.,1.,4./3.))[(i^(i/32))%8];\n    syn.freq2 = syn.freq*3.*1.;\n    syn.shape1 = -.125;\n    syn.shape2 = 1.2;\n    syn.decay = 0.5;\n    syn.attack = 1./32.;\n    f += 0.2*synth4(syn, time-(float(i)+0.0)*clk, 2.);\n  }\n}\n\nvec2 smoothclip(vec2 f) {\n    float p = 3.;\n    f.x = pow(atan(pow(abs(f.x),p)*1.571)/1.571,1./p)*sign(f.x);\n    f.y = pow(atan(pow(abs(f.y),p)*1.571)/1.571,1./p)*sign(f.y);\n    return f;\n}\n\nvec2 mainSound( int sampin ) {\n  synsamp = sampin;\n  if (synsamp > int(iSampleRate*180.)) return vec2(0);\n  float timein = float(synsamp)/iSampleRate;\n  syntime = timein;\n  vec2 v = vec2(0.);\n  float f = 0.;\n  play_seq1(f, 0.5, -2.0, 0.25);\n  v = vec2(f);\n  v = smoothclip(v);\n  v *= 1./(1.+exp((timein-160.)/10.))*(1.-exp((timein-180.)));\n  return vec2(v);\n}\n\n\n\n// Spectrogram Config\n\nconst float timescale = 1./4.; // Screens per second\nconst float freqscale = 4000.;\nconst vec2 stereomix = vec2(1.,1.)*40.;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\nconst float windowmax = 0.5;\n\nvec4 encode ( int i ) { return vec4((uvec4(i)>>ivec4(0,8,16,24))&0xFFu)/255.; }\nint decode ( vec4 f ) { uvec4 d = uvec4(f*255.)<<ivec4(0,8,16,24);\n  return int(d.x|d.y|d.z|d.w); }\n\nvoid mainImage ( out vec4 f, in vec2 pixf ) {\n  f = vec4(0.);\n  if (iFrame==0) return;\n  ivec2 pix = ivec2(pixf);\n  ivec2 res = ivec2(iChannelResolution[0].xy);\n  int center = res.x*res.y/2;\n  int offset = int(iTime*iSampleRate) - center;\n  int index = res.x*pix.y+pix.x;\n  int sampstart = decode(texelFetch(iChannel0, ivec2(1,0), 0));\n  bool start = (iFrame==1);\n  if (index==1) {\n    // Compensate for Shadertoy's failure to synchronize iTime to audio playback time\n    if (start) sampstart = int(iSampleRate*(iTime));\n    f = encode(sampstart);\n    return;\n  }\n  if (start) {\n    f = vec4(0.);\n  }\n  if (index==0) { f = encode(offset); return; }\n  int offsetlast = decode(texelFetch(iChannel0, ivec2(0), 0));\n  int cutoff = int(windowmax*iSampleRate);\n  if (abs(index-center) > cutoff) return;\n  int samp = index+offset;\n  int samplast = center+cutoff+offsetlast;\n  float time = (float(samp)-0.5)/iSampleRate;\n  if (samp <= offsetlast + center + cutoff) {\n    f.xy = texelFetch(iChannel0,\n      (ivec2(index+offset-offsetlast)/ivec2(1,res.x))%(res), 0).xy;\n  } else {\n    f.xy = mainSound(samp-sampstart);\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\nconst float sgr_pi = 3.141592653589793;\n\nvec2 readsound ( int isamp ) {\n  ivec2 res = ivec2(iResolution.xy);\n  int offset = int(iTime*iSampleRate) - res.x*res.y/2;\n  int samp = isamp - offset;\n  ivec2 pix = ivec2(samp%res.x, (samp/res.x));\n  return texelFetch(iChannel1, pix, 0).xy;\n}\n\nvec2 spectrogram ( float windowtime, int isamp, float freq ) {\n  vec2 sum = vec2(0.);\n  int iwindow = int(windowtime*iSampleRate);\n  float window = float(iwindow)/iSampleRate;\n  window = windowtime;\n  for (int irel = -iwindow; irel <= iwindow; irel+=1) {\n    // Cosine window\n    float w = (0.5+0.5*cos(float(irel)/float(iwindow)*sgr_pi));\n    float samp = dot(stereomix,readsound(isamp+irel));\n    float a = fract(float(irel/**/+0*isamp/**/)*freq/iSampleRate)*2.*sgr_pi;\n    sum += w*vec2(cos(a),sin(a))*samp;\n  }\n  return sum/iSampleRate/window;\n}\n\n// Calibrated to ttg's hearing\n// Returns modulation frequency at which a tone at base frequency\n// transitions from sounding as beats to sounding as separate tones\nfloat timeratiofn ( float freq ) {\n  const float nparam = 58.5;\n  const float aparam = 950.;\n  return freq/nparam + exp(-freq/aparam)*aparam/nparam;\n}\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  \n  int shift = int(fsf.x*timescale*(iTime));\n  int shiftlast = int(fsf.x*timescale*(iTime-iTimeDelta));\n  int delta = shift - shiftlast;\n\n  int x2 = (shift+(fs.x-d.x))%fs.x;\n  if (x2>delta) {\n    f = texelFetch(iChannel0,d,0);\n    // if (d.y>fs.y-32) f = vec4(0.5); // Debug\n    return;\n  }\n  float time = float(shift-x2)/timescale/fsf.x;\n  int isamp = int(time*iSampleRate);\n  float y = float(d.y);\n\n  float freq = freqscale * y / iResolution.y;\n  float windowfreq = timeratiofn(freq);\n  vec2 s = spectrogram(1./windowfreq, isamp, freq);\n  float ss = dot(s,s);\n  f.rgb = vec3(10.,3.2,1.)*ss*50.;\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 mainSound( in int samp,float time_DO_NOT_USE)\n{\n    return mainSound(samp);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}