{
    "Shader": {
        "info": {
            "date": "1513381185",
            "description": "... and they want their lighting-models and demo-graphics back... I felt retro today, that's why :)\n\nThe bloom/glow and floor texture turned out ok... the objects and animation are a bit boring, I got lazy at the end... shading is basic blinn-phong.",
            "flags": 32,
            "hasliked": 0,
            "id": "llffW2",
            "likes": 8,
            "name": "The 90s called...",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "phong",
                "postprocessing",
                "blur",
                "blinn"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 831
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The 90s called...\"\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool SHOW_BUFFERS = false;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n\n    vec3 base = texture (iChannel0, fragCoord / iChannelResolution[0].xy).rgb;\n    vec3 intensity = texture (iChannel1, fragCoord / iChannelResolution[1].xy).rgb;\n    vec3 bloomFirst = texture (iChannel2, fragCoord / iChannelResolution[2].xy).rgb;\n    vec3 bloomSecond = texture (iChannel3, fragCoord / iChannelResolution[3].xy).rgb;\n\n    vec3 col = base + 1.5*bloomSecond;\n    //col = col / (1. + col); // Reinhard-tonemapping makes the scene too dull\n    col = sqrt (col);\n\n    if (SHOW_BUFFERS) {\n        if (uv.y < -.5) {\n            fragColor = vec4 (base, 1.);\n        } else if (uv.y < .0) {\n            fragColor = vec4 (intensity, 1.);\n        } else if (uv.y < .5){\n            fragColor = vec4 (col, 1.);\n    \t} else {\n    \t\tfragColor = vec4 (bloomSecond, 1.);\n    \t}\n    } else {\n\t\tfragColor = vec4 (col, 1.);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The 90s called...\"\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// here the base image is generated\n\nconst int MAX_ITER = 64;\nconst float EPSILON = .0001;\n\nstruct Result {\n\tfloat d;\n    int id;\n};\n\nfloat saturate (in float v) {\n\treturn clamp (v, .0, 1.);\n}\n\nmat2 r2d (in float a) {\n    float r = radians (a);\n\tfloat c = cos (r);\n\tfloat s = sin (r);\n    return mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\n// a \"min()\" to pass material-id around\nResult minResult (Result a, Result b) {\n\treturn Result (min (a.d, b.d), (a.d < b.d ? a.id : b.id));\n}\n\nResult map (in vec3 p) {\n    float t = iTime;\n    float r = .075;\n    float offset = .25;\n\n    // balls\n    Result b = Result (length (p + vec3 (offset, offset, offset)) - r, 1); \n    b = minResult (b, Result (length (p + vec3 ( offset,  offset, -offset)) - r, 2));\n    b = minResult (b, Result (length (p + vec3 ( offset, -offset,  offset)) - r, 3));\n    b = minResult (b, Result (length (p + vec3 ( offset+.075*cos(4.*t), -offset, -offset+.075*sin(3.*t))) - r, 4));\n    b = minResult (b, Result (length (p + vec3 (-offset,  offset,  offset)) - r, 5));\n    b = minResult (b, Result (length (p + vec3 (-offset,  offset*sin(3.*t), -offset)) - r, 6));\n    b = minResult (b, Result (length (p + vec3 (-offset, -offset,  offset)) - r, 7));\n    b = minResult (b, Result (length (p + vec3 (-.3*cos(-2.*t), -.1*cos(5.*t), -.1*sin(-3.*t))) - 1.3*r, 8));\n\n    // bars\n    vec3 pBar = p;\n    float f = .125;\n    pBar.x -= 1.;\n    pBar.xy += vec2 (.1, f*sin (2. * t + 1.));\n    b = minResult (b, Result (length (vec3 (pBar).xy) - .025, 9));\n    pBar.xy += vec2 (.2, f*sin (2. * t + 2.));\n    b = minResult (b, Result (length (vec3 (pBar).xy) - .025, 9));\n    pBar.xy += vec2 (.3, f*sin (2. * t + 3.));\n    b = minResult (b, Result (length (vec3 (pBar).xy) - .025, 9));\n    pBar.xy += vec2 (.4, f*sin (2. * t + 4.));\n    b = minResult (b, Result (length (vec3 (pBar).xy) - .025, 9));\n    pBar.xy += vec2 (.5, f*sin (2. * t + 5.));\n    b = minResult (b, Result (length (vec3 (pBar).xy) - .025, 9));\n\n    // floor\n    b = minResult (b, Result (length (vec3 (p - vec3 (.0, -1.0, .0)).y), 10));\n\n    // cube\n    p += vec3 (.5*cos(-iTime), .2*cos (10.*iTime), .5*sin (-iTime));\n    p.xz *= r2d (25.*iTime);\n    p.yz *= r2d (35.*iTime);\n    b = minResult (b, Result (length (max (abs(p) - vec3 (.1), .0)) - .01, 0));\n\n    return b;\n}\n\nResult march (in vec3 ro, in vec3 rd, out int iter) {\n    Result res = Result (.0, 0);\n    for (int i = 0; i < MAX_ITER; ++i) {\n        iter = i;\n        vec3 p = ro + res.d * rd;\n        Result tmp = map (p);\n        if (tmp.d < EPSILON) break;\n        res.d += tmp.d * .95;\n        res.id = tmp.id;\n    }\n\n    return res;\n}\n\nvec3 normal (in vec3 p) {\n\tfloat d = map (p).d;\n    vec3 e = vec3 (EPSILON, .0, .0);\n    vec3 n = vec3 (map (p + e.xyy).d - d,\n                   map (p + e.yxy).d - d,\n                   map (p + e.yyx).d - d);\n    return normalize (n);\n}\n\nfloat shadow (in vec3 p, in vec3 l) {\n    float t = .01;\n    vec3 lDir = normalize (l - p);\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        float d = map (p + t * lDir).d;\n        if (d < EPSILON) return .1;\n        t += d;\n    }\n\n\treturn 1.;\n}\n\nvec3 shade (in vec3 p, in vec3 ro, in int id) {\n    vec3 color[11];\n    color[0] = vec3 (1.0, .0, .0);\n    color[1] = vec3 (.0, 1.0, .0);\n    color[2] = vec3 (.0, .0, 1.0);\n    color[3] = vec3 (1.0, 1.0, .0);\n    color[4] = vec3 (1.0, .0, 1.0);\n    color[5] = vec3 (.0, 1.0, 1.0);\n    color[6] = vec3 (1.0, 1.0, .0);\n    color[7] = vec3 (.5, 1., .25);\n    color[8] = vec3 (1.0, .25, .5);\n    color[9] = vec3 (.25, .5, 1.);\n    color[10] = vec3 (1., .5, .25);\n\n    float shininess[11];\n    shininess[0] = 80.;\n    shininess[1] = 120.;\n    shininess[2] = 20.;\n    shininess[3] = 200.;\n    shininess[4] = 40.;\n    shininess[5] = 80.;\n    shininess[6] = 160.;\n    shininess[7] = 80.;\n    shininess[8] = 100.;\n    shininess[9] = 180.;\n    shininess[10] = 80.;\n\n    vec3 n = normal (p);\n    vec3 lPos = vec3 (1.);\n    vec3 lDir = normalize (lPos - p);\n    vec3 hDir = normalize (ro + lDir);\n\n    float spec = pow (max (dot (hDir, n), .0), shininess[id]);\n    float diff = max (dot (n, lDir), .0);\n    float sha = shadow (p, lPos);\n\n    vec3 ambC = vec3 (.05);\n    float pattern1 = saturate (pow (abs(15. * cos(p.x+iTime) * sin (p.z+iTime)), .3));\n    float pattern2 = saturate (pow (abs(2. * cos(p.x+iTime) * sin (p.z+iTime) * .5 + .5), .3));\n    float pattern3 = saturate (pow (length (1.2*sin(mod((p.z*p.x)+iTime, .3))), .125));\n    float pattern4 = saturate (mod (length(p+iTime), .5));\n    int selector = int (mod (floor (iTime), 4.));\n    float pattern = (selector == 0) ? pattern1 : (selector == 1) ? pattern2 : (selector == 2) ? pattern3 : pattern4;\n    vec3 floorC = mix (vec3 (.3, .3, .7), vec3 (.9, .8, .4), pattern);\n    vec3 diffC = id == 10 ? floorC : color[id];\n    vec3 specC = vec3 (1.) * 2.;\n\n    vec3 col = ambC + sha * (diff*diffC + (sha < 1. ? .0 : spec) * specC);\n\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = 1.;\n    float c = cos (.2*iTime);\n    float s = sin (.2*iTime);\n    vec3 ro = vec3 (r*c, .9 + .2 * c, r*s);\n    vec3 aim = vec3 (.0, .0, .0);\n    vec3 forward = normalize (vec3 (aim - ro));\n    float zoom = 2.;\n    vec3 wup = vec3 (.0, 1., .0);\n    vec3 right = normalize (cross (wup, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + forward * zoom + uv.x * right + uv.y * up;\n    vec3 rd = normalize (camCenter - ro);\n\n    int iter = 0;\n    Result res = march (ro, rd, iter);\n\n    vec3 col = shade (ro + res.d * rd, ro, res.id);\n\n    float f = float (iter) / float (MAX_ITER);\n    col *= (1. / f*f);\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The 90s called...\"\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// here the intensity/greyscale threshold image is generated\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = texture (iChannel0, fragCoord / iChannelResolution[0].xy).rgb;\n    float greyscale = dot (col, vec3 (.29, .59, .12));\n    col = (greyscale > .75) ? vec3 (1.) : vec3 (.0);\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The 90s called...\"\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// first blur-pass (of the intensity-image in buffer B) for the bloom\n// blur-method by anastadunbar, https://www.shadertoy.com/view/4lXXWn\n\nconst float MAX_ITER = 40.;\n\nvec3 draw(vec2 uv) {\n    return texture(iChannel0,vec2(uv.x,1.-uv.y)).rgb;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    float bluramount = .01;\n    vec3 firstPass = vec3(0.);\n    for (float i = 0.; i < MAX_ITER; i++) {\n        vec2 q = vec2(cos(degrees((i/MAX_ITER)*360.)),\n                      sin(degrees((i/MAX_ITER)*360.))) *  (rand(vec2(i,uv.x+uv.y))+bluramount); \n        vec2 uv2 = uv+(q*bluramount);\n        firstPass += draw(uv2)/2.;\n\n        q = vec2(cos(degrees((i/MAX_ITER)*360.)),\n                 sin(degrees((i/MAX_ITER)*360.))) *  (rand(vec2(i+2.,uv.x+uv.y+24.))+bluramount); \n        uv2 = uv+(q*bluramount);\n        firstPass += draw(uv2)/2.;\n    }\n    firstPass /= MAX_ITER;\n\n    fragColor = vec4 (firstPass, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The 90s called...\"\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// second blur-pass (of the first bloom pass from buffer C) for the bloom\n// blur-method by anastadunbar, https://www.shadertoy.com/view/4lXXWn\n\nconst float MAX_ITER = 40.;\n\nvec3 draw(vec2 uv) {\n    return texture(iChannel0,vec2(uv.x,1.-uv.y)).rgb;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);    \n    float bluramount = .01;\n    vec3 secondPass = vec3(0.);\n    for (float i = 0.; i < MAX_ITER; i++) {\n        vec2 q = vec2(cos(degrees((i/MAX_ITER)*360.)),\n                      sin(degrees((i/MAX_ITER)*360.))) *  (rand(vec2(i,uv.x+uv.y))+bluramount); \n        vec2 uv2 = uv+(q*bluramount);\n        secondPass += draw(uv2)/2.;\n\n        q = vec2(cos(degrees((i/MAX_ITER)*360.)),\n                 sin(degrees((i/MAX_ITER)*360.))) *  (rand(vec2(i+2.,uv.x+uv.y+24.))+bluramount); \n        uv2 = uv+(q*bluramount);\n        secondPass += draw(uv2)/2.;\n    }\n    secondPass /= MAX_ITER;\n\n    fragColor = vec4 (secondPass, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}