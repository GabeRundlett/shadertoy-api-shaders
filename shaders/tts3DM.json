{
    "Shader": {
        "info": {
            "date": "1556563487",
            "description": "i like SoC\ni like pMod\ni like kerning\n\ni like dont like global vars\n\ni parallelized and sqrt()deferred DE(Link()) of\nhttps://www.shadertoy.com/view/wtX3W7\ninto this shader",
            "flags": 0,
            "hasliked": 0,
            "id": "tts3DM",
            "likes": 12,
            "name": "SoC Chain Reaction parallelized",
            "published": 3,
            "tags": [
                "soc",
                "pmod",
                "kerning"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 616
        },
        "renderpass": [
            {
                "code": "//self  : https://www.shadertoy.com/view/tts3DM\n//parent: https://www.shadertoy.com/view/wtX3W7\n// Chain Reaction by eiffie\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define tim time*2.0\n\n#define pixelSize 2.0/size.y\n\n#define REFLECTIONS\n#define SHADOWS\n//#define TEXTURECUBE\n//#define CIRCLE_LINKS\n#define TWISTS 4.5\n\n// V2 added shadows and made it compile on my older machine by unrolling the code\n#define time iTime\n#define size iResolution\n#define TAO 6.2831853\n\nconst float aperture=0.1,shadowCone=0.5,reflectionCone=0.5,pdt=10.0/TAO,tdp=TAO/10.0;\nconst vec3 mcol=vec3(.6,1.6,2.0);\n\nvec2 Rot2D(vec2 v,float a){return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\n//below is the dual of the above\nvec4 Rot2D(vec4 v,vec2 a){return vec4(Rot2D(v.xy,a.y),Rot2D(v.zw,a.x));}\n\n#define dd(a) dot(a,a)\n//below is the dual of the above\n#define ddd(a) vec2(dd(a.xy),dd(a.zw))\n\n//so i tried to parallelized the Link() function of\n//https://www.shadertoy.com/view/wtX3W7\n//i suceeded, but the result does not look elegant in source code.\n#ifdef CIRCLE_LINKS\n #define ass .0225\n#else\n #define ass .02\n#endif\nvec2 Link(vec3 p, vec2 a\n){vec4 q=vec4(0)\n ;vec4 f=Rot2D(p.xyxy,a)\n ;f.yw+=1.+sin(a.yx+tim)*.2\n ;q.xy=f.zw\n ;p.x=f.x //this started as origami foldAndCut , and ended up as used toilet paper.\n ;a=a*TWISTS+tim\n ;vec4 g=Rot2D(vec4(vec2(f.w,p.z),vec2(f.y,p.z)),a.yx)\n#ifdef CIRCLE_LINKS  \n ;q.yz=g.xy\n ;p.yz=g.zw\n ;return vec2(dd(vec2(length(vec2(p.x,p.y))-ass,p.z))\n             ,dd(vec2(length(q.xy)-ass,q.z)));}\n#else\n ;f=vec4(p.x,g.z,q.x,g.x)//look at this crumbled piece of paper. its an oregami unicorn!\n ;return ddd(vec4(\n     sqrt(ddd(max(abs(f)-vec2(.125,.025).xyxy,0.)))-.1 \n     ,g.wy).xzyw);}\n#endif \n\nfloat DE(in vec3 p\n){vec2 i=vec2(.5,0)\n ;i=Link(p,(floor(atan(p.x,-p.y)*pdt+i)+i.yx)*tdp)\n ;return sqrt(min(i.y,i.x))-ass;}\n\n/*\nvec2 Link2(vec3 p, vec2 a\n){vec3 q=vec3(0)\n ;vec4 f=p.xyxy\n ;f=Rot2D(f,a)\n ;f.yw+=1.+sin(a.yx+tim)*.2\n ;q.xy=f.zw\n ;p.x=f.x\n ;a=a*TWISTS+tim\n ;vec4 g=Rot2D(vec4(vec2(f.w,p.z),vec2(f.y,p.z)),a.yx)\n ;q.yz=g.xy\n ;p.yz=g.zw\n#ifdef CIRCLE_LINKS  \n ;return vec2(dd(vec2(length(vec2(p.x,p.y))-ass,p.z))\n             ,dd(vec2(length(q.xy)-ass,q.z)));}\n#else\n ;p.xy=sqrt(ddd(max(abs(vec4(p.x,p.y,q.x,q.y))-vec2(.125,.025).xyxy,0.)))-.1\n ;return ddd(vec4(p.x,p.z,p.y,q.z));}\n#endif \n*/\n\n\nfloat CircleOfConfusion(float t,float focalDistance){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nfloat randSeed;\nfloat randStep(){//a simple pseudo random number generator based on iq's hash\n return  (0.8+0.2*fract(sin(++randSeed)*4375.5453123));\n}\n#ifdef SHADOWS\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.0,d,s=1.0,r;\n ro+=rd*rCoC*2.0;\n for(int i=0;i<4;i++){\n  r=rCoC+t*coneGrad;d=DE(ro+rd*t)+r*0.5;s*=linstep(-r,r,d);t+=abs(d)*randStep();\n }\n return clamp(s,0.0,1.0);\n}\n#endif\nvec3 Background(vec3 rd,vec3 Llll){\n#ifdef TEXTURECUBE\n return textureCube(iChannel0,rd).rgb;\n#else\n float s=max(0.0,dot(rd,Llll));\n return vec3(.4,.5,.75)*(s+pow(s,10.0))+rd*0.05;\n#endif\n}\n#ifdef REFLECTIONS\nvec3 FuzzyReflection(vec3 ro, vec3 rd, float coneGrad, float rCoC,vec3 Llll){\n float t=0.0,d,r;\n ro+=rd*rCoC*2.0;\n vec4 col=vec4(0.0);\n for(int i=0;i<3;i++){//had to unroll this before to get it to compile correctly?!?!\n  r=rCoC+t*coneGrad;d=DE(ro);\n  if(d<r){\n   vec2 v=vec2(r*0.1,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(DE(ro+v.xyy)-d,DE(ro+v.yxy)-d,DE(ro+v.yyx)-d));\n   if(N!=N)N=-rd;\n   vec3 scol=mcol*(0.1+Background(reflect(rd,N),Llll))*(0.75+0.5*dot(N,Llll));\n   float alpha=(1.0-col.w)* linstep(-r,r,-d);\n   col+=vec4(scol*alpha,alpha);\n  }\n  d=max(d,r*0.5)*randStep();ro+=d*rd;t+=d;\n }\n return col.rgb+Background(rd,Llll)*(1.0-clamp(col.w,0.0,1.0));\n}\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randSeed=fract(cos((fragCoord.x+fragCoord.y*117.0+time*10.0)*473.7192451));\n vec3 ro=vec3(0,0,-2.75);\n vec3 rd=lookat(vec3(cos(tim)*0.2,-sin(tim)*.2,0.)-ro,vec3(0,1,0))*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n float focalDistance=length(ro);\n vec3 Llll=normalize(vec3(0.5,0.6,0.4));\n vec4 col=vec4(0);//color accumulator\n float t=2.5;//distance traveled\n ro+=rd*t;//move close to object\n for(int i=0;i<15;i++){//march loop\n  if(col.w>0.9 || t>4.0)continue;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t,focalDistance);//calc the radius of CoC\n  float d=DE(ro);\n  if(d<rCoC){//if we are inside add its contribution\n   vec2 v=vec2(rCoC*.1,.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-d+DE(ro+v.xyy),-d+DE(ro+v.yxy),-d+DE(ro+v.yyx)));\n   if(N!=N)N=-rd;\n   vec3 refl=reflect(rd,N);\n   vec3 scol=mcol*(0.1+Background(refl,Llll));\n#ifdef SHADOWS\n   scol*=FuzzyShadow(ro,Llll,3.0,shadowCone,rCoC);\n#else\n   scol*=(0.75+0.5*dot(N,Llll));\n#endif\n#ifdef REFLECTIONS\n   scol+=0.5*FuzzyReflection(ro,refl,reflectionCone,rCoC,Llll);\n#endif\n   float alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col+=vec4(scol*alpha,alpha);//blend in the new color \n  }\n  d=max(d,pixelSize)*randStep();//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n col.rgb=mix(Background(rd,Llll),col.rgb,clamp(col.w,0.0,1.0));\n\n fragColor=vec4(clamp(col.rgb,0.,1.),1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}