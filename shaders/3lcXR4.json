{
    "Shader": {
        "info": {
            "date": "1580443692",
            "description": "These are magnetic fields with random charges, both positive and negative. Lines and colors are determined by the direction of the force acting on a particle at that point.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lcXR4",
            "likes": 7,
            "name": "Magnetic Field Lines",
            "published": 3,
            "tags": [
                "2d",
                "physics",
                "magnet"
            ],
            "usePreview": 0,
            "username": "adasba",
            "viewed": 656
        },
        "renderpass": [
            {
                "code": "//I didn't make this. Credit to:\n//https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//I didn't make this either. Credit to:\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nconst int pointCount = 32;\n    \n#define PI 3.1415926535897932384626433832795\n    \nvec2 magneticField(vec3[pointCount] pts, vec2 position) {\n    vec2 netForce = vec2(0, 0);\n    for (int i = 0; pointCount > i; i++) {\n    \tnetForce += (position - pts[i].xy) / pow(distance(position, pts[i].xy), 3.0) * pts[i].z;\n    }\n    return netForce;\n}\n\nfloat modsign(float a, float b) {\n\treturn mod(a, b) * sign(a);\n}\n\nvec3 points[pointCount];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    for (int i = 0; pointCount > i; i++) {\n        int pc = pointCount;\n    \tpoints[i] = vec3(0.0);\n        points[i].x = rand(vec2(i, i + pc)) + sin(iTime * rand(vec2(i + pc * 5, i + pc * 6)) * 0.25) * 0.6;\n        points[i].y = rand(vec2(i + pc * 2, i + pc * 3)) + sin(iTime * rand(vec2(i + pc * 7, i + pc * 8)) * 0.25) * 0.6;\n        points[i].z = rand(vec2(i + pc * 4)) * 2.0 - 1.0;\n    }\n    \n    points[1].x = m.x;\n    points[1].y = m.y;\n    points[1].z = -1.0;\n    \n    //points[0] = vec3(0.25, 0.25, 1.0);\n    \n    //points[2] = vec3(0.75, 0.75, 1.0);\n\t//points[1] = vec3(m.x, m.y, -1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 mField = magneticField(points, uv);\n    float fieldMag = distance(vec2(0, 0), mField);\n    float fieldDir = atan(mField.y, mField.x);\n    //fragColor = vec4(log(fieldMag * 5.2) * 0.2, fieldDir / (2.0 * PI) + 0.5, 0.0, 1.0);\n    vec2 mDeriv = mField - magneticField(points, uv + vec2(0.0001));\n    \n    //fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, log(fieldMag * 20.0) * 0.1)), 1.0);\n    float logmag = log(fieldMag);\n    //float threshold = (1.0 / (1.0 + pow(3.0, -logmag)));\n    float threshold = pow(distance(vec2(0.0), mDeriv), 0.33);//pow((pow(2.0, 0.333) / (1.0 + pow(2.0, -distance(vec2(0.0), mDeriv)))), 3.0);\n    //vec3 col = vec3((mod(logmag * 4.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0);\n    float col = (mod(fieldDir / PI * 24.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0;\n    fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, col)), 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}