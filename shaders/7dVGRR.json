{
    "Shader": {
        "info": {
            "date": "1630989787",
            "description": "Oneshade suggested I make my refraction box (cube lol?) shader controllable so I've done that here. \nControls [ q,w,e,a,s,d] and mouse for movement\nComment out #define \"ANIMATED\" to play with it yourself.",
            "flags": 48,
            "hasliked": 0,
            "id": "7dVGRR",
            "likes": 22,
            "name": "Refraction Cube [ Playable ]",
            "published": 3,
            "tags": [
                "game",
                "refraction",
                "cube",
                "glass",
                "refract",
                "bigwings",
                "rubiks"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 541
        },
        "renderpass": [
            {
                "code": "/*\nComment out #define \"ANIMATED\" in common tab \nto play with it yourself.\n\nControls [ q,w,e,a,s,d] and mouse for movement\n\nI made a slightly more interesting design\nwith just one gem per square and a faint glow.\nThe solid color could be a lot better.\n\nand this is a far cry from the actual rubiks cube shader:\nhttps://www.shadertoy.com/view/XtG3D1\n\nBut you can play with it!\n\n*/\n\n//for AA set AA_ON to 1 and then set aa to more than 1\nfloat id = 0.;\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}   \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.);\n}\nfloat bar(vec3 p, float r, float le){\n     return max(length(p.yz) - r, abs(p.x)-le);\n     \n}\nfloat gem(vec3 p){\n\n    float c = cos(pi/5.), s = sqrt(0.75-c*c);\n    vec3 n = vec3(-0.5, -c, s);\n    \n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    float d = p.z-1.;\n    return d;   \n}\n\n//luna's rubiks cube tutorial\n//https://www.twitch.tv/videos/317211752?collection=_d31TQedWRW60w\nfloat tick(float time){\n    \n    float t = smoothstep(0.,1.,easeOutBounce(time));\n    t = smoothstep(0.,1.,t);\n    //t = smoothstep(0.,1.,t);\n    return t;\n}\nfloat choose_face(float t){\n    return fract(123.645234*t);\n}\n\nfloat glow = 0.;\nfloat map(vec3 p){\n    \n    float time = T*1.;\n    \n    //the animation lasts one second\n    float t = fract(time);\n    //float tick = tick(1.-TX(iChannel2, vec2(0.)).x);\n    \n    //for that second, we can have one of 6 faces\n    \n    #ifdef ANIMATED \n    float face = floor(choose_face(floor(time))*6.)+1.;\n    float tick = tick(t);\n    #else\n    float tick = tick(1.-TX(iChannel2, vec2(0.)).x);\n    float face = TX(iChannel2, vec2(0.)).z;\n    #endif\n    //choose_face(floor(time))*6.;\n    \n    //luna's rubiks cube tutorial\n    //https://www.twitch.tv/videos/317211752?collection=_d31TQedWRW60w\n    \n    /*\n    if(face == 1.)\n    p.xz *= rot(tick*pi*0.5*step(6.9,p.y));\n    else if(face == 2.)\n    p.xz *= rot(tick*pi*0.5*step(6.9,-p.y));\n    else if(face == 3.)\n    p.yz *= rot(tick*pi*0.5*step(6.9,p.x));\n    else if(face == 4.)\n    p.yz *= rot(tick*pi*0.5*step(6.9,-p.x));\n    else if(face == 5.)\n    p.xy *= rot(tick*pi*0.5*step(6.9,p.z));\n    else if(face == 6.)\n    p.xy *= rot(tick*pi*0.5*step(6.9,-p.z));\n    */\n    \n    p.xz = face == 1. ? p.xz*rot(tick*pi*0.5*step(6.9,p.y)) : p.xz;\n    p.xz = face == 2. ? p.xz*rot(tick*pi*0.5*step(6.9,-p.y)) : p.xz;\n    p.yz = face == 3. ? p.yz*rot(tick*pi*0.5*step(6.9,p.x)) : p.yz;\n    p.yz = face == 4. ? p.yz*rot(tick*pi*0.5*step(6.9,-p.x)) : p.yz;\n    p.xy = face == 5. ? p.xy*rot(tick*pi*0.5*step(6.9,p.z)) : p.xy;\n    p.xy = face == 6. ? p.xy*rot(tick*pi*0.5*step(6.9,-p.z)) : p.xy;\n    \n    vec3 sp = p ;\n   \n    p = mod(p+7., 14.) - 7.;\n    float scene = 1000.;   \n    float bb = sdBox(p, vec3(5.5));\n    \n    vec3 q = p;\n    //q = mod(q, 2.2) - 1.1;\n    float more_gems = gem(q);\n    //more_gems = max(bb, more_gems);\n    scene = min(scene, more_gems);\n    \n    \n    q = p;\n    float hole_size = 4.85;\n    float boxe_size = 6.;\n    float hole, boxe,wooden_frames;\n    \n    for(float i = 0.; i < 3.; i++){\n        hole = max(abs(q.y),abs(q.x)) - hole_size;\n        hole = min(hole, max(abs(q.y),abs(q.z)) - hole_size);\n        hole = min(hole, max(abs(q.z),abs(q.x)) - hole_size);\n\n        boxe = sdBox(p, vec3(boxe_size)\n                     //+ vec3(sin(p.y), 0., sin(p.y/5.))/10.)\n                     )- 0.4;\n        //boxe = max(-bb, boxe);\n        wooden_frames =  smax(-hole, boxe, 0.3);\n        scene = min(scene, wooden_frames);\n        boxe_size --;\n        hole_size --;\n    }\n    \n   // wooden_frames = min(dots, wooden_frames);\n    \n    //sp.xz *= rot(iTime);\n    bb = sdBox(sp, vec3(21.));\n    scene = max(bb, scene);\n    more_gems = max(bb, more_gems);\n    id = more_gems < wooden_frames ? 0. : 1.;\n    \n    if(id == 0.)glow += 0.014;//max(0.01,(0.001/(0.005*pow((more_gems),1.4))));;\n    \n    id = abs(sp.x) > 6.9 && \n             abs(sp.y) > 6.9 && \n             abs(sp.z) > 6.9 && \n             id == 1. ?\n             0. : id;\n             \n    return scene;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = abs(map(ro + rd*t));\n        if(d < 0.001 || t > MAX_DIST) break;\n        t += d*0.85;\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\n\nvec3 cube_map(vec3 p, vec3 n){\n\n    vec3 tex_X = TX(iChannel1,p.zy*0.5+0.5).rgb;\n    vec3 tex_Y = TX(iChannel1,p.xz*0.5+0.5).rgb;\n    vec3 tex_Z = TX(iChannel1,p.xy*0.5+0.5).rgb;\n    \n    n = abs(n);\n    return vec3(tex_X*n.x + tex_Y*n.y + tex_Z*n.z);\n    \n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zm){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zm;\n    return normalize(rd);\n\n}\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd){\n    vec3 color;\n    \n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.001);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + ldist*ldist*0.02);\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.), 5.);\n    vec3 refl_col = TX(iChannel0,reflect(rd, sn)).rgb;\n    color = diff*cube_map(sp/20.,sn)*vec3(0.3,0.3,0.3)/1.5\n            + refl_col*0.1\n            + spec;\n return clamp(color, 0., 1.);   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0., 10., -80.);\n    ro.yz *= rot(-m.y*pi+1.);\n    ro.xz *= rot(-m.x*pi*2.);\n  \n    vec3 rd = camRay(uv, ro, vec3(0., 0.,0.), zoom);\n    \n    vec3 col = TX(iChannel0, rd).rgb*0.5;\n    //col += hexTexture(uv+vec2(iTime/50.,0.), TX(iChannel1, vec2(3.)).rgb, col, vec2(1.))*0.13;\n\n    \n    float t = trace(ro, rd);\n    \n    \n    // Time varying pixel color\n    \n    \n    vec3 tex;\n    if(t < MAX_DIST && id == 0.){\n        \n        //tpnre\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        vec3 rIn = refract(rd,n,1./glass);\n        vec3 enter = p - n*0.01;\n        \n        vec3 obligatory_reflection = reflect(rd, n);\n        vec3 obligatory_outside = TX(iChannel0, obligatory_reflection).rgb;\n        \n        //tpnre\n        float tOut = trace(enter, rIn);\n        p = enter + rIn*tOut;\n        vec3 nExit = -normal(p);\n        \n        \n        vec3 rOut = refract(rIn, nExit, glass - 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.r = TX(iChannel0,rOut).r;\n        \n        rOut = refract(rIn, nExit, glass);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.g = TX(iChannel0,rOut).g;\n        \n        rOut = refract(rIn, nExit, glass + 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.b = TX(iChannel0,rOut).b;\n        \n        //vec3 exit = p + rOut*t;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n        \n        float dens = 0.8;\n        float optDist = exp(-t*dens);\n        \n\n        col = mix(tex, obligatory_outside, fresnel);\n\n    }\n    \n    else if(t < MAX_DIST && id == 1.){\n        vec3 p = ro + rd*t;\n        vec3 n = abs(normal(p));\n        col = clamp(lighting(p,n,vec3(30.), rd), 0., 1.);\n    }\n    \n    col += glow;\n    col = pow(col, vec3(.545));\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define ANIMATED 1\n\n#define TX texture\n\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n\n#define C clamp\n\n#define MAX_STEPS 100\n#define MAX_DIST 145.\n#define pi 3.14159265\n#define air 1.\n#define glass 1.45\n#define zoom 1.\n\n\n\n#define AA 1\n//from david hoskins hash without sine\n// 3 in 1 out\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvec3 hexTexture(vec2 uv, vec3 color, vec3 tex, vec2 firstXY)\n{\n\tvec2 u = 6.*uv;;\n    vec2 s = vec2(1.,1.732);\n    vec2 a = mod(u,s)*2.-s;\n    vec2 idA = floor(u/s);\n    vec2 b = mod(u+s*.5,s)*2.-s;\n    vec2 idB = floor((u+s*.5)/s);\n    \n    float la = length(a);\n    float lb = length(b);\n    \n    u = la < lb ? a : b;\n    vec2 idSeed = la < lb ? idA : idB*1000.;\n    float id = rnd(idSeed+firstXY.x*firstXY.y/800.);\n    vec2 st = abs(u);\n    float q = max(st.x, dot(st,normalize(s)));\n    float radius = pow(id*0.2,4.);\n    float f = smoothstep(radius + 0., radius + 0.05, 1.0-q);\n    //+firstXY.y/16.\n    vec3 col = mix(tex,color-fract(8.*id)*0.5,f*step(0.2,id));\n    return col;\n}\n\n//skaplun\n//https://www.shadertoy.com/view/7tf3Ws \nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n\n//poljere \n//https://www.shadertoy.com/view/Xst3zX\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\n\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_W     = 87.5/256.0;\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//https://www.shadertoy.com/view/Xst3zX\nfloat isKeyPressed(float key)\n{\n    return step(0.1, texture( iChannel1, vec2(key, 0.0) ).x);\n\t//return texture( iChannel1, vec2(key,  2.) ).x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float animation_on = TX(iChannel0,uv).x;\n    float key = TX(iChannel0,uv).z;\n    \n    //if(animation_on == 0.){\n    \n        key = isKeyPressed(KEY_Q) > 0.5 ? 4. : key;\n        key = isKeyPressed(KEY_W) > 0.5 ? 1. : key;\n        key = isKeyPressed(KEY_E) > 0.5 ? 3. : key;\n\n        key = isKeyPressed(KEY_A) > 0.5 ? 6. : key;\n        key = isKeyPressed(KEY_S) > 0.5 ? 2. : key;\n        key = isKeyPressed(KEY_D) > 0.5 ? 5. : key;\n    //}\n\n    float t = 0.;\n    \n    if(key > 0. && animation_on == 0.)animation_on = 1.;\n    \n    if(animation_on > 0.)\n    {\n        animation_on -= 1./30.;\n    }\n    else\n    {\n        animation_on = 0.;\n        key = 0.;\n    }\n    \n    fragColor = vec4(vec3(animation_on,key,key),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}