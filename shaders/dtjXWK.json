{
    "Shader": {
        "info": {
            "date": "1676623394",
            "description": "Demo of:\n[url]https://alister-chowdhury.github.io/posts/20230120-simplifying-drawing-numbers-on-the-gpu[/url]\n\nCompacts numbers into a single u32 for drawing.\n\nNumbers drawn here are:\n* iTime\n* sin(iTime)\n* cos(iTime)\n* iTime^5\n* rcp(iTime)",
            "flags": 0,
            "hasliked": 0,
            "id": "dtjXWK",
            "likes": 7,
            "name": "Encoding and drawing numbers",
            "published": 3,
            "tags": [
                "text",
                "utility",
                "numbers",
                "font",
                "digits"
            ],
            "usePreview": 0,
            "username": "krax",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float padding = .1;\n    float numNumbersToDraw = 5.;\n    float coordScaling = min(iResolution.x/8., iResolution.y/numNumbersToDraw);\n    vec2 uv = fragCoord * vec2(1./8., 1.) / coordScaling;\n\n    int numId = int(uv.y);\n    uv.y = fract(uv.y);\n    uv = uv * (1. + 2.*padding) - padding;\n    bool valid = (numId < int(numNumbersToDraw)) && (min(uv.x, uv.y) > 0.) && (max(uv.x, uv.y) < 1.);\n    \n    float x = iTime;\n    switch(numId)\n    {\n        case 3: { x = sin(x); break; }\n        case 2: { x = cos(x); break; }\n        case 1: { x = x * x * x * x * x; break; }\n        case 0: { x = 1./x; break; }\n    }\n \n    uint encoded = encodeNumber(x);\n    uint signedValue = sampleEncodedNumber(encoded, uv);\n\n    vec3 bgCol = vec3(.251, .027, .471);\n    vec3 fgCol = vec3(0., .835, 1.);\n    fragColor = vec4(mix(bgCol, fgCol, vec3(float(signedValue) * float(valid))), 1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This contains logic for encoding and drawing numbers.\n//\n// The encoding logic is based off:\n// https://github.com/alister-chowdhury/impl-function-ref/blob/master/generic/encode_number_for_gpu_rendering.inl\n//\n// The way this works is by packing a u32 with 8 characters (4 bits per character).\n// This is useful because it requires a fixed amount of storage and max triangle count.\n// If the number doesn't fit into the budget (8 characters), engineering notation is used instead.\n//\n//\n// The drawing part uses a 5x6 1bpp font (30bits), with each character encoded into a\n// uint that can be sampled from.\n//\n// Functions:\n//  uint encodeNumber(uint value);\n//  uint encodeNumber(int value);\n//  uint encodeNumber(float value);\n//\n//  uint sampleEncodedDigit(uint encodedDigit, vec2 uv);\n//  uint sampleEncodedNumber(uint encodedNumber, vec2 uv);\n//  uint sampleEncodedNumber(uvec2 encodedNumber, vec2 uv);\n//\n// It's worth noting `sampleEncodedNumber` will scale the UV.x by 1.2\n// to add a logical 1px padding.\n// So you should be aiming to draw a box with an aspect ratio of 6:1\n//\n// https://alister-chowdhury.github.io/posts/20230120-simplifying-drawing-numbers-on-the-gpu/\n\n\n// GL = Y starts at the bottom\n// DX = Y starts at the top\n#ifndef Y_STARTS_AT_BOTTOM\n#define Y_STARTS_AT_BOTTOM 1\n#endif\n\n\n// Encoding logic\n\n#define GPU_NUMBER_ENCODING_E        10u\n#define GPU_NUMBER_ENCODING_DOT      11u\n#define GPU_NUMBER_ENCODING_PLUS     12u\n#define GPU_NUMBER_ENCODING_NEG      13u\n#define GPU_NUMBER_ENCODING_INVALID  14u\n#define GPU_NUMBER_ENCODING_EMPTY    15u\n\n#define INV_LN_10 0.434294481903251827651128918916605082294397005803666566\n\n#define pow10(x)            pow(10., float(x))\n#define floorLog10(x)       floor(log(x) * INV_LN_10)\n\n\nfloat fractInputReturnFloor(inout float x)\n{\n    float floored = floor(x);\n    x -= floored;\n    return floored;\n}\n\nstruct RepBuffer\n{\n    uint    data;\n    uint    index;\n};\n\n\nRepBuffer RepBuffer_init()\n{\n    RepBuffer repBuffer;\n    repBuffer.data = 0u;\n    repBuffer.index = 0u;\n    return repBuffer;\n}\n\nvoid RepBuffer_push(inout RepBuffer repBuffer, uint value)\n{\n    repBuffer.data |= ((~value) & 15u) << (4u * repBuffer.index++);\n}\n\nvoid RepBuffer_pop(inout RepBuffer repBuffer, uint count)\n{\n    if(count > repBuffer.index) { count = repBuffer.index; }\n    uint mask = ~0u;\n    mask >>= ((count - repBuffer.index) * 4u);\n    repBuffer.data &= mask;\n    repBuffer.index -= count;\n}\n\n\nuint RepBuffer_remainingSpace(RepBuffer repBuffer)\n{\n    return 8u - repBuffer.index;\n}\n\n\nuint RepBuffer_get(RepBuffer repBuffer)\n{\n    return ~repBuffer.data;\n}\n\n\nuint RepBuffer_getZero()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, 0u);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n    RepBuffer_push(repBuffer, 0u);\n    return RepBuffer_get(repBuffer);\n}\n\nuint RepBuffer_getNan()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_INVALID);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_INVALID);\n    return RepBuffer_get(repBuffer);\n}\n\nuint RepBuffer_getPosInf()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_PLUS);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_E);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_PLUS);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    return RepBuffer_get(repBuffer);\n}\n\nuint RepBuffer_getNegInf()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_NEG);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_E);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_PLUS);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    return RepBuffer_get(repBuffer);\n}\n\n\nRepBuffer encodeWholeNumber(float x, bool isInteger)\n{\n\n    RepBuffer repBuffer = RepBuffer_init();\n\n    if(x < 0.)\n    {\n        x = -x;\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_NEG);\n    }\n\n    int e10 = int(floorLog10(x));\n    float d10 = pow10(-e10);\n\n    // Scale down\n    x *= d10;\n\n    // Apply rounding logic\n    x += 0.5f * pow10(-int(RepBuffer_remainingSpace(repBuffer)) + 2);\n\n    // Deal with really odd case\n    // where we round up enough to\n    // change our current number\n    if(x >= 10.0f)\n    {\n        x *= 0.1f;\n        ++e10;\n    }\n\n    // Numbers >= 1, will also omit 0 for decimal numbers\n    if(e10 >= 0)\n    {\n        for(int i=0; i<=e10; ++i)\n        {\n            uint decimal = uint(fractInputReturnFloor(x));\n            x *= 10.0f;\n            RepBuffer_push(repBuffer, decimal);\n        }\n\n        // stop on whole numbers or if we'd just write a single decimal place\n        if(isInteger || (RepBuffer_remainingSpace(repBuffer) <= 1u))\n        {\n            return repBuffer;\n        }\n    }\n\n\n    // Decimals\n    {\n        // Include decimal place as zero we wish to strip\n        uint writtenZeroes = 1u;\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n\n        // Fill in 0's\n        for(int i=0; i<(-e10-1); ++i)\n        {\n            RepBuffer_push(repBuffer, 0u);\n            ++writtenZeroes;\n        }\n\n        // Use the remaining space for anything left\n        uint budget = RepBuffer_remainingSpace(repBuffer);\n        for(uint i=0u; i<budget; ++i)\n        {\n            uint decimal = uint(fractInputReturnFloor(x));\n            x *= 10.0f;\n            if(decimal == 0u)\n            {\n                ++writtenZeroes;\n            }\n            else\n            {\n                writtenZeroes = 0u;\n            }\n            RepBuffer_push(repBuffer, decimal);\n        }\n\n        // Clear trailing 0's and possibly the decimal place\n        RepBuffer_pop(repBuffer, writtenZeroes);\n    }\n\n    return repBuffer;\n}\n\n\nRepBuffer encodeWholeNumber(float x)\n{\n    return encodeWholeNumber(x, floor(x) == x);\n}\n\n\nRepBuffer encodeWholeNumber(int x)\n{\n    return encodeWholeNumber(float(x), true);\n}\n\n\nRepBuffer encodeWholeNumber(uint x)\n{\n    return encodeWholeNumber(float(x), true);\n}\n\n\nRepBuffer encodeEngNotation(float x)\n{\n\n    RepBuffer repBuffer = RepBuffer_init();\n\n    if(x < 0.)\n    {\n        x = -x;\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_NEG);\n    }\n\n    int e10 = int(floorLog10(x));\n    float d10 = pow10(-e10);\n\n    // Scale down\n    x *= d10;\n\n    uint budget = RepBuffer_remainingSpace(repBuffer);\n\n    // X.e+X\n    budget -= 5u;\n    if(abs(e10) >= 10)\n    {\n        budget -= 1u;\n    }\n\n    // Apply rounding logic\n    x += 0.5f * pow10(-int(budget));\n\n    // Deal with really odd case\n    // where we round up enough to\n    // change our current number\n    if(x >= 10.0f)\n    {\n        x *= 0.1f;\n        // Even odder case where our budget decreases\n        if(++e10 == 10)\n        {\n            budget -= 1u;\n        }\n    }\n\n    // First number and a dot\n    {\n        uint decimal = uint(fractInputReturnFloor(x));\n        x *= 10.0f;\n        RepBuffer_push(repBuffer, decimal);\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n    }\n\n\n    while(budget != 0u)\n    {\n        uint decimal = uint(fractInputReturnFloor(x));\n        x *= 10.0f;\n        RepBuffer_push(repBuffer, decimal);\n        --budget;\n    }\n\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_E);\n    RepBuffer_push(repBuffer, (e10 < 0) ? GPU_NUMBER_ENCODING_NEG : GPU_NUMBER_ENCODING_PLUS);\n\n    if(e10 < 0)\n    {\n        e10 = -e10;\n    }\n\n    // NB: We only handle two digit exponents (which is fine for floats)\n    if(e10 >= 10)\n    {\n        RepBuffer_push(repBuffer, uint(e10 / 10));\n    }\n\n    RepBuffer_push(repBuffer, uint(e10) % 10u);\n\n    return repBuffer;\n}\n\n\nbool requiresEngineerNotation(float value)\n{\n    // This is the maximum float we can represent as an integer.\n    // before errors start emerging, (8000011 will output 8000012).\n    // Found purely by brute force.\n    const float maxValidFloat = 8000010.0f;\n    if(value == 0. || value == -0.) return false;\n    if(value < 0.)\n    {\n        value = -value;\n        return !(value <= maxValidFloat && value >= 0.001);\n    }\n    return !(value <= maxValidFloat && value >= 0.0001);\n}\n\n\nbool requiresEngineerNotation(int value)\n{\n    if(value < 0)\n    {\n        value = -value;\n        return !(value < 10000000);\n    }\n    return !(value < 100000000);\n}\n\n\nbool requiresEngineerNotation(uint value)\n{\n    return !(value < 100000000u);\n}\n\n\nuint encodeNumber(uint value)\n{\n    if(value == 0u) { return RepBuffer_getZero(); }\n    RepBuffer buf;\n    if(requiresEngineerNotation(value)) { buf = encodeEngNotation(float(value)); } else { buf = encodeWholeNumber(value); }\n    return RepBuffer_get(buf);\n}\n\n\nuint encodeNumber(int value)\n{\n    if(value == 0) { return RepBuffer_getZero(); }\n    RepBuffer buf;\n    if(requiresEngineerNotation(value)) { buf = encodeEngNotation(float(value)); } else { buf = encodeWholeNumber(value); }\n    return RepBuffer_get(buf);\n}\n\n\nuint encodeNumber(float value)\n{\n    if(value == 0.)      { return RepBuffer_getZero(); }\n    if(isnan(value))    { return RepBuffer_getNan(); }\n    if(isinf(value))\n    {\n        if(value > 0.)\n        {\n            return RepBuffer_getPosInf();\n        }\n        return RepBuffer_getNegInf();\n    }\n\n    RepBuffer buf;\n    if(requiresEngineerNotation(value)) { buf = encodeEngNotation(value); } else { buf = encodeWholeNumber(value); }\n    return RepBuffer_get(buf);\n}\n\n\n\n//// Drawing logic\n\n// .###. ..#.. .###. ##### #...# ##### .#### ##### .###. .###.\n// #..## .##.. #...# ....# #...# #.... #.... ....# #...# #...#\n// #.#.# ..#.. ...#. ..##. #...# ####. ####. ...#. .###. #...#\n// ##..# ..#.. ..#.. ....# .#### ....# #...# ..#.. #...# .####\n// #...# ..#.. .#... #...# ....# ....# #...# ..#.. #...# ....#\n// .###. .###. ##### .###. ....# ####. .###. ..#.. .###. .###.\n//\n// ..... ..... ..... ..... ..... .....\n// .###. ..... ..... ..... .#.#. .....\n// #...# ..... ..#.. ..... ##### .....\n// ##### ..... .###. .###. .#.#. .....\n// #.... .##.. ..#.. ..... ##### .....\n// .###. .##.. ..... ..... .#.#. .....\n\nuint numberPixels[16] = uint[16](\n#if !Y_STARTS_AT_BOTTOM\n    0x1d19d72eu, 0x1c4210c4u, 0x3e22222eu, 0x1d18321fu,\n    0x210f4631u, 0x1f083c3fu, 0x1d18bc3eu, 0x0842221fu,\n    0x1d18ba2eu, 0x1d0f462eu, 0x1c1fc5c0u, 0x0c600000u,\n    0x00471000u, 0x00070000u, 0x15f57d40u, 0x00000000u\n#else\n    0x1d9ace2eu, 0x0862108eu, 0x1d14105fu, 0x3f06422eu,\n    0x2318fa10u, 0x3e17c20fu, 0x3c17c62eu, 0x3f041084u,\n    0x1d17462eu, 0x1d18fa0eu, 0x00e8fc2eu, 0x000000c6u,\n    0x00023880u, 0x00003800u, 0x00afabeau, 0x00000000u\n#endif\n);\n\n\nuint sampleEncodedDigit(uint encodedDigit, vec2 uv)\n{\n    if(uv.x < 0. || uv.y < 0. || uv.x >= 1. || uv.y >= 1.) return 0u;\n    uvec2 coord = uvec2(uv * vec2(5., 6.));\n    return (numberPixels[encodedDigit] >> (coord.y * 5u + coord.x)) & 1u;\n}\n\n\n// 8 character variant\nuint sampleEncodedNumber(uint encodedNumber, vec2 uv)\n{\n    // Extract the digit ID by scaling the uv.x value by 8 and clipping\n    // the relevant 4 bits.\n    uv.x *= 8.0;\n    uint encodedDigit = (encodedNumber >> (uint(uv.x) * 4u)) & 0xfu;\n    \n    // Put the U in between then [0, 1.2] range, the extra 0.2 is add a\n    // logical 1px padding.\n    // (6/5, where 5 is the number of pixels on the x axis)\n    uv.x = fract(uv.x) * 1.2;\n\n    return sampleEncodedDigit(encodedDigit, uv);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}