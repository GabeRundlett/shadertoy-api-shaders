{
    "Shader": {
        "info": {
            "date": "1635381703",
            "description": "A shader I've kicked around for a while - parts of the noise from various @iq's examples / and add in some anisotropic glitter and floating shapes. ",
            "flags": 0,
            "hasliked": 0,
            "id": "ssK3DR",
            "likes": 24,
            "name": "Postcard of a Mirage ",
            "published": 3,
            "tags": [
                "raymarching",
                "fbm",
                "water",
                "anisotropic",
                "sand",
                "glitter"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 504
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Postcard of a Mirage \n    10/27/21 @byt3_m3chanic\n\n    A shader I've kicked around for a while. \n    Parts of the noise from various @iq's examples.\n    Add in some anisotropic glitter and floating \n    shapes, and you have a abstract isometric shader! \n*/\n\n\n#define S\tsmoothstep\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265\n#define PI2 6.28318530\n#define ZRO 0\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nvec2 hash2( vec2 p ){ return fract(sin(vec2(dot(p,vec2(127.1,211.7)),dot(p,vec2(219.5,183.3))))*43758.5453); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// @gaz\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat box(vec2 p,vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// @iq\nvec3 noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    // texel fetch version\n    vec2 p = vec2(floor(x));\n    float a = hash21( p+vec2(0,0) );\n\tfloat b = hash21( p+vec2(1,0) );\n\tfloat c = hash21( p+vec2(0,1) );\n\tfloat d = hash21( p+vec2(1,1) );\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t   6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n// @iq\nfloat fbm ( in vec2 _st, float oct) {\n    oct = min(oct,5.);\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\n    for (float i = 0.; i < 8.25-oct; ++i) {\n        v += a * noised(_st).x;\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n//generate terrain using above noise algorithm\nfloat terrain( vec2 p, float freq ) {\t\n\tfloat h = -1.;\n\tfloat w = 2.6;\n\tfloat m = 0.35;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noised((p * m)).x;\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\n//globals\nvec3 hitPoint,hit;\nvec2 vuv;\nmat2 r45,turn,tilt;\nfloat mvt = 0.,ghs,shs;\nfloat midpt;\n\n//constants\nconst float sz = .5;\nconst float hf = sz*.5;\nconst float db = sz *2.;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    p.y+=4.;\n    vec3 pp = p;\n\n    if(vuv.x<midpt) p.z-=T*.3;\n    \n    float ter = terrain(p.xz*sz,2.)*.85;\n    float d2 = p.y - ter;\n    \n    if(d2<res.x && vuv.x<midpt) {\n       res = vec2(d2,2.);\n       hit=p;\n    }\n    \n    float d3 = pp.y-1.-(ter*.75);\n    if(d3<res.x && vuv.x>midpt) {\n        res=vec2(d3,1.);\n        hit=p;\n    }\n\n    vec2 id = floor(p.xz*sz) + .5; \n    vec2 r = p.xz - id/sz;\n    vec3 qx = vec3(r.x,p.y,r.y);\n    float hs = hash21(id);\n    float xtr = terrain(id,2.)*.85;\n    vec3 qqx=qx-vec3(0,xtr+.1,0);\n    \n    float bf = length(qqx)-(.3*hs);\n    if(bf<res.x && vuv.x<midpt && hs>.4 && xtr>1.15) {\n        res=vec2(bf,4.);\n        hit=qqx;\n        shs=hs;\n    }\n\n    float cells = 8.;\n    vec3 q = pp-vec3(0,4.5,0);\n    q.xz*=turn;\n\n    // @Shane Polar Repetion \n    float a = atan(q.z, q.x);\n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*cells);\n    ia = (ia + .5)/cells*6.2831853;\n\n    // find object via mod and cells and wave\n    float ws = -mod(ia,.0);\n    float cy = sin( ws*4. + (T * .25) * PI) * 1.5;\n    q.y +=cy;\n\n    // Converting the radial centers to their positions.\n    q.xz *= rot(ia);\n    q.x -= 5.75;\n \n    q.zy*=rot(ws+T);\n    q.xz*=rot(ws);\n\n    float df = zag(q,.295);\n    if(df<res.x) {\n        res=vec2(df,3.);\n        hit=q;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\n// water ripples - using bmp map to add extra\n// depth to water effects\nvec3 fxBumpMap( vec3 p, vec3 n, float bf, float per) {\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        vec3(fbm(p.xz - e.xy, 3.)), \n        vec3(fbm(p.xz - e.yx, 2.)), \n        vec3(fbm(p.xz - e.yy, 3.))\n    );\n    vec3 g = vec3(.3, .59, .12) * m; \n    g = (g - dot(vec3(fbm(p.xz , 3.)), vec3(.3, .59, .12)) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\n// reduced voronoi based off @iq\n// https://www.shadertoy.com/view/ldl3W8\n// used for the glitter pattern\nvec3 voronoi( in vec2 x) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.,ox = 0.;\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md ){\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.;\n    //reduced to 1\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = mg + vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        ox = o.x;\n    }\n    return vec3(md,ox,mr.x);\n}\n\n// lame based off the tex3D and used\n// to add texture for glintz\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = voronoi(p.yz).xyz;\n    vec3 ty = voronoi(p.zx).xyz;\n    vec3 tz = voronoi(p.xy).xyz;\n    //return mat3(tx*tx, ty*ty, tz*tz)*n;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 glintz( vec3 lcol, vec3 hitPoint, vec3 n, vec3 rd, vec3 lpos) {\n    vec3 mate = vec3(0);\n    vec3 pos = hitPoint;\n    \n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    float pw,q,anisotropy;\n    vec3 tcoord;\n \n    //build layers\n    for(int i = 0; i < 2;i++) {\n\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n        \n        vec3 aniso = vec3(vor3D(tcoord.zyx*pw,n).yy, vor3D(tcoord.xyz*vec3(pw,-pw,-pw),n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n \n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += \n        (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n\n    return \n        mix(light*vec3(0.3), vec3(.05), .1) +\n        glints +\n        lcol * .3;\n}\n\nvec3 sky = vec3(0);\n// modified slim sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, float ison) { \n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n    // rayleigh / mie\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1), betaM = vec3(4e-2); \n    float zAng = max(2e-6, rd.y);\n    // scatter - Klassen's model.\n    vec3 extinction = exp(-(betaR*1. + betaM*1.)/zAng);\t\n    vec3 col = 2.*(1. - extinction);\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 vuv = (ro + t*rd).xz;\n\tif(t>0.&&ison>0.) {\n        col = mix(col, vec3(3), smoothstep(.45, 1., fbm(3.*vuv/1e5,1.))*\n                                smoothstep(.25, .65, rd.y*.5 + .5)*.4);  \n    }\n    return clamp(ACESFilm(col), 0., 1.);\n} \n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n\n    float  m = 0.;\n    vec3 p = ro;\n    for (int i = 0; i<128;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32? ray.x*.45 : ray.x*.85; \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    ghs=shs;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n        alpha = d;\n      \tvec3 n = normal(p, d);\n         \n        vec3 lpos = vec3(-14.,9,-4.);\n        vec3 l = normalize(lpos-p);   \n        vec3 h = vec3(.5);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.0, 1., fresnel);\n        ref=vec3(.01); \n        // materials and bump\n        if(m==1.) {    \n            n = fxBumpMap(.05*T+hitPoint*.025, n, .15 ,d);\n            h = glintz(vec3(0.114,0.361,0.447), .01*T+hitPoint*.015, n, normalize(p-lpos), l);\n            ref = (h+.2)-fresnel;\n        }\n        if(m==2.) {   \n            h = glintz(vec3(0.945,0.753,0.533), hitPoint.zyx*.055, n, rd, l);\n            ref = (h*.5)-fresnel;\n        }\n        if(m==3.) {\n            ref = vec3(.7)-fresnel;\n        }\n        if(m==4.) {\n            h = mix(vec3(0.624,0.169,0.016),vec3(0.737,0.588,0.043),clamp(ghs*.85,0.,1.));\n            ref = (h*.5)-fresnel;\n        }\n        // diff and shadows\n        float diff = clamp(dot(n,l),.03,1.);\n        float shdw = 1., t = .3;\n        for(int i=0; i<18; i++){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) {shdw = .03; break;}\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = .5 * pow(max(dot(view, ret), 0.), 24.);\n\n        C += h * diff+spec;\n        C = mix(sky,C,  exp(-.000025*d*d*d));\n\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    return vec4(C,alpha);\n}\n\nvoid topLayer(inout vec3 C, vec2 uv) {\n    float px = fwidth(uv.x);\n    //uv*=tilt;\n    float bx = box(uv-vec2(.0,.02),vec2(.9,.475))-.0025;\n    float dx = abs(bx)-.001;\n    dx=smoothstep(px,-px,dx);\n    bx=smoothstep(-px,px,bx);\n\n    float bd = box(uv-vec2(.001,-.015),vec2(.86,.435))-.0025;\n    float sd =smoothstep(.085-px,px,bd);\n\n    vec3 ln = mix(vec3(0.647,0.545,0.435),vec3(0.208,0.588,0.753),.5+uv.y*.75);\n    C=mix(C,ln,bx);\n    if(hash21(uv)>.7)C=mix(C,C*.8,bx);\n    C=mix(C,C*.15,min(sd,bx));\n    \n    float en = noised(vec2(uv.y*20.,.1)).x*.05;\n    float tp = box(uv-vec2(en*.5,.5),vec2(.2,.025));\n    float ts = smoothstep(px,-px,tp);\n    tp = abs(tp)-.001;\n    tp=smoothstep(px,-px,tp);\n    C=mix(C,C*.2,ts);\n    C=mix(C,C*.6,tp);\n\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    mvt+= T*.5;\n    turn=rot(T*.2);\n\n    // uv + ro + rd\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vuv=uv;\n    float vv = uv.y;\n    midpt = .45*sin(vv*5.+T*1.15);\n\n    float zoom = 10.;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    float x = M.xy==vec2(0)?0.:(M.x/R.x * 1. - .5) * PI;\n    mat2 rx = rot(-.38531); mat2 ry = rot(-.38531+x);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fil=vec3(1.);\n    \n    // ref loop @BigWIngs\n    float d =0.;\n    // if slow reduce to 2\n    for(float i=0.; i<3.; i++) {\n        vec4 pass = render(ro, rd, ref, i==3.-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    \n    \n    C=clamp(C,vec3(0),vec3(1));\n    topLayer(C,uv);\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n// end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}