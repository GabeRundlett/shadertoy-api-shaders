{
    "Shader": {
        "info": {
            "date": "1723593810",
            "description": "This Code is a walk through of how it was built\nVideo here: https://youtu.be/RBx9zsxhIpk\nThis is pretty fun on webcam",
            "flags": 0,
            "hasliked": 0,
            "id": "XcSyzd",
            "likes": 22,
            "name": "ASCII Filter w/ Moving Chars",
            "published": 3,
            "tags": [
                "asdf"
            ],
            "usePreview": 1,
            "username": "Yusef28",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "//Top\n#define TUTORIAL_STEP 20\n\n\n/*\n\nHow to get around this code. \nSome people scroll through the code to find the section they want\nand they have to scroll back up to change the number of the tutorial \neach time. The \"Queen's Way\" is to use ctrl+f and enter \"step[tutorial #]\"\nand to get back to the top use ctrl+f and \"top\".\nBelow is a road map to help you with your journey.\n\n\n1. Sample The Font Texture\n2. Scale uv Down to Sample Just One Character\n3. Fix aspect ratio and observe\n4. (offset) Sample One Character with vec2 offset\n5. (id) Sample One Character by id conversion\n6. (zoom) Scale of the texture, character stays in bottom-left corner\n7. Fill a grid with One Character\n8. Get downscaled uv\n9. Get downscaled Luminance\n10. Basic ASCII Shader\n11. Animated Character\n12. Masking Animated Character\n13. add hash and voronoi quick recap\n14. put char*mask in voronoi grid\n15. make voronoi ascii\n16. randomize zooming and movement\n17. contrast (pow luminance & make first level a space)\n18. color palette\n19. outline sdf explaination\n20. add outline to main program\n21. try other char sets\n\n\n*/\n\n//hash22 by dave hoskins\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n#if TUTORIAL_STEP == 1 //step01\n\n//Sample The Font Texture\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 2 //step2\n\n//Scale uv Down to Sample Just One Character (Just vector(?))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(texture(iChannel0, uv/16.).r);\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 3 //step3\n\n//Fix aspect ratio and observe\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(texture(iChannel0, uv/16.).r);\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 4 //step4\n\n//(offset) Sample One Character with vec2 offset\n\n\nfloat char(vec2 uv, vec2 offset){\n    return texture(iChannel0, uv/16. + offset/16.).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(char(uv,vec2(1.,0.)));\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 5 //step5\n\n//(id) Sample One Character by id conversion\n\n\nfloat char(vec2 uv, float id){\n\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(char(uv,1.));\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#elif TUTORIAL_STEP == 6 //step6\n\n//(zoom) Scale of the texture, character stays in bottom-left corner\n\n\nfloat char(vec2 uv, float zoom, float id){\n    \n    uv *= zoom;\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float zoom = 5.+sin(iTime)*0.5;\n    vec3 col = vec3(char(uv,zoom,1.));\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 7 //step7\n\n//Fill a grid with ASCII\n\n\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float scale = 16.;\n    vec2 st = fract(uv*scale);\n    vec3 col = vec3(char(st,1.));\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 8 //step8\n\n//downscale a second texture with asp\n\n\nfloat char(vec2 uv, float id){\n    \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvec2 downscale(vec2 uv, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = floor(uv*amt)/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float scale = 16.;  \n    vec3 col = texture(iChannel1, downscale(uv,scale)).rgb;  \n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 9 //step9\n\n//get downscaled Luminance\nfloat char(vec2 uv, float id){\n    \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvec2 downscale(vec2 uv, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = floor(uv*amt)/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    float level = floor(luminance*max_levels);\n    return level;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float scale = 50.;\n    vec2 downscaledUV = downscale(uv,scale);\n    float max_levels = 10.;\n    float luminance = getLuminance(downscaledUV,max_levels);\n    vec3 col = vec3(luminance/max_levels);  \n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 10 //step10\n\n//get downscaled get Ascii id\n\n\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvec2 downscale(vec2 uv, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = floor(uv*amt)/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n     \n    float LEVELS[10] = float[10](222., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n\n    return LEVELS[int(luminance)];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 50.;\n    vec2 downscaledUV = downscale(uv,scale);\n    float max_levels = 10.;\n    float luminance = getLuminance(downscaledUV,max_levels);\n    float asciiID = ascii(luminance);\n    vec3 col = vec3(char(fract(scale*uv), asciiID)); \n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 11 //step11\n\n//animated character\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, \n    //so does our char\n\n    uv +=vec2(0.5);//after zoom, \n    //pushing down-left by 0.5 will center the char\n    \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 50.;\n\n    //Explain just zoom first and then position\n    vec2 position = vec2(0.);//0.5+vec2(cos(iTime),sin(iTime))*0.5;\n    float zoom = 5. + sin(iTime)*2.5;\n    float c = charAnimated(uv,position,zoom,23.);\n    vec3 col = vec3(c); \n    fragColor = vec4(col,1.0);\n}\n\n#elif TUTORIAL_STEP == 12 //step12\n\n//masking animated character\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n    uv -= p;\n    uv *= zoom;\n    uv +=vec2(0.5); \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    uv*= zoom;//and it will naturally zoom from center\n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y; \n    float scale = 50.;\n\n    //Explain just zoom first and then position\n    vec2 position = 0.5+vec2(cos(iTime),sin(iTime))*0.5;\n    float zoom = 5. + sin(iTime)*2.5;\n    float c = charAnimated(uv,position,zoom,23.);\n    float m = mask(uv,position,zoom);\n    vec3 col = vec3(c*m); \n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 13 //step13\n\n//voronoi quick recap\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n    \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscale(vec2 uv, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = floor(uv*amt)/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](222., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nfloat voronoiText(vec2 uv){\n    vec2 fl = floor(uv);\n    float d = 0.;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 o = 0.5+0.5*sin(hash22(n+fl)*2345.345+iTime*.2);\n            vec2 position = fl+n+o;\n            \n            float c = smoothstep(0.5,0.4,length(uv-position));\n            \n            //mix instead of distance\n            d = mix(d,1.,c);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 50.;\n    vec2 downscaledUV = downscale(uv,scale);\n    float max_levels = 10.;\n    float luminance = getLuminance(downscaledUV,max_levels);\n    float asciiID = ascii(luminance);\n    //again remember to switch mode to NOT mipmap\n    //vec3 col = vec3(char(fract(scale*(fragCoord/iResolution.y)), asciiID)); \n    \n    //Explain just zoom first and then position\n    //vec2 position = 0.5+vec2(cos(iTime),sin(iTime))*0.5;\n    //float zoom = 5. + sin(iTime)*2.5;\n    //float c = charAnimated(uv,position,zoom,23.);\n    //float m = mask(uv,position,zoom);\n    //vec3 col = vec3(c*m); \n    \n    vec3 col = vec3(voronoiText(uv*scale));\n    fragColor = vec4(col,1.0);\n}\n\n\n#elif TUTORIAL_STEP == 14 //step14\n\n//voronoi quick recap\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n    \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscale(vec2 uv, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = floor(uv*amt)/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](222., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nfloat voronoiText(vec2 uv){\n    vec2 fl = floor(uv);\n    float d = 0.;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 o = 0.5+0.5*sin(hash22(n+fl)*2345.345+iTime*.2);\n            vec2 position = fl+n+o;\n            \n            //float c = smoothstep(0.5,0.4,length(uv-p));\n            \n            //dropped in from our mainImage\n            float zoom = 1. + sin(iTime*2.)*.5;//lowered the zoom\n            float c = charAnimated(uv,position,zoom,23.);\n            float m = mask(uv,position,zoom);\n    \n            //mix instead of distance\n            d = mix(d,1.,c*m);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 50.;\n    vec2 downscaledUV = downscale(uv,scale);\n    float max_levels = 10.;\n    float luminance = getLuminance(downscaledUV,max_levels);\n    float asciiID = ascii(luminance);\n    //again remember to switch mode to NOT mipmap\n    //vec3 col = vec3(char(fract(scale*(fragCoord/iResolution.y)), asciiID)); \n    \n    //Explain just zoom first and then position\n    //vec2 position = 0.5+vec2(cos(iTime),sin(iTime))*0.5;\n    //float zoom = 5. + sin(iTime)*2.5;\n    //float c = charAnimated(uv,position,zoom,23.);\n    //float m = mask(uv,position,zoom);\n    //vec3 col = vec3(c*m); \n    \n    vec3 col = vec3(voronoiText(uv*scale));\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#elif TUTORIAL_STEP == 15 //step15\n\n//change scale to 80\n//Make Voronoi ASCII \n//adjust voronoi to take scale input\n//add new downscaleVoornoi function that takes a voronoi id\nfloat char(vec2 uv, float id){\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n}\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscale(vec2 uv, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = floor(uv*amt)/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nvec2 downscaleVoronoi(vec2 id, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = id/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](222., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nfloat voronoiText(vec2 uv, float scale){\n\n    vec2 fl = floor(uv);\n    float d = 0.;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 o = 0.5+0.5*sin(hash22(n+fl)*2345.345+iTime*.2);\n            vec2 position = fl+n+o;\n            \n            //downscaleVoronoi takes the cell id instead of uv\n            vec2 downscaledUV = downscaleVoronoi(n+fl,scale);\n            float max_levels = 10.;\n            float luminance = getLuminance(downscaledUV,max_levels);\n            float asciiID = ascii(luminance);\n            //float c = smoothstep(0.5,0.4,length(uv-p));\n            //dropped in from our main image\n            float zoom = 1.2 + sin(iTime*2.);//lowered the zoom\n            float c = charAnimated(uv,position,zoom,asciiID);\n            float m = mask(uv,position,zoom);\n    \n            //mix instead of distance\n            d = mix(d,1.,c*m);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 80.;\n    vec2 downscaledUV = downscale(uv,scale);\n    float max_levels = 10.;\n    float luminance = getLuminance(downscaledUV, max_levels);\n    float asciiID = ascii(luminance);\n    //again remember to switch mode to NOT mipmap\n    //vec3 col = vec3(char(fract(scale*(fragCoord/iResolution.y)), asciiID)); \n    \n    //Explain just zoom first and then position\n    //vec2 position = 0.5+vec2(cos(iTime),sin(iTime))*0.5;\n    //float zoom = 5. + sin(iTime)*2.5;\n    //float c = charAnimated(uv,position,zoom,23.);\n    //float m = mask(uv,position,zoom);\n    //vec3 col = vec3(c*m); \n    \n    vec3 col = vec3(voronoiText(uv*scale,scale));\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#elif TUTORIAL_STEP == 16 //step16\n\n//use hashOut and randomize zooming \n//and change zoom amount in voronoi\n//and increase the movement speed so things move\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscaleVoronoi(vec2 id, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = id/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](222., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nfloat voronoiText(vec2 uv, float scale){\n\n    vec2 fl = floor(uv);\n    float d = 0.;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 hashOut = hash22(n+fl);\n            vec2 o = 0.5+0.5*sin(hashOut*2345.345+iTime*4.);\n            vec2 position = fl+n+o;\n            \n            //downscaleVoronoi takes the cell id instead of uv\n            vec2 downscaledUV = downscaleVoronoi(n+fl,scale);\n            float max_levels = 10.;\n            float luminance = getLuminance(downscaledUV,max_levels);\n            float asciiID = ascii(luminance);\n            //float c = smoothstep(0.5,0.4,length(uv-p));\n            //dropped in from our main image\n            //animate zoom\n            float zoom = 0.8+0.4*sin(iTime*2.+hashOut.x*852.);//lowered the zoom\n            float c = charAnimated(uv,position,zoom,asciiID);\n            float m = mask(uv,position,zoom);\n    \n            //mix instead of distance\n            d = mix(d,1.,c*m);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 80.;\n\n\n    vec3 col = vec3(voronoiText(uv*scale,scale));\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#elif TUTORIAL_STEP == 17 //step17\n\n//contrast\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscaleVoronoi(vec2 id, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = id/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    luminance = pow(luminance*1.5, 2.);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](208., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nfloat voronoiText(vec2 uv, float scale){\n\n    vec2 fl = floor(uv);\n    float d = 0.;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 hashOut = hash22(n+fl);\n            vec2 o = 0.5+0.5*sin(hashOut*2345.345+iTime*4.);\n            vec2 position = fl+n+o;\n            \n            //downscaleVoronoi takes the cell id instead of uv\n            vec2 downscaledUV = downscaleVoronoi(n+fl,scale);\n            float max_levels = 10.;\n            float luminance = getLuminance(downscaledUV,max_levels);\n            float asciiID = ascii(luminance);\n            //float c = smoothstep(0.5,0.4,length(uv-p));\n            //dropped in from our main image\n            //animate zoom\n            \n            float zoom = 0.8+0.4*sin(iTime*2.+hashOut.x*852.);//lowered the zoom\n            float c = charAnimated(uv,position,zoom,asciiID);\n            float m = mask(uv,position,zoom);\n    \n            //mix instead of distance\n            d = mix(d,1.,c*m);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 80.;\n\n\n    vec3 col = vec3(voronoiText(uv*scale,scale));\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#elif TUTORIAL_STEP == 18 //step18\n\n//color, let voronoi return a vec3 \n//change d to a vec3 \n//add palette function\n//return vec3 to col\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscaleVoronoi(vec2 id, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = id/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    luminance = pow(luminance*1.5, 2.);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](208., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nvec3 pallete(float x){\n    return 0.6+0.4*cos(vec3(1.,2.,4.)/1.5 + x*80.);\n}\n\nvec3 voronoiText(vec2 uv, float scale){\n\n    vec2 fl = floor(uv);\n    vec3 d = vec3(0.,0.,0.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 hashOut = hash22(n+fl);\n            vec2 o = 0.5+0.5*sin(hashOut*2345.345+iTime*4.);\n            vec2 position = fl+n+o;\n            \n            //downscaleVoronoi takes the cell id instead of uv\n            vec2 downscaledUV = downscaleVoronoi(n+fl,scale);\n            float max_levels = 10.;\n            float luminance = getLuminance(downscaledUV,max_levels);\n            float asciiID = ascii(luminance);\n            //float c = smoothstep(0.5,0.4,length(uv-p));\n            //dropped in from our main image\n            //animate zoom\n            \n            float zoom = 0.8+0.4*sin(iTime*2.+hashOut.x*852.);//lowered the zoom\n            float c = charAnimated(uv,position,zoom,asciiID);\n            float m = mask(uv,position,zoom);\n    \n            //mix instead of distance\n            d = mix(d,pallete(hashOut.y*800.),c*m);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float scale = 80.;\n    vec3 col = voronoiText(uv*scale,scale);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n#elif TUTORIAL_STEP == 19 //step19\n\n//add the outline character function\n//use the sdf version of the character\n//show how to make a nice outline\n\n//masking animated character\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n    uv -= p;\n    uv *= zoom;\n    uv +=vec2(0.5); \n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\n\nvec2 charAndOutline(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;\n    uv *= zoom;\n    uv +=vec2(0.5);\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.; \n    \n    float d = texture(iChannel0, uv/16. + cell).a;//sdf\n    \n    //return two sizes of smoothstepped sdf\n    return vec2(smoothstep(0.5,0.48,d),\n                smoothstep(0.55,0.5,d)\n                );\n}\n\nfloat mask(vec2 uv, vec2 p, float zoom){\n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    uv*= zoom;//and it will naturally zoom from center\n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y; \n\n    vec2 position = 0.5+vec2(cos(iTime),sin(iTime))*0.5;\n    float zoom = 5. + sin(iTime)*2.5;\n    //float c = charAnimated(uv,position,zoom,23.);\n    vec2 sdf = charAndOutline(uv,position,zoom,23.);\n    float m = mask(uv,position,zoom);\n    \n    sdf *= m;//mask both sizes\n    \n    vec3 col = vec3(0.6);//grey bg for clarity\n    col = mix(col,vec3(0.),sdf.y);//larger sdf as black\n    col = mix(col,vec3(1.),sdf.x);//smaller sdf as white\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n#elif TUTORIAL_STEP == 20 //step20\n\n//add outline to main program\n\nfloat charAnimated(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;//pulling on (0.5,0.5) as with (0,0)\n\n    uv *= zoom;//(0,0) stays in bottom left corner, so does our char\n\n    uv +=vec2(0.5);//after zoom, pushing down-left by 0.5 will center the char\n\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.;\n    \n    //so this is like a 0 to 1/16 window we move with cell\n    return texture(iChannel0, uv/16. + cell).r;\n\n}\n\nvec2 charAndOutline(vec2 uv, vec2 p, float zoom, float id){\n\n    uv -= p;\n    uv *= zoom;\n    uv +=vec2(0.5);\n    vec2 cell = vec2(mod(id,16.), floor(id/16.))/16.; \n    \n    float d = texture(iChannel0, uv/16. + cell).a;//sdf\n    \n    //return two sizes of smoothstepped sdf\n    return vec2(smoothstep(0.5,0.48,d),\n                smoothstep(0.55,0.5,d)\n                );\n}\n\nfloat mask(vec2 uv, vec2 p, float zoom){\n\n    \n    uv -= p;//since sdfs start an origin we just pull on (0,0) to move\n    \n    uv*= zoom;//and it will naturally zoom from center\n    \n    vec2 st = abs(uv)-vec2(0.5);//basic sdf square with 0.5 dimentions\n    float d = max(st.x, st.y);\n    return 1.-step(0.,d);//get the compliment for masking\n}\n\nvec2 downscaleVoronoi(vec2 id, float amt){\n    float aspect_ratio = iResolution.x/iResolution.y;\n    vec2 downscaledUV = id/vec2(amt*aspect_ratio,amt);\n    return downscaledUV;\n}\n\nfloat getLuminance(vec2 downscaledUV, float max_levels){\n    \n    vec3 video = texture(iChannel1, downscaledUV).rgb;\n    float luminance = dot(vec3(0.299,0.587,0.114), video);\n    luminance = pow(luminance*1.5, 2.);\n    float level = floor(luminance*max_levels);///max_levels;\n    return level;\n}\n\nfloat ascii(float luminance){\n    \n    float LEVELS[10] = float[10](208., 107., 97., 74., \n                                 159., 237., 89., 176., \n                                 243., 244.); \n    \n    return LEVELS[int(luminance)];\n}\n\nvec3 pallete(float x){\n    return 0.6+0.4*cos(vec3(1.,2.,4.)/1.5 + x*80.);\n}\n\nvec3 voronoiText(vec2 uv, float scale){\n\n    vec2 fl = floor(uv);\n    vec3 d = vec3(0.,0.,0.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 n = vec2(i,j);\n            vec2 hashOut = hash22(n+fl);\n            vec2 o = 0.5+0.5*sin(hashOut*2345.345+iTime*4.);\n            vec2 position = fl+n+o;\n            \n            //downscaleVoronoi takes the cell id instead of uv\n            vec2 downscaledUV = downscaleVoronoi(n+fl,scale);\n            float max_levels = 10.;\n            float luminance = getLuminance(downscaledUV,max_levels);\n            float asciiID = ascii(luminance);\n            //float c = smoothstep(0.5,0.4,length(uv-p));\n            //dropped in from our main image\n            //animate zoom\n            \n            float zoom = 0.8+0.4*sin(iTime*2.+hashOut.x*852.);//lowered the zoom\n            vec2 c = charAndOutline(uv,position,zoom,asciiID);\n            float m = mask(uv,position,zoom);\n            c *= m;\n            //mix instead of distance\n            d = mix(d,vec3(0.),c.y);\n            d = mix(d,pallete(hashOut.y*800.),c.x);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float scale = 80.;\n    vec3 col = voronoiText(uv*scale,scale);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n//INTRODUCTION\n\n#elif TUTORIAL_STEP == 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}