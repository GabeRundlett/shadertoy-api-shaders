{
    "Shader": {
        "info": {
            "date": "1652281748",
            "description": "https://en.wikipedia.org/wiki/Simplex_noise\n\ncamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "7lsBRr",
            "likes": 0,
            "name": "Simplex Noise 3d",
            "published": 3,
            "tags": [
                "noise",
                "simplex"
            ],
            "usePreview": 1,
            "username": "TinyTexel",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    camera controls via mouse + shift key\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\nfloat ReadKey      (int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(iChannel0, ivec2(cx, cy), 0).w;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 AA[8], BB[8], CC[8], DD[8];\nvec4 A0, B0, C0, D0;\nvec4 A1, B1, C1, D1;\n\nbool ImplicitRC(vec3, vec3, float, float, float, float, float, out float, out float, out float);\nbool ImplicitRC(vec3, vec3, float, float, float, float, float, out float, out float, out float, inout vec3);\n    \n//======================================================================//\n//////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////\n//======================================================================//\n\nfloat SimplexNoise(vec3 x, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n    vec3 v1 = min(m0.xyz, m1.yzx);\n    vec3 v2 = max(m0.xyz, m1.yzx);\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define DIR(x) normalize(Hash11x3(x, seed))\n     \n    vec4 d;\n\td.x = dot(DIR(xb + v0), off0);\n\td.y = dot(DIR(xb + v1), off1);\n\td.z = dot(DIR(xb + v2), off2);\n\td.w = dot(DIR(xb + v3), off3);    \n         \n    #undef DIR\n    \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    \n    return dot(d, w * w * w) * 4.73;\n}\n\nfloat TriWave(float x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\nvec2  TriWave(vec2  x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\nvec3  TriWave(vec3  x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\nvec4  TriWave(vec4  x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\n\nfloat SimplexNoise(vec3 x, float time, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n    vec3 v1 = min(m0.xyz, m1.yzx);\n    vec3 v2 = max(m0.xyz, m1.yzx);\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define DIR(x) (TriWave(Hash11x3(x, seed) + time * vec3(1.0, 0.91, 1.13)))\n     \n    vec4 d;\n\td.x = dot(DIR(xb + v0), off0);\n\td.y = dot(DIR(xb + v1), off1);\n\td.z = dot(DIR(xb + v2), off2);\n\td.w = dot(DIR(xb + v3), off3);    \n         \n    #undef DIR\n    \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    \n    return dot(d, w * w * w) * 4.73;\n}\n\n//======================================================================//\n//////////////////////////////////////////////////////////////////////////\n\nfloat sdBoxE(vec3 p, vec3 b, float r, float e)\n{\n    b -= r;\n    \n    vec3 d = abs(p)-b;\n    vec3 x = max(d, 0.0);\n    \n    float u = pow(dot(pow(abs(x), vec3(e)), vec3(1.0)), 1.0/e);\n    \n    return u + min(max(d.x, max(d.y, d.z)), 0.0) - r;\n}\n\nfloat Map(vec3 x)\n{\n    \n    float f0;\n    if(ReadKeyToggle(KEY_SPACE) == 0.0)\n    {\n        f0 = length(x) - 0.5;\n    }\n    else\n    {\n        float e = 8.0;\n        f0 = sdBoxE(x, vec3(0.51), 0.125, 4.0);\n    }\n    \n\n    float f = f0;\n    \n    for(float i = 0.0; i < 1.0; ++i)\n    f += SimplexNoise(x * A0.x * 16.0 * (exp2(i)), iTime, 25632u) * B0.x*0.125 * exp2(-i);\n    \n    return f;\n}\n\n\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd, mat3 cmat, bool shadowRay,\nout float t, out vec3 n, out vec3 col)\n{\n    float hit = 0.0;\n    t = 1e10;\n    col = vec3(0.0);\n    \n    vec2 tt; vec3 n0, n1;\n    float th = Intersect_Ray_Cube(rp, rd, vec3(0.0, 0.0, 0.0), vec3(0.55), tt, n0, n1);\n\n    if(th > 0.0)\n    if(hit <= 0.0 || tt.x < t)\n    {   \n        bool inside = tt.y < 0.0;\n\n        vec3 p = inside ? rp : rp + rd * tt.x;\n\n        float intervalLen = inside ? tt.x : tt.y - tt.x;\n        float stepCount = 64.0;\n        float minBinaryCount = shadowRay ? 0.0 : 4.0;\n        float sdfBlendF = 0.0;\n        float minStepF = 0.0;\n\n        float t0, tm, t1;\n\n        vec3 N = inside ? -rd : n0;\n        bool th2 = ImplicitRC(p, rd, intervalLen, stepCount, minBinaryCount, sdfBlendF, minStepF, /*out*/ t0, tm, t1, N);\n\n        if(th2)\n        {\n            hit = 1.0;\n\n            t = (inside ? 0.0 : tt.x) + tm;\n\n            //vec3 p = rp + rd * t;\n            p += rd * t1;\n\n            n = normalize(N);\n            n = normalize(vec4(N, exp2(-16.0))).xyz;\n\n            //float c = cellTile(p*B0.x * 80.0);\n            float c = Map(p);\n            //n = normalize(cellIdB - cellIdA);\n           // if(dot(-rd,n)<0.0)n=-n;\n            col = EvalWaxMtl(-rd * cmat, n * cmat);\n            \n            //col = mix(col.gbr * c, col, sqrt(c));\n\n            //float ha = fract(dot(cellIdA, rPhif3));\n            //float hb = fract(dot(cellIdB, rPhif3));\n            //float hc = fract((ha*1.0 + hb) * rPhif1);\n            //\n            //col = n * 0.5 + 0.5;\n            //col = hc*vec3(1.0);\n            //col *= fract(dot(cellId, rPhif3));\n\n            if(t0 == 0.0) col = col.gbr;\n        }\n    }\n\n    return hit;\n}\n\n\nvec3 EvalSceneCol(vec3 rp, vec3 rd, mat3 cmat, vec3 light)\n{\n    vec3 col = vec3(0.0119);\n    \n    #if 1\n    {\n        bvec2 a = bvec2(rd.y > 0.0, abs(rd.y) > 0.8);\n        \n        bool b = (rd.x > 0.0) != (rd.z > 0.0); \n        \n        col = b != a.y ? col * (a.x ? 1.2 : 0.6) : col * (a.x ? 1.5 : 0.7);\n    }\n    #endif\n    \n    #if 1\n    if(ReadKeyToggle(KEY_Q) != 0.0)\n    {\n        float s = 0.25;\n        float r = 0.96;\n        col = mix(col, vec3(1.0, rd.x < 0.0 ? 0.125 : 0.0, 0.0), abs(rd.x) < r ? 0.0 : s);\n        col = mix(col, vec3(0.0, 1.0, rd.y < 0.0 ? 0.500 : 0.0), abs(rd.y) < r ? 0.0 : s);\n        col = mix(col, vec3(rd.z < 0.0 ? 0.250 : 0.0, 0.0, 1.0), abs(rd.z) < r ? 0.0 : s);\n    }\n    #endif\n    \n    float t; vec3 n; vec3 c;\n    float hit = Intersect_Scene(rp, rd, cmat, false, t, n, c);\n \n    if(hit > 0.0)\n    {\n        vec3 p = rp + rd * t;\n\n        col = c;\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    ivec2 uvi = ivec2(uv);\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n\n    for(int i = 0; i < KnobMatCount; ++i)\n    {\n        int KnobMatId = i;\n        ivec2 KnobMatStateBuffOrigin = ivec2(KnobMatId * 4, KnobMatStateBuffY0);\n\n        #define READ(xy) texelFetch(iChannel0, xy + KnobMatStateBuffOrigin, 0).w;\n        \n        for(int j = 0; j < 4; ++j)\n        {\n            AA[i][j] = READ(ivec2(j, 0));\n            BB[i][j] = READ(ivec2(j, 1));\n            CC[i][j] = READ(ivec2(j, 2));\n            DD[i][j] = READ(ivec2(j, 3));\n        }\n        \n        #undef READ\n    }\n        \n    A0 = AA[0]; B0 = BB[0]; C0 = CC[0]; D0 = DD[0];\n    A1 = AA[1]; B1 = BB[1]; C1 = CC[1]; D1 = DD[1];\n    \n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.2);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(Pi * -0.5, -Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(0.2 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.7;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    float txlSize = 1.0 / iResolution.x * 2.0;\n    vec2 tc = uv0.xy * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n   \n   #if 0\n\n    vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n    \n    col = EvalSceneCol(cpos, rd, cmat, light);  \n    \n   #elif 1\n\n    //vec2 flip = vec2(1.0, (fract(uv.x * 0.5) * 4.0 - 1.0) * (fract(uv.y * 0.5) * 4.0 - 1.0));\n    vec2 flip = fract(uv.yx * 0.5) * 4.0 - 1.0;\n    vec3 off = vec3(2.0, 0.0, -2.0) / 6.0;\n\n    for(uint i = 0u; i < 3u; ++i)\n   \t{\n        vec3 rd = normalize(cmat * vec3(tc + off.xy*flip * txlSize, focalLen)); \n\n        off = off.zxy;\n        \n     \tcol += EvalSceneCol(cpos, rd, cmat, light);  \n    }\n    \n    col /= 3.0;\n    \n   #elif 1\n    \n    vec2 off0 = vec2(0.0);\n    vec4 off = vec4(-2.0, -4.0, 4.0, 2.0) * 0.1;\n    \n    for(uint i = 0u; i < 5u; ++i)\n   \t{\n    \tvec3 rd = normalize(cmat * vec3(tc + off0 * txlSize, focalLen)); \n         \n     \tcol += EvalSceneCol(cpos, rd, cmat, light); \n        \n        off = off.zxwy;\n        off0 = off.xy;\n    }\n    \n    col *= 0.2;\n    \n   #endif\n\n   #if 1\n    if(ReadKeyToggle(KEY_TAB) != 0.0 && (IsKnobUITexel(uv) || IsNumValueUITexel(uv)))\n    {    \n        col = mix(col, col * 0.125 + 0.004, GetKnobUIMask(uv));\n\n        // knobs\n        vec3 ui = texelFetch(iChannel0, ivec2(uv), 0).rgb;\n\n        vec3 kcol = vec3(1.0);\n        if(ui.z <  0.0) kcol = vec3(0.0, 0.0, 0.0); else\n        if(ui.z == 1.0) kcol = vec3(1.0, 0.0, 0.0); else\n        if(ui.z == 2.0) kcol = vec3(0.0, 0.5, 0.0); else\n        if(ui.z == 3.0) kcol = vec3(0.0, 0.0, 1.5); else\n        if(ui.z == 4.0) kcol = vec3(0.9, 0.9, 0.0); else\n        if(ui.z == 5.0) kcol = vec3(0.0, 0.8, 0.8); else\n        if(ui.z == 6.0) kcol = vec3(0.8, 0.0, 0.8);\n    \n       #if 0\n        col = mix(col, kcol, ui.y);\n        col = mix(col, vec3(0.99), ui.x);\n       #else\n        col = mix(col, vec3(0.0), ui.y);\n        col = mix(col, mix(kcol, vec3(1.0), 0.25)*0.8, ui.x);\n       #endif\n    }\n   #endif    \n\n    #if 1\n    {\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s *= s; s *= s; s = 1.0 - s;\n        float u = 1.0 - sqrt(s.x*s.y);\n        col *= mix(1.0, 0.75, u*u);\n    }\n    #endif\n    \n    #if 1\n    {\n        float r2 = fract(dot(uv, vec2(0.7548776662, 0.56984029)));\n        r2 = abs(r2 * 2.0 - 1.0);\n        col += (r2 - 0.5) * 0.001;\n    }\n    #endif\n    \n\toutCol = vec4(sRGB_Encode(clamp01(col)), 1.0);\n    //outCol = vec4(col, 1.0);\n}\n\n\n\n\n// ========================================================= RAY MARCHING ROUTINES =====================================================================\n\nbool ImplicitRC(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n    float sdfBlendF,\n    float minStepF,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit ? (t0 + t1) * 0.5 : \n                   clamp(mix(i * ts, tm + f, sdfBlendF), tm + ts * minStepF, intervalLen);\n\n        vec3 p = x + dir * tm;\n\n        f = Map(p);\n\n        if (f < 0.0)\n        {\n            t1 = tm;\n            f1 = f;\n\n            if (minBinaryCount == 0.0)\n            {\n                hit = true;\n            }\n            else\n            if(!hit)\n            {\n                hit = true;\n\n                i = min(i, stepCount - minBinaryCount);\n            }\n        }\n        else\n        {\n            t0 = tm;\n            f0 = f;\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n\nbool ImplicitRC(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n    float sdfBlendF,\n    float minStepF,\n\n    out float t0, out float tm, out float t1, inout vec3 N)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    bool calcN = false;\n    vec3 e = vec3(1.0);\n    \n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit || calcN ? (t0 + t1) * 0.5 : \n                            clamp(mix(i * ts, tm + f, sdfBlendF), tm + ts * minStepF, intervalLen);\n\n        vec3 p = x + dir * tm;\n\n        p += e * (calcN ? exp2(-14.0) : 0.0);\n            \n        f = Map(p);\n\n\t\tif(calcN)\n        {\n            N += e * f;\n            e = vec3(e.z, -e.yx);            \n        }\n        else\n        {\n            if (f < 0.0)\n            {\n                t1 = tm;\n                f1 = f;\n\n                if (minBinaryCount == 0.0)\n                {\n                    hit = true;\n                }\n                else\n                if(!hit)\n                {\n                    hit = true;\n                    \n                    if(i == 0.0) return true;\n                    \n                    i = min(i, stepCount - minBinaryCount);\n                }\n            }\n            else\n            {\n                t0 = tm;\n                f0 = f;\n            }\n            \n            if(i == stepCount)\n            {\n                N = vec3(0.0);\n            \n                calcN = true;\n                i = 0.0;\n                stepCount = 4.0;\n            }\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define KeyBoard iChannel1\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nbool IsKnobStateTexel(vec2 uv)\n{\n    return uv.x < float(KnobMatCount) * 4.0 && uv.y >= float(KnobMatStateBuffY0) && uv.y < float(KnobMatStateBuffY0 + 4);\n}\n\nbool IsActiveTexel(vec2 uv)\n{\n    // state variables\n    if(uv.y < 4.0) return true;\n\n    // knob states\n    if(IsKnobStateTexel(uv)) return true;\n\n    // UI\n    {\n        // numerical value\n        if(IsNumValueUITexel(uv)) return true;\n        \n        if(IsKnobUITexel(uv)) return true;\n    }\n    \n    return false;\n}\n\nbool HandleStateAndDrawUI( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    //if(IsActiveTexel(uv) == false) return false;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n    //float numKeyLast    = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    //float numKey = \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n    {\n        float i;\n        if((i = KnobMatIdButtonMat(iMouseClick.xy)) >= 0.0)\n        {\n            if(isClick)\n            ActiveKnobMatId = int(i);\n            \n            didInteractUI = true;\n        }\n    }\n        \n    // if current texel holds a knobs state update it if necessary\n    if(IsKnobStateTexel(uv))\n    {\n        int ActiveKnobMatIdTemp = ActiveKnobMatId;\n        \n        ActiveKnobMatId = int(uint(uv.x) / 4u);\n        \n        bool IsKnobMatActuallyActive = ActiveKnobMatId == ActiveKnobMatIdTemp;\n        \n        ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n    \n        KnobState knob;\n    \tif(GetKnob(ivec2(uv) - KnobMatStateBuffOrigin, iChannel0, /*doInit:*/ frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick && IsKnobMatActuallyActive && knob.colId >= 0.0)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                float n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                //n = round(n*32.0)/32.0;\n                knob.n = n;\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;// write knob state\n        }\n        \n        ActiveKnobMatId = ActiveKnobMatIdTemp;\n    }\n    \n    // check for knob interaction (irrespective of whether current texel holds a knobs state or not)\n    float knobVal = 0.0;\n    {\n        KnobState knob;\n        if(GetKnob(iMouseClick.xy, iChannel0, /*doInit:*/ false, /*out*/ knob))\n        {\n            knobVal = knob.n;\n            didInteractUI = true;\n        }\n    }\n\n    // draw knob mat UI\n    {\n        KnobState knob;\n        \n        if(GetKnob(uv0, iChannel0, /*doInit:*/ frameAccuLast == 0.0, /*out*/ knob))\n        {\n            vec3 k = Knob(uv0, knob);\n            col.rgb = k;\n        }\n        \n    \tValueText(col, uv0, knobVal, iChannel2);\n        KnobMatIdButtonMat(col, uv0);\n    }\n    \n\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(float(ActiveKnobMatId), J);\n\n    WriteVar2(iMouseClick,  J);\n    \n    return true;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\n    if(!HandleStateAndDrawUI(col, uv0)) return;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 Resolution;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat sRGB_Encode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_Decode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_Encode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_Decode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n\nvec3 EvalWaxMtl(vec3 V, vec3 N)\n{\n    vec3 up = normalize(vec3(0.0, 1.0, -1.0));\n    vec3 Ld = normalize(vec3(0.5, 1.0, -0.4));\n    vec3 L  = normalize(vec3(0.75, 0.5, -1.0));\n    \n    float LdN = dot(L, N);\n    float VdN = dot(V, N);\n    vec3 H = normalize(V + L);\n\tvec3 Hr = vec3(-H.xy, H.z);\n    \n    vec3 R = N * (2.0 * dot(N, V)) - V;\n\n    float f = Pow3(clamp01(dot(N, V)));\n    \n    vec3 c = vec3(1.0, 0.04, 0.03) * 0.2;\n    c *= 1.0 + f * 0.1;\n\n    float diff = cubic(clamp01(dot(N, Ld) * 0.5 + 0.5));\n    \n    float fd = mix(f, 1.0, diff);\n\n    vec3 col = mix(vec3(1.0, 0.0, 0.0)*diff*0.15,c, clamp01(dot(N, Ld)*0.8+0.2))*fd;\n\n    float s = 0.5;\n    col += (1.0/(1.025- clamp01(dot(N, H )))) * (s*0.0015*vec3(0.75, 0.9, 1.0))*cubic(clamp01(dot(R, up)*2.))*1.5;\n    col += (1.0/(1.03 - clamp01(dot(N, Hr)))) *    0.0002*vec3(0.25, 0.6, 1.0);\n    col += vec3(0.0, 0.5, 1.0) * (0.02*s) * cubic(clamp01((dot(R, up)*0.75+0.25)*2.));\n\n    col += vec3(1.0, 0.1, 0.3)*0.05 *(1.0-fd)*f;\n    col += vec3(1.0)*0.1*(1.0-diff)*(1.0-clamp01(VdN))*(c*c+c);\n    col *= mix(1.0, 0.75, Pow4(1.0-clamp01(VdN)));\n    col *= 1.3;\n    \n    float fuzz = Pow4(clamp01(LdN) / (clamp01(LdN) + clamp01(VdN) + exp2(-16.0)));\n    col += fuzz * diff * (0.1 * vec3(0.1, 0.8, 1.0));\n    \n    col *= mix(0.5, 1.0, sqrt(clamp01(dot(N, V)))) * 1.05;\n    \n    return col;\n}\n\n\n// ===============================================  KNOB STUFFS  =========================================================================== //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    float colId;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.colId = 0.0;\n    state.n = n;\n\n    return state;\n}\n\nint ActiveKnobMatId = 0;\n\nconst int KnobMatCount = 1;// <=== set this to number of matrices you want to use \nconst int KnobMatKnobCount = 16;\nconst int KnobCount = KnobMatKnobCount * KnobMatCount;\n\nconst int KnobMatStateBuffY0 = 4;\n\nconst float KnobOuterRadius = 16.0; \nconst float KnobCircleThick =  4.0; \nconst float KnobPadding     =  4.0; \nconst float KnobSizeTotal   =  2.0 * (KnobOuterRadius + KnobPadding);\nfloat GetKnobMatPosY0() { return Resolution.y*0.5 + (KnobSizeTotal*2.0); } \nfloat GetKnobMatPosY1() { return Resolution.y*0.5 - (KnobSizeTotal*2.0); } \n\nivec2 GetKnobMatStateBuffOrigin()\n{\n    return ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n}\n\nivec2 GetKnobXY(vec2 uv)\n{\n    int x = int(floor(uv.x / KnobSizeTotal));\n    int y = int(floor((GetKnobMatPosY0() - uv.y) / KnobSizeTotal));\n    \n    if(x < 0 || x >= 4 || y < 0 || y >= 4) return ivec2(-1, -1);\n    \n    return ivec2(x, y);\n}\n\nfloat ReadKnobValue(sampler2D stateBuffer, ivec2 xy)\n{\n    return texelFetch(stateBuffer, GetKnobMatStateBuffOrigin() + xy, 0).w;\n}\n\nbool IsKnobUITexel(vec2 uv)\n{\n    float width = KnobSizeTotal * 4.0;\n\n    if(uv.x < width+4.0 && uv.y > GetKnobMatPosY1()-4.0 && uv.y < GetKnobMatPosY0() + 48.0+2.0)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nfloat GetKnobUIMask(vec2 uv)\n{\n    float width = KnobSizeTotal * 4.0 + 0.0;\n\n    float minY = GetKnobMatPosY1() - 1.0;\n    float maxY = GetKnobMatPosY0() + 48.0 - 2.0;\n\n    float r = 8.0;\n\n    vec2 p = uv - vec2(width, maxY + minY) * 0.5;\n    vec2 b = vec2(width, maxY - minY) * 0.5 - r;\n    vec2 d = max(abs(p) - b, 0.0);\n    \n    return 1.0 - clamp01((dot(d, d) - r*r)*0.05);\n}\n\nbool IsNumValueUITexel(vec2 uv)\n{\n    if(uv.x < 51.0 && uv.y < 17.0) return true;\n}\n\nKnobState CreateMatKnob(ivec2 xy, bool signed, float n, float colId)\n{\n    float x = float(xy.x);\n    float y = float(xy.y);\n    \n    KnobState knob;\n    knob.p.x = 0.5 * KnobSizeTotal + x * KnobSizeTotal;\n    knob.p.y = 0.5 * KnobSizeTotal + y * KnobSizeTotal;\n    \n    knob.p.y = GetKnobMatPosY0() - knob.p.y;\n\n    knob.r = vec2(KnobOuterRadius, KnobCircleThick);\n    knob.signed = signed;\n    knob.colId = colId;\n\n\tknob.n = n;\n    \n    return knob;\n}\n\nbool GetKnob0(ivec2 xy, out KnobState knob)\n{\n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    if(xy.x < 0 || xy.x > 3 || \n       xy.y < 0 || xy.y > 3) return false;\n\n    if(ActiveKnobMatId < 0 || ActiveKnobMatId >= KnobMatCount) return false;\n\n    int i = xy.x + xy.y * 4;\n    \n    i += ActiveKnobMatId * KnobMatKnobCount;\n    \n    const bool fals = false;\n    const bool IsSigned[] = bool[]\n    (\n        //========  0  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  1  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  3  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        false\n    );\n    \n    const float DefaultValue[] = float[]\n    (\n        //======  0  ======//\n        0.3, 0.0, 0.0, 0.,// A \n        0.5, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n        \n        //======  3  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n       \n        0.0\n    );\n    \n    const float ColId[] = float[]\n    (\n        //======  0  ======//\n        0.0, -.1, -.1, -.1,// A \n        0.0, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n    \n        //======  1  ======//\n        -.1, -.1, -.1, -.1,// A \n        -.1, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n        \n        //======  3  ======//\n        -.1, -.1, -.1, -.1,// A \n        -.1, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n        \n        0.0\n    );    \n    \n    knob = CreateMatKnob(xy, IsSigned[i], DefaultValue[i], ColId[i]);\n    \n    return true;\n}\n\n\n// get knob by position id xy\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    // fill knob with hardcoded settings\n\tif(!GetKnob0(xy, /*out*/ knob)) return false;\n    \n    // fill in knob value stored in state buffer\n    if(!doInit) knob.n = ReadKnobValue(stateBuffer, xy);\n    \n    return true;\n}\n\n// get knob by uv\nbool GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    ivec2 xy = GetKnobXY(uv);\n    \n    // is position id valid\n    if(xy.x == -1 || xy.y == -1) return false;\n    \n    // does knob actually exist\n    if(!GetKnob0(xy, /*out*/ knob)) return false;\n\n    // does uv lie on knob disk\n    if(SqrLen(uv - knob.p) >= Pow2(knob.r.x + KnobPadding)) return false;\n    \n    // fill in knob value stored in state buffer\n    if(!doInit) knob.n = ReadKnobValue(stateBuffer, xy);\n\n    return true;\n}\n\n\nvec3 Knob(vec2 uv, KnobState state)\n{\n    //if(state.colId < 0.0) return vec3(0.0);\n    if(state.colId < 0.0) { state.n = 0.0; state.r.x *= 0.5; state.r *= 1.5; }\n    \n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.18);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0., 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.25, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    \n    if(state.colId < 0.0) { r *= 0.25; sh = 1.0; }\n    \n    return vec3(r, 1.0 - sh, state.colId);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph, sampler2D glyphBuffer)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(glyphBuffer, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n, sampler2D glyphBuffer)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c, glyphBuffer);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf);// * 0.999;\n}\n\nfloat KnobMatIdButtonMat(inout vec4 col, vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n    \n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    float ButtonCountX = 4.0;\n    float ButtonCountY = 2.0;\n\n    if(uv2.x < width && uv2.y >= 0.0 && uv2.y < height)\n    {\n        float wi = width / ButtonCountX;\n        float hi = height / ButtonCountY;\n\n        float ix = 0.0;\n        float iy = 1.0;\n\n        ix = floor(uv2.x / wi);\n        uv2.x = (uv2.x / wi - ix) * wi;\n\n        iy = floor(uv2.y / hi);\n        uv2.y = (uv2.y / hi - iy) * hi;\n        iy = float(ButtonCountY) - 1.0 - iy;\n\n        uv2 -= vec2(wi, hi) * 0.5;\n\n        float buttonSizeMod = 2.0;\n        float l = length(uv2) + buttonSizeMod;\n\n        float ll = min(wi, hi) * 0.5;\n\n        float i = ix + iy * ButtonCountX;\n\n        bool isActive = int(i) == ActiveKnobMatId;\n\n        float buttonOpacity = isActive ? 0.9 : 0.2;\n        float shadowOpacity = isActive ? 0.6 : 0.4;\n\n        if(int(i) >= KnobMatCount) { buttonOpacity *= 0.09; shadowOpacity = 0.0; }\n\n        col.rgb = vec3(smoothstep(ll-3.0, ll-4.5, l)       * buttonOpacity , \n                   pow(smoothstep(ll    , ll-4.0, l), 2.0) * shadowOpacity, .0);\n                   \n        return i;\n    }\n    \n    return -1.0;\n}\n\nfloat KnobMatIdButtonMat(vec2 uv)\n{\n    vec4 col;\n    return KnobMatIdButtonMat(col, uv);\n}\n\n\n/*\nvec3 normalize2(vec3 v)//not significantly faster than normalize\n{\n    float l2 = dot(v, v);\n    \n    return v * (1.5 - 0.5 * l2);\n}\n\nvec3 TransformHL2Basis(vec3 x)\n{\n    vec3 hlX = vec3(-1.0/sqrt(6.0), -1.0/sqrt(2.0), 1.0/sqrt(3.0)).xzy;\n    vec3 hlY = vec3(-1.0/sqrt(6.0),  1.0/sqrt(2.0), 1.0/sqrt(3.0)).xzy;\n    vec3 hlZ = vec3(sqrt(2.0/3.0), 0.0, 1.0/sqrt(3.0)).xzy;\n    \n    return x.x*hlX + x.y*hlY + x.z*hlZ;\n}\n\nvec3 Transform(vec2 uv)\n{\n    return uv.x * normalize(vec3(0.5, -1.0, 0.5)) + \n           uv.y * normalize(vec3(1.0, 0.0, -1.0));\n}\n\n\treturn dot(d, (w * w) * (w))*0.785;//norm len(grad)\n\t//return dot(d, (w * w) * (w))*4.73;// norm val\n\t//return dot(d, (w * w) * (w * w))*0.86;//norm len(grad)\n\t//return dot(d, (w * w) * (w * w))*6.725;// norm val\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}