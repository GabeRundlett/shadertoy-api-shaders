{
    "Shader": {
        "info": {
            "date": "1613442963",
            "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl3fD2",
            "likes": 34,
            "name": "Perfect Pistons Example 3",
            "published": 3,
            "tags": [
                "domainrepetition",
                "pistons"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 1287
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 3 dimensional domain repetition.\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\n//nonzero sign function\nfloat nonZeroSign(float x) {\n    return x < 0. ? -1. : 1.;\n}\n\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(nonZeroSign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,nonZeroSign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,nonZeroSign(p.z));\n    return vec3(0);\n}\n\nfloat scene(vec3 p) {\n    vec3 center = floor(p) + .5;\n    vec3 neighbour = center + face(p - center);\n    float hs = hash(hash(center.x, center.y), center.z);\n    vec3 pos = p - center;\n    pos = erot(pos, vec3(0, 0, 1), hs*100.);\n    vec3 npos = p - neighbour;\n    float worst = box(vec3(length(npos.xy), npos.z, 0), vec3(.4, .04, .04))-.005;\n    float me = box(pos, vec3(.4, 0.04, 0.04))-.005;\n    return min(me, worst);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-2,0,0);\n    \n    float yrot = .5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n\n    vec3 p =init;\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.);\n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}