{
    "Shader": {
        "info": {
            "date": "1689815338",
            "description": "Bouncing smiley with random backgrounds.",
            "flags": 0,
            "hasliked": 0,
            "id": "csBfzG",
            "likes": 6,
            "name": "Bouncing Smiley",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "alphardex",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "#define AASIZE 2.\n#define BGCOUNT 7\n\nconst float PI=3.14159265359;\n\n// utils\n// rotate\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nfloat getTheta(vec2 st){\n    return atan(st.y,st.x);\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec3 rgb2hsv(in vec3 c){\n    vec4 K=vec4(0.,-.33333333333333333333,.6666666666666666666,-1.);\n    \n    vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));\n    vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n    \n    float d=q.x-min(q.w,q.y);\n    float e=1.e-10;\n    return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsb){\n    vec3 rgb=clamp(abs(mod(hsb.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return hsb.z*mix(vec3(1.),rgb,hsb.y);\n}\n\nvec3 hueShift(in vec3 color,in float amount){\n    vec3 hsv=rgb2hsv(color);\n    hsv.r+=amount;\n    return hsv2rgb(hsv);\n}\n\nvec3 blendMultiply(vec3 base,vec3 blend){\n    return base*blend;\n}\n\nfloat blendScreen(float base,float blend){\n    return 1.-((1.-base)*(1.-blend));\n}\n\nvec3 blendScreen(vec3 base,vec3 blend){\n    return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nfloat circle(vec2 uv,vec2 p,float r,float blur)\n{\n    float d=length(uv-p);\n    float c=smoothstep(r,r-blur,d);\n    return c;\n}\n\nhighp float random(vec2 co)\n{\n    highp float a=12.9898;\n    highp float b=78.233;\n    highp float c=43758.5453;\n    highp float dt=dot(co.xy,vec2(a,b));\n    highp float sn=mod(dt,3.14);\n    return fract(sin(sn)*c);\n}\n\nfloat remap(float a,float b,float c,float d,float t)\n{\n    return clamp((t-a)/(b-a),0.,1.)*(d-c)+c;\n}\n\n// raymarching\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat sdCappedTorus(vec3 p,vec2 sc,float ra,float rb)\n{\n    p.x=abs(p.x);\n    float k=(sc.y*p.x>sc.x*p.y)?dot(p.xy,sc):length(p.xy);\n    return sqrt(dot(p,p)+ra*ra-2.*ra*k)-rb;\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n    float h=max(k-abs(d1-d2),0.);\n    return min(d1,d2)-h*h*.25/k;\n}\n\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1,float d2,float k)\n{\n    float h=max(k-abs(d1-d2),0.);\n    return max(d1,d2)+h*h*.25/k;\n}\n\nfloat opSubtraction(float d1,float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothSubtraction(float d1,float d2,float k)\n{\n    float h=max(k-abs(-d1-d2),0.);\n    return max(-d1,d2)+h*h*.25/k;\n}\n\nfloat diffuse(vec3 n,vec3 l){\n    float diff=clamp(dot(n,l),0.,1.);\n    return diff;\n}\n\nfloat specular(vec3 n,vec3 l,float shininess){\n    float spec=pow(clamp(dot(n,l),0.,1.),shininess);\n    return spec;\n}\n\nfloat fresnel(float bias,float scale,float power,vec3 I,vec3 N)\n{\n    return bias+scale*pow(1.+dot(I,N),power);\n}\n\nconst float gamma=2.2;\n\nfloat toGamma(float v){\n    return pow(v,1./gamma);\n}\n\nvec2 toGamma(vec2 v){\n    return pow(v,vec2(1./gamma));\n}\n\nvec3 toGamma(vec3 v){\n    return pow(v,vec3(1./gamma));\n}\n\nvec4 toGamma(vec4 v){\n    return vec4(toGamma(v.rgb),v.a);\n}\n\n// functions\nvec3 getGrad(vec2 uv){\n    vec3 col1=vec3(.969,.639,.482);\n    vec3 col2=vec3(1.,.871,.659);\n    vec3 col3=vec3(.816,.894,.690);\n    vec3 col4=vec3(.486,.773,.816);\n    vec3 col5=vec3(0.,.635,.882);\n    vec3 col6=vec3(0.,.522,.784);\n    vec3 c=col1;\n    float ratio=1./6.;\n    c=mix(c,col2,step(ratio*1.,uv.y));\n    c=mix(c,col3,step(ratio*2.,uv.y));\n    c=mix(c,col4,step(ratio*3.,uv.y));\n    c=mix(c,col5,step(ratio*4.,uv.y));\n    c=mix(c,col6,step(ratio*5.,uv.y));\n    return c;\n}\n\n// bgs\nvec4 bg1(vec2 uv){\n    uv-=.5;\n    uv=rotate(uv,-PI/4.);\n    uv+=.5;\n    uv=fract(uv*16.);\n    vec3 c=mix(vec3(1.),vec3(.941,.416,.055),1.-step(.5,uv.y));\n    return vec4(c,1.);\n}\n\nvec4 bg2(vec2 uv){\n    vec2 st=.5-uv;\n    \n    st=rotate(st,PI/2.);\n    \n    float a=getTheta(st);\n    \n    vec3 col=mix(vec3(.604,.804,.196),vec3(1.,.078,.576),(a+PI)/(PI*2.));\n    \n    return vec4(col,1.);\n}\n\nvec4 bg3(vec2 uv){\n    uv=fract(uv*5.);\n    \n    vec2 p1=uv;\n    p1-=.5;\n    p1=rotate(p1,PI/4.);\n    p1+=.5;\n    float d1=sdBox(p1,vec2(.5));\n    \n    vec2 p2=uv;\n    p2.y=1.-p2.y;\n    p2-=.5;\n    p2=rotate(p2,PI/4.);\n    p2+=.5;\n    float d2=sdBox(p2,vec2(.5));\n    \n    float d=opUnion(d1,d2);\n    \n    float mask=step(0.,d);\n    \n    vec3 col=vec3(1.)*mask;\n    \n    return vec4(col,1.);\n}\n\nvec4 bg4(vec2 uv){\n    vec2 st=.5-uv;\n    \n    st=rotate(st,PI/2.);\n    \n    float a=getTheta(st);\n    a=mod(a,PI/6.);\n    \n    vec3 col=mix(vec3(.604,.804,.196),vec3(1.,.078,.576),step(1./24.,(a)/(PI*2.)));\n    \n    return vec4(col,1.);\n}\n\nvec4 bg5(vec2 uv){\n    uv-=.5;\n    \n    float a=length(uv);\n    a=sin(a*200.);\n    \n    vec3 col=mix(vec3(.937,.965,.957),vec3(.945,.169,.937),a);\n    \n    return vec4(col,1.);\n}\n\nvec4 bg6(vec2 uv){\n    vec3 col1=vec3(.373,.867,.800);\n    vec3 col2=vec3(1.,0.,.302);\n    uv-=.5;\n    uv=rotate(uv,PI/4.);\n    uv+=.5;\n    vec3 col12=mix(col1,col2,uv.x);\n    vec3 col=hueShift(col12,fract(iTime*.1));\n    return vec4(col,1.);\n}\n\nvec4 bg7(vec2 uv){\n    vec2 p1=uv;\n    p1-=.5;\n    p1=rotate(p1,-PI/4.);\n    p1+=.5;\n    p1=fract(p1*4.);\n    vec3 col1=getGrad(p1);\n    \n    vec2 p2=uv;\n    p2-=.5;\n    p2=rotate(p2,PI/4.);\n    p2+=.5;\n    p2=fract(p2*4.);\n    vec3 col2=getGrad(p2);\n    \n    // vec3 c=col1;\n    // vec3 c=col2;\n    vec3 c=blendMultiply(col1,col2);\n    \n    return vec4(c,1.);\n}\n\n// main\nvec4 getBg(vec2 uv,int frame){\n    if(frame==0){\n        return bg1(uv);\n    }else if(frame==1){\n        return bg2(uv);\n    }else if(frame==2){\n        return bg3(uv);\n    }else if(frame==3){\n        return bg4(uv);\n    }else if(frame==4){\n        return bg5(uv);\n    }else if(frame==5){\n        return bg6(uv);\n    }else if(frame==6){\n        return bg7(uv);\n    }\n}\n\nvec4 getRandBg(vec2 uv){\n    // float ratio=iResolution.x/iResolution.y;\n    // uv.x*=ratio;\n    \n    int frame=int(iTime);\n    \n    int currentFrame=0;\n    currentFrame=frame%BGCOUNT;\n    vec4 randBg=getBg(uv,currentFrame);\n    return randBg;\n}\n\n// raymarching\nvec2 map(vec3 p){\n    vec2 d=vec2(1e10,0.);\n    \n    float bounce=abs(sin(iTime*PI));\n    float y=-bounce+.5;\n    p.y+=y;\n    \n    float scaleX=remap(0.,1.,1.25,1.,bounce);\n    p.x/=scaleX;\n    \n    float scaleY=remap(0.,1.,.75,1.,bounce);\n    p.y/=scaleY;\n    \n    vec3 p1=p;\n    \n    float d1=sdSphere(p1,.5)*scaleX*scaleY;\n    d=opUnion(d,vec2(d1,1.));\n    \n    vec3 p2=p;\n    p2+=vec3(.15,-.2,.34);\n    float d2=sdSphere(p2,.1);\n    d=opUnion(d,vec2(d2,2.));\n    \n    vec3 p3=p;\n    p3+=vec3(-.15,-.2,.34);\n    float d3=sdSphere(p3,.1);\n    d=opUnion(d,vec2(d3,2.));\n    \n    vec3 p4=p;\n    p4.y*=-1.;\n    p4+=vec3(0.,.15,.45);\n    float angle=PI/4.;\n    float d4=sdCappedTorus(p4,vec2(sin(angle),cos(angle)),.4,.025);\n    d=opUnion(d,vec2(d4,2.));\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 pos,float eps){\n    const vec3 v1=vec3(1.,-1.,-1.);\n    const vec3 v2=vec3(-1.,-1.,1.);\n    const vec3 v3=vec3(-1.,1.,-1.);\n    const vec3 v4=vec3(1.,1.,1.);\n    \n    return normalize(v1*map(pos+v1*eps).x+\n    v2*map(pos+v2*eps).x+\n    v3*map(pos+v3*eps).x+\n    v4*map(pos+v4*eps).x);\n}\n\nvec3 calcNormal(vec3 pos){\n    return calcNormal(pos,.002);\n}\n\nfloat softshadow(in vec3 ro,in vec3 rd,in float mint,in float tmax)\n{\n    float res=1.;\n    float t=mint;\n    for(int i=0;i<16;i++)\n    {\n        float h=map(ro+rd*t).x;\n        res=min(res,8.*h/t);\n        t+=clamp(h,.02,.10);\n        if(h<.001||t>tmax)break;\n    }\n    return clamp(res,0.,1.);\n}\n\nvec3 material(vec3 col,vec3 normal,float m){\n    col=vec3(1.);\n    \n    if(m==1.){\n        col=vec3(1.,.6824,0.);\n    }\n    \n    if(m==2.){\n        col=vec3(.1137,.0588,.0039);\n    }\n    \n    return col;\n}\n\nvec3 lighting(in vec3 col,in vec3 pos,in vec3 rd,in vec3 nor){\n    vec3 lin=vec3(0.);\n    \n    // reflection\n    vec3 ref=reflect(rd,nor);\n    \n    // ao\n    float occ=1.;\n    \n    // sun\n    {\n        // pos\n        vec3 lig=normalize(vec3(-.5,.4,-.6));\n        // dir\n        vec3 hal=normalize(lig-rd);\n        // diffuse\n        float dif=diffuse(nor,lig);\n        // softshadow\n        dif*=softshadow(pos,lig,.02,2.5);\n        // specular\n        float spe=specular(nor,hal,16.);\n        spe*=dif;\n        // fresnel\n        spe*=fresnel(.04,.96,5.,-lig,hal);\n        // apply\n        lin+=col*2.20*dif*vec3(1.30,1.,.70);\n        lin+=5.*spe;\n    }\n    // sky\n    {\n        // diffuse\n        float dif=sqrt(clamp(.5+.5*nor.y,0.,1.));\n        // ao\n        dif*=occ;\n        // specular\n        float spe=smoothstep(-.2,.2,ref.y);\n        spe*=dif;\n        // fresnel\n        spe*=fresnel(.04,.96,5.,rd,nor);\n        // softshadow\n        spe*=softshadow(pos,ref,.02,2.5);\n        // apply\n        lin+=col*.60*dif;\n        lin+=2.*spe;\n    }\n    // back\n    {\n        // diff\n        float dif=diffuse(nor,normalize(vec3(.5,0.,.6)))*clamp(1.-pos.y,0.,1.);\n        // ao\n        dif*=occ;\n        // apply\n        lin+=col*.55*dif;\n    }\n    // sss\n    {\n        // fresnel\n        float dif=fresnel(0.,1.,2.,rd,nor);\n        // ao\n        dif*=occ;\n        // apply\n        lin+=col*.25*dif;\n    }\n    \n    return lin;\n}\n\nvec2 raycast(vec3 ro,vec3 rd){\n    vec2 res=vec2(-1.,-1.);\n    \n    float depth=0.;\n    for(int i=0;i<128;i++){\n        vec3 p=ro+rd*depth;\n        \n        vec2 t=map(p);\n        float d=t.x;\n        float m=t.y;\n        \n        // hit\n        if(d<.0001){\n            res=vec2(depth,m);\n            break;\n        }\n        \n        depth+=d;\n    }\n    \n    return res;\n}\n\nvec3 render(vec3 ro,vec3 rd,vec2 uv){\n    vec3 col=vec3(0.);\n    \n    vec2 res=raycast(ro,rd);\n    float d=res.x;\n    float m=res.y;\n    \n    // skybox\n    // col=vec3(.4,.7,1.)-(rd.y*.7);\n    col=getRandBg(uv).xyz;\n    \n    if(m>-.5){\n        vec3 p=ro+d*rd;\n        \n        vec3 nor=calcNormal(p);\n        col=material(col,nor,m);\n        col=lighting(col,p,normalize(-ro),nor);\n        col=toGamma(col);\n    }\n    \n    return col;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    // uv (0,1) -> (-1,1)\n    vec2 p=uv;\n    p=2.*p-1.;\n    p.x*=iResolution.x/iResolution.y;\n    \n    // camera\n    vec3 ca=vec3(0.,0.,-5.);\n    float z=4.;\n    vec3 rd=normalize(vec3(p,z));\n    \n    // raymarch\n    vec3 col=render(ca,rd,uv);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=AASIZE;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}