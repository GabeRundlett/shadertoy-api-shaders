{
    "Shader": {
        "info": {
            "date": "1637796075",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "7tyGWm",
            "likes": 6,
            "name": "spqr: volumetric light study",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "Fahrenheitrequited",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat sph (vec3 p, float r) {\n  return length(p) -r;\n}\nfloat cyl (vec2 p,float r) {\n  return length(p) - r;\n}\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat map(vec3 p) {\n\n  // geo\n  \n  float outside = cyl(p.xz, 3.);\n  float inside = -cyl(p.xz, 2.8);\n  float tunnel = max(inside,outside);\n  p.xz *= rot((p.y/10.) * sin(iTime) * 5.1);\n  p = rep(p, vec3(.52));\n  float holes = sph(p, .27);\n \n  tunnel = max(tunnel,-holes);\n  return tunnel;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  \n  \n  \n\n\n // vec3 r=normalize(vec3(-uv, 1));\n  \n  \n  // nav\n  float tt = iTime * .01 + 16.5;\n  vec3 s,t;\n  s += lattice(tt) * 20.;\n  s += lattice(tt * 3.) * 5.1;\n  s *= sin(tick(iTime * .31) * .21+ 7.);\n  \n  t += lattice(tt * 95. + 1.) * 3.;\n  t += lattice(tt * 57.) * 1.1;;\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,-1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n\n \n\n  \n  // march\n  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 100.0;\n  float z;\n  for( z=0.; z<100.; ++z) {\n  \n    float d=map(p);\n    if(d<0.001) break;\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n    \n  }\n  \n  \n  \n  // volume\n  \n  float rand=rnd(uv);\n  \n  vec3 lightpos = vec3(3);\n  //vec3 lightfocus = vec3(3);\n  float lightangle = .1;\n \n  lightpos = vec3(0,0,4);\n  lightpos.xz *= rot(iTime);\n  lightpos.yz *= rot(iTime * .61);\n  lightpos.xy *= rot(iTime * .41);\n  \n  \n  //lightfocus.yz *= rot(t1 * .7);\n  //lightfocus.xz *= rot(t2 * .8);\n  //lightfocus.yx *= rot(t3 * .91);\n  \n\n\n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n    if ( dot( normalize(lv), normalize(lp) ) > -1.) {\n      atcol += 5./(0.01+(pow(ldistvol,1.5))) * shadvol;\n    }\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n \n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(lightpos - p);\n\n  float ldist = length(lightpos - p);\n  float fade = 1.0/(ldist*ldist);\n  \n  float shad = shadow(p + n * 0.2, l, ldist, 30, 0.01);\n  \n  vec3 col=vec3(0);\n\n  col += atcol * .07;\n  col = pow(col, vec3(0.4545));\n  col *= 1.2-length(uv);\n  \n  col += pow( 1.-z/100., 135.) * vec3(1);\n  \n  fragColor = vec4(col, 1);\n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}