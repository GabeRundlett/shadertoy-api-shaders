{
    "Shader": {
        "info": {
            "date": "1529141451",
            "description": "Combination of [url]https://www.shadertoy.com/view/XtffW8[/url] and [url]https://www.shadertoy.com/view/XsVBRm[/url]\n\nClick the left side to reset, or the right side to show tectonic plates.",
            "flags": 32,
            "hasliked": 0,
            "id": "lsKBWw",
            "likes": 25,
            "name": "Plate Tectonics with Erosion",
            "published": 3,
            "tags": [
                "procedural",
                "terrain",
                "simulation",
                "erosion"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 1445
        },
        "renderpass": [
            {
                "code": "#define STEP1 1.\n#define STEP2 1.5\n#define STEP3 3.\n#define STEP4 10.\n\nvoid mainImage(out vec4 r, in vec2 p) {\n    float y = buf(p).z;\n    if (iMouse.z > 0. && iMouse.x/iResolution.x > 0.5) {\n        float q = buf(p).x;\n        float uplift = buf(p).y;\n        r.rgb = (q < 0.) ? vec3(1) : .6 + .6 * cos(2.*PI*q + vec3(0,23,21));\n        r.rgb *= 0.1 + 0.9 * uplift;\n    } else if (y < OCEAN_DEPTH) {\n        r = mix(vec4(0.01, 0.02, 0.08, 1), vec4(0.11, 0.28, 0.51, 1), y / OCEAN_DEPTH);\n    } else {\n        y -= OCEAN_DEPTH;\n        r = vec4(0.08, 0.14, 0.03, 1);\n        r = mix(r, vec4(0.18, 0.26, 0.08, 1), smoothstep(0., STEP1, y));\n        r = mix(r, vec4(0.52, 0.39, 0.26, 1), smoothstep(STEP1, STEP2, y));\n        r = mix(r, vec4(0.32, 0.3, 0.2, 1), smoothstep(STEP2, STEP3, y));\n        r = mix(r, vec4(1,1,1,1), smoothstep(STEP3, STEP4, y));\n        \n        vec2 grad = vec2(buf(p+E).z - buf(p+W).z, buf(p+N).z - buf(p+S).z);\n        r.rgb *= 0.75 + 0.25 * cos(atan(grad.y, grad.x) + 0.25*PI)\n                             * clamp(0.2 * length(grad), 0., 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define OCEAN_DEPTH 7.5\n\n#define buf(p) texture(iChannel0,(p)/iResolution.xy)\n\n#define N  vec2( 0, 1)\n#define NE vec2( 1, 1)\n#define E  vec2( 1, 0)\n#define SE vec2( 1,-1)\n#define S  vec2( 0,-1)\n#define SW vec2(-1,-1)\n#define W  vec2(-1, 0)\n#define NW vec2(-1, 1)\n\n#define PI 3.14159265359\n\n\n// https://www.shadertoy.com/view/4tdSWr\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// 2018 David A Roberts <https://davidar.io>\n\n// plate movement\nvec2 move(float q, int iFrame) {\n    vec2 v = vec2(cos(2.*PI*q), sin(2.*PI*q));\n    if (hash13(vec3(v,iFrame)) < 0.05) {\n        if (hash13(vec3(v+1.,iFrame)) < abs(v.x) / (abs(v.x) + abs(v.y))) {\n            return vec2(sign(v.x),0.);\n        } else {\n            return vec2(0.,sign(v.y));\n        }\n    }\n    return vec2(0);\n}\n#define MOVE(c) move(c.x, iFrame)\n\nfloat slope(vec2 p, vec2 q) {\n    if (p == q) return 0.;\n    return (buf(q).z - buf(p).z) / distance(p,q);\n}\n\nvec2 rec(vec2 p) { // direction of water flow at point\n    vec2 d = vec2(0);\n    if (slope(p + N,  p) >= slope(p + d, p)) d = N;\n    if (slope(p + NE, p) >= slope(p + d, p)) d = NE;\n    if (slope(p + E,  p) >= slope(p + d, p)) d = E;\n    if (slope(p + SE, p) >= slope(p + d, p)) d = SE;\n    if (slope(p + S,  p) >= slope(p + d, p)) d = S;\n    if (slope(p + SW, p) >= slope(p + d, p)) d = SW;\n    if (slope(p + W,  p) >= slope(p + d, p)) d = W;\n    if (slope(p + NW, p) >= slope(p + d, p)) d = NW;\n    return d;\n}\n\nvoid mainImage(out vec4 c, in vec2 p) {\n    if(iFrame < 10 || (iMouse.z > 0. && iMouse.x/iResolution.x < 0.5)) {\n        c = vec4(0);\n        c.x = -1.;\n        c.z = 15. * clamp(5. * fbm(3. * p / iResolution.xy) + 0.5, 0., 1.);\n        return;\n    }\n    \n    c = buf(p);\n    vec4 n = buf(p + N);\n    vec4 e = buf(p + E);\n    vec4 s = buf(p + S);\n    vec4 w = buf(p + W);\n    \n    // diffuse uplift through plate\n    float dy = 0.;\n    if (e.x == c.x) dy += e.y - c.y;\n    if (w.x == c.x) dy += w.y - c.y;\n    if (n.x == c.x) dy += n.y - c.y;\n    if (s.x == c.x) dy += s.y - c.y;\n    c.y = max(0., c.y + 0.1 * dy);\n    \n    // tectonic uplift\n    c.z += 2. * clamp(c.y - 0.5, 0., 1.);\n    \n    if (c.z >= OCEAN_DEPTH - 0.01) {\n        // thermal erosion\n        float dz = 0.;\n        if (abs(e.z - c.z) > 1.) dz += e.z - c.z;\n        if (abs(w.z - c.z) > 1.) dz += w.z - c.z;\n        if (abs(n.z - c.z) > 1.) dz += n.z - c.z;\n        if (abs(s.z - c.z) > 1.) dz += s.z - c.z;\n        c.z = max(0., c.z + 0.02 * dz);\n\n        // flow accumulation\n        c.w = 1.;\n        if (rec(p + N)  == -N)  c.w += buf(p + N).w;\n        if (rec(p + NE) == -NE) c.w += buf(p + NE).w;\n        if (rec(p + E)  == -E)  c.w += buf(p + E).w;\n        if (rec(p + SE) == -SE) c.w += buf(p + SE).w;\n        if (rec(p + S)  == -S)  c.w += buf(p + S).w;\n        if (rec(p + SW) == -SW) c.w += buf(p + SW).w;\n        if (rec(p + W)  == -W)  c.w += buf(p + W).w;\n        if (rec(p + NW) == -NW) c.w += buf(p + NW).w;\n\n        if (rec(p) == vec2(0)) { // local minima\n            c.z += 0.001; // extra sediment\n        } else {\n            // hydraulic erosion with stream power law\n            vec4 receiver = buf(p + rec(p));\n            float pslope = (c.z - receiver.z) / length(rec(p));\n            float dz = min(pow(c.w, 0.8) * pow(pslope, 2.), c.z);\n            c.z = max(c.z - 0.05 * dz, receiver.z);\n        }\n    }\n\t\n    // approximation of sediment accumulation\n    c.z += 0.0002 * clamp(c.z + 2.5, 0., 10.);\n    \n    bool subduct = false;\n    \n    if(iFrame % 3000 < 10) {\n        // generate new plate boundaries\n        c.x = -1.;\n    } else if(c.x < 0.) { // no plate under this point yet\n        if(length(hash33(vec3(p,iFrame))) < 7e-3) {\n            // seed a new plate with random velocity\n            c.x = hash13(vec3(p,iFrame));\n        } else {\n            // accretion\n            int dir = int(4.*hash13(vec3(p,iFrame)));\n            if(dir == 0) c.x = s.x;\n            if(dir == 1) c.x = w.x;\n            if(dir == 2) c.x = n.x;\n            if(dir == 3) c.x = e.x;\n        }\n    } else if (MOVE(n) == S) {\n        if (MOVE(c) != S) subduct = true;\n        c = n;\n    } else if (MOVE(e) == W) {\n        if (MOVE(c) != W) subduct = true;\n        c = e;\n    } else if (MOVE(s) == N) {\n        if (MOVE(c) != N) subduct = true;\n        c = s;\n    } else if (MOVE(w) == E) {\n        if (MOVE(c) != E) subduct = true;\n        c = w;\n    } else if (MOVE(c) != vec2(0) && buf(p - MOVE(c)).x >= 0.) { \n        // rift\n        c.x = -1.;\n        if (c.z < OCEAN_DEPTH) {\n            c.y = 0.;\n            c.z = 0.;\n        }\n        c.w = 0.;\n    }\n    \n    if (subduct) {\n        c.y = 1.;\n    } else {\n        c.y = clamp(c.y - 0.0001, 0., 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}