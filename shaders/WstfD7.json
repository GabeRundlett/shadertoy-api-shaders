{
    "Shader": {
        "info": {
            "date": "1605292903",
            "description": "A lonely planet filled with a shiny sea and surrounded by an atmosphere unproportionate to the size of the planet.",
            "flags": 0,
            "hasliked": 0,
            "id": "WstfD7",
            "likes": 8,
            "name": "Atmosphere + planet",
            "published": 3,
            "tags": [
                "planet",
                "raytrace",
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "xacer",
            "viewed": 650
        },
        "renderpass": [
            {
                "code": "// planet with atmosphere inspired by Sebastian Lague's Coding Adventure\n\n// any tips on rendering the sun would be appreciated!\n\n// noise from: https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat snoise(vec3 v) { \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n            dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvec2 raySphere (vec3 sphereCenter, float sphereRadius, vec3 origin, vec3 ray) {\n    vec3 offset = origin - sphereCenter;\n    float a = 1.0;\n    float b = 2.0 * dot(offset, ray);\n    float c = dot(offset, offset) - sphereRadius * sphereRadius;\n    float d = b * b - 4.0 * a * c;\n\n    if (d > 0.0) {\n        float s = sqrt(d);\n        float dstToSphereNear = max(0.0, (-b - s) / (2.0 * a));\n        float dstToSphereFar = (-b + s) / (2.0 * a);\n        if (dstToSphereFar >= 0.0) {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n\n    }\n    return vec2(100.00, -1.0);\n}\n\nconst float epsilon = 0.003;\nconst vec3 dirToSun = normalize(vec3(0.9, 0, 1));\nconst vec3 planetCenter = vec3(0.0, 0.0, 0.0);\nconst float atmosphereRadius = 1.7;\nconst float planetRadius = 1.0;\nconst float numInScatteringPoints = 8.0;\nconst float densityFalloff = 11.0;\nconst float numOpticalDepthPoints = 8.0;\n\nconst float scatteringStrength = 13.0;\nconst vec3 waveLengths = vec3(800, 530, 440);\nconst vec3 scatterCoefs = scatteringStrength * vec3(\n    pow(400.0 / waveLengths.x, 4.0), \n    pow(400.0 / waveLengths.y, 4.0), \n    pow(400.0 / waveLengths.z, 4.0));\n\nfloat densityAtPoint (vec3 p) {\n    float heightAboveSurface = length(p - planetCenter) - planetRadius;\n    float height01 = heightAboveSurface / (atmosphereRadius - planetRadius);\n    float localDensity = exp(-height01 * densityFalloff) * (1.0 - height01);\n    return localDensity;\n}\n\nfloat opticalDepth (vec3 ro, vec3 rd, float rl) {\n    vec3 densitySamplePoint = ro.xyz;\n    float stepSize = rl / (numOpticalDepthPoints - 1.0);\n    float opticalDepth = 0.0;\n    for (float i = 0.0; i < numOpticalDepthPoints; i += 1.0) {\n        opticalDepth += densityAtPoint(densitySamplePoint) * stepSize;\n        densitySamplePoint += rd * stepSize;\n    }\n    return opticalDepth;\n}\n\nvec3 calculateLight (vec3 ro, vec3 rd, float rl, vec3 originalColor) {\n\n    vec3 inScatterPoint = ro.xyz;\n\n    float stepSize = rl / (numInScatteringPoints - 1.0);\n\n    vec3 inScatteredLight = vec3(0, 0, 0);\n\n    float viewRayOpticalDepth = 0.0;\n\n    float ii = 0.0;\n    for (float i = 0.0; i < numInScatteringPoints; i += 1.0) {\n\n        float sunRayLength = raySphere(\n            planetCenter, atmosphereRadius, inScatterPoint, dirToSun).y;\n\n        float sunRayOpticalDepth = opticalDepth(\n            inScatterPoint, dirToSun, sunRayLength);\n\n        viewRayOpticalDepth = opticalDepth(\n            inScatterPoint, -rd, stepSize * ii);\n\n        vec3 transmittance = exp(\n            (-sunRayOpticalDepth-viewRayOpticalDepth) * scatterCoefs);\n\n        float localDensity = densityAtPoint(inScatterPoint);\n\n\n        inScatteredLight += \n            localDensity * transmittance * \n            scatterCoefs * stepSize;\n        inScatterPoint += \n            rd * stepSize;\n\n        ii += 1.0;\n    }\n\n    float originalTransmittance = exp(-2.0*viewRayOpticalDepth);\n    return originalTransmittance * originalColor + inScatteredLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.yy;\n\t\n    vec3 ray = normalize(vec3(uv, 1.0));\n    float rot = iTime*0.4;\n    vec3 cpos = -4.0 * vec3(cos(rot + 3.14 / 2.0), 0, sin(rot + 3.14 / 2.0));\n   \t\n    float ct = cos(rot), st = sin(rot);\n    ray.xz = vec2(ray.x * ct - ray.z * st, ray.x * st + ray.z * ct);\n    \n    vec2 dstToPlanet = raySphere(planetCenter, planetRadius, cpos, ray);\n    \n    vec3 tint = vec3(0, 0, 0);\n    \n    if (dstToPlanet.y > 0.0) {\n    \tvec3 pos = cpos + ray * dstToPlanet.x;\n        vec3 normal = normalize(pos);\n        float ns = 10.0 + iTime * 0.2;\n        vec3 normal_edit = vec3(\n            snoise(normal.xyz*25.0+ns), \n            snoise(normal.yzx*25.0+ns), \n            snoise(normal.zyx *25.0+ns));\n       \tnormal += normal_edit * 0.2;\n        float diffuse = max(dot(normal, dirToSun), 0.0);\n        float specular = dot(reflect(ray, normal), dirToSun);\n        specular = pow(max(specular, 0.0), 16.0);\n\n        float light = 0.7 * diffuse + 0.3 * specular;\n\n        tint = vec3(0.8, 0.8, 0.8) * light;\n    } else {\n        float dp = dot(ray, dirToSun);\t\t\t\n        float sn = snoise(ray.xyz * 50.0);\n        if (sn > 0.8) {\n            sn -= 0.8;\n            tint = vec3(sn, sn, sn) * 5.0;\n        }\n        if (dp > 0.997) {\n            dp -= 0.997;\n            dp *= 1000.0;\n            tint = dp * vec3(1.0, 0.8, 0.5);\n        }\n    }\n    vec2 t = raySphere(planetCenter, atmosphereRadius, cpos, ray);\n    if (t.y > 0.0) {\n        float nt = t.x, ft = min(t.y, dstToPlanet.x - t.x);\n        vec3 posInAtmosphere = cpos + ray * (nt + epsilon);\n        tint = calculateLight(posInAtmosphere, ray, ft - epsilon * 2.0, tint);\n    }\n    fragColor = vec4(tint,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}