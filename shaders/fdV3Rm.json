{
    "Shader": {
        "info": {
            "date": "1631333802",
            "description": "Some work on timing / animation / stacking stuff. Probably have more around this theme - I like the mechanics / taking vec - time + traveled to change animation",
            "flags": 0,
            "hasliked": 0,
            "id": "fdV3Rm",
            "likes": 19,
            "name": "Candy Stacks",
            "published": 3,
            "tags": [
                "raymarching",
                "animation",
                "truchet",
                "motion",
                "timing"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "/**\n    \n    Candy Stacks \n    @byt3_m3chanic | 09/10/21\n\n    work on some timing/motion stuff.\n    built mechanics first\n    \n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    150.\n#define MIN_DIST    .001\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0., 1.); }\n\n//@iq shapes and extrude\nfloat box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat cyl( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat opx( in vec3 p, float d, in float h ) {\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n// gear\nfloat gear(vec3 p, float radius, float thick, float hl) {\n    float hole = (radius*.25);\n    float sp = floor(radius*PI);\n    float gs = length(p.xy)-radius;\n    float gw = abs(sin(atan(p.y,p.x)*sp)*.2);\n    gs +=smoothstep(.05,.45,gw);\n    float cog= hl<1. ? max(opx(p,gs,thick),-(length(p.xy)-hole)) : opx(p,gs,thick);\n    return cog;\n}\n// consts\nconst float size = 4.;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\n// globals\nfloat floorspeed;\nfloat ga1,ga2,ga3,ga4;\n\nvec3 hit=vec3(0),hitPoint,gid,sid;\nvec3 speed = vec3(0);\nmat2 r45,turn,spin;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    float id;\n    vec3 p2, q;\n    for(int i = 0; i<2; i++)\n    {\n        float cnt = i<1 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n\n        float ff = qf-size;\n        float lent= ff<floorspeed-3. ? 7. : clamp(ga4,0.,1.)*7. ;\n        float fent= ff<floorspeed-3. ? 5. : clamp(ga4,0.,1.)*5. ;\n        vec3 r = q;\n        p2=q;\n        q.z=abs(q.z)-19.;\n        \n        float pole = (ff<floorspeed+1.&& i==0) ? min(cyl(q-vec3(0,lent+1.5,0),.25,lent+.5),\n        length(q-vec3(0,(lent+1.5)*2.,0))-(.75)) : 1e5;\n        \n        float pcap = max(cyl(q,.85,1.), -cyl(q,.45,2.) );\n        pcap = min(box(q,vec3(1.9,.1,1.5)),pcap);\n        pole=min(pcap,pole);\n        if(pole<res.x){\n            res = vec2(pole,5.);\n            hit=q;\n            gid = vec3(qf,0,0);\n        }  \n        \n        float qw=q.z - 2.;     \n        float wave = .5*sin(qw*1.5-T*4.+ff);\n        wave = mix(wave,0.,clamp(1.-((qw-1.5)*.5),0.,.8));\n        q.x-= wave*2.;\n        q.y-= wave;\n        \n        vec3 fq = q-vec3(0,(lent*2.),fent);\n        float flag=(ff<floorspeed+1.&& i==0) ? box(fq,vec3(.05,2.5,fent)) : 1e5;\n        if(flag<res.x){\n            res = vec2(flag,1.);\n            hit=fq;\n            gid = vec3(qf,0,0);\n        }\n\n        lent= ff<floorspeed+5. ? 0. : ff>floorspeed+6. ? 3.25 : clamp(1.-ga3,0.,1.)*3.25;\n        float ent= ff<floorspeed+35. ? 0. : ff>floorspeed+38. ? 38. : clamp(1.-ga3,0.,1.)*38.;\n        \n        if(i==0) ent = -ent;\n        float d3=box(r-vec3(0,(lent*3.)-2.,ent),vec3(2,2,14.));\n        if(d3<res.x){\n            res = vec2(d3,3.);\n            hit= r-vec3(0,(lent*3.)-2.,ent);\n            gid = vec3(qf,0,0);\n        }\n        \n    }\n\n    vec3 pb = vec3(p.x-speed.x-25.,p.y-19.,p.z-11.);\n    pb.xy*=spin;\n    float bls = gear(pb, 9.,1.5,1.);\n    vec3 pp = vec3(p.x-speed.x-29.,p.y-3.,p.z);\n    vec3 pq = vec3(p.x-speed.x-16.,p.y-3.,p.z);\n    \n    float beam = min(length(pp.xy)-.45,length(pq.xy)-.45);\n    beam = min(cyl(pb.yzx-vec3(0,22,0),1.25,25.25),beam);\n    beam = min(cyl(pb+vec3(0,0,2.4),.5,1.85),beam);\n    pp.xy*=turn; pq.xy*=turn;\n    bls = min(gear(pp, 3.,14.75,0.),bls);\n    bls = min(gear(pq, 3.,14.75,0.),bls);\n   \n    if(bls<res.x){\n        res=vec2(bls,4.);\n        hit=p2;\n    }\n    if(beam<res.x){\n        res=vec2(beam,5.);\n        hit=pb;\n    }\n    float fl=max(p.y,-box(p2,vec3(8.,4.,16.)) );\n    if(fl<res.x){\n        res=vec2(fl,2.);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.25:ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 hue(float t){ \n    const vec3 c = vec3(.122,.467,.918);\n    return .45 + .35*cos(PI2*t*(c+vec3(.878,.969,.851))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,128);\n    hitPoint=hit;  \n    sid=gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(25.,125.,-75.);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint+vec3(size,5,size);\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.;\n        for( float t=.0; t < 38.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += t<12.? h*.5 : h;\n            if( shdw<MIN_DIST || t>38. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.3 * pow(max(dot(view, ret), 0.), 20.);\n        float clr;\n        \n        // materials\n        if(m==1.){\n            h=vec3(.745,.933,.929);\n            vec2 f = fract(hp.zy)-.5;\n            if(f.x*f.y>0.||hp.y<0.) h*=.25;    \n            ref = h-fresnel;     \n        }\n        if(m==2.){\n            h=vec3(.192,.306,.302);\n            vec2 f = fract(hp.xz/(dbl*2.))-.5;\n            if(f.x*f.y>0.) h=vec3(.220,.698,.682);\n            if( hp.y<1.1 ) h=vec3(.133,.247,.243);\n            ref =(f.x*f.y>0. && hp.y>1.1) ? vec3(.35)-fresnel:vec3(0.); \n        }\n        if(m==3.){\n            h = hue((50.+sid.x)*.0025);\n            float px = .05;\n            vec2 grid = fract(hp.xz/hlf)-.5;\n            vec2 id = floor(hp.xz/hlf);\n            float hs = hash21(id+sid.x);\n            if(hs>.5) grid.x*=-1.;\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n            float circle = length(gx)-.5;\n            circle=(chk>.5 ^^ hs<.5) ? smoothstep(-px,px,circle) : smoothstep(px,-px,circle);\n            h = mix(h, vec3(.08),circle);\n            if(hp.y<6.99) h=vec3(.8); \n            if(hp.y<6.99&&hp.y>6.) h=vec3(.2);\n            ref = (h*.4)-fresnel;\n        }\n        if(m==4.) {\n            ref = vec3(.1)-fresnel;\n            h=vec3(.2);\n        }\n        if(m==5.) {\n            ref = vec3(.2)-fresnel;\n            h=vec3(.4);\n        }\n        C = (diff*h)+spec;\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {   \n    // precal\n    r45=rot(-0.78539816339); \n    float time = (T+40.)*12.;\n    float tmod = mod(time, 10.);\n    float t3 = lsp(5., 10., tmod);\n    \n    float fmod = mod(time, 20.);\n    float t2 = lsp(10., 20., fmod);\n    \n    ga1 = (time*.1);\n    ga3 = (tmod<5.?t3+1. :t3);\n    ga4 = (fmod<10.?t2+1. :t2);\n    \n    speed = vec3(abs(ga1*size),0,0);\n    floorspeed=floor(speed.x);\n    turn=rot(ga1);\n    spin=rot(-ga1*.38);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*45.,-45.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    ro.yz*=r45;ro.xz*=r45;\n    rd.yz*=r45;rd.xz*=r45;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fill=vec3(1);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fill;\n        fill*=ref;\n    }\n    // mixdown \n    float vin = length((2.*F.xy-R.xy)/R.x)-.175;\n    C = mix(C,C*.5,smoothstep(.0,.8,vin));\n    C = clamp(C,vec3(.015),vec3(1));\n    // gamma\n    C = pow(C, vec3(.4545));\n    // output\n    O = vec4(C,1.);\n}\n//end\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}