{
    "Shader": {
        "info": {
            "date": "1554510922",
            "description": "During dinner I had this idea after seeing Passion's \"World War Zed\" (https://www.shadertoy.com/view/3dBSz3)... it worked out for the most part (minus the bugs :). The cell-index is a bit underused for introducing more variations per cell-scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "3s2SR3",
            "likes": 11,
            "name": "Grid Slider",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "raymarching",
                "phong",
                "grid",
                "sdf",
                "fbm",
                "shadow",
                "blinn"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 553
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Grid Slider - Passion's \"World War Zed\" gave me the idea for trying this\n// collage-like thing. Passion's shader is https://www.shadertoy.com/view/3dBSz3\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float degree)\n{\n\tfloat r = radians (degree);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c,  s, -s,  c);\n}\n\n// hash(), noise3d() & fbm() are from iq or shane iirc\nfloat hash (float f)\n{\n\treturn fract (sin (f) * 45785.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\nfloat fbm (vec3 p)\n{\n\tmat2 m1 = r2d (1.1 * iTime);\n\tmat2 m2 = r2d (-1.2 * iTime);\n\tmat2 m3 = r2d (iTime);\n\n    float result = .0;\n    result = 0.5 * noise3d (p);\n    p.xz *= m1 * 2.02;\n    result += 0.25 * noise3d (p);\n    p.xz *= m2 * 2.03;\n    result += 0.125 * noise3d (p);\n    p.xz *= m3 * 2.04;\n    result += 0.0625 * noise3d (p);\n    result /= 0.9375;\n\n    return result;\n}\n\nfloat sdThing (in vec3 p, in int type, inout vec3 objectUVW) {\n    float d = .0;\n    if (type == 0) { // wavy ball\n    \tfloat r = .5 + .1*(.5 + .5*cos (5.*iTime + 25.*p.y));\n\t    d = length (p) - r;\n    } else if (type == 1) { // turning cube\n        p.xz *= r2d (25.*iTime);\n        p.yz *= r2d (67.*iTime);\n        d = length (max (vec3 (.0), abs (p) - vec3 (.3))) - .05;\n    } else if (type == 2){ // spiky ball\n        float x = .5 + .5*cos (5.*(iTime + 2.) + 17.*p.x);\n        float y = .5 + .5*cos (5.*(iTime + 4.) + 17.*p.y);\n        float z = .5 + .5*cos (5.*(iTime + 6.) + 17.*p.z);\n    \tfloat r = .5 + .1*(x + y + z);\n        d = length (p) - r;\n    }\n\n\tobjectUVW = p;\n\n    return d;\n}\n\nfloat map (in vec3 p, in int type, inout vec3 objectUVW, inout int id) {\n    float g = p.y + 2.;\n    float w = p.z + 2.;\n    vec3 s = p;\n    vec3 t;\n    float b = sdThing (p, type, t);\n    float d = min (g, min (w, b));\n    if (d == g || d == w) {\n        objectUVW = s;\n        id = 0;\n    } else if (d == b) {\n        objectUVW = t;\n    \tid = 1;\n    }\n    return d;\n}\n\nfloat march (in vec3 ro, in vec3 rd, in int type, inout vec3 objectUVW, inout int id)\n{\n    float t = .0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    for (int i = 0; i < 64; ++i) {\n        p = ro + d*rd;\n        t = map (p, type, objectUVW, id);\n        if (abs (t) < .0001*(1. + .125*t)) break;\n        d += t*.75;\n    }\n\treturn d;\n}\n\nvec3 normal (in vec3 p, in int type) {\n    vec3 ignored1;\n    int ignored2;\n    float d = map (p, type, ignored1, ignored2);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map(p + e.xyy, type, ignored1, ignored2),\n                            map(p + e.yxy, type, ignored1, ignored2),\n                            map(p + e.yyx, type, ignored1, ignored2)) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 ldir, in float ldist, in int type) {\n    vec3 ignored1;\n    int ignored2;\n    float d2w = march (p + .01*n, ldir, type, ignored1, ignored2);\n    return ldist < d2w ? 1. : .5;\n}\n\nvec3 shade (in vec3 ro,\n            in vec3 rd,\n            in float d,\n            in vec3 n,\n            in vec3 lc,\n            in vec3 lp,\n            in float lshiny,\n            in int type,\n            in vec3 objectUVW,\n            in int id) {\n    vec3 amb = vec3 (.05);\n    vec3 p = ro + d*rd;\n    vec3 ldir = normalize (lp - p);\n    float ldist = distance (lp, p);\n    float diff = max (.0, dot (n, ldir));\n    float att = 4./(ldist*ldist);\n    float li = 2.;\n    vec3 mat = vec3 (.0);\n    if (id == 1 && type == 0) { // wavy ball\n        float m = smoothstep (.1, .2, .5 + .5*(cos (40.*objectUVW.x) * cos(40.*objectUVW.z)));\n        mat = mix (vec3 (1.), vec3 (.0), m);\n    }\n    else if (id == 1 && type == 1) { // turning cube\n        float m = smoothstep (.1, .2, .5 + .5*cos (20.*objectUVW.x));\n        float n = smoothstep (.1, .2, .5 + .5*cos (20.*objectUVW.y));\n        float o = smoothstep (.1, .2, .5 + .5*cos (20.*objectUVW.z));\n        mat = mix (vec3 (.125, .0, .25), vec3 (1., 1., 0), m*n*o);\n    }\n    else if (id == 1 && type == 2) { // spiky ball\n        float m = smoothstep (.2, .4, .5 + .5*cos (500.*objectUVW.x*objectUVW.y*objectUVW.z));\n        mat = mix (vec3 (.125, .25, .5), vec3 (.5, .25, .125), m);\n    }\n    else\n        mat = vec3 (.25);\n\n    float s = shadow (p, n, ldir, ldist, type);\n    vec3 h = normalize(-rd + ldir);\n    float sp = pow (max (.0, dot (n, h)), lshiny);\n\n\treturn amb + att*s*(diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n\tvec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*zoom;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvec3 miniRaymarcher (in vec2 uv,\n                     in vec3 lc,\n                     in vec3 lp,\n                     in float lshiny,\n                     in int type,\n                     in float offset,\n                     in float aspect)\n{\n    uv = uv*2. - 1.;\n    uv.x *= aspect;\n\n    vec3 ro = vec3 (2.*cos(iTime + offset), .75, 1.);\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = cam (uv, ro, aim, zoom);\n    vec3 objectUVW = vec3 (.0);\n    int id = 0;\n    float d = march (ro, rd, type, objectUVW, id);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, type);\n    vec3 col = shade (ro, rd, d, n, lc, lp, lshiny, type, objectUVW, id);\n    col += shade (ro, rd, d, n, lc, lp + vec3 (-1., .0, .0), lshiny, type, objectUVW, id);\n    col += shade (ro, rd, d, n, lc, lp + vec3 (1., .0, 1.), lshiny, type, objectUVW, id);\n\n    col *= 1. - .25*length (uv);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= r2d (20.*cos (iTime));\n    uv *= 1. + .25*length (vec2 (uv.x + .3*cos(2.*iTime + 8.*uv.y), uv.y));\n\n    vec3 col = vec3 (.0);\n    vec2 scale = 1.125*vec2 (1., 1.75);\n    vec2 grid = fract (uv*scale);\n    vec2 cell = floor (uv*scale);\n    float aspect = scale.y/scale.x;\n\n    uv.x += .5*(iTime+15.)*abs ((fbm (vec3 (cell.y + .75))));\n    grid = fract (uv*scale);\n    cell = floor (uv*scale);\n\n    float d = length (grid*2. - 1.) - .02;\n    float m = smoothstep (.01, .02, d);\n    col = vec3 (1. - m);\n    float r = fbm (vec3(cell+1., cell.x));\n    float g = fbm (vec3(cell+2., cell.y));\n    float b = fbm (vec3(cell.x, cell+3.));\n    float x = fbm (vec3(cell+2., cell.x));\n    float y = fbm (vec3(cell+4., cell.y));\n    float z = fbm (vec3(cell.x, cell+2.));\n    float shiny = 60.*fbm (vec3(cell, cell.x));\n    float offset = cos (iTime + cell.x + cell.y);\n    col = miniRaymarcher (grid,\n                          vec3 (r, g, b),\n                          vec3 (x, y, z),\n                          shiny,\n                          int(mod (floor(cell.x + cell.y),3.)),\n                          offset,\n                          aspect);\n\n    col = col/(1. + col);\n    col = pow (col, vec3 (1./2.2));\n    col *= mix (1., .5, .5 + .5*cos (600.*uv.y));\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}