{
    "Shader": {
        "info": {
            "date": "1602218467",
            "description": "Plis Disney don't sue me :(\nI wanted to rotate the mickey in xz axis but I was unable to do it. If you uncomment the 27 line and comment the 26 I try to transform the p.xz (axis I want to rotate) with a rotation transformation matrix, but doesn't works.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsycz1",
            "likes": 2,
            "name": "MM - Raymarching mickey",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "MatMercer",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 1024\n#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n\n#define SHADOW_OUT_DIST 0.02\n\nmat2 rotateMat(float deg) {\n    float s = sin(deg);\n    float c = cos(deg);\n   \n    return mat2(c, -s, s, c);\n}\n\n// raymarch distance formulas for primitives\nfloat sphere(vec4 s, vec3 view) {\n    return length(view - s.xyz) - s.w;\n}\n\nfloat plane(float y, vec3 view) {\n    return view.y - y;\n}\n\nfloat getDist(vec3 p) {\n    float plane = plane(0.0, p);\n    \n    p.xy *= rotateMat(sin(iTime) * .5);\n    //p.xz *= rotateMat(sin(iTime) * .5); \n    \n    float head = sphere(vec4(0, 1, 6, 1), p);\n    float ear1 = sphere(vec4(-1.0, 2, 6, 0.8), p);\n    float ear2 = sphere(vec4(1.0, 2, 6, 0.8), p);\n    float eye1 = sphere(vec4(-0.3, 1.3, 5.05, 0.1), p);\n    float eye2 = sphere(vec4(0.3, 1.3, 5.05, 0.1), p);\n    float nose = sphere(vec4(0, 1, 5, 0.1), p);\n\n    \n    return min(head,\n               min(ear1, \n                   min(ear2, \n                       min(eye1, \n                           min(eye2,\n                               min(nose, \n                                   plane))))));\n}\n\n// raymarch main loop\nfloat rayMarch(vec3 orig, vec3 dir) {\n   \tvec3 curPoint;\n    \n    float dist = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        curPoint = orig + dir * dist;\n        \n        float minDist = getDist(curPoint);\n                \n        dist += minDist;\n        \n        if (minDist < MIN_DIST || minDist > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\n// normal calculation function\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 view) {\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(p - view);\n    vec3 n = getNormal(view);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = rayMarch(view + n * SHADOW_OUT_DIST, l);\n    if (d < length(p - view)) dif *= .5;\n    \n    return dif;\n}\n\n// shader light function\nfloat getLight(vec3 p) {\n    return (light(vec3(-6, 6, 4), p) * 0.5) + (light(vec3(3, 4, 3), p) * 0.5);\n}\n\n// main img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // center coords\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    vec3 camera = vec3(0, 1.3, 1);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));\n    float d = rayMarch(camera, dir);\n    //d /= 10.;\n\n    vec3 p = camera + dir * d;\n    \n    float dif = getLight(p);\n\tvec3 col = vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}