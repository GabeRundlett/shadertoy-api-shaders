{
    "Shader": {
        "info": {
            "date": "1606897534",
            "description": "Improving Markus version.     Look around: mouse   Move: W,S + arrows\nprinciple: 2D SDF is precomputed in buffA.  \nFloor, ceiling and objects are added on the fly during rendering.",
            "flags": 48,
            "hasliked": 0,
            "id": "tsyBDR",
            "likes": 9,
            "name": "Raycaster with 2D SDF map  - Fab",
            "published": 3,
            "tags": [
                "raycaster",
                "mm"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 465
        },
        "renderpass": [
            {
                "code": "// Fork of \"Raycaster 2D SDF 0\" by markusm. https://shadertoy.com/view/wdB3WG 2020-11-29 11:47:08\n\n#define AA 2 // AA*AA sample per pixel\n\n//float seed = 0.;\n//float random() {    return fract(sin(seed++)*43758.5453123);  }\n\n// Create the camera dir, camera code is 3D, not really\nvoid getCameraDir( in vec2 uv, in vec3 pos, in vec3 lookAt, out vec3 rayDir )\n{\n\tvec3 camPos = pos;\n\tvec3 camLookAt = lookAt;\n\n    float ratio = iResolution.x / iResolution.y;\n \n\n    const float fov = 80.;\n    float halfWidth = tan(radians(fov) * .5);\n    float halfHeight = halfWidth / ratio;\n\n    vec3 w = normalize(camPos - camLookAt);\n    vec3 upVector = vec3(0, 1, 0 );\n\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n\n    vec2 p = 2.* uv - 1.;\n    vec3 dir = p.x * u* halfWidth  + p.y * v* halfHeight - w ;\n\n    rayDir = normalize( dir );\n}\n\nvoid mainImage( out vec4 fragColor, in float2 fragCoord )\n{    \n    vec2 uv = fragCoord / iResolution.xy,\n         M  = iMouse.xy / iResolution.xy;\n    if (M==vec2(0)) M = vec2(.5);\n  //fragColor = texture(iChannel0,uv).x*7.*vec4(1,-1,0,0); return;   // ( debug: show map )\n  //float seed = float(iTime) + hash12( uv );\n\n    float3 camPos = texelFetch( iChannel1, ivec2(0), 0 ).xyz, camDir;\n    float3 camLookAt = vec3( M.x, .5-M.y, .5 );\n\n    float3 Light =float3( .5+.25*cos(-3.*iTime), 0, .5+.25*sin(-3.*iTime) );    // light position\n\n    vec4 outColor = vec4( 0 );   \n    //vec3 camPos = vec3( 0.5, 0, 0.1), camDir;\n\n    for ( int aa = 0; aa < AA*AA; aa ++ )                                       // antialiasing loop\n    {\n        vec2 offset = ( vec2(aa%AA, aa/AA ) /float(AA) - .5 ) / iResolution.xy; // AA offset\n        getCameraDir( uv + offset, camPos, camLookAt, camDir );\n        vec4 sdfMap;\n        vec3 rayPos;\n        float t = 0., eps = 1./700.;    \n        for (int i = 0; i < 250; ++i)\n        {\n            rayPos = camPos + t * camDir;\n            sdfMap = texture( iChannel0, rayPos.xz );\n            sdfMap.xy = merge( sdfMap.xy, vec2( rayPos.y+.05, -1) );            // floor\n            sdfMap.xy = merge( sdfMap.xy, vec2(-rayPos.y+.05, -2) );            // ceiling\n            sdfMap.xy = merge( sdfMap.xy, vec2(length(Light-rayPos)-.01, -3));  // light\n            if (sdfMap.x < eps)  break;\n            t += sdfMap.x;                                 // sphere marching \n         // t += .005;                                     // 1 texel per step would be 1/700 = .0015\n        }\n        \n        if ( sdfMap.x > eps ) continue;                    // escape to infinity\n      //fragColor = vec4((3.+sdfMap.y)/5.); return;        // ( debug: show ids )\n        int o = int(sdfMap.y);\n\n        float2 uv = o < 0                                  // texture coords\n            ? rayPos.xz                                    //   floor & ceiling\n            : vec2(sdfMap.z,.5+.5*rayPos.y);               //   walls\n        float3 N  = o < 0                                  // normal\n            ? vec3(0, -sign(rayPos.y), 0 )                 //   floor & ceiling\n            : vec3( cos(sdfMap.w), 0, sin(sdfMap.w) );     //   restore normale\n        //  fragColor = vec4(.5+.5*N,0); return;           // ( debug: show normals )\n        float d = length(camPos-rayPos),\n            illu = 0.                                                         // ambiant\n                 + 1.5* max(0., dot( N, normalize(Light-rayPos) ))            // light source\n                 +  .6* max(0., dot( N, normalize(camPos-rayPos) )*.1/(d*d) );// head lamp\n        outColor +=\n            o==-3 ? vec4( 1 )                                                 // light source\n          : o==-1 ? vec4( .5, .5, 1, 1 ) * illu * texture(iChannel3, uv )     // floor\n          : o==-2 ? vec4( .5, .5, 1, 1 ) * illu * texture(iChannel2, 4.*uv )  // ceiling\n          : o== 0 ? vec4( 1 , 0 , 0, 1 ) * illu * texture(iChannel2, vec2(6,12)*uv ) // walls\n          : o== 1 ? vec4( 0 , 1 , 0, 1 ) * illu * texture(iChannel3, uv )     // column\n          : vec4(0);\n    }\n    outColor /= float(AA*AA);\n    fragColor = outColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat2 merge(float2 d1, float2 d2)\n{\n    if ( d1.x < d2.x ) return d1;\n\telse return d2;\n}\nfloat2 carve(float2 d1, float2 d2)\n{\n    if ( d1.x > d2.x ) return d1;\n\telse return d2;\n}\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nvec2 translate(float2 p, float2 t) \n{ \n    return p - t; \n}\n\nfloat sdCircle (float2 p, float radius)\n{\n\treturn length(p) - radius;\n}\nfloat uCircle (float2 p, float radius)                        // $Fab\n{\n\treturn .5 + atan(p.y,p.x)/6.283;\n}\nfloat nCircle (float2 p, float radius)                        // $Fab\n{\n\treturn  atan(p.y,p.x);\n}\n\nfloat sdBox(in float2 p, in float2 size, in float radius)\n{\n\tfloat2 d = abs(p) - size + radius;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\nfloat uBox(in float2 p, in float2 size, in float radius)       // $Fab\n{\n    p /= size;\n    float2 a = abs(p);\n\treturn .5+.5* ( a.x > a.y ? sign(p.x)*p.y : sign(p.y)*p.x  );\n}\nfloat nBox(in float2 p, in float2 size, in float radius)       // $Fab\n{\n    float2 a = abs(p),\n           s = .5+.5*sign(p);   // 0 or 1.\n\treturn 3.14* ( a.x > a.y ? s.x: .5 + s.y ); \n}\n\n#define sdFrame(p,size,radius) ( abs( sdBox(p,size,radius) ) - 10. )\n#define uFrame - uBox\n#define nFrame(p,size,radius) ( nBox(p,size,radius) + 3.14*float(sdBox(p,size,radius) < 0. ) )\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float4 map(float2 p)\n{\n    float2 center = float2( 350., 350. * iResolution.y / iResolution.x );\n\tfloat2 d = float2( 1000., -1.);\n    \n\td = merge( d, float2( sdFrame( translate( p, center), float2( 195., 195. ), 20.), 0 ) );\n\td = carve( d, float2( -sdBox(  translate( p ,center+float2(195,0)), float2( 40 ), 20.), 0 ) );\n\td = merge( d, float2( sdCircle( translate( p, center), 50.0 ), 1 ) );\n    \n    // defered calculation on uv and normals. More efficient, but duplicates scene description\n    float u = d.y==0. ? uBox( translate( p, center), float2( 195., 195. ), 20.) // uv and normals\n            : d.y==1. ? uCircle( translate( p, center), 50.0 )\n            : -1.,\n          a = d.y==0. ? nBox( translate( p, center), float2( 195., 195. ), 20.)\n            : d.y==1. ? nCircle( translate( p, center), 50.0 )\n            : -1.;\n                         \n    return float4( d, u, a );\n}\n\nvoid mainImage( out vec4 fragColor, in float2 fragCoord )\n{\n    vec2 uv = 700. * (fragCoord + .5) / iResolution.x;\n\n\tfragColor = map( uv );\n    fragColor.x /= 700.;                                  // normalize distances to [0,1]Â space\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nconst int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90;\n//  LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n//  Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n\nbool is_key_down   (int code) { return code != 0 && texelFetch(iChannel1, ivec2(code, 0), 0).r > 0.; }\nbool is_key_pressed(int code) { return code != 0 && texelFetch(iChannel1, ivec2(code, 1), 0).r > 0.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame == 0 )\n    \tfragColor = vec4(.5, 0, .1, 0);\n    else \n      if (fragCoord == vec2(.5 )) {\n\t\tfragColor = texelFetch( iChannel0, ivec2(0), 0 );   \n        float eps = .01;\n        if ( is_key_down( KEY_W ) ) fragColor.z += eps;\n        if ( is_key_down( KEY_S ) ) fragColor.z -= eps;\n        if ( is_key_down( 37 )    ) fragColor.x += eps;\n        if ( is_key_down( 39 )    ) fragColor.x -= eps;\n        if ( is_key_down( 38 )    ) fragColor.z += eps;\n        if ( is_key_down( 40 )    ) fragColor.z -= eps;\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}