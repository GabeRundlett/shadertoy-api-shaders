{
    "Shader": {
        "info": {
            "date": "1628985587",
            "description": "Just taking a play day and pushing out some i've been kicking around - concept from older shader. Two woven truchet tile patterns, with some glow effects. Using buffer tab to feed in color for Fog to get trail effect.",
            "flags": 32,
            "hasliked": 0,
            "id": "7ljXWt",
            "likes": 26,
            "name": "Abstract Truchet Inversion ",
            "published": 3,
            "tags": [
                "raymarching",
                "glow",
                "truchet",
                "inversion",
                "design"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 568
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Abstract Truchet Inversion \n    8/14/21 @byt3_m3chanic\n\n    (mouseable)\n    \n    suggest music to play (since soundcloud isnt working in shader)\n    https://soundcloud.com/relapserecords/07-survive-low-fog\n*/\nfloat offset[3] = float[]( 0.01, 1.75, 4.95 );\nfloat weight[3] = float[]( 0.2, 0.35, 0.075 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.32;\n    dt = smoothstep(0.82,.965,1.-dt);\n    vec3 Color = mix(R,C,dt);\n    \n    // output\n    Color=pow(Color, vec3(.4545));\n    fragColor = vec4(Color,1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Playing with some abstract forms and shapes\n    Standard truchet patten in 3d (grid) and\n    then warped nothing too exciting\n    \n    8/14/21 @byt3_m3chanic\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    20.00\n#define MIN_DIST    0.001\n#define SCALE       0.6500\n\n//utils\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//globals\nvec3 hit,hitP1,sid,id;\nfloat glow,speed;\nmat2 t90;\n\n//@iq torus sdf\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//make tile piece\nfloat truchet(vec3 p,vec3 x, vec2 r) {\n    return min(torus(p-x,r),torus(p+x,r));\n}\n\n//const\nconst float size = 1./SCALE;\nconst float hlf = size/2.;\nconst float dbl = 1./size;\nconst float shorten = 1.26;  \n\n//domain rep\nvec3 drep(inout vec3 p) {\n    vec3 id=floor((p+hlf)/size);\n    p = mod(p+hlf,size)-hlf;\n    return id;\n}\n\nvec2 map(vec3 q3, float gw){\n    vec2 res = vec2(100.,0.);\n\n    float k = 5.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += speed*.4;\n\n    vec3 qm = q3;\n    vec3 qd = q3+hlf;\n    qd.zy*=t90;\n    vec3 qid=drep(qm);\n    vec3 did=drep(qd);\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz+did.y);\n    \n    // truchet build parts\n    float thx = (.0750+.0475*sin(T+(q3.x+qid.z)*5.25) ) *size;\n    float thz = (.0115+.0325*sin(T*3.+(q3.x+did.z)*6.5) ) *size;\n    float thd = (.0515+.0325*sin(T*3.+(q3.x+did.z)*6.5) ) *size;\n    if(ht>.5) qm.x *= -1.;\n    if(hy>.5) qd.x *= -1.;\n    \n    // ring movement\n    float dir = mod(did.x+did.y,2.)<.5? -1. : 1.;\n    if(mod(did.z,2.)<1.)dir*=-1.;\n    vec2 d2 = vec2(length(qd-hlf), length(qd+hlf));  \n    \n    vec2 pp = d2.x<d2.y? vec2(qd - hlf) : vec2(qd + hlf);\n    pp *= rot(speed*dir);\n    \n    float a = atan(pp.y, pp.x);\n    float amt = 6.;\n    a = (floor(a/PI2*amt) + .5)/amt;\n\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hlf;\n    vec3 npos = vec3(qr.x,qr.y,qd.z);\n\n    //truchets1\n    float t = truchet(qm,vec3(hlf,hlf,.0),vec2(hlf,thx));\n    if(t<res.x) {\n        sid = qid;\n        hit = qm;\n        res = vec2(t,2.);\n    }\n    //truchets2\n    float d = truchet(qd,vec3(hlf,hlf,.0),vec2(hlf,thz));\n    if(d<res.x) {\n        sid = did;\n        hit = qd;\n        res = vec2(d,1.);\n    }\n    //rings\n    float f = truchet(npos.xzy,vec3(.0,0,0),vec2(thd,.025));\n    f=max(f,-(d-.01));\n    if(f<res.x) {\n        sid = did;\n        hit = qd;\n        res = vec2(f,3.);\n    }\n    //glows\n    if (gw==1.) glow += smoothstep(.1,.25,.002/(.0165+f*f)); \n\n    float mul = 1.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec3 FC= vec3(.001,.001,.001);\nvec3 gcolor = vec3(0.145,0.659,0.914);\nvec3 lpos = vec3(.0,.001,3.85);\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d) {\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    \n    for(int i=0;i<120;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p,1.);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.35: ray.x*.95;\n        m  = ray.y;\n    } \n    hitP1 = hit;\n    id = sid;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 12.);\n        fresnel = mix(.01, 1., fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; ){\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 24.);\n\n        if(m==1.) {\n            vec3 hp = hitP1/(1./SCALE);\n            float dir = mod(id.x + id.y,2.) * 2. - 1.;  \n            vec2 uv = hp.xy-sign(hp.x+hp.y+.001)*.5;\n            float angle = atan(uv.x, uv.y);\n            float a = sin(dir*angle*4.+T*1.25);\n            a = abs(abs(abs(a)-.5)-.24)-.124;\n            h = mix(gcolor, gcolor*.2, smoothstep(.01, .02, a));   \n            ref = h-fresnel;\n        }\n\n        if(m==2.) {\n            vec3 hp = hitP1/(1./SCALE);\n            float dir = mod(id.x + id.y,2.) * 2. - 1.;  \n            if(mod(id.z,2.)<1.)dir*=-1.;\n            vec2 uv = hp.xy-sign(hp.x+hp.y+.001)*.5;\n            float angle = atan(uv.x, uv.y);\n            float a = sin(dir*angle*8.+T*0.5);\n            a = abs(abs(abs(abs(a)-.75)-.5)-.25)-.06;\n            h = mix( vec3(.01), vec3(0.400,0.761,0.941) , smoothstep(.02, .01, a)); //vec3(0.400,0.761,0.941)\n            ref = h-fresnel;\n        }\n        if(m==3.) {\n            h = vec3(0.906,0.757,0.894); \n            ref = vec3(.0);\n        }\n        \n        C = diff*h+spec;\n        C = mix(FC.rgb,C,  exp(-.375*d*d*d));\n    \n        ro = p+n*.002;\n        rd = reflect(rd,n);\n        \n    } else {\n        C = FC.rgb;\n    }\n     \n    return vec3(C);\n}\n\nvoid topLayer(inout vec3 C, vec2 uv, float alpha) \n{\n    float px = fwidth(uv.x);\n    float md = mod(T*.1,2.);\n    float zw = md<1.? 2.: 1.25*sin(fract(T*.1));\n    float d = length(uv)-zw;\n    d=abs(d)-.002;\n    d=smoothstep(px,-px,d);\n    C =mix(C,gcolor,d);   \n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    t90 = rot(90.*PI/180.);\n    speed = T*.35;\n    FC = (texture(iChannel0,F.xy/R.xy).rgb)*.9;\n    gcolor = vec3(0.145,0.659,0.914);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,3.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? -.005 : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0.015 : -(M.x/R.x * .25 - .125) * PI;\n    \n    mat2 rx = rot(x);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    \n    float glowMask =0.;\n    float d =0.;\n\n    C = render(ro, rd, ref, d).rgb;\n\n\n    vec3 gcolor = vec3(0.145,0.659,0.914);\n\n    glowMask = clamp(glow,.0,1.);\n    C = mix(C,gcolor*glow,glowMask);\n    \n    float vw = .5+.5*sin(uv.x*.075+T*.3);\n    float fade = clamp((d*.045)+vw,0.,1.);\n    fade=abs(abs(fade)-.005)-.001;\n    C = mix(C,gcolor,smoothstep(.11,.1,fade)); \n    \n    topLayer(C,uv,d);\n    C = clamp(C,vec3(0),vec3(1));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}