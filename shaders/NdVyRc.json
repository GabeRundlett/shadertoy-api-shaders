{
    "Shader": {
        "info": {
            "date": "1656078262",
            "description": "Attaching an animated triangle Truchet weave to the triangle cells of an icosahedron.",
            "flags": 32,
            "hasliked": 0,
            "id": "NdVyRc",
            "likes": 65,
            "name": "Animated Icosahedral Weave",
            "published": 3,
            "tags": [
                "truchet",
                "geometry",
                "pattern",
                "icosahedron",
                "spherical",
                "polyhedron",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 931
        },
        "renderpass": [
            {
                "code": "/*\n\n    Animated Icosahedral Weave\n    --------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Animated Icosahedral Weave\n    --------------------------\n    \n    Of all the geometric art out there, 3D polyhedron variations would have to \n    be among my favorites. This is more of a 3D polyhedral texture demonstration,\n    but I'll post more interesting 3D ones later. This is the icosahedral \n    version of my previous \"Animated Triangle Grid Weave\" example. I was pretty \n    sure it'd work in theory, but couldn't be sure until I tried it. I was able \n    to use an icosahedral template of mine, so thankfully, didn't have to put \n    too much thinking into it.\n    \n    In fact, I put more effort into the background and color scheme than the \n    icosahedral sphere construction itself. Technically speaking, there wasn't\n    a great deal to it: Obtain the nearest icosahedral triangle face information, \n    then render arcs around each of the vertices. Obtain the angle of the pixel on\n    each arc, then use that to render some repeat moving parts, and that's it.\n    \n    Of course, I'm glossing over the spherical arc rendering and spherical \n    angles, but that's not as hard as you'd think, and you can find that amongst \n    the code somewhere.\n    \n    Anyway, this was just a simple demonstration, but as mentioned, I intend to \n    post more interesting examples along these lines later. \n\n    \n\n\tOther examples:\n    \n\t// To my knowledge, the following is the only animated polyhedral weave on \n    // here, which is not surprising, because although looking cool, they're not\n    // that fun to make. :) Having made one of these, I can say that the static \n    // non-animated version is simple enough to produce, but including moving parts \n    // can be fiddly work. I'll get around to posting my own one at some stage.\n    medusas hairdo with uv - flockaroo\n    https://www.shadertoy.com/view/ltBcDw\n    \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n    \n    // The flat plane version.\n    Animated Triangle Grid Weave - Shane\n    https://www.shadertoy.com/view/7sycz3\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Color: White: 0, Pinkish Red: 1, Green 2, Blue: 3.\n#define COLOR 1\n\n// Two arcs subtended from each spherical triangle vertex. The alternative\n// is a single arc.\n#define DOUBLE_ARC\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831859))*43758.5453); \n}\n\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(mod(dot(p, vec3(91.537, 151.761, 72.453)), 6.2831859))*435758.5453);\n}\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3./2.);\n    p.yz *= rot2(iTime/6./4. + 0.); \n    \n    return p;\n    \n}\n\n/*\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    \n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Two layers of noise.\nfloat fBm(vec3 p){ return n3DT(p)*.57 + n3DT(p*2.)*.28 + n3DT(p*4.)*.15; }\n*/ \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Moving parts direction vectors.\nvec3 dir, dir2;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n    \n\n    // Arc direction vectors. Hacked in at the last minute.\n    #ifdef DOUBLE_ARC\n    // You'd think this would present the most problems, but double\n    // arc directions are easier.\n    dir = vec3(1);\n    #else\n    // For single arcs, directions need to be flipped in two of the\n    // latitudinal strips, which is not all that surprising.\n    if(id==1 || id==2) dir = vec3(1, -1, 1);\n    else dir = vec3(-1, 1, -1);\n    #endif\n     \n    return q;\n}\n\n\n \n// You could get out a pen and paper and figure out the arc distances, or\n// if you're lazy like me, you could use Mattz's formula below. :)\n//\n// By the way, the original example that it comes from is awesome.\n// heavy metal squiggle orb - mattz\n// https://www.shadertoy.com/view/wsGfD3\n//\n// Distance from point p to a circle perpendicular to a central vector n \n// and passing through point p0.\n//\nfloat pCircDist(vec3 p, vec3 n, vec3 p0) {\n\n    // Projecting \"p0\" onto \"n\".\n    vec3 c = dot(p0, n)*n;\n    \n    // Perpendicular distance.\n    p -= c, p0 -= c;\n    \n    p -= normalize(p - dot(p, n)*n)*length(p0);\n    \n \n    return length(p); \n    \n}\n\n// Angle between 3D vectors. Similar to the 2D version. It's easy to derive\n// this yourself, or look it up on the internet.\nfloat angle(vec3 p0, vec3 p1){\n\n    return acos(dot(p0, p1)/(length(p0)*length(p1)));\n}\n\n// TDHooper's closest icosahedron vertex formula. The original is \n// clever and concise. The original formula is here:\n// Closest icosahedron vertices - tdhooper\n// https://www.shadertoy.com/view/fdXcDl\n//\nvec3 icosahedronVertex(inout vec3 p) {\n\n    // TDHooper's function is designed for differently aligned vertices,\n    // which I'm guessing are center face aligned along the vertical. Mine \n    // have vertically algined vertex poles, so rather than do rewrite \n    // the function, I've lazily realigned the coordinate system. Not my\n    // best work. :D\n    \n    // Coordinate realignment.\n    //const float iAng = acos(dot(vec3(PHI, 1, 0), \n    //                   vec3(0, 1, 0))/length(vec3(PHI, 1, 0)));\n    const float iAng = acos(1./length(vec2(PHI, 1)));\n    const float cIR = cos(iAng), sIR = sin(iAng);\n    const mat2 mIR = mat2(cIR, -sIR, sIR, cIR);\n    p.xy = mIR*p.xy;\n    \n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI, 1, 0);\n    if (ap.x + ap.z*PHI > dot(ap, v)) v = vec3(1, 0, PHI);\n    if (ap.z + ap.y*PHI > dot(ap, v)) v = vec3(0, PHI, 1);\n    return v*.52573111*(max(vec3(0), sign(p))*2. - 1.);\n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    float wall = -(length(p - sphPos - vec3(0, 0, -(48. - 3.))) - 48.);\n     // Flat plane back wall.\n    //float wall = -p.z + 3.;\n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n    \n///////////////////////////    \n\n    // Icosahedron vertices for the current cell.\n    // Using TDHooper's simple icasahedron vertices\n    // formula. \"v0\" is is the nearest vertex \n    // coordinate for a sphere of radius one.\n    vec3 v0 = icosahedronVertex(q); \n\n    // The \".5\" figure is compensating for the sphere's\n    // \".05\" radius.\n    float vert = length(q -  v0*.5) - .02;\n  \n////////////////////////////////    \n \n    // Overall object ID -- There in one rundundant slot there.\n    vID = vec4(sph, wall, vert, 1e5);\n    \n    // Shortest distance.\n    return  min(min(sph, wall), vert);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Frame blend value for the sphere.\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .25, -1.75);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t     \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        // A bright color with grey tones is a design cliche, but cliches are\n        // cliches for a reason. :)\n        #if COLOR == 0\n        const vec3 bCol = vec3(.7); // White.\n        #elif COLOR == 1\n        const vec3 bCol = vec3(1, .1, .2); // Pink.\n        #elif COLOR == 2\n        const vec3 bCol = vec3(.45, .85, .15); // Green.\n        #else\n        const vec3 bCol = vec3(.2, .6, 1.2); // Blue.\n        #endif\n        \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n            \n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            vec3[3] v, vertID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, vertID, rad);\n    \n            v[0] = sphericalToWorld(vertID[0]);//vec3(0, rad, 0);\n            v[1] = sphericalToWorld(vertID[1]);\n            v[2] = sphericalToWorld(vertID[2]);\n            \n             \n           \n            // Edge mid points, edge tangents and exit and entry points.\n            vec3[3] vE, vN;\n            vec3[6] vE2;\n            \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n  \n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness, which can be used for \n            // randomness, etc.\n            vec3 id = normalize((v[0] + v[1] + v[2]))*rad;\n             \n\n            // Icosahedral cell boundary.\n            //\n            // Rendering lines on a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float line = min(min(ep.x, ep.y), ep.z) - .0035;\n \n          \n            #ifdef DOUBLE_ARC\n            // Calculating the tangent vectors for each edge, as well as the two\n            // entry and exit points on each side of the mid-edge point. All are\n            // used to produce the random curves within each triangle cell.\n            for(int i = 0; i<3; i++){\n                \n                // Edge entry points -- One on each side of the mid point.\n                float mOffs = .333/2.; // Edge mid point offset.\n                vE2[i*2] = normalize(mix(v[i], v[(i + 1)%3], .5 - mOffs))*rad;\n                vE2[i*2 + 1] = normalize(mix(v[i], v[(i + 1)%3], .5 + mOffs))*rad; \n                \n            } \n            #endif\n           \n \n            vec3 laneDir = vec3(1);\n            // Rendering the spline curves between entry and exit points. There are six\n            // alltogether. We're indexing into random indices, and that creates the \n            // randomness, strangely enough. :)\n            vec3 ln = vec3(1e5), ln2 = vec3(1e5);\n            vec3 angl;\n             \n            for(int i = 0; i<3; i++){\n            \n                vec3 v0 = v[(i + 2)%3], v2 = v[(i + 1)%3];\n         \n                \n                // Using Mattz's spherical arc formula to determine the\n                // arc distance. It's easy enough to work out, but it's\n                // even easier just to use Mattz's formula. :) By the way,\n                // the original example that it comes from is awesome.\n                //\n                // heavy metal squiggle orb - mattz\n                // https://www.shadertoy.com/view/wsGfD3\n                #ifdef DOUBLE_ARC\n                ln[i] = pCircDist(lq, normalize(v0), vE2[((i + 2)%3)*2]); \n                ln[i] = abs(ln[i]); \n                ln2[i] = pCircDist(lq, normalize(v0), vE2[((i + 2)%3)*2 + 1]); \n                ln2[i] = abs(ln2[i]); \n                \n                if(ln[i]<ln2[i]) laneDir[i] *= -1.;\n                #else\n                ln[i] = pCircDist(lq, normalize(v0), vE[((i + 2)%3)]); \n                ln[i] = abs(ln[i]); \n                #endif\n                \n                // Moving parts.\n                //\n                // Angle of each pixel on each arc. As above, further calculations\n                // are performed outside the loop for speed.\n                angl[i] = angle(cross(lq, v0), cross(v2, v0));\n  \n\n            }\n            \n            // Combine the top and bottom arcs and givving them some thickness\n            #ifdef DOUBLE_ARC\n            // Comining the arcs in order to perform just a single render.\n            ln = min(ln, ln2);\n            ln -= .04;\n            #else\n            ln -= .05;\n            #endif\n            \n \n\n            \n            // RENDERING.\n            \n            \n            // Smoothing factor.\n            float sf = .003; \n           \n            \n            // Initial background color.\n            texCol = vec3(.05); \n\n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line ))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line))*.9);\n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z) - .035;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .0075));\n\n            \n            // Angular repetition.\n            #ifdef DOUBLE_ARC\n            // Repeat objects need to be divisible by 5 (due to the five triangles per\n            // revolution, or whatever), and maybe 2 also on occasion. If you don't like\n            // science, try any set of numbers, and if it works, great. :D\n            const float aOuter = 40., aInner = 20.;\n            vec3 angNum = vec3(aOuter); \n            // Less repetion along the inner arcs, since the arc length is shorter, which in\n            // turn means a smaller circle. Therefore, fewer squares are required to fill out\n            // the perimeter of the circle.\n            if(laneDir.x<0.){ angNum.x = aInner; };\n            if(laneDir.y<0.){ angNum.y = aInner; };\n            if(laneDir.z<0.){ angNum.z = aInner; };\n            #else\n            const float aOuter = 20.; // Only one arc, so only one repetition factor.\n            vec3 angNum = vec3(aOuter);        \n            #endif\n\n            // Angular ID, for multicolored squares. Not used here.\n            //vec3 rpFct = aInner/10.;// Repetition factor and ID (not used).\n            //vec3 angID = mod(floor(angl/6.2831*angNum*dir*laneDir + iTime*2.), rpFct)/rpFct;\n\n\n            // Repeat partitioning the squares along the vertical.\n            angl = fract(angl/6.2831*angNum*dir*laneDir + iTime*2.);\n\n            #ifdef DOUBLE_ARC\n            // No rounding, but it's there as an option.\n            vec3 an2 = vec3(0);//max(ln, cos(angl*6.2831)*.5 + .5);\n            // Moving squares.\n            angl = (abs(angl - .5)*2. - .85)/aOuter;\n            angl = max(angl, ln + .0165*(1. + an2*.2));\n            #else\n            // Rounding the square edges.\n            vec3 an2 = vec3(0);//max(ln, cos(angl*6.2831)*.5 + .5);\n            // Moving squares.\n            angl = (abs(angl - .5)*2. - .9)/aOuter;\n            angl = max(angl, ln + .0165*(1. + an2*.2));\n            #endif\n            \n            // Extra noise.\n            //float ns = fBm(txP*256.);\n            //texCol *= ns*.5 + .75;\n            \n            \n            // Rendering the arc lines and squares over the top.\n            for(int i = min(0, iFrame); i<3; i++){ \n            \n                // Arc lines.\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., ln[i] - .01))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, ln[i] - .0085));\n                texCol = mix(texCol, vec3(.1)*1.2, 1. - smoothstep(0., sf, ln[i]));\n                \n                // Arc line rails.\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, abs(ln[i] + .011 - .005) - .0025));\n           \n                // Squares.\n                //\n                //vec3 lCol = vec3(1);\n                //if(i==1) lCol = bCol;\n                //lCol = mod(angID[i], 2.)<.5? bCol : vec3(1);\n                vec3 lCol = bCol*1.2;//.5 + .45*sin(6.2831*angID[i] + vec3(0, 1, 2) + 1.);\n                float shd = max(.2 - angl[i]/.02, 0.);\n                vec3 rCol = vec3(1)*shd;//*(fract(angID[i])*.7 + .6);\n                //if(mod(floor(angID[i]*4.), 2.)<.5){ vec3 tmp = lCol; lCol = rCol; rCol = tmp; }\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, angl[i]));\n                texCol = mix(texCol, rCol, 1. - smoothstep(0., sf, angl[i] + .007));\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, angl[i] + .011));\n                texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, angl[i] + .018));\n                \n                \n            }\n            \n    \n            \n        }\n        else if(objID==1){ \n        \n            //  Wall.\n         \n            // Intitial background color.\n           \n           \n            // Rendering an ordered subdivided pattern.\n            const vec2 sc = vec2(1./2., 1./4.);\n            float sf = .005;\n            vec2 p = rot2(3.14159/6.)*sp.xy;\n            float iy = floor(p.y/sc.y);\n            float rndY = hash21(vec2(iy));\n            if(mod(iy, 2.)<.5) p.x += sc.x/2. + iTime/8.*(rndY*.65 + .35);\n            else p.x -= iTime/8.*(rndY*.65 + .35);\n            vec2 ip = floor(p/sc);\n            p -= (ip + .5)*sc;\n            \n            // I catered for angular subdivision, then decided against\n            // it, so this could be tidied up a lot, which I'll do later.\n            float a = 0.;//atan(sc.y, sc.x) + 3.14159/9.;\n            if(mod(ip.x, 2.)<.5) a += 3.14159/2.;\n            if(mod(ip.y, 2.)<.5) a += 3.14159/2.;\n            vec2 pR = rot2(-a)*p;\n            float tri = pR.y<0.? -1. : 1.;\n            ip.x += tri*.5; // Subdivided ID.\n            \n            // Rectangle distance value.\n            p = abs(p) - sc/2.;\n            float shp = max(p.x, p.y);\n            shp = max(shp, -tri*pR.y);\n            \n            // Rendering the squares.\n            texCol = vec3(.04) + hash21(ip)*.02;\n            // Extra noise.\n            //float ns = fBm(sp*256.);\n            //texCol *= ns*.5 + .75;\n            texCol = mix(texCol, texCol*2.5, (1. - smoothstep(0., sf*3.5, abs(shp) - .015)));\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(shp) - .015))*.9);\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(shp + .06) - .005))*.5);\n    \n            /*\n            // Rectangles on random blocks.\n            if(abs(ip.y + 2.)>7. && hash21(ip + .11)<.5){\n                shp += .045;\n                vec3 svCol = texCol;\n                float sh = max(.1 - shp/.08, 0.);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, shp));\n                texCol = mix(texCol, vec3(sh), 1. - smoothstep(0., sf, shp + .02));\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, shp + .04));\n                texCol = mix(texCol, bCol*1.2, 1. - smoothstep(0., sf, shp + .06));\n            } \n            */\n\n        }\n        else {  \n            // The icosahedral vertices.\n            texCol = bCol;\n        }\n\n        \n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh*2.);\n \n\n\n            // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}