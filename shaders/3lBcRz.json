{
    "Shader": {
        "info": {
            "date": "1595810351",
            "description": "Saw this as an animated GIF a long time ago.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lBcRz",
            "likes": 6,
            "name": "Circling circles",
            "published": 3,
            "tags": [
                "2d",
                "circles",
                "gif"
            ],
            "usePreview": 0,
            "username": "h3nr1x",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "const float speed = 2.5f;\n\nfloat circle(vec2 uv, vec2 center, float radious) {\n  float dist = length(uv - center);\n  return smoothstep(radious - 0.01f, radious, dist);\n}\n\nfloat circunference(vec2 uv, vec2 center, float radious, float thickness) {\n  float dist = length(uv - center);\n  // The |d - r| part below might be a bit confusing, \n  // to better understand it, I'd fully recommend \n  // https://www.youtube.com/watch?v=60VoL-F-jIQ  \n  return smoothstep(.0f, thickness, abs(dist - radious));\n}\n\nvoid mainImage(out vec4 frag_colour, in vec2 frag_coord) {\n  // These 2 lines:\n  // 1. Move the smaller dimension (usually Y) to [-1, 1]\n  // 2. Set (0, 0) at the center of the screen, and\n  // 3. Scale the larger dimension (usually X) accordingly \n  //    keeping the aspect ratio\n  // This make it all go to [-1.something, 1.something]\n  float m = min(iResolution.x, iResolution.y);\n  vec2 uv = (2.0f * frag_coord - iResolution.xy) / m; // (1)\n    \n  // To get min/max UV, replace frag_coord with 0 and W/H \n  // respectively in (1)\n  vec2 max_uv = iResolution.xy / m;\n  vec2 min_uv = -max_uv;\n\n  vec2 size = max_uv - min_uv;\n\n  float radious = size.x / 30.0f;\n  float dist_between_circles = radious + (radious / 10.0f);\n\n  vec3 colour = vec3(1.0f);\n\n  // Set a grid on top of our coordinate system and get the\n  // integers (i, j) for the quadrant our fragment is in\n  vec2 ij = (uv - min_uv) / dist_between_circles;\n  ij -= fract(ij);\n\n  const float thickness = 0.006;\n\n  // Visit the 8 surrounding quadrants (and ours at [i=0, jj=0]) \n  // to check if this fragment is part of a circuference from \n  // that quadrant, or the tiny moving circle. \n  for (int ii = -1; ii <= 1; ii++) {\n    for (int jj = -1; jj <= 1; jj++) {\n      vec2 iijj = ij + vec2(float(ii), float(jj));\n      vec2 center = min_uv + iijj * dist_between_circles;\n      colour *= circunference(uv, center, radious, thickness);\n \n      // The angle a for the moving little circle has an offset\n      // that depends on the cuadrant iijj\n      float offset = iijj.x * 0.5f - iijj.y * 0.5f;  \n      // The above can also be expressed as:\n      // float offset = dot(iijj, vec2(0.5f, -0.5f));\n        \n      // If you remove the offset below, all the\n      // circles will move in the same direction\n      float a = speed * -iTime - offset;\n      center += radious * vec2(cos(a), sin(a));\n      colour *= circle(uv, center, 0.02);\n    }\n  }\n\n\n  frag_colour = vec4(colour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}