{
    "Shader": {
        "info": {
            "date": "1610474131",
            "description": "WASD and mouse for movement\nSome settings are in common tab\n\nWhat else should I do/make with this/how can I improve this?",
            "flags": 48,
            "hasliked": 0,
            "id": "WlVcRh",
            "likes": 5,
            "name": "Path Tracing Testing 62",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "pathtrace",
                "pathtracing",
                "caustic"
            ],
            "usePreview": 0,
            "username": "Pjbomb2",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture( iChannel0, uv ).xyz;\n    \n    col *= 2.; // exposure\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    //col = pow( col, vec3(0.8,0.85,0.9) );\n    col = ACESFilm(col); // convert unbounded HDR color range to SDR color range\n    col = LinearToSRGB(col); // convert from linear to sRGB for display\n    col = smoothstep(0., 1., col); // increase contrast\n    \n    fragColor = vec4( col, 1 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//increase/decrease bouncecount for more bounces per ray\n#define BOUNCECOUNT 5\n//comment out to remove the procedural \"textures\"\n#define textures\n//comment out to remove the global sun and replace it with a skybox\n#define sun\n\n//material numbers\n#define MATFLOOR 0.\n#define MATBRONZE 1.\n#define MATCHROME 2.\n#define MATLIGHT 3.\n#define MATGLASS 4.\n\n//materials and their properties\nvec3 GetMatProps(in float matID, out float refl, out float refr, out float emmis, out float IOR, out float absorb) {//return material properties when what material is being hit is requested\n    if(matID == MATFLOOR) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(0.933,0.749,0.627);\n    }\n    if(matID == MATBRONZE) {\n     \trefl = 0.5;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.18;\n        return vec3(0.6, 0.5, 0.38);\n    }\n    if(matID == MATCHROME) {\n     \trefl = 0.85;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 2.3;\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if(matID == MATLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 10.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if(matID == MATGLASS) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 0.1;\n        IOR = 1.5;\n        return vec3(0.086,0.486,0.831);\n    }\n\nreturn vec3(1.0, 0.0, 1.0);\n}\n\n//Color correction from Demofox\nvec3 LessThan(vec3 f, float value) {return vec3(lessThan(f, vec3(value)));}//Reccomended change by Dave_Hoskins\n \nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n//used for procedural \"textures\"\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\n}\n\nfloat noise(const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat fbm(const in vec3 p, const in int octaves) {\n    float accum = 0.;\n    vec3 temp_p = p;\n    float weight = 1.;\n     \n    for (int i=0; i<octaves; i++) {\n        accum += weight * noise(temp_p);\n        weight *= .5;\n        temp_p *= 2.;\n    }\n    return abs(accum);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n//Applies textures to SDF's\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n ) {\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n\n//SDF functions\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat SDFSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat SDFBox(vec3 point, vec3 size) {\n    vec3 d = abs(point) - size;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 Union(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SmoothMin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotateZ( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\nvec3 rotateY( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//for non transparent materials\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident, float refl)\n{\n\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (refl + (1.0-refl) * ret);\n        return ret;\n\n}\n//for transparent materials\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0;\n    } \n    else { \n        float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nvec3 SunPos = vec3(100, 100, 0);\nvec3 sunCol = 2.0*vec3(0.8, 0.7, 0.6);\n\nuint wang_hash(inout uint seed) {//random number generator(unsigned integer)\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {//random number generator(float)\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state, in vec3 nor) {//cosine hemisphere ray direction calculation when ray bounces off an object\n    float u = RandomFloat01(state);\n    float v = RandomFloat01(state) * c_twopi;\n   \n    \t// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\nvec2 MapBoxes(vec3 rayPoint) {//organization: floor mapping function\n    float b = SDFBox(rayPoint - vec3(0,0.2,0), vec3(15, 1.1, 32));\n\n    vec2 scene = vec2(b,MATFLOOR);\n    return scene;\n}\n\nfloat MapSpheres(vec3 p) {//organization: sphere shape prefab\n    float a1 = SDFSphere(p, 1.0);\n    float a2 = sdTorus(p, vec2(1.0, 0.1));\n    p = rotateZ(p, 1.57);\n    float a3 = sdTorus(p, vec2(1.0, 0.1));\n    float a4 = SDFSphere(p - vec3(0,0,-1.25), 0.5);\n\n    float scene = max(min(a1,min(a2,a3)),-a4);\n    return scene;\n}\n\nvec2 MapLights(vec3 p) {//organization: light mapping function\n    float a = SDFSphere(p - vec3(0,6,3), 1.0);\n    vec2 ret = vec2(a, MATLIGHT);\n    return ret;\n}\n\nvec2 map(vec3 rayPoint, in float inside) {//main mapping function\n    rayPoint += vec3(0.0, 3.0, -2.0);\n        vec2 boxes = MapBoxes(rayPoint);\n        vec2 bronze = vec2(MapSpheres(rayPoint-vec3(0,3,3)),MATBRONZE);\n        vec2 chrome = vec2(MapSpheres(rayPoint-vec3(3,3,3)),MATCHROME);\n        float a = sdTorus(rayPoint - vec3(0,3,6), vec2(1.0, 0.3));\n        vec2 glass = vec2(min(MapSpheres(rayPoint-vec3(-3,3,3)),a),MATGLASS);\n        vec2 lights = MapLights(rayPoint);\n  \n    vec2 ret = boxes;\n    \n    ret = Union(ret, bronze);\n    ret = Union(ret, chrome);\n    ret = Union(ret, glass);\n    ret = Union(ret, lights);\n \n    if(ret.x < 0.0001) return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n    \n    \n    return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n}\n\nvec3 calcNormal( in vec3 pos ) {//normals calculation\n    vec2 eps = vec2(0.0001,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy, 0.0).x - map( pos-eps.xyy, 0.0).x,\n      map( pos+eps.yxy, 0.0).x - map( pos-eps.yxy, 0.0).x,\n      map( pos+eps.yyx, 0.0).x - map( pos-eps.yyx, 0.0).x ) );\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n\tfloat res = -1.0;\n    float tmax = 100.0;\n    float t = 0.001;\n    for(int i = 0; i < 228; i++) {\n    \tfloat h = map(ro+rd*t, inside).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n\nfloat shadow( in vec3 ro, in vec3 rd ) {//used for god rays when in enclosed spaces\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t, 0.0).x;\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n//creates the procedural \"textures\", like the dirtyness of the bronze\nvoid texturing(in float matID, inout vec3 surfaceColor, inout float refl, inout float refr, inout float emmis, inout float IOR, in vec3 pos) {\n  float fbm10 = sin(fbm(pos,15));\n    if(matID == MATFLOOR) {\n        surfaceColor = mix(surfaceColor, vec3(0.475,0.255,0.106), sin(fbm(pos, 1))/3.0);\n    }\n          \n    if(matID == MATBRONZE) {\n        surfaceColor = mix(surfaceColor, vec3(0.000,0.000,0.000), sin(fbm(pos, 15)));\n        refl = min(0.9 - max(0.0,fbm10)/2.0,1.0);\n    }\n\n}\n\n\nvec3 calcFinalColor(vec3 ro, vec3 rd, inout uint rngState) {//main function\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 colorMask = vec3(1.0);\n    float fdis = 0.0;\n\n    float emmis, refl, refr, absorb = 0.0;//material properties initialization\n    float IOR = 1.0003;\n        \n    vec3 norm = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    float rand = RandomFloat01(rngState);//initial random number generation\n    #ifdef sun\n     vec3 SunDir = normalize(SunPos - ro);\n    #endif\n\n    for(int bounce = 0; bounce < BOUNCECOUNT; bounce++) {\n\t\t#ifdef sun\n         SunDir = normalize(SunPos - ro);\n        #endif\n        rand = RandomFloat01(rngState);//random number generator\n        float preIOR = IOR;\n        float t = intersect(ro, rd, 0.0);\n        vec3 iColor = vec3(0.0);\n\n    \tif(bounce == 0) fdis = t;\n        vec3 pos = ro + rd*t;\n        vec3 surfaceColor = GetMatProps(map(pos, 0.0).y, refl, refr, emmis, IOR, absorb);//gets material color and properties\n\n        if( t < 0.0 ) {\n            #ifdef sun\n                colorMask *= sunCol;\n                iColor += max(pow(max(0.0, dot(rd, SunDir)), 10.0),0.0001) * (1.0 * sunCol) + 2.0 * accumulatedColor;\n                accumulatedColor += colorMask * iColor;//pow is to enhance the directionality of it, I wanted sharper shadows, so I did that\n            #else\n                colorMask *= texture(iChannel0, rd).xyz;\n                iColor += texture(iChannel0, rd).xyz+2.0*accumulatedColor;\n                accumulatedColor += iColor * colorMask * 0.5;\n            #endif\n            break;\n        }\n\n         norm = calcNormal(pos);\n\n        #ifdef textures\n         texturing(map(pos, 0.0).y, surfaceColor, refl, refr, emmis, IOR, pos);\n        #endif\n        if(refr == 1.0) {//if material is refractive\n            float eps = IOR;\n            if(t < 0.001) {//theory: if ray is already inside an object, use first calculation, else use second calculation\n                norm = -norm;         \n            }else {\n               eps = preIOR/eps;\n            }\n            \n            rd = (fresnel(rd, norm, preIOR/eps) > rand) ? reflect(rd, norm) : refract(rd, norm, eps);//Fresnel function located in common\n\n            t = intersect(pos, rd, 1.0);\n            pos += rd*t;\n                    \n            colorMask *= exp(-(surfaceColor*absorb) * t * t ); //coloring based on distance ray travels through transparent object\n        \n        }else { //else if material not refractive\n            colorMask *= surfaceColor;\n\n            //mix between reflective and diffuse ray directions\n            rd = mix( reflect(rd, norm), RandomUnitVector(rngState, norm), 1.0 - FresnelReflectAmount(1.003, IOR,rd, norm, refl));\n    \n              }\n\t\tro = pos;\n        iColor +=  (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);//apply colors and emmisive materials\n        accumulatedColor += colorMask * iColor;//apply colors and emmissive to final color\n\n    }\n    //distance fog\n    float ff = exp(-0.001*fdis*fdis);\n    accumulatedColor *= ff; \n    accumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n   \n   #ifdef sun\n       ff = exp(-0.1*fdis);\n\n       // volumetrics\n       float dt = 0.0;//change dt to increase fog, reccomended for enclosed spaces to make god rays\n       float acc = 0.0;\n       float t = fdis*rand;\n       vec3 pos = oro + ord*t;\n       acc += 5.0 * dt*shadow( pos, SunDir );//*exp(-0.25*t);\n       accumulatedColor += vec3(0.1)*pow(acc,2.0)*sunCol*0.4;\n    #endif\n    return accumulatedColor;\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {//Camera function to make flying camera\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;//anti-aliasing\n    \n    vec3 ro, rd, col = vec3(0.0);\n    Camera(fragCoord + jitter, ro, rd);\n    col = calcFinalColor(ro, rd, rngState);\n    \n    //reads from previous frame and blends the new frame into the old, and outputs that\n    vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );\n    float blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    \n    fragColor = vec4(col,blend);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}