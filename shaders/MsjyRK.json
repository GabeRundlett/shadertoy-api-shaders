{
    "Shader": {
        "info": {
            "date": "1492900124",
            "description": "Semi-accurate B-DNA model with the worms shader created by iq: https://www.shadertoy.com/view/XsjXR1",
            "flags": 1,
            "hasliked": 0,
            "id": "MsjyRK",
            "likes": 9,
            "name": "DNA Worms",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "worms",
                "dna"
            ],
            "usePreview": 0,
            "username": "wolf",
            "viewed": 875
        },
        "renderpass": [
            {
                "code": "// DNA Worms\n// combination of a couple things\n// DNA model - me, used wikipedia and a few other sources to get the numbers right.\n// (DNA-B)\n\n// worms:\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nvec2  sincos( float x ) { return vec2( sin(x), cos(x) ); }\nvec3  opU( vec3 d1, vec3 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// Smooth Min\n// https://iquilezles.org/articles/smin\n\n// Min Polynomial\n// ========================================\nfloat sMinP( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Min Exponential\n// ========================================\nfloat sMinE( float a, float b, float k) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// Min Power\n// ========================================\nfloat sMin( float a, float b, float k ) {\n    a = pow( a, k );\n    b = pow( b, k );\n    return pow( (a*b) / (a+b), 1.0/k );\n}\n\nmat4 Rot4X(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( 1, 0, 0, 0,\n                0, c,-s, 0,\n                0, s, c, 0,\n                0, 0, 0, 1 );\n}\n\n// Return 4x4 rotation Y matrix\n// angle in radians\n// ========================================\nmat4 Rot4Y(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( c, 0, s, 0,\n                0, 1, 0, 0,\n                -s, 0, c, 0,\n                0, 0, 0, 1 );\n}\n\n// Return 4x4 rotation Z matrix\n// angle in radians\n// ========================================\nmat4 Rot4Z(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n}\n\n// if no support for GLSL 1.2+\n//     #version 120\n// ========================================\nmat4 transposeM4(in mat4 m ) {\n    vec4 r0 = m[0];\n    vec4 r1 = m[1];\n    vec4 r2 = m[2];\n    vec4 r3 = m[3];\n\n    mat4 t = mat4(\n        vec4( r0.x, r1.x, r2.x, r3.x ),\n        vec4( r0.y, r1.y, r2.y, r3.y ),\n        vec4( r0.z, r1.z, r2.z, r3.z ),\n        vec4( r0.w, r1.w, r2.w, r3.w )\n    );\n    return t;\n}\n\n\n// Note: m must already be inverted!\n// TODO: invert(m) transpose(m)\n// Op Rotation / Translation\n// ========================================\nvec3 opTx( vec3 p, mat4 m ) {   // BUG in iq's docs, should be q\n    return (transposeM4(m)*vec4(p,1.0)).xyz;\n}\n\n// angstroms to world units\n#define ANG_TO_WORLD 0.1\n// angstroms\n#define DNA_RADIUS 10.72 * ANG_TO_WORLD\n\n#define RISE 3.32 * ANG_TO_WORLD\n\n#define OFFSET 21.44 * ANG_TO_WORLD\n// angstroms\n\n//#define ROTATION_PER_BP -0.5986479 / 3.32 / ANG_TO_WORLD\n#define ROTATION_PER_BP -0.180315633 / ANG_TO_WORLD\n\n#define BP_APOTHEM 3.84170 * ANG_TO_WORLD\n\n#define BP_WIDTH 20.01596 * ANG_TO_WORLD / 2.0\n\nvec3 opDNATwist(vec3 p) // 20 angs wide\n{\n    float c = cos(ROTATION_PER_BP * p.y); // angs / 10\n    float s = sin(ROTATION_PER_BP * p.y);\n    mat2 m = mat2(c, -s, s, c); // rotation matrix\n \treturn vec3(m * p.xz, p.y);\n}\n\nfloat mapDNA(vec3 pos) {\n    // dna base pair\n    float dnaBasePairs = sdBox(\n        opRep(\n            opDNATwist(pos - vec3(0, - RISE / 2.0, 0)) + vec3(BP_APOTHEM, 0, iTime * 1.0),\n            vec3(0, 0, RISE)\n        ),\n        vec3(.07, BP_WIDTH, .1)\n    );\n    \n    vec2 strands = opU(\n        vec2(sdBox(opDNATwist(pos) - vec3(0, DNA_RADIUS, 0), vec3(.225, .125, 100)), 200.),\n        vec2(sdBox(opDNATwist(pos + vec3(0, OFFSET, 0)) - vec3(0, DNA_RADIUS, 0.0), vec3(.225, .125, 100)), 100.0)\n    );\n    \n    \n    vec2 res = opU(\n        strands,\n        vec2(dnaBasePairs, 40.0)\n    );\n    \n    return res[0];\n}\n\nvec3 map( vec3 p )\n{\n    vec2  id = floor( (p.xz+1.0)/5.0 );\n    float ph = hash(id+113.1);\n    float ve = hash(id);\n\n    p.xz = mod( p.xz+1.0, 5.0 ) - 2.50;\n    p.xz += 0.5*cos( 2.0*ve*iTime + (p.y+ph)*vec2(0.53,0.32) - vec2(1.57,0.0) );\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(p.y-ve*iTime*ve+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(p.y-ve*iTime*ve+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(p.y-ve*iTime*ve+4.0);\n    \n    vec2 h1 = sdSegment( p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h2 = sdSegment( p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h3 = sdSegment( p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n\n    return opU( opU( vec3(h1.x-0.15*(0.8+0.2*sin(200.0*h1.y)), ve + 0.000, h1.y), \n                     vec3(h2.x-0.15*(0.8+0.2*sin(200.0*h2.y)), ve + 0.015, h2.y) ), \n                     vec3(mapDNA(p), ve + 0.030, h3.y) );\n\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float px, const float maxdist )\n{\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    vec3 h = map(ro + t*rd);\n        res = vec3( t, h.yz );\n        if( h.x<(px*t) || t>maxdist ) break;\n        t += min( h.x, 0.5 )*0.7;\n    }\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.003;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.1;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.0*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += h-d;\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float px )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    vec3 res = intersect( ro, rd, px, maxdist );\n    if( res.x < maxdist )\n    {\n        vec3  pos = ro + res.x*rd;\n        vec3  nor = calcNormal( pos );\n        float occ = calcOcc( pos, nor );\n\n        col = 0.5 + 0.5*cos( res.y*30.0 + vec3(0.0,4.4,4.0) );\n        col *= 0.5 + 1.5*nor.y;\n        col += clamp(1.0+dot(rd,nor),0.0,1.0);\n        float u = 800.0*res.z - sin(res.y)*iTime;\n        col *= 0.95 + 0.05*cos( u + 3.1416*cos(1.5*u + 3.1416*cos(3.0*u)) + vec3(0.0,1.0,2.0) );\n        col *= vec3(1.5,1.0,0.7);\n        col *= occ;\n\n        float fl = mod( (0.5+cos(2.0+res.y*47.0))*iTime + res.y*7.0, 4.0 )/4.0;\n        col *= 2.5 - 1.5*smoothstep(0.02,0.04,abs(res.z-fl));\n        \n        col *= exp( -0.1*res.x );\n        col *= 1.0 - smoothstep( 20.0, 30.0, res.x );\n    }\n    \n    return pow( col, vec3(0.5,1.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec2 q = fragCoord.xy/iResolution.xy;\n    \n\tvec3  ro = vec3(0.6,1.4,1.2);\n\tvec3  ta = vec3(-2.0,1.0,0.0);\n    float fl = 3.0;\n    vec3  ww = normalize( ta - ro);\n    vec3  uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3  vv = normalize( cross(ww,uu) );\n    vec3  rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\n    vec3 col = render( ro, rd, 1.0/(iResolution.y*fl) );\n    \n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 1.0, 0.0, 1.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, 0.001 );\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}