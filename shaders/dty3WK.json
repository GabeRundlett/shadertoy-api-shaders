{
    "Shader": {
        "info": {
            "date": "1684662116",
            "description": "mediocre speed run compo. nothing particular",
            "flags": 32,
            "hasliked": 0,
            "id": "dty3WK",
            "likes": 5,
            "name": "[Outline 2023]  геометрийн цэцэг",
            "published": 3,
            "tags": [
                "speedrun"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    fragColor.rgb /= (fragColor.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n // hash functions adapted from Devour\n// https://www.shadertoy.com/view/3llSzM\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\n/* vvv your shader goes here vvv */\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\n\nfloat box2(vec2 p,vec2 b){\n    p = abs(p)-b;\n    return length(max(p,vec2(0.)))+min(0.,max(p.x,p.y));\n}\nvec2 bb(vec3 p){\n       float s=1.;\n       for(float i=0.;i++<2.;){\n         \n         p =abs(p)-.5;\n         p*=2.9;\n         s*=2.9;\n         p = erot(p,normalize(vec3(.1,.2,.3)),.785);\n       }\n      vec2 h;\n      h.x = min(box2(p.xy,vec2(.25)),box2(p.yz,vec2(.5)));\n      h.y = 3.;\n      \n      vec2 t;\n    \n      t.x = box2(p.xz,vec2(.2));\n      t.y = 3.;\n      h=t.x < h.x ? t:h;\n      h.x /=s;\n     return  h;\n}\n// tdhooper 4D \nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\nvec3 op=p;\n    float f= length(p);\n    vec2 h;\n  \n    //p.z +=iTime;\n\n    vec4 p4 = inverseStereographic(p);\n     p4.wxy=erot(p4.xyw,normalize(vec3(1.,0.0,0.)),1.);\n    p = stereographic(p4);\n       \n     p=abs(p)-.5;\n   \n    float e = length(p);\n\n  \n    h = bb(p);\n    h.x*=min(1.,1./e)*max(1.,f);\n\n  \n     vec2 t;\n     t.x = length(p.xy)-.05;\n     t.y = 2.;\n     h=t.x < h.x ? t:h;\n    return h;\n}\n\nvec3 q(vec3 p, vec3 s){return s*sdf(p+s).x;}\nvec3 norm(vec3 p, float a){vec2 e=vec2(-a,a);return normalize(q(p,e.xyy)+q(p,e.yxy)+q(p,e.yyx)+q(p,e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n\t// set up UVs, jittered for antialiasing\n\tvec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n\n    \n\n            vec4 pframe = vec4(texture(iChannel0,fragCoord.xy/iResolution.xy));\n        fragColor = pframe;\n    vec3 col = .1*vec3(1.-sqrt(length(uv)));\n    \n    vec3 ro=vec3(0.25,0.25,-5.25),rt=vec3(0.,1.,2.);\n    vec3 z = normalize(rt-ro);\n    vec3 x= normalize(cross(vec3(0,1.,0.),z));\n    vec3 y = cross(z,x);\n    \n    vec3 rd= mat3(x,y,z)*normalize(vec3(uv,1.-.2*sqrt(length(uv))));\n    vec3 rp=ro;\n   \n    vec3 light = vec3(1.,2.,-3.);\n    float dd= 0.;\n    float i=0.;\n    vec3 acc=vec3(0.);\n    while(i++<128. && dd < 150.){\n        vec2 d = sdf(rp);\n        if(d.y==2.){\n            acc+=vec3(.1,.2,.33)*exp(10.*-abs(d.x))/10.;\n            d.x = max(.001,abs(d.x));\n        }\n        dd+=d.x;\n        rp+=rd*d.x;\n        if(d.x<.0001){\n             vec3 n = norm(rp,.0001);\n             vec3 l = normalize(light-rp);\n             \n             float dif = max(0.,dot(l,n));\n             float fr = 1.-max(0.,1.-dot(rd,n));\n             if(d.y == 3.){\n                rd=reflect(rd,normalize(n));\n                rp+=rd*.01;\n                continue;\n             }\n              \n             break;\n        }\n    }\n   col = mix(col,vec3(.1),-exp(-dd));\n    col= tanh(sqrt(col+acc));\n\n   \n    //Output to screen\n   fragColor.rgb += col;\n    fragColor.a++;\n  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}