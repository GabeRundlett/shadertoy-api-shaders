{
    "Shader": {
        "info": {
            "date": "1511790466",
            "description": "See explanation and description in comments. \n\nWith a focus on clarity and readablility, not performance.\n\n(Approximate) Line count:\nComments: 158\nWhitespace: 32\nCode: 50\nTotal: 240",
            "flags": 0,
            "hasliked": 0,
            "id": "XllfWH",
            "likes": 5,
            "name": "Unsigned distance to hyperbola",
            "published": 3,
            "tags": [
                "distance",
                "hyperbola"
            ],
            "usePreview": 0,
            "username": "mv",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "// \n// We approximate the (unsigned) distance from a point in the plane to the right branch of\n// a hyperbola in canonical form. \n//\n// The hyperbola is defined such that any point on the hyperbola (green) is equidistant \n// to the surface of two circles (blue) of varying radius.\n//\n// Note: Any hyperbola can be reduced to canonical form by an appropriate change\n//       of coordinates, i.e. by scaling, rotating and translating. \n//\n// Note: For debugging purposes the background is colored according to the number of \n//       iterations required to terminate the Newton-Rhapson iteration, and not the distance. \n//\t\t Each band corresponds to one iteration.\n//\n\nfloat dist_circle(vec2 p, float r)\n{\n    //\n    // Calculates the (signed) distance to a circle\n    //\n\treturn length(p) - r;\n}\n\nvec3 dist_hyperbola(vec2 p, float a, float c)\n{\n    //\n    // Calculates the (unsigned) distance to a hyperbola (in canonical form)\n    // with foci on the x-axis\n    // \n    \n    //\n    // EXPLANATION/DERIVATION:\n    //\n    \n    //\n\t// Given a canonical hyperbola with foci (±c, 0) and vertices (±a, 0), then\n\t// \n\t//     (x/a)² - (y/b)² = 1\n\t// \n\t// holds for any point (x,y) on the hyperbola, where b² = c² - a².\n    // \n    // A possible parametrization of the right branch of this curve is \n    //\n    //     P(t) = (x(t), y(t)), \n    //\n    // where\n    //\n    //     x(t) = a cosh(t)\n    //     y(t) = b sinh(t)\n    //\n    // since\n    //\n    //     cosh²(t) - sinh²(t) = 1.\n    //\n    \n    //\n    // The distance between a point p = (x,y) and the curve P(t) is found by \n    // calculating the value of t such that the distance between P(t) and p \n    // is minimized, or symbolically:\n    //\n    //     d/dt |P(t) - p| = 0\n    // \n    // The absolute value isn't convenient to work with, so we'll work with the\n    // square instead, which has the same solution for t:\n    //\n    //     d/dt |P(t) - p|² = 0\n    //\n    // This is convenient form, because we can work with the dot product\n    //\n    //     f(t) = |P(t) - p|² = dot(P(t) - p, P(t) - p)\n    // \n    \n    //\n    // When differentiating, using the chain rule, we get \n    // \n    //     d/dt (P(t) - p)² = 2 (P(t) - p) * d/dt (P(t) - p)) = 0\n    //\n    // or\n    //\n    //     (P(t) - p) * dP/dt = 0\n    //\n    // where the * represents a dot product, since we're working with vectors.\n    //\n    \n    // \n    // Differentiating x(t) and y(t) gives\n    //\n    //     dx/dt = d/dt cosh(t) = sinh(t)\n    //     dy/dt = d/dt sinh(t) = cosh(t)\n    //\n    // such that\n    //\n    //     dP/dt = (a sinh(t), b cosh(t))\n    //\n    \n    //\n    // We end up with\n    //\n    //     (a cosh(t) - x)*(a sinh(t)) + (b sinh(t) - y)*(b cosh(t)) = 0\n    //\n    // where p = (x,y) has been used. Simplifying, we get\n    //\n    //     a² cosh(t) sinh(t) + b² sinh(t) cosh(t) - a x sinh(t) - b y cosh(t) = 0\n    //\n    // and, by collecting terms and reordering, we get\n    //\n    //     f'(t) = g(t) = cosh(t) sinh(t) - A sinh(t) - B cosh(t) \n    //\n    // where \n    //\n    //     A = a x /(a² + b²)\n    //     B = b y /(a² + b²)\n    //\n    \n    //\n    // This expression might have analytical roots, but these are most likely not very nice\n    // to calculate or work with, as it's equivalent to solving a quartic polynomial. \n    // Instead we attempt a numerical solution, hoping that it converges rather quickly \n    // and consistently. \n    //\n    \n    //\n    // We will use a standard Newton-Rhapson iterative scheme for root solving:\n    //\n    // Given a function g(x) = 0, and an initial guess x_0, then by applying the following\n    // iterative scheme,\n    //\n    //     x_{n+1} = x_n - f(x_n)/f'(x_n)\n    // \n    // we should converge to a root as long as the function g(x) is sufficiently \"nice\".\n    //\n    \n    //\n    // By choosing the initial guess t_0 well, we can (hopefully) be guaranteed to reach the \n    // global minimum, thereby finding the value of t such that the distance is minimized.\n    //\n    \n    // \n    // At this point we have everything we need, so let's go:\n    //\n    \n    \n    //\n    // CALCULATIONS:\n    //\n    \n    // Helper quantities\n    float a2 = a*a;\n    float c2 = c*c;\n    float b2 = c2 - a2;\n    float b = sqrt(b2);\n    \n    float A = a*p.x/(a2 + b2);\n    float B = b*p.y/(a2 + b2);\n    \n    // try t = 0 as initial guess, this could/should most likely be improved\n    float t = 0.0;\n    //float t = p.y;\n    //float t = 1.0*length(p)*sign(p.y);\n    \n    // iterate\n    int i;\n    for (i = 0; i < 1000;i++) {\n        float ch = cosh(t);\n        float sh = sinh(t);\n        float dt = (ch * sh - A * sh - B * ch) / (ch * ch + sh * sh - A * ch - B * sh);\n        t = t - dt;\n        if (abs(dt) < 1.0e-3) break; // until sufficiently close to solution\n    }\n    \n    // calculate closest point\n    vec2 P = vec2(a*cosh(t), b*sinh(t));\n    \n    // return distance, iteration count and parameter\n    return vec3(length(P - p), float(i), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // between -2 and +2 on y axis, and similar on x axis after aspect ratio correction\n\tvec2 uv = 2.0*(2.0*fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // thickness of lines and smoothing width \n    float t = 0.04; \n    float w = 2.0*fwidth(uv.x);\n    \n    //\n    // Given a circle (-1.0, 0.0) and (1.0, 0.0) with radius r1 and r2, respectively,\n    // draw a hyperbola that is equidistant from both circles (surfaces) for any point \n    // along the hyperbola\n    //\n\n    float r1 = 0.5 + 0.4*cos(iTime);\n    float r2 = 0.5 - 0.4*cos(2.0*iTime);\n    \n    //\n    // Note, c = 1.0, since we place our circles (foci) at (±1, 0).\n    // instead, we vary the vertex position by varying the radius\n    //\n    // The rightmost point on the left circle has x coordinate (-1 + r1), and\n    // the leftmost point on the right circle has x coordinate (1 - r2).\n    // \n    // The vertex of the right branch of the hyperbola should pass through halfway \n    // between these two points:\n    //\n    //     ((-1 + r1) + (+1 - r2))/2 = (r1 - r2)/2\n    //\n    float a = (r1 - r2)/2.0;\n    \n    // calculate distance to hyperbola branch, and iteration count (for background color)\n    vec3 res = dist_hyperbola(uv, a, 1.0);\n    \n    // calculate distance to circles and extract distance from hyperbola from results\n\tfloat d1 = dist_circle(uv - vec2(-1.0, 0.0), r1);\n    float d2 = dist_circle(uv - vec2( 1.0, 0.0), r2);\n    float d3 = res.x;\n\t\n    // pass them through smoothstep to get thick anti-aliased lines (s = 1 inside, s = 0 outside)\n    float s1 = smoothstep(w/2.0, -w/2.0, abs(d1) - t);\n    float s2 = smoothstep(w/2.0, -w/2.0, abs(d2) - t);\n    float s3 = smoothstep(w/2.0, -w/2.0, abs(d3) - t);\n    \n    // define colors\n    vec3 bgColor = vec3(0.5 + 0.5*cos(res.y));\n    vec3 circleColor = vec3(0.0, 0.0, 1.0);\n    vec3 hyperbolaColor = vec3(0.0, 1.0, 0.0);\n    \n    // compose colors\n    vec3 col = bgColor;\n    col = col*(1.0 - s1) + circleColor*s1;\n    col = col*(1.0 - s2) + circleColor*s2;\n    col = col*(1.0 - s3) + hyperbolaColor*s3;\n    \n    // final output\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}