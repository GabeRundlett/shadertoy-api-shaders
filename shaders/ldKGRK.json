{
    "Shader": {
        "info": {
            "date": "1455405925",
            "description": "This was too obvious to resist. \nThanks to BigWings for the butterflies: https://www.shadertoy.com/view/XsVGRV\nSome of them are *really* beautiful :)",
            "flags": 32,
            "hasliked": 0,
            "id": "ldKGRK",
            "likes": 27,
            "name": "butterfly evolution",
            "published": 3,
            "tags": [
                "evolutionary"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 1624
        },
        "renderpass": [
            {
                "code": "/* Based on BigWing's \"The Butterfly Effect\" https://www.shadertoy.com/view/XsVGRV\n   \n   Uses the evolution code from https://www.shadertoy.com/view/XdyGWw\n*/\n\n/*  Interactive Evolutionary Framework - https://www.shadertoy.com/view/XdyGWw\n    (c) 0x7e Stefan Berke\n   \tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tRender some image, animation or what-have-you from a set of parameters\n    and evolve the parameters by choosing an offspring to populate the next pool.\n\n    The pool is split into tiles on the screen. \n\tClicking a tile fills the rest of the pool with new variations. \n\tRewind or red cross resets to new, previously unseen! population\n\n  USAGE:\n\t(bottom-right) \n\tred cross =     reset pool\n\tgreen cross =   cross-breed locked tiles\n\n\t(per tile)\n\twhite square =  lock/unlock tile\n    green square =  show big\n\n  FOR CODER:\n\tEach parameter set (per tile) is a rectangle of size iResolution.x, NUM_PARAM_ROWS\n\tin the input buffer. So with one row, you have easily 200+ parameters to use. \n\tIncrease NUM_PARAM_ROWS if you need more. \n\tTo plug into this framework, defined theImage() and use the parameter() function \n\tto drive all image generation with the returned values. \n\tThe values are vec4s initialized in the range [-1,1]\n\t(range is adjustable in BufA)\n\n\tVersion 0.4\n      - cross breeding of locked tiles\n      - min/max ranges for random values\n\n\tVersion 0.3\n      - big display (with numbers) via green button\n\t  - single mouse-down event on click\n      - TODO only prints x component of parameters..\n\n\tVersion 0.21\n\t  - fixed anti-aliasing\n\tVersion 0.2\n      - added locking\n\n\tVersion 0.1\n\t  TODO: Cross-breeding, Undo, Favorites/Keep/Bookmark, \n\t\t    Print parameter values  \n*/\n\n#define AA 1\t\t\t\t\t\t// anti-aliasing > 1\n#define DO_PRINT 1\t\t\t\t\t// print numbers in big view ?\t\n#define SHOW_VALUES 0\t\t\t\t// show only parameter values (for debugging)\nconst int NUM_PARAM_ROWS = 1;\t\t// Number of rows of parameters for one 'tile'\nconst int NUM_TILES = 4;\t\t\t// Number of 'tiles' per screen screen height\n\n\n// ---- parameters ----\n\nint cur_tile; // (initialized in main)\n\n// returns the parameters for the current 'tile' \nvec4 parameter(in int column, in int row) \n{ \n    vec2 uv = (vec2(column+2, row + cur_tile * NUM_PARAM_ROWS)+.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv)\n    // some slight varying in time\n        + 0.006 * sin(float(column) + iTime) * vec4(1., -1., -1., 1.);\n        ;    \n}\n\n// wrapper, if you don't use rows\nvec4 parameter(in int column) { return parameter(column, 0); }\n\n// wrapper that just gives the next number\nint _P = 0;\nvec4 parameter() { return parameter(_P++); }\n\n\n\n// 8<---------8<---------8<--------8<--\n// paste your favorite algorithm here\n// and use the parameter() function above\n\n\n// \"The Butterfly Effect\" by Martijn Steinrucken aka BigWings - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Removed some stuff and replaced all hash() uses with parameter() - bergi\n// PS. Numbers can get bigger than 1.0, after a while it gets experimental..\n\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n#define S01(x, offset, frequency) (sin((x+offset)*frequency*TWOPI)*.5+.5)\n#define S(x, offset, frequency) sin((x+offset)*frequency*TWOPI)\n#define B(x,y,z) S(x, x+fwidth(z), z)*S(y+fwidth(z), y, z)\n#define saturate(x) clamp(x,0.,1.)\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat SHAPESHIFT=0.;\n\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( float j=-1.; j<=1.; j++ )\t\t// iterate cell neighbors\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2  g = vec2( i, j );\t\t\t// vector holding offset to current cell\n        vec2  o = hash2( n + g );\t\t// unique random offset per cell\n      \to.y*=.1;\n        vec2  r = g - f + o;\t\t\t// current pixel pos in local coords\n\t   \n\t\tfloat d = dot( r, r );\t\t\t// squared dist from center of local coord system\n        \n        if( d<m.x )\t\t\t\t\t\t// if dist is smallest...\n            m = vec3( d, o );\t\t\t// .. save new smallest dist and offset\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nfloat skewcirc(vec2 uv, vec2 p, float size, float skew, float blur) {\n\tuv -= p;\n    \n    uv.x *= 1.+uv.y*skew;\n    \n    float c = length(uv);\n    c = smoothstep(size+blur, size-blur, c);\n    return c;\n}\n\nfloat curve(float x, vec4 offs, vec4 amp, vec4 pulse) {\n    // returns a fourier-synthesied signal followed by a band-filter\n\tx *= 3. * pulse.w;\n    \n    vec4 c = vec4(\tS(x, offs.x, 1.),\n                  \tS(x, offs.y, 2.),\n                 \tS(x, offs.z, 4.),\n                 \tS(x, offs.w, 8.));\n\n    float v = dot(c, amp*vec4(1., .5, .25, .125));\n    \n    pulse.y/=2.;\n    \n    v *= smoothstep(pulse.x-pulse.y-pulse.z, pulse.x-pulse.y, x);\n    v *= smoothstep(pulse.x+pulse.y+pulse.z, pulse.x+pulse.y, x); \n    return v;\n}\n\nvec4 Wing(vec2 st, float radius, vec2 center, vec4 misc, vec4 offs, vec4 amp, vec4 pattern1, vec4 global, vec4 detail) {\n\t// returns a wings shape in the lower right quadrant (.5<st.x<1)\n    // we do this by drawing a circle... (white if st.y<radius, black otherwise)\n    // ...and scaling the radius based on st.x \n    // when st.x<.5 or st.x>1 radius will be 0, inside of the interval it will be \n    // an upside down parabola with a maximum of 1\n    \n    vec2 o=vec2(0.);\n        \n    // use upsidedown parabola 1-((x - center)*4)^2\n    float b = mix(center.x, center.y, st.x);\t// change the center based on the angle to further control the wings shape\n    float a = (st.x-b)*4.;\t\t\t// *4 so curve crosses 0 at .5 and 1.\n    a *= a;\n    a = 1.-a;\t\t\t\t\t\t// flip curve upside down\n    float f = max(0., a);\t\t\t// make curve 0 outside of interval\n    \n    f = pow(f, mix(.5, 3., misc.x));\n    \n    o.x = st.x;\n    \n    float r = 0.;\n    float x = st.x*2.;\n    \n    vec2 vor = voronoi(vec2(st.x, st.y*.1)*40.*detail.z);\n    \n    r = curve(x-b, offs, amp,vec4(global.x, global.y, max(.1, global.z), .333));\n\n    r = (radius + r*.1)*f;\n    \n    float edge = 0.01;//max(.001, fwidth(r))*4.;\n    \n    o.x = smoothstep(r, r-edge, st.y);\n    o.y=r;\n    \n    float t = 0.;//floor(iTime*2.)*SHAPESHIFT;\n    \n    \n    vec3 edgeCol = parameter().xyz;\n    vec3 mainCol = parameter().xyz;\n    vec3 detailCol = cross(edgeCol, mainCol);\n    \n    vec3 col = mainCol;\n    \n    misc = pow(misc, vec4(10.));\n    \n    r -= misc.y*curve(x-b, amp, offs, vec4(offs.xw, amp.wz));\n    \n    float edgeBand =  smoothstep(r-edge*3.*misc.w, r, st.y);\n    col = mix(col, edgeCol, edgeBand);\n    r = st.y-r;\n    \n    float clockValue = curve(r*.5+.5, pattern1, offs, amp)*global.x;\n    \n    float distValue = curve(length(st-offs.yx), pattern1.wzyx, amp, global);\n    \n    col += (clockValue+pow(distValue,3.))*detail.z;\n    \n    \n    float d= distance(st, fract(st*20.*detail.x*detail.x));\n    col += st.y*st.y*smoothstep(.1, .0, d)*detail.w*5.*curve(st.x,pattern1, offs, amp);\n    \n    col *= mix(1., st.y*st.y*(1.-vor.x*vor.x)*15., detail.x*detail.w);\n    \n    return vec4(col, o.x);\n}\n\nvec4 body(vec2 uv, vec4 n) {\n\t\n    float eyes = skewcirc(uv, vec2(.005, .06), .01, 0., 0.001);\n    \n    uv.x+=.01;\n    uv.x *= 3.;\n    \n    vec2 p = vec2(-.0, 0.);\n    float size = .08;\n    float skew = 2.1;\n    float blur = .005;\n    \n    float v = skewcirc(uv, p, size, skew, blur);\n    \n    p.y -= .1;\n    uv.x *= mix(.5, 1.5, n.x);\n    v += skewcirc(uv, p, size, skew, blur);\n    \n    vec4 col = n.w*.1+ vec4(.1)* saturate(1.-uv.x*10.)*mix(.1, .6, S01(uv.y, 0., mix(20., 40., n.y)));\n    col +=.1;\n    col.a = saturate(v);\n    \n    \n    col = mix(col, n*n, eyes);\n    \n    return col;\n}\n\nfloat BlockWave(float x, float b, float c) {\n\t// expects 0<x<1\n    // returns a block wave where b is the high part and c is the transition width\n    \n    return smoothstep(b-c, b, x)*smoothstep(1., 1.-c, x);\n}\n\n// evo-render entrypoint, uv is -1,1\nvec3 theImage(in vec2 uv)\n{\n    float t = iTime;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n        \n    vec2 p = uv*.7;\n    \n    SHAPESHIFT = 0.;\t\t// turns the overall shapeshifting on or off\n                \n    p.x = abs(p.x);\t\t\t\t\t\t\t\t// mirror wings\n\n    float shapeShifter = SHAPESHIFT;\t\t\t\n    \n    float it = parameter().x*10.+.25;\n    \n    vec4 pattern1 = parameter();\t\t\t// get a whole bunch of random numbers \n    vec4 n1 = parameter();\n    vec4 n2 = parameter();\n    vec4 n3 = parameter();\n    vec4 global = parameter();\n    vec4 detail = parameter();\n    vec4 nBody = parameter();\n    \n    p.x-=.01*n1.x;\t\t\t\t\t\t\t// distance between wings\n    \n    vec4 col = vec4(1.);\n\tvec4 bodyCol = body(p, nBody);\n    \n    float wingFlap = pow(S01(t+parameter().x*20., 10., .05), 60.); \n    \n    p.x *= mix(1.,20., wingFlap);\n    \n    vec2 st = vec2(atan(p.x, p.y), length(p));\n    st.x /= PI;\n    \n    vec4 top = vec4(0.);\n    if(st.x<.6)\n    \ttop = Wing(st, .5, vec2(.25, .4), n1, n2, n3, pattern1, global, detail);\n    vec4 bottom = vec4(0.);\n    if(st.x>.4)\n    \tbottom = Wing(st, .4, vec2(.5, .75), n2, n3, n1, pattern1, global, detail); \n    \n    wingFlap = (1.-wingFlap*.9);\n    \n    vec4 wings = mix(bottom, top, top.a);\n    wings.rgb *= wingFlap;\t\t\t\t\t\t\t// darken wings when they are back-to-back\n    \n  \tcol = mix(bodyCol*bodyCol.a, wings, wings.a);\t// composite wings and body\n    // background\n    col = mix(col, vec4(0.15, 0.25, 0.3, 1.), smoothstep(.01, .0, dot(col,col)));   \n    \n    return col.xyz;\n}\n\n\n\n// 8<---------8<---------8<--------8<--\n\n\n\n// --- ui state ---\n\n// is the given 'tile' excluded from mutation?\nbool isTileLocked(in int cur_tile) \n{\n    vec2 uv = (vec2(1, cur_tile * NUM_PARAM_ROWS) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x >= .5;\n}\n\n// returns selected tile (even if already unselected)\nint selectedTile()\n{\n    vec2 uv = (vec2(0., 1.) + .5) / iChannelResolution[0].xy;\n\treturn int(texture(iChannel0, uv).x)-1;\n}\n\n// transition for selection fade-in\nfloat selectionMorph()\n{\n    vec2 uv = (vec2(0., 2.) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x;\n}\n\n// --- number printing --- \n// from effie https://www.shadertoy.com/view/ldGGRG\n// XXX not used yet\n\n#define BLUR 0.1\nfloat segment(vec2 uv){//from Andre https://www.shadertoy.com/view/Xsy3zG\n\tuv = abs(uv);return (1.0-smoothstep(0.07-BLUR,0.07+BLUR,uv.x)) * (1.0-smoothstep(0.46-BLUR,0.46+BLUR,uv.y+uv.x)) ;//* (1.25 - length(uv*vec2(3.8,1.3)))\n\t//uv = abs(uv);return (1.0-smoothstep(udef[6]-udef[8],udef[6]+udef[8],uv.x)) * (1.0-smoothstep(udef[7]-udef[8],udef[7]+udef[8],uv.y+uv.x)) ;//* (1.25 - length(uv*vec2(3.8,1.3)))\n}\nfloat sevenSegment(vec2 uv,int num){\n\tuv=(uv-0.5)*vec2(1.5,2.2);\n\tfloat seg=0.0;if(num>=2 && num!=7 || num==-2)seg+=segment(uv.yx);\n\tif (num==0 || (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):(uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))seg += segment(abs(uv)-0.5); \n\tif (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))seg += segment(vec2(abs(uv.y)-1.0,uv.x)); \n\treturn seg;\n}\n//prints a \"num\" filling the \"rect\" with \"spaces\" # of digits including minus sign\nfloat formatNum(vec2 uv, vec2 rect, float num, int spaces){//only good up to 6 spaces!\n\tuv/=rect;if(uv.x<0.0 || uv.y<0.0 || uv.x>1.0 || uv.y>1.0)return 0.0;\n\tuv.x*=float(spaces);\n\tfloat place=floor(uv.x);\n\tif(num<0.0){if(place==0.0)return segment((uv.yx-0.5)*vec2(2.2,1.5));else {num=-num;place-=1.0;uv.x-=1.0;spaces-=1;}}\n\tfloat decpnt=floor(max(log(num)/log(10.0),0.0));//how many digits before the decimal place\n\tif(decpnt==0.0 && num<1.0){place+=1.0;uv.x+=1.0;spaces+=1;}\n\tfloat period=(decpnt==float(spaces-1)?0.0:1.0-smoothstep(0.06-BLUR/2.,0.06+BLUR/2.,length(uv-vec2(decpnt+1.0,0.1))));\n\tuv.x=fract(uv.x);\n\tnum+=0.000001*pow(10.,decpnt);\n\tnum /= pow(10.,decpnt-place);\n\tnum = mod(floor(num),10.0);\n\treturn period+sevenSegment(uv,int(num));\n}\n\n// --- end number printing\n\n\n// --- other ui stuff ---\n\nfloat drawRect(in vec2 uv, in vec2 pos, in float si)\n{\n    si *= 0.9;\n    uv -= pos;\n    uv /= si;\n    float s = max( abs(uv.x), abs(uv.y) );\n    return pow(clamp(s * (1.-s) * 4., 0., 1.), 30.);\n}\n\nvec3 theImage_(in vec2 uv)\n{\n#if SHOW_VALUES\n    int par = int(50. * (uv.x * .5 + .5));\n    float p = parameter(par).x;\n    float v = smoothstep(.1, 0., abs(uv.y - p));\n    v += (uv.y > 0. && uv.y < p) || (uv.y < 0. && uv.y > p) ? .5 : 0.;\n    return vec3(0., v, 0.) + .3;\n        \n#else\n    return theImage(uv);\n#endif\n}\n\nvoid renderBig(inout vec4 fragColor, in vec2 fragCoord)\n{\n    _P = 0;\n    \n    float trans = selectionMorph();\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n\tvec2 tileuv = uv*(2.-trans);\n    \n    if (tileuv.x > -1. && tileuv.x < 1.\n       && tileuv.y > -1. && tileuv.y < 1.)\n    {\n#if AA <= 1\n\t\tvec3 col = theImage_(tileuv);\n#else\n        float width = iResolution.x - iResolution.y;\n        vec2 sc = vec2(2.) / width / float(AA);\n        vec3 col = vec3(0.);\n        for (int j=0; j<AA; ++j)\n        for (int i=0; i<AA; ++i)\n        {\n            _P = 0;\n            col += theImage_(tileuv + sc * vec2(float(i), float(j)));\n        }\n        col /= float(AA * AA);\n#endif\n        \n\t\t// vignette\n        float border = pow(max(abs(tileuv.x), abs(tileuv.y)), 20.);\n        col *= 1. - border;\n    \t\n        fragColor += trans * (vec4(col, 1.) - fragColor);\n\t}\n    // shadow \n    else if (tileuv.x > -1.1 && tileuv.x < 1.1\n       && tileuv.y > -1.1 && tileuv.y < 1.1)\n    {\n        float border = pow(max(abs(tileuv.x*.9), abs(tileuv.y*.9)), 15.);\n        fragColor.xyz *= mix(1., border, trans);\n    }\n#if DO_PRINT\n    // params\n    if (tileuv.x > 1. && tileuv.y > -1. && tileuv.y < 1.)\n    {\n        tileuv += vec2(-1., 1.);\n        fragColor.xyz -= .4 * trans * fragColor.xyz;\n        int P = int(tileuv.y / .1);\n        tileuv.y = mod(tileuv.y, .1);\n        tileuv.x -= .1;\n        fragColor.xyz += trans * formatNum(\n            tileuv, vec2(.6, .09)*.6, parameter(P).x, 6);\n    }\n#endif\n}\n\nvoid renderTiles(inout vec4 fragColor, in vec2 fragCoord)\n{ \n    // get per-tile uv\n    float width = iResolution.y / float(NUM_TILES);\n    vec2 tileuv = vec2(mod(fragCoord.x, width), \n                       mod(fragCoord.y, width)) \n        / iResolution.y * float(NUM_TILES) * 2.  - 1.;\n\n    // --- render ---\n\n    #if AA <= 1\n    vec3 col = theImage_(tileuv);\n    #else\n    vec2 sc = vec2(2.) / width / float(AA);\n    vec3 col = vec3(0.);\n    for (int j=0; j<AA; ++j)\n        for (int i=0; i<AA; ++i)\n        {\n            _P = 0;\n            col += theImage_(tileuv + sc * vec2(float(i), float(j)));\n        }\n    col /= float(AA * AA);\n    #endif\n\n    // vignette\n    float border = pow(max(abs(tileuv.x), abs(tileuv.y)), 20.);\n    col *= 1. - border;\n\n    // --- various indicators ---\n\n    // lock inidicator\n    if (isTileLocked(cur_tile))\n        col.xyz += border;\n\n    // put into [0,1]\n    tileuv = tileuv * .5 + .5;\n\n    // lock square\n    col.xyz += (isTileLocked(cur_tile)? 1. : .4)\n        * drawRect(tileuv, vec2(.075, .925), .15);\n\n    // display square\n    col.y += .4*drawRect(tileuv, vec2(.225, .925), .15);\n\n    fragColor = vec4(col, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    fragColor = vec4(0.);\n    \n    // determine the rendered tile index\n    cur_tile = int(uv.y * float(NUM_TILES))\n             + int(uv.x * float(NUM_TILES)) * NUM_TILES;\n\n    // disable tile rendering in background of big display\n    bool doTiles = true;\n    if (selectionMorph() > 0.99)\n    {\n        float uvw = .5*(iResolution.x - iResolution.y) / iResolution.y;\n        if (uv.x > uvw && uv.x < 1.+uvw)\n            doTiles = false;   \n    }\n    \n    if (doTiles)\n        renderTiles(fragColor, fragCoord);\n    \n    // reset dot\n    if (uv.x < 0.05 && uv.y < 0.05)\n    {\n        uv /= .05;\n        float cros = 1.-3.*min(abs(uv.x-uv.y), abs(1.-uv.x-uv.y));\n        fragColor += cros * (vec4(1., 0., 0., 1.) - fragColor);\n    }\n    else if (uv.x < 0.1 && uv.y < 0.05)\n    {\n        uv.x -= .05;\n        uv /= .05;\n        float cros = 1.-3.*min(abs(uv.x-uv.y), abs(1.-uv.x-uv.y));\n        fragColor += cros * (vec4(0., 1., 0., 1.) - fragColor);\n    }\n\n    cur_tile = selectedTile();\n    if (cur_tile >= 0 && selectionMorph() > 0.01)\n    \trenderBig(fragColor, fragCoord);\n\n    //fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Interactive Evolutionary Framework - https://www.shadertoy.com/view/XdyGWw\n   (c) 0x7e Stefan Berke\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   This buffer renders a set of parameters \n   and applies mutation on mouse-click\n\n   (first two columns of output are used for various flags)\n*/\n\nconst int NUM_PARAM_ROWS = 1;\t\t// Number of rows of parameters for one 'tile'\nconst int NUM_TILES = 4;\t\t\t// Number of 'tiles' per screen height\nconst int NUM_TILES_ALL = 100;\t\t// for cross-breeding, set this to the maximum\n\t\t\t\t\t\t\t\t\t// number of tiles on screen\n\nconst float MUTATION_PROB = 0.3;\t// Probability of mutating one parameter\nconst float MUTATION_AMT = 0.4; \t// Maximum amount of mutation +/-\nconst float AV_NUM_PARAMS = 20.;\t// Number of parameters for a cross-breed section\n\t\t\t\t\t\t\t\t\t// This is kind of the length of a consecutive section\n\t\t\t\t\t\t\t\t\t// in the gene..\n\n// scales mutation amount by distance to clicked tile\n#define DO_SCALE\n// define for only positive values \n#define ABSOLUTE\n//#define RANGE_MIN -1.\n//#define RANGE_MAX  1.\n\n\n\n// hashes by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n// uniform random vec4 [-1,1]\n// (this is not state-of-the-art hashing)\nvec4 rndVec(in vec2 seed)\n{\n    return vec4(hash(seed), hash(seed+.1283), hash(seed+.7229), hash(seed+.32941)) * 2. - 1.;\n}\n\nvec4 clampVec(in vec4 v)\n{\n#ifdef ABSOLUTE\n    v = abs(v);\n#endif\n#ifdef RANGE_MIN\n    v = max(vec4(RANGE_MIN), v);\n#endif\n#ifdef RANGE_MAX\n    v = min(vec4(RANGE_MAX), v);\n#endif\n  \treturn v;\n}\n\n\n// returns the parameters for the given 'tile' \nvec4 parameter(in int column, in int row, in int cur_tile) \n{ \n    vec2 uv = (vec2(column+2, row + cur_tile*NUM_PARAM_ROWS)+.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);    \n}\n\n\n// sets random parameters\nvoid reset(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 1.) // keep ui-states\n    {\n        // clear flags\n        if (fragCoord.x < 2.)\n            fragColor = vec4(0.);\n        // init randomly\n        else\n        {\n            vec2 seed = fragCoord/1.1 + sin(iDate.zw + float(iFrame)*.1); \n            fragColor = clampVec( rndVec(seed) );    \n        }\n    }\n}\n\nvec4 mutate(in int sel_tile, in vec2 fragCoord)\n{\n    // init random mutation \n    vec2 seed = fragCoord + sin(iDate.zw);\n    vec4 mutate = vec4(0.);\n\n    #ifdef DO_SCALE\n    // scale mutation amount by tile distance\n    float amt = clamp( abs(float(sel_tile) - fragCoord.y / float(NUM_PARAM_ROWS))\n                      / float(NUM_TILES * NUM_TILES), 0.1, 1.);\n    #else\n    float amt = 1.;\n    #endif\n    // mutate with probability\n    if (hash(seed*0.12345) < MUTATION_PROB * max(.5, amt))\n        mutate = MUTATION_AMT * amt * rndVec(seed);\n\n    // copy weights from 'sel_tile' slot to all others + mutation\n    return clampVec( parameter(int(fragCoord.x-2.), \n                                   int(mod(fragCoord.y, float(NUM_PARAM_ROWS))), \n                                   sel_tile)\n                     + mutate);\n}\n\nvec4 crossBreed(in int tile1, in int tile2, in vec2 fragCoord)\n{\n    ivec2 parVec = ivec2(int(fragCoord.x-2.), \n                         int(mod(fragCoord.y, float(NUM_PARAM_ROWS))));\n  \tvec4 p1 = parameter(parVec.x, parVec.y, tile1);\n    vec4 p2 = parameter(parVec.x, parVec.y, tile2);\n    \n    vec2 seed = vec2(fragCoord.y) + sin(iDate.zw);\n    float freq = 3.14159265 / float(AV_NUM_PARAMS);\n    float mx = (.5 + .5 * sin(fragCoord.x*freq + 6.*hash(seed)));\n    mx = pow(mx, 1. + 5. * hash(seed.yx*.87));\n    mx *= hash(seed*1.31);\n    // swap dominant set\n    if (hash(seed+mx) > .5)\n    \tmx = 1.-mx;\n    return p1 + mx * (p2 - p1);\n}\n    \n\n// --- ui state ---\n\n// is the given 'tile' excluded from mutation?\nbool isTileLocked(in int cur_tile) \n{\n    vec2 uv = (vec2(1, cur_tile * NUM_PARAM_ROWS) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x >= .5;\n}\n\nint selectedTile()\n{\n    vec2 uv = (vec2(0., 0.) + .5) / iChannelResolution[0].xy;\n\treturn int(texture(iChannel0, uv).x)-1;\n}\n\nfloat selectionMorph()\n{\n    vec2 uv = (vec2(0., 2.) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x;\n}\n\nbool prevMouseDown()\n{\n    vec2 uv = (vec2(0., 3.) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x > .5;\n} \n\n// chooses two random, non-equal, locked tiles\n// if none is locked, chooses two random tiles\nvoid selectParents(out int tile1, out int tile2, in vec2 fragCoord)\n{\n    // count number of locked tiles\n    int count = 0;\n    for (int i=0; i<NUM_TILES_ALL; ++i)\n    {\n        bool isLocked = isTileLocked(i);\n        if (isLocked)\n            ++count;\n    }\n\n    vec2 seed = sin(iDate.wz + float(iFrame)*.123 + fragCoord.y);\n\n    if (count < 1)\n    {\n        tile1 = int(hash(seed) * iResolution.y / float(NUM_PARAM_ROWS));\n        tile2 = int(hash(1.-seed*1.11341) * iResolution.y / float(NUM_PARAM_ROWS));\n        return;\n    }\n    \n    // choose index of locked tiles\n    int tilei1, tilei2;\n    if (count == 2)\n    {\n\t\ttilei1 = 0;\n        tilei2 = 1;\n    }\n    else\n    {\n        tilei1 = int(hash(seed) * float(count));\n        tilei2 = int(hash(seed*1.1311+3.) * float(count));\n    }\n    \n    tile1 = tile2 = -1;\n    \n    // select locked tiles\n\tcount = 0;\n    for (int i=0; i<NUM_TILES_ALL; ++i)\n\tif (isTileLocked(i))\n    {\n        if (count == tilei1 && tile1 < 0)\n            tile1 = i;\n    \tif (count++ == tilei2 && tile2 < 0)// || tile2 == tile1)\n        \ttile2 = i;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 pixpos = ivec2(fragCoord);\n    \n    // by default, copy previous pixel\n    vec4 pix = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy);\n    fragColor = pix;\n    \n    // currently rendered 'tile' parameters\n    int cur_tile = int(fragCoord.y) / NUM_PARAM_ROWS;\n\n\t// catch single mouse-down event\n\tbool mouseDown = false;\n    bool prevDown = prevMouseDown();\n    if (iMouse.z > .5 && !prevDown)\n    {\n        mouseDown = true;\n        if (pixpos.x == 0 && pixpos.y == 3)\n            fragColor.x = 1.;\n    }\n    else if (iMouse.z < .5 && prevDown)\n    {\n        if (pixpos.x == 0 && pixpos.y == 3)\n            fragColor.x = 0.;\n    }\n\n    // init parameters\n    if (iFrame < 2)\n    {\n\t\treset(fragColor, fragCoord);\n    }\n\telse\n        \n    // on click\n    if (mouseDown && selectedTile() < 0)\n    {\n        vec2 muv = iMouse.xy / iResolution.y;\n        \n        // clicked on reset-square?\n        if (muv.x < 0.05 && muv.y < 0.05)\n        {\n            if (!isTileLocked(cur_tile))\n            \treset(fragColor, fragCoord);\n        }\n        // clicked on sex-party square?\n        else if (muv.x < 0.1 && muv.y < 0.05)\n        {\n            if (!isTileLocked(cur_tile) && fragCoord.x >= 2.)\n            {\n                int tile1, tile2;\n                selectParents(tile1, tile2, fragCoord);\n                fragColor = crossBreed(tile1, tile2, fragCoord);\n            }\n        }\n        // per tile\n        else\n        {\n            // find 'tile' that was clicked\n            float width = iResolution.y / float(NUM_TILES);\n            int sel_tile = int(iMouse.y / width)\n                         + int(iMouse.x / width) * NUM_TILES;\n            // are we rendering the parameters for the clicked tile?\n            bool is_this_tile = cur_tile == sel_tile;\n            \n            vec2 clickuv = vec2(mod(iMouse.x, width) / width, \n                                mod(iMouse.y, width) / width);\n            \n            // clicked on top bar?\n            if (clickuv.y > .85)\n            {\n                // lock\n                if (clickuv.x < .15)\n                {                \n                    if (pixpos.x == 1 && is_this_tile)\n                    {\n                        pix.x = 1. - pix.x;\n\t                    fragColor = pix; \n                    }\n                }\n                // show\n                else if (clickuv.x < .3)\n                {\n                    if (pixpos.x == 0 && pixpos.y <= 1)\n        \t\t\t\tfragColor = vec4(float(sel_tile+1));\n                }\n            }\n            \n            // mutate\n            else\n            {\n                // don't mutate flags, locked sets or clicked tile\n                if (fragCoord.x < 2. || is_this_tile \n                    || isTileLocked(cur_tile))\n                {\n                    /* fragColor = pix; */\n                }\n                else\n                {\n                    fragColor = mutate(sel_tile, fragCoord);\n                    //fragColor = crossBreed(sel_tile, 4, fragCoord);\n                }\n            }\n        }\n    }\n    else\n        \n    // end selection click\n    if (mouseDown && selectedTile() >= 0)\n    {\n        if (pixpos.x == 0 && pixpos.y == 0)\n        {\n            fragColor = vec4(0.);\n        }\n    }\n    \n    // ui-flags\n    else if (pixpos.x == 0)\n    {\n        // selection fade-in\n        if (pixpos.y == 2)\n        {\n            float on = selectedTile() >= 0 ? 1. : 0.;\n            fragColor.x += min(1., 7.*iTimeDelta) * (on - fragColor.x);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}