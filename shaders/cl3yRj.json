{
    "Shader": {
        "info": {
            "date": "1699389088",
            "description": "That floor-LATTICED Gilbert tessellation, where a straight main road is either horizontal or vertical, and randomly shifted, and that then bleeds straight into neighbor tiles, BUT on a hex lattice (instead of rectangle-lattice)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "cl3yRj",
            "likes": 3,
            "name": "Hexagonal ┣┳┻┫ ꓕTiles Beta",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "road",
                "tile",
                "tesselation",
                "gilbert"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "//A proper noun for this may be \"Gilbert tessellation\", to look up in math texts.\n\n//On shadertoy, for speed, we tend to do floor()-lattices before doing a Voronoi.\n//same seems to be true for gilbert tesselation, for speed on smaller neighborhoods.\n\n// parent shader \"Hexagonal Grid Traversal - 2D\" \n// was Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//removed the traversal and the AA, but really needed everything else.\n//especially hexagonGetID() and id2center()\n\n\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/NlKfWt\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/7ldfzS\n//honorable aunt                    wiggles around: https://www.shadertoy.com/view/DsGBDK\n//honorable uncle    working in industrial storage: https://www.shadertoy.com/view/dtccWn\n//in memory to         something similar was tried: https://www.shadertoy.com/view/clfSDj\n\n#define timeOscillator cos(iTime*.6)*.5+.5\n#define rmax r=max(r,1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h))))\n\n// return the hexagon that p belongs to\nivec2 uv2id(vec2 p\n){vec2  q=vec2( p.x, p.x*.5+p.y*0.8660254037)\n ;ivec2 i = ivec2(floor(q))\n ;vec2  f =       fract(q)\n ;int v = mod3(i.x+i.y)\n ;ivec2 id = i + v\n ;if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1)\n ;return ivec2( id.x, (2*id.y-id.x)/3 );}\n\n// return the center of an hexagon\nvec2 id2center(ivec2 id\n){return vec2(float(id.x),float(id.y)*1.732050807);}\n\n//=============================================================\n\nfloat h21(ivec2 i\n){return sin(float(15*i.x)+cos(float(33*i.y)))*.5//*2.+.3\n ;}\n\nvec3 road0(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h)))\n ;if(u.y-center.y<h\n ){\n  ;//hal=.1//below red main road\n  ;//add green road\n\n ;}else{\n  ;//hal=0.//above red main road\n  ;float h=h21(i+ivec2(-1,1))//height of top adjacent blue\n  ;mat2 m=rotby(acos(.5));u*=m;center*=m\n  ;rmax\n  ;if(u.y-center.y<h\n  ){\n  ;}else{\n   ;float h=h21(i+ivec2(1,1))//height of top adjacent green\n   ;mat2 m=rotby(acos(.5));u*=m;center*=m\n   ;rmax\n   ;\n  ;}\n ;}\n ;return vec3(r,0,r)\n ;}\n \n\nvec3 road1(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(-.5));u*=m;center*=m\n ;float r=1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h)))\n  ;if(u.y-center.y<h\n  ){\n  ;}else{\n   ;float h=-h21(i+ivec2(2,0))//height of right adjacent red\n   //-h21 is negated cause a clockwise meets a counterclockwise!!\n   ;mat2 m=rotby(acos(.5));u*=m;center*=m\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n   ;}else{\n    ;float h=-h21(i+ivec2(1,-1))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}\n  ;}\n ;return vec3(r,r,0)\n ;}\n\n\nvec3 road2(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(.5))\n ;float r=0.\n ;u*=m\n ;center*=m\n ;rmax\n ;if(u.y-center.y<h\n  ){  \n   ;float h=h21(i+ivec2(-1,-1))//height of right adjacent re\n   ;mat2 m=rotby(acos(.5));u*=m;center*=m\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21(i+ivec2(-2,0))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}else{\n   ;}\n  ;}else{\n  ;}\n ;return vec3(0,r,r)\n ;}\n\n\nvec3 roads(vec2 u,ivec2 i,int t//uvScreen,hexID,hexType\n){const float kPtRa = 0.3;\n ;vec2 center=id2center(i);\n ;//vec2 r=1.-smoothstep(-v*0.5,v*0.5,vec2(sdDisk(u,center,kPtRa)))\n ;vec3 r;\n ;float h=h21(i)\n ;     if(t==0)r=road0(u,center,kPtRa,h,i)\n ;else if(t==1)r=road1(u,center,kPtRa,h,i)\n ;else         r=road2(u,center,kPtRa,h,i)\n ;r=mix(vec3(max(max(r.x,r.y),r.z)),r,timeOscillator)//mix road color\n ;return r\n ;}\n\nvec3 render(vec2 u,vec2 v\n){ ;// scale image\n ;u*= 9.// scale image\n ;v*= 9.// scale image\n ;ivec2 i=uv2id(u)\n ;int t=(mod3(i.x))\n ;float backgroundBrightness=.5\n ;vec3 col=mix(vec3(0),vec3(t)/2.*backgroundBrightness,timeOscillator)//mix background tiles showing\n ;col+=roads(u,i,t)\n //vec3  col=vec3(fract(float(i)/3.))\n ;// draw ray\n ;// prepare for hex-traverse\n ;return col;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 c=render((u-iResolution.xy)/iResolution.y,1./iResolution.xy)\n ;o=vec4(c,1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdDisk( vec2 p, vec2 a, float r ){\n\treturn length(p-a)-r;}\n\n//return matrix that rotates by t\nmat2 rotby(float t\n){float ct=cos(t),st=sin(t)\n ;return mat2(ct,-st, st, ct);}\n\n//rotate 60deg clockwise\n#define r60 (mat2(-1,sqrt(3.),-1,-sqrt(3.))*.5)\n\nint   mod3(int   n){return (n<0) ? 2-((2-n)%3) : n%3;}\n//ivec2 mod3(ivec2 n){return ivec2(mod3(n.x),mod3(n.y));}//not needed\n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}