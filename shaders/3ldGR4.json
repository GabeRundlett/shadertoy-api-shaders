{
    "Shader": {
        "info": {
            "date": "1575769528",
            "description": "Next time I'll deal with boxes and multiple subtractions from the same sphere, which will let me abstract this a bit more.\nCredit: lots from Reinder and WillP's implementation of Shirley's Ray Tracing in One Weekend + Nimitz hash functions.",
            "flags": 32,
            "hasliked": 0,
            "id": "3ldGR4",
            "likes": 2,
            "name": "Constructive Spheres 1",
            "published": 3,
            "tags": [
                "raytracing",
                "geometry",
                "constructive",
                "shirley"
            ],
            "usePreview": 0,
            "username": "aethelwhat",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // hold mouse button + move to move around scene\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Using lots of things from Reinder and WillP's \n * implementations of Shirley's Ray Tracing in \n * One Weekend + Nimitz hash functions.\n */\n\nconst float pi = 3.14159265358979;\n\nstruct Ray {\n    vec3 o;     // origin\n    vec3 d;     // direction - always set with normalized vector\n};\n\nRay createRay(vec3 o, vec3 d)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    return r;\n}\n\nvec3 pointOnRay(Ray r, float t)\n{\n    return r.o + r.d * t;\n}\n\nfloat gSeed = 0.0;\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed)\n{\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat rand(vec2 v)\n{\n    return fract(sin(dot(v.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 toLinear(vec3 c)\n{\n    return pow(c, vec3(2.2));\n}\n\nvec3 toGamma(vec3 c)\n{\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec2 randomInUnitDisk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.0, 6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 randomInUnitSphere(inout float seed)\n{\n    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1.0, 0.0, 0.0);\n    float phi = h.y;\n    float r = pow(h.z, 1.0/3.0);\n\treturn r * vec3(sqrt(1.0 - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n\nstruct Camera\n{\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lensRadius;\n};\n\nCamera createCamera(\n    vec3 lookFrom,\n    vec3 lookAt,\n    vec3 worldUp,\n    float fovy,\n    float aspect)\n{\n    float theta = fovy * pi / 180.0;\n    float halfHeight = tan(theta * 0.5);\n    float halfWidth = aspect * halfHeight;\n\n    Camera cam;\n    cam.origin = lookFrom;\n    cam.w = normalize(lookFrom - lookAt);\n    cam.u = normalize(cross(worldUp, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.lowerLeftCorner = cam.origin - halfWidth * cam.u - halfHeight * cam.v - cam.w;\n    cam.horizontal = 2.0 * halfWidth * cam.u;\n    cam.vertical = 2.0 * halfHeight * cam.v;\n    return cam;\n}\n\nRay getRay(Camera cam, vec2 uv)\n{\n    return createRay(\n        cam.origin,\n        normalize(cam.lowerLeftCorner + uv.x * cam.horizontal + uv.y * cam.vertical - cam.origin));\n}\n\n// MT_ material type\n#define MT_DIFFUSE 0\n#define MT_METAL 1\n#define MT_DIALECTRIC 2\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float roughness; // controls roughness for metals\n    float refIdx; // index of refraction for dialectric\n};\n\nMaterial createDiffuseMaterial(vec3 albedo)\n{\n    Material m;\n    m.type = MT_DIFFUSE;\n    m.albedo = albedo;\n    return m;\n}\n\nMaterial createMetalMaterial(vec3 albedo, float roughness)\n{\n    Material m;\n    m.type = MT_METAL;\n    m.albedo = albedo;\n    m.roughness = roughness;\n    return m;\n}\n\nMaterial createDialectricMaterial(vec3 albedo, float refIdx)\n{\n    Material m;\n    m.type = MT_DIALECTRIC;\n    m.albedo = albedo;\n    m.refIdx = refIdx;\n    return m;\n}\n\nstruct HitRecord\n{\n    vec3 pos;\n    vec3 normal;\n    float t;            // ray parameter\n    float t2;\t\t\t// second hit\n    Material material;\n};\n\nbool customRefract(vec3 v, vec3 n, float niOverNt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);\n    if(discriminant > 0.0)\n    {\n        refracted = niOverNt * (uv - n * dt) - n * sqrt(discriminant);\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float refIdx)\n{\n    float r0 = (1.0 - refIdx) / (1.0 + refIdx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\nbool scatter(Ray rIn, HitRecord rec, out vec3 atten, out Ray rScattered)\n{\n    if(rec.material.type == MT_DIFFUSE)\n    {\n        vec3 target = rec.pos + rec.normal + randomInUnitSphere(gSeed);\n        rScattered = createRay(rec.pos, normalize(target - rec.pos));\n        atten = rec.material.albedo;\n        return true;\n    }\n    if(rec.material.type == MT_METAL)\n    {\n        vec3 refl = reflect(rIn.d, rec.normal);\n        rScattered = createRay(rec.pos, normalize(refl + rec.material.roughness * randomInUnitSphere(gSeed)));\n        atten = rec.material.albedo;\n        return true;\n    }\n    if(rec.material.type == MT_DIALECTRIC)\n    {\n        atten = vec3(1.0);\n        vec3 outwardNormal;\n        float niOverNt;\n        float cosine;\n\n        if(dot(rIn.d, rec.normal) > 0.0)\n        {\n            outwardNormal = -rec.normal;\n            niOverNt = rec.material.refIdx;\n            cosine = rec.material.refIdx * dot(rIn.d, rec.normal) / length(rIn.d); // last divide not required (already normalized)\n        }\n        else\n        {\n            outwardNormal = rec.normal;\n            niOverNt = 1.0 / rec.material.refIdx;\n            cosine = -dot(rIn.d, rec.normal) / length(rIn.d); // same as above\n        }\n\n        vec3 refracted;\n        float reflectProb;\n        if(customRefract(rIn.d, outwardNormal, niOverNt, refracted))\n        {\n            reflectProb = schlick(cosine, rec.material.refIdx);\n        }\n        else\n        {\n            reflectProb = 1.0;\n        }\n\n        if(hash1(gSeed) < reflectProb)\n        {\n            vec3 reflected = reflect(rIn.d, rec.normal);\n            rScattered = createRay(rec.pos, normalize(reflected));\n        }\n        else\n        {\n            rScattered = createRay(rec.pos, normalize(refracted));\n        }\n\n        return true;\n    }\n    return false;\n}\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nSphere createSphere(vec3 center, float radius)\n{\n    Sphere s;\n    s.center = center;\n    s.radius = radius;\n    return s;\n}\n\nbool hit_sphere(Sphere s, Ray r, float tmin, float tmax, inout HitRecord rec)\n{\n    vec3 oc = r.o - s.center;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float discriminant = b * b - a * c;\n    if(discriminant > 0.0)\n    {\n        float sqrtDiscriminant = sqrt(discriminant);\n        float t1 = (-b - sqrtDiscriminant) / a;        \n        float t2 = (-b + sqrtDiscriminant) / a;     \n        \n        float first = min(t1,t2);\n        float second = max(t1,t2);   \n        \n        if(first < tmax && first > tmin)\n        {\n            rec.t = first;\n            rec.t2 = second;\n            rec.pos = pointOnRay(r, rec.t);\n            rec.normal = (rec.pos - s.center) / s.radius;\n            return true;\n        }\n        \n        if(second < tmax && second > tmin)\n        {\n            rec.t = second;\n            rec.t2 = first;\n            rec.pos = pointOnRay(r, rec.t);\n            rec.normal = (rec.pos - s.center) / s.radius;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool subtract_Sphere(in Sphere cut, in Ray r, float tmin, in HitRecord recSolid, inout HitRecord rec, in Material inside){  \n \tbool hit = true;\n    HitRecord recCut;    \n    if(hit_sphere( cut, r, tmin, 1000.0, recCut)) //cut could be behind tmax\n    {   \n        hit = false;        \n        // Hit the inside, starting from inside both spheres\n        if(recCut.t2 < tmin && recSolid.t2 < tmin && recSolid.t > recCut.t){\n        \trec.pos = pointOnRay(r, recCut.t);\n            rec.normal = (cut.center - rec.pos) / cut.radius;\n            rec.t = recCut.t;\n            rec.material = inside;\n            return true;\n        }\n        // Hit the inside, starting from inside the cut but outside the solid\n        if(recCut.t2 < tmin && recSolid.t > tmin && recCut.t > recSolid.t && recCut.t < recSolid.t2){\n        \trec.pos = pointOnRay(r, recCut.t);\n            rec.normal = (cut.center - rec.pos) / cut.radius;\n            rec.t = recCut.t;\n            rec.material = inside;\n            return true;\n        }\n        // no hit, starting from inside the cut but outside the solid\n        if(recCut.t2 < recSolid.t && recCut.t > recSolid.t && recCut.t2 < tmin){\n            return false;\n        }\n        // Hit the inside\n        if(recCut.t2 > recSolid.t && recCut.t2 < recSolid.t2 && recCut.t < recSolid.t){\n        \trec.pos = pointOnRay(r, recCut.t2);\n            rec.normal = (cut.center - rec.pos) / cut.radius;\n            rec.t = recCut.t2;\n            rec.material = inside;\n            return true;\n        }\n        // Hit the outside\n        if ( recCut.t > recSolid.t || recCut.t2 < recSolid.t) { // both intersections were before the hit point\n            hit = true;\n        }\n    }\n    if(hit){\n        rec = recSolid;\n    }\n    return hit;  \n}\n\n\n// abstracting this out more and adding box \n// intersections or multiple intersection\n// in my next Shader.\nbool hit_Bowl(Ray r, float tmin, float tmax, inout HitRecord rec){\n    HitRecord recSolid;\n    bool hit = false;\n    Sphere solid = createSphere(vec3(-4.7, 1.7, 0.0), 1.6);\n    Material outside = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.06);\n\tHitRecord recCut;  \n    Sphere cut = createSphere(vec3(-3.3, 1.4, 0.0), 1.4);\n    Material inside = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.05);\n    if(hit_sphere( solid, r, tmin, rec.t, recSolid))\n    {\n        recSolid.material = outside;\n        if(subtract_Sphere(cut, r, tmin, recSolid, rec, inside)){\n            hit = true;\n        }\n    }\n    return hit;\n}\n\nbool hit_Bowl2(Ray r, float tmin, float tmax, inout HitRecord rec){\n    HitRecord recSolid;\n    bool hit = false;\n    Sphere solid = createSphere(vec3(3.5, 1.7, 0.0), 1.6);\n    Material outside = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.02);\n\tHitRecord recCut;  \n    Sphere cut = createSphere(vec3(1., 2.0, 0.0), 3.6);\n    Material inside = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.01);\n    if(hit_sphere( solid, r, tmin, rec.t, recSolid))\n    {\n        recSolid.material = outside;\n        if(subtract_Sphere(cut, r, tmin, recSolid, rec, inside)){\n            hit = true;\n        }\n    }\n    return hit;\n}\n\nbool hit_world(Ray r, float tmin, float tmax, inout HitRecord rec)\n{\n    bool hit = false;\n    rec.t = tmax;\n\n    if(hit_Bowl(r, tmin, rec.t, rec)){\n       hit = true; \n    }\n    \n    if(hit_Bowl2(r, tmin, rec.t, rec)){\n       hit = true; \n    }\n    \n    // Ground\n    \n    if(hit_sphere( \n        createSphere(vec3(0.0, -1002.0, -1.0), 1000.03),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createMetalMaterial(vec3(0.6, 0.8, 0.2), 0.03);\n        //rec.material = createDiffuseMaterial(vec3(0.5,0.7,0.1));      \n    }\n\n    // Glass\n    \n    if(hit_sphere(\n        createSphere(vec3(0.0, 1.8, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material.type = MT_DIALECTRIC;\n        rec.material = createDialectricMaterial(vec3(0.8, 0.8, 0.8), 1.5);\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(0.0, 1.8, 0.0), -0.95),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material.type = MT_DIALECTRIC;\n        rec.material = createDialectricMaterial(vec3(0.8, 0.8, 0.8), 1.5);\n    }\n\n    int numxy = 4;\n    float radius = 5.0;\n    for(int x = -numxy; x < numxy; ++x)\n    {\n        for(int y = -numxy; y < numxy; ++y)\n        {\n            float fx = float(x);\n            float fy = float(y);\n            float seed = fx + fy / 1000.0;\n            float rand1 = hash1(seed);\n            float size = hash1(seed) * 0.2 + 0.15;\n            vec3 disk = randomInUnitSphere(rand1) * radius;\n            vec3 center = vec3(disk.x,disk.y,disk.z);\n            float chooseMaterial = rand1;\n            if(distance(center, vec3(4.0, 1.8, 0.0)) > 1.4)\n            {\n\t\t\t\tif(chooseMaterial < 0.6)\n                {\n                    // diffuse\n                    if(hit_sphere(\n                        createSphere(center, size),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material = createDiffuseMaterial(hash3(seed) * hash3(seed));\n                    }\n                }\n                else if(chooseMaterial < 0.9)\n                {\n                    // metal\n                    if(hit_sphere(\n                        createSphere(center, size),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material.type = MT_METAL;\n                        rec.material = createMetalMaterial((hash3(seed) + 1.0) * 0.5, hash1(seed));\n                    }\n                }\n                else\n                {\n                    // glass (dialectric)\n                    if(hit_sphere(\n                        createSphere(center, size),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material.type = MT_DIALECTRIC;\n                        rec.material = createDialectricMaterial(vec3(0.0), 1.5);\n                    }\n                }\n            }\n        }\n    }\n\n    return hit;\n}\n\n#define MAX_BOUNCES 20\n\nvec3 color(Ray r)\n{\n    HitRecord rec;\n    HitRecord prev;\n    vec3 col = vec3(1.0);\n    for(int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        prev = rec;\n        if(hit_world(r, 0.001, 10000.0, rec))\n        {\n            Ray scatterRay;\n            vec3 atten;\n            if(scatter(r, rec, atten, scatterRay))\n            {\n                if(prev.material == rec.material){\n                    // storing previous material for easing the color \n        \t\t\t// of multiple bounces inside of a metal dish\n                \tatten = vec3(1.0);   \n                }\n                col *= atten;\n                r = scatterRay;\n            }\n            else\n            {\n                return vec3(0.0);\n            }\n        }\n        else\n        {\n            float t = 0.5 * (r.d.y + 1.0);\n            col *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);\n            return col;\n        }\n    }\n    return col;\n}\n\nvec3 debugNormals(Ray r)\n{\n    HitRecord rec;\n    vec3 col = vec3(1.0);\n    for(int i = 0; i < 1; ++i)\n    {\n        if(hit_world(r, 0.001, 10000.0, rec))\n        {\n\t\t\tcol = (rec.normal + 1.0) / 2.0;\n        }\n        else\n        {\n            float t = 0.5 * (r.d.y + 1.0);\n            col *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);\n            return col;\n        }\n    }\n    return col;\n}\n\n#define MAX_SAMPLES 5000.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    gSeed = float(baseHash(floatBitsToUint(gl_FragCoord.xy))) / float(0xffffffffU) + iTime;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x = mouse.x * 2.0 - 1.0;\n\tmouse.x += .5; // for thumbnail default camera position\n    float zoom = 5.0 * mouse.y + 7.0;\n    vec3 camPos = vec3(cos(mouse.x * pi) * zoom, mouse.y + 2.0, sin(mouse.x * pi) * zoom);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    float fovy = 60.0;\n    Camera cam = createCamera(\n        camPos,\n        camTarget,\n        vec3(0.0, 1.0, 0.0),\n        fovy,\n        iResolution.x / iResolution.y);\n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 prev = texture(iChannel0, uv);\n    vec3 prevLinear = toLinear(prev.xyz);\n    prevLinear *= prev.w;\n\n    uv = (gl_FragCoord.xy + hash2(gSeed)) / iResolution.xy;\n    vec3 col = color(getRay(cam, uv));\n    //vec3 col = debugNormals(getRay(cam,uv));\n\n    vec4 mousedata = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(mousedata.x - mousedata.z != 0.0 || mousedata.y - mousedata.w != 0.0)\n    {\n        col = toGamma(col);\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    if(prev.w > MAX_SAMPLES)\n    {\n        fragColor = prev;\n        return;\n    }\n\n    col = (col + prevLinear);\n    float w = prev.w + 1.0;\n    col /= w;\n    col = toGamma(col);\n    fragColor = vec4(col, w);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(iMouse.xy, prev.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}