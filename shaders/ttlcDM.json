{
    "Shader": {
        "info": {
            "date": "1592255569",
            "description": "testing smooth min",
            "flags": 0,
            "hasliked": 0,
            "id": "ttlcDM",
            "likes": 2,
            "name": "blending smooth spheres",
            "published": 3,
            "tags": [
                "spheres",
                "smoothmin"
            ],
            "usePreview": 0,
            "username": "cabbibo",
            "viewed": 377
        },
        "renderpass": [
            {
                "code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n// power smooth min (k = 8);\n// polynomial smooth min (k = 0.1);\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h),a.y);\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    \n    vec2 res = vec2(10000.,-1.);\n    for( int i = 0; i< 8; i++){\n       res = opU(res, vec2(sdSphere( pos - vec3( -1.2 , float(i) * .15 -.5 , -.4) , .1  ),1.));\n        \n    }\n    \n    float blendTime = .5*abs(sin(iTime));\n    \n    for( int i = 0; i< 8; i++){\n       res = smin(res, vec2(sdSphere( pos - vec3( 0. , float(i) * .15 -.5 , -.4) , .1 ),1.),  blendTime);\n        \n    }\n    \n    \n    vec2 rightRes = vec2(10000.,-1.);\n    for( int i = 0; i< 8; i++){\n    \trightRes = opU(rightRes, vec2(sdSphere( pos - vec3( 1.2 , float(i) * .15 -.5 , -.4) , .1  ),1.));\n    }\n    \n    rightRes = smin( rightRes , rightRes , blendTime );\n\n    \n    res = opU( rightRes , res );\n    \n        \n\n \t//vec2 res = vec2( sdSphere( pos - vec3( .3 , .3 , -0.4 ) , 1.1 ) , 1. ); \n    //res = opU( res , vec2( sdBox( pos- vec3( -.8 , -.4 , 0.2 ), vec3( .4 , .3 , .2 )) , 2. ));\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n    // Balloon\n    if( res.y == 1. ){\n            \n    \tcolor = vec3( 1. , 0., 0.) * match + vec3( .3 , .1, .2 );\n        vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n    // Box\n    }else if(res.y == 2. ){\n        \n        color = norm;\n        \n    }\n        \n        \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}