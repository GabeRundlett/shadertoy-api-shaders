{
    "Shader": {
        "info": {
            "date": "1708028664",
            "description": "Illustration of approximating [url=https://en.wikipedia.org/wiki/Phong_reflection_model]Phong lighting[/url] (which is itself an empirical model), via pow-less computation.\nLeft - Phong, right - approximation.\nLMB to select power.",
            "flags": 0,
            "hasliked": 0,
            "id": "lXXGWl",
            "likes": 4,
            "name": "pow-less Phong",
            "published": 3,
            "tags": [
                "phong",
                "specular"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 109
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Illustration of approximating Phong lighting, as per\n// https://en.wikipedia.org/wiki/Phong_reflection_model#Computationally_more_efficient_alterations\n// using (1-(n/2^k)*(1-x))^(2^k), computed without pow(...),\n// to approximate x^n (for arbitrary positive n).\n// No claims are made about the effect on performance.\n\nint K=2; // Squaring iterations.\n\n// Approximation of max(x,0)^n, for -inf<x<=1.\n// Here x is dot(A,B) in Phong model.\n// Written this way for generality.\n// In practice, you might settle on a fixed k,\n// and possibly even n, and hardcode the expression.\n// NOTE: this is accurate to O((1-x)^2) around x=1.\n// You may instead choose to e.g. exactly match\n// function width at specific height y, in which case\n// the expression is\n//     (1-a*(1-x))^(2^k)\n// with a=(y^(2^-k)-1)/(y^(1/n)-1).\nfloat f(float x,float n,int k)\n{\n    float ret=max(mix(1.0,x,n/float(1<<k)),0.0);\n    for(int i=0;i<k;++i) ret=ret*ret;\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0.03125,0.125,0.03125);\n    float P=exp2(mix(1.0,9.0,0.5+0.5*sin(0.73*iTime))); // Power.\n    if(abs(iMouse.y)>10.0) P=exp2(mix(1.0,9.0,abs(iMouse.x)/iResolution.x));\n    vec3 l=normalize(vec3(cos(iTime),1,sin(iTime)));\n    vec3 ro=vec3(0,0,1.5);\n    vec3 rd=normalize(vec3(xy,-1.0));\n    float p=dot(ro,rd),q=dot(ro,ro)-1.0,d=p*p-q;\n    if(d>0.0)\n    {\n        float t=-p-sqrt(d);\n        vec3 r=ro+t*rd;\n        // Noise.\n        vec3 n=2.0*r;\n        n.xz=vec2(n.x*cos(0.37*iTime)-n.z*sin(0.37*iTime),n.x*sin(0.37*iTime)+n.z*cos(0.37*iTime));\n        for(int k=0;k<6;++k) n=sin(0.7*dot(n,n)+1.9*n.yzx);\n        n=normalize(r+0.5*n);\n        vec3 b=normalize(l-rd);\n        col=mix(\n            col,\n            vec3(0.03125)+0.5*max(dot(n,l),0.0)+2.5*(xy.x<0.0?\n                pow(max(dot(n,b),0.0),P):\n                f(dot(n,b),P,K)),\n            smoothstep(0.0,1.5*fwidth(d),d)); // AA.\n    }\n    if(true) // Plot.\n    {\n        float c=cos(xy.x);\n        float y=pow(max(c,0.0),P);\n        col+=vec3(0.2,0.7,0.2)*smoothstep(1.5*fwidth(2.0*y-xy.y-1.0),0.0,abs(2.0*y-xy.y-1.0));\n        y=f(c,P,K);\n        col+=vec3(0.5,0.5,0.5)*smoothstep(1.5*fwidth(2.0*y-xy.y-1.0),0.0,abs(2.0*y-xy.y-1.0));\n    }\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}