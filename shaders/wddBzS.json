{
    "Shader": {
        "info": {
            "date": "1606065014",
            "description": "...from the Hellraiser series.\nA few firsts for me - Bump mapping, blood(!), and a different camera system. Quite happy, but would like to have added electricity arcs. Alas I'm hitting Shadertoy's 'Max 5 second' compile time rule...\nEnjoy!",
            "flags": 0,
            "hasliked": 0,
            "id": "wddBzS",
            "likes": 26,
            "name": "Lemarchand's Box",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "horror",
                "movie",
                "cineshader",
                "pinhead"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 13490
        },
        "renderpass": [
            {
                "code": "// Lemarchand's Box\n//\n// ...from the Hellraiser series.\n// A few firsts for me - Bump mapping, blood(!), and a different camera system.\n// Quite happy, but would like to have added electricity arcs. Alas I'm hitting\n// Shadertoy's 'Max 5 second' compile time rule...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 50.\n#define MAX_STEPS\t\t72.\n#define SHADOW_STEPS\t 30.\n#define MAX_SHADOW_DIST  18.\n\nfloat lift, hatch, circRot, chain;\n\n#define AA  // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d;\n\tvec4 po;\n\tfloat spe; // 0: None, 30.0: Shiny\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n11(float n) {\n\tfloat flr = floor(n);\n\tn = fract(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.3456) * 43758.5453);\n\treturn mix(rndRange.x, rndRange.y, n * n * (3. - 2. * n));\n}\n\nfloat istep(float a, float b) { return 1. - step(a, b); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n\treturn mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.));\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rot(vec3 p, vec3 ax, float a) {\n\t// Thanks Blackle.\n\treturn mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max2(q.yz)), 0.);\n}\n\nfloat sdUBox(vec3 p) { return sdBox(p, vec3(1)); }\n\nfloat sdCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tconst vec3 r = vec3(0, 1, 0);\n\tvec3 forward = normalize(r - ro),\n\t\t right = normalize(cross(r, forward)),\n\t\t up = cross(forward, right);\n\treturn normalize(forward + right * uv.x + up * uv.y);\n}\n\nfloat sdFan(vec3 p) {\n\tfloat d = 1e7;\n\tmat2 m = rot(.785);\n\tfor (int i = 0; i < 4; i++)\n\t\td = min(d, sdBox(p, vec3(.2 * length(p.xz), 2, 2))), p.xz *= m;\n\n\treturn d;\n}\n\nfloat hole(vec3 p) {\n\treturn sdBox(rot(p, vec3(0, 1, 0), .78), vec3(.35, 10, .35));\n}\n\n// Outline square.\nfloat sq(vec2 p, float r1, float r2) {\n\tfloat mp = max2(p);\n\treturn step(r1, mp) - step(r2, mp);\n}\n\n// Outline circle.\nfloat circ(vec2 p, float r1, float r2) {\n\tfloat d = length(p);\n\treturn istep(r1, d) * step(r2, d);\n}\n\nvec3 tex(vec4 po) {\n\tif (po.w == 0.) // Ground.\n\t\treturn po.rgb;\n\n\tif (sdUBox(po.xyz) < 0.) // Inside cube (Wood)\n\t\treturn mix(vec3(.035, .02, .01), vec3(.025, .015, .01), n11(n31(po.xyz * vec3(3, 1, 3)) * 30.));\n\n\t// On cube surface.\n\tconst vec2 e = vec2(1, -1) * .00001;\n\tvec3 n = normalize(e.xyy * sdUBox(po.xyz + e.xyy) +\n\t\t\t \t\t   e.yyx * sdUBox(po.xyz + e.yyx) +\n\t\t\t\t\t   e.yxy * sdUBox(po.xyz + e.yxy) +\n\t\t\t\t\t   e.xxx * sdUBox(po.xyz + e.xxx));\n\n\tfloat c = 0., patt = step(.25, n31(po.xyz * 42.5) * 2.2 * n31(po.xyz * 10.6));\n\tvec2 p;\n\tif (abs(n.x) > .001) {\n\t\tp = abs(po.zy);\n\n\t\t// Decoration lines.\n\t\tc = istep(.015, abs(abs(po.z + .05 * sign(po.y)) - .04)) +\n\t\t\tistep(.015, abs(p.y - .04));\n\n\t\tp = abs(po.zy * rot(.785));\n\t\tc += istep(.015, abs(p.x - .04)) + istep(.015, abs(p.y - .04));\n\t\tfloat d = step(0., p.x - .02) * step(0., p.y - .02);\n\n\t\t// Decoration squares.\n\t\tp = abs(abs(po.zy) - 1.);\n\t\tc += sq(p, .5, .53) + sq(p, .56, .59);\n\t\tc *= d;\n\n\t\t// Circle outlines.\n\t\tp = abs(po.zy);\n\t\tfloat cc = length(abs(p - .45) - .45);\n\t\tc += istep(.3, cc) * step(.27, cc);\n\n\t\t// Inner outline.\n\t\tc *= istep(.8, max2(p));\n\t\tc += sq(p, .8, .83);\n\n\t\tc *= step(.27, cc); // Cut-outs.\n\n\t\tc += istep(.22, cc) + // Circles.\n\t\t\t step(.88, max2(p)); // Outer square.\n\t} else if (abs(n.z) > .001) {\n\t\t// Inner square.\n\t\tp = abs(po.xy * rot(.785));\n\t\tc = istep(.63, max2(p));\n\n\t\t// Corner circle segments.\n\t\tc += circ(abs(abs(po.xy) - .83), .55, .4);\n\n\t\t// Spiky circle.\n\t\tp = abs(po.xy);\n\t\tc *= step(.24, length(p)) *\n\t\t\t step(.42 * pow(abs(sin(1.57 + atan(po.y, po.x) * 4.)), 10.), length(p));\n\n\t\t// Outer square.\n\t\tc += step(.88, max2(p));\n\t} else {\n\t\t// Surface pattern.\n\t\tc += step(.3, ((n31(po.xyz * 47.5) + n31(po.xyz * 30.)) * n31(po.xyz * 7.5)) / 2.);\n\n\t\t// Outer square.\n\t\tc += step(.92, max2(abs(po.xz)));\n\n\t\t// Radial lines.\n\t\tc += circ(abs(po.xz), .62, .56);\n\t\tp = vec2(1) * rot(sin(atan(po.z, po.x) * 16. + 4.5));\n\t\tc *= step(.3, p.x - .1);\n\t\tc += istep(.3, abs(p.x - .1));\n\n\t\t// Cut-out circle.\n\t\tc *= step(.56, length(po.xz));\n\n\t\t// Circle (and pattern).\n\t\tp = po.xz * rot(circRot * 1.57);\n\t\tc += istep(.5, length(po.xz)) *\n\t\t\t 1. - (istep(.12 - hatch, mod(atan(p.x, p.y) + 1.57, 1.57)) * step(.01, mod(clamp(length(p) + .12, .32, .6), .04)));\n\n\t\tp = abs(po.xz);\n\t\tpatt = 1.;\n\t}\n\n\t// Outer square.\n\tc *= istep(.98, max2(p));\n\n\treturn mix(\n\t\tvec3(.018, .011, .005),\n\t\tmix(mix(vec3(.13, .09, .002), vec3(.3, .23, .006), n31(po.xyz * 58.6)), vec3(.19, .16, .08), n31(po.xyz * 50.)),\n\t\tmin(c, patt));\n}\n\nHit topBox(vec3 p) {\n\tp.y -= min(sin(lift * 3.141) * 6., 2.);\n\tp.xz *= rot(max(0., smoothstep(0., 3., ((lift - .1) * 6.)) * 3.141 / 4.));\n\n\tfloat b = sdUBox(p), // Whole box.\n\t\t  c = sdCylinder(p, .5, 1.); // Central circle.\n\n\tvec3 pp = p;\n\tpp.y -= .99;\n\tpp.xz = abs(pp.xz);\n\tpp -= vec3(.25, 0, .25);\n\tpp = rot(pp, normalize(vec3(-1, 0, 1)), hatch * 2.);\n\tfloat l = max(sdBox(pp, vec3(.26, .01, .26)), length(p.xz) - .5), // Lid.\n\t\t  ho = hole(p);\n\n\tHit h = Hit(0., vec4(p, 1), step(0., b) * 50.);\n\tp.xz *= rot(.2);\n\th.d = max(min(max(b, sdFan(p)), c), -ho);\n\th.d = min(h.d, l);\n\n\treturn h;\n}\n\nHit botBox(vec3 p) {\n\tfloat b = sdUBox(p), // Whole box.\n\t\t  c = sdCylinder(p, .45, .95), // Central circle.\n\t\t  ho = hole(p);\n\n\tHit h = Hit(0., vec4(p, 2), step(0., b) * 50.);\n\tp.xz *= rot(.2);\n\th.d = min(c, max(max(b, -sdFan(p)), .5 - length(p.xz)));\n\n\treturn h;\n}\n\nfloat flrPat(vec3 p) {\n\tp.x = mod(p.x, 1.) - .5;\n\tp.y += .06;\n\treturn length(p.xy) - .1 * abs(sin(p.z * 3.141));\n}\n\nHit flr(vec3 p) {\n\tp.y += 1.04;\n\n\tfloat splat = n31(p * 30.12);\n\tvec3 rgb = mix(mix(vec3(mix(.13, .17, n31(p * 8.28))), vec3(.11, .12, .13), splat), vec3(.125, .002, .002) * splat, splat * .3 + smoothstep(.6, .8, n31(p * .46)));\n\n\tp.xz *= rot(.3);\n\treturn Hit(min(p.y, min(flrPat(p), flrPat(p.zyx + vec3(0, 0, .5)))), vec4(rgb, 0), 10.);\n}\n\nfloat chn(vec3 p, float i) {\n\tp.xy *= rot(.3);\n\tp.y += i * 2. - chain;\n\tfloat oy = p.y;\n\tconst vec3 s = vec3(.075, .15, .015);\n\tvec3 s2 = vec3(s.xy, 1.015),\n\t\tp2 = p.zyx;\n\n\tp.y = mod(oy, .45) - .225;\n\tp2.y = mod(oy - .225, .45) - .225;\n\n\treturn max(min(max(sdBox(p, s), -sdBox(p, s2)), max(sdBox(p2, s), -sdBox(p2, s2))) - .02, oy);\n}\n\nHit chains(vec3 p) {\n\tconst vec2 u = vec2(1, -1);\n\treturn Hit(min(min(min(chn(p, 0.), chn(p * u.yxx, 1.)), chn(p.zyx, 2.)), chn(p.zyx * u.yxx, 3.)),\n\t\t\t   vec4(.04, .03, .03, 0),\n\t\t\t   50.);\n}\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\treturn minH(minH(minH(topBox(p), botBox(p)), flr(p)), chains(p));\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst float sceneAdjust = .25;\n\tconst float h = .0001 * sceneAdjust;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e*map(p+e*h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nconst vec3 sunPos = vec3(8, 3, -8);\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\n\tfloat sha = 1., t = .1;\n\tfor (float i = 0.; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(p + rd * t).d;\n\t\tsha = min(sha, 15. * h / t);\n\t\tt += h;\n\t\tif (sha < .001 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn clamp(sha, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, Hit h) {\n\tconst vec3 sunCol = vec3(2, 1.6, 1.4);\n\tvec3 sunDir = normalize(sunPos - p),\n\t\t n = calcNormal(p);\n\n\tfloat u = tex(h.po + vec2(.02, 0).xyyy).r,\n\t\t  r = tex(h.po + vec2(.02, 0).yxyy).r;\n\tvec3 c = tex(h.po);\n\tn = normalize(vec3(c.r - r, c.r - u, 0) * .2 + n);\n\tfloat ao = dot(vec2(ao(p, n, .5), ao(p, n, 2.)), vec2(.3, .5)),\n\n\t// Primary light.\n\tpri = max(0., dot(sunDir, n)),\n\n\t// Secondary(/bounce) light.\n\tbounce = max(0., dot(sunDir * vec2(-1, 0).xyx, n)) * .3,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(sunDir, n))), h.spe)) * h.spe / 10.,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\n\t// Fog\n\tfog = exp(-length(p) * .14);\n\n\t// Combine.\n\treturn mix(((pri * mix(.4, 1., calcShadow(p, sunPos)) + bounce) * ao + spe) * sunCol * c, vec3(.01), fre) * fog;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST * d || d > MAX_DIST)\n\t\t\tbreak;\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tif (d > MAX_DIST)\n\t\treturn vec3(0); // Distance limit reached - Stop.\n\n\t// Lighting.\n\treturn applyLighting(p, rd, h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tlift = hatch = circRot = chain = 0.;\n\n\t// Camera.\n\tfloat time = mod(iTime, 45.),\n\t\t  t = min(min(min(time, abs(time - 8.)), abs(time - 12.)), abs(time - 36.)),\n\t\t  dim = 1. - pow(abs(cos(clamp(t, -1., 1.) * 1.57)), 10.);\n\n\tvec3 cam;\n\n\tif (time < 8.) {\n\t\tcam = mix(vec3(.5, .5, 18.75), vec3(-.5, 0, 3.75), remap(time, 0., 8., 0., 1.));\n\t}\n\telse if (time < 12.) {\n\t\tcam = mix(vec3(0, 0, 5.6), vec3(-.5, .05, 5.6), remap(time, 8., 12., 0., 1.));\n\t}\n\telse if (time < 36.) {\n\t\tcam = mix(vec3(.12, .7, 3.67), vec3(.12, .7, 5), remap(time, 15., 30., 0., 1.));\n\t\tcircRot = smoothstep(0., 1., remap(time, 22., 24., 0., 1.)) - smoothstep(0., 1., remap(time, 13., 15., 0., 1.));\n\t\tlift = remap(time, 16., 21., 0., 1.) - remap(time, 25., 30., 0., 1.);\n\t\thatch = remap(time, 31., 34., 0., .98);\n\t} else {\n\t\thatch = 1.;\n\t\tchain = (time - 36.) * 4.;\n\t\tcam = mix(vec3(.02, .98, 5.78), vec3(.02, 1, 2.56), smoothstep(0., 1., remap(time, 36., 37., 0., 1.)));\n\t\tcam.z -= remap(time, 40., 41., 0., 1.2);\n\t\tdim = remap(time, 40.5, 41., 1., 0.);\n\t}\n\n\tvec3 ro = vec3(0, 0, -cam.z);\n\tro.yz *= rot(cam.y * -1.4);\n\tro.xz *= rot(cam.x * -3.141);\n\n\tvec3 col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n#ifdef AA\n\t\t}\n\t}\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.4545)), fragCoord), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}