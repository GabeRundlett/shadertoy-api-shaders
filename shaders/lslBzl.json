{
    "Shader": {
        "info": {
            "date": "1497640419",
            "description": "also some ellipsoid code, \nhttp://www.navipedia.net/index.php/Ellipsoidal_and_Cartesian_Coordinates_Conversion\nnot put to any use. i dot side tracked with it.",
            "flags": 0,
            "hasliked": 0,
            "id": "lslBzl",
            "likes": 4,
            "name": "circle refraction shenanigans",
            "published": 3,
            "tags": [
                "refraction",
                "intersection",
                "circle",
                "ellipsoid",
                "ellipse",
                "reflect",
                "tangent"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1075
        },
        "renderpass": [
            {
                "code": "#define camLens 4.\n#define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y \n\n/*\n//define an axis-aligned ellispoid by a vec3...\n//... that defines the halfWidths of its boundingBox.\n\n//P.xyz==carthesian location\n//E.xy ==latitude.longitude\n//E.  z==height\n//e2c(); Ellipsoid  vec3 E.xyz to Carthesian vec3 P.xyz conversion (closed form)\n//c2e(); Carthesian vec3 P.xyz to Ellipsoid  vec3 E.xyz conversion (iterative, no closed form)\n//c2e() is iterated over;\n#define iterEllipsoid 12\n//  http://www.navipedia.net/index.php/Ellipsoidal_and_Cartesian_Coordinates_Conversion\n\n\n//return xyz of ellipsoid [F] coordinates [E.xy]=latitude,longitude [E.z]=height\nvec3 e2c(vec3 E,vec3 F){\n float a=max(max(F.x,F.y),F.z);//semi major axis, longest diameter\n float b=min(min(F.x,F.y),F.z);//semi minor axis, shortest diameter\n //https://en.wikipedia.org/wiki/Semi-major_and_semi-minor_axes\n float f=1.-b/a;//flattening factor\n float e=2.*f-f*f;e*=e;//excentricity\n float s=sin(E.y);//sine of longitude\n float n=a/sqrt(1.-e*s*s);//radius of curvature\n return vec3((n+E.z)*cos(E.x)*cos(E.y),\n             (n+E.z)*cos(E.x)*sin(E.y),\n      ((1.-e)*n+E.z)*sin(E.x));\n}//relevant for long distance navigation,projectiles,satelites.\n//below inverse(), relevant for distance fields and uvw (ellipsoid normal) mapping.\n\n//return ellipsoid of carthesian [u] \"around\" ellispoid focal points [-a and a]\nvec3 c2e(vec3 P,vec3 F){\n vec3 E;//return value: [E.xy]=latitude,longitude [E.z]=height\n E.y=atan(P.y/P.x);\n float p=length(P.xy);\n float a=max(max(F.x,F.y),F.z);//semi major axis, longest diameter\n float b=min(min(F.x,F.y),F.z);//semi minor axis, shortest diameter\n float f=1.-b/a;//flattening factor\n float e=2.*f-f*f;e*=e;//excentricity\n E.x=atan(P.z/(1.-e)*p);\n float n;\n for(int i=0;i<iterEllipsoid;i++){//closed form does not exist, involves root solving?\n  float s=sin(E.x);s*=s;\n  n=a/sqrt(1.-e*s);//n(i)\n  E.z=p/cos(E.x)-n;//E.z(i)==h(i)\n  E.x=atan(P.z/(1.-e*(n/(n+E.z))));\n }return E;}\nvec3 c2p(vec3 c);\n*/\n\n//ray [o,d]origin.,direction starts inside sphere [r]radios \n//return intersection of ray from within sphere (is less brancing)\nvec3 rayinsideSphere(float r,vec3 o,vec3 d){\n if(d==vec3(0))return vec3(0);\n float a=dot(d,d);\n float b=2.*dot(d,o);\n float c=dot(o,o)-r*r;\n float e=b*b-4.*a*c;\n e=sqrt(e);\n float q=(e-b)*.5;\n vec2 t=vec2(q/a,c/q);//t stores 2 intersection distances.\n if(t.x>t.y)t=t.yx;//swivel to make t.x closest intersection.\n t.x=mix(t.x,t.y,step(t.x,0.));//if(t.x>0.)t.x=t.x;else t.x=t.y;\n return o+(t.x*d);}//second life wiki geometric\n\n//return polar of carthesian\nvec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//return carthesian of polar\nvec2 p2c(vec2 u){return vec2(u.x*cos(u.y),u.x*sin(u.y));}\n\n//above and below make me think about sphere inverting below, \n//to become the above, for the case where intersection exists.\n//return intersection of [o]RayOrigin  [d]RayDirection and circle [r]Radius \n//this branches too often\nvec3 gSRxX(float r, vec3 o, vec3 d){\n if(r>length(o)) return rayinsideSphere(r,o,d);\n //float t; //o -= Sp;\n if(d==vec3(0))return vec3(0);\n float a=dot(d,d);\n float b=2.*dot(d,o);\n float c=dot(o,o)-r*r;\n float e=b*b-4.*a*c;\n if(e<0.)return vec3(0);\n e=sqrt(e);\n float q; \n if(b<0.)q=(-b-e)*.5;\n else    q=(-b+e)*.5;\n vec2 t=vec2(q/a,c/q);//t stores 2 intersection distances.\n if(t.x>t.y)t=t.yx;//swivel to make t.x closest intersection.\n //there seems to be some sign nonsense going on here.\n //...because this unifies the cases of originInsideCircle and OriginOutsideCircle\n if(t.y<0.)return vec3(0);//both negative, sphere is behind camera.\n t.x=mix(t.x,t.y,step(t.x,0.));//if(t.x>0.)t.x=t.x;else t.x=t.y;\n return o+(t.x*d);}//second life wiki geometric\n    \n//return intersection of ray [o]origin [d]direction with [r]SphereRadius\nvec3 r2s(vec3 o, vec3 d, float e){return gSRxX(e,o,d);}\nvec2 r2s(vec2 o, vec2 d, float e){return gSRxX(e,vec3(o,0),vec3(d,0)).xy;}\n//return intersection of ray [o]origin [d]direction with [e]ellipsoid\nvec3 r2e(vec3 o, vec3 d, vec3 e){\n return r2s(o/e,d/e,1.);}//is scaled intersection of ray and circle\n\n//mirror around half rotated axis.\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//return distance to ray_from_(0,0)_to_(0,infinity)=\"Infinite Line Segment\"\nfloat ils(vec2 u){return mix(length(u),abs(u.y),step(u.x,0.));}\n//return distance to ray from [a] trough [b]\nfloat ils2(vec2 b,vec2 a){vec2 d=b-a;return ils(a*r2(atan(d.y,d.x)));}\n\nvec2 refractd(vec2 i,vec2 n){return 2.*dot(n,i)*n+i;}\n\nvec2 recfectd(vec2 i,vec2 n){\n  return i-2.*dot(n,i)*n;\n  return reflect(i,n);}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n//does not check for non-intersecticn cases! intersection.y is not important.\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n\nvoid mirror(inout vec2 u,inout vec2 m){m.y=abs(m.y);u.y=abs(u.y);}\n\nvoid mainImage(out vec4 O,in vec2 U){\n\tvec2 u=frame(U);\n    vec2 m=frame(iMouse.xy);\n    vec2 n=frame(iMouse.zw);        \n    mirror(u,m);\n    m.y=abs(m.y);\n    n.y=0.;\n    n.x=abs(n.x);\n    m.x=abs(m.x);\n    float blur = 0.025;    \n    vec2 i=r2s(m,m-n,1.);\n    float k=0.;    \n    vec2 t;\n    t.x=cci(vec3(1,n.x,n.x));\n    t.x=2.*sign(n.x)*abs(t.x);\n    t.y=cos(t.x);\n    t.x=abs(t.x);\n    k=abs(.2-length(t-u));    \n    float g=ils2(m-u,n-u);//distance to ray\n    g=mix(g,99.,step(length(u),1.));//only visible outside of circle\n    //g=mix(99.,g,step(length(u),1.));//only visible inside  of circle\n    \n    if(all(equal(i,vec2(0,0)))){}\n    else{        \n     g=mix(g,99.,step(u.x,i.x));//only visible outside of circle\n     k=min(k,abs(.2-length(i-u)));\n     vec2 dir=m-n;\n     dir=refractd(dir,i);\n     //dir=vec2(dir.y,dir.x);\n     g=min(g,ils2(i+dir-u,i-u));\n    }\n    k=smoothstep(blur,-blur,k);\n    float l=smoothstep(-blur,blur,abs(1.-length(u))-blur);\n    g=smoothstep(-blur,blur,g-blur);    \n    if(length(u)>1.){\n     u-=n;\n     u=c2p(u);\n     u.y*=16./acos(-1.);\n    }    \n    u=fract(u*2.);\n    vec3 e=u.y*vec3(1,.5,0)+u.x*vec3(.5,0,1)+g*vec3(0,1,.5)+k*vec3(1,1,1);\n    e=min(e/1.5,vec3(l));\n    O = vec4(e,1);}\n\n//2d is almost boring in comparison:\n/*\n//reminder what opengl does to sinh(x)\n//#define sinh(x) (exp(x)-exp(-x))*.5\n//https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/sinh.xhtml\n#define tau acos(-1.)*2.\n\n//return carthesian of ellipsoid [u] \"around\" ellispoid focal points [-a and a]\nvec2 e2c(vec2 u,float a){\n u.x=abs(u.x);//u\n u.y=min(abs(u.x),tau);//v\n //u.y=abs(u.y);\n return vec2(a*cosh(u.x)*cos(u.y),\n             a*sinh(u.x)*sin(u.y));\n}//https://en.wikipedia.org/wiki/Elliptic_coordinate_system\nstruct ellipsoid{float p;float a;float h;};\n*/\n//#define eul exp(1.)",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}