{
    "Shader": {
        "info": {
            "date": "1616449212",
            "description": "ray marching ",
            "flags": 0,
            "hasliked": 0,
            "id": "NsX3DB",
            "likes": 1,
            "name": "ray marching - v1",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "jezersek",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "#define NUMBER_OF_STEPS 100\n#define MAX_DISTANCE 10.0\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\nconst int n = 8;\nvec3 p[n] = vec3[](\n    vec3(-1,-1, 4), vec3(-1, 1, 4), vec3(1, 1, 4), vec3(1, -1, 4),\n    vec3(-1, 1, 6), vec3(1, 1, 6), vec3(1, -1, 6), vec3(-1,-1, 6)\n);\nfloat f = 1.; // focal length\nvec3 light = normalize(vec3(1,0,-1));\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r + sin(ray.x*4.+iTime)*.1 + sin(ray.y*3.+iTime)*.1 + sin(ray.z*4.+iTime)*.1;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nfloat safe_distance(vec3 ray){\n    float min_distance = MAX_STEP_SIZE;\n    /*float avg = 0.;\n    for(int i=0; i<n; i++){\n        float d = 0.0;\n        if(i%2 == 0){\n            d = distance_to_sphere(ray, p[i], 0.7);\n        }\n        else{\n            d = distance_to_wave_sphere(ray, p[i], 0.7);\n        }\n        \n        if(d < min_distance)min_distance = d;\n    }*/\n    \n    float d1 = distance_to_wave_sphere(ray, vec3(-2,0,6), 2.3);\n    float d2 = distance_to_sphere(ray, vec3(-1.+4.*pow(abs(sin(iTime*0.5)),4.),0,6), 1.); \n   \n    min_distance = smooth_min(d1, d2, 0.4);\n    \n    return min_distance;\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float d = 0.; // ray length\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l = max(dot(n, light), 0.);\n            //color = vec3(l,l,l);\n            color = -n*0.5+0.5;\n            break;\n        }\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}