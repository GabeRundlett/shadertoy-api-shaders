{
    "Shader": {
        "info": {
            "date": "1521479777",
            "description": "Computes maxnorm distance to cubic bezier curve, and also norms whose 'circles' are regular polygons with more edges, just comment out first line. Mouse to show curve touching polygon, click lower left to let it disappear",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKyRm",
            "likes": 10,
            "name": "Cubic bezier maxnorm distance",
            "published": 3,
            "tags": [
                "bezier",
                "cubic",
                "maxnorm"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 884
        },
        "renderpass": [
            {
                "code": "#define MAXNORM\n#define SHOW_POLYGON\n#define NUM_CORNERS int(mod(iTime,6.))*2+4\n\nconst float eps = .000005;\nconst float zoom = 1.;\nconst float dot_size=.005;\nconst vec3 point_col=vec3(1,1,0);\nconst float pi = 3.1416;\nconst int max_corners=16;\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_roots){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos < uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1 = p0.xy - p1.xy;\n\tvec2 tang2 = p2.xy - p3.xy;\n\n\tvec2 nor1 = vec2(tang1.y,-tang1.x);\n\tvec2 nor2 = vec2(tang2.y,-tang2.x);\n\n\tif(p0.y < p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat max_norm(vec2 vector){\n\treturn max(abs(vector.x),abs(vector.y));\n}\n\nfloat hexagon_norm(vec2 vector){\n\treturn max(dot(abs(vector),vec2(0.866025403784439,.5)),abs(vector.y));\n}\n\nfloat octagon_norm(vec2 vector){\n\treturn max(dot(abs(vector),vec2(0.707106781186548)),max_norm(vector));\n}\n\nfloat decagon_norm(vec2 vector){\n\tvec2 dir1=vec2(0.587785252292473,0.809016994374947);\n\tvec2 dir2=vec2(0.951056516295154,0.309016994374947);\n\n\treturn max(max(abs(vector.y),dot(abs(vector),dir1)),dot(abs(vector),dir2));\n}\n\n//only even numbers >=4 allowed\nfloat regular_polygon_norm(vec2 vector, int n){\n\tfloat dir_step=(1.-2./float(n))*pi;\n\n\tfloat norm=0.;\n\n\tfor(int i=0;i<max_corners/2;i++){\n\t\tif(i<n/2){\n\t\t\tfloat cur_dir=float(i)*dir_step;\n\t\t\tvec2 dir=abs(vec2(sin(cur_dir),cos(cur_dir)));\n\n\t\t\tnorm=max(norm,dot(abs(vector),dir));\n\t\t}\n\t}\n\n\treturn norm;\n}\n\nfloat cubic_bezier_max_norm_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tvec2 b2 = 3.*a3;\n\tvec2 b1 = 2.*a2;\n\tvec2 b0 = a1;\n\n\tvec3 roots1 = vec3(1e38);\n\tvec3 roots2 = vec3(1e38);\n\n\tint num_roots1 = solve_cubic(vec3(a0.x+a0.y,a1.x+a1.y,a2.x+a2.y)/(a3.x+a3.y),roots1);\n\tint num_roots2 = solve_cubic(vec3(a0.x-a0.y,a1.x-a1.y,a2.x-a2.y)/(a3.x-a3.y),roots2);\n\n\tvec2 roots_drv_x = vec2(1e38);\n\tvec2 roots_drv_y = vec2(1e38);\n\n\tint num_roots_drv_x = solve_quadric(vec2(b0.x,b1.x)/b2.x, roots_drv_x);\n\tint num_roots_drv_y = solve_quadric(vec2(b0.y,b1.y)/b2.y, roots_drv_y);\n\n\tfloat d0 = 1e38;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i<num_roots1){\n\t\t\troots1[i]=clamp(roots1[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots1[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t\tif(i<num_roots2){\n\t\t\troots2[i]=clamp(roots2[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots2[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t\tif(i<num_roots_drv_x){\n\t\t\troots_drv_x[i]=clamp(roots_drv_x[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots_drv_x[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t\tif(i<num_roots_drv_y){\n\t\t\troots_drv_y[i]=clamp(roots_drv_y[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots_drv_y[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_regular_polygon_norm_dis(vec2 uv, int n, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = -p0 + 3. * p1 - 3. * p2 + p3;\n\tvec2 a2 = 3. * p0 - 6. * p1 + 3. * p2;\n\tvec2 a1 = -3. * p0 + 3. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat dir_step=(1.-2./float(n))*pi;\n\n\tfor(int i=0;i<max_corners/2;i++){\n\t\tif(i<n/2){\n\t\t\tfloat cur_dir=dir_step*float(i);\n\t\t\tfloat next_dir=dir_step*float(i+1);\n\n\t\t\tvec2 dir=(vec2(sin(cur_dir),cos(cur_dir)));\n\t\t\tvec2 dir2=(vec2(sin(next_dir),cos(next_dir)));\n\n\t\t\tvec3 poly=vec3(dot(a0,dir+dir2),dot(a1,dir+dir2),dot(a2,dir+dir2))/dot(a3,dir+dir2);\n\t\t\tvec2 poly_drv=vec2(dot(a1,(dir)),2.*dot(a2,(dir)))/(3.*dot(a3,(dir)));\n\n\t\t\tvec3 roots=vec3(1e38);\n\t\t\tvec2 roots_drv=vec2(1e38);\n\n\t\t\tint num_roots = solve_cubic(poly,roots);\n\t\t\tint num_roots_drv = solve_quadric(poly_drv,roots_drv);\n\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(j<num_roots){\n\t\t\t\t\troots[j]=clamp(roots[j],0.,1.);\n\t\t\t\t\tvec2 point = parametric_cub_bezier(roots[j],p0,p1,p2,p3);\n\t\t\t\t\td0 = min(d0,regular_polygon_norm(point-uv,NUM_CORNERS));\n\t\t\t\t}\n\t\t\t\tif(j<num_roots_drv){\n\t\t\t\t\troots_drv[j]=clamp(roots_drv[j],0.,1.);\n\t\t\t\t\tvec2 point = parametric_cub_bezier(roots_drv[j],p0,p1,p2,p3);\n\t\t\t\t\td0 = min(d0,regular_polygon_norm(point-uv,NUM_CORNERS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.y *= iResolution.y / iResolution.x;\n\n\tborder*=zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat t0=mod(iTime*2.+1.5,24.*pi);\n\n\tvec2 p0 = vec2(-cos(t0 * 1./2.) * .2,sin(t0 * 1./3.) * .25);\n\tvec2 p1 = vec2(-cos(t0 * 2./3.) * .2,sin(t0 * 1./4.) * .1);\n\tvec2 p2 = vec2(cos(t0 * 1./4.) * .1,-sin(t0 * 2./3.) * .2);\n\tvec2 p3 = vec2(cos(t0 * 1./3.) * .25,-sin(t0 * 1./2.) * .1);\n\n\t//vec2 p0=vec2(-.3,-.1);\n\t//vec2 p1=vec2(-.5,.5);\n\t////vec2 p1=mouse;\n\t//vec2 p2=vec2(.1,-.2);\n\t//vec2 p3=vec2(.2,.15);\n    \n    float radius=1e38;\n    \n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        #ifdef SHOW_POLYGON\n        \n        #ifdef MAXNORM\n\t\tradius = cubic_bezier_max_norm_dis(mouse,p0,p1,p2,p3);\n    \t#else\n    \tradius = cubic_bezier_regular_polygon_norm_dis(mouse,NUM_CORNERS,p0,p1,p2,p3);\n    \t#endif\n        \n        #else\n        p0=vec2(-.3,-.1);\n        p1=mouse;\n        p2=vec2(.1,-.2);\n        p3=vec2(.2,.15);\n        #endif\n    }\n\n\tfloat d0 = 1e38;\n\n    #ifdef MAXNORM\n\td0 = min(d0,cubic_bezier_max_norm_dis(uv,p0,p1,p2,p3));\n    #else\n\td0 = min(d0,cubic_bezier_regular_polygon_norm_dis(uv,NUM_CORNERS,p0,p1,p2,p3));\n    #endif\n\n\tfloat sgn = cubic_bezier_sign(uv,p0,p1,p2,p3);\n\n\t//iq's sd color scheme\n\tvec3 col = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-8.0 * d0);\n\tcol *= 0.8 + 0.2*cos(480.0*d0);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d0)));\n\n\td0 = 1e38;\n\n\td0 = min(d0,distance(p0,uv) - dot_size);\n\td0 = min(d0,distance(p1,uv) - dot_size);\n\td0 = min(d0,distance(p2,uv) - dot_size);\n\td0 = min(d0,distance(p3,uv) - dot_size);\n\n\tcol = mix(point_col,col,smoothstep(0.,border,d0));\n\n\td0 = 1e38;\n\n    #ifdef SHOW_POLYGON\n    #ifdef MAXNORM\n\td0 = min(d0,abs(max_norm(mouse-uv)-radius));\n    #else\n\td0 = min(d0,abs(regular_polygon_norm(mouse-uv,NUM_CORNERS)-radius));\n    #endif\n    #endif\n\n\tcol = mix(vec3(0),col,smoothstep(0.,border,d0));\n\n\tfragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}