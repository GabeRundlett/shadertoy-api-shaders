{
    "Shader": {
        "info": {
            "date": "1697127104",
            "description": "First Kendama on Shadertoy!\n\nUse the mouse to move the camera.\nJust deactivate the AA (line 21: true -> false) if the shader is running too slowly.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtfBWX",
            "likes": 9,
            "name": "Hello KENDAMA",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "wood",
                "kendama"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "//                     = Hello KENDAMA =         \n//               by Maximilian Knape ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA 2.2\n\n#define MAX_STEPS 120\n#define STEP_FAC 0.6\n#define MAX_DIST 1.\n#define MIN_DIST .01\n\n#define GLOW_INT 0.5\n#define PP_ACES 0.5\n#define PP_CONT 0.5\n#define PP_VIGN 1.5\n#define AO_OCC 0.3\n#define AO_SCA 0.8\n\n#define AA_ENAB true\n#define AA_THRE .01\n\n#define iTime iTime\n#define PI 3.14159265\n#define TAU 6.28318531\n#define S(x,y,t) smoothstep(x,y,t)\n\n\nvec2 Map(in vec3 p) \n{    \n    float d = MAX_DIST, col = 0., l = length(p);\n    \n    //TAMA\n    vec3 tamp = p - vec3(0,.0745 + Move(iTime)*.06,0);\n    float taml = length(tamp);\n    if (taml < .1)\n    {\n        float tama = length(tamp) - .03;\n        tama = smax(tama, -sdCone(tamp + vec3(0.,.016,0.), vec2(0.7), .02), .001);\n        tama = max(tama, -sdCylinder(tamp + vec3(0,.01,0), vec2(.007, .03)));\n        tama = max(tama, -sdCylinder(tamp - vec3(0,.01,0), vec2(.001, .03)));\n        tama = max(tama, -(length(tamp - vec3(0,.0325,0))-0.0035));\n        \n        col = tamp.y > -.015 && taml > .029 ? \n                mix(col, 3.85, step(tama, d)) : \n                mix(col, Wood(tamp.yzx), step(tama, d));\n                \n        d = min(tama, d);\n    }\n    else d = .1;\n    \n    //KEN\n    vec3 kenp = p;\n    if (length(kenp) < .3)\n    {\n        float ken = sdCappedCone(p, 0.075, .015, .0001) - (kenp.y*kenp.y)/1.5;\n        \n        if (kenp.y > -.02) \n        {\n            ken = smin(ken, length(kenp - vec3(0,0.080,0)) - .0008, .0045);\n            \n            float cups = sdEllipsoid(kenp - vec3(0.012, .035, 0.), vec3(.1, .025, .025));\n            cups = max(cups, -sdTorus(kenp.zxy - vec3(0., .0, .035), vec2(.04, .031))); \n            cups = max(cups, sdBox(kenp - vec3(0.001, .035, 0.), vec3(.038)));\n            cups = max(cups, -(length(kenp - vec3(0.059, .035, 0.)) - .03));\n            cups = max(cups, -(length(kenp - vec3(-0.059, .035, 0.)) - .03));\n\n            col = mix(col, Wood(kenp.zxy), step(cups, d));\n            d = min(cups, d);\n        }\n        else\n        {\n            ken = smin(ken, sdCylinder(kenp + vec3(0,.0715,0), vec2(.02, .006)), .003);\n            ken = smin(ken, sdCylinder(kenp + vec3(0,.035,0), vec2(.017, .002)), .01);\n            float bcup = length(kenp + vec3(0.,.1,0.)) - .029; \n            bcup = min(bcup, sdCylinder(kenp + vec3(0,.1,0), vec2(.007, .05)));\n            ken = max(ken, -bcup);\n        }\n        \n        col = mix(col, Wood(kenp), step(ken, d));\n        d = min(ken, d);\n    }\n    else d = .1;\n\n    return vec2(d, col);\n}\n\nfloat String(in vec3 ro, in vec3 rd)\n{\n    float m = Move(iTime);\n    \n    vec3 p0 = vec3(0., 0.04, -.0085);\n    vec3 p1 = vec3(-.08*cos(iTime*1.3), -.7 + m*.03, -.14);\n    vec3 p2 = vec3(-.03*sin(iTime*0.5), .105 + m*.06, .15);\n    vec3 p3 = vec3(0, .105 + m*.06, 0);\n    \n    float t = iBezier( ro, rd, p0, p1, p2, p3, 0.0005);\n    \n    return t > 0.0 ? t : MAX_DIST;\n}\n\nfloat SurfDis(float depth) { return depth / iResolution.y / 2.; }\n\nvec3 Normal(in vec3 p, in float depth)\n{\n    float h = SurfDis(depth);\n    vec2 k = vec2(1.,-1.);\n\n    return normalize(   k.xyy * Map(p + k.xyy * h).x + \n                        k.yyx * Map(p + k.yyx * h).x + \n                        k.yxy * Map(p + k.yxy * h).x + \n                        k.xxx * Map(p + k.xxx * h).x );\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, vec2 fc) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    dO += (fract(1e3* sin( dot(fc,vec2(114,211.1) )))-.5)*MIN_DIST; //fabrice like\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < SurfDis(dO)) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float dis, float w) //iq mk\n{\n    float res = 1.;\n    float t = .01;\n    float d = (MAX_DIST-dis)*.5;\n    \n    for( int i=0; i<12 && t<d; i++ )\n    {\n        float h = Map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n        t += clamp(log(h+1.), .001, .1);\n        if( res<-1.0 || t>d) break;\n    }\n    res = clamp(res*2., -1., 1.);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = 0.001 + 0.150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(0.0, 1.0 , 1.0 - 1.5 * occ);    \n}\n\nconst vec3 ambCol = vec3(.03,.05,.1) * 2.0;\nconst vec3 sunCol = vec3(1., .8, .6) * 1.0;\nconst vec3 skyCol = vec3(.3, .5, 1.) * 1.0;\nconst float specExp = 5.;\n\nvec3 Sky(vec3 rd, vec3 lPos, float depth)\n{\n    float gnd = smoothstep(-.2, .3, dot(vec3(0,1,0), rd));\n    vec3 col = mix((ambCol + skyCol + sunCol) / 8., skyCol, gnd);\n\n    return S(vec3(0), vec3(1), col);\n}\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lp, float dis) \n{\n\n    vec3    lidi = normalize(lp - p);\n    float   mafa = max(mat, .0),\n            amoc = CalcAO(p, n),\n            shad = softshadow(p, normalize(lp), dis, 0.5),\n            diff = max(dot(n, lidi), 0.) * shad,\n            spec = pow(diff, max(1., specExp * mafa)),\n            refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad;\n\n    return  col * (amoc * ambCol +                                       \n                   (1. - mafa) * diff * sunCol +                         \n                   mafa * (spec + refl) * sunCol +                       \n                   max(-mat, 0.) * smoothstep(0., 1., amoc * amoc + .5));\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1.);\n        case 1: return vec3(1., .6, .3) *.7;\n        case 2: return vec3(1., .02, .01) *.3 * S(0.,1.,cos(iTime/21.));\n        case 3: return hsv2rgb_smooth(vec3(fract(iTime/36.+.3), .8, .85));\n    }\n    return vec3(0.);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l)\n{\n    vec3   f = normalize(l - p),\n           r = normalize(cross(vec3(0,1,0), f)),\n           u = cross(f,r),\n           c = p + f,\n           i = c + uv.x*r + uv.y*u;\n    return normalize(i - p);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(0., 0., -.3);\n    ro.yz *= Rot(-m.y * PI + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0., 0.03, 0.));\n    \n    vec3 lPos = vec3(sin(iTime*2.*PI/10.)*5., sin(iTime*2.*PI/20.)*5.+00., cos(iTime*2.*PI/30.)*5.-10.);\n    \n    vec3 p = vec3(0.);\n    vec3 rmd = RayMarch(ro, rd, fragCoord);\n    \n    vec3 bg = Sky(rd, lPos, rmd.x/MAX_DIST);\n    vec3 col = bg;\n    \n    float str = String(ro, rd);\n    \n    if (str < rmd.x)\n    {\n        col = Palette(2) * S(1.,-1., dot(rd, normalize(lPos))) + vec3(.02);\n        //col *= softshadow( ro + rd*str, normalize(lPos), str, 0.5);\n        rmd.x = str;\n        rmd.y = 1.;\n    }\n    else if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p, rmd.x);\n        if (rmd.z < 2. && rmd.z > 1.) \n            n *= 1. - (rmd.z-1.5) * .5;\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        col = Palette(int(floor(abs(rmd.z))));\n        col = Shade(col, shine, p, n, rd, lPos, rmd.x);   \n        \n        //col = vec3(1) * CalcAO(p, n);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 2.));\n    \n    col = mix(col, bg, disFac);\n    col += pow(rmd.y / float(MAX_STEPS), 2.) * normalize(ambCol) * GLOW_INT;\n    \n    fragColor = vec4(col * S(0., 10., iTime*iTime),1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES); \n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, vec3(1) / GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) //Fabrice\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   -----= Inigo Quilez =-----\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) // vertical\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h ) // vertical\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n}\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float width)\n{\n    const int kNum = 42;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec3 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n}\n\n//   -------= IQ END =-------\n\n\nfloat Move(in float t) { return smoothstep(-.0, 1., -sin(t/3.)); }\n\nfloat Wood(in vec3 p)\n{\n    p *= vec3(50,10,30);\n    //p += vec3(3,2,1);\n    return 1. + fract(dot(sin(p), cos(p))*10.)*.4;\n}\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}