{
    "Shader": {
        "info": {
            "date": "1718676205",
            "description": "I was at a cafe and saw this beautiful pattern at the floor. I decided to copy it into a GLSL shader.\nEvery shape is related to another and you can control the size of everything at line 129.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3cSz8",
            "likes": 12,
            "name": "020.1 - Cafe floor pattern",
            "published": 3,
            "tags": [
                "sdf",
                "antialias",
                "pattern",
                "floor",
                "beautiful"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 142
        },
        "renderpass": [
            {
                "code": "// 2024.06.16 rev 1\n// 2024.06.18 rev 2 fix tearing and add final noise output\n// 2024.06.18 rev 3 fix a bug related to tearing when iTime variable is too large\n// 2024.06.22 rev 4 see https://www.shadertoy.com/view/lXcXWN use texture instead of uv space rotation to avoid float precision errors\n// 2024.06.22 rev 5 see https://www.shadertoy.com/view/l3dSDN use supersampling to avoid imprecision patterns\n\n#define DEBUG 0\n#define AA 1\n#define NOISE 1\n//#define iTime (51.)\n//#define iMouse vec3(200)\n\n// Returns a range of vec2(-1) to vec2(1) based on mouse and screen size\n// Deals with first frame and returns vec2(0) if so\nvec2 uvMouse() {\n    if (length(iMouse.xy) == 0.) {\n        return vec2(0, 0);\n    }\n    return ((iMouse.xy / iResolution.xy) - 0.5) * 2.;\n}\n\n// From https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n// From https://gist.github.com/tylerdurrett/d492d8aa08f4c3968602a14a4cbe44c9\nmat2 skewUV(vec2 s) {\n    return mat2(1., tan(s.x),\n                tan(s.y), 1.);\n}\n\nfloat antiAlias = 1.5;\nfloat stepaa(float x, float y) {\n    #if AA\n    float w = antiAlias;\n    return smoothstep(x - w, x + w, y);\n    #endif\n    return step(x, y);\n}\n\n// (v.x, v.y) -> (v.y, v.x)\nvec2 swap(vec2 v) {\n    return vec2(v.y, v.x);\n}\n\n// Returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\n// Returns alpha value of a circle with antiAlias\nfloat circle(vec2 uv, vec2 origin, float size) {\n    return stepaa(length(uv - origin), size+antiAlias);\n}\n\n// Returns alpha value of a square with antiAlias\nfloat square(vec2 uv, vec2 origin, vec2 size) {\n    vec2 o = abs(uv - origin);\n    size += antiAlias;\n    return stepaa(o.x, size.x) * stepaa(o.y, size.y);\n}\n\n// Returns alpha value of a paralelogram with antiAlias\nfloat paralelogram(vec2 uv, vec2 origin, vec2 size, vec2 skew) {\n    vec2 o = uv - origin;\n    mat2 s = skewUV(skew);\n    o *= s;\n    size *= s;\n    float leftEdge = stepaa(o.x, size.x);\n    float rightEdge = stepaa(-o.x, size.x);\n    float topEdge = stepaa(o.y, size.y);\n    float bottomEdge = stepaa(-o.y, size.y);\n    return leftEdge * rightEdge * topEdge * bottomEdge;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = uvMouse();\n    antiAlias = (antiAlias + ((mouse.x + 1.) * 5.))/iResolution.y;\n#if !AA\n    antiAlias *= 0.;\n#endif\n    vec3 color = vec3(1.);\n#if DEBUG\n    vec3 red = vec3(1, 0, 0);\n    vec3 green = vec3(0, 1, 0);\n    vec3 blue = vec3(0, 0, 1);\n    vec3 magenta = vec3(1, 0, 1);\n#endif    \n\n    // Screen space setup\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= mouse.x + 1.;\n    vec2 fuv = rotate(uv, radians(mod(45. + iTime*2. + 12., 180.))) + (mod(iTime, 12.))/12.;\n    uv = (fract(fuv) - 0.5) * 2.;\n    vec2 quadrant = sign(uv);\n    vec2 suv = uv * 2.;\n    if (quadrant == vec2(1)) {\n        uv = suv + vec2(-1);\n#if DEBUG\n        color = red;\n#endif\n    } else if (quadrant == vec2(-1, 1)) {\n        uv = suv + vec2(1, -1);\n        uv = rotate(uv, radians(-90.0));\n#if DEBUG\n        color = green;\n#endif\n    } else if (quadrant == vec2(-1)) {\n        uv = suv + vec2(1, 1);\n        uv = rotate(uv, radians(-180.0));\n#if DEBUG\n        color = blue;\n#endif\n    } else if (quadrant == vec2(1, -1)) {\n        uv = suv + vec2(-1, 1);\n        uv = rotate(uv, radians(-270.0));\n#if DEBUG\n        color = magenta;\n#endif\n    }\n    \n    // Colors\n    vec2 coord = mod(mod(fuv*300., 300.), 256.);\n    float noise = texelFetch(iChannel0, ivec2(coord), 0).x/10.;\n#if !NOISE\n    noise = 0.;\n#endif\n    vec3 white = mix(vec3(0.93), vec3(0.031), noise);\n    vec3 black = mix(vec3(0.02), vec3(0.98), noise);\n    vec3 grey = mix(vec3(0.51f, 0.47f, 0.44f), vec3(0.0444), noise);\n#if !DEBUG\n    color = grey * 0.65;\n#endif\n    \n    // Size for circles\n    float s1 = 0.61;\n#if DEBUG\n    s1 += abs(sin(iTime)) / 75.;\n#endif\n    float s2 = s1 * 0.75;\n    // Size for grey background square\n    float thick = (s1 - s2);\n    \n    // White background\n    color = mix(color, white, square(uv, vec2(0), vec2(1.)));\n    \n    // Bottom left background square\n    color = mix(color, grey, square(uv, vec2(-thick/2.), vec2(1. - thick/2.)));\n\n    // Corners black semicircles\n    vec2 cbq = vec2(s2 * 0.65);\n    color = mix(color, black, square(uv, vec2(-1. + cbq.x, 1. - cbq.y), cbq));\n    color = mix(color, black, square(uv, vec2(1. - cbq.x, -1. + cbq.y), cbq));\n    \n    // Corners pattern circles\n    vec2 cpc1 = vec2(-1. + s1, 1. - s1);\n    vec2 cpc2 = vec2(1. - s1, -1. + s1);\n    color = mix(color, white, circle(uv, cpc1, s1));\n    color = mix(color, white, circle(uv, cpc2, s1));\n    \n    // Squares to mask circles\n    vec2 maskSize = vec2(1. - thick - s2/2., s2 * 0.7);\n    vec2 maskCoord = 1. - thick - maskSize;\n    color = mix(color, grey, square(uv, maskCoord, maskSize));\n    color = mix(color, grey, square(uv, swap(maskCoord), swap(maskSize)));\n    \n    // Corners small circles\n    vec2 csc1 = vec2(-1. + s1, 1. - s1);\n    vec2 csc2 = vec2(1. - s1, -1. + s1);\n    color = mix(color, grey, circle(uv, csc1, s2));\n    color = mix(color, grey, circle(uv, csc2, s2));\n        \n    // Small white square to mask circle discontinuity\n    vec2 cdist = cpc2 - cpc1;\n    vec2 sqp = (cpc1 + normalize(cdist) * length(cdist)/2.) + s2/3.;\n    color = mix(color, white, square(uv, sqp, vec2(thick)));\n\n    // Center leafs\n    float l1 = s2 * 0.4;\n    float l2 = l1 * 0.80;\n    float ang = radians(105.);\n    color = mix(color, white, circle(uv, csc1 + vec2(sin(ang), cos(ang))*s2, l2));\n    color = mix(color, white, circle(uv, csc2 + vec2(cos(ang), sin(ang))*s2, l2));\n    color = mix(color, white, circle(uv, sqp + thick, l1));\n    \n    // Bottom left leafs\n    vec2 sbl = vec2(1.-(s1), (1. - s1)/2.);\n    float slbang = radians(45.);\n    color = mix(color, white, paralelogram(uv, vec2(-1.) + sbl, sbl, vec2(-slbang, 0.)));\n    color = mix(color, black, paralelogram(uv, vec2(-1.) + swap(sbl), swap(sbl), vec2(0., -slbang)));\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}