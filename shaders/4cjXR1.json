{
    "Shader": {
        "info": {
            "date": "1706032096",
            "description": "WARNING: may be slow.\nComparison of several filters (see code for full list).\nOnly quality is compared, speed is not representative.\nClick LMB to select a pair of filters (x=left, y=right).\nChange \"#define N\" in code to enable more/less filters.",
            "flags": 0,
            "hasliked": 0,
            "id": "4cjXR1",
            "likes": 2,
            "name": "Filters comparison",
            "published": 3,
            "tags": [
                "texture",
                "filter"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 172
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details,\n// EXCEPT the code for spline*_kernel is adapted from CubicSpline in\n// https://github.com/ImageMagick/ImageMagick/blob/main/MagickCore/resize.c,\n// see https://github.com/ImageMagick/ImageMagick/blob/main/LICENSE\n// for the details.\n\n// Comparison of several filters.\n// Both interpolating (exactly match samples at gridpoints, e.g.\n// Catmull-Rom) and approximating (e.g. B-spline) filters are included.\n\n//==============================================================================\n// \"Hermite\"  kernels from https://www.shadertoy.com/view/McfXWs.\n// NOTE: \"Hermite\" is a bit of a misnomer, since a Hermite\n// spline is defined by function values and derivatives\n// at interval endpoints. Since we don't HAVE derivatives,\n// only function samples, a Hermite spline does not exist.\n// We instead use samples to compute finite difference\n// approximations of the derivatives, and use those.\n// Calling the resulting filter/kernel \"Hermite\" might not\n// be strictly accurate, but hopefully clear enough.\n\nfloat hermite4_kernel(float t)\n{\n    t=abs(t);\n    if(t<1.0) return 1.0+t*t*(-2.5+t*1.5);\n    if(t<2.0) return 2.0+t*(-4.0+t*(2.5+t*-0.5));\n    return 0.0;\n}\n\n// Quintic 4-taps Hermite kernel from\n// https://www.shadertoy.com/view/XflXz7.\nfloat hermite4q_kernel(float t)\n{\n    t=abs(t);\n    if(t<1.0) return 1.0+t*t*(-1.0+t*(-4.5+t*(7.5+t*-3.0)));\n    if(t<2.0) return -4.0+t*(18.0+t*(-29.0+t*(21.5+t*(-7.5+t*1.0))));\n    return 0.0;\n}\n\nfloat hermite6_kernel(float t)\n{\n    t=abs(t);\n    if(t<1.0) return (12.0+t*t*(-15.0+t*(-35.0+t*(63.0+t*-25.0))))/12.0;\n    if(t<2.0) return (-96.0+t*(450.0+t*(-735.0+t*(545.0+t*(-189.0+t*25.0)))))/24.0;\n    if(t<3.0) return (432.0+t*(-918.0+t*(765.0+t*(-313.0+t*(63.0+t*-5.0)))))/24.0;\n    return 0.0;\n}\n\nfloat hermite8_kernel(float t)\n{\n    t=abs(t);\n    if(t<1.0) return 1.+t*(0.+t*(-49./36.+t*(0.+t*(-959./144.+t*(2569./144.+t*(-727./48.+t*(623./144.)))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(-3./4.+t*(3./4.+t*(13./48.+t*(95./24.+t*(-429./40.+t*(1091./120.+t*(-623./240.)))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(3./20.+t*(-3./40.+t*(-1./6.+t*(-191./144.+t*(2581./720.+t*(-2183./720.+t*(623./720.)))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(-1./60.+t*(1./180.+t*(1./48.+t*(7./36.+t*(-37./72.+t*(13./30.+t*(-89./720.)))))));\n    return 0.0;\n}\n\nfloat hermite10_kernel(float t)\n{\n    t=abs(t);\n    if(t<1.0) return 1.+t*(0.+t*(-205./144.+t*(0.+t*(91./192.+t*(-6181./320.+t*(6337./96.+t*(-2745./32.+t*(28909./576.+t*(-3569./320.)))))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(-4./5.+t*(4./5.+t*(61./180.+t*(-61./180.+t*(3697./288.+t*(-31681./720.+t*(5147./90.+t*(-24091./720.+t*(3569./480.)))))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(1./5.+t*(-1./10.+t*(-169./720.+t*(169./1440.+t*(-1579./288.+t*(13577./720.+t*(-30883./1260.+t*(144547./10080.+t*(-3569./1120.)))))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(-4./105.+t*(4./315.+t*(1./20.+t*(-1./60.+t*(175./128.+t*(-2263./480.+t*(41179./6720.+t*(-36137./10080.+t*(3569./4480.)))))))));\n    t-=1.0;\n    if(t<1.0) return 0.+t*(1./280.+t*(-1./1120.+t*(-7./1440.+t*(7./5760.+t*(-175./1152.+t*(503./960.+t*(-1961./2880.+t*(16061./40320.+t*(-3569./40320.)))))))));\n    return 0.0;\n}\n\n//==============================================================================\n// SplineN kernels.\n// Adapted from CubicSpline in https://github.com/ImageMagick/ImageMagick/blob/main/MagickCore/resize.c\n\nfloat spline4_kernel(float x)\n{\n    x=abs(x);\n    if(x<1.0) return ((x-9.0/5.0)*x-1.0/5.0)*x+1.0;\n    if(x<2.0) return ((-1.0/3.0*(x-1.0)+4.0/5.0)*(x-1.0)-7.0/15.0)*(x-1.0);\n    return 0.0;\n}\n\nfloat spline6_kernel(float x)\n{\n    x=abs(x);\n    if (x<1.0) return ((13.0/11.0*x-453.0/209.0)*x-3.0/209.0)*x+1.0;\n    if (x<2.0) return ((-6.0/11.0*(x-1.0)+270.0/209.0)*(x-1.0)-156.0/209.0)*(x-1.0);\n    if (x<3.0) return ((1.0/11.0*(x-2.0)-45.0/209.0)*(x-2.0)+26.0/209.0)*(x-2.0);\n    return 0.0;\n}\n\nfloat spline8_kernel(float x)\n{\n    x=abs(x);\n    if(x<1.0) return ((49.0/41.0*x-6387.0/2911.0)*x-3.0/2911.0)*x+1.0;\n    if(x<2.0) return ((-24.0/41.0*(x-1.0)+4032.0/2911.0)*(x-1.0)-2328.0/2911.0)*(x-1.0);\n    if(x<3.0) return ((6.0/41.0*(x-2.0)-1008.0/2911.0)*(x-2.0)+582.0/2911.0)*(x-2.0);\n    if(x<4.0) return ((-1.0/41.0*(x-3.0)+168.0/2911.0)*(x-3.0)-97.0/2911.0)*(x-3.0);\n    return(0.0);\n}\n\n//==============================================================================\n// Mitchell-Netravali kernels.\n// See also https://www.shadertoy.com/view/Dlc3Rn.\n// This class includes Catmull-Rom (same as hermite4_kernel, B=0, C=0.5),\n// and cubic B-spline (B=1, C=0).\n// The splines are interpolating (pass exactly through samples)\n// iff B=0.\n\nfloat mitchell_netravali_kernel(float B,float C,float t)\n{\n    t=abs(t);\n    if(t<1.0) return ((6.0-2.0*B)+t*t*((-18.0+12.0*B+6.0*C)+t*(12.0-9.0*B-6.0*C)))/6.0;\n    if(t<2.0) return ((8.0*B+24.0*C)+t*((-12.0*B-48.0*C)+t*((6.0*B+30.0*C)+t*(-B-6.0*C))))/6.0;\n    return 0.0;\n}\n\n// \"Classic\" Mitchell-Netravali kernel: B=C=1/3.\nfloat mitchell_kernel(float t)\n{\n    return mitchell_netravali_kernel(1.0/3.0,1.0/3.0,t);\n}\n\n// Cubic B-spline: B=1, C=0;\nfloat bspline4_kernel(float t)\n{\n    return mitchell_netravali_kernel(1.0,0.0,t);\n}\n\n//==============================================================================\n// Lanczos kernels.\n\n// Normalized sinc function.\nfloat sinc(float x)\n{\n    x=3.14159265358979*abs(x)+1e-4; // Avoid 0/0.\n    return sin(x)/x;\n}\n\n// NOTE: the naming scheme is unconventional,\n// for consistency with the rest of the code.\n// Normally, what is called lanczos4_kernel\n// here, would probably be called lanczos2,\n// and so on.\n\nfloat lanczos4_kernel(float x)\n{\n    return abs(x)<2.0?sinc(x)*sinc(x/2.0):0.0;\n}\n\nfloat lanczos6_kernel(float x)\n{\n    return abs(x)<3.0?sinc(x)*sinc(x/3.0):0.0;\n}\n\nfloat lanczos8_kernel(float x)\n{\n    return abs(x)<4.0?sinc(x)*sinc(x/4.0):0.0;\n}\n\n//==============================================================================\n// sRGB<->linear conversions.\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvec3 srgb2linear(vec3 rgb)\n{\n    return mix(rgb/12.92,pow((rgb+0.055)/1.055,vec3(2.4)),step(0.04045,rgb));\n}\n\n#define SRGB 1 // 1=manual.\n\n#if SRGB\nvec4 Texture(sampler2D t,vec2 uv)\n{\n    vec4 rgba=texture(t,uv);\n    return vec4(\n        srgb2linear(rgba.xyz),\n        rgba.w);\n}\n#else\n#define Texture texture\n#endif\n\n//==============================================================================\n// Dispatcher.\n// NOTE: we treat *all* filters as NxN. This slows many of them\n// down, renders performance comparisons moot, but seems easier for\n// GPUs to stomach.\n\n// You may define this to something else, depending\n// on how powerful your GPU is.\n#define N 6 // Max. filter size.\n\nfloat kernel(int id,float t)\n{\n    switch(id)\n    {\n        case  0: return step(abs(t),0.5);     // Nearest.\n        case  1: return max(1.0-abs(t),0.0);  // Linear.\n#define NUM_FILTERS 2\n#if N>=4\n        case  2: return hermite4_kernel(t);   // Catmull-Rom (B=0, C=1/2).\n        case  3: return hermite4q_kernel(t);  // Quintic 4-taps Hermite spline.\n        case  4: return spline4_kernel(t);\n        case  5: return mitchell_kernel(t);   // B=1/3, C=1/3\n        case  6: return bspline4_kernel(t);   // B=1  , C=0\n        case  7: return lanczos4_kernel(t);\n#undef NUM_FILTERS\n#define NUM_FILTERS 8\n#endif\n#if N>=6\n        case  8: return hermite6_kernel(t);\n        case  9: return spline6_kernel(t);\n        case 10: return lanczos6_kernel(t);\n#undef NUM_FILTERS\n#define NUM_FILTERS 11\n#endif\n#if N>=8\n        case 11: return hermite8_kernel(t);\n        case 12: return spline8_kernel(t);\n        case 13: return lanczos8_kernel(t);\n#undef NUM_FILTERS\n#define NUM_FILTERS 14\n#endif\n#if N>=10\n        case 14: return hermite10_kernel(t);\n#undef NUM_FILTERS\n#define NUM_FILTERS 15\n#endif\n    }\n    return 0.0;\n}\n\nvec4 f(int id,sampler2D t,vec2 uv)\n{\n    vec2 wh=vec2(textureSize(t,0));\n    uv*=wh;\n    uv-=0.5;\n    ivec2 iuv=ivec2(floor(uv));\n    uv-=vec2(iuv);\n    vec2 c=(vec2(iuv)+0.5)/wh,d=1.0/wh;\n    vec4 ret=vec4(0);\n#if 0\n    // Doesn't seem to work. Bug?\n    vec2 W[N];\n    for(int i=1-N/2;i<=+N/2;++i) W[i+N/2-1]=vec2(kernel(id,float(i)-uv.x),kernel(id,float(i)-uv.y));\n    for(int y=1-N/2;y<=+N/2;++y)\n        for(int x=1-N/2;x<=+N/2;++x)\n            ret+=W[x+N/2-1].x*W[y+N/2-1].y*Texture(t,c+d*vec2(x,y));\n#else\n    for(int y=1-N/2;y<=+N/2;++y)\n        for(int x=1-N/2;x<=+N/2;++x)\n            ret+=kernel(id,float(x)-uv.x)*kernel(id,float(y)-uv.y)*Texture(t,c+d*vec2(x,y));\n#endif\nreturn ret;\n}\n\nint label(int id,ivec2 xy)\n{\n    int x=xy.x,y=xy.y;\n    if(x<0||x==3||x>=7) return 0;\n    if(y<0||y>=5) return 0;\n    if(x>3) x-=1;\n    uint s=uint(y*6+x)&31u;\n    switch(id)\n    {\n        case  0: return int((0x3D3FF3FDu>>s)&1u);\n        case  1: return int((0x3945147Fu>>s)&1u);\n        case  2: return int((0x2DB7F965u>>s)&1u);\n        case  3: return int((0x25D7F965u>>s)&1u);\n        case  4: return int((0x2EA7A923u>>s)&1u);\n        case  5: return int((0x2DFFFF6Du>>s)&1u);\n        case  6: return int((0x2BB7B963u>>s)&1u);\n        case  7: return int((0x29A79867u>>s)&1u);\n        case  8: return int((0x3D37FB7Du>>s)&1u);\n        case  9: return int((0x3E27AB3Bu>>s)&1u);\n        case 10: return int((0x39279A7Fu>>s)&1u);\n        case 11: return int((0x3DB7FB7Du>>s)&1u);\n        case 12: return int((0x3EA7AB3Bu>>s)&1u);\n        case 13: return int((0x39A79A7Fu>>s)&1u);\n        case 14: return int((0x3DF7FF7Du>>s)&1u);\n    }\n    return 0;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float SCALE=8.0; // Pixels per texel.\n    ivec2 id=clamp(ivec2(float(NUM_FILTERS)*abs(iMouse.xy)/iResolution.xy),ivec2(0),ivec2(NUM_FILTERS-1));\n    ivec2 ps=clamp(ivec2(float(NUM_FILTERS)*fragCoord/iResolution.xy),ivec2(0),ivec2(NUM_FILTERS-1));\n    vec2 uv=fragCoord/(SCALE*vec2(textureSize(iChannel0,0)))+vec2(cos(iTime/128.0),sin(iTime/128.0));\n    vec3 col=vec3(0);\n    col=(fragCoord.x<iResolution.x/2.0?f(id.x,iChannel0,uv):f(id.y,iChannel0,uv)).xyz;\n    if(fragCoord.y<min(16.0,fragCoord.x)) col=mix(col,((ps.x&1)==0?0.5:1.0)*vec3(0.5,(ps.x==id.x?1.0:0.5),0.5),0.5);\n    if(fragCoord.x<min(16.0,fragCoord.y)) col=mix(col,((ps.y&1)==0?0.5:1.0)*vec3(0.5,(ps.y==id.y?1.0:0.5),0.5),0.5);\n    col=mix(col,vec3(0.2,0.7,0.2),float(label(id.x,ivec2(floor(0.25*(fragCoord-vec2(iResolution.x/2.0-44.0,iResolution.y-32.0)))))));\n    col=mix(col,vec3(0.2,0.7,0.2),float(label(id.y,ivec2(floor(0.25*(fragCoord-vec2(iResolution.x/2.0+16.0,iResolution.y-32.0)))))));\n#if SRGB\n    col=vec3(linear2srgb(col));\n#endif\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}