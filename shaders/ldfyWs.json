{
    "Shader": {
        "info": {
            "date": "1490292987",
            "description": "Playing around with PBR material code from https://learnopengl.com/#!PBR/Lighting on stream, then RUINED IT SO HARD YAS :)\n\nDiscontinuities4lyf3 <3",
            "flags": 32,
            "hasliked": 0,
            "id": "ldfyWs",
            "likes": 9,
            "name": "PBR Playground",
            "published": 3,
            "tags": [
                "fun",
                "material",
                "pbr"
            ],
            "usePreview": 0,
            "username": "yupferris",
            "viewed": 1888
        },
        "renderpass": [
            {
                "code": "// Dedicated to the public domain under CC0 1.0 Universal\n//  https://creativecommons.org/publicdomain/zero/1.0/legalcode\n\n#define saturate(x) (clamp((x), 0.0, 1.0))\n\nvec3 unitSquareToNGon(vec2 p, float n, float amount)\n{\n    float a = p.x * 2.0 - 1.0;\n    float b = p.y * 2.0 - 1.0;\n\n    float pi = 3.141592;\n\n    float r, theta;\n    if (a > -b)\n    {\n        if (a > b)\n        {\n            r = a;\n            theta = (pi / 4.0) * (b / a);\n        }\n        else\n        {\n            r = b;\n            theta = (pi / 4.0) * (2.0 - (a / b));\n        }\n    }\n    else\n    {\n        if (a < b)\n        {\n            r = -a;\n            theta = (pi / 4.0) * (4.0 + (b / a));\n        }\n        else\n        {\n            r = -b;\n            if (b != 0.0)\n            {\n                theta = (pi / 4.0) * (6.0 - (a / b));\n            }\n            else\n            {\n                theta = 0.0;\n            }\n        }\n    }\n\n    float circleRadius = r;\n\n    r *= mix(1.0, cos(pi / n) / cos(theta - (2.0 * pi / n) * floor((n * theta + pi) / (2.0 * pi))), amount);\n    // This is just so that the shape isn't aligned to an axis, which looks a bit nicer\n    theta += .6;\n\n    float u = r * cos(theta);\n    float v = r * sin(theta);\n    return vec3(u, v, circleRadius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 clean = texture(iChannel0, uv).xyz;\n    \n    vec3 acc = vec3(0.0);\n    int kernelSize = 30;\n    for (int y = 0; y < kernelSize; y++)\n    {\n        for (int x = 0; x < kernelSize; x++)\n        {\n            vec2 unitSquare = vec2(ivec2(x, y)) / vec2(ivec2(kernelSize - 1));\n            \n            vec2 nGon = unitSquareToNGon(unitSquare, 7.0, 1.0).xy * 20.0;\n            vec2 offset = nGon / iChannelResolution[0].xy;\n            acc += texture(iChannel0, uv + offset).xyz * (1.0 / float(kernelSize * kernelSize));\n        }\n    }\n    \n    acc = pow(acc + 0.01, vec3(3.3));\n    \n    vec3 outputColor = clean + acc;\n    vec3 tonemappedColor = outputColor / (outputColor + 1.0);\n    vec3 gammaCorrectedOutputColor = pow(tonemappedColor, vec3(1.0 / 2.2));\n\n    fragColor = vec4(gammaCorrectedOutputColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Dedicated to the public domain under CC0 1.0 Universal\n//  https://creativecommons.org/publicdomain/zero/1.0/legalcode\n\n// PBR material code from https://learnopengl.com/#!PBR/Lighting\n\n#define saturate(x) (clamp((x), 0.0, 1.0))\n\n// Noise by iq\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float ret = noise(x);\n    ret += noise(x * 2.0) / 2.0;\n    ret += noise(x * 4.0) / 4.0;\n    ret += noise(x * 8.0) / 8.0;\n    ret += noise(x * 16.0) / 16.0;\n    return ret;\n}\n\nvec3 rotateX(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x, x.y * c - x.z * s, x.z * c + x.y * s);\n}\n\nvec3 rotateY(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.z * s, x.y, x.z * c + x.x * s);\n}\n\nvec3 rotateZ(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.y * s, x.y * c + x.x * s, x.z);\n}\n\nstruct Material\n{\n\tvec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n};\n    \nMaterial mixMaterials(Material a, Material b, float x)\n{\n    return Material(\n        mix(a.albedo, b.albedo, x),\n        mix(a.metallic, b.metallic, x),\n        mix(a.roughness, b.roughness, x),\n    \tmix(a.emissive, b.emissive, x));\n}\n    \nstruct SceneResult\n{\n    float d;\n    Material material;\n};\n\nfloat sphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p - pos) - radius;\n}\n\nSceneResult f(vec3 p)\n{\n    p.x += iTime * 3.0;\n    \n    vec3 op = p;\n    \n    float gridSideCount = 7.0;\n    \n    float range = 4.0;\n    float halfRange = range / 2.0;\n    p = vec3(\n        fract((p.x + halfRange) / range) * range - halfRange,\n    \tfract((p.y + halfRange) / range) * range - halfRange,\n    \tp.z);\n    \n    float indexX = float(int((op.x - -gridSideCount * halfRange) / range));\n    float indexY = float(int((op.y - -gridSideCount * halfRange) / range));\n    \n    float boundsX = abs(op.x) - gridSideCount * halfRange;\n    float boundsY = abs(op.y) - gridSideCount * halfRange;\n    float bounds = max(boundsX, boundsY);\n    \n    float rad = 1.5 + 0.4 * (sin(iTime * 1.2 + fbm(vec3(indexX, indexY, 0.0)) * 6.0) * 0.5 + 0.5);\n    float d = /*max(*/sphere(p, vec3(0.0, 0.0, sin(iTime * 0.899 + fbm(vec3(indexX, indexY, 100.0) * 0.4)) * 8.0), rad);//, bounds);\n\n    Material material1 = Material(\n        vec3(1.0),\n        1.0,\n        0.1,\n    \tpow(sin(op.y + iTime * 3.9) * 0.5 + 0.5, 120.0) * vec3(0.1, 0.8, 1.0) * 15.0);\n    Material material2 = Material(\n        vec3(0.01),\n        0.0,\n        1.0,\n    \tvec3(1.0, 0.1, 0.02) * 10.0 * pow(saturate(fbm(p * 2.0)), 2.0));\n    Material material = mixMaterials(material1, material2, saturate(pow(saturate(fbm(op) - 0.3), 40.0)));\n    d += fbm(op) * (0.1 + material.roughness * 0.01);\n    \n    float cutoutPhase = op.x + op.y + op.z;\n    float cutout = sin(cutoutPhase) * 0.5 + 0.5;\n    \n\n    return SceneResult(d, material);\n}\n\n// PBR material code from https://learnopengl.com/#!PBR/Lighting\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    float PI = 3.14159265;\n    denom = PI * denom * denom;\n\t\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 lightItUp(vec3 hitPos, vec3 eyeDir, vec3 normal, Material material)\n{\n    const int numLights = 4;\n    vec3 lightPositions[numLights] = vec3[numLights](\n        vec3(-10.0, 10.0, 10.0),\n        vec3(sin(iTime) * 10.0, 10.0, cos(iTime) * 10.0),\n        vec3(16.0, -10.0, 7.0),\n        vec3(-7.0, -15.0, 20.0)\n    );\n    vec3 lightColors[numLights] = vec3[numLights](\n        vec3(1.0),\n        vec3(1.0, 0.2, 0.02),\n        vec3(0.1, 0.8, 1.0),\n        vec3(1.0)\n    );\n    \n    vec3 ret = material.emissive;\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, material.albedo, material.metallic);\n    \n    for (int i = 0; i < numLights; i++)\n    {\n        vec3 lightVec = normalize(lightPositions[i] - hitPos);\n        vec3 reflectionVec = reflect(eyeDir, normal);\n     \n        // calculate per-light radiance\n        vec3 N = normal;\n        vec3 WorldPos = hitPos;\n        vec3 V = -eyeDir;\n        vec3 L = lightVec;\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance     = lightColors[i];// * attenuation;        \n        \n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, material.roughness);        \n        float G   = GeometrySmith(N, V, L, material.roughness);      \n        vec3 F    = vec3(fresnelSchlick(max(dot(H, V), 0.0), F0));\n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - material.metallic;\t  \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n        vec3 brdf = nominator / denominator;\n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);      \n        float PI = 3.14159265;\n        vec3 lightContribution = (kD * material.albedo / PI + brdf) * radiance * NdotL; \n\n        ret += lightContribution;\n    }\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float fovDegrees = 40.0;\n    float fovRadians = fovDegrees / 180.0 * 3.14159265;\n    float fovTan = tan(fovRadians / 2.0);\n    vec3 eyeDir = normalize(vec3(uv * fovTan, -1.0));\n\n    float camRotX = (iMouse.y / iResolution.y * 2.0 - 1.0) * 3.14159265;\n    float camRotY = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14159265;\n    float camRotZ = 0.0;\n    \n    eyeDir = rotateZ(eyeDir, camRotZ);\n    eyeDir = rotateX(eyeDir, camRotX);\n    eyeDir = rotateY(eyeDir, camRotY);\n    \n    vec3 eyePos = vec3(0.0, 0.0, 50.0);\n    eyePos = rotateX(eyePos, camRotX);\n    eyePos = rotateY(eyePos, camRotY);\n    \n    vec3 color = vec3(pow(sin(saturate(fbm(eyeDir * 12.0 + iTime * 0.2) - 0.4) * 6.0 * 3.14159265) * 0.5 + 0.5, 12.0)) * vec3(0.02);\n    \n    const float t_min = 0.001;\n    const float t_max = 100.0;\n    float omega = 1.2;\n    float t = t_min;\n    float candidate_error = 1.0 / 0.0;\n    float candidate_t = t_min;\n    float previousRadius = 0.0;\n    float stepLength = 0.0;\n    float pixelRadius = 0.001;\n    const int maxIterations = 90;\n    for (int i = 0; i < maxIterations; i++)\n    {\n        float signedRadius = f(eyePos + eyeDir * t).d;\n        float radius = abs(signedRadius);\n\n        bool sorFail = omega > 1.0 && (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.0;\n        } else {\n            stepLength = signedRadius * omega;\n        }\n\n        previousRadius = radius;\n\n        float error = radius / t;\n\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n\n        if (!sorFail && error < pixelRadius || t > t_max)\n            break;\n\n        t += stepLength;\n    }\n\n    bool hit = t <= t_max && candidate_error <= pixelRadius;\n    if (hit)\n    {\n        vec3 hitPos = eyePos + eyeDir * candidate_t;\n        SceneResult intersection = f(hitPos);\n\n        const int discontinuityReductionIterations = 3;\n        const float discontinuityReductionEpsilon = 0.1;\n        for (int i = 0; i < discontinuityReductionIterations; i++)\n        {\n            hitPos += eyeDir * (intersection.d - discontinuityReductionEpsilon);\n            intersection = f(hitPos);\n        }\n\n        float normalEpsilon = 0.001;\n        vec3 normal = normalize(vec3(f(hitPos + vec3(normalEpsilon, 0, 0)).d - f(hitPos - vec3(normalEpsilon, 0, 0)).d,\n                                     f(hitPos + vec3(0, normalEpsilon, 0)).d - f(hitPos - vec3(0, normalEpsilon, 0)).d,\n                                     f(hitPos + vec3(0, 0, normalEpsilon)).d - f(hitPos - vec3(0, 0, normalEpsilon)).d));\n        \n        vec3 litSurfaceColor = lightItUp(hitPos, eyeDir, normal, intersection.material);\n        float hitDistance = distance(hitPos, eyePos);\n        float fogAmount = 1.0 - pow(1.0 - hitDistance / t_max, 2.0);\n        color = mix(litSurfaceColor, color, fogAmount);\n    }\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}