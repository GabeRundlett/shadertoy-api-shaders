{
    "Shader": {
        "info": {
            "date": "1600024983",
            "description": "live coded for the In√©rcia Demoparty Shader Royale test stream\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WljBWc",
            "likes": 15,
            "name": "Chaotic Orchard",
            "published": 3,
            "tags": [
                "livecode"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(p.x,p.y));\n}\n\nvec3 tree(vec3 p, float t) {\n    for (int i = 0; i < 8; i++) {\n    //p.y -= 1.;\n    p.x = abs(p.x);\n    vec2 roter = normalize(vec2(.4,1.));\n    p.xz -= roter*max(dot(p.xz,roter),0.)*2.;\n    p.z += .25;\n        p = erot(p,vec3(0,0,1),iTime + t);\n    }\n    return p;\n}\n\nfloat pillar;\nfloat scene(vec3 p) {\n    vec3 p2 = vec3(asin(sin(p.xy)*.5),p.z);\n    vec3 p3 = vec3(p.xy,p.z-1.25);\n    vec2 id = floor(p.xy/4.)*4.+2.;\n    p3.xy -= id;\n    p3 = erot(p3, vec3(0,0,1),id.x);\n    p3=tree(p3, id.x+id.y);\n    vec2 crds = vec2(length(p3.xy),p3.z);\n    pillar = box(crds, vec2(.02,.25))-.01;\n    float ball = length(p2)-1.;\n    return min(pillar,ball);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(.001);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float t = cos(iTime)*.3;\n    float yrt = sin(t)*.2+.5;\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-8,0,0);\n    \n    init = erot(init,vec3(0,1,0), yrt);\n    cam = erot(cam ,vec3(0,1,0), yrt);\n    init = erot(init,vec3(0,0,1), t);\n    cam = erot(cam, vec3(0,0,1), t);\n    init.x += asin(sin(iTime*.1))/.05;\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n    }\n    bool pl = pillar == dist;\n    float fog = smoothstep(40.,10.,distance(p,init));\n    vec3 n =    norm(p);\n    vec3 r = reflect(cam,n);\n#define AO(p, d, s) smoothstep(-s,s,scene(p+d*s))\n    float ao = AO(p,n,.1)*AO(p,n,.3)*AO(p,n,.5);\n    float ro = AO(p,r,.1)*AO(p,r,.3);\n    \n    vec3 ldir = normalize(vec3(1));\n    \n    vec3 p2 = p+ldir*.1;\n    float mdd = 100.;\n    for (int i = 0; i < 50; i++) {\n        float dd = scene(p2);\n        mdd = min(abs(dd),mdd);\n        p2 += dd*ldir;\n    }\n    float diff = length(sin(n*2.)*.4+.6)/sqrt(3.);\n    float spec = length(sin(r*5.)*.4+.6)/sqrt(3.);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float specpow = .2;\n    vec3 diffcol = vec3(.05,.05,.05);\n    if (pl) {\n        diffcol = vec3(.7,.05,.05);\n        specpow = 1.5;\n        ao *= smoothstep(-1.,1.,dot(ldir,n));\n        ro *= smoothstep(-1.,0.,dot(ldir,n));\n    } else {\n        ao *= smoothstep(0.,0.1,mdd);\n    }\n    \n    vec3 col = diffcol*diff*ao + pow(spec,10.)*fres*specpow*ro;\n    vec3 fogcol = vec3(.3,.4,.6);\n    fragColor.xyz = sqrt(hit ? mix(fogcol,col,fog) : fogcol);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}