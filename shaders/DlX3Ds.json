{
    "Shader": {
        "info": {
            "date": "1676011329",
            "description": "Stylistically inspired by Ben Griffin's KNOTS Zoo project: https://github.com/MrBenGriffin/Knot\nSimulation inspired by Wave Function Collapse: https://github.com/mxgmn/WaveFunctionCollapse\n\n*mouse to reset tiles*\n*WASD/QE/RF to fly*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "DlX3Ds",
            "likes": 48,
            "name": "Celtic Knots Zoo: Wood Carving",
            "published": 3,
            "tags": [
                "raymarch",
                "dof",
                "depthoffield",
                "wood",
                "carve",
                "multipass",
                "carving",
                "wfc",
                "wavefunctioncollapse"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 553
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiement with my interpretation of Wave Function Collapse, this time again\n//  with a 3D raymarched renderer.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  Stylistically this is inspired by Ben Griffin's KNOTS Zoo project, especially \"Knots\n//  Zoo Holy\":\n//\n//      https://github.com/MrBenGriffin/Knot\n//      https://fontlibrary.org/en/font/knots\n//\n//  Here are my previous WFC shaders:\n//\n//      Simple Wave Function Collapse   https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC               https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC           https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                   https://shadertoy.com/view/ds2XzD\n//      Superposition Weave WFC         https://shadertoy.com/view/Ds2XRV\n//      Celtic Knotwork WFC             https://shadertoy.com/view/mtfGWX\n//\n//  But this one shares the most code and concepts from my other raymarched WFC shader:\n//\n//      Raymarched Circuit Board WFC    https://shadertoy.com/view/mdjSDz\n//\n//  However there have been a lot of changes:\n//\n//    * Brought tileset over from Celtic Knotwork WFC\n//    * Adapted 2D SDF to 3D with chamfered extrusion\n//    * Added dragon heads/tails/wings and dots\n//    * Added extra logic to allow heads to connect to tails and nothing else\n//    * Merged superposition simulation (faster)\n//    * Rigged simulation and rendering for toroidal repeat at edges\n//    * Simulation resets not far from camera position\n//    * Removed multiple lights/shadows\n//    * Added noise layers for wood grain and gouged surfaces\n//    * Non-repeating wood texture as a base color\n//    * New attract mode camera motion, including roll\n//    \n//  This shader was originally released with HERE_BE_DRAGONS disabled in the Common tab,\n//  because when I tested it on a PC it took almost a minute to compile. But iq saved the\n//  day by pointing out I had missed de-unrolling the grad loop (see comments for more \n//  details).\n//\n//  If you've been following my other shaders, you might wonder if I tried \"progressive\n//  ray marching\" here. I did, and I left some commented out code if you want to see what\n//  I tried. It does speed up rendering, but only very slightly, I think because the ray\n//  marcher converges in very few iterations anyway.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//  Buffer C does the main scene render\n//  Image applies blur effect and renders lights on top\n//\n// ---------------------------------------------------------------------------------------\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  7;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState state = fxGetState();\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\tvec3 centerRayDir = fxCalcRay(iResolution.xy * vec2(.5, .7), iResolution, cameraFwd, cameraUp, cameraLeft);\n    float centerDepth = -cameraPos.y / centerRayDir.y;\n\n    vec4 pixel = texelFetch(iChannel0, ivec2(u), 0);\n    float depth = pixel.w;\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a depth of field effect.\n    w = (abs(depth-centerDepth)) * iResolution.y / 500.;\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n        O = pixel;\n    }\n    \n    // render lights after blur\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 lightPos = calcLightPos(iTime, iResolution, cameraPos, cameraFwd);\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    lightPos = (w2c * vec4(lightPos,1.0)).xyz;\n    lightPos.xy = lightPos.xy / lightPos.z;\n    \n    float d = distance(lightPos.xy, (u - .5*iResolution.xy) / iResolution.y);\n    O.xyz = max(O.xyz, smoothstep(.04, .02, d));\n    \n    O.xyz = pow(ACESFilm(O.xyz), vec3(1./2.2));\n    O.a = 1.;\n    \n    //O = vec4(float(countBits(floatBitsToUint(texelFetch(iChannel2, ivec2(u), 0))))) *.1; // debug draw sim buffer\n    //u = iResolution.xy - u;\n    //O = smoothstep(0., .01, vec4(sdEndFoot(8. * u / iResolution.y))); // debug draw one tile\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Turn this on for all the cool dragon heads and stuff, but\n// if you have a PC it may take a minute (or more?) to compile.\n#define HERE_BE_DRAGONS 1\n\n// This makes all the circles, turn this off I guess if it's\n// running really badly for you or if you like a smoother look.\n#define HERE_BE_DOTS 1 \n\n// CONSTANTS\n\nconst float MAX_Y = 0.; \nconst float MAX_T = 2.2;\nconst float SDF_EPSILON_R = 0.002;\nfloat SDF_EPSILON = SDF_EPSILON_R;\nconst int MAX_MARCH_ITER = 8;\n\nconst uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\n// UTILITY\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\nvec2 rot90(vec2 v) { return v.yx * vec2(1, -1); }\n\nconst float PI = 3.141592653589793;\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_R 82\n#define KEY_F 70\n#define KEY_Q 81\n#define KEY_E 69\n\n// counts the number of bits set to 1 in a uint\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\n// counts the number of bits set to 1 in a uvec4\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\n// computes the highest set bit index in a uint\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// STATE MANAGEMENT\n\nstruct fxState\n{\n    vec3 camPos;\n    float camDir;\n    float camRoll;\n    float resolution;\n    bool attract;\n    float attractTime;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.attract = data0.y != 0.;\n    state.camRoll = data0.z;\n    state.attractTime = data0.w;\n    state.camPos = data1.xyz;\n    state.camDir = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.attract ? 1. : 0., state.camRoll, state.attractTime);\n    }\n    \n    return vec4(state.camPos, state.camDir);\n}\n\n// TILE TYPE ENUM\n\nconst int EMPTY = 0;\nconst int I_ST_ST = 1;\nconst int I_ST_CR = 2;\nconst int I_CR_CR = 3;\nconst int END_CR = 4;\nconst int END_WING = 5;\nconst int CORNER_ST_ST = 6;\nconst int CORNER_CR_ST = 7;\nconst int CORNER_ST_CR = 8;\nconst int CORNER_CR_CR = 9;\nconst int T_ST_CR_ST = 10;\n#if HERE_BE_DRAGONS\nconst int I_ST_DRH = 11;\nconst int I_ST_DRT = 12;\nconst int CORNER_CR_DRH = 13;\nconst int CORNER_ST_DRT = 14;\nconst int NUM_TILES = 15;\n#else\nconst int NUM_TILES = 11;\n#endif\n\n// SIGNED DISTANCE FIELDS (2D)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n#if HERE_BE_DRAGONS\n\n// https://iquilezles.org/articles/distfunctions2d/\n#define POLY_FN(N) \\\nfloat sdPolygon( in vec2[N] v, vec2 p, int iFrame ) \\\n{ \\\n    float d = dot(p-v[0],p-v[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=N-1; DONT_UNROLL && i<N; j=i, i++ ) \\\n    { \\\n        vec2 e = v[j] - v[i]; \\\n        vec2 w =    p - v[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \\\n        if( all(c) || all(not(c)) ) s*=-1.0; \\\n    } \\\n    return s*sqrt(d); \\\n}\n\nbool inBBox(vec2 mins, vec2 maxs, vec2 p)\n{\n    return clamp(p, mins, maxs) == p;\n}\n\nconst int NUM_WING_POINTS = 24;\nconst vec2 WING_MIN = vec2(3.9,4.4);\nconst vec2 WING_MAX = vec2(6.6, 8);\nconst vec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(4.8, 4.7), vec2(5.3, 4.6), vec2(6, 6.1), vec2(6.3, 7), vec2(6.3, 7.5),\n    vec2(6.1, 7.7), vec2(5.85, 6.7), vec2(5.5, 6.1), vec2(5.65, 6.7), vec2(5.6, 7.5),\n    vec2(5.3, 7.8), vec2(5.4, 7.3), vec2(5.3, 6.8), vec2(5, 6.3),\n    vec2(5, 6.8), vec2(4.8, 7.4), vec2(4.5, 7.6),\n    vec2(4.65, 7.2), vec2(4.7, 6.6), vec2(4.6, 6.3), vec2(4.2, 5.9),\n    vec2(4.7, 6), vec2(5, 5.8), vec2(5, 5.3)\n);\n\nPOLY_FN(NUM_WING_POINTS)\n\nconst int NUM_HEAD_S_POINTS = 6;\nconst vec2 HEAD_S_MIN = vec2(4.7, 3.6);\nconst vec2 HEAD_S_MAX = vec2(7.7, 8.2);\nconst vec2 HEAD_S_POINTS[NUM_HEAD_S_POINTS] = vec2[](\n    vec2(7, 4.5), vec2(6.3, 4.), vec2(5.7, 3.9),\n    vec2(5, 4.1), vec2(5, 8.2), vec2(7, 8.2)\n);\n\nPOLY_FN(NUM_HEAD_S_POINTS)\n\nconst int NUM_HEAD_POINTS = 25;\nconst vec2 HEAD_MIN = vec2(3.3, -.05);\nconst vec2 HEAD_MAX = vec2(7.7, 4);\nconst vec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(4.45, -.05), vec2(6.0, 1.4), vec2(6.35, 1.8), vec2(6.4, 2.4), vec2(5.9, 2.9),\n    vec2(5.35, 2.8), vec2(5.55, 2.2), vec2(5.55, 1.9), vec2(5.45, 1.65), vec2(5., 1.2),\n    vec2(4.75, 1.45), vec2(5.1, 1.8), vec2(5.05, 2.2), vec2(4.9, 2.8), vec2(4.3, 3.7),\n    vec2(5.5, 3.4), vec2(6.5, 3.5), vec2(7, 3.8), vec2(6.97, 3.55), vec2(6.99, 3.15),\n    vec2(7.4, 2.5), vec2(7.5, 2.), vec2(7.2, 1.5), vec2(5.7, .7), vec2(4.95, -.05)\n);\n\nPOLY_FN(NUM_HEAD_POINTS)\n\nconst int NUM_TAIL_POINTS = 26;\nconst vec2 TAIL_MIN = vec2(3.8, 2.4);\nconst vec2 TAIL_MAX = vec2(7.3, 8.2);\nconst vec2 TAIL_POINTS[NUM_TAIL_POINTS] = vec2[](\n    vec2(7, 5), vec2(6.8, 3.7), vec2(6.2, 3.1), vec2(5.7, 2.9), vec2(4.9, 3.0),\n    vec2(4.2, 3.5), vec2(4, 4.2), vec2(4, 4.8), vec2(4.3, 5.2), vec2(4.9, 5.5),\n    vec2(5.1, 5.4), vec2(5.2, 5.25), vec2(5.3, 5.0), vec2(5.35, 4.7), vec2(5.25, 4.5),\n    vec2(5.15, 4.9), vec2(4.95, 5.1), vec2(4.7, 5.), vec2(4.7, 4.3), vec2(4.9, 4.),\n    vec2(5.3, 3.95), vec2(5.45, 4.05), vec2(5.7, 4.4), vec2(5.7, 5), vec2(4.95, 8.2),\n    vec2(7, 8.2)\n);\n\nPOLY_FN(NUM_TAIL_POINTS)\n\nconst int NUM_EYE_POINTS = 8;\nconst vec2 EYE_MIN = vec2(6.5, 1.4);\nconst vec2 EYE_MAX = vec2(7.4, 2.8);\nconst vec2 EYE_POINTS[NUM_EYE_POINTS] = vec2[](\n    vec2(7., 2.5), vec2(7.2, 2.), vec2(7.1, 1.8), vec2(6.9, 1.7),\n    vec2(6.7, 1.7), vec2(6.6, 1.85), vec2(6.7, 2.1), vec2(6.85, 2.2)\n);\n\nPOLY_FN(NUM_EYE_POINTS)\n\nconst int NUM_NOSE_POINTS = 12;\nconst vec2 NOSE_MIN = vec2(2.6, -.3);\nconst vec2 NOSE_MAX = vec2(5.8, 2.3);\nconst vec2 NOSE_POINTS[NUM_NOSE_POINTS] = vec2[](\n    vec2(2.95, -.05), vec2(4.5, 1.5), vec2(4.6, 1.7), vec2(4.75, 2.), vec2(4.9, 2.05), vec2(5.2, 2),\n    vec2(5.5, 1.5), vec2(5.6, 1.2), vec2(5.4, .7), vec2(5.3, 1.2), vec2(5, 1.5), vec2(3.45, -.05)\n);\n\nPOLY_FN(NUM_NOSE_POINTS)\n\nconst int NUM_TOOTH_POINTS = 4;\nconst vec2 TOOTH_MIN = vec2(4.4, .5);\nconst vec2 TOOTH_MAX = vec2(5.5, 1.4);\nconst vec2 TOOTH_POINTS[NUM_TOOTH_POINTS] = vec2[](\n    vec2(4.7, 0.9), vec2(4.9, 1.1), vec2(5.2, 0.8), vec2(4.95, 0.8)\n);\n\nPOLY_FN(NUM_TOOTH_POINTS)\n\nconst int NUM_TAIL2_POINTS = 30;\nconst vec2 TAIL2_MIN = vec2(0, .7);\nconst vec2 TAIL2_MAX = vec2(8.3, 5.8);\nconst vec2 TAIL2_POINTS[NUM_TAIL2_POINTS] = vec2[](\n    vec2(8.1, 3), vec2(8.1, 1), vec2(3, 1), vec2(2, 1.1), vec2(1.3, 1.4),\n    vec2(.8, 2.2), vec2(.6, 4), vec2(1, 5), vec2(1.7, 5.5), vec2(2.5, 5.5),\n    vec2(3.6, 5.1), vec2(3.9, 4.8), vec2(4.3, 4.1), vec2(4.2, 3.5), vec2(3.9, 3.1),\n    vec2(3.2, 3), vec2(2.6, 3.3), vec2(2.5, 3.8), vec2(2.8, 4.3), vec2(3.1, 4.3),\n    vec2(3.3, 4), vec2(3, 3.6), vec2(3.3, 3.5), vec2(3.7, 3.8), vec2(3.5, 4.3),\n    vec2(3, 4.6), vec2(2, 4.4), vec2(1.9, 3.6), vec2(2, 2.8), vec2(3, 2.4)\n);\n\nPOLY_FN(NUM_TAIL2_POINTS)\n#endif // HERE_BE_DRAGONS\n\n// cell distance functions\n#if HERE_BE_DOTS\n#define DOTR(X, Y, R) dist = max(dist, R - distance(p, vec2(X, Y)))\n#define DOT(X, Y) DOTR(X, Y, .6)\n#else\n#define DOTR(X, Y, R)\n#define DOT(X, Y)\n#endif\n\nfloat sdIStSt(vec2 p)\n{\n    float dist = min(abs(p.x - 2.), abs(p.x - 6.)) - 1.;\n    \n    DOT(2, .7); DOT(2, 2.); DOT(2, 3.3); DOT(2, 4.7); DOT(2, 6.); DOT(2, 7.3);\n    DOT(6, .7); DOT(6, 2.); DOT(6, 3.3); DOT(6, 4.7); DOT(6, 6.); DOT(6, 7.3);\n    \n    return dist;\n}\n\nconst float ARC_ANGLE = PI / 8.;\nconst vec2 ARC_SC = vec2(sin(ARC_ANGLE), cos(ARC_ANGLE));\n\nfloat sdCross(vec2 p)\n{\n    float dist = sdArc(rotate(5. * PI / 8.) * (p - vec2(4, 2.85)), ARC_SC, 2., 1.);\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.37)), vec2(.35, 1)));\n    return dist;\n}\n\nfloat sdIStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(6, 7), vec2(1, 4)));\n    dist = min(dist, sdCross(p));\n    \n    DOT(4.6, .6); DOT(5.7, 1.9); DOT(6, 3.35); DOT(6, 4.7); DOT(6, 6); DOT(6, 7.35);\n    DOT(2, 7.4); DOT(2, 6); DOT(2, 4.6); DOT(2, 3.2); DOT(2.4, 1.8);\n    \n    return dist;\n}\n\nfloat sdICrCr(vec2 p)\n{\n    const float BIG_ARC_ANGLE = 2. * PI / 8.;\n    const vec2 BIG_ARC_SC = vec2(sin(BIG_ARC_ANGLE), cos(BIG_ARC_ANGLE));\n    float dist = sdArc(rotate(4. * PI / 8.) * (p - vec2(1.65, 4)), BIG_ARC_SC, 4.5, 1.);\n    dist = min(dist, sdArc(rotate(-4. * PI / 8.) * (p - vec2(6.35, 4)), BIG_ARC_SC, 4.5, 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 1.6)));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1, 1.6)));\n\n    DOT(4.6, .6); DOT(5.7, 1.9); DOT(6, 3.4); DOT(6, 4.9); DOT(5.6, 6.3);\n    DOT(3.3, 7.3); DOT(2.4, 6); DOT(1.9, 4.7); DOT(1.9, 3.2); DOT(2.4, 1.8);\n\n    return dist;\n}\n\nfloat sdEndCross(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 4), vec2(1, 1.2));\n    dist = min(dist, sdBox(p - vec2(6, 4), vec2(1, 1.2)));\n    dist = min(dist, sdBox(p - vec2(4, 6), vec2(3, 1)));\n    dist = min(dist, sdCross(p));\n    \n    DOT(2.4, 1.8); DOT(2, 3.2); DOT(2, 4.6); DOT(2, 6); DOT(3.3, 6); DOT(4.7, 6);\n    DOT(6, 6); DOT(6, 4.6); DOT(6, 3.2); DOT(5.8, 1.8); DOT(4.7, .7);\n\n    return dist;\n}\n\nfloat sdEndWing(vec2 p, int iFrame)\n{\n    float dist = 1e6;\n#if HERE_BE_DRAGONS\n    vec2 wp1 = rotate(-.4) * p - vec2(-.5, -2.1);\n    if (inBBox(WING_MIN, WING_MAX, wp1))\n        dist = min(dist, sdPolygon(WING_POINTS, wp1, iFrame));\n    dist = max(dist, -sdBox(rotate(-.3) * (p - vec2(3, 4.5)), vec2(1, .5)));\n#endif // HERE_BE_DRAGONS\n    dist = min(dist, sdBox(p - vec2(2, 1), vec2(1, 1.5)));\n    dist = min(dist, sdBox(p - vec2(6, 1), vec2(1, 1.5)));\n    const float a = PI / 2.;\n    const vec2 sc = vec2(sin(a), cos(a));\n    dist = min(dist, sdArc((p - vec2(4, 2)), sc, 2., 1.));\n#if HERE_BE_DRAGONS\n    dist = max(dist, .7 - length((p - vec2(5, 4.7)) * vec2(1, .7)));\n    vec2 wp2 = p - vec2(-.2, -.5);\n    if (inBBox(WING_MIN, WING_MAX, wp2))\n        dist = min(dist, sdPolygon(WING_POINTS, wp2, iFrame));\n#else\n    DOT(4.8, 4.1);\n#endif // HERE_BE_DRAGONS\n\n    DOT(6, .65); DOT(6, 1.95); DOT(5.8, 3.25); DOT(3.45, 4.1); DOT(2.4, 3.25); DOT(2, 1.95); DOT(2, .65);\n    \n    return dist;\n}\n\nfloat sdCornerStSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(5, 2), vec2(4, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 6.6), vec2(1, 1.6)));\n    dist = min(dist, sdBox(p - vec2(6.6, 6), vec2(1.6, 1)));\n    \n    DOT(2, 7.3); DOT(2, 5.9); DOT(2, 4.6); DOT(2, 3.3); DOT(2, 2); DOT(3.3, 2);\n    DOT(4.6, 2); DOT(5.9, 2); DOT(7.3, 2); DOT(7.3, 6); DOT(6, 6); DOT(6, 7.3);\n    \n    return dist;\n}\n\nfloat sdCornerCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(3.9, 2), vec2(1.2, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4., 0.)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.85, 1.32)), vec2(.25, 1)));\n\n    DOT(7.4, 4.6); DOT(6.2, 5.85); DOT(6, 7.35); DOT(2, 7.4); DOT(2, 6.1);\n    DOT(2, 4.8); DOT(2, 3.4); DOT(2, 2); DOT(3.4, 2); DOT(4.8, 2); DOT(6.2, 2.4);\n\n    return dist;\n}\n\nfloat sdCornerStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(5, 2), vec2(4, 1));\n    dist = min(dist, sdBox(p - vec2(2, 4), vec2(1, 1.2)));\n    dist = min(dist, sdBox(p - vec2(8, 6), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2.0, 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.35, 1)));\n\n    DOT(5.8, 6.3); DOT(7.3, 6); DOT(7.3, 2); DOT(6, 2); DOT(4.6, 2); DOT(3.3, 2);\n    DOT(2, 2); DOT(2, 3.4); DOT(2, 4.8); DOT(2.3, 6.2); DOT(3.3, 7.3);\n\n    return dist;\n}\n\nfloat sdCornerCrCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(3, 2), vec2(2, 1));\n    dist = min(dist, sdBox(p - vec2(2, 3), vec2(1, 2)));\n\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p1 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1.5, 2.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1, 2.75)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.67, 5.15)), vec2(.25, .99)));\n\n    DOT(7.3, 4.7); DOT(6, 6); DOT(6, 2.2); DOT(4.6, 2); DOT(3.3, 2); DOT(2, 2);\n    DOT(2, 2); DOT(2, 3.3); DOT(2, 4.6); DOT(2.2, 6.1); DOT(3.3, 7.3);\n\n    return dist;\n}\n\nfloat sdTStCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 6));\n    dist = min(dist, sdBox(p - vec2(6, .5), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(PI / 8.) * (p2 - vec2(1.35, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2.1)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.9, 1.3)), vec2(.25, .99)));\n\n    DOT(6, .8); DOT(6.3, 2.3); DOT(7.4, 4.7); DOT(6.3, 5.8); DOT(6, 7.3);\n    DOT(2, 7.3); DOT(2, 6); DOT(2, 4.7); DOT(2, 3.4); DOT(2, 2); DOT(2, 0.7);\n\n    return dist;\n}\n\n#if HERE_BE_DRAGONS\nfloat sdIStDrH(vec2 p, int iFrame)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(3.3, 0.87)), vec2(1, 1)));\n    if (inBBox(HEAD_S_MIN, HEAD_S_MAX, p))\n        dist = min(dist, sdPolygon(HEAD_S_POINTS, p, iFrame));\n    if (inBBox(HEAD_MIN, HEAD_MAX, p))\n        dist = min(dist, sdPolygon(HEAD_POINTS, p, iFrame));\n    if (inBBox(EYE_MIN, EYE_MAX, p))\n        dist = max(dist, -sdPolygon(EYE_POINTS, p, iFrame));\n    dist = min(dist, distance(p, vec2(6.9, 1.95)) - .05);\n\n    DOT(2, 7.3); DOT(2, 6); DOT(2, 4.7); DOT(2, 3.3); DOT(2.3, 1.9);\n    DOT(3.3, .8); DOT(6, 7.3); DOT(6, 6); DOTR(6, 4.7, .5);\n\n    return dist;\n}\n\nfloat sdIStDrT(vec2 p, int iFrame)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4.2));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 2.7)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.07)), vec2(.45, 1)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4.7, -1. + 0.12)), vec2(1, 1)));\n    if (inBBox(TAIL_MIN, TAIL_MAX, p))\n        dist = min(dist, sdPolygon(TAIL_POINTS, p, iFrame));\n    if (inBBox(NOSE_MIN, NOSE_MAX, p))\n        dist = min(dist, sdPolygon(NOSE_POINTS, p, iFrame));\n    if (inBBox(TOOTH_MIN, TOOTH_MAX, p))\n        dist = min(dist, sdPolygon(TOOTH_POINTS, p, iFrame));\n    dist = max(dist, .1 - distance(p * vec2(.7, 1), vec2(5. * .7, 1.8)));\n    \n    DOTR(4.6, 3.8, .2); DOTR(5.2, 3.5, .2); DOTR(6, 3.9, .3); DOTR(6.3, 4.9, .3); DOTR(6.2, 6, .4);\n    DOTR(6.1, 7.2, .5); DOT(2, 7.2); DOT(2, 5.8); DOT(2, 4.3); DOT(2, 2.8); DOT(2.5, 1.4);\n    \n    return dist;\n}\n\nfloat sdCornerCrDrH(vec2 p, int iFrame)\n{\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    const float ARC_ANGLE2 = PI / 2.9;\n    const vec2 ARC_SC2 = vec2(sin(ARC_ANGLE2), cos(ARC_ANGLE2));\n    float dist = sdArc(rotate(12.7 * PI / 8.) * (p1 - vec2(3.5, 3.5)), ARC_SC2, 2., 1.);\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n    if (inBBox(HEAD_MIN, HEAD_MAX, 8. - p))\n        dist = min(dist, sdPolygon(HEAD_POINTS, 8. - p, iFrame));\n    if (inBBox(EYE_MIN, EYE_MAX, 8. - p))\n        dist = max(dist, -sdPolygon(EYE_POINTS, 8. - p, iFrame));\n    dist = min(dist, distance(8. - p, vec2(6.9, 1.95)) - .05);\n    dist = min(dist, sdBox(rotate(PI / 3.8) * (p2 - vec2(6.9, 2.9)), vec2(1, 4.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.5, 5.3)), vec2(.55, .99)));\n\n    DOT(4.7, 7.2); DOT(5.9, 6); DOT(7.3, 4.7); DOT(6.2, 2.5);\n    DOT(4.9, 1.6); DOT(3.4, 1.8); DOT(2.5, 3);\n\n    return dist;\n}\n\nfloat sdCornerStDrT(vec2 p, int iFrame)\n{\n    float dist = sdBox(p - vec2(8, 6), vec2(1, 1));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.4, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.65, 1)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * ((8. - p) - vec2(4.7, -1. + 0.12)), vec2(1, 1)));\n    if (inBBox(NOSE_MIN, NOSE_MAX, 8. - p))\n        dist = min(dist, sdPolygon(NOSE_POINTS, 8. - p, iFrame));\n    if (inBBox(TOOTH_MIN, TOOTH_MAX, 8. - p))\n        dist = min(dist, sdPolygon(TOOTH_POINTS, 8. - p, iFrame));\n    dist = max(dist, .1 - distance((8. - p) * vec2(.7, 1), vec2(5. * .7, 1.8)));\n    if (inBBox(TAIL2_MIN, TAIL2_MAX, p))\n        dist = min(dist, sdPolygon(TAIL2_POINTS, p, iFrame));\n        \n    DOT(7.2, 6); DOT(5.6, 6.5); DOTR(7.3, 1.95, .55); DOTR(5.9, 1.9, .5); DOTR(4.7, 1.825, .425);\n    DOTR(3.5, 1.75, .35); DOTR(2.3, 1.7, .3); DOTR(1.5, 2.4, .3); DOTR(1.3, 3.4, .3);\n    DOTR(1.4, 4.2, .2); DOTR(1.9, 4.9, .2); DOTR(2.7, 5, .2); DOTR(3.5, 4.7, .2);\n    \n    return dist;\n}\n#endif // HERE_BE_DRAGONS\n\nfloat sdCell(vec2 p, int type, int iFrame)\n{\n    float dist = 1e6;\n    \n    if (type == I_ST_ST)            dist = sdIStSt(p);\n    else if (type == I_ST_CR)       dist = sdIStCr(p);\n    else if (type == I_CR_CR)       dist = sdICrCr(p);\n    else if (type == END_CR)        dist = sdEndCross(p);\n    else if (type == END_WING)      dist = sdEndWing(p, iFrame);\n    else if (type == CORNER_ST_ST)  dist = sdCornerStSt(p);\n    else if (type == CORNER_CR_ST)  dist = sdCornerCrSt(p);\n    else if (type == CORNER_ST_CR)  dist = sdCornerStCr(p);\n    else if (type == CORNER_CR_CR)  dist = sdCornerCrCr(p);\n    else if (type == T_ST_CR_ST)    dist = sdTStCrSt(p);\n#if HERE_BE_DRAGONS\n    else if (type == I_ST_DRT)      dist = sdIStDrH(p, iFrame);\n    else if (type == I_ST_DRH)      dist = sdIStDrT(p, iFrame);\n    else if (type == CORNER_CR_DRH) dist = sdCornerCrDrH(p, iFrame);\n    else if (type == CORNER_ST_DRT) dist = sdCornerStDrT(p, iFrame);\n#endif // HERE_BE_DRAGONS\n\n    return dist;\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\n// NOISE\n\n// From iq's Noise - gradient - 2D https://www.shadertoy.com/view/XdXGW8\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 1\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// From Voronoise by iq: https://www.shadertoy.com/view/Xd23Dh\nfloat voronoise(vec2 p)\n{\n\tfloat k = 1.0+63.0*pow(1.0,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g );\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-step(1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\n// wood grain top surface\nfloat topNoise(vec3 gp)\n{\n    return pow(noise(gp.xz * vec2(1000., 50000.)), 6.) * .05;\n}\n\n// gouged-out looking rougher bottom surface\nfloat bottomNoise(vec3 gp)\n{\n    float angle = voronoise(gp.xz*3000.) * PI * 2.;\n    gp.xz = rotate(angle) * gp.xz; // align according to voronoi region\n    return abs(fract(gp.x*20000.) - .5) * .01; // sawtooth pattern\n}\n\n// SIGNED DISTANCE FIELDS (3D)\n\nfloat extrudeCell(vec3 p, vec3 gp, float t, int type, int iFrame, out float d2d, vec2 res)\n{\n    float dp = p.y; // distance to plane\n    float df = sdCell(p.xz*8. + 4., type, iFrame); // distance to 2d SDF\n    df = smoothstep(-.05, .5, df) * .05;\n    \n    vec2 w = vec2(df, dp); // box distance\n    float de = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n    de = min(de, w.x * .5 + w.y); // with chamfered edges\n    \n    float tb = smoothstep(.01, .0, df - .02); // top or bottom noise\n\n    float tnl = 15./res.y; // noise t limits\n    float bnl = 12./res.y;\n    float tn = tb > 0. && t < tnl ? topNoise(gp) * smoothstep(tnl, tnl * .7, t) : 0.;\n    float bn = tb < 1. ? bottomNoise(gp) * smoothstep(bnl, bnl * .5, t) : 0.;\n\n    de += mix(bn, tn, tb);\n    \n    d2d = df;\n\n    return min(de, p.y + 0.05);\n}\n\nfloat sdCell(uvec4 value, vec3 p, vec3 gp, float t, bool forShadow, int iFrame, out float d2d, vec2 res)\n{\n    if (value != uvec4(0) &&\n        value != MAX_UVEC4 &&\n        countBits(value) == 1) // only render anything if we have collapsed to a single state\n    {\n        uint top;\n        int rot = emptyWords(value, top);\n        int type = log2int(top);\n\n        if (rot == 1) p.xz = rot90(p.xz);\n        if (rot == 2) p.xz = rot90(rot90(p.xz));\n        if (rot == 3) p.xz = rot90(rot90(rot90(p.xz)));\n\n        return extrudeCell(p, gp, t, type, iFrame, d2d, res);\n    }\n\n    return extrudeCell(p, gp, t, 0, iFrame, d2d, res);\n}\n\nfloat scene(sampler2D sampler, vec3 res, vec3 p, float t, bool forShadow, int iFrame, out float d2d)\n{\n    // compute addresses\n    vec2 addr = mod(p.xz + .5, vec2(res.x/res.y, 1)) * res.y;\n    vec2 subaddr = (fract(addr) - .5);\n    vec3 subp = vec3(subaddr.x, p.y * res.y, subaddr.y);\n    \n    // fetch underlying sim result\n    uvec4 value = floatBitsToUint(texelFetch(sampler, ivec2(addr), 0));\n    \n    // render\n    float minDist = sdCell(value, subp, p, t, forShadow, iFrame, d2d, res.xy);\n    minDist /= res.y;\n    \n    return minDist;\n}\n\n// RENDER\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 grad( sampler2D sampler, vec3 res, in vec3 pos, float t, int iFrame )\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        float d2d;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(sampler,res,pos+0.000001*e, t, false, iFrame, d2d);\n    }\n    return normalize(n);\n}\n\nvec3 rayMarch(sampler2D sampler, vec3 res, vec3 pos, vec3 dir, bool forShadow, inout float t, int iFrame, out float d2d)\n{\n    pos += t * dir; // passed-in t is warm-start (best guess)\n    \n    for (int i = 0; DONT_UNROLL && i < MAX_MARCH_ITER; ++i)\n    {\n        float d = scene(sampler, res, pos, t, forShadow, iFrame, d2d);\n        \n        if (abs(d) < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        t += d;\n        pos += dir * d;\n    }\n    \n    return pos;\n}\n\nvec3 calcLightPos(float time, vec3 res, vec3 cameraPos, vec3 cameraFwd)\n{\n    vec3 lightCenter = cameraPos; // light move along with camera\n    lightCenter.y = 10. / res.y;\n    lightCenter.xz += cameraFwd.xz * 30. / res.y;\n    return lightCenter;\n}\n\nvec4 pixelInternal(sampler2D sampler, sampler2D tex, float time, int iFrame, vec3 res, vec3 cameraPos, vec3 cameraFwd, vec3 rayDir, inout float t, out vec3 hitPos, out vec3 normal)\n{    \n    float d2d;\n    hitPos = rayMarch(sampler, res, cameraPos, rayDir, false, t, iFrame, d2d);\n    normal = grad(sampler, res, hitPos, t, iFrame);\n\n    // compute color\n    vec2 wood = hitPos.xz*.1*res.xy;\n    vec2 tile = trunc(wood);\n    vec3 wh = hash3(uvec3(tile, tile.x * tile.y));\n    wood = wood * .5 - .25 + .5 * wh.xy; // choose a random offset within the texture per tile, to relieve repetition\n    vec3 mColor = texture(tex, wood).rgb;\n    float mShiny = float(d2d < 0.02); // 2D distance to pattern determines shininess\n    \n    const float AMBIENT = .02;\n    vec3 color = mColor * AMBIENT;    \n\n    // apply light\n    vec3 lightPos = calcLightPos(time, res, cameraPos, cameraFwd);            \n    vec3 lightDir = normalize(lightPos - hitPos);\n                              \n    // diffuse\n    float dp = max(0., dot(normal, lightDir));\n    color += .1 * mColor * dp / (res.y * length2(lightPos - hitPos));\n\n    // specular\n    vec3 reflection = reflect(lightDir, normal);\n    dp = max(0., dot(cameraFwd, reflection));\n\n    color.rgb += .075 * mShiny * pow(abs(dp), 50.0) / (res.y * length2(lightPos - hitPos));\n    color *= 1000./res.y;\n    \n    // fade at distance\n    if (t >= MAX_T*.75)\n    {\n        vec3 sky = vec3(.01);\n        color = mix(color, sky, smoothstep(MAX_T*.75, MAX_T, t));\n    }\n    \n    return vec4(color.xyz, t);\n}\n\n#define pixel(A, B, C, D, E, F) pixelInternal(iChannel0, iChannel2, iTime, iFrame, iResolution, A, B, C, D, E, F)\n\nvoid fxCalcCamera(fxState state, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = state.camPos;\n    vec3 delta = vec3(0,-.013,.015);\n    delta.xz *= rotate(state.camDir);\n    cameraLookAt = cameraPos + delta;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    vec3 up = normalize(vec3(delta.z * state.camRoll, 1, -delta.x * state.camRoll));\n    cameraLeft = -normalize(cross(cameraFwd, up));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(0,0,0,\n         0,0,0,\n         0,0,0);\n         \nconst mat3 S_I_ST_ST =\n    mat3(0,1,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_I_ST_CR =\n    mat3(0,1,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_I_CR_CR =\n    mat3(0,2,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_CR =\n    mat3(0,0,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_WING =\n    mat3(0,0,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_CORNER_ST_ST =\n    mat3(0,1,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_CR =\n    mat3(0,2,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_CR =\n    mat3(0,2,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_T_ST_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,1,0);\n         \n#if HERE_BE_DRAGONS\nconst mat3 S_I_ST_DRH =\n    mat3(0,1,0,\n         0,2,0,\n         0,3,0);\n                  \nconst mat3 S_I_ST_DRT =\n    mat3(0,1,0,\n         0,3,0,\n         0,3,0);\n                  \nconst mat3 S_CORNER_CR_DRH =\n    mat3(0,3,0,\n         0,3,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_DRT =\n    mat3(0,3,0,\n         0,2,1,\n         0,0,0);\n#endif // HERE_BE_DRAGONS\n         \nmat3 shCell(int type)\n{\n    if (type == EMPTY)          return S_EMPTY;\n    if (type == I_ST_ST)        return S_I_ST_ST;\n    if (type == I_ST_CR)        return S_I_ST_CR;\n    if (type == I_CR_CR)        return S_I_CR_CR;\n    if (type == END_CR)         return S_END_CR;\n    if (type == END_WING)       return S_END_WING;\n    if (type == CORNER_ST_ST)   return S_CORNER_ST_ST;\n    if (type == CORNER_CR_ST)   return S_CORNER_CR_ST;\n    if (type == CORNER_ST_CR)   return S_CORNER_ST_CR;\n    if (type == CORNER_CR_CR)   return S_CORNER_CR_CR;\n    if (type == T_ST_CR_ST)     return S_T_ST_CR_ST;\n#if HERE_BE_DRAGONS\n    if (type == I_ST_DRH)       return S_I_ST_DRH;\n    if (type == I_ST_DRT)       return S_I_ST_DRT;\n    if (type == CORNER_CR_DRH)  return S_CORNER_CR_DRH;\n    if (type == CORNER_ST_DRT)  return S_CORNER_ST_DRT;\n#endif // HERE_BE_DRAGONS\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY)          return 0.;\n    if (type == I_ST_ST)        return .01;\n    if (type == I_ST_CR)        return .1;\n    if (type == I_CR_CR)        return 1.;\n    if (type == END_CR)         return .1;\n    if (type == END_WING)       return .05;\n    if (type == CORNER_ST_ST)   return .1;\n    if (type == CORNER_CR_ST)   return .1;\n    if (type == CORNER_ST_CR)   return .1;\n    if (type == CORNER_CR_CR)   return .1;\n    if (type == T_ST_CR_ST)     return .1;\n#if HERE_BE_DRAGONS\n    if (type == I_ST_DRH)       return .05;\n    if (type == I_ST_DRT)       return .05;\n    if (type == CORNER_CR_DRH)  return .05;\n    if (type == CORNER_ST_DRT)  return .05;\n#endif // HERE_BE_DRAGONS\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == I_ST_ST || type == I_ST_CR || type == I_CR_CR;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 2u;\n    \n    for (int i = 1; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            if (myShape[1][1] <= 1. || nShape[1][1] != myShape[1][1])\n            {\n                for (int d = 0; d < 4; ++d)\n                {\n                    if (tilesMatch(rotShape(myShape, d), nShape))\n                    {\n                        valid[(d + 4 - r) % 4] |= bit;\n                    }\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\n// compute the ivec2 offset for each direction\n// n.b. using the modulo negatives here to avoid issues with mods of negative numbers\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, iResolution.y - 1.);\n    /*if (d == 0)*/ return ivec2(iResolution.x - 1., 0);\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nuvec4 getCell(ivec2 coord, ivec2 offset)\n{\n    return floatBitsToUint(texelFetch(iChannel0, (coord + offset) % ivec2(iResolution.xy), 0));\n}\n\n// use toroidal distance to find the squared distance to a cell including wrap-around\nfloat dist2ToCell(vec2 p, vec2 coord)\n{\n    vec2 d = abs(p - coord);\n    d = mix(d, iResolution.xy - d, greaterThan(d, .5 * iResolution.xy));\n    return d.x * d.x + d.y * d.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    ivec2 ifc = ivec2(fragCoord);\n    if (keyDown(KEY_SPACE) ||\n        iFrame == 0 ||\n        state.resolution < 0. )\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        return;\n    }\n\n    if (dist2ToCell((cameraPos.xz + .5) * iResolution.y, fragCoord) > 15. * 15.)\n    {\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        return;\n    }\n\n    // handle mouse input\n    if (iMouse.z > 0. && iMouse.w < 0.)\n    {\n        vec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n        float toT = cameraPos.y / rayTo.y;\n        vec3 toHit = cameraPos - toT * rayTo;\n        vec2 proj = (toHit.xz + .5) * iResolution.y;\n\n        if (dist2ToCell(proj, fragCoord) < 2.5 * 2.5)\n        {\n            fragColor = uintBitsToFloat(MAX_UVEC4);\n            return;\n        }\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n\n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = getCell(ifc, nDir(d));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = getCell(ifc, nDir(d));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-3)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and direction\n// ---------------------------------------------------------------------------------------\n\nvec3 camPath(float t)\n{\n    vec3 result;\n    result.x = t * .00002;\n    result.y = (4. + 1.5*sin(t*.004))/iResolution.y;\n    result.z = -.005*sin(t*.002);\n    return result;\n}\n\nvoid updateCamera(inout fxState state)\n{\n    const float MOVE_SPEED = 0.0002;\n    vec3 camMove = vec3(0);\n    if (keyDown(KEY_W))\n    {\n        camMove.z += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_S))\n    {\n        camMove.z -= MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_A))\n    {\n        camMove.x += MOVE_SPEED;\n        state.camRoll += 2.;\n        state.attract = false;\n    }\n    if (keyDown(KEY_D))\n    {\n        camMove.x -= MOVE_SPEED;\n        state.camRoll -= 2.;\n        state.attract = false;\n    }\n    if (keyDown(KEY_R))\n    {\n        camMove.y += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_F))\n    {\n        camMove.y -= MOVE_SPEED;\n        state.attract = false;\n    }\n    \n    state.camRoll *= .9;\n\n    camMove.xz *= rotate(state.camDir);\n    state.camPos += camMove;\n\n    if (state.attract)\n    {\n        state.attractTime = mod(state.attractTime + 1., 1e4); // protect against numerical error by resetting every five minutes\n        state.camPos = camPath(state.attractTime);\n        vec3 nextCamPath = camPath(state.attractTime + 50.);\n        vec3 camDelta = state.camPos - nextCamPath;\n        state.camDir = atan(camDelta.x, camDelta.z) + PI;\n        vec3 nextCamDelta = camPath(state.attractTime + 100.) - nextCamPath;\n        state.camRoll = -cross(camDelta, nextCamDelta).y * 5e8;\n    }\n\n    const float TURN_RATE = 0.02;\n    if (keyDown(KEY_Q))\n    {\n        state.camRoll += 2.;\n        state.camDir += TURN_RATE;\n        state.attract = false;\n    }\n    if (keyDown(KEY_E))\n    {\n        state.camRoll -= 2.;\n        state.camDir -= TURN_RATE;\n        state.attract = false;\n    }\n\n    float MIN_HEIGHT = .0002;\n    float MAX_HEIGHT = .01;\n    state.camPos.y = clamp(state.camPos.y, MIN_HEIGHT, MAX_HEIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { fragColor = vec4(0); return; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.attract = true;\n        state.camPos = vec3(0, 5. / iResolution.y, 0);\n        state.camDir = 0.;\n        state.attractTime = 0.;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        updateCamera(state);\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Main render: RGB color A depth\n// ---------------------------------------------------------------------------------------\n\n// set this to 2 for 4xMSAA, 3 for 9x, etc.\n#define MSAA 1\n\nvec4 render(vec2 u, fxState state)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 hitPos, normal;\n    vec4 color = vec4(0);\n    float count = 0.;\n    \n#if MSAA > 1\n    float t = 0.;//texelFetch(iChannel3, ivec2(u), 0).w; // \"progressive ray marching\" doesn't help here\n    \n    for (int x = 0; x < MSAA; ++x)\n    for (int y = 0; y < MSAA; ++y)\n    {\n        vec2 offset = .7*vec2(x, y) / float(MSAA - 1) - .5 * float(MSAA - 1);\n        vec3 rayDir = fxCalcRay(u + offset, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n        if (t == 0.) t = (MAX_Y - cameraPos.y) / rayDir.y;\n\n        // t is inout param here, so we will use the t from one subsample as a starting guess for the next one\n        vec4 subsample = pixel(cameraPos, cameraFwd, rayDir, t, hitPos, normal);\n        \n        color += subsample;\n    }\n    \n    color /= float(MSAA * MSAA);\n#else\n    vec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    if (rayDir.y > 0.) { return vec4(0,0,0,MAX_T); }\n    float t = (MAX_Y - cameraPos.y) / rayDir.y;\n    //t = texelFetch(iChannel3, ivec2(u), 0).w; // testing \"progressive ray marching\"...doesn't help much here, I suppose because of fast convergence\n    \n    color = pixel(cameraPos, cameraFwd, rayDir, t, hitPos, normal);\n#endif\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    SDF_EPSILON = SDF_EPSILON_R / iResolution.y;\n    fxState state = fxGetState();\n    fragColor = render(fragCoord, state);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}