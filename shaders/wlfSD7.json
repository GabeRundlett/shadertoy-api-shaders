{
    "Shader": {
        "info": {
            "date": "1563187032",
            "description": "Messing around with folding functions to generate polyhedra. Instead of measuring the distance from the folded position to a plane to other primitives such as a spheres and boxes turned out quite nice so decided to share the code.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlfSD7",
            "likes": 9,
            "name": "Dodecahedron variant",
            "published": 3,
            "tags": [
                "raymarchingfoldingdodecahedron"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 553
        },
        "renderpass": [
            {
                "code": "// License CC0, mrange\n\n// Messing around with folding functions to generate polyhedra. \n// Instead of measuring the distance from the folded position \n// to a plane to other primitives such as a spheres and boxes \n// turned out quite nice so decided to share the code.\n\n// Based on knighty's dodecahedron\n#define TOLERANCE           0.00001\n#define NORM_OFF            0.0001\n#define MAX_RAY_LENGTH      8.0\n#define MAX_RAY_MARCHES     50\n#define PI                  3.141592654\n#define TAU                 (2.0*PI)\n#define PHI                 (.5*(1.+sqrt(5.)))\n\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nvoid rot(inout vec2 v, in float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  v.xy = vec2(v.x*c + v.y*s, -v.x*s + v.y*c);\n}\n\nfloat sdSoftBox(in vec3 p, in float r)\n{\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nconst vec3 pn1 = normalize(vec3(1, 1, -1));\nconst vec3 n1  = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2  = normalize(vec3(1.0,-PHI,PHI+1.0));\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat weird(in vec3 p, out int m)\n{\n  vec3 z = p;\n  float t;\n  \n  // Folds for Dodecahedron\n  \n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float tt = 0.3*iTime;\n  float ssz = 0.5;\n  vec3 zz = z - ssz*pn1;\n  \n  rot(zz.yz, tt);\n  rot(zz.xz, sqrt(2.0)*tt);\n  rot(zz.xy, sqrt(3.0)*tt);\n\n  float dmin1 = dot(pn1, zz - vec3(ssz, 0, 0));\n  // In addition to measuring distance of folded position to plane also measure to torus and soft box\n  float dmin4 = sdTorus(zz, vec2(ssz, ssz*0.7));\n  float dmin5 = sdSoftBox(zz, ssz);\n  \n  float dmin = min(dmin4, dmin5);\n\n  if (dmin == dmin5)\n  {\n    m = 1;\n  }\n  else\n  {\n    m = 2;\n  }\n\n\n  return max(dmin1, dmin);\n}\n\nfloat map(in vec3 p, out int m)\n{\n  float d1 = weird(p, m);\n  return d1;\n}\n\n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int mat, out int iter)\n{\n  float t = 0.0;\n  float distance;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    iter = i;\n    distance = map(ro + rd*t, mat);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  \n  if (abs(distance) > 100.0*TOLERANCE) return MAX_RAY_LENGTH;\n  \n  return t;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(NORM_OFF,0.0,0.0);\n  vec3 nor;\n  int mat;\n  nor.x = map(pos+eps.xyy, mat) - map(pos-eps.xyy, mat);\n  nor.y = map(pos+eps.yxy, mat) - map(pos-eps.yxy, mat);\n  nor.z = map(pos+eps.yyx, mat) - map(pos-eps.yyx, mat);\n  return normalize(nor);\n}\n\nconst vec3 lightPos1 = 100.0*vec3(-0.3, 0.15, 1.0);\nconst vec3 lightPos2 = 100.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 skyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  \n  final += 1.0*pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 1.0*lightCol1 * pow(ld1, 200.0);\n  final += 1.0*pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += 1.0*lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float t = rayMarch(ro,rd, mat, iter);\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n    \n  if (t < MAX_RAY_LENGTH)\n  {\n    // Ray intersected object\n    nor = normal(pos);\n    float d2 = abs(dot(-rd, nor));\n    \n    if(mat == 0)\n    {\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n    }\n    else if (mat == 1)\n    {\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n    }\n    else if (mat == 2)\n    {\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n    }\n    else\n    {\n      color = nor*nor;\n    }\n      \n  }\n  else\n  {\n    // Ray intersected sky\n    return skyColor(rd);\n  }\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = skyColor(ref);\n  \n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = lightPos1 - pos;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = lightPos2 - pos;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float rst  = rayMarch(pos + ref*10.0*TOLERANCE, ref, rmat, riter);\n  float rsha = rst < MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*lightCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*lightCol2, 0.8);\n\n  vec3 col = mix(rcol*rsha, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(2, 2, 0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  rot(ro.xz, TAU*iTime/20.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(mix(col, vec3(1.0), 0.0),1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}