{
    "Shader": {
        "info": {
            "date": "1615683290",
            "description": "Simple polygon clipping algorithm. Drag with the mouse to set the clipping boundary.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdXGz7",
            "likes": 12,
            "name": "Polygon Clipping Algorithm",
            "published": 3,
            "tags": [
                "triangle",
                "geometry",
                "polygon",
                "algorithm",
                "clipping"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "/*\nSimple polygon clipping algorithm. It works for nonconvex and irregular polygons\nas well and can generalize to any number of dimensions.\nClipping the Utah teapot because why not: https://repl.it/@hathnoname/Polygon-Clipping#main.py\n*/\n\n// Drawing utilities\nvoid drawPoint(inout vec3 pixel, in float unit, in vec2 p, in vec2 pos, in float size, in vec3 color) {\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, length(p - pos) - size));\n}\n\nvoid drawLine(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in float thickness, in vec3 color) {\n    vec2 pa = p - a, ba = b - a;\n    float d = length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - thickness;\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, d));\n}\n\nvoid drawTriangle(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec3 color) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    // Triangle subareas\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    pixel = mix(pixel, color, smoothstep(1.0 + unit, 1.0 - unit, (bcp + cap + abp) / abc) * 2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    // Previous and current mouse positions\n    vec2 pMouse, mouse;\n    if (iMouse.z > 0.0) {\n        pMouse = (abs(iMouse.zw) - center) / iResolution.y;\n        mouse = (iMouse.xy - center) / iResolution.y;\n    }\n\n    else {\n        float c = cos(iTime), s = sin(iTime);\n        pMouse = vec2(c, c * s) * 0.5;\n        mouse = vec2(s * s - c * c, -s) + pMouse;\n    }\n\n    // Normalized screen coordinates, pixel size, and pixel color\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Triangle vertices\n    vec2 a = vec2(-0.5, -0.3);\n    vec2 b = vec2(0.3, -0.2);\n    vec2 c = vec2(0.0, 0.25);\n\n    // Draw edges\n    drawLine(color, unit, uv, a, b, 0.01, vec3(0.0, 1.0, 0.0));\n    drawLine(color, unit, uv, b, c, 0.01, vec3(0.0, 1.0, 0.0));\n    drawLine(color, unit, uv, c, a, 0.01, vec3(0.0, 1.0, 0.0));\n\n    // Begin clipping\n    vec2 clipPos = pMouse;                      // Position of the clipping boundary\n    vec2 clipDir = mouse - pMouse;              // Side of the clipping boundary that gets kept\n\n    vec2[] poly = vec2[](a, b, c);   // Original polygon\n    vec2[poly.length() + 1] clipped; // Clipped polygon\n    int nClip = 0;                   // Number of vertices in the clipped polygon\n\n    for (int v=1; v < poly.length() + 1; v++) {\n        vec2 v1 = poly[v - 1], v2 = poly[v % poly.length()];\n        bool clipV1 = dot(v1 - clipPos, clipDir) < 0.0;\n        bool clipV2 = dot(v2 - clipPos, clipDir) < 0.0;\n        if (!clipV1) {\n            clipped[nClip] = v1;\n            nClip++;\n        }\n\n        if (clipV1 != clipV2) {\n            float dot1 = dot(v1, clipDir), dot2 = dot(v2, clipDir);\n            vec2 clip = v1 + (v2 - v1) * (dot(clipPos, clipDir) - dot1) / (dot2 - dot1);\n\n            // Add to clipped vertices\n            clipped[nClip] = clip;\n            nClip++;\n        }\n    }\n    // End clipping\n\n    // Draw simple convex triangulation\n    for (int v=1; v < nClip - 1; v++) {\n        vec2 v1 = clipped[0], v2 = clipped[v], v3 = clipped[v + 1];\n        drawTriangle(color, unit, uv, v1, v2, v3, vec3(0.0, 1.0, 0.0));\n    }\n\n    // Draw clipping area and clipping boundary\n    float db = dot(uv - clipPos, normalize(clipDir));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, db) * 0.5);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(db) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}