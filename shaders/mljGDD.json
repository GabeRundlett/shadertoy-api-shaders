{
    "Shader": {
        "info": {
            "date": "1673351095",
            "description": "They wonk around helplessly, but smeared",
            "flags": 0,
            "hasliked": 0,
            "id": "mljGDD",
            "likes": 3,
            "name": "Flying butter noodles",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "sdf",
                "squares"
            ],
            "usePreview": 0,
            "username": "brainsandwich",
            "viewed": 317
        },
        "renderpass": [
            {
                "code": "// https://stackoverflow.com/a/4275343/4296866\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdf_rect(in vec2 uv, in vec2 position, in vec2 halfsize)\n{\n    vec2 componentWiseEdgeDistance = abs(uv - position) - halfsize;\n    return min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 1.);\n}\n\nfloat sdf_rect_rounded(in vec2 uv, in vec2 position, in vec2 halfsize)\n{\n    vec2 componentWiseEdgeDistance = abs(uv - position) - halfsize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.);\n    return outsideDistance + insideDistance;\n}\n\nstruct rect {\n    vec3 color;\n    vec2 center;\n    vec2 halfsize;\n};\n\nvec3 mixfn(in vec3 pixel, in vec3 color, in float mixer)\n{\n    vec3 cp = color; //color-pixel;\n    return mix(pixel, cp, mixer);\n}\n\nfloat antialias(in float dist)\n{\n    return smoothstep(-1., 1., (dist-.04)/fwidth(dist));\n}\n\nvoid draw_rect(inout vec3 pixel, in vec2 position, rect r)\n{\n    float dist = sdf_rect_rounded(position, r.center, r.halfsize);\n    float clampd = 1.-antialias(dist); // 1.-step(0.01, dist);\n    pixel = mixfn(pixel, r.color, clampd);\n}\n\nfloat wobble(in float d)\n{\n    float c1 = sin(0.2*iTime+d*10.0);\n    float c2 = sin(-0.1*iTime+d*24.0);\n    float c3 = sin(-0.5*iTime+d*2.0*sin(c1));\n    return 0.5*(3.0*c1 + 1.0*c2 + 5.0*c3 + d);\n}\n\n// Very sensitive, cool at limit of float precision\n#define TIMEFACTOR 0.000000001\n#define BACKGROUND vec3(0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Smear pixel pos\n    uv.x = uv.x + 0.1*wobble(uv.y);\n    uv.y = uv.y + 0.1*wobble(uv.x);\n    uv.x = uv.x + 0.1*wobble(uv.y);\n    uv.y = uv.y + 0.1*wobble(uv.x);\n    uv.x = uv.x + 0.1*wobble(uv.y);\n    uv.y = uv.y + 0.1*wobble(uv.x);\n\n    // Background color\n    vec3 col = BACKGROUND;\n    for (int i = 0; i < 32; i++)\n    {\n        float fi = float(i)*sin(TIMEFACTOR*iTime+0.001);\n        \n        rect r;\n        r.color = vec3(rand(10.*vec2(fi)), rand(vec2(4.501*fi)), rand(vec2(-fi*.99)));\n        r.center = 5.*vec2(rand(vec2(fi, fi+0.1)), rand(vec2(0.1*fi)))-2.;\n        r.halfsize = 0.6*vec2(rand(vec2(fi, fi+0.1)), rand(vec2(2.*fi)));\n        \n        draw_rect(col, uv, r);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}