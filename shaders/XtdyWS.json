{
    "Shader": {
        "info": {
            "date": "1533856983",
            "description": ".",
            "flags": 8,
            "hasliked": 0,
            "id": "XtdyWS",
            "likes": 6,
            "name": "[SH18] Heart",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "metaballs",
                "normal",
                "heartbeat"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 841
        },
        "renderpass": [
            {
                "code": "// References:\n// Metaballs quintic: https://www.shadertoy.com/view/ld2GRz\n// Normal mapping: https://www.shadertoy.com/view/4t2GDG\n\nconst float EPSILON = 0.0001;\nconst float ANIM_TIME = 1.0;\n\nvec3 diffuseColor = vec3(0.3, 0.1, 0.1);\n\n#define bCount 14\n#define cylCount 3\nvec4 m[bCount];\nfloat cyl[cylCount];\n\nfloat quinticSmooth(float x) { return x*x*x*(x*(x*6.0-15.0)+10.0); }\n\nfloat metaBallsSDF(vec3 pos) {\n    bool inRangeOfBoundingShape = false; \n\tfloat dmin = 1e20;\n    \n    float p = 0.0;\n\tfloat h = 0.1;\n    \n    for (int i=0; i<bCount; i++) {\n        vec3 sphCenter = m[i].rgb;\n        float size = m[i].w;\n        float boundingR = sqrt(dot(size, size));\n        vec3 c = pos - sphCenter;\n        \n        if (length(c) < boundingR) {\n            inRangeOfBoundingShape = true;\n            \n        \tfloat x = length(c) / boundingR;\n            p += 1.0 - quinticSmooth(x);\n\n            h = max(h, 0.5333*boundingR / x);\n        } else {\n            dmin = min( dmin, boundingR );\n        }\n    }\n\t\n\tif (inRangeOfBoundingShape) {\n\t\tfloat threshold = 0.25;\n\t\treturn h*(threshold-p);\n    } else {\n    \treturn dmin + 0.05;\n    }\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)/k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sceneSDF( vec3 pos )\n{\n    float d = metaBallsSDF(pos);\n    \n    float leftC = sdCapsule(pos, vec3(-2.3, 7.6, 0.0), vec3(-2.0, 7.4,0.0), cyl[0]);\n    float rC = sdCapsule(pos, vec3(1.7, 8.0, 1.0), vec3(1.4, 6.4, 0.9), cyl[1]);\n    float rC2 = sdCapsule(pos, vec3(1.7, 8.0, 1.0), vec3(1.5, 9.0, 1.2), cyl[2]);\n    \n    d = smin(d, leftC, 0.5);\n    d = smin(d, rC, 0.2);\n    d = smin(d, rC2, 0.15);\n    \n    // https://www.shadertoy.com/view/XtdcWr\n    float veins = textureLod(iChannel3, (pos.xy - pos.z*0.2) * vec2(0.2, 0.1) + vec2(0.1, 0.0), 0.0).x;\n    d += veins * 0.07;\n    return d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// https://www.shadertoy.com/view/MsX3RH\nvec3 nmap(vec2 t, sampler2D tx, float str)\n{\n\tfloat d=1.0/1024.0;\n\n\tfloat xy=texture(tx,t).x;\n\tfloat x2=texture(tx,t+vec2(d,0)).x;\n\tfloat y2=texture(tx,t+vec2(0,d)).x;\n\t\n\tfloat s=(1.0-str)*1.2;\n\ts*=s;\n\ts*=s;\n\t\n\treturn normalize(vec3(x2-xy,y2-xy,s/8.0));\n}\n\nvec3 computeSingleLight(vec3 n, vec3 p, vec3 l)\n{\n\tfloat diffTerm = max(dot(normalize(n), normalize(l)), 0.0) * 1.5;\n    vec3 reflectVec = normalize(-reflect(l, n));\n    float specTerm = pow(max(dot(reflectVec, normalize(p)), 0.0),12.0) * 0.2;\n    \n    return diffuseColor * diffTerm + specTerm ;\n}\n\nvec3 computeLighting(vec3 n, vec3 p)\n{   \n    return computeSingleLight(n, p, vec3(0.3, 0.2, 0.5))\n       + computeSingleLight(n, p, vec3(-0.3, 0.3, -0.5));\n}\n\nvoid setupScene() {\n    float t = 30.0 * mod(iTime, ANIM_TIME) / ANIM_TIME;\n\tfloat p = t / 6.0;\n    \n    float s0 = mix(0.573, 0.614, t / 11.0);\n    float s1 = mix(1.675, 1.63, p);\n    float s2 = 1.025;\n    float s4 = 1.168;\n    float s7 = 0.81;\n    float s10 = mix(0.63, 0.51, p);\n    float s11 = 0.77;\n    \n    cyl[0] = mix(0.85, 0.7, t / 5.0);\n    if (t > 5.0) {\n        cyl[0] = mix(0.7, 0.85, min((t-5.0) / 5.0,1.0));\n    }\n    \n    cyl[1] = 0.65;\n    cyl[2] = mix(0.55, 0.6, max((t-8.0)/9.0, 0.0));\n    \n    if (t > 6.0) {\n        p = (t-6.0)/5.0;\n        s1 = mix(1.63, 1.779, p);\n        s2 = mix(1.025, 1.089, p);\n        s4 = mix(1.168, 1.021, p);\n        s7 = mix(0.81, 0.938, p);\n        s10 = mix(0.51, 0.558, p);\n        s11 = mix(0.77, 0.72, p);\n        cyl[1] = mix(0.65, 0.7, p);\n    }\n    if (t > 11.0) {\n        p = min((t - 11.0) / 6.0, 1.0);\n        s0 = mix(0.614, 0.573, p);\n        s1 = mix(1.779, 1.631, p);\n        s2 = mix(1.089, 0.922, p);\n        s4 = mix(1.021, 1.168, p);\n        s7 = mix(0.938, 0.796, p);\n        s10 = mix(0.558, 0.63, p);\n        s11 = mix(0.72, 0.77, p);\n        cyl[1] = mix(0.7, 0.65, p);\n    }\n    if (t > 17.0) {\n        p = (t - 17.0) / 13.0;\n        s1 = mix(1.631, 1.675, p);\n        s2 = mix(0.922, 1.025, p);\n        s7 = mix(0.796, 0.81, p);\n        cyl[2] = mix(0.6, 0.55, min(p,1.0));\n        \n    }\n    \n    m[0] = vec4(-0.645, 1.855, -0.00427, s0);\n    m[1] = vec4(-0.839, 4.754, -0.16, s1);\n    m[2] = vec4(0.349, 2.759, 0.0515, s2);\n    m[3] = vec4(-0.19, 4.52, 0.97, 1.0);\n    m[4] = vec4(1.73, 5.26, -0.162, s4);\n    m[5] = vec4(1.39, 3.811, -0.30, 1.0);\n    m[6] = vec4(-0.214, 3.52, 0.587, 1.0);\n    m[7] = vec4(-0.745, 2.898, 0.17, s7);\n    m[8] = vec4(-0.05, 4.63, -0.8, 1.282);\n    m[9] = vec4(-0.47, 2.96, -0.36, 1.0);\n    m[10] = vec4(-1.618, 6.82, 0.16, s10);\n    m[11] = vec4(2.06, 7.0, -0.04, s11);\n    m[12] = vec4(0.7, 6.47, 0.61, 0.569);\n    m[13] = vec4(1.18, 7.08, 0.68, 0.503);   \n   \n    // fix input :everything-is-very-bad:\n    for (int i = 0; i < bCount; ++i) {\n    \tm[i].w *= 2.5;\n    }\n}\n\n// https://www.shadertoy.com/view/ld2GRz\nvoid makeCamera(out vec3 ro, out vec3 rd, vec2 fragCoord) {\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    // move camera\t\t\n    float an = 0.55 + sin(iTime * 0.3) * 0.3 - 6.2831*(m.x-0.5);\n    ro = vec3(sin(an),0.7,cos(an)) * 12.0;\n    vec3 ta = vec3(0.0,5.3,0.0);\n    // image plane\t\t\n    vec2 pp = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    pp.x *= iResolution.x/iResolution.y;\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // create view ray\n    rd = normalize( pp.x*uu + pp.y*vv + 2.0*ww );\n}\n\nvec3 background(vec3 rd)\n{\n    float m = smoothstep(-0.5, 0.0, rd.y);\n    return mix(vec3(0.1), vec3(0.4, 0.2, 0.2), m);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 ro, rd, p;\n    \n    setupScene();\n    makeCamera(ro, rd, fragCoord);\n    \n\tp = ro;\n\n\tfloat t = 0.;\n    vec3 normal = vec3(0.0);\n    \n    vec3 l = background(rd);\n    \n\tfor (float i = 0.; i < 1.8; i += .01) {\n\t\tp = ro + rd * t;\n        \n\t\tfloat d = sceneSDF(p);\n        if (d < .001) {\n            normal = estimateNormal(p);\n            \n            float nms=.59;\n            vec3 tuv=p*vec3(1.0); // texture coordinates\n\n            // triplanar blend vector ( https://www.shadertoy.com/view/MsX3RH )\n            vec3 tpn=normalize(max(vec3(0.0),(abs(normal.xyz)-vec3(0.2))*7.0))*0.5;\n\n            vec3 nmx=nmap(tuv.yz,iChannel1,nms)+nmap(-tuv.yz,iChannel3,nms);\n            vec3 nmy=nmap(tuv.xz,iChannel1,nms)+nmap(-tuv.xz,iChannel3,nms);\n            vec3 nmz=nmap(tuv.xy,iChannel1,nms)+nmap(-tuv.xy,iChannel3,nms);\n\n            vec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);\n            normal = normalize(nn*0.15 + normal);\n            \n            l = computeLighting(normal, p);\n            break;\n        }\n        \n\t\tt += d * 0.4;\n        if (t > 20.) {\n            break;\n        }\n\t}\n    \n\tfragColor = vec4(l, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float ANIM_TIME = 1.0;\n\nfloat cl(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat triangle(float t) {\n\treturn 1.0 - abs(mod(t, 2.0) - 1.0);\n}\n\nfloat kick(float t, float freqIn)\n{\n    float freq = 6.2831852 * freqIn * 0.125;\n    float osc1 = sin(t * freq);\n    float fade1 = cl(1.0-exp(t)*0.8);\n    float osc2 = triangle(t * freq *0.5);\n    float fade2 = cl(1.0-exp(t)*0.84);\n\n\treturn osc1 * fade1 * 35.0 + osc2 * fade2 * 40.0;\n}\nvec2 mainSound( in int samp, float time )\n{\n    float t = fract((30.0 * mod(time, ANIM_TIME) / ANIM_TIME - 5.0) / 30.0);\n    float t2 = fract((30.0 * mod(time, ANIM_TIME) / ANIM_TIME - 11.0) / 30.0);\n\n    return kick(t, 120.0) * vec2(1.0, 0.8) + kick(t2, 210.0) * vec2(0.5, 0.3);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}