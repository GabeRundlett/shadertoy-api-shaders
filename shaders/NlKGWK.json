{
    "Shader": {
        "info": {
            "date": "1638349551",
            "description": "My attempt at a procedural ocean. It should run pretty fast, I got 60fps on my phone. ",
            "flags": 0,
            "hasliked": 0,
            "id": "NlKGWK",
            "likes": 202,
            "name": "Lonely Waters",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "waves",
                "sea",
                "sun",
                "clouds",
                "water",
                "ocean",
                "sky"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 6861
        },
        "renderpass": [
            {
                "code": "//Set to 2.0 for AA\n#define AA 1.0\n\n#define STEPS 80.0\n#define MDIST 35.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n\n#define ITERS_TRACE 9\n#define ITERS_NORM 20\n\n#define HOR_SCALE 1.1\n#define OCC_SPEED 1.4\n#define DX_DET 0.65\n\n#define FREQ 0.6\n#define HEIGHT_DIV 2.5\n#define WEIGHT_SCL 0.8\n#define FREQ_SCL 1.2\n#define TIME_SCL 1.095\n#define WAV_ROT 1.21\n#define DRAG 0.9\n#define SCRL_SPEED 1.5\nvec2 scrollDir = vec2(1,1);\n\n\n//Built with some ideas from\n//https://www.shadertoy.com/view/wldBRf\n//https://www.shadertoy.com/view/ssG3Wt\n//https://www.shadertoy.com/view/4dBcRD\n//https://www.shadertoy.com/view/Xdlczl\nvec2 wavedx(vec2 wavPos, int iters, float t){\n    vec2 dx = vec2(0);\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0; \n    wavPos+= t*SCRL_SPEED*scrollDir;\n    wavPos*= HOR_SCALE;\n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for(int i=0;i<iters;i++){\n        wavDir*=rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime; \n        float result = exp(sin(x)-1.)*cos(x);\n        //if(result>0.) foam+=result*0.3;\n        result*=wavWeight;\n        dx+= result*wavDir/pow(wavWeight,DX_DET); \n        wavFreq*= FREQ_SCL; \n        wavTime*= TIME_SCL;\n        wavPos-= wavDir*result*DRAG; \n        wavWeight*= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; \n    return dx/pow(wavSum,1.-DX_DET);\n}\n\nfloat wave(vec2 wavPos, int iters, float t){\n    float wav = 0.0;\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0;\n    wavPos+= t*SCRL_SPEED*scrollDir;\n    wavPos*= HOR_SCALE; \n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for(int i=0;i<iters;i++){\n        wavDir*=rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime;\n        float wave = exp(sin(x)-1.0)*wavWeight;\n        wav+= wave;\n        wavFreq*= FREQ_SCL;\n        wavTime*= TIME_SCL;\n        wavPos-= wavDir*wave*DRAG*cos(x);\n        wavWeight*= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; \n    return wav/wavSum;\n}\n\nvec3 norm(vec3 p){\n    vec2 wav = -wavedx(p.xz, ITERS_NORM, iTime);\n    return normalize(vec3(wav.x,1.0,wav.y));\n}\n\nfloat map(vec3 p){\n    float a = 0.;\n    int steps = ITERS_TRACE;\n    p.y-= wave(p.xz,steps,iTime);\n    a = p.y;\n    return a;\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){\n    return a+b*cos(2.0*pi*(c*t+d));\n}\nvec3 spc(float n,float bright){\n    return pal(n,vec3(bright),vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.67));\n}\nvec2 sunrot = vec2(-0.3,-0.25);\n\n//Change the color of the scene here, it better withs some colors than others\nfloat spec = 0.13;\n\nvec3 sky(vec3 rd){\n    float px = 1.5/min(iResolution.x,iResolution.y);\n    vec3 rdo = rd;\n    float rad = 0.075;\n    vec3 col = vec3(0);\n\n    //Sun\n    rd.yz*=rot(sunrot.y);\n    rd.xz*=rot(sunrot.x);\n    float sFade = 2.5/min(iResolution.x,iResolution.y);\n    float zFade = rd.z*0.5+0.5;\n    \n    vec3 sc = spc(spec-0.1,0.6)*0.85;\n    float a = length(rd.xy);\n    vec3 sun=smoothstep(a-px-sFade,a+px+sFade,rad)*sc*zFade*2.;\n    col+=sun;\n    col+=rad/(rad+pow(a,1.7))*sc*zFade;\n    col=col+mix(col,spc(spec+0.1,0.8),sat(1.0-length(col)))*0.2;\n    \n    //This code provides the implication of clouds :)\n    float e = 0.;\n    vec3 p = rdo;\n    p.xz*=0.4;\n    p.x+=iTime*0.007;\n    for(float s=200.;s>10.;s*=0.8){\n        p.xz*=rot(s);\n        p+=s;\n        e+=abs(dot(sin(p*s+iTime*0.02)/s,vec3(1.65)));\n    }\n    e*=smoothstep(0.5,0.4,e-0.095);\n    \n    col += (e)*smoothstep(-0.02,0.3,rdo.y)*0.8*(1.0-sun*3.75)*mix(sc,vec3(1),0.4);\n    \n    return (col);\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,2.25,-3)*1.1;\n    bool click = iMouse.z>0.;\n    if(click){\n    ro.yz*=rot(2.0*min(iMouse.y/iResolution.y-0.5,0.15));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.9)+uv.x*r+uv.y*cross(f,r));\n\n    float dO = 0.;\n    bool hit = false;\n    float d = 0.;\n    vec3 p = ro;\n\n    float tPln = -(ro.y-1.86)/rd.y;\n    if(tPln>0.||click){\n        if(!click)dO+=tPln;\n        for(float i = 0.; i<STEPS; i++){\n            p = ro+rd*dO;d = map(p);dO+=d;\n            if(abs(d)<0.005||i>STEPS-2.0){\n                hit = true;\n                break;\n            }\n            if(dO>MDIST){\n                dO = MDIST;\n                break;\n            }\n        }\n    }\n    vec3 skyrd = sky(rd);\n    if(hit){\n    vec3 n = norm(p);\n    vec3 rfl = reflect(rd,n);\n    rfl.y = abs(rfl.y);\n    vec3 rf = refract(rd,n,1./1.33); \n    vec3 sd = normalize(vec3(0,0.3,-1.0));\n    float fres = clamp((pow(1. - max(0.0, dot(-n, rd)), 5.0)),0.0,1.0);\n\n    vec3 sunDir = vec3(0,0.15,1.0);\n    sunDir.xz*=rot(-sunrot.x);\n    col += sky(rfl)*fres*0.9;\n    float subRefract =pow(max(0.0, dot(rf,sunDir)),35.0);\n    //This effect is exaggerated much more than is realistic because I like it :) \n    col += pow(spc(spec-0.1,0.5),vec3(2.2))*subRefract*2.5;\n    vec3 rd2 = rd;\n    rd2.xz*=rot(sunrot.x);\n    vec3 waterCol = min(sat(spc(spec-0.1,0.4))*0.05*pow(min(p.y+0.5,1.8),4.0)*length(skyrd)*(rd2.z*0.3+0.7),1.0);\n   \n    waterCol = sat(spc(spec-0.1,0.4))*(0.4*pow(min(p.y*0.7+0.9,1.8),4.)*length(skyrd)*(rd2.z*0.15+0.85));\n    col += waterCol*0.17;\n    //col+=smoothstep(0.95,1.55,wave(p.xz,25,iTime))*mix(waterCol*0.3,vec3(1),0.2)*0.2;\n\n    col = mix(col,skyrd,dO/MDIST);\n    }\n    else{\n        col += skyrd;\n    }\n    col = sat(col);\n    col = pow(col,vec3(0.87));\n    col *=1.0-0.8*pow(length(uv*vec2(0.8,1.)),2.7);\n    fragColor = vec4(col,1.0);\n    \n}\n\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}