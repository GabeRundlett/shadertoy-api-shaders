{
    "Shader": {
        "info": {
            "date": "1670666177",
            "description": "Inspired by my dear labradorite, which I obtained from an amazing artesanian in Mexico.\nHe told me, it would support me to focus my creativity -- well, here we are (\n\nPlay with the mouse to scrub the universe!\n\nAnti aliasing could be better..",
            "flags": 32,
            "hasliked": 0,
            "id": "ddjXR3",
            "likes": 22,
            "name": "[phreax] the universe within",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "refraction"
            ],
            "usePreview": 0,
            "username": "phreax",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n   \n   Some fusion of my previous work.\n   \n   \n   The refraction is based on https://www.shadertoy.com/view/fl23Ww\n   Which it self is based on an awesome tutorial by BigWIngs\n   \n   The spiral is from https://www.shadertoy.com/view/dslSRf\n*/\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define tt (iTime*.7)\n\n// reduce if too slow\n#define AA 2 \n\nfloat g_mat;\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float h21(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(53.839,144.53))) * 2341.532);\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nvec3 transform(vec3 p) {\n\n    float a = PI*.5 + iTime;\n    p.xz *= rot(a);\n    p.xy *= rot(a);\n    \n    return p;\n}\n\n\nfloat cornet(vec3 p) {\n\n    p.x *= 1.23;\n    p.y -= .5;\n    p.yz *= rot(.5*PI);\n    \n    float r = 2.2;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n\n    vec2 CP = cp;\n\n    float rev = 5.5;\n    float a = atan(p.z, p.x);\n \n    cp *= rot(rev*a);\n\n    cp *= rot(.5+sin(0.2*cp.x*2.*cp.x*2.*PI));\n    cp= abs(cp) - .1 - .05*SIN(p.z*.7+p.x*.3);\n    cp *= rot(.2+sin(0.9*CP.x*2.*PI)+.3*tt);\n    cp= abs(cp) - .1;\n    cp *= rot(.4);\n    \n    float ri = .01+0.04*SIN(CP.x*2.);\n   \n    return rect(cp.xy, vec2(ri), 0.01)*.8;\n}\n\nvec3 transformGem(vec3 p) {\n    p.y -= .5;\n    p.z -= .9;\n    p.x *= 1.23;\n    p.z *= 1.5;\n    p.xz *= rot(-sin(tt)*.2);\n    \n    return p;\n}\n\nfloat gem(vec3 p) {\n\n    p = transformGem(p);\n    float d = length(p) -2.1;\n    return d*.8;\n}\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n    p *= 1.1;\n   \n    float gem = gem(p);\n     p.xz *= rot(-sin(tt)*.2);\n    float corn = cornet(p);\n    \n    \n    g_mat = gem < corn ? 0. : 1.;\n    \n    p = bp;\n    p.z -= 5.;\n    float bg = box(p, vec3(10, 10, .1));\n\n    \n    float d = min(gem, corn);\n    \n    g_mat = bg < d ? 2. : g_mat;\n    \n    d = min(d, bg)*.9;\n    return d;\n    \n}\n\n// used for reflection\nfloat rayMarchGem(vec3 ro, vec3 rd, out vec3 p) {\n    float i, t, d = 0.1;\n    p = ro;\n  \n    for(i=0.; i<100.; i++) {\n        d = -gem(p);\n        \n        if(abs(d) < 0.001 || t > 2.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    return d;\n\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0035, -0.0035);\n \n    vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                        e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n    return n;\n}\n\nvec3 refractCol(vec3 p, vec3 rd, vec3 n, float ior) {\n\n        vec3 rdIn = refract(rd, n, 1./ior);\n        \n        vec3 pEnter = p - n * 0.003;\n        \n        vec3 pExit;\n       \n        float dIn = rayMarchGem(pEnter, rdIn, pExit );\n        \n        vec3 nExit = -getNormal(pExit);\n        vec3 rdOut = refract(rdIn, nExit, ior);\n        \n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n\n        vec3 env = texture(iChannel1, rdOut).rgb;\n        return env;\n}\n\nvec3 refractRGB(vec3 p, vec3 rd, vec3 n, float ior) {\n    float roff = 0.04;\n\n    vec3 colR = refractCol(p, rd, n, ior);\n    vec3 colG = refractCol(p, rd, n, ior+roff);\n    vec3 colB = refractCol(p, rd, n, ior+2.*roff);\n\n    vec3 col;\n    col.r = colR.r;\n    col.g = colG.g;\n    col.b = colB.b;\n    return col;\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 cam(in vec3 p) {\n    p.x += .3*sin(tt);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col;\n    vec3 totCol = vec3(0);\n    #if AA\n    for(int i=0; i < AA; i++) {\n        vec2 subPix = .4*vec2(cos(2.*PI*float(i)/float(AA)),\n                                sin(2.*PI*float(i)/float(AA)));\n\n        vec2 uv = (fragCoord+subPix-.5*iResolution.xy)/iResolution.y;\n        \n    #else\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    #endif\n    \n    //uv *= rot(-.5*PI);\n    \n    vec3 ro = vec3(0, .5, -5.1),\n         rd = normalize(vec3(uv, 1.)),\n         lp = vec3(-1., 1., -8);\n         \n    vec3 p = ro;\n \n\n    p = cam(p);\n\n    float t, d = 0.1;\n    \n    float mat = 0.;\n    \n    for(float i=.0; i<200.; i++) {\n    \n        d = map(p);\n        mat = g_mat;\n        \n        if(d < 0.001 || t > 20.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n\n     \n    vec3 c1 = vec3(0.149,0.094,0.925);\n    vec3 c2 = vec3(0.141,0.678,0.718);\n\n    vec3 bg = vec3(0.043,0.247,0.298);\n    vec3 gold = vec3(0.886,0.769,0.173);\n    \n    if(d < 0.001) {\n        vec3 n = getNormal(p);\n       \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 200.);\n        \n        float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n        vec3 refd = reflect(rd, n) + vec3(.2, 0, 0); \n        vec3 refl = texture(iChannel0, refd).rgb;\n       \n       \n        if(mat == 0.) { // gem\n            p = transformGem(p);\n\n            col = mix(c1, .7*refl*(c2+.2), .5);\n      \n            col *= .8*(mix(1., dif, .5)+.5*sss);\n            rd.y += .5;\n           \n            vec3 refr = refractRGB(p, rd, n, 1.45);\n            \n            vec2 tuv = fragCoord.xy / iResolution.xy;\n    \n            vec3 galaxy = texture(iChannel2, (tuv)).rgb;\n             \n            col = mix(col, refr*(c2), .7);\n            col = mix(col, (refr+0.4*refl)*c1*mix(1.3, 0.1, clamp(pow(length(p.xy), 0.8), 0., 1.)), .5);\n            \n            col = mix(col, col+2.9*galaxy*mix(1.3, 0.1, clamp(pow(length(p.xy), .6), 0., 1.)), .3);\n            col += .2*spe;\n            \n        } else if(mat==1.) { // cornet\n            float shd = softshadow(p, l, 0.1, 1., 20.0);\n            col = .2*spe+ gold * refl*mix(.6, 1., shd);\n            \n        } else { // background\n            float shd = softshadow(p, l, 2., 10., 15.0);\n            col += 1.5*bg*mix(.1, 1., (1.-length(uv)));\n            col *= mix(.6, 1., shd);\n            #if AA\n            col *= 1./pow(float(AA), .45); // convert to linear\n            #endif\n        }\n    } \n    \n    #if AA\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, h21(uv)); // dithering\n    totCol += col;\n    }\n    \n    col = totCol/float(AA);\n    #else\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, h21(uv)); // dithering\n    #endif\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define SIN(x) (sin(x)*.5+.5)\n#define BEND .8     \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 50.\n#define DISTORT 2.5\n#define COLOR 1.\n#define SPIRAL 2.\n\n//#define WATERCOLOR\n//#define TUNNEL\nfloat tt;\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset) {\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nfloat triangle(vec2 uv, float w, float blur) {   \n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulate the distance\n  float d = 1.-cos(floor(.5+a/r)*r-a)*length(uv);\n  return smoothstep(blur, .0, abs(d)-w)*(0.3/blur);\n}\n\nvec3 spiral(vec2 uv, float z) {  \n\n    uv *= rot((z*TAU-.2*tt)*(SPIRAL+3.*sin(.5*PI+iMouse.y/360.*2.*PI)));\n    #ifdef TUNNEL\n    uv.y += 1.7*sin(.4*z+2.4*tt);\n    uv.x -= .9*sin(.3*z+1.8*tt);\n    #endif\n    \n    float dist = DISTORT * sin(.25*PI+iMouse.x/640.*2.*PI);\n    uv += dist*sin(vec2(5)*uv.yx+.2*tt);\n\n    float blur = exp(-19.*z);\n    float luma = exp(-18.5*z);\n    return triangle(uv, 0.05, blur)*spectral_zucconi6(fract(2.*z+.2*tt+uv.x*.2))*luma*.8;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec4 tex = texture(iChannel0, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0);\n    \n    tt = iTime*.2;\n    uv *= 100.;\n\n    float s = 1./COUNT;\n    \n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(1., .9, z);\n        vec2 UV = uv;\n        col += spiral(UV*z, z)*fade; \n    }\n    \n    col = pow(col, vec3(0.5));\n    #ifdef WATERCOLOR\n    col = 1.05-col;\n    col = pow(col, vec3(2.2));\n    col = clamp(col, vec3(0), vec3(1));\n    #endif\n    col = mix(col, tex.rgb, 0.98);\n    \n   \n   \n    // Output to screen\n    fragColor = vec4(col, iResolution.x);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}