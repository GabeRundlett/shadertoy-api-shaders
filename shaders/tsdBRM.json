{
    "Shader": {
        "info": {
            "date": "1605291265",
            "description": "Méthode empirique pour vieillir des terrains.\nReprésentation du terrain inspirée du papier : \"Authoring Landscapes by Combining Ecosystem and Terrain Erosion Simulation\" [Cordonier et Al.]\n#START_FRAME permet d'avoir le temps de se mettre en plein écran.",
            "flags": 32,
            "hasliked": 0,
            "id": "tsdBRM",
            "likes": 12,
            "name": "Weathering - JFIG Contest",
            "published": 3,
            "tags": [
                "terrain",
                "jfig2020",
                "jfigcontest"
            ],
            "usePreview": 0,
            "username": "zibout",
            "viewed": 848
        },
        "renderpass": [
            {
                "code": "////////////////////////\n// IMAGE - SCENE RENDERING\n////////////////////////\n\n// Rendering the actual water height yeild in strong visual artifacts \n// on slopes due to discrete step along the ray\n#define SHOW_WATER 1\n\n\n#define OVER4PI 1.0/3.141592\nconst vec3 L = normalize(vec3(-0.4, 0.5, -0.3));   \n\n\n\nfloat cumulus(in float h) \n{ \n    return( smoothstep(0., 0.1625, h) - smoothstep(0.88,0.98,h) );    \n}\n\n// Intersection function from Inigo Quilez\n// https://iquilezles.org/\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nvec3 ShadeSurface(vec3 albedo, vec3 L, vec3 N, vec3 V, vec3 LightColor)\n{\n    float NdotL = max(dot(N, L), 0.0);\n    return albedo * NdotL * LightColor;\n}\n\nvec3 ShadeSpecular(vec3 L, vec3 N, vec3 V, vec3 LightColor)\n{\n    vec3 halfwayDir = normalize(L - V);  \n    return vec3(pow(max(dot(N, halfwayDir), 0.0), 16.0));\n}\n\n\nvec3 TerrainAlbedo(vec3 p, vec4 terrainData)\n{\n    vec3 rock = vec3(0.4, 0.4, 0.4);     \n    vec3 sand = vec3(1.0, 0.8, 0.7);                \n    vec3 vegetation = vec3(0.4, 0.7, 0.4);\n    vec3 albedo = rock;\n    \n    if(terrainData.y > 0.0)\n    {\n        float ratio = clamp(terrainData.y*100.0, 0.0, 1.0);\n        albedo = mix(albedo, sand, ratio);\n    }\n    \n    if(terrainData.z > 0.0)\n    {\n        float ratio = clamp(terrainData.z*100.0, 0.0, 1.0);\n        albedo = mix(albedo, vegetation, ratio);\n    }\n           \n    \n    return albedo;\n}\n\nvec4 TerrainData(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n\nvec3 TerrainNormal(vec2 uv)\n{\n    return normalize(texture(iChannel3, uv).xyz);\n}\n\nvec3 WaterNormal(vec2 uv)\n{\n    return normalize(texture(iChannel2, uv).xyz);\n}\n\nfloat SampleClouds(vec2 uv, float h)\n{\n    float heightRatio = smoothstep(0.8, 0.84, h) - smoothstep(0.86, 0.9, h);\n    return heightRatio * texture(iChannel1, uv).x;\n}\n\nfloat henyey_greenstein_phase_function(float g, float mu) \n{\n\tfloat gg        = g * g;\n\treturn( ((1. - gg) / pow( 1. + gg - 2. * g * mu, 1.5)) * OVER4PI );\n}\n\nfloat PhaseFunction(float g1, float g2, float alpha, float mu)\n{\n    return mix(henyey_greenstein_phase_function(g1,mu),henyey_greenstein_phase_function(g2,mu),alpha);\n}\n\nfloat DistanceAttenuation(float value, float sigma)\n{\n    return exp(-value*sigma);\n}\n\nvec3 sky(vec3 rd)\n{\n    return mix(vec3(0.6, 0.8, 1.0), vec3(1.0, 1.0, 1.0), rd.y);\n}\n\n\n// RENDER FUNCTION\n////////////////////////\nvec3 TraceRay(vec3 ro, vec3 rd)\n{\n    \n    vec3 boundsN; \n    vec2 bounds = boxIntersection(ro-0.5, rd, vec3(0.5, 0.5, 0.5), boundsN);\n    \n    float terrainResolution = min(min(iResolution.x, iResolution.y), float(MAX_TERRAIN_SIZE));\n    vec2 toTerain = (terrainResolution-1.0)/iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    // Intersecting terrain bounding box\n    // Check ray -> bouding box intersection\n    if(bounds.y > 0.0) \n    {\n        bounds.x = max(bounds.x, 0.0);\n        vec3 LColor = vec3(1.0, 1.0, 1.0);\n\n        float tStep = 0.005;\n        float tMax = bounds.y;\n        \n        vec3 p = ro + rd * bounds.x;\n        vec2 terrainUV = p.xz * toTerain;\n        vec3 pStep = rd * tStep;\n        vec2 terrainUVVar = (rd.xz * tStep) * toTerain;\n        vec4 datas = TerrainData(terrainUV);\n\t\t\n        vec3 absorption = vec3(1.0);\n        bool inWater = false;\n        // Raymarch heightmap\n        float prevPH = p.y;\n        float prevH = TerrainHeight(datas);        \n\n        for(float t = bounds.x ; t<= tMax ; t += tStep)\n        {\n            \n            //float sampleH \n            datas = TerrainData(terrainUV);\n            float h = TerrainHeight(datas);\n            float ph = p.y;\n            float wh = h + datas.w;\n            \n            #if SHOW_WATER\n            if(p.y < wh - 0.02)\n            {\n                // Phase change, account for water surface participation\n                if(!inWater) \n                {\n                    // Force using terrain bounding box normals if the intersection happens on the edge.\n                    vec3 N = t == bounds.x ? boundsN : WaterNormal(terrainUV);\n                    color += ShadeSpecular(L, N, rd, LColor);\n                }\n                inWater = true;\n                // Absorption due to water medium\n                absorption *= vec3(DistanceAttenuation(25.0, tStep), DistanceAttenuation(12.0, tStep), DistanceAttenuation(10.0, tStep)); \n            }else{\n                inWater = false;\n            }\n            #endif\n            if(ph < h) \n            {\n                // We refine the intersection point with the surface.\n                // Should be done with water surface but I was in a hurry\n                float x = 1.0 - (prevH-prevPH) / (ph-prevPH-h+prevH);\n                tMax = t - x*tStep;\n                p -= pStep * x;\n                terrainUV = p.xz * toTerain;\n                datas = TerrainData(terrainUV);\n                \n                vec3 N = t == bounds.x ? boundsN : TerrainNormal(terrainUV);\n                vec3 albedo = TerrainAlbedo(vec3(p), datas);\n                color += ShadeSurface(albedo, L, N, -rd, LColor) * absorption ;\n                break;\n            }\n            if(p.y > 0.8 && p.y < 0.9)\n            {\n                float density = SampleClouds(terrainUV, p.y) * 30.0;\n                if(density > 0.0){\n                    // Absorption due to cloud medium\n                    float Tr   =  DistanceAttenuation(density, tStep);\n                    float Tr2 = 1.0;\n                    // Compute absorbed light to current sample point\n                    for(int i = 0 ; i < 10 ; i++)\n                    {\n                        vec3 cloudP = p + L * float(i) * 0.005;\n                        float cloudDensity = SampleClouds( cloudP.xz * toTerain, cloudP.y) * 30.0;\n                        Tr2 *= DistanceAttenuation(cloudDensity, 0.01);\n                    }\n                    // Cloud scattering\n                    vec3 Scat = Tr2 * (5.0*LColor) * density * PhaseFunction(0.8,-0.2,0.5,dot(L, rd)); \n\n                    color += absorption * ((Scat-Scat*Tr) / density);\n                    absorption *= vec3(Tr);\n                }\n                \n            }\n            \n            prevPH = p.y;\n            prevH = h;\n            p += pStep; \n            terrainUV += terrainUVVar;\n\n        }\n        \n        // If no intersection occured render sky\n        if(tMax == bounds.y) \n        {\n            color += sky(rd) * absorption;\n        }\n        \n    }else{ // Render sky color\n        color = sky(rd);\n    }\n    \n\treturn color;    \n}\n\n\n// Main - Setup camera and trace ray\n////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float terrainResolution = min(min(iResolution.x, iResolution.y), float(MAX_TERRAIN_SIZE));\n    vec2 toTerain = (terrainResolution-1.0)/iResolution.xy;\n    \n    // Create Ray (iquilez)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\t\n\tfloat fov = 2.0;\n\tfloat dist = 1.4 - 1.4*iMouse.y/iResolution.y;\n\tfloat an = -0.7 + 2.0*3.141592*iMouse.x/iResolution.x - 0.3*iTime;\n\tvec3 ro = vec3( dist*cos(an), 0.0, dist*sin(an) ) + vec3(0.5, 1.2, 0.5); //1.2\n    vec3 ta = vec3( 0.5, 0.25, 0.5 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n    \n    vec3 color = TraceRay(ro, rd);\n    \n        \n    fragColor = vec4(color, 1.0);\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////\n// BUFFER A\n////////////////////////\n// FragColor => (Rock Height, Sand, Vegetation, water)\n// Compute initial heightmap from frame 0 to START_FRAME\n// Then weather it for until the end of times.\n\n#if 1\n        const int neighnorsCount = 9;\n        const ivec2 neighbors[9] = ivec2[](\n            ivec2(-1, -1), ivec2(-1,  0), ivec2(-1,  1), \n            ivec2( 0, -1), ivec2( 0,  0), ivec2( 0,  1), \n            ivec2( 1, -1), ivec2( 1,  0), ivec2( 1,  1)\n\t\t);\n        const float weights[9] = float[](\n            0.077847, 0.123317, 0.077847,\n            0.123317, 0.195346,\t0.123317, \n            0.077847, 0.123317, 0.077847\n        );\n        #else\n\t\tconst int neighnorsCount = 25;\n        const ivec2 neighbors[25] = ivec2[](\n            ivec2(-2, -2), ivec2(-2, -1), ivec2(-2, 0), ivec2(-2, 1), ivec2(-2, 2), \n            ivec2(-1, -2), ivec2(-1, -1), ivec2(-1, 0), ivec2(-1, 1), ivec2(-1, 2), \n            ivec2( 0, -2), ivec2( 0, -1), ivec2( 0, 0), ivec2( 0, 1), ivec2( 0, 2), \n\t\t\tivec2( 1, -2), ivec2( 1, -1), ivec2( 1, 0), ivec2( 1, 1), ivec2( 1, 2), \n\t\t\tivec2( 2, -2), ivec2( 2, -1), ivec2( 2, 0), ivec2( 2, 1), ivec2( 2, 2)\n        );\n        const float weights[25] = float[](\n            0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n            0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n            0.023792, 0.094907, 0.150342, 0.094907, 0.023792, \n            0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n            0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n        );\n#endif\n\n\n\n\n\n\n// Credit to haqreu\n// https://www.shadertoy.com/view/wsXyD8\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n\n// INITIAL TERRAIN HEIGHMAP GENERATION\nvec4 terrainHeightMap(vec2 terrainUV)\n{\n    vec4 data = vec4(0.0);\n    \n    float terrainHeight = 0.0;\n    \n    \n\tvec4 C = texture(iChannel3, terrainUV);\n    float baseH = (C.x + C.y + C.z)/3.0;        \n\n    float jfigHeight = 0.0;\n    \n    const float offset = 0.05;\n    const float size = 0.2;\n    if(terrainUV.x < (1.0-offset) && (1.0-terrainUV.y) > offset && terrainUV.x > (1.0-size-offset) && (1.0-terrainUV.y) < (size+offset))\n    {\n        vec2 jfigUV = vec2(remap(terrainUV.x, 1.0-size-offset, 1.0-offset, 1.0, 0.0), remap(1.0-terrainUV.y, size+offset, offset, 0.0, 1.0));\n        \n        jfigHeight = jfig(uint(jfigUV.x * float(JFIGW)), uint(jfigUV.y* float(JFIGH))) ? 1.0 : 0.0;\n        jfigHeight = jfigHeight * 0.005 + remap(terrainUV.y, 0.7, 0.9, 0.1, 0.2);\n        terrainHeight = 0.11 + jfigHeight;\n        data.y = 0.005;\n    }else{        \n    \tterrainHeight = 0.1 + 0.2 * baseH + gaussian(length(terrainUV*2.0-1.0), 0.5)*(0.2 + baseH);\n    }\n    data.x = terrainHeight;\n    data.w = clamp(SEA_LEVEL-TerrainHeight(data), 0.0, 1.0);\n    return data;\n}\n\nvec4 terrainTestHeightMap(vec2 terrainUV)\n{\n    \n    return vec4(0.1 + (terrainUV.x > 0.5 ? 0.0 : 0.1), (terrainUV.y > 0.5 ? 0.0 : 0.1), 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //MAX_TERRAIN_SIZE\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 samplePos = ivec2(fragCoord);\n    \n    int terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    \n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if(iFrame < START_FRAME){\n        \n        ///////////////////////\n        /// INITIAL TERRAIN CREATION\n        ///////////////////////\n        vec2 terrainUV = vec2(samplePos)/vec2(terrainDef);\n        vec4 data = terrainHeightMap(terrainUV);\n        //data = terrainTestHeightMap(terrainUV);\n        \n        fragColor = data;\n    \n    \n    }else{\n        ///////////////////////\n        /// EVOLUTION\n        ///////////////////////\n        \n        vec4 data = texelFetch(iChannel0, samplePos, 0);\n        float groundHeight = TerrainHeight(data);\n        float totalHeight = groundHeight + data.w;\n        float waterVariation = 0.0;\n        float sandVariation = 0.0;\n        for(int i = 0 ; i < neighnorsCount ; i++)\n        {\n            ivec2 nPos = clamp(samplePos + neighbors[i], 0, terrainDef-1);\n            vec4 nData = texelFetch(iChannel0, nPos, 0);\n            \n            float nGroundHeight = TerrainHeight(nData);\n            float nTotalHeight = nGroundHeight + nData.w;\n            \n            float hDiff = nTotalHeight - totalHeight;\n            if(hDiff < 0.0){\n                hDiff = max(hDiff, -data.w);\n            }else{\n                hDiff = min(hDiff, nData.w);\n            }\n            waterVariation += hDiff * weights[i];\n            \n            \n            float GroundhDiff = nGroundHeight - groundHeight;\n            if(GroundhDiff < 0.0){\n                GroundhDiff = max(GroundhDiff, -data.y);\n            }else{\n                GroundhDiff = min(GroundhDiff, nData.y);\n            }\n            sandVariation += GroundhDiff * weights[i];\n            \n            \n        }\n        \n        // WATER MOVEMENT\n        data.w += waterVariation;\n        \n        // SAND MOVEMENT\n        data.y = max(data.y + sandVariation * SAND_MOVEMENT_RATE, 0.0);\n        \n        // ERROSION (Due to the strength of water movement)\n        float soilErrosion = abs(waterVariation * ERROSION_RATE);\n        data.y += soilErrosion;\n        data.x = max(data.x - soilErrosion, 0.0);\n        \n        \n        \n\t\t\n        // VEGETATION FORMATION\n        vec3 N = normalize(texelFetch(iChannel1, samplePos, 0).xyz);\n\t\tfloat NdotUp = max(dot(N, vec3(0.0, 1.0, 0.0)), 0.0);\n        if(NdotUp > 0.8 )\n        {\n            float v = remap(NdotUp, 0.8, 1.0, 0.0, 1.0) * data.w * max(min(data.y, VEGETATION_FORMATION_RATE), 0.0);\n            data.y -= v;            \n            data.z += v;\n        }\n        \n        // WATER ABSORPTION BY VEGETATION\n        float waterAbsorption = data.z * VEGETATION_ABSORPTION_RATE;\n        data.w -= waterAbsorption;\n\n        if(data.y < data.w) // More water than vegetationit dies\n        {\n            float dyingVegetation = min(VEGETATION_DRAWNING_RATE, data.z);\n        \tdata.y += dyingVegetation;            \n            data.z -= dyingVegetation;\n        }\n        \n        // WATER EVAPORATION\n        data.w = max(data.w - EVAPORATION_RATE*iTimeDelta, 0.0);\n        \n        // RAIN\n        float clouds = texelFetch(iChannel1, samplePos, 0).x;\n        data.w += clouds * RAINFALL_RATE * iTimeDelta;\n        \n        //data.w = max(data.w, clamp(SEA_LEVEL-groundHeight, 0.0, 1.0));\n        \n        fragColor = data;\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////\n// Common\n////////////////////////\n#define START_FRAME 100\n#define MAX_TERRAIN_SIZE 512\n\n\n// SIMULATION PARAMETERS\n////////////////////////\n#define EVAPORATION_RATE 0.003\n#define RAINFALL_RATE 0.008\n#define VEGETATION_ABSORPTION_RATE 0.001\n\n#define SEA_LEVEL 0.25\n\n#define ERROSION_RATE 0.1\n\n#define SAND_MOVEMENT_RATE 0.1\n\n#define VEGETATION_FORMATION_RATE 0.04\n#define VEGETATION_DRAWNING_RATE 0.02\n\n// UTILITIES\n////////////////////////\nfloat TerrainHeight(vec4 terrainData)\n{\n    return terrainData.x +  terrainData.y +  terrainData.z;\n}\n\nfloat WaterHeight(vec4 terrainData)\n{\n    return terrainData.x +  terrainData.y +  terrainData.z +  terrainData.w;\n}\n\n\nfloat remap(in float value, in float original_min, in float original_max, in float new_min, in float new_max)\n{\n    return new_min + (((value - original_min) / (original_max - original_min)) * (new_max - new_min));\n}\n\nfloat gaussian(float d, float sigma)\n{\n    return(1.0/(sigma*sqrt(2.0*3.141592)))*exp(-(d*d)/(2.0*(sigma*sigma)));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n////////////////////////\n// BUFFER D - TERRAIN NORMALS COMPUTATION\n////////////////////////\n// Compute terrain normal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 samplePos = ivec2(fragCoord);\n    \n\tint terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\tivec2 nL = clamp(samplePos - ivec2(1, 0), 0, terrainDef-1);\t\n    ivec2 nR = clamp(samplePos + ivec2(1, 0), 0, terrainDef-1);\n\tivec2 nD = clamp(samplePos - ivec2(0, 1), 0, terrainDef-1);\n\tivec2 nU = clamp(samplePos + ivec2(0, 1), 0, terrainDef-1);\n    \n    float hL = TerrainHeight(texelFetch(iChannel0, nL, 0));\n    float hR = TerrainHeight(texelFetch(iChannel0, nR, 0));\n    float hD = TerrainHeight(texelFetch(iChannel0, nD, 0));\n    float hU = TerrainHeight(texelFetch(iChannel0, nU, 0));        \n    \n    float fac = 0.5 * float(terrainDef);\n    \n    vec3 N = vec3((hL-hR)*fac, 1.0, (hD-hU)*fac);\n    \n    fragColor = vec4(normalize(N), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n////////////////////////\n// BUFFER B\t- COMPUTE CLOUD MAP\n////////////////////////\n\n// Noise function from Inigo Quilez\n// https://iquilezles.org/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat w1( in vec3 x )\n{\n    float dx = noise(x+vec3(6.53, 21.932, 21.123));\n    float dy = noise(x+vec3(9.77, 7.34, 3.1));\n    float dz = noise(x+vec3(3.91, 71.73, 8.23));\n    return noise(x+vec3(dx, dy, dz));\n}\n\nfloat weatherMap( in vec2 x )\n{\n    return 0.5 * w1(vec3(x*5.0, iTime*0.25)) + 0.25 * w1(vec3(x.yx*10.0, iTime*0.2)) + 0.125 * w1(vec3(x.yx*20.0, iTime*0.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 samplePos = ivec2(fragCoord);\n    \n\tint terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    vec2 uv = fragCoord / vec2(terrainDef);\n    \n    float v = clamp(weatherMap(uv+vec2(iTime*0.5)), 0.0, 1.0);\n    \n    fragColor = vec4(v, v, v, 1.0);\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n////////////////////////\n// BUFFER C - WATER NORMALS COMPUTATION\n////////////////////////\n//Water Normal\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 samplePos = ivec2(fragCoord);\n    \n\tint terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\tivec2 nL = clamp(samplePos - ivec2(1, 0), 0, terrainDef-1);\t\n    ivec2 nR = clamp(samplePos + ivec2(1, 0), 0, terrainDef-1);\n\tivec2 nD = clamp(samplePos - ivec2(0, 1), 0, terrainDef-1);\n\tivec2 nU = clamp(samplePos + ivec2(0, 1), 0, terrainDef-1);\n    \n    float hL = WaterHeight(texelFetch(iChannel0, nL, 0));\n    float hR = WaterHeight(texelFetch(iChannel0, nR, 0));\n    float hD = WaterHeight(texelFetch(iChannel0, nD, 0));\n    float hU = WaterHeight(texelFetch(iChannel0, nU, 0));        \n    \n    //Water surface perturbation tests\n    #if 0\n    \thL += 0.005 * sin(float(samplePos.x - 1)*0.05+iTime);    \n    \thR += 0.005 * sin(float(samplePos.x + 1)*0.05+iTime);\n\t\thD += 0.005 * cos(float(samplePos.y - 1)*0.05+iTime);    \n    \thU += 0.005 * cos(float(samplePos.y + 1)*0.05+iTime);\n    #endif \n    \n    float fac = 0.5 * float(terrainDef);\n    \n    vec3 N = vec3((hL-hR)*fac, 1.0, (hD-hU)*fac);\n    \n    fragColor = vec4(normalize(N), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}