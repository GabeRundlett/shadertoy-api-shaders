{
    "Shader": {
        "info": {
            "date": "1630697886",
            "description": "super quick experiment at zooming just a region of the MS.\nclick on an interesting spot and drag around.",
            "flags": 32,
            "hasliked": 0,
            "id": "NscGDX",
            "likes": 8,
            "name": "mandel magnifier",
            "published": 3,
            "tags": [
                "mandelbrotzoom"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "vec2 complexMul(in vec2 A, in vec2 B) {\n  return vec2((A.x * B.x) - (A.y * B.y), (A.x * B.y) + (A.y * B.x));\n}\n\n// adapted from IQ. I may have messed this up.\n// https://iquilezles.org/articles/distancefractals\nfloat mandelDist(in vec2 c, float numIters)\n{\n  vec2  z = vec2(0.0, 0.0);\n  vec2 dz = vec2(0.0, 0.0);\n  \n  float m2;\n  for (float n = 0.0; n < numIters; ++n) {\n    dz = 2.0 * complexMul(z, dz) + vec2(1.0, 0.0);\n    z  = complexMul(z, z) + c;\n\n    m2 = dot(z, z);\n    if (m2 > 1.0e10) {\n      break;\n    }\n  }\n  \n  return sqrt(m2 / dot(dz, dz)) * 0.5 * log(m2);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float canvasZoom = 0.8;\n    float smoothEpsilon = 5.0 / RESMIN / canvasZoom;\n    \n    vec4 ioData = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 rawMouse = ioData.xy;\n\n    \n    vec2 p1 = (XY       - RES.xy / 2.0) / RESMIN * 2.0 / canvasZoom;\n    vec2 m  = (rawMouse - RES.xy / 2.0) / RESMIN * 2.0 / canvasZoom;\n    \n    if (length(iMouse.xy / RESMIN) <  0.2) {\n        // auto\n        float t = iTime * 0.1;\n        float r = 0.7;\n        m.x  = cos(t * 1.00) * r + 0.25;\n        m.y  = sin(t * 1.00) * r;\n        m.x += cos(t * 0.21) * r * 0.1;\n        m.x += sin(t * 0.21) * r * 0.1;\n    }\n    \n    float magnificationPower = 2000.0;\n    \n    m .x -= 0.5;\n    p1.x -= 0.5;\n    \n    // todo: use gradient of mandelbrot to nudge focus towards the set.\n\n    vec2 p2 = p1;\n    p2 -= m;\n    p2 /= magnificationPower;\n    p2 += m;\n    \n    float overallBulgeSize = 1.0;\n    float q = smoothstep(0.0, overallBulgeSize, length(p1 - m));\n    \n    // more iterations with higher zoom\n    const float minIters =   100.0;\n    const float maxIters = 10000.0;    \n    float iters = floor(mix(maxIters, minIters, pow(q, 0.5)) / 2.0) * 2.0;\n\n    float regionOfMaxZoom = 5.0;\n    q = pow(q, regionOfMaxZoom);\n    \n    vec2 p = mix(p2, p1, q);\n    \n    \n    float d = smoothstep(0.0, smoothEpsilon, abs(length(p) - 1.0));\n    \n    d = mandelDist(p, iters);\n    d = pow(d, 0.1);\n    d = sin(d) * 0.5 + 0.5;\n    \n    // grid\n    vec2 g = fract(p * 2.0 + 0.5) - 0.5;\n    d *= minComponent(0.8 + 0.2 * smoothstep(0.0, smoothEpsilon, abs(g)));\n    \n    RGBA = vec4(vec3(d), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution)\n#define RESMIN (min(RES.x, RES.y))\n\nfloat minComponent(in vec2 v) {\n    return min(v.x, v.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// mouse smoothing\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA = texelFetch(iChannel0, IJ, 0);\n    vec4 mb = texelFetch(iChannel0, ivec2(1), 0);\n    \n    bool mouseIsDown  = iMouse.z > 1.0;\n    bool mouseWasDown = mb.x > 0.5;\n    \n    if (iFrame < 2) {\n        RGBA.xy = iMouse.xy;\n    }\n \n     if (IJ == ivec2(0)) {\n        // tuned for 60fps\n        \n        if (mouseIsDown) {\n            if (!mouseWasDown) {\n                RGBA.zw = iMouse.xy;\n            }\n            \n            vec2 d = iMouse.xy - RGBA.zw;\n            \n            if (!mouseWasDown && length(RGBA.xy - RGBA.zw) > RESMIN * 0.2) {\n                RGBA.xy = RGBA.zw;\n            }\n            else {            \n                RGBA.xy += d * 0.0001;\n            }\n        }\n     }\n     else if (IJ == ivec2(1)) {\n         RGBA.x = mouseIsDown ? 1.0 : 0.0;\n     }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}