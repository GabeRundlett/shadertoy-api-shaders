{
    "Shader": {
        "info": {
            "date": "1717837806",
            "description": "copypast and combination",
            "flags": 0,
            "hasliked": 0,
            "id": "MXV3Ww",
            "likes": 3,
            "name": "go to the eye of end",
            "published": 3,
            "tags": [
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nnew",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat DEG2RAG = .0174532925199;\n\n#define time iTime\n#define resolution iResolution.xy\\\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 11\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st+.2+fract(iTime));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 eye(in vec3 bg_color, in vec2 p, in vec2 q, float radius) {\n  p.x *= resolution.x / resolution.y;\n  vec3 color = vec3(0.);\n  float r2 = sqrt(dot(p, p));\n  float a = atan(p.y, p.x);\n//  vec3 bg_color = color;\n  if (r2 < radius) {\n\n    // color principal iris\n    color = vec3(0.0, 0.3, 0.4*.2+fract(iTime));\n    float f = fbm(9.0*p*cos(iTime));\n    color = mix(color, vec3(0.2, 0.5, 0.4), f);\n\n    // componente amarillo alrededor de pupila\n    f = 1.0 - smoothstep(.2, .5, r2);\n    color = mix(color, vec3(.9, .6, .2), f);\n\n    a += 0.05 * fbm(20. * p);\n\n    //lineas blancas iris\n    f = smoothstep(.3, 1., fbm(vec2(6.*r2, 20. * a)));\n    color = mix(color, vec3(1.), f);\n\n    // lineas negras iris\n    f = smoothstep(.4, .9, fbm(vec2(8.*r2, 10.*a)));\n    color *= 1. - .5* f;\n\n    // sombreado exterior\n    f = smoothstep(.6, .8, r2);\n    color *= 1. - .5* f;\n\n    //pupila\n    f = smoothstep(.2, .25, r2);\n    color *= f;\n\n    f = smoothstep(0., .15 , r2);\n    color =  mix(color, vec3(.8, 1., 0.), 1. -f);\n\n    // borde externo\n    f = smoothstep(.75, .8, r2);\n    color = mix(color, bg_color, f);\n  } else {\n color = bg_color;\n  }\n\nreturn color;\n\n}\nfloat tri2(vec2 pos)\n{\nfloat a = dot(pos, vec2(sin( 60.0*DEG2RAG), cos( 60.0*DEG2RAG)));\nfloat b = dot(pos, vec2(sin(-60.0*DEG2RAG), cos(-60.0*DEG2RAG)));\nfloat c = -pos.y;\nfloat d = 0.2*cos(60.0*DEG2RAG);\n\nfloat u1 = a - d*0.25;\nfloat v1 = b - d*0.25;\nfloat w1 = c - d*0.25;\n\nfloat u2 = c + d*1.25;\nfloat v2 = b + d*1.25;\nfloat w2 = a + d*1.25;\n\nfloat t1 = min(u2, min(u1, v1));\nfloat t2 = min(v2, min(w1, u1));\nfloat t3 = min(w2, min(v1, w1));\n\nfloat res = max(max(t1, t2), t3);\nreturn 0.002/abs(res);\n}\n\n\nfloat tri(vec2 pos)\n{\nfloat a = dot(pos+sin(iTime), vec2(sin( 90.0*DEG2RAG), cos( 60.0*DEG2RAG)));\nfloat b = dot(pos+cos(iTime), vec2(sin(-60.0*DEG2RAG), cos(-60.0*DEG2RAG)));\nfloat c = -pos.y+cos(iTime);\n\nfloat result = 0.002/abs(min(min(0.01511-a,0.105-b), 0.1505-c));\nreturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\nvec2 pos = (2.0*gl_FragCoord.xy - resolution.xy)/max(resolution.x, resolution.y) / 16.0;\nvec2 st = gl_FragCoord.xy/resolution.xy*3.;\n    // st += st * abs(sin(u_time*0.1)*3.0);\n    vec3 color = vec3(1.0,0,0);\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(pos.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\n   \nmat2 ma = mat2(co, si, -si, co);\n    pos.xy*=ma;\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.01*time);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*time );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*time);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                //vec3(0.,0,.1),\nclamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n              //  vec3(0., 0,0.4),\nclamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n//   vec3(1., 0,0),\nclamp(length(r.x),0.0,1.0));\nq = gl_FragCoord.xy / resolution.xy;\nvec2 p =  vec2(-1.0, -1.0) + 2.0 * q ;\ncolor *= f*f*f*f+.6*f*f*f+.5*f*f;\ncolor = eye(color, p, q, 0.8);\n//rotate & zoom\nmat2 rot = mat2(cos(time),-sin(time),\nsin(time), cos(time));\n       \n\nfloat zoom = 1.0/(mod(-time, 1.0)+1.0)*3.0-1.0;\npos *= zoom;\n\n//effect\nvec3 result = vec3(0.0);\nfor(int i = 0 ; i < 6 ; i++)\n{\nresult += vec3(tri(pos), tri(-pos*0.5), tri2(pos));\npos /= 0.25;\n}\nfragColor = vec4( mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0,1.0), result.x)\n   +mix(vec3(0.0, 0.0, 0.0), vec3(0.5,0.25,0.0), result.y)\n   +mix(vec3(0.0, 0.0, 0.0), vec3(0.0,0.5,0.1), result.z)+  color, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}