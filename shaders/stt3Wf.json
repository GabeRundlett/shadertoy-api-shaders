{
    "Shader": {
        "info": {
            "date": "1636884031",
            "description": "Debug Grid IDs in 3D.\nThe grid may be nested, complexly offset, or\nIf they are correlated, this may be useful.\nIn fact, it saved me a lot of trouble.\n\nMore simpler usage scene of sdNumFont() is here:\nhttps://www.shadertoy.com/view/Ntc3Wf",
            "flags": 0,
            "hasliked": 0,
            "id": "stt3Wf",
            "likes": 14,
            "name": "Debug Grid IDs",
            "published": 3,
            "tags": [
                "neighbors"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "vec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv)\n{\n    const float cL = 25.;\n    const vec3 forcus = vec3(0,-5,0);\n    const float fov = .25;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,1.5,0);\n    pos.xz = vec2(0)*cL;\n    pos.xz-=vec2(-iTime,iTime);\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n        \n    \n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// I forgot where I found these bx_cossin()...\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// More simpler usage scene of sdNumFont() is here:\n// https://www.shadertoy.com/view/Ntc3Wf\nfloat sdNumFont(vec3 p, float s, float w, float i) {\n    i = mod(floor(i), 10.); // 0-9\n    vec2 uv = p.xy/s +vec2(i, 12); // Numbers are in 12 row of Font texture.\n    \n    // https://www.shadertoy.com/view/llcXRl\n    // Sample the font texture. Make sure to not use mipmaps.\n    vec4 tx = texture(iChannel0, (uv+.5)*(1./16.));\n    float ch = tx.w - .5 - .025 * min(1.,(w/10.)*2.-1.);\n    \n    vec3 q = abs(p)-vec3(s,s*.8,.15*s)*.5;\n    float bb =  length(max(vec3(0.),q));\n    return max(ch, bb)*.7;\n}\n\nfloat sdID(vec3 p, float id) {\n    float num = id;\n    const float fontSize = .4;\n    const float fontWeight = 8.; // 1 to 10\n    const float spacing = .25;\n    float ppd = sdNumFont(p+vec3(3,0,0)*spacing*fontSize, fontSize, fontWeight, num*.01);\n    float pd = sdNumFont(p+vec3(1,0,0)*spacing*fontSize, fontSize, fontWeight, num*.1);\n    float nd = sdNumFont(p-vec3(1,0,0)*spacing*fontSize, fontSize, fontWeight, num);\n    return min(ppd,min(pd,nd));\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    #if 1\n    float rad = .2;\n    #else // animate radius. they can't move at raius 1.0.\n    float rad = abs(sin(3.14+iTime*.1))*0.9+.1;\n    #endif\n    \n    vec3 q = p;\n    q.xz = mod(q.xz,1.);\n    \n    #if 1 // Spheres.\n        q.y-= rad;\n    #else // Shrink the height. You can see more clearly the range of movement of each sphere.\n        q.y-= rad*.1;\n        q.y*=4.;\n    #endif\n    \n    float speed = 2.;\n    vec3 pm=MAT_ERNST2;\n    for(int i=-1; i<1; i++)\n    for(int j=-1; j<1; j++)\n    {\n        vec2 offset = vec2(i,j);\n        vec3 qq = q;\n        vec2 iqq = floor((p.xz-offset));\n        vec2 rnd = hash22(iqq);\n        \n        qq.xz+=offset;\n        float v =  rnd.x * iTime * speed * sign(rnd.y-rnd.x); \n        vec2 sq = bx_cossin(v)*(1.-rad/* max range is Â±(cellSize-Radius) */);\n        qq.xz+= sq;\n        \n        //qq.y-=.25*abs(sin(rnd.x*3.+iTime*3.*4.)); // jumping. just for fun.\n        \n        #if 0 // reduce population\n        if(rnd.y<.1 || rnd.x<.1)\n        #endif\n        {\n            vec2 iq = abs(floor((p.xz-offset)));\n            iq = vec2(int(iq.x)%2, int(iq.y)%2);\n            float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .05 : .05;\n            vec3 m = (rnd.y<.5) ? (tile<.5)?MAT_ERNST0:MAT_ERNST3 : (tile<.5)?MAT_ERNST1:MAT_ERNST4;\n\n            res = v4OpUnionSmooth(vec4(length(qq)-rad, m), res, .01);\n            /*\n            if(sat(sin(iTime*.5))>0.){\n                //pm = mix(pm,m,.5);\n                res = v4OpUnion(vec4(sdCapsule(qq, vec3(0), vec3(sq.x, -rad, sq.y), .01), m), res);\n                res = v4OpUnion(vec4(length(q+vec3(i,rad,j))-.05, m), res);\n            }\n            //*/\n        }\n    }\n\n    vec2 iqq = floor(p.xz);\n    vec2 rnd = hash22(iqq);\n    res = v4OpUnion(vec4(sdID(q-vec3(.5,.3,.5), iqq.x),vec3(0.996,0.224,0.224)), res);\n    res = v4OpUnion(vec4(sdID(q-vec3(.5,.0,.5), iqq.y),vec3(0.149,0.788,0.192)), res);\n\n    vec2 iq = abs(floor((p.xz)));\n    iq = vec2(int(iq.x)%2, int(iq.y)%2);\n    float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .85 : .85; \n    res = v4OpUnion(vec4(p.y, pm*tile),res);\n    \n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION+ZERO; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+ZERO; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < 20; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 8;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv;\n\n\tfloat ao = 0.0;\n\n\tfor( int i=ZERO; i<nbIte+ZERO; i++ ){\n\t\tfloat l = hash11(float(i)+maxDist*falloff)*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l+maxDist+falloff )*rad)*l;\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n\t\tfloat shininess = .5;\n\t\tfloat intensity = .05;\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\t//renDat.ao = ambientOcclusion(p, renDat.normal, .1, 1.5);\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .5, 1.5);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 2., 4.);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 4., 8.);\n\t\trenDat.ao = smoothstep(-0.3, 1.5, renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\n\t\t#define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\t\tfloat spec = ggx(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST*3.5;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid init(){\n    cam0.position = vec3(-26.9963, 88.0527, -48.4978);\n\tcam0.quaternion = vec4(0.2949, -0.0793, -0.2473, 0.9196);\n\tcam0.fov = 0.2;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(-0.0875, 0.7071, -0.3935));\n\tlit0.color = vec3(2.5372, 2.3575, 1.8639);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.5875, -0.7071, 0.3935));\n\tlit1.color = vec3(0.214, 0.1892, 0.1329);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    renDat.result.rgb = sms(-.01,.9,renDat.result.rgb);\n\trenDat.result = pow(renDat.result, vec3(1./2.2));\n\tfragColor = vec4(renDat.result, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(1.000,0.980,0.400)\n#define MAT_ERNST1 vec3(1.000,0.424,0.361)\n#define MAT_ERNST2 vec3(0.631,0.525,0.408)\n#define MAT_ERNST3 vec3(0.322,0.773,1.000)\n#define MAT_ERNST4 vec3(0.345,0.976,0.502)\n#define AMB_COL vec3(0.6921, 0.8636, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL AMB_COL\n#define FOG_START 0.0\n#define FOG_POW 1.85\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n\n\t// iq:\n\t//float h = max(r-abs(a-b),0.0);\n\t//return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\n\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// Phong specular\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 reflect_light = normalize(reflect(ld, n));\n\treturn pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\treturn 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tvec3 h  = normalize(-vd+ld);\n\treturn 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// https://www.shadertoy.com/view/3ssSz2\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat originalSigmoidContrast(float color, float contrast, float mid){\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\nvec3 originalSigmoidContrast(vec3 color, float contrast, float mid){\n\tcolor.r = originalSigmoidContrast(color.r, contrast, mid);\n\tcolor.g = originalSigmoidContrast(color.g, contrast, mid);\n\tcolor.b = originalSigmoidContrast(color.b, contrast, mid);\n\treturn color;\n}\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}