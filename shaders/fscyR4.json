{
    "Shader": {
        "info": {
            "date": "1653050301",
            "description": "Default Julia Set: z = z^2 + c\nHold the mouse in the canvas to generate Julia for c seed corresponding to the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "fscyR4",
            "likes": 3,
            "name": "Custom Julia",
            "published": 3,
            "tags": [
                "julia",
                "mandelbrot",
                "complex"
            ],
            "usePreview": 0,
            "username": "Fraktoler",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "#define MAX_ITER 256\n#define BAILOUT 256.\n#define normalizer vec4(vec3(255.), 400.)\nconst vec4 palette[] = vec4[](\nvec4(0., 7., 100., 0.) / normalizer,\nvec4(32., 107., 203., 64.) / normalizer,\nvec4(237., 255., 255., 168.) / normalizer,\nvec4(255., 170., 0., 257.) / normalizer,\nvec4(0., 2., 0., 343.) / normalizer,\nvec4(0., 7., 100., 400.) / normalizer\n);\n\nvec3 gradient(float x) {\n    int m = palette.length() - 2;\n    while (m > 0) {\n        if (x > palette[m].w) break;\n        else if (x == palette[m].w) return palette[m].rgb;\n        m--;\n    }\n    return mix(palette[m].rgb, palette[m + 1].rgb, smoothstep(palette[m].w, palette[m + 1].w, x));\n}\n\nvec2 toComplex(float zoom, vec2 center, vec2 pixel) {\n    return zoom * (pixel - .5 * iResolution.xy) / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.;\n    vec2 center = vec2(0.0);\n    vec2 uv = toComplex(zoom, center, fragCoord);\n    float r;\n    vec2 c, z = uv;\n    if (iMouse.z > 0.001) {\n        c = toComplex(zoom, center, iMouse.xy);\n    } else {\n        c = cis(iTime * pi * 0.1);\n    }\n    int k = 0;\n    float exponent = 3.0;\n    while (k < MAX_ITER) {\n        r = dot(z, z);\n        if (r > BAILOUT) break;\n        z = power(z, exponent) + c;\n        k++;\n    }\n    vec3 col = vec3(0.);\n    if (k != MAX_ITER) {\n        float invln = 1. / log(exponent);\n        float lnlnb = log(log(BAILOUT));\n        float u = 0.7 * log(float(k) + invln*lnlnb - invln*log(.5 * log(r))) - 0.4;\n        col = gradient(fract(u));\n    }\n    fragColor = vec4(col * col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n linearroot(a, b) = -b / a (Solution of a * z + b = 0)\n gamma(z) (Gamma function)\n*/\n#define one vec2(1., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(vec2(2.0, 0.0), powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(vec2(2.0, 0.0), powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 linearroot(in vec2 a, in vec2 b) {\n    return div(-b, a);\n}\n\nvec2 gamma(in vec2 z) {\n    //https://www.shadertoy.com/view/WtlGDN\n    const float[6] p = float[] (2.506628275635, 225.525584619175, -268.295973841305, 80.9030806934622, -5.007578639705, 0.0114684895435);\n    vec2 zz = z.x > 1. ? z : one - z;\n    vec2 m = vec2(p[0], 0.);\n    for (int k = 1; k < p.length(); k++) {\n        m = m + p[k] * recip(zz + vec2(k, 0.));\n    }\n    vec2 zh = zz + vec2(5.65, 0.0);\n    vec2 w = powexp(ln(m) + mul(zz + vec2(.5, 0.), ln(zh)) - ln(zz) - zh);\n    return z.x > 1. ? w : pi * recip(mul(w, sine(pi * z)));\n}\n\n//vec2 W0(in vec2 z) {\n//    //https://www.shadertoy.com/view/3lsGD4\n//    vec2 v = sqrtp(2. * e * (z - i * 0.3678796) + 2.);\n//    vec2 w = 2. * ln(one + 0.8842 * v);\n//    return div(w - ln(one + 0.9294 * ln(one + 0.5106 * v)) - vec2(1.213, 0.), one + recip(w + vec2(4.69483568, 0.)));\n//}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}