{
    "Shader": {
        "info": {
            "date": "1684534595",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\n[truchet discover team alpha]",
            "flags": 0,
            "hasliked": 0,
            "id": "ctG3WG",
            "likes": 39,
            "name": "Year of Truchets #021",
            "published": 3,
            "tags": [
                "raymarching",
                "torus",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #021\n    05/19/2023  @byt3_m3chanic\n    Can't stop - won't stop | Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    35.\n\n// globals & const\nmat2 r90,spin;\nconst vec3 size = vec3(1.);\nconst vec3 sz2 = size*2.;\nconst vec3 hlf =  size/2.;\nconst float thick = .0275;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.73,59.71+iDate.z)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b; return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y); return length(q)-t.y;\n}\n\nvec3 hp,hit;\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    \n    //@mla inversion\n    float k = 5.0/dot(p,p); \n    p *= k;\n    p +=vec3(hlf.xy,T*.3);\n\n    vec3 q = p;\n    vec3 id = floor((q + hlf)/size);\n    q = mod(q+hlf,size)-hlf;\n    \n    //3D every other\n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n\n    float hs = hash21(id.xz+id.y);\n    if(hs>.85) { q.yz*=r90; } else if(hs>.65) { q.xz*=r90; } else if(hs>.45) { q.xy*=r90; }\n\n    vec2 d3 = vec2(length(q.xy-hlf.xy), length(q.xy+hlf.xy));\n    vec2 gy = d3.x<d3.y ? vec2(q.xy-hlf.xy) : vec2(q.xy+hlf.xy);\n    vec3 tz = vec3(gy.xy,q.z);\n    \n    float xhs = fract(2.31*hs+id.y);\n    float trh = 1e5, trx = 1e5, srh = 1e5, dre = 1e5, jre=1e5;\n\n    if(chk>.5){\n        trh = min(cap(q.zyx,hlf.z,thick),cap(q,hlf.x,thick));\n        trh = max(trh,-(length(q)-(hlf.x*.45)));\n        trh = min(trs(q,vec2(hlf.x*.45,thick)),trh);\n        dre = length(q.xz)-thick;\n        trx = min(dre,trh);\n    } else{\n       jre = trs(tz.yzx,vec2(hlf.x,thick));\n       dre = length(q.xy)-thick;\n       srh = min(dre,jre);\n    }\n\n    if(trx<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        hp = q;\n        if(dre<trh) { mt = mt+5.; hp = q;}\n        res = vec2(trx,mt);\n        \n    } \n    \n    if(srh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        hp = tz;\n        if(dre<jre){ mt = mt+5.; hp = q.xzy;}\n        res = vec2(srh,mt);\n    } \n\n    float ck = thick*.65, cr = thick*2.;\n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),ck,cr);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),ck,cr),crt);\n    crt = min(cap(vec3(q.xz,abs(q.y))-vec3(0,0,hlf),ck,cr),crt);\n\n    if(crt<res.x) {\n       res = vec2(crt,1.);\n    } \n\n    // compensate for the scaling that's been applied\n    float mul = 1./k;\n    res.x = res.x* mul / 1.5;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    r90 = rot(1.5707);\n    spin = rot(T*.1);\n    \n    float vv = uv.y+.3+(.05*sin(uv.x*6.));\n    vec3 fog = mix(vec3(.025,.1,.2),vec3(.5),clamp(vv,0.,1.));\n    \n    vec3 ro = vec3(0,0,1);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    ro.xy *= spin; rd.xy *= spin;\n\n    vec3 C = vec3(.0), p = ro;\n    float m = 0., d = 0.;\n    \n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<d*MIN_DIST||d>MAX_DIST)break;\n        d += i<32? ray.x*.3: ray.x*.8;\n        m  = ray.y;\n    } \n    \n    hit=hp;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-hlf.x,sz2.y+hlf.y,sz2.z);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.0001,.99);\n        float spec = pow(max(dot(reflect(l, n),rd),.001),14.)*2.;\n\n        vec3 h = vec3(.0);\n\n        if(m==1.) {h=vec3(.25);}\n        if(m==2.) {h=vec3(.89,.37,.03);}\n        if(m==3.) {h=vec3(.22,.44,.77);}\n        if(m==4.) {h=vec3(1);}\n        if(m==5.) {h=vec3(.025);}\n        \n        if(m>5.) {\n            vec3 hp = hit;\n            //@Fabrice uv for the cylinder \n            vec2 uv   = vec2(atan(hp.z,hp.x)/PI2,hp.y);\n\n            float px  = .01;\n            vec2 scale= vec2(8.,42.);\n            vec2 grid = fract(uv.xy*scale)-.5;\n            vec2 id   = floor(uv.xy*scale);\n            float rnd = hash21(id);\n            if(rnd>.5) grid.x*=-1.;\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n            vec2 d2 = vec2(length(grid-.5),length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5):vec2(grid+.5);\n\n            float xck = length(gx)-.5;\n            float center = (rnd>.5 ^^chk>.5)? smoothstep(-px,px,xck):smoothstep(px,-px,xck);\n            h = mix(h, vec3(.2),center);\n            C = h*diff;\n        } else {\n            C =clamp(h*diff+spec,vec3(0),vec3(1));\n        }\n    }\n\n    C = mix(C,fog,1.-exp(-20.*d*d*d));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}