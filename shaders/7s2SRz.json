{
    "Shader": {
        "info": {
            "date": "1619611215",
            "description": "Notable changes:\n- Smooth blending of water and other materials.\n- Performance improvements.\n- Increased delta for water normal to reduce artifacting.\n- Added some compositions featuring smooth blending.",
            "flags": 0,
            "hasliked": 0,
            "id": "7s2SRz",
            "likes": 3,
            "name": "Light in the Dark: Forked-RogerB",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "water",
                "bridge"
            ],
            "usePreview": 0,
            "username": "RogerB",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// Raymarcher adapted from implementation by Inigo Quilez\n\n#define GAMMA_CORRECTION\n#define MOTION\n#define DISTANCE_FOG\n\n// Material aliases\n#define WATER 0\n#define LAMBERT_RED 1\n#define BLOB 2\n\n// Scene compositions.\n//#define COMPOSITION_0\n//#define COMPOSITION_1\n#define COMPOSITION_2\n\n// Camera Views\n//#define VIEW_0\n#define VIEW_1\n//#define MOUSE_CONTROL\n\n// Water Noise (NO NOISE -> 0, PERLIN -> 1, WORLEY -> 2, IQ -> 3)\n// Iq noise taken from https://www.shadertoy.com/view/4sS3zG.\n#define NOISE 1\n#define SINEWAVES\n\nconst float INFINITY = 99999999999999999.99f;\nconst float PI = 3.14159;\nconst float EPSILON = 0.0001f;\nconst float MIN_CLIP = 0.001f;\nconst float FAR_CLIP = 500.f;\nconst int RAY_STEPS = 256;\nconst int SHADOW_RAY_STEPS = 256;\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat noise3( vec3 p ) {\n    vec3 noise = fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n    return max(noise.x, max(noise.y, noise.z));\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint).xyz * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\t\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat iqNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                              hash( i + vec2(1.0,0.0) ), u.x),\n                         mix( hash( i + vec2(0.0,1.0) ), \n                              hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat almostAbs( float x )\n{\n    return almostIdentity(abs(x), 0.05, 0.025 );\n}\n\nfloat iqNoiseLayered( vec2 p )\n{\n    vec2 q = 0.05*p;\n\tfloat f = 0.0;\n    f += 0.50000*almostAbs(iqNoise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*almostAbs(iqNoise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*almostAbs(iqNoise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*almostAbs(iqNoise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*almostAbs(iqNoise( q ));\n    return 3.7-4.0*f;\n}\n\nbool equals(float a, float b){\n    return abs(a - b) < EPSILON;\n}\n\nbool equalsmargin(float a, float b, float m){\n    return abs(a - b) < m;\n}\n\nvec2 smin(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n// Because the above implementation of smin doesn't work with k=0.\nvec2 hardMin(float a, float b) {\n    return (a<b) ? vec2(a, 0) : vec2(b, 1);\n}\n\nfloat isect( float d1, float d2, float k ) {\n    // float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    // return mix( d2, d1, h ) + k*h*(1.0-h); \n    return -smin(-d1, -d2, k).x;\n}\n\nfloat sub(float d1, float d2, float k) {\n    return isect(d1, -d2, k);\n}\n\nvec3 repeat(vec3 pos, float cx, float cy, float cz){\n    return vec3(mod(pos.x + 0.5f * cx, cx) - 0.5f * cx,\n                mod(pos.y + 0.5f * cy, cy) - 0.5f * cy,\n                mod(pos.z + 0.5f * cz, cz) - 0.5f * cz);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid computeray (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat infinite_plane_sdf(vec3 pos, float y){\n    return pos.y - y;\n}\n\nfloat sphere_sdf (vec3 ro, vec3 p, float r){\n    return length(ro - p) - r;\n}\n\nfloat box_sdf(vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(ro - p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat cylinder_sdf(vec3 ro, vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(ro.xz - p.xz)-2.0*ra+rb, abs(ro.y - p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat vert_cylinder_sdf(vec3 ro, vec3 p, float r, float h){\n    float s0 = box_sdf(ro, vec3(0.f, 1.f, 0.f) + p, vec3(r, 2.f * r, h), 0.1f);\n    float s1 = sphere_sdf(ro, vec3(0.f, 0.f, 0.f) + p, r);\n    return isect(s0, s1, 0.1f);\n\n}\n\nfloat arch_sdf(vec3 ro, vec3 p, float r1, float r2, float t){\n    float s0 = vert_cylinder_sdf(ro, p, r1, t);\n    float s1 = vert_cylinder_sdf(ro, p, r2, 2.f * t);\n    float d1 = sub(s0, s1, 0.1f);\n    return d1;\n}\n\nfloat steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 0; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir) * 0.8f, 2.f * dim.y * float(i), 0.f) + p, dim, 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir) * 0.8f) + p, dim.zyx, 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nfloat full_steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 1; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir), dim.y * float(i), 0.f) + p, vec3(dim.x, 2.f * float(i) * dim.y, dim.z), 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir)) + p, vec3(dim.z, dim.y, dim.x), 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nvec3 map(vec3 p){\n    float aTime = iTime/2.f;\n    \n    //BRIDGE\n    vec3 q = repeat(p, 12.f , 0.f, 0.f);\n    float a0 = arch_sdf(q, vec3(0.f), 7.f, 5.f, 2.f);\n    float a1 = arch_sdf(q, vec3(0.f), 8.f, 6.f, 1.5f);\n    float d0 = sub(a0, a1, 0.2f);\n    \n    \n    // FLOATING BLOBS\n    vec3 qs1 = repeat(p, 40.f, 0.f, 40.f);\n    vec3 qs2 = repeat(p, 10.f, 0.f, 10.f);\n    float f = 5.f;\n    float hf = 15.5f * cos(p.z/40.f);\n    vec3 h0 = vec3(f * cos(iTime/4.f), 15.f + (sin(p.x) + cos(p.z)) * sin(iTime) - hf * (sin(p.x/20.f) + cos(p.z/20.f)) * cos(iTime), f * sin(iTime/2.f));\n    vec3 h1 = vec3(5.f + -f * cos(iTime/4.f), 20.f + (sin(p.x) + cos(p.z)) * sin(iTime) + hf * (cos(p.x/20.f) + sin(p.z/20.f)) * sin(iTime), 5.f + -f * sin(iTime/2.f));\n    float s0 = sphere_sdf(qs1, h0, 3.5f);\n    float s1 = sphere_sdf(qs1, h1, 3.5f);\n    float d1 = smin(s0 * 0.5f, s1 * 0.5f, 2.f).x;\n    \n    \n    // WATER\n    float plane_noise = 2.f;\n    #ifdef SINEWAVES\n    plane_noise += 1.f *(cos(p.x/10.f - cos(iTime)) + sin(p.z/15.f + sin(iTime))) * ((sin(iTime/5.f) + 1.1f)*0.5);\n    plane_noise -= 1.;\n    #endif\n    \n    #if NOISE == 0\n    // nop\n    #elif NOISE == 1\n    // plane_noise += (perlinNoise3D(p) * (sin(iTime/5.f) + 1.1f) * 0.5f);\n    // plane_noise += (perlinNoise3D(p) *  0.2f);\n    // plane_noise += (perlinNoise3D(p) * (sin(iTime/5.f) + 1.1f) * 0.1f);\n    // plane_noise += perlinNoise3D(vec3(p.x, 0., p.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f; // 2D perlin noise is about 3x as fast to march through, but doesn't look as good.\n    // plane_noise += perlinNoise3D(vec3(p.x, iTime, p.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f; // Using the time as the third component makes it look better, while still being 2D noise within a single frame so we keep the performance benefits. At least, we should but we don't for some reason.\n    // Shifting the noise over time is both fast and looks alright, however.\n    vec3 qWater = p + vec3(-iTime*3., 0., sin(iTime/(1.62*3.))*5.);\n    plane_noise += perlinNoise3D(vec3(qWater.x, 0., qWater.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f;\n    #elif NOISE == 2\n    plane_noise += ((worley(p.xz/10.f, abs(sin(iTime) * cos(iTime/2.f)))) * (sin(iTime/5.f) + 1.1f) * 0.3f);\n    #elif NOISE == 3\n    // plane_noise += iqNoiseLayered(p.xz) * (sin(iTime/5.f) + 1.1f) * 0.5f;\n    plane_noise += iqNoiseLayered(p.xz) * 0.2f;\n    #endif\n    \n    float d2 = infinite_plane_sdf(p, plane_noise);\n    \n    \n    // COMPOSITION\n    // x: distance, y: material, z: water mask. (Water mask is used for mixing in the reflection term.)\n    vec3 res;\n    \n    #ifdef COMPOSITION_0\n    // In this block, water and blobs merge and the bridge is independent.\n    res.xz = smin(d1, d2, 3.f);\n    res.y = res.z < 1. ? float(BLOB) : float(WATER);\n\n    vec2 bridge_res;\n    bridge_res = hardMin(res.x, d0);\n    res.x = bridge_res.x;\n    res.y = bool(bridge_res.y) ? float(LAMBERT_RED) : res.y;\n    res.z = bool(bridge_res.y) ? 0. : res.z;\n    #endif\n    \n    #ifdef COMPOSITION_1\n    // In this block, blobs and the bridge merge with the water but not eachother.\n    vec3 bridge_water;\n    bridge_water.xz = smin(d0, d2, 1.);\n    bridge_water.y = float(LAMBERT_RED);\n    \n    vec3 blob_water;\n    blob_water.xz = smin(d1, d2, 3.);\n    blob_water.y = float(BLOB);\n    \n    res = bridge_water.x < blob_water.x ? bridge_water : blob_water;\n    res.y = res.z < 1. ? res.y : float(WATER); // For when water reflects into more water.\n    #endif\n    \n    #ifdef COMPOSITION_2\n    // Same as composition 1 but the blobs deform around the bridge.\n    vec3 bridge_water;\n    bridge_water.xz = smin(d0, d2, 1.);\n    bridge_water.y = float(LAMBERT_RED);\n    \n    float expanded_bridge = d0 - 1.;\n    float blob = d1;\n    //blob = smin(blob, expanded_bridge, 10.).x; // Make the far side of the blob smush away from the bridge; disabled because of artefacts where the bridge is close to the water.\n    blob = sub(blob, expanded_bridge, 2.); // Avoid the bridge instead of going through it.\n    \n    vec3 blob_water;\n    blob_water.xz = smin(blob, d2, 3.);\n    blob_water.y = float(BLOB);\n    \n    res = bridge_water.x < blob_water.x ? bridge_water : blob_water;\n    res.y = res.z < 1. ? res.y : float(WATER); // For when water reflects into more water.\n    #endif\n    \n    // TODO: add ability to smoothly blend all three materials, then make a scene that does that.\n    \n    return res;\n}\n\nvec3 calcNormal(in vec3 pos, float eps){\n    // Central differences approach.\n    // 6s compile time because of over-eager compiler inlining.\n    /*\n    vec2 e = vec2(eps, 0.f);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n    */\n    \n    \n    // Tetrahedron approach from https://iquilezles.org/articles/normalsSDF.\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e).x;\n    }\n    return normalize(n);\n    \n    \n    // Below this point are implementations of inlining-resistant central difference algorithms.\n    // I started messing with them because the tetahedron approach was causing black artefacts\n    // on the underside bridge corners. (But it turns out I had just accidentally set epsilon an\n    // order of magnitude higher than intended in one of the calls.)\n    // The below implementations aren't used any more, but I think they're interesting enough to keep.\n    \n    \n    // Inlining-resistant central differences.\n    // 3s compile time because two map calls get inlined.\n    // Follows the sprit of the inlining-resistant tertrahedron approach, but I haven't seen this implementation elsewhere.\n    /*\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<3; i++) {\n        vec3 e = vec3(((i+3)>>1)&1,(i>>1)&1,i&1);\n        n += e*map(pos+eps*e).x - e*map(pos-eps*e).x;\n    }\n    return normalize(n);\n    */\n\n\n    // Inlining-resistant central differences mk. 2.\n    // 2s compile time with the single inlined map call.\n    // This should be equivalent to mk. 1, but it isn't. (I notice it as banding in the water reflection in the smooth part of the water cycle.) I'm not currently sure why.\n    /*\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<6; i++) {\n        float signBit = float(i&1);\n        int j = i >> 1;\n        vec3 e = signBit * vec3(((j+3)>>1)&1,(j>>1)&1,j&1);\n        n += e*map(pos+eps*e).x;\n    }\n    return normalize(n);\n    */\n    \n    \n    // It's worth noting that the central differences approaches aren't much more expensive at runtime than the tetrahedron approach.\n    // (Not a lot of the total time is spent calculating normals.)\n}\n\nvec3 grad(vec3 pos, float eps) {\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e).x;\n    }\n    return n;\n}\n\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    float res = 1.f;\n    float t = MIN_CLIP;\n    light_dist = min(light_dist, FAR_CLIP);\n    for (int i = 0; i < SHADOW_RAY_STEPS; i++){\n        t = min(t, light_dist);\n        vec3 pos = ro + rd * t;\n        float sdf = map(pos).x;\n        // Soft shadows were causing heavy banding on the blobs from the point light sources.\n        // The reason was that the \"distance function\" wasn't exact.\n        // We can fix this by using a first-order Taylor series approximation for the true distance function.\n        // (https://iquilezles.org/articles/distance)\n        // Nevermind, there's something else at play here, too. Also, computing the gradient during the shadow step is expensive.\n        // float dist = sdf / length(grad(pos, 0.01));\n        float dist = sdf * 50.;\n        res = min(res, 0.2 * dist/t);\n        t += sdf;\n        if (t >= light_dist || res < 0.001) break;\n    }\n    return res;\n}\n\n/*\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    light_dist = min(light_dist, FAR_CLIP);\n    float res = 1.f;\n    float t = MIN_CLIP;\n    float ph = 1e20;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        \n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 10.f * d/max(0., t-y));\n        ph = h;\n        t += h;\n\n        if (res < 0.0001 || t > light_dist){\n            break;\n        }\n    }\n    return res;\n}\n*/\n\nfloat shadowcast(in vec3 ro, in vec3 rd){\n    return shadowcast_pointlight(ro, rd, FAR_CLIP);\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, out vec2 mat){\n    float t = MIN_CLIP;\n    mat = vec2(-1, 0);\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        vec3 sdf = map(pos);\n        float dist = sdf.x;\n        mat = sdf.yz;\n        if (abs(dist) < 0.0001f){\n            return t;\n        }\n        if (t > FAR_CLIP){\n            return -1.f;\n        }\n        t += dist;\n    }\n    return t;\n}\n\nvec3 calcmaterial(vec3 pos, vec3 nor, int mat){\n        vec3 col = vec3(0.f);        \n        \n        // ambient light parameters\n        vec3 sky_light = vec3(0.f, 0.1f, 0.3f) * clamp(0.5f + 0.5f * nor.y, 0.f, 1.f);\n        \n        // light parameters\n        float aTime = iTime/2.f;\n        #ifdef MOTION\n        vec3 light_pos = vec3(7.f * sin(aTime) - iTime , 7.f, 7.f * cos(aTime));\n        #else\n        vec3 light_pos = vec3(7.f * sin(aTime) , 7.f, 7.f * cos(aTime));\n        #endif\n        vec3 light_dir = normalize(light_pos - pos);\n        vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f) * clamp(dot(nor, light_dir), 0.f, 1.f);\n        //vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f);\n\n        #ifdef MOTION\n        vec3 light2_pos = vec3(-7.f * cos(aTime) - iTime, 7.f, -7.f * sin(aTime));\n        #else\n        vec3 light2_pos = vec3(-7.f * cos(aTime), 7.f, -7.f * sin(aTime));\n        #endif\n        vec3 light2_dir = normalize(light2_pos - pos);\n        vec3 lambert_light2 = vec3(0.8f, 0.2f, 0.01f) * clamp(dot(nor, light2_dir), 0.f, 1.f);\n        //vec3 lambert_light2 =vec3(0.8f, 0.2f, 0.01f);\n        \n\n        // bounce light (fake GI)\n        vec3 bounce_light = vec3(0.1f, 0.05f, 0.02f) * clamp(0.5f - 0.5f * nor.y, 0.f, 1.f);\n        \n        float light1_dist = distance(light_pos, pos);\n        float light2_dist = distance(light2_pos, pos);\n        // float t_shadow1 = shadowcast_pointlight(pos, light_dir, light1_dist) / (light1_dist*light1_dist);\n        // float t_shadow2 = shadowcast_pointlight(pos, light2_dir, light2_dist) / (light2_dist*light2_dist);\n        float t_shadow1 = shadowcast_pointlight(pos, light_dir, light1_dist);\n        float t_shadow2 = shadowcast_pointlight(pos, light2_dir, light2_dist);\n         //t_shadow = 1.f;\n                \n        vec3 base_colour;\n        \n        switch(mat){\n            case WATER:\n            base_colour = vec3(0.f, 0.1f, 0.3f) * 0.05f;\n            break;\n            case LAMBERT_RED:\n            // vec2 textureIndex = mix(pos.xy, pos.xz, 0.5);\n            // vec2 textureIndex = vec2(pos.x, pos.y+pos.z);\n            // base_colour  = texture(iChannel0, textureIndex.xy/4.f).xyz;\n            \n            if (abs(nor.y) > abs(nor.z)){\n                base_colour  = texture(iChannel0, pos.xz/4.f).xyz;\n            } else {\n                base_colour  = texture(iChannel0, pos.xy/4.f).xyz;\n            }\n            \n            base_colour *= vec3(0.9f, 0.2f, 0.4f);\n            break;\n            case BLOB:\n            base_colour = vec3(1.f, 0.4f, 0.3f);\n            break;\n        }\n        \n        // final colour evaluation\n        vec3 sum_light = vec3(0);\n        sum_light = lambert_light * t_shadow1 * 2.;\n        sum_light += lambert_light2 * t_shadow2 * 2.;\n        \n        sum_light += sky_light;\n        sum_light += bounce_light;\n        \n        return base_colour * sum_light;\n        //return sum_light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    \n    // camera variance variable\n    #ifdef MOUSE_CONTROL\n    float u = 20.f * iMouse.x/iResolution.x;\n    float v = PI/2.f * iMouse.y/iResolution.y;\n    #endif\n    \n    // Camera parameters\n    #ifdef MOUSE_CONTROL\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d * cos(u), 30.f * abs(sin(v)), d * sin(u));\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_0\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d, 7.5f, 0.f);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_1\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(0.f, 5.f, d);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef MOTION\n    #ifndef VIEW_1\n    vec3 motion = vec3(-iTime, abs(sin(iTime)), 0.f);\n    #else\n    vec3 motion = vec3(-iTime, 0.f, 0.f);\n    #endif\n    eye += motion;\n    ref.x += motion.x;\n    #endif\n    float fov = 45.f;\n    \n    vec3 ro , rd;\n    computeray(eye, ref, ndc, fov, ro, rd);\n        \n    #ifdef DISTANCE_FOG\n    vec3 skyCol = mix(vec3(0.f, 0.1f, 0.3f) * 0.3f, vec3(0.f, 0.1f, 0.3f) * 0.f, abs(ndc.y * 1.25f));     \n    #else\n    vec3 skyCol = vec3(0.f);\n    #endif\n    vec3 col = skyCol;\n    vec2 mat = vec2(-1.f, 0.f);\n    float t = raycast(ro, rd, mat);\n    \n    // TODO: Clean this up to handle the water more nicely. (With less duplicated logic.)\n    if (t > 0.f){\n        vec3 pos = ro + t * rd;\n        \n        vec3 initialNorm = calcNormal(pos, 0.01f);\n        vec3 initialCol = calcmaterial(pos, initialNorm, int(round(mat.x)));    \n        // Add a water reflection. Blend it using the water mask stored in mat.y.\n        if (mat.y > 0.){\n            vec3 ro_new = pos;\n            vec3 rd_new = reflect(rd, initialNorm);\n            vec2 mat_new;\n            float t_new = raycast(ro_new, rd_new, mat_new);\n            \n            vec3 reflectedCol;\n            if (t_new > 0.) {\n                // pos = ro_new + t_new*rd_new;\n                // t = min(t + t_new, FAR_CLIP);\n                // mat = mat_new;\n                vec3 pos_new = ro_new + t_new*rd_new;\n                \n                vec3 reflectedNorm = calcNormal(pos_new, 0.01f);\n                reflectedCol = calcmaterial(pos_new, reflectedNorm, int(round(mat_new.x)));\n                // reflectedCol = calcmaterial(pos_new, reflectedNorm, BLOB);\n            } else {\n                // TODO: This is probably wrong, since the sky is non-uniform.\n                reflectedCol = skyCol;\n            }\n            reflectedCol *= 0.35; // Dampen the water reflection.\n            col = mix(initialCol, reflectedCol, mat.y);\n        } else {\n            col = initialCol;\n        }\n        // TODO: Apply these separately to initialCol and reflectedCol.\n        col *= 1.f - pow(t/FAR_CLIP, 2.f) * vec3(0.8f, 0.8f, 0.6f);\n        #ifdef DISTANCE_FOG\n        col += vec3(0.f, 0.1f, 0.3f) * 0.25f * (t/FAR_CLIP) * (t/FAR_CLIP) ;\n        #endif\n    }\n    \n    #ifdef GAMMA_CORRECTION\n    // Gamma correction - https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=1990s - 38:00\n    col = pow(col, vec3(0.4545f));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}