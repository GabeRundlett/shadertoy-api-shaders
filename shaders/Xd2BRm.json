{
    "Shader": {
        "info": {
            "date": "1522523552",
            "description": "A special effect from a past project",
            "flags": 2,
            "hasliked": 0,
            "id": "Xd2BRm",
            "likes": 30,
            "name": "Halftone Lines & Dots Filter",
            "published": 3,
            "tags": [
                "lines",
                "halftone",
                "dots"
            ],
            "usePreview": 1,
            "username": "cacheflowe",
            "viewed": 1710
        },
        "renderpass": [
            {
                "code": "/*\n * Copyright 2020 Justin Gitlin\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfloat colorSteps = 8.;\nfloat scale = 0.25;\nfloat timeFactor = 0.03;\nfloat blur = 1.;\n\nfloat rgbToGray(vec4 rgba) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgba.xyz, W);\n}\n\nvec2 rotateCoord(vec2 uv, float rads) {\n    uv *= mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n\treturn uv;\n}\n\nfloat halftoneDots(vec2 uv, float rows, float curRadius, float curRotation, float invert) {\n    // update layout params\n    // get original coordinate, translate & rotate\n    uv = rotateCoord(uv, curRotation);\n    // calc row index to offset x of every other row\n    float rowIndex = floor(uv.y * rows);\t\t\n    float oddEven = mod(rowIndex, 2.);\n    // create grid coords\n    vec2 uvRepeat = fract(uv * rows) - 0.5;\t\t\n    if(oddEven == 1.) {\t\t\t\t\t\t\t// offset x by half\n        uvRepeat = fract(vec2(0.5, 0.) + uv * rows) - vec2(0.5, 0.5);\t\n    }\n    // adaptive antialiasing, draw, invert\n    float aa = iResolution.y * rows * 0.00001; \t\n    float col = smoothstep(curRadius - aa, curRadius + aa, length(uvRepeat));\n    if(invert == 1.) col = 1. - col;\t\t\t\n    return col;\n}\n\nfloat halftoneLines(vec2 uv, float rows, float curThickness, float curRotation, float invert) {\n    // get original coordinate, translate & rotate\n    uv = rotateCoord(uv, curRotation);\n    // create grid coords\n    vec2 uvRepeat = fract(uv * rows);\t\t\n    // adaptive antialiasing, draw, invert\n    float aa = iResolution.y * 0.0003; \t\n    float col = smoothstep(curThickness - aa, curThickness + aa, length(uvRepeat.y - 0.5));\n    if(invert == 1.) col = 1. - col;\t\t\t\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n\tvec2 uvDraw = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = 1. - uv.x; // mirror\n\n    // get texture color\n\tvec4 color = texture(iChannel0, uv);\n    \n    if(blur == 1.) {\n    \t// get samples around pixel for averaged color\n    \tfloat stepH = 1.;\n    \tfloat stepV = 1.;\n\t\tvec4 colors[9];\n    \tfloat stepX = stepH/iResolution.x;\n    \tfloat stepY = stepV/iResolution.y;\n    \tcolors[0] = texture(iChannel0, uv + vec2(-stepX, stepY));\n\t\tcolors[1] = texture(iChannel0, uv + vec2(0, stepY));\n\t\tcolors[2] = texture(iChannel0, uv + vec2(stepX, stepY));\n\t\tcolors[3] = texture(iChannel0, uv + vec2(-stepX, 0));\n\t\tcolors[4] = texture(iChannel0, uv);\n\t\tcolors[5] = texture(iChannel0, uv + vec2(stepX, 0));\n\t\tcolors[6] = texture(iChannel0, uv + vec2(-stepX, -stepY));\n\t\tcolors[7] = texture(iChannel0, uv + vec2(0, -stepY));\n\t\tcolors[8] = texture(iChannel0, uv + vec2(stepX, -stepY));\n    \n    \t// apply color steps to original color\n    \tcolor = vec4(0.);\n    \tfor(int i=0; i < 9; i++) {\n    \t    color += colors[i];\n    \t}\n    \tcolor = vec4((color.rgb / 9.), 1.);\n    }\n    \n    // color = vec4(vec3(1. - uv.x), 1.); // test gradient\n    float luma = rgbToGray(color) * 1.;\n    float lumaIndex = floor(luma * colorSteps);\n   \tfloat lumaFloor = lumaIndex / colorSteps;\n    \n    // time\n    float time = iTime * timeFactor;\n    \n    // posterize -> halftone gradient configurations\n    float halftoneCol = 0.;\n    if(lumaIndex == 0.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 50., 0.1, 0.2 + time, 1.);\n    } else if(lumaIndex == 1.) {\n   \t\thalftoneCol = halftoneLines(uvDraw, scale * 84., 0.08, 2. - time, 1.);\n    } else if(lumaIndex == 2.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 120., 0.45, 0.8 + time, 0.);\n\t} else if(lumaIndex == 3.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 60., 0.37, 0.5 - time, 1.);\n  \t} else if(lumaIndex == 4.) {\n\t\thalftoneCol = halftoneLines(uvDraw, scale * 40., 0.18, 2. + time, 0.);\n    } else if(lumaIndex == 5.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 60., 0.34, 0.5 - time, 0.);\n    } else if(lumaIndex == 6.) {\n\t\thalftoneCol = halftoneLines(uvDraw, scale * 84., 0.15, 2. + time, 0.);\n\t} else if(lumaIndex >= 7.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 50., 0.1, 0.2 - time, 0.);\n    } \n    fragColor = vec4(vec3(halftoneCol),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}