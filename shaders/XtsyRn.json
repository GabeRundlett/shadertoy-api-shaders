{
    "Shader": {
        "info": {
            "date": "1503127221",
            "description": "My first shader (quite simple)",
            "flags": 0,
            "hasliked": 0,
            "id": "XtsyRn",
            "likes": 2,
            "name": "A simple example",
            "published": 3,
            "tags": [
                "simple",
                "chess",
                "checkerboardtexture"
            ],
            "usePreview": 0,
            "username": "LuisRodriguezRuiz",
            "viewed": 743
        },
        "renderpass": [
            {
                "code": "#define boardSize 12.0\n#define maxIterations 256\n\nstruct Light\n{\n  vec3 position;\n  vec3 direction;\n  vec3 color;\n  float intensity;\n  vec3 attenuation;\n};\n\nstruct Material\n{\n  vec4 color;\n  float ambient;\n  float diffuse;\n  float specular;\n  float emissive;\n  int texture;\n  vec4 bgColor;\n};\n\n\nstruct Object\n{\n  float distance;\n  Material material;\n};\n\n\n\n\n\n/*  --- GLOBAL VARIABLES --- */\n\n// Directional light\nLight light = Light(vec3(0.0,0.0,0.0),normalize(vec3(-1.0,0.5,-0.6)),normalize(vec3(1.0,1.0,1.0)),10.0,vec3(0.0,0.0,0.0));\n// Camera\nvec3 cameraPosition = vec3(-1.0,10.0,-25.0);\n// Materials\nMaterial whitePawnMaterial=Material(vec4(0.9,0.8,0.8,1.0),0.1,0.6,0.7,0.0,0,vec4(0.8,1.0,0.8,1.0));\nMaterial blackPawnMaterial=Material(vec4(0.2,0.2,0.2,1.0),0.1,1.0,0.7,0.0,0,vec4(0.8,1.0,0.8,1.0));\nMaterial boardMaterial=Material(vec4(1.0,1.0,1.0,1.0),0.1,0.6,0.0,0.0,1,vec4(0.6,0.4,0.4,1.0));\nMaterial planeMaterial=Material(vec4(0.4,0.1,0.1,1.0),0.1,0.6,0.0,0.0,0,vec4(0.6,0.4,0.4,1.0));\nMaterial backgroundMaterial=Material(vec4(1.0,1.0,1.0,1.0),0.5,1.0,1.0,1.0,2,vec4(0.0,0.0,0.0,1.0));\n\n\n\n\n\n// Not the best one but it does for this example. \n\nfloat rnd(vec2 seed)\n{\n    return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// Iñigo Quilez's distance functions.\n\n\nfloat sphere( vec3 p, float radius )\n{\n    return length( p ) - radius;\n}\n\n\nfloat box( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p)\n{\n\n  return p.y;\n}\n\n// This function is used to add an object (geometry and material) to the\n// current scene.\n\nObject unionOp(Object o1 ,Object o2)\n{\n  if(o1.distance<o2.distance)\n    return o1;\n  else\n    return o2;\n  //  return o1.distance<o2.distance ? o1: o2;\n}\n\n// This function is for combining different geometric primitives to\n// build and object\n\nfloat unionGeometry(float d1, float d2)\n{\n    return d1<d2 ? d1: d2;\n}\n\n\n//Function to build a pawn. It consists of a cylinder whose radius is defined\n// by an exponential function over the y coordinate, a sphere (head) and two\n// tori as decoration.\n\nObject pawn(vec3 p, Material mat)\n{\n  return Object(unionGeometry(sdTorus(p,vec2(0.9,0.3)),unionGeometry(sdTorus(p-vec3(0.0,2.5,0.0),vec2(0.6,0.15)), unionGeometry(cylinder(p-vec3(0,1.8,0.0),vec2(exp(-p.y/2.0),2.0)),sphere(p-vec3(0.0,3.5,0.0),1.0)))),mat);\n}\n\n\n// In this function we define the scene that contains two pawns, the chess board\n// and the ground.\n\nObject map( vec3 p )\n{    \n\n  Object pawns=unionOp(pawn(p+vec3(-4.5,0.0,7.5),whitePawnMaterial),pawn(p+vec3(4.5,0.0,11.0),blackPawnMaterial));\n  pawns=unionOp(pawns, Object(sdPlane(p+vec3(0.0,+1.0,0.0)),planeMaterial));\n  return unionOp(pawns, Object(box(p+vec3(0.0,0.5,0.0),vec3(boardSize,0.3,boardSize)),boardMaterial));\n}\n\n\n\n\n// This function compute the normal of an object\n\nvec3 computeNormal( vec3 p )\n{\n    vec2 epsilon = vec2(0.001,0.0);\n     \n    float deltaX = map(p+epsilon.xyy).distance - map(p-epsilon.xyy).distance;\n    float deltaY = map(p+epsilon.yxy).distance - map(p-epsilon.yxy).distance;\n    float deltaZ = map(p+epsilon.yyx).distance - map(p-epsilon.yyx).distance;\n    \n    return normalize(vec3(deltaX,deltaY,deltaZ));\n}\n\n\n// Iñigo Quilez's function to compute soft shadows.\n\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat smoothStep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0); \n    return x*x*(3.0- 2.0*x);\n}\n\n\n// This function computes the color of a pixel based on the texture\n// defined in the material object. The textures are encoded as integers\n\nvec4 getTexture(Material mat, vec3 p,  vec3 normal)\n{\n  float alpha=1.0;\n  int texIndex=mat.texture;\n  float squareSize=boardSize/2.0;\n\n  // Checkerboard texture for the chess board.\n  if(texIndex==1)\n  {\n\n    if(normal.y<0.5) mat.color;\n    vec2 fmod=vec2(p.x+boardSize,p.z+boardSize)/squareSize;\n    float floorx=fmod.x-float(int(fmod.x)); \n    float floory=fmod.y-float(int(fmod.y)); \n    \n    if(floorx>0.5^^floory>0.5) \n    \talpha=1.0;\n      else\n        alpha=0.0;\n   \n  }\n  // Starry texture for the background\n  else if(texIndex==2)\n    {\n     \n      float threshold=0.997;\n      float starBrightness=rnd(p.xy);\t\n      if(rnd(p.xy)>threshold) alpha=(starBrightness-threshold)/(1.0-threshold);\n      else alpha=0.0;\n\n    }\n  // Interpolation between the foreground and background color\n \n  return alpha*mat.color+(1.0-alpha)*mat.bgColor;\n  \n}\n\n\n// Method to compute the lighting and color of the objects\n\nvec4 lighting(vec3 pos,vec3 p, Light light, vec3 rayDirection, Material mat)\n{\n  \n  \n  float intensity=light.intensity;\n  if(light.direction==vec3(0.0,0.0,0.0))\n  {\n    light.direction=normalize(vec3(p-light.position));\n    float d=distance(light.position,p);\n    if(light.attenuation!=vec3(0.0,0.0,0.0))\n       intensity*=1.0/(light.attenuation.x*d*d+light.attenuation.y*d+light.attenuation.z);\n  }\n\n  // Gamma correction:\n  intensity=pow(intensity,0.45);\n  \n  vec3 ambientColor=mat.ambient*light.color;\n  vec3 emissiveColor=vec3(mat.emissive);\n  vec3 N=computeNormal(p);\n  vec3 diffuseColor = intensity*light.color*mat.diffuse*max(dot(light.direction, N),0.0);\n \n  vec3 R=reflect(light.direction,N);\n  vec3 specularColor =intensity*light.color*mat.specular*pow(max(0.0, dot(R,rayDirection)),100.0);\n  vec4 materialColor=getTexture(mat,p,N);\n  return vec4(materialColor.xyz*(diffuseColor+specularColor+ambientColor+emissiveColor)*softShadow(pos,light.direction,0.02,2.5,8.0),materialColor.w);\n }\n\n\n\n// Ray marching function. It is called for each pixel in the image\n\n\nObject rayMarching(vec3 origin, vec3 direction, out vec3 p)\n{\n    float currentDistance = 0.0;\n\n\n    Object res=Object(0.0,backgroundMaterial);\n    float lowerThreshold=0.001;\n    float upperThreshold=2000.0; \n    for(int i=0;i<256;i++)\n    {\n        p=origin+direction*currentDistance;\n\tObject obj=map(p);\n\tfloat distanceToClosestSurface = obj.distance;\n        currentDistance += distanceToClosestSurface;\n        if(distanceToClosestSurface<lowerThreshold)\n\t{\n\t  res=Object(currentDistance,obj.material);\n\t  break;\n\t}\n        \n        if(distanceToClosestSurface>upperThreshold)\n        {\n            currentDistance=0.0;\n            break;\n        }\n    }\n\n    return res;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n   {\n     vec2 uv = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n     uv.x *= iResolution.x / iResolution.y;\n     vec3 rayDirection = normalize(vec3( uv.x, uv.y, 1.0));    \n     vec3 pointOnSurface;\n     \n     Object obj=rayMarching( cameraPosition, rayDirection, pointOnSurface);\n     \n     vec3 pos = cameraPosition + obj.distance*rayDirection;\n     // An object was reached by the ray. Lighting is computed.\n     if(obj.distance!=0.0)\n     {   \n      fragColor = lighting(pos,pointOnSurface, light, rayDirection, obj.material);\n     }\n     // Otherwise, we define the background.\n     else\n     {\n      fragColor=getTexture(backgroundMaterial,vec3(uv,0.0),vec3(0.0,0.0,0.0));\n     }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}