{
    "Shader": {
        "info": {
            "date": "1450115217",
            "description": "Deep",
            "flags": 0,
            "hasliked": 0,
            "id": "Xsd3W7",
            "likes": 19,
            "name": "Balleidoscope",
            "published": 3,
            "tags": [
                "raymarching",
                "balls",
                "kaleidoscope"
            ],
            "usePreview": 0,
            "username": "DrLuke",
            "viewed": 2359
        },
        "renderpass": [
            {
                "code": " #define MARCHLIMIT 70\n\nvec3 camPos = vec3(0.0, 0.0, -1.0);\nvec3 ld = vec3(0.0, 0.0, 1.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nvec3 right = vec3(1.0, 0.0, 0.0);\nvec3 lightpos = vec3(1.5, 1.5, 1.5);\n\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 range(vec3 p)\n{\n\n    // Sphere with Radius\n    vec3 spherepos = vec3(0.0, 0.0, 0.0);\n    float radius = log(sin(iTime*0.1)*0.05+1.0)+0.1;\n\t\n    //float anim = floor(cos(iTime*0.4)+1.0);\n    float anim = smoothstep(0., .1, cos(iTime*0.4)+1.0);\n    \n    //float anim2 = floor(-cos(iTime*0.4)+1.0);\n    float anim2 = smoothstep(0., .1, -cos(iTime*0.4)+1.0);\n    \n    float xampl = sin(iTime*1.3)*0.4*anim;\n    float yampl = sin(iTime*1.3)*0.4-(anim2*0.3);\n    \n    p.x += cos((max(-2.0+p.z-camPos.z,0.)))*xampl-xampl;\n    p.y += sin((max(-2.0+p.z-camPos.z,0.)))*yampl;\n    \n    \n    p = mod(p + vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0)) - vec3(0.5,0.5,0.5);\n    spherepos = mod(spherepos + vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0)) - vec3(0.5,0.5,0.5);\n    \n    vec3 diff = p - spherepos;\n    \n    vec3 normal = normalize(diff);\n\n    \n    return vec4(normal, length(diff)-radius);\n}\n\nvec3 lerp(vec3 a, vec3 b, float p)\n{\n    p = clamp(p,0.,1.);\n \treturn a*(1.0-p)+b*p;   \n}\n\n\nvec4 march(vec3 cam, vec3 n)\n{\n    \n    float len = 1.0;\n    vec4 ret;\n    \n    for(int i = 0; i < MARCHLIMIT; i++)\n    {\n        ret = range(camPos + len*n)*0.5;\n\t\tlen += ret.w;\n    }\n    \n\treturn vec4(ret.xyz, len);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float colorangle = 0.;\n    \n\tvec2 uv = (fragCoord.xy*2.0) / iResolution.xy - vec2(1, 1);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float rotangle = iTime*0.08;\n    vec2 newuv;\n    newuv.x = uv.x*cos(rotangle)-uv.y*sin(rotangle);\n    newuv.y = uv.x*sin(rotangle)+uv.y*cos(rotangle);\n    uv = newuv;\n    \n    camPos = vec3(0.5, 0.5, iTime*1.0);\n\n    //ld = normalize(vec3(0.0, sin(iTime*0.8)*0.1, cos(iTime*0.8)*0.5));\n    float zoom = 0.6;\n    vec3 n = normalize(vec3(sin(uv.x*3.1415*zoom),sin(uv.y*3.1415*zoom) ,ld.z*cos(uv.x*3.1415*zoom)*cos(uv.y*3.1415*zoom)));\n    vec4 rangeret = march(camPos, n);\n    float d = log(rangeret.w / 1.0 + 1.0);\n    vec3 normal = rangeret.xyz;\n    \n    vec3 p = camPos + n*d;\n    float angle = acos(dot(normal, n)/length(normal)*length(n));\n    \n\tfragColor = vec4(hsv2rgb_smooth(lerp(vec3(d*0.1 + (colorangle + iTime)*0.01 + atan(uv.y/uv.x)*3.1415 , 2.0, max(1.0 - log(d),0.0)),vec3(d*0.1 + ((colorangle + iTime)+120.0)*0.01 , 2.0, max(1.0 - log(d),0.0)),cos(angle/10.0))),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}