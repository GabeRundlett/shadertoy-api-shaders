{
    "Shader": {
        "info": {
            "date": "1513860633",
            "description": "Ray marching experiment.\nDisplaced sphere from 'iq':\nhttps://www.shadertoy.com/view/Xds3zN",
            "flags": 32,
            "hasliked": 0,
            "id": "XlXfDs",
            "likes": 48,
            "name": "Ray marched PT",
            "published": 3,
            "tags": [
                "gi",
                "pathtracing",
                "pt"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 2266
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 ) {\n        col = texture( iChannel0, uv ).xyz;\n        col = pow( col, vec3(0.4545) );\n    }\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PIXEL_SAMPLES \t\t1\t\t//samples per pixel. Increase for better image quality\n#define MAX_DEPTH\t\t\t4\t\t//GI depth\n#define CLAMP_VALUE\t\t\t4.0\t\t//biased rendering\n\n#define SPHERE_LIGHT\n#define BOX\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\nvec3 orthogonalize(in vec3 n, in vec3 v) {\n    return v - n * dot(n, v);\n}\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\nvec2 rnd2() { return vec2(rnd(), rnd()); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    return aDist2 == 0.0 ? 0.0 : aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    return abs(aCosThere) == 0.0 ? 0.0 : aPdfA * aDist2 / abs(aCosThere);\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    return v.w == 0.0 ? v.xyz : v.xyz*(1.0/v.w);\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n#if __VERSION__ >= 300\n    return inverse(m);\t//webGL 2.0\n#else\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n#endif\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n#if __VERSION__ >= 300\n    return inverse(m);\t//webGL 2.0\n#else\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n#endif\n}\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_BUNNY\t\t5\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    int type_; // 0 - diffuse, 1 - mirror, 2 - plastic\n    vec3 color_;\n};\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n    float focusDist;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\n \n#ifdef BOX\n#define N_OBJECTS 7\n#define N_MATERIALS 6\n#else\n#define N_OBJECTS 6\n#define N_MATERIALS 5\n#endif\n\nLight lights[2];\nMaterial materials[N_MATERIALS];\nObject objects[N_OBJECTS];\nCamera camera;\n//***********************************\nMaterial getMaterial(int i) {\n#if __VERSION__ >= 300\n    return materials[i];\t//webGL 2.0\n#else\n    if(i==0) return materials[0]; \n    if(i==1) return materials[1];\n    if(i==2) return materials[2];\n    if(i==3) return materials[3];\n    if(i==4) return materials[4];\n    return materials[5];\n#endif \n}\n\nLight getLight(int i) {\n    if(i==0) return lights[0]; else\n        return lights[1];\n    //return lights[i];\n}\n\nvec3 getColor(vec2 uv, int tex) {\n    if(tex==0)\treturn vec3(0.8, 0.5, 0.3);\n    if(tex==1)\treturn vec3(0.5, 0.5, 0.6);\n\t\t\t\treturn vec3(0.7, 0.7, 0.7);\n}\n\nvec3 getNormal(vec2 uv, int tex ) {\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 getRadiance(vec2 uv) {\n    return /*getColor(uv, 2)*lights[0].color_**/vec3(1.0, 1.0, 1.0)*lights[0].intensity_;\n}\n\nvoid createMaterial( int type, vec3 c, out Material mtl) { mtl.type_ = type; mtl.color_ = c;}\n\nvoid createLight(vec3 color, float intensity, out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n}\n\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//min x\n    obj.params_[1] = minY;\t\t\t//min y\n    obj.params_[2] = maxX;\t\t\t//max x\n    obj.params_[3] = maxY;\t\t\t//max y\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createDisk(mat4 transform, float r, float R, int mtl, out Object obj) {\n    obj.type_ = OBJ_DISK;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r*r;\n    obj.params_[1] = R*R;\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createBunny(mat4 transform, int mtl, out Object obj) {\n    obj.type_ = OBJ_BUNNY;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = 0.0;\t\t//not used\n    obj.params_[1] = 0.0;\t\t//not used\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t    //not used\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(1.0 - Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n//taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvoid cartesianToSpherical(in vec3 xyz, out float rho, out float phi, out float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n\n// ************************  INTERSECTION FUNCTIONS **************************\n\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    if( isect.position_.x < minX - EPSILON ) {\n        isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n    } else if( isect.position_.x > maxX - EPSILON ) {\n        isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n    } else if( isect.position_.y < minY - EPSILON ) {\n        isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n    } else if( isect.position_.y > maxY - EPSILON ) {\n        isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n    } else if( isect.position_.z < minZ - EPSILON ) {\n        isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n    } else /*if( isect.position_.z > maxZ - EPSILON ) )*/ {\n        isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n    }\n    \n    return true;\n}\n\nbool iSphere(in Ray ray, in vec3 sph_o, in float sph_r2, out float t0, out float t1) {\n    vec3 L = ray.origin - sph_o;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - sph_r2;\n    return solveQuadratic(a, b, c, t0, t1);\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    if (!iSphere(ray, vec3(.0), radiusSquared, t0, t1))\n\t\treturn false;\n    \n    t = mix(mix(-1.0, t1, float(t1 > 0.0)), t0, float(t0 > 0.0));\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    isect.normal_ = normalize( isect.position_ );\n\t\n\treturn (t != -1.0);\n}\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, out float t, out SurfaceHitInfo isect ) {\n    if ( ray.dir.z == 0.0 )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    isect.normal_ \t= vec3( 0.0, 0.0, 1.0 );\n    return\t(isect.position_.x > min_x) &&\n       \t\t(isect.position_.x < max_x) &&\n      \t\t(isect.position_.y > min_y) &&\n      \t\t(isect.position_.y < max_y);\n}\n\nbool iCylinder(in Ray r, float radius, out float t0, out float t1) {\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n\treturn solveQuadratic(a, b, c, t0, t1);\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n\tfloat t0, t1;\n    \n\tif (!iCylinder(r, radius, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    isect.position_ = phit;\n    isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n    \n\treturn true;\n}\n\n// Distance from p to sphere of radius s (centered at origin)\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat map( in vec3 pos )\n{\n    float a = 15.0;\n    return 0.2 * sdSphere( pos, 1.3 )\n                           + 0.03*sin(a*pos.x)*sin(a*pos.y)*sin(a*pos.z);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // epsilon = a small number\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0002;\n    \n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nbool castRay( in Ray ray, out float t, out vec3 n ){\n    float tmin = 0.0;\n    float tmax = 100.0;\n    \n    if(!iSphere(ray, vec3(0.), 2.25, tmin, tmax))return false;\n    tmin = max(tmin, 0.0);\n    \n    t = tmin;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.0002*t;\n        vec3 p = ray.origin + ray.dir*t;\n        float d = map( p );\n\t    \n        if( d<precis || t>tmax ) break;\n        t += d;\n    }\n    \n    n = calcNormal( ray.origin + ray.dir*t );\n    bool res = t > tmin && t < tmax;\n    \n    return res;\n}\n\nbool rayBunnyIntersection( in Ray ray, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    bool res = castRay( ray, t, isect.normal_ );\n    isect.position_ = ray.origin + ray.dir*t;\n    return res;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], t, currentHit );\n    } else if( obj.type_ == OBJ_BUNNY ) {\n        hitResult = rayBunnyIntersection( rayLocal, forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.mtl_id_ = obj.mtl_id_;\n        \n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    \n    for(int i=0; i<N_OBJECTS; i++ ) {\n        CHECK_OBJ( objects[i] );\n    }\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n\nvoid initScene() {\n    \n    //create lights\n    createLight(vec3(1.0, 1.0, 0.9), 10.0, lights[0]);\n    \n    //Create materials\n    createMaterial(0, vec3(0.9), materials[0]);\n    createMaterial(0, vec3(0.9), materials[1]);\n    createMaterial(1, vec3(0.9, 0.5, 0.9), materials[2]);\n    createMaterial(0, vec3(0.5, 0.5, 0.9), materials[3]);\n    createMaterial(2, vec3(0.5, 0.5, 0.9), materials[4]);\n#ifdef BOX\n    createMaterial(0, vec3(0.96, 0.02, 0.05), materials[5]);\n#endif\n    \n    //init lights\n    float r = 1.3;\n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = xFactor*7.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -2.2;\n    mat4 trans = createCS(\tvec3(x, 5.0, z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n#ifdef SPHERE_LIGHT\n    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );\n#else\n    float aa = 2.0 * r;\n    float bb = 3.0 * r;\n    createPlane(trans, -bb, -aa, bb, aa, LIGHT_ID_BASE+0, objects[0]);\n#endif\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 4.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -5.0, 10.0, 5.0, SURFACE_ID_BASE+1, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -5.0, 1.0 ));\n    createPlane(trans, -10.0, -5.0, 10.0, 5.0, SURFACE_ID_BASE+1, objects[2]);\n \n    \n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -3.5, 0.3, -4.5, 1.0 ));\n    createBunny(trans, SURFACE_ID_BASE+2, objects[3]);\n    \n    vec3 xvec = normalize(vec3(0.8, 0.2, -0.1));\n    trans = createCS(\tvec3(0.0, 0.3, -5.5),\n                        xvec,\n                  \t\tvec3(0.0, 1.0, 0.0));\n    createBunny(trans, SURFACE_ID_BASE+4, objects[4]);\n    \n    xvec = normalize(vec3(0.8, 0.2, -0.1));\n    trans = createCS(\tvec3(3.5, 0.3, -4.5),\n                        xvec,\n                  \t\tvec3(0.0, 1.0, 0.0));\n    createBunny(trans, SURFACE_ID_BASE+3, objects[5]);\n    //createSphere(trans, 1.0, SURFACE_ID_BASE+4, objects[5]);\n    \n#ifdef BOX\n    //box\n    xvec = normalize(vec3(0.8, 0.0, -0.25));\n    trans = createCS(\tvec3(0.0, -0.5, -2.5),\n                        xvec,\n                  \t\tvec3(0.0, 1.0, 0.0));\n    createAABB( trans, -vec3(0.5), vec3(0.5), SURFACE_ID_BASE+5, objects[6]);\n#endif\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV,\n                \tin float focus_dist\n               ) {\n    camera.pos = vec3( 0.3, 3.0, 4.8 );\n    \n    target = vec3( 0.0, 0.4, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.focusDist = focus_dist;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\n    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n#ifdef SPHERE_LIGHT\nvec3 sampleLightSource( \tin vec3 x,\n                          \tin vec2 xi,\n                          \tout LightSamplingRecord sampleRec ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    \n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    \n    float sin_theta_max_2 = sph_r2 / dc_2;\n\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    float cos_theta = mix( cos_theta_max, 1.0, xi.x );\n    float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    float sin_theta = sqrt(sin_theta_2);\n    sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*xi.y, sin_theta, cos_theta );\n    sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n    //Calculate intersection distance\n\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n    sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);\n    \n    return lights[0].color_*lights[0].intensity_;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                            in vec3 wi,\n                           \tin float d,\n                            in float cosAtLight ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    float solidangle;\n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sph_r2 ) {\n    \tfloat sin_theta_max_2 = clamp( sph_r2 / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n}\n#else\nvec3 sampleLightSource(\t\tin vec3 x,\n                          \tin vec2 xi,\n                       \t\tout LightSamplingRecord sampleRec) {\n    vec2 minp = vec2(objects[0].params_[0], objects[0].params_[1]);\n    vec2 maxp = vec2(objects[0].params_[2], objects[0].params_[3]);\n    vec2 size = maxp - minp;\n    vec3 p_local = vec3(mix(minp, maxp, xi), 0.0);\n    vec3 n_local = vec3(0.0, 0.0, 1.0);\n    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );\n    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );\n    \n    float pdfA = 1.0 / (size.x*size.y);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(xi):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L*0.3;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                               in vec3 wi,\n                             \tfloat d,\n                              \tfloat cosAtLight\n                             ) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    float pdfA = 1.0 / (dim_x*dim_y);\n    return PdfAtoW(pdfA, d*d, cosAtLight);\n}\n#endif\n\n// ************************   Scattering functions  *************************\nfloat SchlickFresnel(in float Rs, float cosTheta) {\n    return Rs + pow(1.0 - cosTheta, 5.) * (1. - Rs);\n}\n\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){\n\treturn ((dot(n,a)*dot(n,b))>0.0);\n}\n\nbool sameHemisphere(in vec3 a, in vec3 b){\n\treturn (a.z*b.z>0.0);\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 E, in vec3 L) {\n    if(mtl.type_ == 0) {\n        return \tvec3(INV_PI) * mtl.color_;\n    } else if(mtl.type_ == 1) {\n        return vec3(0.0);\n    }\n\n    float f = max(SchlickFresnel(0.1, L.z), SchlickFresnel(0.1, E.z));\n    return \t(1.0 - f) * vec3(INV_PI) * mtl.color_;\n}\n\nstruct BrdfSamplingResult {\n\tvec3 w;\n    float pdf;\n    vec3 f;\n    bool isDelta;\n};\n    \n    \nBrdfSamplingResult sampleDiffuse(in vec2 xi) {\n    BrdfSamplingResult res;\n    res.isDelta = false;\n    res.w = sampleHemisphereCosWeighted( xi.x, xi.y );\n    res.pdf = INV_PI * res.w.z;\n    res.f = vec3(INV_PI);\n    return res;\n}\n\nBrdfSamplingResult sampleSpecular(in vec3 E) {\n    BrdfSamplingResult res;\n    res.isDelta = true;\n    res.w = reflect(-E, vec3(0.0, 0.0, 1.0));\n    res.pdf = 1.0;\n    res.f = vec3(1.0);\n    return res;\n}\n\nBrdfSamplingResult mtlSample(Material mtl, in vec3 Ng, in vec3 E, in vec2 xi) {\n\tBrdfSamplingResult res;\n    res.isDelta = false;\n    \n    if(mtl.type_ == 0) {\n        res = sampleDiffuse(xi);\n        res.f *= mtl.color_;\n    } else if(mtl.type_ == 1) {\n        res = sampleSpecular(E);\n    } else {\n        float f = SchlickFresnel(0.1, E.z);\n        float p = f;\n        if(xi.x < p) {\n        \tres = sampleSpecular(E);\n            res.pdf *= p;\n            res.f *= f;\n        } else {\n            xi.x = clamp(xi.x / p, 0.0, 1.0);\n    \t\tres = sampleDiffuse(xi);\n         \tres.pdf *= 1.0 - p;\n        \tres.f *= mtl.color_ * (1.0 - f);\n        }\n    }\n    \n    if(/*!sameHemisphere(Ns, E, L) ||*/ !sameHemisphere(Ng, E, res.w)) {\n       res.pdf = 0.0;\n    }\n    \n    return res;\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 E, in vec3 L) {\n    if(!sameHemisphere(Ng, E, L)) {\n        return 0.0;\n    } else {\n        if(mtl.type_ == 0) {\n            return abs(L.z)*INV_PI;\n        } else if(mtl.type_ == 1){\n            return 0.0;\n        } else {\n            float diff_pdf = abs(L.z)*INV_PI;\n            float f = min(SchlickFresnel(0.1, L.z), SchlickFresnel(0.1, E.z));\n            return diff_pdf * (1.0 - f);\n        }\n    }\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin mat3 trans,\n                  \tin mat3 inv_trans,\n                  \tin vec3 ng,\n                \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                \tout BrdfSamplingResult brdfres,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit) {\n    vec3 Lo = vec3(0.0);\n    \n    brdfres = mtlSample(mtl, ng, wi, rnd2() );\n    \n    //Continue if sampled direction is under surface\n    if ((dot(brdfres.f,brdfres.f)>0.0) && (brdfres.pdf > 0.0)) {\n        \n        Ray shadowRay = Ray(x + (trans * ng) * EPSILON, trans * brdfres.w);\n\n        float cosAtLight = 1.0;\n        float distanceToLight = -1.0;\n        vec3 Li = vec3(0.0);\n\n        {\n            float distToHit;\n\n            if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n                if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                    distanceToLight = distToHit;\n                    cosAtLight = dot(hit.normal_, -shadowRay.dir);\n                    if(cosAtLight > 0.0) {\n                        Li = getRadiance(hit.uv_);\n                        //Li = lights[0].color_*lights[0].intensity_;\n                    }\n                } else {\n                    hitRes = true;\n                }\n            } else {\n                hitRes = false;\n                //TODO check for infinite lights\n            }\n        }\n\n        if (distanceToLight>0.0) {\n            if (cosAtLight > 0.0) {\n                vec3 contribution = (Li * brdfres.f * brdfres.w.z) / brdfres.pdf;\n\n                if (!brdfres.isDelta ) {\n                    float lightPdfW = sampleLightSourcePdf( x, shadowRay.dir, distanceToLight, cosAtLight );\n \n                    contribution *= misWeight(brdfres.pdf, lightPdfW);\n                }\n\n                Lo += contribution;\n            }\n        }\n    }\n\n    return Lo;\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin mat3 trans,\n                  \tin mat3 inv_trans,\n                  \tin vec3 ng,\n                  \tin vec3 lwi,\n                  \tin Material mtl,\n                  \tin bool useMIS ) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    float lightPickingPdf = 1.0;\n    Light light = lights[0];\n\n    vec3 lwo;\n    float lightPdfW, lightDist;\n\n    LightSamplingRecord rec;\n    vec3 Li = sampleLightSource( x, rnd2(), rec );\n    lwo = inv_trans * rec.w;\n    lightPdfW = rec.pdf;\n    lightDist = rec.d;\n    lightPdfW *= lightPickingPdf;\n\n    float dotNWo = lwo.z;\n\n    if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {\n        vec3 fr = mtlEval(mtl, ng, lwi, lwo);\n        if(dot(fr,fr)>0.0) {\n            Ray shadowRay = Ray(x, rec.w);\n            if (isLightVisible( shadowRay )) {\n                vec3 contribution = (Li * fr * dotNWo) / lightPdfW;\n\n                if (useMIS && !(mtl.type_==1)) {\n                    float brdfPdfW = mtlPdf(mtl, ng, lwi, lwo);\n                    contribution *= misWeight(lightPdfW, brdfPdfW);\n                }\n\n                Lo += contribution;\n            }\n        }\n    }\n\n    return Lo;\n}\n\nvec3 Radiance( in Ray r, int strataCount, int strataIndex ) {\n    vec3 e = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    bool hitResult;\n\n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        return vec3(0.0);\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                e = getRadiance(event.uv_);\n            }\n        }\n    }\n    \n    vec3 direct = vec3(0.0), indirect = vec3(0.0);\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        \n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        if(dot(wi, event.normal_) < 0.0) {\n            event.normal_ *= -1.0;\n        }\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n        vec3 tangent = vec3(event.normal_.xzy);\n        tangent = orthogonalize(event.normal_, tangent);\n    \n        mat3 trans = mat3FromNormal(event.normal_);\n    \tmat3 inv_trans = mat3Inverse( trans );\n    \tvec3 wi_local = inv_trans * wi;\n        vec3 ng_local = inv_trans * ng;\n        ns = event.normal_;//frame*ns;\n        \n        if (wi_local.z < 0.0) { break; }\n \n        BrdfSamplingResult brdfres;\n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //In addition BSDF sampling does next event estimation and returns all necessary values which corresponds to next event\n       \tdirectLight  = salmpleLight (x, trans, inv_trans, ng_local, wi_local, mtl, true);\n        directLight += sampleBSDF   (x, trans, inv_trans, ng_local, wi_local, mtl, true, brdfres, hitResult, nextEvent);\n        \n       \n        if(pathWeight.x > 1.0 || pathWeight.y > 1.0 || pathWeight.z > 1.0)\n            break;\n        \n        if(i == 0) {\n            direct += directLight*pathWeight;\n        } else {\n        \tindirect += directLight*pathWeight;\n        }\n\n        if (!hitResult || brdfres.w.z <0.0) { break; }\n        if (brdfres.pdf == 0.0) { break; }\n        pathWeight *= brdfres.f * brdfres.w.z / brdfres.pdf;\n\n        //Update values for next iteration\n        ray = Ray(event.position_, trans * brdfres.w);\n        event = nextEvent;\n    }\n    \n    //Clamp only indirect\n    indirect = vec3(min(indirect, vec3(CLAMP_VALUE)));\n\n    return e + direct + indirect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    float fov = radians(40.0);\n    initCamera( vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 1.0, 0.0 ),\n               fov,\n               9.2\n              );\n\n    initScene();\n\n    vec3 accumulatedColor = vec3( 0.0 );\n    float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n\n    for( int si=0; si<PIXEL_SAMPLES; ++si ){\n        vec2 sc = fragCoord.xy + vec2(strataSize*(float(si) + rnd()), rnd());\n        accumulatedColor += Radiance(genRay(sc, rnd(), rnd()), PIXEL_SAMPLES, si);\n    }\n\n    //devide to sample count\n    accumulatedColor = accumulatedColor*oneOverSPP;\n    \n    vec3 col_acc;\n    vec2 coord = floor(fragCoord.xy);\n    if(all(equal(coord.xy,vec2(0)))) {\n        if( iMouse.z > 0.0 ) {\n            col_acc = vec3(iFrame);\n        } else {\n            col_acc = texture( iChannel0, vec2(0.5, 0.5)/iResolution.xy ).xyz;\n        }\n    } else {\n        if(iFrame == 0) {\n            col_acc = accumulatedColor;\n        } else {\n            int frame_start = int(texture( iChannel0, vec2(0.5, 0.5) / iResolution.xy ).x);\n            int spp1 = ( iMouse.z > 0.0 ) ? 0 : iFrame - frame_start;\n            int spp2 = 1;\n            vec3 col_new = accumulatedColor;\n            col_acc = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n            col_acc = mix(col_acc, col_new, float(spp2)/float(spp1+spp2));\n        }\n    }\n    \n    fragColor = vec4( col_acc, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}