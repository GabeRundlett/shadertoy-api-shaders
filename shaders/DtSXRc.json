{
    "Shader": {
        "info": {
            "date": "1676367577",
            "description": "The nonpipe again - now with refraction and a varying index (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "DtSXRc",
            "likes": 20,
            "name": "This Is Not A Refracted Pipe",
            "published": 3,
            "tags": [
                "refract",
                "pipe",
                "magritte"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "// \"This Is Not A Refracted Pipe\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Note from \"This Is Not A Pipe\":\n  This is clearly not Magritte's masterpiece. But is the 3D form less\n  'not a pipe' than the original?\n\n No. 27 in \"Refraction\" series - listed at end\n\n No. 4 in \"Nonpipe\" series\n    \"This Is Not A Pipe\"              (4s3XD2)\n    \"This Is Not A Reflected Pipe\"    (Wsd3W8)\n    \"This Is Not A Reflected Pipe 2\"  (Nsd3RN)\n\n (with bits from \"This Is Not A Reflected Pipe 2\" and \"Fugu Egg\")\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nfloat dstFar, tCur, szFac, sphRad;\nint idObj;\nconst int idPipe = 1, idCoal = 2;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{  // (from \"This Is Not A Reflected Pipe 2\")\n  vec3 q;\n  vec2 rp;\n  float dMin, d;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.x += 1.;\n  q = p;\n  d = SmoothMax (abs (PrCapsDf (q.xzy, 0.55, 0.25)) - 0.06, q.y - 0.5, 0.05);\n  q.y -= smoothstep (0.5, 2.5, q.x) - 0.5;\n  q.x -= 1.3;\n  rp = vec2 (0.1, 0.17) - vec2 (0.05, 0.06) * (q.x / 0.6 - 1.);\n  d = SmoothMin (d, max (SmoothMin (PrEllCylDf (q.yzx, rp, 1.2),\n     PrEllCylDf (q.yzx - vec3 (0., 0., 1.2), rp + 0.007, 0.007), 0.05),\n     0.03 - length (q.yz * vec2 (1.1, 0.35))), 0.12);\n  DMIN (idPipe);\n  q = p;\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 0.5, 0.01);\n  DMIN (idCoal);\n  return 0.7 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat InSphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d;\n  b = dot (rd, ro);\n  d = b * b + rad * rad - dot (ro, ro);\n  return (d > 0.) ? - b - sqrt (d) : dstFar;\n}\n\nfloat OutSphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d;\n  b = dot (rd, ro);\n  d = b * b + rad * rad - dot (ro, ro);\n  return (d > 0.) ? - b + sqrt (d) : dstFar;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col; \n  if (rd.y > 0.85) col = mix (vec3 (0.1), vec3 (0.9, 0.9, 1.), smoothstep (0., 0.02,\n     0.47 - Maxv2 (abs (fract (8. * Rot2D (rd.xz / rd.y, 0.25 * pi) + 0.5) - 0.5))));\n  else col = mix (vec3 (0.5, 0.5, 0.), vec3 (0.7, 0.9, 1.),  Minv2 (smoothstep (0.05, 0.1, \n     abs (sin (64. * atan (rd.zy, vec2 (rd.x, length (rd.xz)))))))) * (0.3 + 0.1 * rd.y);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{  // (optics simplified from \"Fugu Egg\")\n  vec3 col, rdo, vn, vnIn, q;\n  float dstObj, dstSphIn, dstSphOut, eta, sh;\n  szFac = 0.8;\n  eta = 1. / (1. - 0.6 * SmoothBump (0.25, 0.75, 0.15, mod (0.05 * tCur, 1.)));\n  rdo = rd;\n  dstObj = dstFar;\n  dstSphIn = InSphHit (ro, rd, sphRad);\n  if (dstSphIn < dstFar) {\n    ro += dstSphIn * rd;\n    vnIn = ro / sphRad;\n    rd = refract (rd, vnIn, 1. / eta);\n    dstObj = ObjRay (ro, rd);\n    dstSphOut = OutSphHit (ro, rd, sphRad);\n    if (dstSphOut < dstObj) {\n      ro += dstSphOut * rd;\n      rd = refract (rd, - ro / sphRad, eta);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    q = ro / szFac;\n    if (idObj == idPipe) {\n      q.xy -= vec2 (0.4);\n      q.xy = Rot2D (q.xy, -0.2 * pi);\n      if (q.x < -0.03) vn = VaryNf (16. * q, vn, 0.1);\n      col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.), 0.5 * Fbm3 (4. * q)) :\n         vec3 (0.1), vec3 (0.7, 0.6, 0.), SmoothBump (-0.03, 0.03, 0.01, q.x));\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n      col = col * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         0.2 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } else if (idObj == idCoal) {\n      col = mix (vec3 (0.9, 0., 0.) * (0.2 + 0.8 * smoothstep (0.1, 0.9, Fbm1 (0.5 * tCur))),\n         vec3 (0.1, 0., 0.), smoothstep (0.2, 0.7, Fbm2 (64. * q.xz)));\n    }\n  } else {\n    col = BgCol (rd);\n  }\n  if (dstSphIn < dstFar) col = mix (col, 2. * BgCol (reflect (rdo, vnIn)),\n     0.05 + 0.95 * pow (1. - abs (dot (rdo, vnIn)), 5.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 1.);\n    t = (floor (32. * t) + smoothstep (0.5, 1., mod (32. * t, 1.))) / 32.;\n    az = pi * sin (2. * pi * t);\n    el = -0.2 * pi * sin (4. * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  sphRad = 2.;\n  ro = vuMat * vec3 (0., 0., -5. * sphRad);\n  zmFac = 4.5;\n  dstFar = 30.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n  \"Refraction\" series\n    \"Aquarium\"                    (Mtf3zM)\n    \"Wavescape\"                   (lls3z7)\n    \"Sailing Home\"                (Ml23WV)\n    \"Fishbowl\"                    (MlSSDR)\n    \"A Few Fish\"                  (4dtSDs)\n    \"Fishbowl 2\"                  (lt3SW8)\n    \"Swimming Pool Waves\"         (llKSDG)\n    \"Green Grotto\"                (Ms2yR1)\n    \"Glass Duck\"                  (XslBR8)\n    \"Foggy Duck\"                  (XsfBWn)\n    \"Rainbow Cavern\"              (XsfBWM)\n    \"Magic Orb\"                   (XsfBWB)\n    \"Glass Duck 2\"                (MtlyRf)\n    \"White Folly\"                 (ll2cDG)\n    \"White Folly 2\"               (ltXfzr)\n    \"Virtual Dolphins\"            (XlfBD2)\n    \"Refractable Ship\"            (MtjBRm)\n    \"Refracted Colliding Balls\"   (lljBDR)\n    \"Refraction Exercise\"         (4ddyRj)\n    \"Wrapped Bottle\"              (wdS3zV)\n    \"Ship in a Bottle\"            (wlXXzf)\n    \"Booze Cruise\"                (3dsfWl)\n    \"Nautilus Submerging\"         (WtXfR2)\n    \"Nautilus Interior\"           (wt2fzz)\n    \"Nautilus at Sunset\"          (slscWj)\n    \"Fugu Egg\"                    (NtjcRV)\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}