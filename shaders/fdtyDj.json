{
    "Shader": {
        "info": {
            "date": "1660682803",
            "description": "standard balls moving in a tiled domain of all 3 axis | Cropping wave fun for effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdtyDj",
            "likes": 24,
            "name": "Test World Phase 4",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "repetition",
                "looping"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Test World Phase 4    \n    8/16/22 | byt3 m3chanic\n    \n    Same ole trick, trying refraction and fumbling with a single pass multi\n    bounce marcher - thanks @blackle / @tdhooper / and sdf's @iq\n*/\n\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    40.\n\n// AA Setting - comment/uncomment to disable/endable AA from render\n#define AA 2\n\nfloat mtime=0.,time=0.;\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*41458.5453); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//@iq SDF functions\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cap( vec3 p, float h, float r ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global vars\nvec3 hit=vec3(0), hitPoint=vec3(0);\nfloat travelSpeed,modTime,fractTime;\n\nconst float size = 20.;\nconst float rep_half = size/2.;\nconst float rr = rep_half/2.;\n\nvec2 map(vec3 pos) {\n\tvec2 res = vec2(1e5,-1.);\n    vec3 center = vec3(0,-2, -rr);\n\n    vec3 pp = pos-center;\n    vec3 tt = pp;\n    vec3 sp = pp;\n\n    vec3 pi = vec3(\n        floor((pp + rep_half)/size)\n    );\n    vec3 ti = pi;\n\n    float bfs,fhs,dhs;\n    if(modTime<2.){\n        fhs = hash21(pi.xz);\n        if(fhs>.57){\n            tt.y += fractTime;\n        } else {\n            tt.y -= fractTime;\n        } \n    } else if (modTime<4.){\n      \tdhs = hash21(pi.zy+vec2(4,.4));\n        if(dhs>.67){\n            tt.x += fractTime;\n        } else {\n            tt.x -= fractTime;\n        }\n    } else {\n      \tbfs = hash21(pi.xy+vec2(21,.4));\n        if(bfs>.27){\n            tt.z -= fractTime;\n        } else {\n            tt.z += fractTime;\n        }   \n    }\n\n    pp =  mod(pp+rep_half,size) - rep_half;\n\ttt =  mod(tt+rep_half,size) - rep_half;\n\n    float thk = 1.;\n    float d1 = length(abs(pp.xy)-vec2(10))-thk;\n    d1 = min(length(abs(pp.xz)-vec2(10))-thk,d1);\n    d1 = min(length(abs(pp.yz)-vec2(10))-thk,d1);\n    if(d1<res.x) {\n        res = vec2(d1,3);\n        hit = abs(pp)-vec3(10);\n    }\n\n    d1 = min(cap(abs(pp)-vec3(10,0,10),1.5,1.5),d1);\n    d1 = min(cap(abs(pp.yzx)-vec3(10,0,10),1.5,1.5),d1);\n    d1 = min(cap(abs(pp.zxy)-vec3(10,0,10),1.5,1.5),d1);\n    if(d1<res.x) {\n        res = vec2(d1,6);\n        hit = abs(pp)-vec3(10);\n    }\n\n\tfloat d2 = box(abs(pp)-vec3(10), vec3(3.5))-.05;\n    d2=max(d2,-(abs(d1)-.5));\n    if(d2<res.x) {\n        res = vec2(d2,2);\n        hit = abs(pp)-vec3(10);\n    }\n\n    float d5 = length(tt)-2.35;\n    if(d5<res.x) {\n        res = vec2(d5,4);\n        hit = tt;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist){\n    t*=mindist;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d-vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n){\n    n = normal(p,d,1.);\n  \n    vec3 lpos = vec3(5,9,-7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 h=vec3(.05);\n\n    if(m==2.) {\n        vec3 dv = p-vec3(0,0, -rr/2.);\n        vec3 f=fract(dv)-.5;\n        if(f.x*f.y*f.z>.0) h = vec3(1);\n        \n        float px = 4./R.x;\n        float d1 = length(hitPoint)-4.5;\n        float d2 = smoothstep(px,-px,abs(d1)-.05);\n        d1=smoothstep(px,-px,d1);\n        float cut = clamp((p.y*.03)+.2,0.,1.);\n        h=mix(h,vec3(.8,.47,0.),d1);\n        h=mix(h,vec3(.05),d2);\n    }\n\n    if(m==3.) {\n        float bg = clamp(sin(length(hitPoint)*22.)*1.5-.5,.01,.99);\n        h=mix(vec3(.37,.55,.57),vec3(.063,.11,.12),bg);\n    }\n    if(m==4.) h=vec3(.05);\n    if(m==6.) h=vec3(.3);\n    return diff*h;\n}\n\nvec3 renderFull(vec2 uv)\n{\n\n    vec3 C=vec3(.0);\n    float fA = 0.;\n    vec3 ro = vec3(0,-1,10.15),\n         rd = normalize(vec3(uv,-1));\n\n    mat2 mx =rot(-(.65*sin(T*.08))); mat2 my =rot(-.55+(.2*cos(T*.1)));\n    \n    ro.zy*=mx;rd.zy*=mx;\n    ro.xz*=my;rd.xz*=my;\n    \n    vec3  p = ro + rd * .0001;\n    float atten = 1.;\n    float k = 1.;\n    float bounce = 4.;\n\n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    // a lot of these settings are tweaked for this scene \n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n        float d = i<32? ray.x*.5:ray.x*.9;\n        float m = ray.y;\n        p += rd*d*k;\n\n        hitPoint=hit;\n        if(bounce>2.)fA+=d;\n\n        if (d*d < 1e-5) {\n            bounce--;\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m!=4.&&m!=6.) break;\n            \n            atten *= .45;\n            p += rd*.1;\n            k = sign(map(p).x);\n            vec3 rf=refract(rd,n,.65);\n            \n            if(m==6.){\n                rf=reflect(-rd,n);  \n            }\n            \n            p+=n*.5;\n            rd=rf;\n\n        }\n\n        if(bounce<1.||distance(p,rd)>75.) break;\n    }\n\n    if(fA>0.) C=mix(C,vec3(.03), 1.-exp(-.00001*fA*fA*fA));\n    return clamp(C,vec3(0),vec3(1)); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\n    vec3 col = vec3(.00); \n    time = iTime;    \n \n    mat2 r15 = rot(-25.*PI/180.);\n    fractTime = fract(time*.3)* (size);\n    modTime = mod(time*.6,6.);\n    \n    vec2 o = vec2(0);\n    vec2 xv = (2.*fragCoord.xy-R.xy)/max(R.x,R.y);\n    \n    vec2 ff = fract(xv*5.+T*.5)-.5;\n    float wv = .2 * sin(xv.x*.75+T*1.5);\n    xv.y+=wv;\n\n    if(ff.x*ff.y>0.&&(xv.y>.35||xv.y<-.35)) col=vec3(.9);\n\n    if(xv.y<.35&&xv.y>-.35){\n    // @tdhooper \n    // @iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - .5;\n    #endif\n\t\t\n        //time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.x;\n    \tcol += renderFull(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    }\n    \n    float px = 2./R.x;\n    float f1 = length(abs(xv.y)-.35)-.005;\n    float f2 = smoothstep(.02+px,-px,f1);\n    f1 = smoothstep(px,-px,f1);\n    if(xv.y>.35||xv.y<-.35)col = mix(col,col*.4,f2);\n    col = mix(col,vec3(.8,.47,0.),f1);\n    col = pow( col, vec3(.4545) );\n    fragColor = vec4(col, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}