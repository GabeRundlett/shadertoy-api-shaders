{
    "Shader": {
        "info": {
            "date": "1654541608",
            "description": "All big dots are draggable.\nMapping between image and plane coordinates with a single matrix using:\n- Image of origin\n- Image of main directions\n- Screen space ratio to image of first units",
            "flags": 32,
            "hasliked": 0,
            "id": "7sKcz1",
            "likes": 9,
            "name": "Evenly Spaced Grid",
            "published": 3,
            "tags": [
                "grid",
                "geometry",
                "projective"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "// Rough version using one axis in 2D-space: https://www.shadertoy.com/view/fdVcR1\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    initView(iResolution);\n    vec2 uv = fromView(O);\n    vec2 click = fromView(abs(iMouse.zw));\n    vec2 mouse = fromView(abs(iMouse.xy));\n    \n    vec2 o = getPoint(0); // zero\n    vec2 u = getPoint(1); // u-infinity\n    vec2 v = getPoint(2); // v-infinity\n\n    // g = distance(zero, one) / distance(zero, infinity)\n    vec2 g  = getPoint(3);\n    vec2 gu = mix(o, u, g.x); // u-one\n    vec2 gv = mix(o, v, g.y); // v-one\n\n    // gf = distance(zero, one) / distance(zero, infinity)\n    vec2 gf = g / (1. - g);\n\n    // Those are homogenous matrices, their scale does not matter:\n    //   As long as you keep all signs, you can skip multiplication\n    //   with the determinant during inversion\n    mat3 T = mat3(vec3(u, 1.) * gf.x, vec3(v, 1) * gf.y, vec3(o, 1));\n    mat3 Ti = inverse(T);\n\n    vec2 ij = P(Ti * vec3(uv, 1));\n\n    C = vec4(1);\n\n    // Grid\n    vec2 grid = abs(ij - round(ij)) / fwidth(ij);\n    if ((T * vec3(ij, 1)).z > 0.)\n    {\n        C = pow(texture(iChannel1, ij, -1.), vec4(2));\n        C = blend(C, vec3(0), min(grid.x, grid.y));\n    }\n\n    // Dots at grid junctions\n    vec3 z = T * vec3(round(ij), 1);\n    if (z.z > 0.)\n        C = blend(C, vec3(0), distance(uv, P(z)) / f - 1.5);\n\n    // One unit in u/v directions\n    C = blend2(C, colors[1], distance(uv, gu) / f - 3.);\n    C = blend2(C, colors[2], distance(uv, gv) / f - 3.);\n\n    // Horizon\n    float fuv = clamp(dot(uv-u, v-u) / dot(v-u, v-u), 0., 1.);\n    C = blend(C, mix(colors[1], colors[2], fuv), sdLine(uv, u, v, -inf, inf) / f - .5);\n\n    // Handles\n    for (int i=0 ; i<3 ; ++i)\n        C = blend2(C, colors[i], distance(uv, getPoint(i)) / f - 3.);\n    C = blend2(C, colors[3], distance(O, getPoint(3)*iResolution.xy) - 3.);\n\n    C = sqrt(C);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 C, in vec2 O)\n{\n    ivec2 I = ivec2(O);\n    C = texelFetch(iChannel0, I, 0);\n\n    initView(iResolution);\n    vec2 click = fromView(abs(iMouse.zw));\n    vec2 mouse = fromView(abs(iMouse.xy));\n    vec2 absMouse = abs(iMouse.xy);\n    bool down = iMouse.z > 0.;\n    bool pressed = iMouse.w > 0.;\n    bool init = iFrame == 0;\n    float demo = float(iMouse == vec4(0));\n    int activeIndex = getActiveIndex();\n\n    vec2 o  = getPoint(0);\n    vec2 du = getPoint(1) - o;\n    vec2 dv = getPoint(2) - o;\n\n    vec2 g  = getPoint(3);\n    vec2 gu = o + du * g.x;\n    vec2 gv = o + dv * g.y;\n    \n    if (I == ivec2(0, 1))\n    {\n        if (init)\n        {\n            activeIndex = -1;\n        }\n        else if (pressed)\n        {\n            activeIndex = -1;\n            float best = 30. * f;\n            for (int i=0 ; i<3 ; ++i)\n            { float r = distance(mouse, getPoint(i)); if (r < best) activeIndex = i, best = r; }\n            { float r = distance(mouse, fromView(g*iResolution.xy)); if (r < best) activeIndex = 3, best = r; }\n            { float r = distance(mouse, gu); if (r < best) activeIndex = -2, best = r; }\n            { float r = distance(mouse, gv); if (r < best) activeIndex = -3, best = r; }\n        }\n        else if (!down)\n        {\n            activeIndex = -1;\n        }\n        C = vec4(activeIndex);\n    }\n    else if (I.y == 0 && I.x < npoints)\n    {\n        if (init || demo!=0.)\n        {\n            //C = vec4(.5, .5, 0, 0);\n            if (I.x == 0) C = vec4(.5 + 0.3 * demo * sin(iTime), .2, 0, 0);\n            if (I.x == 1) C = vec4(.8, .6 + 0.1 * demo * cos(iTime), 0, 0);\n            if (I.x == 2) C = vec4(.2, .6 - 0.1 * demo * cos(iTime), 0, 0);\n            if (I.x == 3) C = vec4(.15, .2, 0, 0) + 0.1 * demo * vec4(cos(iTime/5.), sin(iTime/5.), 0, 0);\n            if (I.x != 3)\n            {\n                C.xy *= iResolution.xy;\n                C.xy = fromView(C.xy);\n            }\n        }\n        else if (down)\n        {\n            if (activeIndex == I.x)\n            {\n                if (activeIndex == 3)\n                    C = vec4(absMouse / iResolution.xy, 0, 0);\n                else\n                    C = vec4(mouse, 0, 0);\n            }\n            else if (activeIndex == -2 && I.x == 3)\n                C.x = dot(mouse - o, du) / dot(du, du);\n            else if (activeIndex == -3 && I.x == 3)\n                C.y = dot(mouse - o, dv) / dot(dv, dv);\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define getActiveIndex() int(texelFetch(iChannel0, ivec2(0, 1), 0).x)\n#define getPoint(i) texelFetch(iChannel0, ivec2(i, 0), 0).xy\n\nconst int npoints = 4;\n\nfloat f;\nvec2 cResolution;\n\nvoid initView(vec3 iResolution)\n{\n    f = 5. / iResolution.y;\n    cResolution = iResolution.xy;\n}\n\nvec2 fromView(vec2 O)\n{\n    vec2 uv = O;\n    uv.x -= cResolution.x / 2.;\n    uv.y -= cResolution.y / 2.;\n    uv *= f;\n    return uv;\n}\n\nfloat inf = 1e3;\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float i, float j)\n{\n    vec2 v = b - a;\n    vec2 l = p - a;\n    float h = dot(l, v) / dot(v, v);\n    return length(l - v * clamp(h, i, j));\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    return sdLine(p, a, b, 0., 1.);\n}\n\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(1. - r, 0., 1.));\n}\n\nvec4 blend2(vec4 C, vec3 c, float r)\n{\n    return blend(blend(C, vec3(0), r-1.), c, r);\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nconst vec3 colors[] = vec3[](\n    vec3(0,.2,1),\n    vec3(1,.2,0),\n    vec3(0,0.5,0),\n    vec3(0.5)\n);\n\nvec2 P(vec3 x)\n{\n    return x.xy / x.z;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}