{
    "Shader": {
        "info": {
            "date": "1440311780",
            "description": "This is how stars die.\nRecommended Usage:\n1) Put full screen on a large screen\n2) Turn off all lights in the room\n3) listen to deepspacehouse on mixes.beatport.com\n4) Enjoy!",
            "flags": 64,
            "hasliked": 0,
            "id": "MllSDX",
            "likes": 164,
            "name": "Dying Universe",
            "published": 3,
            "tags": [
                "star",
                "bounce",
                "universe"
            ],
            "usePreview": 0,
            "username": "BigWIngs",
            "viewed": 6235
        },
        "renderpass": [
            {
                "code": "// \"Dying Universe\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n// Song:\n// Cubicolor - Fictionalise (Lindstr√∏m & Prins Thomas Remix)\n// https://soundcloud.com/cubicolor/fictionalise-lindstrom-prins-thomas-remix\n\nvec4 COOLCOLOR = vec4(1.,.5,0.,0.);\nvec4 HOTCOLOR = vec4(0.,0.1,1.,1.);\n\nvec4 MIDCOLOR = vec4(0.5,0.3,0.,1.);\nfloat STARSIZE = 0.03;\n#define NUM_STARS 100\n#define NUM_BOUNCES 6\n#define FLOOR_REFLECT\n\n#define saturate(x) clamp(x,0.,1.)\nfloat DistSqr(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); } \nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nconst vec3 up = vec3(0.,1.,0.);\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\nfloat time;\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nvec4 Noise401( vec4 x ) { return fract(sin(x)*5346.1764); }\nvec4 Noise4( vec4 x ) { return fract(sin(x)*5346.1764)*2. - 1.; }\nfloat Noise101( float x ) { return fract(sin(x)*5346.1764); }\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\nfloat PeriodicPulse(float x, float p) {\n    // pulses from 0 to 1 with a period of 2 pi\n    // increasing p makes the pulse sharper\n\treturn pow((cos(x+sin(x))+1.)/2., p);\n}\n\nfloat SlantedCosine(float x) {\n    // its a cosine.. but skewed so that it rises slowly and drops quickly\n    // if anyone has a better function for this i'd love to hear about it\n\tx -= 3.55;\t// shift the phase so its in line with a cosine\n    return cos(x-cos(x)*0.5);\n}\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\n\n\nfloat BounceFast(float t) {\n\t// Precomputed bounced interpolation\n    // 2 bounces, decay of 0.3\n    \n    t *= 2.695445115; // comment out if you don't need t normalized\n    \n    float a1 = 1.-t*t;\n    t -= 1.5477225575; // 1 + sqrt(0.3)\n    float a2 = 0.3-t*t;\n    t -= 0.8477225575; // sqrt(0.3) + sqrt(0.09)\n    float a3 = 0.09-t*t;\n    \n    return max(max(a1, a2), max(a3, 0.));\n}\n\n#define NUM_ARCS NUM_BOUNCES+1\nfloat Bounce(float t, float decay) {\n    // Returns a bounced interpolation\n    // t = time\n    //     start of bounce is 0   \n    //     end of bounce depends on number of bounces and decay param\n    // decay = how much lower each successive bounce is\n    //\t\t0 = there is no bounce at all\n    //\t\t0.5 = each successive bounce is half as high as the previous one\n    //\t\t1 = there is no energy loss, it would bounce forever\n \n    \n    float height = 1.;\n    float halfWidth=1.;\n    float previousHalf = 1.;\n    \t\t\n    float y = 1.-t*t;\n   \n    height = 1.;\n    for(int i=1; i<NUM_BOUNCES; i++) {\n        height *= decay;\n        previousHalf = halfWidth;\n    \thalfWidth = sqrt(height);\n        t -= previousHalf + halfWidth;\n        y = max(y, height - t*t);\n    }\n    \n    return saturate( y );\n}\n\nfloat BounceNorm(float t, float decay) {\n    // Returns a bounced interpolation\n    // Like Bounce but this one is time-normalized\n    // t = 0 is start of bounce\n    // t = 1 is end of bounce\n    \n    float height = 1.;\n    \n    float heights[NUM_ARCS]; heights[0] = 1.;\n    float halfDurations[NUM_ARCS]; halfDurations[0] = 1.;\n    float halfDuration = 0.5;\n    for(int i=1; i<NUM_ARCS; i++) {\t\t\t// calculate the heights and durations of each bounc\n    \theight *= decay;\n        heights[i]= height;\n        halfDurations[i] = sqrt(height);\n        halfDuration += halfDurations[i];\n    }\t\n\tt*=halfDuration*2.;\t\t\t\t\t\t// normalize time\n    \t\t\n    float y = 1.-t*t;\n   \n    for(int i=1; i<NUM_ARCS; i++) {\n        t -=  halfDurations[i-1] + halfDurations[i];\n        y = max(y, heights[i] - t*t);\n    }\n    \n    return saturate( y );\n}\n\nvec3 IntersectPlane(ray r, vec4 plane) {\n    // returns the intersection point between a ray and a plane\n\tvec3 n = plane.xyz;\n    vec3 p0 = plane.xyz*plane.w;\n    float t = dot(p0-r.o, n)/dot(r.d, n);\n    return r.o+max(0.,t)*r.d;\t\t\t\t// not quite sure what to return if there is no intersection\n    \t\t\t\t\t\t\t\t\t\t// right now it just returns the ray origin\n}\nvec3 IntersectPlane(ray r) {\n    \t// no plane param gives ground-plane intersection\n    return IntersectPlane(r, vec4(0.,1.,0.,0.));\n}\n\nfloat Circle(vec2 pos, vec2 uv, float radius) {\n\treturn smoothstep(radius, radius*0.9, length(uv-pos));\n}\n\n// -------------------------------------------------------------\n\n\nvec4 Star(ray r, float seed) {\n    vec4 noise = Noise4(vec4(seed, seed+1., seed+2., seed+3.));\n    \n\tfloat t = fract(time*0.1+seed)*2.;\n    \n    float fade = smoothstep(2., 0.5, t);\t\t// fade out;\n    vec4 col = mix(COOLCOLOR, HOTCOLOR, fade); // vary color with size\n    float size = STARSIZE+seed*0.03;\t\t\t\t\t// random variation in size\n    size *= fade;\n    \n    float b = BounceNorm(t, 0.4+seed*0.1)*7.;\n    b+=size;\n    \n    vec3 sparkPos = vec3(noise.x*10., b, noise.y*10.);\n    vec3 closestPoint = ClosestPoint(r, sparkPos);\n    \n    float dist = DistSqr(closestPoint, sparkPos)/(size*size);\n    float brightness = 1./dist;\n    col *= brightness;\n    \n    \n    return col;\n}\n\nvec3 stars[100];\n\nvec4 Star2(ray r, int i) {\n    vec3 sparkPos = stars[10];\n    vec3 closestPoint = ClosestPoint(r, sparkPos);\n    \n    float dist = DistSqr(closestPoint, sparkPos)/(0.01);\n    float brightness = 1./dist;\n    vec4 col = vec4( brightness );\n    \n    \n    return col;\n}\n\nvec4 Stars(ray r) {\n    vec4 col = vec4( 0. );\n    \n    float s = 0.;\n    for(int i=0; i<NUM_STARS; i++) {\n    \ts++;\n        col += Star(r, Noise101(s));\n    }\n    \n    return col;\n}\n\nfloat Greasy(vec3 I) {\n    vec3 q = 8.0*I;\n    float f;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    \n    return f;\n        \n}\n\nvec4 CalcStarPos(int i) {\n\t// returns the position in xyz and the fade value in w\n    \n    float n = Noise101(float(i));\n    \n    vec4 noise = Noise4(vec4(n, n+1., n+2., n+3.));\n    \n\tfloat t = fract(time*0.1+n)*2.;\n    \n    float fade = smoothstep(2., 0.5, t);\t\t// fade out;\n    \n    float size = STARSIZE+n*0.03;\t\t\t\t\t// random variation in size\n    size *= fade;\n    \n    float b = BounceNorm(t, 0.4+n*0.1)*7.;\n    b+=size;\n    \n    vec3 sparkPos = vec3(noise.x*10., b, noise.y*10.);\n    \n    return vec4(sparkPos.xyz, fade);\n}\n\nvec4 Ground(ray r) {\n\t\n    vec4 ground = vec4(0.);\n    \n    if(r.d.y>0.) return ground;\n    \n    vec3 I = IntersectPlane(r);\t\t// eye-ray ground intersection point\n    \n    vec3 R = reflect(r.d, up);\n    ray ref = ray(I, R);\n    \n    for(int i=0; i<NUM_STARS; i++) {\n    \tvec4 star = CalcStarPos(i);\n        \n        vec3 L = star.xyz-I;\n        float dist = length(L);\n        L /= dist;\n        \n        float lambert = saturate(dot(L, up));\n        float light = lambert/pow(dist,1.);\n       \n        \n        vec4 col = mix(COOLCOLOR, MIDCOLOR, star.w); // vary color with size\n        vec4 diffuseLight =  vec4(light)*0.1*col;\n        \n        ground += diffuseLight*(sin(time)*0.5+0.6);\n        \n        #ifdef FLOOR_REFLECT\n        float spec = pow(saturate(dot(R, L)), 400.);\n        float fresnel = 1.-saturate(dot(L, up));\n        fresnel = pow(fresnel, 10.);\n        \n        vec4 specLight = col*spec/(dist);\n        specLight *= star.w;\n        ground += specLight*0.5*fresnel;\n        #endif\n        \n    }\n    \n    \n    return ground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    \n\ttime = iTime*0.2;\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n   \n    time *= 2.;\n    \n\tfloat t = time*pi*0.1;\n    COOLCOLOR = vec4(sin(t), cos(t*0.23), cos(t*0.3453), 1.)*0.5+0.5;\n    HOTCOLOR = vec4(sin(t*2.), cos(t*2.*0.33), cos(t*0.3453), 1.)*0.5+0.5;\n   \t\n    vec4 white = vec4(1.);\n    float whiteFade = sin(time*2.)*0.5+0.5;\n    HOTCOLOR = mix(HOTCOLOR, white, whiteFade);\n    \n    MIDCOLOR = (HOTCOLOR+COOLCOLOR)*0.5;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat3 rot = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    float camHeight = mix(3.5, 0.1, PeriodicPulse(time*0.1, 2.));\n    vec3 pos = vec3(0., camHeight, -10.)*rot*(1.+sin(time)*0.3);\n   \t\n    CameraSetup(uv, pos, vec3(0.), 0.5);\n    \n    fragColor = Ground(cam.ray);\n    fragColor += Stars(cam.ray);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 10921,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/cubicolor/fictionalise-lindstrom-prins-thomas-remix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}