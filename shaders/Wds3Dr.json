{
    "Shader": {
        "info": {
            "date": "1545826082",
            "description": "Gilmore Leaves",
            "flags": 0,
            "hasliked": 0,
            "id": "Wds3Dr",
            "likes": 1,
            "name": "Simplest Gilmore Leaves",
            "published": 3,
            "tags": [
                "procedural",
                "texture",
                "leaves"
            ],
            "usePreview": 0,
            "username": "dalerank",
            "viewed": 465
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535;\nconst float flipTime  = 2.;\n\nvec2 tileDims = vec2(3.0,3.0); //number of rows ,columns\n\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 rotate2D(vec2 position, float theta)\n{\n    float cost = 0.5;//cos(theta);\n    float sint = 0.5;//sin(theta)\n    mat2 m = mat2(cost, -sint, sint, cost);\n    return m * position;\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//returns 1 for inside circ, 0 for outside\nfloat circle(in vec2 _st, in vec2 pos, in float _radius){\n    \n    float circEdge  =  20.0 / iResolution.x;\n    \n    vec2 dist = _st - pos;    \n\treturn 1. - smoothstep(_radius-(_radius*circEdge),\n                         _radius+(_radius*circEdge),\n                         dot(dist,dist)*4.0);\n}\n\nvec3 gilmoreCol(float x){    \n    //offset hue to put red in middle\n    float hue = ((1.0 - x) - 0.45);    \n    //saturation is higher for warmer colors\n    float sat = 0.3 + (x*PI);    \n    //brightness higher in middle\n    float bri = (smoothstep(0.,0.6, x) - smoothstep(0.6,1.0,x))*.6 + 0.3;  \n    return vec3(hue, sat,bri);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = uv * 4.0;//vec2( fragCoord.xy * 2.0 - 0.5*iResolution.xy ) / min(iResolution.x,iResolution.y);\n    \n    //number of rows ,columns\n    tileDims = vec2(8,8);\n    \n    //rotate\n    uvs = rotate2D(uvs,0.8);\n    \n    float colId = (uvs.x * tileDims.x);   \n    float rndColumn = 1.0;\n    float rnd = random(floor(uvs.xy * tileDims));\n    \n    vec3 tileHSV;\n    tileHSV = gilmoreCol(rnd/2.6);       \n             \n    //get random int 0 - 3 per tile\n    float tileRnd = random(floor(uvs.xy * tileDims ) * 99.89 );\n    tileRnd = floor(tileRnd * 4.);\n    \n    //st is 0-1 coords within tile \n    vec2 st = fract(uvs * tileDims);\n    \n    //flip tiles\n    if (tileRnd == 1.) {\n    \tst.y = 1.0 - st.y;        \n    } else if (tileRnd == 3.) {        \n        st.x = 1.0 - st.x;    \n        st.y = 1.0 - st.y;    \n    }\n    \n    //draw circles\n    float circ = circle(st,vec2(-0.0,0.0),4.);\n\ttileHSV.z *= circ;\n  \n    //column shadows\n    float hShadow = smoothstep(0.4, 0., fract(-uvs.x*tileDims.x)) * 0.12;\n   \ttileHSV.z -= hShadow;\n    \n    //screen vertical brightness gradient\n    tileHSV.z -= fract( 1.0 - uv.y  ) * 0.3;\n    fragColor = vec4(hsv2rgb(tileHSV),0.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}