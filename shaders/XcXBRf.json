{
    "Shader": {
        "info": {
            "date": "1724093574",
            "description": "WTPFL - Minesweeper/2024 graphics shader\n Hello, this is the shader used by the 4KiB Minesweper/2024 to render the graphics.\n\nThanks to Virgill for the music. Thanks to Pestis for Sointu (the music program and player)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XcXBRf",
            "likes": 17,
            "name": "Minesweeper/2024 graphics shader",
            "published": 3,
            "tags": [
                "2d",
                "game"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "// WTPFL - Minesweeper/2024 graphics shader\n//  Hello, this is the shader used by the 4KiB Minesweper/2024 to render the graphics\n//  I haven't managed to port the entire game as a shader (I suppose it could be done)\n//  Instead I thought I just share the shader code in case someone is interested \n\n// Thanks to Virgill for the music. Thanks to Pestis for Sointu (the music program and player)\n\n// The demozoo link: https://demozoo.org/productions/355430/\n\n\n// Here is a prelude to setup the debugging\n\nconst int\n  CELLS       = 12\n, HCELLS      = CELLS/2\n, STATE_SIZE  = 2\n;\n\nconst float STATE_SLEEP = 1./8.;\n\n// The game state is injected as uniform vec4 array \n//  to support debugging this is a test state\nvec4[CELLS*CELLS+STATE_SIZE] state = vec4[](\n  vec4(1920, 1080, 0, 0)  // resx, resy, game_time, board_time\n, vec4(0, 0, 0, 13)  // mousex, mousey, boardscore, remaining\n, vec4(0, 0, 0, 0)  // cell - 0; state,prev_state,changed_time,mouse_time\n, vec4(0, 0, 0, 0)  // cell - 1\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 1, 0) // Render uncovered\n, vec4(1, 2, 1, 0) // Render covered_empty\n, vec4(2, 1, 1, 0) // Render covered_flag\n, vec4(3, 1, 1, 0) // Render uncovering\n, vec4(4, 1, 1, 0) // Render exploding\n, vec4(5, 4, 1, 0) // Render exploded\n, vec4(6, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(-1, 0, 1, 0) // Render number\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(-1, 0, 1, 0) // Render number\n, vec4(0, 0, 0, 0)\n, vec4(-1, 0, 1, 0) // Render number\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(-1, 0, 1, 0) // Render number\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(-1, 0, 0, 0)\n, vec4(-2, 0, 0, 0)\n, vec4(-3, 0, 0, 0)\n, vec4(-4, 0, 0, 0)\n, vec4(-5, 0, 0, 0)\n, vec4(-6, 0, 0, 0)\n, vec4(-7, 0, 0, 0)\n, vec4(-8, 0, 0, 0)\n, vec4(-9, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(1, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 1)  // Mouse left at 1 sec\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n, vec4(0, 0, 0, 0)\n);\n\n// CUT FROM HERE -->\n\n// This is the start of the actual shader\n\nconst float\n    BORDER_DIM      = .825\n  , CELL_DIM        = float(BORDER_DIM)/float(HCELLS)\n  , PI              = acos(-1.)\n  , TAU             = 2.*PI\n  , tcw             = BORDER_DIM/6.\n  , fz              = .25\n  , tz              = .05\n  , cz              = CELL_DIM\n  , tr              = .75\n  , textChars[12]   = float[](\n        5.   // S\n      , 12.  // C\n      , 0.   // O\n      , 17.  // R\n      , 14.  // E\n      , 19.  // BLANK\n      , 16.  // L\n      , 14.  // E\n      , 15.  // F\n      , 18.  // T\n      , 19.  // BLANK\n      , 19.  // BLANK\n      )\n  ;\n\nvec2\n    ddim        = vec2(.75, .075)\n    // Controls button look for different states\n  , bstates[7]  = vec2[](\n      vec2(0  ,0)\n    , vec2(.5 ,1)\n    , vec2(4  ,2)\n    , vec2(10 ,1)\n    , vec2(10 ,2)\n    , vec2(4  ,1)\n    , vec2(10 ,2)\n    )\n  ;\n\nint ddigits[20] = int[](\n    0x7D // 0, O\n  , 0x50 // 1\n  , 0x4F // 2\n  , 0x57 // 3\n  , 0x72 // 4\n  , 0x37 // 5, S\n  , 0x3F // 2\n  , 0x51 // 7\n  , 0x7F // 8\n  , 0x77 // 9\n  , 0x7B // A\n  , 0x3E // B\n  , 0x2D // C\n  , 0x5E // D\n  , 0x2F // E\n  , 0x2B // F\n  , 0x2C // L\n  , 0xFB // R\n  , 0x29 // T\n  , 0x00 // BLANK\n  );\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 palette(float a) {\n  return 1.+sin(vec3(-4.,3.,1.)/2.+a);\n}\n\nfloat segmentx(vec2 p, vec2 dim) {\n  float o = (dim.x-dim.y)/2.;\n  p.x = abs(p.x);\n  return (p.x < o ? abs(p.y) : length(p-vec2(o, 0)))-dim.y;\n}\n\nvec3 digit(vec2 p, vec3 acol, vec3 icol, float caa, float n) {\n  vec2\n      ap = abs(p)\n    , p0 = p\n    , p2 = p\n    , p1 = ap.yx-.5\n    , sp = sign(p)\n    ;\n\n  if (ap.x > (.6+ddim.y)||ap.y > (1.1+ddim.y)) return vec3(0);\n\n  p0.y -= 1.;\n  float n0 = round(p0.y);\n  p0.y -= n0;\n\n  p2.y  = ap.y-.5;\n  p2    = abs(p2);\n\n  // Praying bit shift operations aren't TOO slow\n  vec3 scol =\n      ((ddigits[int(floor(n))] & (1 << int(dot(vec2(1., -1.)/sqrt(2.), p2) > 0. ? (3.+(sp.x+1.)/2. + sp.y+1.) : -n0))) == 0)\n    ? icol\n    : acol\n    ;\n\n  return scol*smoothstep(caa, -caa, min(segmentx(p0, ddim), segmentx(p1, ddim)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // This code uses way too many different variable names.\n  //  Bad for compression\n  \n  vec2\n      res = state[0].xy\n  ;\n\n  // REMOVE FROM HERE -->\n  //  This is debug code to introduce changing content as we don't want to modify the arrays\n\n  //  If we mutate the state array it sucks of lot of GPU\n  //  possibly mutable arrays not cool to GPUs\n  res = iResolution.xy;\n  // <-- REMOVE FROM HERE\n\n  vec2 \n    , p   = (2.*gl_FragCoord.xy-res)/res.yy\n    , ap  = abs(p)\n    , tcp = p\n    , ts  = vec2(tr*tcw, tcw)\n    , cp\n    , np\n    , tnp\n    , cp4\n    ;\n\n  float\n      atm = state[0].z/2.\n    , bs  = state[1].z\n    , gtm = state[0].w\n    , rem = state[1].w\n    , aa  = sqrt(2.) / res.y\n    , caa = aa/cz\n    , taa = aa/tz\n    , faa = aa/(fz*cz)\n    , sty = sign(tcp.y)\n    , fi\n    ;\n\n  // REMOVE FROM HERE -->\n  //  This is debug code to introduce changing content as we don't want to modify the arrays\n\n  //  If we mutate the state array it sucks of lot of GPU\n  //  possibly mutable arrays not cool to GPUs\n  atm = (iTime-1.)/2.;\n  // Repeat every 10 sec to see the animations\n  gtm = mod(iTime,10.);\n  bs  = iTime+2.;\n  // <-- REMOVE FROM HERE\n\n  vec3\n      col = vec3(0.)\n    , ro  = vec3(0.,0.,atm)\n    // Quick n dirty ray direction\n    , rd  = normalize(vec3(p,2))\n    ;\n\n  // Setting up various cells and coordinates. I forgotten mostly why and how :) \n  cp = p/cz-.5;\n\n  tcp.x -= p.y/5.-tcw*tr/2.;\n  tcp.y = abs(tcp.y)-.9;\n\n  tcp /= ts;\n\n  tnp = round(tcp);\n  np  = round(cp);\n\n  tcp -= tnp;\n  cp -= np;\n\n  cp4 = cp*cp*cp*cp;\n\n  tcp *= ts;\n  tcp.y *= sty;\n\n  np += float(HCELLS);\n\n  tcp /= tz;\n\n  fi = np.x+np.y*float(CELLS)+float(STATE_SIZE);\n\n  // The \"fancy\" background\n  for (int i = 1; i < 9; ++i) {\n    // Find ray plane intersection, use abs to test both left and right at the same time\n    float tw = -(ro.x-6.*sqrt(float(i)))/abs(rd).x;\n\n    vec3 wp = ro+rd*tw;\n\n    vec2\n        wp2 = wp.yz*2E-2\n      , wn2 = round(wp2)\n      , wc2 = wp2 - wn2\n      ;\n\n    // The background is the classic truchet pattern essentially\n    if (hash(wn2+float(i)+.5*sign(rd.x)) < .5)\n      wc2 = vec2(wc2.y, -wc2.x);\n\n    float\n        fo = smoothstep(-.7, 1., sin(wp.z/9.+atm+float(i)+sign(rd.x)))\n      , wd  = abs(min(length(wc2+.5)-.5, length(wc2-.5)-.5))-.025\n      ;\n\n    col += palette(5E-2*tw+atm)*exp(-3E-3*tw*tw)*25E-4/max(abs(wd), 3E-3*fo)*fo;\n  }\n\n  // The score and left digits\n  if (tnp.y == 0. && abs(tnp.x-.5) < 6.) {\n    float\n      v = sty > 0. ? bs : rem\n    , d = tnp.x > 0. ? mod(v*pow(10., tnp.x-6.), 10.) : textChars[int(tnp.x+5.+3.*(1.-sty))];\n    vec3\n        acol = palette(2.5+1.5*sty+.4*tcp.y+(tnp.x < 1. ? 0.:3.))\n      , icol = acol*.075\n      ;\n    col += digit(tcp, acol, icol, taa, d);\n  }\n\n  if (max(ap.x, ap.y) < BORDER_DIM) {\n    vec4 c = state[int(fi)];\n\n    float\n        cts = c.z\n      , mts = c.w\n      , d1  = pow(dot(cp4, cp4), 1./8.)-.45\n      , mfo = smoothstep(mts+1./2., mts+1./8., gtm)\n      , sfo = smoothstep(cts, cts+STATE_SLEEP, gtm)\n      ;\n\n    vec3 ccol  = tanh(col*8.)/8.;\n\n    // Loops twice, first for the current state, and second for previous state. Then mix them to create the animation result\n    for (int i = 0; i < 2; ++i) {\n      float\n        // Picking the state\n        cs    = i == 0?c.y:c.x\n        // Mixing factor\n      , m     = i == 0?1.-sfo:sfo\n      , gd    = abs(length(cp)-mfo/9.)\n      ;\n      vec2 bstate = bstates[int(cs)];\n      for (float yy = 0.; yy < bstate.y; ++yy) {\n        gd = min(abs(gd-.1), gd);\n      }\n      vec3 scol =(.2+palette(2.-cs))*(bstate.x*5E-3/max(gd, 3E-3));\n\n      // State 0 or less, means it's a digit\n      if (cs < 1.) {\n        vec2 fcp = cp/fz;\n        fcp.x += -fcp.y/8.;\n        // \"Fancy\" colors\n        vec3\n            acol = palette(cs/2.-fcp.y/2.)\n          , icol = acol/20.\n          ;\n        // If not a zero then render the digit\n        if (cs < 0.) {\n          ccol += digit(fcp, acol, icol, faa, -cs);\n        }\n      } else {\n        // Render the button\n        ccol   = mix(ccol, scol, m*smoothstep(caa, -caa, d1));\n      }\n    }\n\n    // Draw the cell graphics \n    col = mix(col, ccol, smoothstep(caa, -caa, d1));\n    // Draw the cell grid \n    col = mix(col, mix(palette(3.+p.y)/3.,vec3(1.), mfo), smoothstep(caa, -caa, abs(d1)-1./80.));\n  }\n\n  // We are done! sqrt for approximate sRGB conversion, tanh for approximate [0,inf[ to [0,1] mapping\n  fragColor = vec4(sqrt(tanh(col)), 1.);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}