{
    "Shader": {
        "info": {
            "date": "1721895705",
            "description": "LVEB shader",
            "flags": 0,
            "hasliked": 0,
            "id": "4cBcz1",
            "likes": 0,
            "name": "Smoked cherry",
            "published": 3,
            "tags": [
                "cherry"
            ],
            "usePreview": 0,
            "username": "julienledortz",
            "viewed": 63
        },
        "renderpass": [
            {
                "code": "// Fonction pour échantillonner une texture cubique en utilisant les coordonnées et les normales\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec4 x = texture( sam, p.yz ); // Échantillonner la texture sur l'axe YZ\n    vec4 y = texture( sam, p.zx ); // Échantillonner la texture sur l'axe ZX\n    vec4 z = texture( sam, p.xy ); // Échantillonner la texture sur l'axe XY\n    vec3 w = pow( abs(n), vec3(k) ); // Pondération basée sur les normales, avec un exposant k\n    return (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z); // Mélange des échantillons en fonction des poids\n}\n\n// Fonction pour créer une carte de déplacement perturbée par des sinus\nvec4 map( vec3 p )\n{\n    // Ajout de perturbations sinusoidales aux coordonnées\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.1 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.1 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.1 );\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.3 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.3 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.3 );\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.2 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.2 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.2 );\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.1 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.1 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.1 );\n    \n    // Calcul d'une distance modifiée et mise à l'échelle\n    float d1 = length(p.xz) - 1.0;\n    d1 *= 0.01;    \n\n    return vec4( d1, p ); // Retourne la distance et la position perturbée\n}\n\n// Fonction pour trouver l'intersection d'un rayon avec la surface définie par `map`\nvec4 intersect( in vec3 ro, in vec3 rd, in float maxd )\n{\n    vec3 res = vec3(-1.0); // Initialisation du résultat avec une valeur par défaut\n    float precis = 0.0001; // Précision de l'intersection\n    float t = 1.0; // Distance de marche initiale\n    \n    // Boucle de marche pour trouver l'intersection\n    for( int i=0; i<2048; i++ )\n    {\n        vec4 tmp = map( ro+rd*t ); // Calcul de la carte à la position actuelle\n        res = tmp.yzw; // Stocke les coordonnées perturbées\n        float h = tmp.x; // Récupère la hauteur\n        if( h<precis || t>maxd ) break; // Arrête si proche de la surface ou si trop loin\n        t += h; // Avance le rayon\n    }\n\n    return vec4( t, res ); // Retourne la distance de l'intersection et les coordonnées\n}\n\n// Fonction pour calculer la normale à une position donnée sur la surface\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.001; // Petite épsilon pour l'approximation de la dérivée\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n                      e.yyx*map( pos + e.yyx ).x + \n                      e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x ); // Moyenne pondérée des dérivées\n}\n\n// Fonction pour calculer l'occlusion ambiante à une position donnée\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.2; // Hauteur de l'échantillon\n    float ao = 0.0; // Valeur d'occlusion ambiante\n    \n    // Boucle pour échantillonner l'environnement et calculer l'occlusion\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,5.13,10.71)+vec3(0.0,0.5,0.0) ); // Direction d'échantillonnage\n        dir *= sign(dot(dir,nor)); // Signe pour la direction vers l'extérieur\n        float d = map( pos + h*dir ).x; // Distance à la surface\n        ao += max(0.0,h-d*2.0); // Accumulation de l'occlusion\n    }\n    return clamp( 4.0 - 2.5*ao, 0.0, 1.0 ); // Retourne l'occlusion clippée\n}\n\n// Fonction principale pour générer l'image de chaque fragment\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z > 0.0 ) m = iMouse.xy / iResolution.xy;\n\n    float an = 0.1 * iTime - 50.0 * m.x;\n    vec3 ro = vec3(4.5 * sin(an), 0.0, 4.5 * cos(an));\n    vec3 ta = vec3(1.0, 1.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(1.0, 2.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 3.0 * ww);\n\n    vec3 col = vec3(0.773,0.8,0.871); // Couleur de fond par défaut\n\n    const float maxd = 8.0;\n    vec4 inn = intersect(ro, rd, maxd);\n    float t = inn.x;\n    if (t < maxd)\n    {\n        vec3 tra = inn.yzw;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\n        col = 0.5 + 0.1 * cos(tra.y * 0.4 + vec3(0.6, 0.1, 0.2)); // Couleur de base perturbée avec teinte rose foncé\n        vec3 pat = texCube(iChannel0, 0.1 * tra, nor, 10.0).xyz; // Texture cubique\n        col *= pat;\n\n        float occ = calcOcc(pos, nor);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 5.0);\n        float spe = 0.3 * pat.x * max(0.0, pow(clamp(dot(-rd, nor), 0.0, 1.0), 10.0)) * occ;\n\n        vec3 lin = vec3(0.5, 11.5, 11.0); // Lumière avec teinte rose foncé\n        lin += vec3(0.5, 0.2, 0.2);\n        lin += 1.0 * fre * vec3(0.8, 0.3, 0.5);\n        lin *= 1.0 + nor.y;\n        col = col * lin + spe;\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}