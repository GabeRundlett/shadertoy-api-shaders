{
    "Shader": {
        "info": {
            "date": "1708386879",
            "description": "Test",
            "flags": 0,
            "hasliked": 0,
            "id": "M323Dz",
            "likes": 5,
            "name": "MidnightTest_4",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 97
        },
        "renderpass": [
            {
                "code": "// musk's lense flare, modified by icecool.\n// \"Modularized\" by SolarLiner, with improvements\n// See the original at: https://www.shadertoy.com/view/4sX3Rs \n\n#define ORB_FLARE_COUNT\t6\n#define DISTORTION_BARREL 1.\n\nmat2 rot(const in float a)\n{\n    vec2 sinCos = vec2( sin( a ), cos( a ) );\n    return mat2(sinCos.y, -sinCos.x,\n                sinCos.x,  sinCos.y);\n}\n\nvoid rot(const in vec2 a, out mat2 rot0, out mat2 rot1)\n{\n    vec2 aSin = sin(a);\n    vec2 aSinN = -aSin;\n    vec2 aCos = cos(a);\n    rot0 = mat2(aCos.x, aSinN.x,\n                aSin.x, aCos.x);\n    rot1 = mat2(aCos.y, aSinN.y,\n                aSin.y, aCos.y);\n}\n\n\n// Courtesy of IÃ±igo Quilez.\nfloat noise( vec2 x, sampler2D iChannel0 )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.x) + f.xy;\n    uv = (uv+ 0.5)/256.0;\n    uv.y = 1.-uv.y;\n    vec2 rg = textureLod( iChannel0, uv, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.x );\n}\n\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n      return length(p-vec2(a,b));\n    }\n    vec4 pVec4 = vec4(p, p)-vec4(0., 0., d, 0.);\n    vec2 dotPVec4 = sqrt(vec2(dot(pVec4.xy, pVec4.xy), dot(pVec4.zw, pVec4.zw)))-vec2(ra, rb);\n    return max(dotPVec4.x, -dotPVec4.y);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n\nvec4 shape(const in vec2 uv, const in vec2 mou, \n           const in vec2 iResolution, const in float iTime, \n           const in sampler2D iChannel0, out mat2 outRot)\n{\n    float ra = 0.9;\n    float rb = 0.75;\n    float di = -0.2;\n    \n    vec2 ang = vec2(iTime) * vec2(.4, .5);\n    \n    float g = noise( uv * 3. + ang.x, iChannel0 );\n    \n    mat2 r0, r1;\n    \n    ang.x = cos(ang.x)*.5+.5;\n    ang.x *= 0.25+radians(45.);\n    rot(ang, r0, r1);\n    \n    vec4 pMC = uv.xyxy - vec4(0., 0., mou);\n    pMC += g * vec2(.05, .01).xxyy;\n    pMC.xy *= r0;\n    pMC.zw *= r1;\n    \n    float m = sdMoon( pMC.xy, di, ra, rb );\n    float c = sdCross( pMC.zw, vec2(0.3, .15), 0.2 );\n\n    float invR = 3. / iResolution.y;\n    \n    vec2 dVec2 = ( vec2( m, c ) );\n    \n    float minMC = min(dVec2.x, dVec2.y);\n    float minMCOut = minMC;\n    \n    float d = minMC-.04;\n    //d -= 0.02;\n    d = d / (fwidth(d) / invR);\n    float s = smoothstep(-invR, invR, d);\n    outRot = r1;\n    \n    return vec4(d, s, minMCOut, g);\n}\n\nvec3 rgbSplit(const in vec3 sD)\n{\n    float r0 = sD.z-.03;\n    float rep = 1./2.;\n    float hRep = rep * 0.5;\n\n    r0 = mod(r0, hRep)-hRep;\n\n    float rr = exp(-16.*sD.z)*sD.y;\n    \n    float absD = 1.;\n    float st = .25;\n    vec3 ID = r0 + hRep * ( vec3( absD ) - st * vec3(0, 1, 2) );\n    ID = abs(ID)-(hRep*.05);\n\n    float sL = 0.5*hRep;\n    \n    vec3 lS = smoothstep(vec3(0), vec3(sL), ID);\n    \n    vec3 colL = mix(vec3(0.992,0.286,0.533), vec3(0, 0, 0), lS.z);\n    colL      = mix(vec3(0.992,0.800,0.388), colL, lS.y);\n    colL      = mix(vec3(0.525,0.918,0.996), colL, lS.x);\n    return colL*rr;\n}\n\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy;\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n    \n    float angle = length(tocenter.xy)*2.221*DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset,0.0);\n    vec2 sinCos = vec2( sin( angle ), cos( angle ) );\n    \n    vec3 rotated = oldoffset * sinCos.y + \n                   cross( prep, oldoffset ) * sinCos.x + \n                   prep * dot( prep, oldoffset ) * ( 1.0 - sinCos.y );\n    \n    return rotated.xy;\n}\n\nfloat dot2(const in vec2 a)\n{\n    return dot(a, a);\n}\n\nvec3 flare(vec2 uv, vec2 pos, float dist, float size)\n{\n    float sizeInv = 1./(size*2.);\n    pos = GetDistOffset(uv, pos);\n    \n    vec4 uvPlusDist = uv.xyxy + (dist + vec2(-.05, .05).xxyy) * pos.xyxy;\n    \n    vec3 uvDot2 = sqrt(vec3(dot2(uvPlusDist.xy), dot2(uv + dist * pos), dot2(uvPlusDist.zw)));\n    uvDot2 = .01-pow(uvDot2, vec3(2.4))*sizeInv;\n    uvDot2 = max(uvDot2, vec3(0.)) * 6.;\n    \n    return uvDot2;\n}\nvec3 flare(vec2 uv, vec2 pos, float dist, float size, vec3 color)\n{\n    return flare(uv, pos, dist, size)*color;\n}\n\nvec3 orb(vec2 uv, vec2 pos, float dist, float size)\n{\n    vec3 c = vec3(0.0);\n    \n    for(int i=0; i<ORB_FLARE_COUNT; i++)\n    {\n        float j = float(i+1);\n        float offset = j/(j+1.);\n        float colOffset = j/float(ORB_FLARE_COUNT*2);\n        \n        c += flare(uv,pos,dist+offset, size/(j+.1), vec3(1.0-colOffset, 1.0, 0.5+colOffset));\n    }\n    \n    c += flare(uv,pos,dist+.5, 4.0*size, vec3(1.0))*4.0;\n    \n    return c/4.0;\n}\nvec3 orb(vec2 uv, vec2 pos, float dist, float size, vec3 color)\n{\n    return orb(uv,pos,dist,size)*color;\n}\n\nvec3 ring(vec2 uv, vec2 pos, float dist)\n{\n    vec2 uvd = uv*(length(uv));\n    \n    vec4 uvdPlusDist = uvd.xyxy + (dist + vec2(-.05, .05).xxyy) * pos.xyxy;\n    vec3 uvdSqrt = sqrt(vec3(dot2(uvdPlusDist.xy), dot2(uvd + dist * pos), dot2(uvdPlusDist.zw)));\n    vec3 rgb = max( vec3( 0. ), 1. / (1. + 32. * pow( uvdSqrt, vec3( 2.) ) ) ) * vec3( 0.25, 0.23, 0.21 );\n    return rgb;\n}\n\nfloat glare(vec2 uv, vec2 pos, float size, const in mat2 r0, const in float n)\n{\n    vec2 main = uv-pos+n * .01;\n    //main += n * 0.01;\n    main *= r0;\n\t\n\tfloat ang = atan( main.y, main.x ) * 1.;\n    float r = length( main );\n    //main = vec2( sin( ang ), cos( ang ) ).yx * r;\n    \n\tfloat dist = sdCross( main, vec2(0.3, .15), 0.2 );//length( main ); \n    float distNonPow = dist;\n    dist = pow( max( dist, 0. ), .1 );\n\t\n\tfloat f0 = 1.0 / ( distNonPow * ( 1.0 / size * 16.0 ) + 3.141559 );\n    \n    f0 = f0 + f0 * ( cos( ( ang ) * 8.0 ) * .5 + dist );\n    return pow(f0, 4.);\n}\n\nvec3 lensflare(vec2 uv,vec2 pos, float brightness, float size)\n{\n    mat2 r0;\n    vec4 sD = shape(uv, pos, iResolution.xy, iTime, iChannel1, r0);\n    //vec3 c = ( vec3( glare( uv, pos, size, r0 ) ) \n    vec3 c = vec3(0);\n    c += vec3( 1. - sD.y );\n    c += glare( uv, pos, size, r0, sD.w );// * sD.y;\n    \n    c += flare(uv,pos, -3., 3.*size);\n    c += flare(uv,pos, -1., size) * 3.;\n    c += flare(uv,pos, .5, .8*size);\n    c += flare(uv,pos,-.4, .8*size);\n    \n    c += orb(  uv,pos,  0.,.5*size);\n    \n    c += ring(uv,pos,-1.)*.5*size;\n    c += ring(uv,pos, 1.)*.5*size;\n    \n    c = c * brightness;\n    \n    vec3 rgb = rgbSplit(sD.xyz);\n    return rgb+c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-iResolution.xy+2.*fragCoord) / iResolution.y;\n    vec2 mou = (-iResolution.xy+2.*iMouse.xy)/iResolution.y;\n    vec4 pMou = vec4(p, mou)*1.2;\n    p = pMou.xy;\n    mou = pMou.zw;\n    \n    vec3 l = lensflare(p, mou, 1., 3.);\n    //l = pow(l, vec3(2.22));\n    \n    fragColor = vec4(l, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}