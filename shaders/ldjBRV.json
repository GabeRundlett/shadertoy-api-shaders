{
    "Shader": {
        "info": {
            "date": "1501270807",
            "description": "mouse sets roundness and distance.\n\na rounded box, done in 3 different approaches, 1 with a basic branch, 2  others use common subroutines.\none special, one small and general.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldjBRV",
            "likes": 6,
            "name": "3 different rounded boxes",
            "published": 3,
            "tags": [
                "rounded",
                "stretch",
                "hgsdf",
                "variations",
                "fbox"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 691
        },
        "renderpass": [
            {
                "code": "#define linethickness .2\n\n/*\nspecial cases of rounded boxes, to construct glyphs.\n\nthe basic approach is; gradients to ellipses are hard, but rounded boxes are simple.\nmix(), max() or smin() of 2 rounded boxes can estimate elliptical shapes nicely.\n*/\n\n/*\n//overly explicit fuzzy variant of max(a,b); but it has \"weirdly fuzzy\" twens\n//these are not useful here, but proves some substitutional utility earlier:\nfloat ma(float a,float b){\n b=clamp(b,0.,1.);//much bettr gradients in combination with the below\n b=a-b;return b*b+a;//only holds true for x=0||x=1;\n //return step(a,b)*(a-b)+a;//only holds true for x=0||x=1;\n //return mix(a,b,step(a,b));\n //if(a>b)return a;return b;\n //return max(a,b);\n}*/\n\n//2 domain max() for box2d\n#define ma2(a) max(a.x,a.y)\n\n//float fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\n//float fBox(vec2 p,vec2 b){vec2 d=abs(p)-b,q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}\nfloat fBox(vec2 p,float b){vec2 d=abs(p)-b,q=min(d,0.);return length(max(d,0.))+ma2(q);}\n//rounded box, using fBox() from hg_sdf\nfloat o4_(vec2 p,float m){return fBox(p,m)+m;}//simple wapper to a general function.\n\n//rounded box, simple branch\nfloat o3_(vec2 p,float m){p=abs(p); \n //return mix(length(p-m)+m,ma2(p),step(-ma2(-p),m));}//branchless\n if(-ma2(-p)>m)return length(p-m)+m;else return ma2(p);}\n\n//#define stretch(a,b) mix(a-b,mix(0.,a,step(a,0.)),step(a,b))\n#define stretch2(a,b) sign(a)*max(abs(a)-b,0.)\n#define stretch(a,b) stretch2(a-b*.5,b*.5)\n//rounded box, using stretch()\nfloat o2_(vec2 p,float m){p=abs(p);float i=ma2(p)-m;\n return length(stretch(p,m))-1.+m+step(i,0.)*i+1.;}\n\n#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U)*6.;\n vec2 m=frame(iMouse.xy)*6.;\n m.x=clamp(abs(m.x),0.,1.); \n vec3 c=vec3(0);\n c.r=o4_(u,m.x);\n c.b=o3_(u,m.x);\n c.g=o2_(u,m.x);\n \n c=abs(c-abs(m.y))-linethickness;//abs offset\n \n c=mix(smoothstep(.01,-.01,c),fract(abs(c*3.+.001)),.25);\n //r=smoothstep(.01,-.01,abs(r)-.05);//lines to smooth thick borders, thikck enough to show gratient/derivatives.\n //d=fract(d*.8);//seesaw first derivative, contrast illusion.\n u=fract(u);\n O=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}