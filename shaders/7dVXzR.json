{
    "Shader": {
        "info": {
            "date": "1634280574",
            "description": "Simple ray-marching scene",
            "flags": 0,
            "hasliked": 0,
            "id": "7dVXzR",
            "likes": 10,
            "name": "Simple ray-marching scene",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "busybeaver",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "#define enable_color_correction 1\n\nfloat max_d = 100000.;\nfloat min_d = 0.0015;\nint max_i = 220;\nfloat rotation_speed = .2;\n\nvec4 s0 = vec4(-4.5, 0., -3., 4.);\nvec4 s1 = vec4(3., -1.8, -2., 2.2);\nvec4 c0 = vec4(1., -1.5, 4., 2.5);\nfloat p1 = -4.03;\nvec4 c2 = vec4(.5, 2.02, 3.5, 1.);\nvec4 s2 = vec4(.5, 4.5, 3.5, 1.5);\nvec4 s3 = vec4(-7., 4., 5., 1.);\n\n#if enable_color_correction\nfloat gamma = 2.2; // For gamma correction.\nfloat exposure = 0.6;\nfloat tone_pow = 0.35; // Represents how strong the tone mapping is.\n\nvec3 correct_color(vec3 c) {\n    c *= exposure;\n    c = pow(c, vec3(1. / tone_pow));\n    c = pow(c / (c + 1.), vec3(tone_pow));\n    c = pow(c, vec3(1. / gamma));\n    return c;\n}\n#endif\n\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\nfloat max_abs(vec3 v) { return max(max(abs(v.x), abs(v.y)), abs(v.z)); }\n\nfloat sphere(vec3 p, vec3 s, float r) { return sqrt(sum((p - s) * (p - s))) - r; }\n\nfloat cube(vec3 p, vec3 s, float r) { return max_abs(p - s) - r; }\n\nvec3 cube_m(vec3 p, vec4 c, vec3 ray) {\n    if(abs(p.x - c.x) > max(abs(p.z - c.z), abs(p.y - c.y))) { ray.x *= -1.; }\n    if(abs(p.y - c.y) > max(abs(p.z - c.z), abs(p.x - c.x))) { ray.y *= -1.; }\n    if(abs(p.z - c.z) > max(abs(p.y - c.y), abs(p.x - c.x))) { ray.z *= -1.; }\n    return ray;\n}\n\nvec3 col(vec3 cam, vec3 ray) {\n    vec3 p = cam;\n    vec3 col = vec3(1., 1., 1.);\n    vec3 col_1 = col;\n    vec3 pcol = vec3(0., 0., 0.);\n    float min_s3d = 2.;\n    bool t;\n    for(int i = 0; i < max_i; i ++) {\n        t = true;\n        float d = max_d;\n        d = min(d, sphere(p, s0.xyz, s0.a));\n        if(d < min_d && t) {\n            ray -= normalize(s0.xyz - p) * dot(s0.xyz - p, ray) / s0.a * 2.;\n            col *= vec3(1., .5, .5);\n            t = false;\n        }\n        d = min(d, sphere(p, s1.xyz, s1.a));\n        if(d < min_d && t) {\n            ray -= normalize(s1.xyz - p) * dot(s1.xyz - p, ray) / s1.a * 2.;\n            col *= vec3(.5, 1., .5) * (float(sin(atan((s1.x - p.x) / (s1.z - p.z)) * 10. + sin(iTime) * 30.) > 0.) * .7 + .3);\n            t = false;\n        }\n        d = min(d, sphere(p, s2.xyz, s2.a));\n        if(d < min_d && t) {\n            ray -= normalize(s2.xyz - p) * dot(s2.xyz - p, ray) / s2.a * 2.;\n            col *= vec3(.2, 1., 1.) * (float(sin(atan(length(s2.xz - p.xz) / (s2.y - p.y)) * 12.) > 0.) * .7 + .3);\n            t = false;\n        }\n        float s3d = sphere(p, s3.xyz, s2.a);\n        if(s3d < min_s3d && s3d < 2.) { min_s3d = s3d; }\n        d = min(d, s3d * .4);\n        if(d < min_d && t) {\n            pcol += vec3(2., 2., 4.) * col;\n            t = false;\n            break;\n        }\n        d = min(d, cube(p, c0.xyz, c0.a));\n        if(d < min_d && t) {\n            ray = cube_m(p, c0, ray);\n            col *= vec3(.4, .4, 1.);\n            t = false;\n        }\n        if(ray.y < 0.) {\n            d = min(d, (p1 - p.y) / ray.y);\n            if(d < min_d && t) {\n                ray.y *= -1.;\n                col *= vec3(.3, .3, .3);\n                t = false;\n            }\n        }\n        d = min(d, cube(p, c2.xyz, c2.a));\n        if(d < min_d && t) {\n            ray = cube_m(p, c2, ray);\n            col *= vec3(1., 1., .1);\n            t = false;\n        }\n        if(!t) {\n            p += ray * min_d * 2.;\n            pcol += col_1 * vec3(1., 1., 2.) * (2. - min_s3d) * (2. - min_s3d) * .5;\n            min_s3d = 2.;\n            col_1 = col;\n        }\n        p += ray * d;\n        if(length(p) > max_d) { break; }\n    }\n    pcol += col * vec3(1., 1., 2.) * (2. - min_s3d) * (2. - min_s3d) * .5;\n    if(length(p) <= max_d && t) { return pcol; }\n    col = col * (ray.yxz * vec3(.65, .45, .45) + vec3(.35, .55, .55)).rgb * (ray.y * 2.5 + .4) *\n    (0.9 + .2 * float(sin(atan(ray.x / ray.z) * 30.) > 0.6)) *\n    (0.9 + .2 * float(sin(atan(ray.y / ray.z) * 30.) > 0.6)) *\n    (0.9 + .2 * float(sin(atan(ray.y / ray.x) * 30.) > 0.6)) + pcol;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n\n    float x = iTime * 1.5 - float(int(iTime * 1.5)) - .5;\n    s2.y = 4.52 + (1. - x * x * 4.) * 2.;\n\n    float t = iTime * rotation_speed;\n    \n    vec3 color = col(\n        vec3(sin(t) * 25., 4., - cos(t) * 25.),\n        normalize(vec3(- sin(t) * 1.3 + cos(t) * uv.x,\n            uv.y - .3, cos(t) * 1.3 + sin(t) * uv.x))\n    );\n    \n    #if enable_color_correction\n    fragColor.rgb = correct_color(color);\n    #else\n    fragColor.rgb = color;\n    #endif\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}