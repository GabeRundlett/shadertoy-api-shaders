{
    "Shader": {
        "info": {
            "date": "1631498340",
            "description": "References to learn:\nInigo Quilez's website and videos.\nhttps://learnopengl.com/\nThe Book of Shaders: https://thebookofshaders.com/",
            "flags": 0,
            "hasliked": 0,
            "id": "NdKGRz",
            "likes": 3,
            "name": "No Basis In Reality",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "prishainabox",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001;\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\nfloat fractalNoise(in vec3 uvw) {\n    float c = noise(uvw * 4.0);\n    c += 0.5 * noise(uvw * 8.0);\n    c += 0.25 * noise(uvw * 16.0);\n    c += 0.125 * noise(uvw * 32.0);\n    c += 0.0625 * noise(uvw * 64.0);\n    c /= 2.0;\n    return c;\n}\n\n// SDFs\n\nfloat sdfSphere(in vec3 pt, in float rad) {\n    return length(pt) - rad;\n}\n\nfloat sdfEllipsoid(in vec3 pt, in vec3 rad) {\n    float k0 = length(pt/rad);\n    float k1 = length(pt/(rad*rad));\n    return k0 * (k0-1.0)/k1;\n}\n\nfloat sdfCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\n\n// SDF SCENE\n// materials\n// -1.0 -> sky\n// 0.0 -> grass\n\nvec4 sdfScene(in vec3 pt) {\n\n    float time = iTime;\n    \n    vec4 res = vec4(1000.0, -1.0, 0.0, 1.0);\n    \n    // water?\n    {\n        float water = sdfSphere(pt, 1.12) + 0.01 * (\n            sin(pt.x * 20.0 + sin(pt.y * 30.0) * 0.8) * \n            sin(pt.y * 20.0 + sin(pt.x * 10.0)) * \n            sin(pt.z * 20.0 + sin(pt.x * 10.0))\n        ) - 0.05 * fractalNoise(pt);\n        if(water > 2.0) return res;\n        if (water < res.x) {\n            res.y = 0.0;\n        }\n        res.x = min(res.x, water);\n    }\n    \n    // planet\n    {\n        float ground = 0.5 * sdfSphere(pt, 0.9) - 0.3 * fractalNoise(pt * 0.7);// - 0.05 * noise(pt);\n        ground -= 0.05 * sin(pt.x * 10.0) * sin(pt.y * 10.0) * sin(pt.z * 10.0);\n        if (ground < res.x) {\n            res.y = 1.0;\n        }\n        res.x = min(res.x, ground);\n    }\n    \n    return res;\n    \n}\n\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdfScene(pt + h.xyy).x - sdfScene(pt - h.xyy).x,\n       sdfScene(pt + h.yxy).x - sdfScene(pt - h.yxy).x,\n       sdfScene(pt + h.yyx).x - sdfScene(pt - h.yyx).x\n    ));\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd) {\n    \n    // result\n    // res.x = closest distance\n    // res.y = material\n    // res.z\n    // res.w\n    vec4 res = vec4(-1.0, -1.0, 0.0, 1.0);\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        vec4 h = sdfScene(ro + td*rd);\n        // if distance is really close, break\n        if (abs(h.x) < (0.0001*td)) {\n           res = vec4(td, h.yzw);\n           break;\n        }\n        // add to total distance\n        td += h.x;\n    }\n       \n    return res;\n    \n}\n\nfloat smoothShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        float d = sdfScene(ro + td*rd).x;\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection, no shadow -> 1.0\n    return res;\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in vec3 lightDir, in vec3 clr, in float shininess, in float shadowK) {\n    float dif = uclamp(dot(nor, lightDir));\n    float shadow = smoothShadow(pt, lightDir, shadowK);\n    vec3 ref = reflect(lightDir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), shininess);\n    // return  dif * clr * shadow * spec + dif * clr * shadow; \n    return  dif * clr * shadow * (spec + 1.0);\n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd) {\n\n    // cast ray, return dist to closest object and material\n    // obj.x = distance, obj.y = material index\n    // obj.z = , obj.w = \n    vec4 res = castRay(ro, rd);\n    vec3 pt = ro + res.x*rd;\n    \n    float time = iTime;\n    \n    // COLORS\n    vec3 planetClr = vec3(0.08, 0.01, 0.13);\n    vec3 skyClr = vec3(0.05, 0.18, 0.45) * 0.01;\n    vec3 waterClr = vec3(0.335, 0.214, 0.147);\n    \n    // background color\n    vec3 clr = skyClr;\n    \n    // return background if too far\n    if (res.x < 0.0) return clr;\n    \n    float mat = res.y; // material\n    float shininess = 5.0;\n    vec3 nor = calcNormal(pt);\n    \n    if (mat == 0.0) {\n        clr = waterClr;\n        shininess = 200.0;\n    } else if (mat == 1.0) {\n        shininess = 100.0;//(pow(random(pt), 2.0) * 2.0 - 1.0) * 50.0 + 100.0;\n        clr = planetClr - 0.1*fractalNoise(pt);// -  sin(pt.x * 7.0) * sin(pt.x * 5.0) * sin(pt.y * 10.0) * vec3(0.1, 0.02, 0.04) * fractalNoise(pt) * vec3(0.4, 0.2, 0.9);\n    }\n    \n    if (mat == 0.0 || mat == 1.0) {\n        float k = uclamp( \n            sin(pt.y * (40.0 + 10.0*(1.0 + sin(pt.y * 20.0))) + \n            sin(pt.z * 30.0 + sin(pt.x * 10.0))) \n        );\n        vec3 c = vec3(\n            0.1 + 0.31 * sin(pt.y * 10.0), \n            0.1 + 0.05 * sin(pt.z * 10.0), \n            0.08 + 0.02 * sin(pt.z * 20.0)\n        );\n        clr += k * c * (0.8 - 0.6*mat);\n        clr *= 0.3;\n    }\n    \n    // LIGHTS\n    \n    vec3 sunClr = 0.4 * vec3(9.8, 6.0, 5.5);\n    vec3 moonClr = vec3(2.13, 2.40, 3.46) * 0.5;\n    \n    vec3 sunDir = normalize(vec3(0.6, 0.55, 0.5) * 2.0 - pt); // directional\n    vec3 moonDir = normalize(vec3(-0.6, 0.0, -0.5) * 3.0 - pt);\n   \n    // CALCULATE COLOR\n    vec3 light = vec3(0.01);\n    light += calcLighting(pt, rd, nor, sunDir, sunClr, shininess, 10.0);\n    light += calcLighting(pt, rd, nor, moonDir, moonClr, shininess, 4.0);\n    // misc lights\n    light += 0.5 * calcLighting(\n        pt, rd, nor, \n        normalize(vec3(0.5, -0.2, 0.1) * 2.5 - pt), 0.5 * vec3(5, 2, 1),\n        shininess, 6.0\n    ); // orangey\n    light += 0.5 * calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.0, 0.2, 0.5) * 2.3 - pt),\n        0.5 * vec3(8, 2, 4), shininess, 3.0\n    ); // red\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(1.9, 0.6, -0.9) * 0.62 - pt),\n        0.5 * vec3(4, 5, 2), shininess, 9.0\n    ); // yellow\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(-0.5, -0.2, 0.1) * 2.5 - pt),\n        vec3(1, 5, 3), shininess, 10.0\n    ); // blue green\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.0, 0.0, -0.5) * 3.0 - pt),\n        0.5 * vec3(6, 5, 4.5), shininess, 8.0\n    ); // pinkish\n    // misc moving lights\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.2 + 0.4*sin(time * 5.0), -0.2 + 0.4*sin(time * 2.0), 0.5 - cos(time)) * 1.2 - pt),\n        vec3(2, 2, 5), shininess, 8.0\n    ); // blue\n    \n    clr *= light;\n    \n    clr = pow(clr, vec3(0.4545));\n    return clr;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = iTime;\n    vec2 mouse = iMouse.xy;\n    vec2 res = iResolution.xy;\n\n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0, 0.0, 0);\n    // ray origin\n    float r = 2.5;\n    vec3 ro = target + vec3(cos(time * 0.5) * r,  0.0, -sin(time * 0.5) * r);\n    \n    vec3 forward = normalize(target - ro); // cam w\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0))); // cam u\n    vec3 up = normalize(cross(right, forward)); // cam v\n    \n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    \n    // calculate color based on distance, etc\n    vec3 clr = calcClr(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}