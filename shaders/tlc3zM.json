{
    "Shader": {
        "info": {
            "date": "1575923643",
            "description": "impulse (e.g. star) response footprint through a real sensor optic is an Airy pattern, related to Bessel function.\nLeft: real Airy intensity. In practice, sensor resolution is saved so as to not get the oscillations.\nRight: thus this smoothed version fA()",
            "flags": 0,
            "hasliked": 0,
            "id": "tlc3zM",
            "likes": 40,
            "name": "Smoothed Airy intensity / glow",
            "published": 3,
            "tags": [
                "glow",
                "fourier",
                "psf",
                "airy",
                "sensor",
                "bessel",
                "glowairy"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1523
        },
        "renderpass": [
            {
                "code": "// cf https://www.desmos.com/calculator/b4fa9jsmsq\n\n#define gauss(x) exp(-.5*((x)*(x)) )\n#define S(v)     smoothstep(1.5*fwidth(v),0.,abs(v))\n\n#if 0\n#define fact(n)  1. // stub valid for 0,1. -> to implement: n! for n >= 2\n\n// --- Bessel function https://en.wikipedia.org/wiki/Bessel_function\nfloat J(float n, float x) { \n    float s = pow(x/2.,n) / fact(n), j = s;\n    for (float p=1.; p<27.; p++)\n        j += s *= - (x*x/4.) / (p*(n+p)) ;\n    return j;\n}\n#define J1(x) J(1.,x)\n\n#else // thanks TinyTexel !\n\nfloat J1(float x) // https://www.sciencedirect.com/science/article/pii/S2211379718300111\n{\n    float xx = x * x, a = 1. + .12138 * xx;\n    return (   sqrt(a) * (46.68634 + 5.82514 * xx) * sin(x) \n             -    x    * (17.83632 + 2.02948 * xx) * cos(x)\n           ) / ( (57.70003 + 17.49211 * xx) * pow( a, 3./4.) );\n}\n\n#endif\n\n// --- Airy intensity https://en.wikipedia.org/wiki/Airy_disk#Mathematical_formulation\nfloat A(float x){ float v = 2.*J1(x)/x; return /* abs(x)>19.5 ? 0. : */ v*v; } \n\n// fast Airy intensity\n//#define fA(x) ( abs(x) < 1.88 ? gauss(x/1.4) : ( gauss(x/1.4) + 2.7/abs(x*x*x) )/2. ) // enveloppe: 2.7/d^3\n  #define fA(x) ( abs(x) < 1.88 ? gauss(x/1.4) : abs(x) > 6. ? 1.35/abs(x*x*x) : ( gauss(x/1.4) + 2.7/abs(x*x*x) )/2. ) // enveloppe: 2.7/d^3\n \n\nvoid mainImage( out vec4 O, vec2 u )  // ---------------------------------------------\n{\n    vec2 R = iResolution.xy,\n         U = 10.* ( 2.*u - R ) / R.y; U.y += 7.;\n    float kC = 30.,                   // curves amplitude gain\n          d = length(U);\n    \n    O = ( U.x<0. ? A(d) : fA(d) ) * vec4(1,.5,.25,0) * 10.; // Airy and fastAiry spots\n    if ( U.y < - .4 && fract(U.y)<.5 ) O -= O;    // black mask, to emphase low values\n    \n    for (float y=0.; y<4.; y++)       // array of dots with 2^n intensity progression\n        for (float x=0.; x< 5.; x++ ) \n            O += fA( 30.*length(U-vec2(5.+3.*x,4.+2.*pow(1.7,y))) ) * exp2(x+5.*y)/8. * vec4(.25,.5,1,0);\n                  // 4.*R.y/20. // 1-pixel spot\n    // --- curves\n    O.r += S( kC*fA(U.x) - U.y );     // fast Airy function\n    O.g += S( kC* A(U.x) - U.y );     // true Airy function\n    O.b += S(U.y) + S(U.x)            // frame\n        + S(U.x-2.1)*sin(10.*U.y);\n    O = vec4( pow(O, vec4(1./2.2)) ); // to sRGB\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}