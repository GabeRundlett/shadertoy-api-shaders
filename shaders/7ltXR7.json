{
    "Shader": {
        "info": {
            "date": "1638902881",
            "description": "It seems in this case that IQ's voronoi edges method makes more sense than Tomkh's. If we want to find borders so we can find the nearest intersection, we actually need to find all the borders around pointA, NOT around the uv (or in this case the ro).",
            "flags": 0,
            "hasliked": 0,
            "id": "7ltXR7",
            "likes": 8,
            "name": "Voronoi (Borders Around Point A]",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "commented",
                "borders",
                "edges",
                "comments",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 353
        },
        "renderpass": [
            {
                "code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n\n=============================================================\n\nAn important discorvery I made, assuming I am understanding\ntomkh's and Iq's work is that actually:\n\nIt seems in this case that IQ's method makes \nmore sense than tomkh's. If we want to find borders \nso we can find the nearest intersection, we actually \nneed to find all the borders around pointA, NOT around \nthe uv (or in this case the ro).\n\nThis way we are garanteed that the edges will be \nthe ones that fully enclose the cell.\n    \nIf you check for borders around ro, you will get borders\nclose to ro for the 3x3 loop which may not find the borders\nin the direction ro+rd*t is even going. So you would then need \na 5x5 loop to do that which is super slow.\n\n==========================================================\n\nHere is a voronoi traversal algorithm I came up with.\nThere are a few hacks involved:\n\n1. When I check edges for a hit I actually check a 5x5 neighborhood\nbecause otherwise the way I do things there are times when not all\nthe correct edges are drawn.\n\n2. The weirdest thing. I find I can't use a constant value \n(such as ray origin) as an input to this algorithm. It has to \nbe moving even a little bit so I jitter with sin(iTime)*0.001\n\nNo idea why. A mouse position will work find and give me the edges, \nbut a set value like vec2(1.,0.) will not. \n\nEDIT: The jitter can be a constant value, we just need to \nbe a tiny bit off from pointA when we checkk pointB for some reason.\nso eps = 0.001 wo\n\n*/\n\n//I used this visual to create \"Border Skipping\"\n//where we don't check every border\n//https://www.shadertoy.com/view/7tcSDn\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n}\n\n/***************************************************\n\nHere is the actual voronoi border finding algorithm\nusing IQ's method of search for point Bs around PointA.\nThis is more effective in the case where you have a single\ncell that you want to find all the borders around.\n\nUsing just a given point in the cell (like a mouse position)\nwould lead to you finding all the borders closest to the \nmoust position. When we only look for 9 borders (3x3 double for loop)\nwe risk getting some of the wrong borders.\n\nWhen we instead check for borders around the \"pointA\"\nthat we found from the first voronoi loop, we get all the \ncorrect borders!\n\n*************************************************** */\n\n\nvec4 voronoiLine(vec2 uv, vec2 m, inout vec3 col){\n\n    vec2 st = fract(m);\n    vec2 stFL = floor(m);\n    vec2 d = vec2(10.);\n    vec2 pointA;\n    vec2 pointB;\n\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 id = vec2(i,j);\n            vec2 rndShift = rnd2(stFL+id);\n            vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n            vec2 testA = stFL + coords;\n            float c = length(coords.xy - st);\n            \n            if(c < d.x){\n                d.x = c;\n                pointA = testA;\n                \n                }\n             }\n          }\n    col = mix(col,vec3(1.,1.,0.),\n                      clamp( point(uv-pointA, 0.1), 0., 1.));\n                      \n    //we want to find the next point from pointA to get \n    //correct edges. Like in IQ's article\n    st = fract(pointA);\n    stFL = floor(pointA+sin(iTime)*0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){   \n        \n            vec2 id = vec2(i,j);\n            vec2 rndShift = rnd2(stFL+id);\n            vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n            vec2 testB = coords+stFL;\n            \n            //check edge\n            \n            if(length(testB-pointA) > 0.001){\n                vec2 edgePoint = (pointA+testB) / 2.;\n                \n                col = mix(col,vec3(0.,0.,1.),\n                      clamp( point(uv-edgePoint, 0.1), 0., 1.));\n                \n                vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n                vec2 edgeSideA = edgePoint - perp;\n                vec2 edgeSideB = edgePoint + perp;\n                \n                col = mix(col, vec3(1.), \n                          line(uv, edgeSideA, edgeSideB, 0.04));\n            }\n        }\n    }\n    \n    return vec4(pointA, d);\n}\n\n///////////////////////////////////////////\n\n//Another voronoi function just for the cell the mouse is in...\n\n//////////////////////////////////////////\n\nvec2 voronoiMouseID(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) ;\n        vec2 testB = coords + stFL;\n        \n        float c = length(coords.xy- st);\n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n            \n            }\n        }\n    }\n\n    return vec2(d);\n}\n\n\n///////////////////////////////////////////\n\n//voronoi edge function just for coloring\n\n//////////////////////////////////////////\nvec4 voronoi(vec2 uv, inout vec2 pos){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    pos = stFL;\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n            pos = stFL+id;\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);\n        \n        if(length(A-coords) > 0.00){\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,0.5+0.5*sin(pow(B*100.,vec2(1./2.))));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float globalScale = 4.;\n    uv*=globalScale ;\n    vec2 pos;\n    vec4 voronoXY = voronoi(uv,pos);\n    \n    \n    //====================START OF FANCY COLORING====================\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    col.zy *= rot(.1);\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n\n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.),pos).x-voronoi(uv+vec2(eps,0.),pos).x,\n                  voronoi(uv-vec2(eps,0.).yx,pos).x-voronoi(uv+vec2(eps,0.).yx,pos).x,\n                  voronoi(uv-vec2(eps,0.),pos).z\n                  -voronoi(uv+vec2(eps,0.).yy,pos).z\n \n                  );\n         n = normalize(n);\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.)/2., smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n    //====================END OF FANCY COLORING====================\n    \n  \n    \n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    if(iMouse.z < 0.5){ m = vec2(0.);}\n    \n    \n    //call voronoi to get the mouse id. This could be\n    //probably done in one of the other voronoi calls\n    vec2 vMouse = voronoiMouseID(m*globalScale );\n    //color the cell black that the mouse is currently in \n    //if the mouse is pressed, otherwise it will be the (0.,0.) point.\n    if(vMouse.y==voronoXY.y)col = \n                vec3(0.,0.0,0.)\n                    *smoothstep(0.9,0.99,voronoXY.z);\n   \n                    \n                    \n                    \n   vec3 lines = vec3(0.);\n   //calling voronoiLine to color \"lines\".\n   //super messy code here and the return isn't used\n   vec4 not_used = voronoiLine(uv,m*globalScale,lines);\n\n    col /= 1.88;\n    //col = mix(col, vec3(1.,0.,0.), lines);\n    col = mix(col, vec3(1.), lines);\n    col= pow(col, vec3(1.4));\n   // col = tx0;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}