{
    "Shader": {
        "info": {
            "date": "1583303384",
            "description": "Link to associated article: https://lucodivo.github.io/menger_sponge.html",
            "flags": 0,
            "hasliked": 0,
            "id": "3lKSWh",
            "likes": 4,
            "name": "Menger Sponge Breakdown",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Parcle",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2013 Connor Alexander Haskins\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A helpful breakdown for teaching a beginner how to create a Menger Sponge\n// This shader has an associated article which can be found here: http://connorahaskins.com/menger_sponge.html\n\n#define MAX_STEPS 60\n#define MISS_DIST 10.0\n#define HIT_DIST 0.01\n\n#define WIDTH 2.0\n#define HALF_WIDTH 1.0\n    \nvec2 distanceRayToScene(vec3 rayDir);\nfloat distPosToScene(vec3 rayPos);\nfloat sdYAlignedPlane(vec3 rayPos);\nmat2 rotate(float angle);\n\nfloat sdSphere(vec3 rayPos, vec3 sphereCenterPosition, float radius);\nfloat sdSphere(vec3 rayPos, float radius);\nfloat sdSphere(vec3 rayPos);\nfloat sdCube(vec3 rayPos);\nfloat sdCross(vec3 rayPos);\n\nfloat sdBoundedCross(vec3 rayPos);\nfloat sdBoundedCrossSlimmed(vec3 rayPos);\nfloat sdBoundedCrossWithBox(vec3 rayPos);\nfloat sdMengerSpongeIteration1(vec3 rayPos);\nfloat sdBoundedBoxFieldBroken(vec3 rayPos);\nfloat sdBoundedBoxField(vec3 rayPos);\nfloat sdTwentySevenBoxesKinda(vec3 rayPos);\nfloat sdTwentySevenBoxesCross(vec3 rayPos);\nfloat sdTwentySevenBoxes(vec3 rayPos);\nfloat sdTwentySevenCrossesBound(vec3 rayPos);\nfloat sdMengerSpongeIteration2(vec3 rayPos);\nfloat sdMengerSponge(vec3 rayPos, int numIterations);\n\nconst vec3 cameraPos = vec3(6.0, 6.0, -6.0);\nconst vec3 missColor = vec3(0.0, 0.0, 0.0);\n\nconst float floorHeight = -3.0;\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\nconst float sphereScale = 3.0;\nconst vec3 cubePos = vec3(0.0, 0.0, 0.0);\nconst float cubeScale = 2.0;\nconst vec3 crossPos = vec3(0.0, 0.0, 0.0);\nconst float crossScale = 1.1;\nconst vec3 infSpherePos = vec3(0.0, 0.0, 0.0);\nconst float infSphereScale = 0.5;\nconst vec3 mengerSpongePos = vec3(0.0, 0.5, 0.0);\nconst float mengerSpongeScale = 2.5;\nconst int mengerSpongeIterations = 3;\n\nfloat distPosToScene(vec3 rayPos) {\n    \n    float distFloor = sdYAlignedPlane(rayPos - vec3(0.0, floorHeight, 0.0));\n    float dist;\n    \n    // NOTE: Pairing the floors with some objects through a union helps \n\t// create a more understandable scene\n    \n    // Sphere Method #1\n\tdist = min(sdSphere(rayPos, spherePos, sphereScale), distFloor);\n    \n    // Sphere Method #2\n    //dist = min(sdSphere(rayPos - spherePos, sphereScale), distFloor);\n    \n    // Sphere Method #3\n    //dist = min(sdSphere((rayPos - spherePos) / sphereScale) * sphereScale, distFloor);\n    \n    // Cube\n    //dist = min(sdCube((rayPos - cubePos) / cubeScale) * cubeScale, distFloor);\n    \n    // Cross\n    //dist = sdCross((rayPos - crossPos) / crossScale) * crossScale;\n    \n    // Infinite Spheres\n    //vec3 infRayPos = mod(rayPos, WIDTH) - HALF_WIDTH;\n    //dist = sdSphere((infRayPos - infSpherePos) / infSphereScale) * infSphereScale;\n    \n    \n    \n    // === Menger Sponge ===\n    // MengerSponge Part 1: Bounded Cross\n    //dist = sdBoundedCross((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 2: Slimmed Bounded Cross\n    //dist = sdBoundedCrossSlimmed((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 3: Bounded Cross w/ Box\n    //dist = sdBoundedCrossWithBox((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 4: Iteration 1\n    //dist = sdMengerSpongeIteration1((rayPos - mengerSpongePos) / 1.5) * 1.5;\n    \n    // MengerSponge Part 5: Bounded Box Field (Broken)\n    //dist = sdBoundedBoxFieldBroken((rayPos - mengerSpongePos) / 0.5) * 0.5;\n    \n    // MengerSponge Part 6: Bounded Box Field (Fixed)\n    //dist = sdBoundedBoxField((rayPos - mengerSpongePos) / 0.5) * 0.5;\n    \n    // MengerSponge Part 7: Twenty Seven Boxes...Kinda\n    //dist = sdTwentySevenBoxesKinda((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 8: Twenty Seven Boxes Cross-Section\n    //dist = sdTwentySevenBoxesCross((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 9: 27 Cubes\n    //dist = sdTwentySevenBoxes((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 10: 27 Crosses Bound\n    //dist = sdTwentySevenCrossesBound((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // MengerSponge Part 11: Iteration 2\n    //dist = sdMengerSpongeIteration2((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale;\n    \n    // Menger Sponge\n    //dist = sdMengerSponge((rayPos - mengerSpongePos) / mengerSpongeScale, mengerSpongeIterations) * mengerSpongeScale;\n    \n    return dist;\n}\n\n// NOTE: Entry point of fragment shader\n// This function point is called per pixel\n// fragCoord is (x,y) location of pixel\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Subtract half the width/height resolution components to\n    // Move origin, (0,0), from bottom left corner to center of screen\n    vec2 pixelCoord = fragCoord.xy - (iResolution.xy * 0.5);\n\n    // Scale y value to [-1.0, 1.0], scale x by same factor (if screen is wider, x will have values >1 & <-1)\n    pixelCoord = pixelCoord / iResolution.y;\n\n    // Represents the fragment position on the plane where rays are shot through\n    // Can be thought of as the pixel coordinate on the screen\n    vec3 fragmentPos = vec3(pixelCoord.x, pixelCoord.y, 0.0);\n    \n    // The point in which our rays emit from\n    // Adjusting z value in the range of [-3.0, 0.0] gives a variety of viewing angles\n    const vec3 focalPoint = vec3(0.0, 0.0, -1.0);\n    \n    // get the direction of a ray emitting from the focal point through fragment position\n    vec3 rayDir = fragmentPos - focalPoint;\n\n    // rotate direction vectors to point towards the world origin (where our objects will be centered)\n    // these \"magic\" numbers were derived from the angle needed to point from cameraPos to the world origin\n    rayDir.yz *= rotate(radians(35.24)); \n    rayDir.xz *= rotate(radians(45.0));\n    rayDir = normalize(rayDir);\n\n    vec2 dist = distanceRayToScene(rayDir);\n\n    if(dist.x > 0.0) { // hit\n        // color surface by number of iterations (from white to black)\n        vec3 col = vec3(1.0 - (dist.y/float(MAX_STEPS)));\n        fragColor = vec4(col, 1.0);\n    } else { // miss\n        fragColor = vec4(missColor, 1.0);\n    }\n}\n\n\n// returns vec2(dist, iterations)\n// NOTE: ray dir arguments are assumed to be normalized\nvec2 distanceRayToScene(vec3 rayDir) {\n\n\tfloat dist = 0.0;\n\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = cameraPos + (dist * rayDir);\n        float posToScene = distPosToScene(pos);\n        dist += posToScene;\n        if(abs(posToScene) < HIT_DIST) return vec2(dist, i); // absolute value for posToScene incase the ray makes its way inside an object\n        if(posToScene > MISS_DIST) break;\n    }\n\n    return vec2(-1.0f, MAX_STEPS);\n}\n\nfloat sdSphere(vec3 rayPosition, vec3 sphereCenterPosition, float radius) {\n    vec3 centerToRay = rayPosition - sphereCenterPosition;\n\tfloat distToCenter = length(centerToRay);\n    return distToCenter - radius;\n}\n\nfloat sdSphere(vec3 rayPos, float radius) {\n    return length(rayPos) - radius;\n}\n\nfloat sdSphere(vec3 rayPos) {\n    return length(rayPos) - HALF_WIDTH;\n}\n\nfloat sdCube(vec3 rayPos) {\n\tconst vec3 corner = vec3(HALF_WIDTH);\n    vec3 ray = abs(rayPos); // fold ray into positive octant\n    vec3 cornerToRay = ray - corner;\n    float cornerToRayMaxComponent = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n    float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n    vec3 closestToOutsideRay = max(cornerToRay, 0.0);\n\treturn length(closestToOutsideRay) + distToInsideRay;\n} \n\nfloat sdCross(vec3 rayPos) {\n    const vec3 corner = vec3(HALF_WIDTH);\n\tvec3 ray = abs(rayPos); // fold ray into positive quadrant\n\tvec3 cornerToRay = ray - corner;\n\n    float smallestComp = min(min(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat largestComp = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat middleComp = cornerToRay.x + cornerToRay.y + cornerToRay.z\n\t\t\t\t\t\t\t- smallestComp - largestComp;\n            \n\tvec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n\tvec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n\treturn (middleComp > 0.0) ? length(closestOutsidePoint) : -length(closestInsidePoint);\n}\n\nfloat sdBoundedCross(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos);\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\treturn intersection;\n}\n\n\nfloat sdBoundedCrossSlimmed(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos / 0.33) * 0.33;\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\treturn intersection;\n}\n\n\nfloat sdBoundedCrossWithBox(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos * 3.0) / 3.0;\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\tfloat spongeBox = sdCube(rayPos);\n\tfloat boxCrossUnion = min(intersection, spongeBox);\n\treturn boxCrossUnion;\n}\n\n\nfloat sdMengerSpongeIteration1(vec3 rayPos) {\n\tfloat crossDist = sdCross(rayPos * 3.0) / 3.0;\n\tfloat spongeBox = sdCube(rayPos);\n\treturn max(spongeBox, -crossDist);\n}\n\n\nfloat sdBoundedBoxFieldBroken(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos / 3.9) * 3.9;\n\tvec3 ray = mod(rayPos, 2.0);\n\tfloat dist = sdCube(ray / 1.5) * 1.5;\n\treturn max(dist, boundingBox);\n}\n\n\nfloat sdBoundedBoxField(vec3 rayPos) { \n\tfloat boundingBox = sdCube(rayPos / 4.0) * 4.0;\n\tvec3 ray = mod(rayPos, 2.0);\n\tray -= 1.0;\n\tfloat dist = sdCube(ray / 0.8) * 0.8;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenBoxesKinda(vec3 rayPos) {\n\t// bounding box spans all axes between [-halfBoxDimen, halfBoxDimen]\n\tfloat boundingBox = sdCube(rayPos);\n\t// The rays are transformed into boxed spaces with all axes between [0, boxDimen / 3.0)\n\t// this is because each cube should have a third the dimension of the entire cube\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tvec3 ray = mod(rayPos, boxedWorldDimen);\n\t// The origin within the boxes is moved from the corner to the center of the cube,\n\t// with the rays now having a range between [-boxDimen / 6.0, boxDimen / 6.0)\n\tray -= (boxedWorldDimen) / 2.0;\n\t// Transform coordinates of each boxed space to range [-halfBoxDimen, halfBoxDimen)\n\tray *= 3.0;\n\t// Shrink the cubes slightly to reveal gaps between them\n\tfloat dist = sdCube(ray / 0.9) / 0.9;\n\t// Correct warping of space caused by previously stretching the ray\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenBoxesCross(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tvec3 ray = mod(rayPos, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCube(ray / 0.9) * 0.9;\n\tdist /= 3.0;\n\tdist = max(dist, boundingBox);\n\t// Cross that runs along the axes of our world\n\tfloat axesCross = sdCross(rayPos / 0.25) * 0.25;\n\treturn max(dist, axesCross);\n}\n\nfloat sdTwentySevenBoxes(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\t// We want to translate the first box in the positive octant to change itâs world coordinates\n\t// from [0, boxedWorldDimen) to [-boxedWorldDimen / 2.0, boxedWorldDimen / 2.0) \n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCube(ray / 0.9) * 0.9;\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenCrossesBound(vec3 rayPos) {\n    const float oneThird = 1.0 / 3.0;\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCross(ray / oneThird) * oneThird;\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdMengerSpongeIteration2(vec3 rayPos) {\n    const float oneThird = 1.0 / 3.0;\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat crossesUnboundDist = sdCross(ray / oneThird) * oneThird;\n\tcrossesUnboundDist /= 3.0;\n    \n\tfloat distFirstIter = sdMengerSpongeIteration1(rayPos);\n\treturn max(distFirstIter, -crossesUnboundDist);\n}\n\nfloat sdMengerSponge(vec3 rayPos, int numIterations) {\n\tfloat spongeCube = sdCube(rayPos);\n    if(spongeCube > HIT_DIST) return spongeCube; // use dist of sponge box as bounding box\n\tfloat mengerSpongeDist = spongeCube;\n\n\tfloat scale = 1.0;\n\tfor(int i = 0; i < numIterations; ++i) {\n    \tfloat boxedWidth = WIDTH / scale;\n    \tvec3 ray = mod(rayPos + boxedWidth / 2.0, boxedWidth);\n    \tray -= boxedWidth / 2.0;\n    \tray *= scale;\n    \tfloat crossesDist = sdCross(ray * 3.0);\n    \tscale *= 3.0;\n    \tcrossesDist /= scale;\n    \tmengerSpongeDist = max(mengerSpongeDist, -crossesDist);\n\t}\n    \n\treturn mengerSpongeDist;\n}\n\nfloat sdYAlignedPlane(vec3 rayPos) {\n    return abs(rayPos.y);\n}\n\nmat2 rotate(float angle) {\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}