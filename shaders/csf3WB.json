{
    "Shader": {
        "info": {
            "date": "1666733654",
            "description": "using curvature detection to create a bit realistic old metalic effect.\nStarts this shader using edge detecton but curvature do it best and we can easily avoid negative ones.  ",
            "flags": 32,
            "hasliked": 0,
            "id": "csf3WB",
            "likes": 36,
            "name": "Metal'occ",
            "published": 3,
            "tags": [
                "edge",
                "metal",
                "cross",
                "curvature",
                "metalic",
                "occitan"
            ],
            "usePreview": 0,
            "username": "iapafoto",
            "viewed": 386
        },
        "renderpass": [
            {
                "code": "\n// Created by sebastien durand - 10/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n\n\n#define WITH_DOF\n\n#ifdef WITH_DOF\n\n//const float fov = 2.5;\nconst float aperture = 2.;\nconst float cosAngle = cos(radians(aperture/2.));\n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn step(cosAngle,side*dot(normalize(o-p), n)) > 0.5;\n}\n\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2./iResolution.y) * (1.+t));\n}\n\nvec4 bokeh(sampler2D tex, vec2 uv, float fdist) {\n // based on dof by Jochen \"Virgill\" Feldk√∂tter, Alcatraz / Rhodium 4k Intro liquid carbon\n  // simplyfied version of Dave Hoskins blur\n  // now bokeh is not cut within dof mask, added alpha blending based on difference of dof mask samples\n    const float GA =2.399; \n\tconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n    vec4 acc = texture(tex,uv);\n    float rad = min(.3, 2.*coc(abs(acc.w-fdist)));//.3; // TODO calculate this for Max distance on picture\n\t acc = vec4(texture(tex,uv).rgb, rad);\n    float d = rad;\n    vec2 pixel=0.0001*vec2(iResolution.y/iResolution.x,7.);\n\tvec2 angle=vec2(0,rad);\n\tfor (int j=0;j<64;j++) {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec2 tap_uv = uv+pixel*(rad-1.)*angle;\n        vec4 col = texture(iChannel0, tap_uv);\n      \tacc.rgb = max(acc.rgb,col.rgb);\n\t}\n\treturn acc;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float fdist = texture(iChannel0,vec2(.5)).w;\n\tfragColor = bokeh(iChannel0,uv,fdist);\n    \n#else   \n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n#endif\n\n  //  vec2 grainuv = fragCoord.xy + floor(iTime*60.)*vec2(37,41);\n//\tvec2 filmNoise = 1.5*textureLod( iChannel1, .5*grainuv/iChannelResolution[0].xy, 0. ).rb;\n//\tfragColor.rgb *= 1.1*mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define COLOR_BACK  vec3(.6, .7, 1)*.045\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    float n = mix(h.x, h.y, p.z);\n    return n;\n}\n\nfloat fbm(in vec3 p){\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n}\n\n// 2D rotation formula.\nmat2 rot2(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\nvec2 hash2(vec2 p) {\n   // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n// [iq] https://www.shadertoy.com/view/4lyfzw\nfloat opExtrussion(vec3 p, float sdf, float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\nfloat smin(float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// --------------------------------------\n// Distance Functions\n// --------------------------------------\n\nfloat sdOcc1( in vec2 p) {\n    return min(max(length(p)-2.8, 3.-\n        min(length(p-vec2(0,3.4)), length(p-vec2(5.4,1.75)))), \n        min(length(p-vec2(2.352,1.404)), length(p-vec2(3,0))) - .33);\n}\nfloat sdOcc0( in vec2 p) {\n    return max(length(p)-2.8, 3.-\n        min(length(p-vec2(0,3.4)), length(p-vec2(5.4,1.75))) \n         );\n}\nfloat sdOcc( in vec2 p) {\n    p = abs(p);\n    return min(sdOcc1(p),sdOcc1(p.yx));\n}\nfloat sdOcc00( in vec2 p) {\n    p = abs(p);\n    return min(sdOcc0(p),sdOcc0(p.yx));\n}\n\nfloat sdOcc3D(in vec3 p, float h) {\n    p.z = -abs(p.z);\n    float d1 = opExtrussion(p, sdOcc(p.xy), h);   \n    float d2 = opExtrussion(p+vec3(0,0,h), sdOcc00(p.xy)+.25, h*.15);    \n    return /*max(d1,-d2); //*/smin(d1-.025,-d2,-.05);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Background\n\n#define sharp 35. \n#define thick 0.2\n\nfloat draw_tiles(vec2 uv,float seed) {\n    float k = floor(rand(floor(uv)+(seed/0.12))+0.5);\n    uv = fract(uv);\n    float x = clamp((1.-length(uv-vec2(1.,k))-(0.5-thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,1.-k))-(0.5-thick))*sharp,0.,1.);\n    x -= clamp((1.-length(uv-vec2(1.,k))-(0.5+thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,1.-k))-(0.5+thick))*sharp,0.,1.);\n    return x;   \n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Background\n    vec2 p = fragCoord/iResolution.y;\n    p=p*(7.+.4*cos(.1*iTime))+vec2(5)*rot2(.04*iTime);\n    p *= rot2(.01*iTime);\n    vec2 q = fragCoord/iResolution.xy;\n    vec3 sceneCol = COLOR_BACK + .05*hash(vec3(q,1.));\n    float k = draw_tiles(p*.5,2.);\n    sceneCol *= .8 + .2*smoothstep(.06,.08,k);\n    fragColor = vec4(sceneCol* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f), 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Created by sebastien durand - 10/2022\n//-------------------------------------------------------------------------------------\n\n#define FAR 10.\n\nfloat gDist;\nvec3 closest;\n\n#define PI 3.141592\n\nfloat map0(vec3 p) {\n    return .5*sdOcc3D(p.zxy*2., 1.);\n}\n\nfloat map(vec3 p) {\n//return map0(p);\n    // Avarage arround to get a more interesting shape \n    float d = 0.;\n      for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        d += map0(p + .045*e);\n    }\n    d /= 4.;\n    return d;\n}\n\n\n//------------------------------------------------------------------------\n// Normal and Curvature (adapted from Shane shader)\n//------------------------------------------------------------------------\nvec3 calcNormal(vec3 p, inout vec3 edge, inout float crv, float t) { \n    float d = map(p);\n    vec2 ec = 7.*vec2(12./450., 0);\n\tfloat d1 = map(p + ec.xyy), d2 = map(p - ec.xyy),\n          d3 = map(p + ec.yxy), d4 = map(p - ec.yxy),\n          d5 = map(p + ec.yyx), d6 = map(p - ec.yyx);\n    crv = (d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5;\n  \n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\nfloat trace(in vec3 ro, in vec3 rd){\n    float t = 0., tmax=FAR, d;\n    for(int i = 0; i<200; i++){\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(1. + t*.05) || t > tmax) break;\n        t += d; // the distance field is over estimated\n    }\n    if(t>tmax) t = FAR;\n    return min(t, FAR);\n}\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n) {\n\tfloat sca = 4., occ = 0.;\n    for( int i=1; i<6; i++ ) {\n        float hr = float(i)*.3/5.,       \n              dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n}\n\n// The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n    float shade = 1.;\n    float dist = .001*(1. + t*.05) + .001*abs(hash2(ro.xz).x);\n    for (int i = 0; i<32; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);    \n        dist += clamp(h, .001, .025);        \n        if (h<.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n// Shane magie\nvec3 envMap(vec3 p){\n    p *= 3.;\n    float n3D2 = noise3D(p*3.);\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); \n    p = vec3(c, c*c, c*c*c);\n    return mix(p, p.zyx, n3D2*.5 + .5);\n}\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nfloat tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).x;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( tex3D(tex, vec3(p.x-ep, p.y, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y-ep, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y, p.z-ep), n));\n    grad = (grad - tex3D(tex, p, n))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n//------------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro),\n         cp = vec3(sin(cr), cos(cr),.0),\n         cu = normalize( cross(cw,cp) ),\n         cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = .1*iTime;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float a = mix(.3,3.*cos(.4*time),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    // camera\t\n    vec3 ta = vec3(0),\n         ro = vec3(2.5*cos(a), 3.*cos(.4*iTime+15.) + 3., 3.5*sin(a)+3.*sin(.4*iTime+15.));\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n        \n    // ray direction\n    vec3 rd = ca * normalize(vec3(p,2.5)),\n         lp = ro + 3.*vec3(.25, 2, -.1);\n        \n    // Ray march.\n    float t = trace(ro, rd);\n\n    // Background\n    vec2 q = fragCoord/iResolution.xy;\n    vec3 sceneCol = texture(iChannel0, q).xyz; \n\n    if (t < FAR){\n        vec3 col = vec3(.9, .2, .4); // Pink\n        // Position.\n        vec3 pos = ro + rd*t;\n        vec3 edge = vec3(0);\n        float crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        float border = .015*crv; //length(edge);\n        // Scratchs   \n        nor = doBumpMap(iChannel2, pos, nor, .04*border*fbm(pos*10.)); \n        \n        // Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li /= lDist;\n       \n        // Light falloff - attenuation.\n        float atten = 1./(1. + lDist*.05 + lDist*lDist*0.025);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); // Shadows.\n        float ao = .3+.7*calcAO(pos, nor);\n        float diff = max(dot(li, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 99.); // Specular.\n        \n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        float od = diff;\n        diff += mix(.1,3.5,smoothstep(0.,.7,border))*spec;\n        diff = pow(diff, 4.)*2.; \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.),\n\t\t      fre2 = mix(.5, 1., Schlick);\n        // Metalic effect\n        col *= fbm(pos*64.)*.75 + .5;\n        // Wear effect\n        col = mix(col, vec3(1)*fbm(pos*128.), 3.*border);\n        sceneCol = col*(diff + .25); \n           \n        // Fake environment mapping (Metalic effect)\n        sceneCol += sceneCol*envMap(reflect(rd, nor))*8.;\n        sceneCol *= atten*shd*ao; // Applying the light falloff, shadows and AO.\n    } \n    \n    fragColor = vec4(pow(clamp(sceneCol, 0., 1.),vec3(.47)), t);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}