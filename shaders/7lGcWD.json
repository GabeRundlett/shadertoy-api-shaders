{
    "Shader": {
        "info": {
            "date": "1661515701",
            "description": "Sugar rush",
            "flags": 0,
            "hasliked": 0,
            "id": "7lGcWD",
            "likes": 10,
            "name": "Candy cage",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "abstract",
                "halftone",
                "truchet",
                "weave"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "// Candy cage by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash12(vec2 p)\n{\n    p = fract(p * 3.213 + .679) * 31.9;\n    p.x *= fract(p.y * 12.321) * 2047.6;\n    return fract(p.x + p.y);\n}\n\nfloat cheb(vec2 p, float k)\n{\n    return pow(pow(abs(p.x), k) + pow(abs(p.y), k), 1./k);\n}\n\nfloat cheb(vec3 p, float k)\n{\n    return pow(pow(abs(p.x), k) + pow(abs(p.y), k) + pow(abs(p.z), k), 1./k);\n}\n\nvec2 cubeCoord(vec3 n)\n{\n    vec2 res;\n    if (abs(n.x) > abs(n.y) && abs(n.x) > abs(n.z))\n        res = n.yz / abs(n.x);\n    else if (abs(n.y) > abs(n.x) && abs(n.y) > abs(n.z))\n        res = n.xz / abs(n.y);\n    else\n        res = n.xy / abs(n.z);\n    \n    return res + 1.5;\n}\n\nvec2 truch(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = p - i;\n    \n    float h = hash12(i*17.);\n    if (h < .5) f.y = 1. - f.y;\n    \n    if (f.x + f.y > 1.) f = 1. - f;\n    \n    float y = sin(atan(f.y, f.x));\n    y = smoothstep(.4, -.4, y);\n    \n    return vec2(cheb(f, 1.5 + h * 5.) - .5, y);\n}\n\nfloat cage(vec3 p, float rad, float t)\n{\n    mat2 r = rot(t);\n    p.xz *= r;\n    p.yx *= r;\n    vec2 uv = cubeCoord(normalize(p));\n    uv *= floor(rad);\n    vec2 t0 = truch(uv);\n    vec2 t1 = truch(uv + 3.5);\n    t0.y = t0.y * .2 + length(p) - rad;\n    t1.y = t1.y * .2 + length(p) - rad;\n    return (min(length(t0), length(t1)) - .05)\n         * max(1. - max(abs(p.y)-rad*.5, 0.) * .4, .1);\n}\n\nfloat scene(vec3 p)\n{\n    float pt = iTime * 3.141593 * .125;\n    return min(min(cage(p, 1., pt * -.75), cage(p, 1.5, pt)), cage(p, 2., pt * -1.5)) * .5;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    const vec2 e = vec2(.001, 0);\n    return normalize(\n        d - vec3(\n            scene(p - e.xyy),\n            scene(p - e.yxy),\n            scene(p - e.yyx)\n        )\n    );\n}\n\n// sphere intersection to accelerate raymarch\nfloat acc(vec3 ro, vec3 rd)\n{\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - 2.1*2.2;\n    float h = b*b-c;\n    if (h<0.) return 11.;\n    return -b-sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0,0,-3.),\n         rd = normalize(vec3(uv, .8)),\n          p = vec3(0),\n        col = vec3(0);\n    float i = 0., t = acc(ro, rd), d = 0.;\n\n    for(;i<1. && t < 10.;i += 1./256.)\n    {\n        p = ro + rd * t;\n        d = scene(p) - .02;\n        if (abs(d) < .001) break;\n        t += d;\n    }\n    \n    float olT = t;\n    t += d;\n    \n    for(;i<1. && t < 10.;i += 1./256.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        if (abs(d) < .001 + max(t * .001 - .001, 0.)) break;\n        t += d;\n    }\n    \n    if (t < 10.)\n    {\n        vec3 n = normal(p, d);\n        float frn = pow(1.-dot(rd,-n), 2.);\n        vec3 refd = reflect(rd,n);\n        mat2 r = rot(1.);\n        n.xz *= r;\n        n.yz *= r;\n        float l = dot(max(n, 0.), vec3(.5));\n        l *= l;\n        col = mix(vec3(1.,.2,0), vec3(.85,1.,0), smoothstep(.5 - fwidth(l), .5 + fwidth(l), l));\n        float e = exp(-t + 1.2);\n        col = mix(col, vec3(0,.95,1), 1.-e);\n        l = max(l, pow(dot(vec3(1), cos(refd * 8.)), 4.) * frn);       \n        col = mix(col,vec3(l),l*l);\n    }\n    else if (olT < 10.)\n        col = vec3(1);\n    else\n    {\n       float grad = clamp(uv.y - uv.x * .25 + .5, 0.,1.) * 2. -1.;\n       uv *= rot(.6);\n       uv.y += iTime * .2;\n       \n       float hft = cheb(fract(uv * 20.) * 2. - 1., 2. + 2. * smoothstep(-.8,.8,sin(uv.x * 3. + iTime)));\n       col = mix(vec3(.9,0,1), vec3(1), step(.5, hft+grad));\n    }\n\n    col *= 1.-pow(length(fragCoord / iResolution.xy - .5), 4.);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}