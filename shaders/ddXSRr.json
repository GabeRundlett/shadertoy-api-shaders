{
    "Shader": {
        "info": {
            "date": "1668429075",
            "description": "Using a long-range Texture SDF algorithm, you have much more control over the result (such as neighbor search distance) without impacting performance.",
            "flags": 32,
            "hasliked": 0,
            "id": "ddXSRr",
            "likes": 35,
            "name": "Procedural Erosion 2.0",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field",
                "signed"
            ],
            "usePreview": 1,
            "username": "Hatchling",
            "viewed": 906
        },
        "renderpass": [
            {
                "code": "// Controls:\n// Mouse click - Clear and restart. (Useful for when you go fullscreen.)\n\n\nvec2 compress(vec2 vec)\n{\n    float mag = sqrt(dot(vec, vec));\n\n    float newMag = mag;\n\n    // Softly compress the range \n    // from 0 to +Inf\n    // to 0 to +1 \n    // instead of clipping values\n    // when contrast is used for visualization.\n    newMag = newMag / (0.5 + newMag);\n\n    vec *= newMag / (mag + 0.00001);\n    return vec;\n}\nfloat compress(float vec)\n{\n    float mag = abs(vec);\n\n    float newMag = mag;\n\n    // Softly compress the range \n    // from 0 to +Inf\n    // to 0 to +1 \n    // instead of clipping values\n    // when contrast is used for visualization.\n    newMag = newMag / (0.5 + newMag);\n\n    vec *= newMag / (mag + 0.00001);\n    return vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvC = fragCoord.xy / iChannelResolution[0].xy;\n\tvec2 uvR = (fragCoord.xy + vec2(1,0)) / iChannelResolution[0].xy;\n\tvec2 uvT = (fragCoord.xy + vec2(0,1)) / iChannelResolution[0].xy;\n\tvec2 uvL = (fragCoord.xy - vec2(1,0)) / iChannelResolution[0].xy;\n\tvec2 uvB = (fragCoord.xy - vec2(0,1)) / iChannelResolution[0].xy;\n    vec2 colC = texture(iChannel0, uvC).zw;\n    vec2 colR = texture(iChannel0, uvR).zw;\n    vec2 colT = texture(iChannel0, uvT).zw;\n    vec2 colL = texture(iChannel0, uvL).zw;\n    vec2 colB = texture(iChannel0, uvB).zw;\n    \n    colC.r /= colC.g;\n    colR.r /= colR.g;\n    colT.r /= colT.g;\n    colL.r /= colR.g;\n    colB.r /= colT.g;\n    \n    \n    vec2 gradient = vec2(colL.r - colR.r, colB.r - colT.r);\n    vec2 curvature = vec2\n    (\n        colL.r + colR.r - 2.0 * colC.r, \n        colB.r + colT.r - 2.0 * colC.r \n    ) * 0.5;\n    \n    \n    // Enhance gradient+curvature contrast.\n    vec2 both = compress(gradient * 100.0 - curvature * 8000.0);\n    \n    \n    // Unmodified gradients:\n    // vec2 gradient = vec2(colC.r - colR.r, colC.r - colT.r);\n    \n    fragColor = vec4(both * 0.5 + 0.5, compress(colC.r), 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n   \n   // RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nfloat perlin(vec2 uv, inout uint rngState)\n{\n    uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    uv /= 1.0;\n    vec2 occ = vec2(0);\n    float a = 1.0;\n    for(int i = 0; i <8; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= 0.5;\n        a *= 1.7;\n        uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    }\n    float v = occ.x / occ.y;\n    \n    return v;\n       \n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    vec2 uvTile = uv * 2.0;\n    \n    if(uvTile.x > 1.0)\n        uvTile.x = 2.0-uvTile.x;\n    if(uvTile.y > 1.0)\n        uvTile.y = 2.0-uvTile.y;\n        \n    \n    uvTile = smoothstep(0., 1., uvTile);\n        \n    uint rngState = 14114u;\n    \n    vec2 uv00 = uv + vec2(0.5, 0.5);\n    uv00 -= floor(uv00);\n    vec2 uv01 = uv + vec2(0.0, 0.5);\n    uv01 -= floor(uv01);\n    vec2 uv10 = uv + vec2(0.5, 0.0);\n    uv10 -= floor(uv10);\n    vec2 uv11 = uv + vec2(0.0, 0.0);\n    uv11 -= floor(uv11);\n    \n    float height00 = perlin(uv00, rngState);\n    float height01 = perlin(uv01, rngState);\n    float height10 = perlin(uv10, rngState);\n    float height11 = perlin(uv11, rngState);\n    \n     //height00 = 0.;\n     //height01 = 0.;\n     //height10 = 0.;\n     //height11 = 0.;\n    \n    float height0X = mix(height00, height01, uvTile.x);\n    float height1X = mix(height10, height11, uvTile.x);\n    float v = mix(height0X, height1X, uvTile.y);\n    \n    //v = height01;\n    /*float height1 = perlin(uv, rngState);\n    \n    vec2 offsetUv = uv;\n    offsetUv += vec2(0.5, 0.5);\n    offsetUv -= floor(offsetUv);\n    \n    float height2 = perlin(offsetUv, rngState);\n    \n    vec2 weightXY = abs(uv - vec2(0.5)) * 2.0;\n    float weight2 = weightXY.x * weightXY.y  + 0.001;\n    float weight1 = (1.0-weightXY.x) * (1.0-weightXY.y) + 0.001;\n    \n    float weight = weight2 / (weight1 + weight2);\n    weight = smoothstep(0., 1., weight);\n    \n    float v = mix(height1, height2, weight);*/\n        \n\n    \n    // Increase contrast\n    // (though this will flatten the tops and bottoms).\n    v = v * 2.0 - 1.0;\n    v = min(1.0, max(-1.0, v * 2.25));\n    v = v * 0.5 + 0.5;\n    \n    // Make peaks pointer and valleys flatter.\n    v *= v * v * v;\n    \n    v = 1. - v;\n    \n    \n    fragColor = vec4(v, v, v, 1.0); \n    \n    vec3 noise = getNoise(iFrame);\n    fragColor = v > noise.z ? vec4(1) : vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about 7.2 seconds, 144+ FPS @ 900x506\n\n// Controls =================================\n// Frag + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Circle:           (Color) Gradient (Radius) Final distance.\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    vec2 pointToMin = pointToCenter - minOffset;\n    return vec3(pointToMin, lengthSqr(pointToMin));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 noise = getNoise(iFrame);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iChannelResolution[0].xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize) \n                       + noise.xy * (1.0 / float(1 << RECURSION_DEPTH));\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    bool fragIsOccupied = isOccupied(fragUV); \n    \n    const float maxDist = 2.0;\n    vec3 diff_distSqr = vec3(maxDist, 0.0, maxDist*maxDist);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(fragTestIntCoord) + vec2(0.5) - fragTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = fragTestIntCoord;\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(fragTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(!containsEdge(fragIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = fragTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            fragIsOccupied\n        ); \n    }\n         \n    vec3 diff_dist = vec3(diff_distSqr.xy, sqrt(diff_distSqr.z)) / (fragIsOccupied ? -maxDist : maxDist);     \n         \n    diff_dist.xy = normalize(diff_dist.xy);\n    \n    diff_dist.z = diff_dist.z * 0.5 + 0.5;\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    //diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    \n         \n    fragColor = vec4(diff_dist, 1.0);\n    if(isnan(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    if(isinf(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    \n    // Accumulate samples over time.\n    if(iFrame > 1 && iMouse.z <= 0.)\n    {\n        vec2 uv = (fragCoord.xy) / iChannelResolution[1].xy;\n        vec4 oldColor = texture(iChannel1, uv);\n        fragColor += oldColor;\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}