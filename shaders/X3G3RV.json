{
    "Shader": {
        "info": {
            "date": "1718062984",
            "description": "Using differential geometry concepts towards SMS/MNEE of arbitrary parametric manifolds. Click on the screen to change the incident point (blue)",
            "flags": 0,
            "hasliked": 0,
            "id": "X3G3RV",
            "likes": 6,
            "name": "Differential Geometry 1",
            "published": 3,
            "tags": [
                "parametric",
                "catacaustic",
                "evolute",
                "orthotomic"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 88
        },
        "renderpass": [
            {
                "code": "/*\n\nThe idea is that you can express a tangent bundle of rays as an envelope and operate on that.\nThis example uses mostly analytical methods but numerical for catacaustic.\n\nThe green shape is the input ellipse.\nThe red shape is the evolute of the ellipse, the envelope of all normals.\nThe blue shape is the orthotomic of the ellipse and incident point.\nThe orange shape is the catacaustic, the envelope of all reflections\n    Solving for when the catacaustic first derivative equals the incident first derivative yields all specular paths.\n\nThis whole thing started by stumbling on this one sentence:\n\"The catacaustic is an evolute of the orthotomic (Lawrence 1972, p. 60)\"\nhttps://mathworld.wolfram.com/Catacaustic.html\n\n*/\n\n\n\n// this example is an ellipse and uses analytical derivatives\nfloat alpha = 1.0, beta = 1.41421;\n\n// parametric ellipse\nvec2 ellipse_0(in float t) {\n    return vec2(alpha * cos(t), beta * sin(t));\n}\n\n// first derivative\nvec2 ellipse_1(in float t) {\n    return vec2(alpha * -sin(t), beta * cos(t));\n}\n\n// second derivative\nvec2 ellipse_2(in float t) {\n    return vec2(alpha * -cos(t), beta * -sin(t));\n}\n\n\n\n// finite difference degree 1, fn_i should be fn(t - EPS), fn_f should be fn(t + EPS)\nvec2 fn_d1(in vec2 fn_i, in vec2 fn_f) {\n    return 0.5 * (fn_i - fn_f) / EPS;\n}\n\n// finite difference degree 2, fn_i should be fn(t - EPS), fn should be fn(t), fn_f should be fn(t + EPS)\nvec2 fn_d2(in vec2 fn_i, in vec2 fn, in vec2 fn_f) {\n    return (((fn_i - fn) / EPS) - ((fn - fn_f) / EPS)) / EPS;\n}\n\n// evolute: locus of centers of curvature (sitches between envelopes of tangents and normals), is its own inverse.\n// https://mathworld.wolfram.com/Evolute.html\n\n// this version takes derivatives explicitly\nvec2 _evolute(in vec2 d0, in vec2 d1, in vec2 d2) {\n    float d1s = dot(d1, d1);\n    float norm = 1.0 / wedge(d1, d2);\n    return d0 + vec2(-d1s, d1s) * d1.yx * norm;\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 evolute(in vec2 fn_i, in vec2 fn, in vec2 fn_f) {\n    return _evolute(fn, fn_d1(fn_i, fn_f), fn_d2(fn_i, fn, fn_f));\n}\n\n// orthotomic curve: locus of reflections from point source illuminating parametric curve.\n// https://resources.wolframcloud.com/FunctionRepository/resources/Orthotomic\n// https://mathworld.wolfram.com/PedalCurve.html\n// WARNING, INCORRECT SOURCE: https://mathworld.wolfram.com/Orthotomic.html\n\n// this version takes derivatives and incident point P\nvec2 _orthotomic(in vec2 d0, in vec2 d1, in vec2 p) {\n    vec2 d1s = d1 * d1;\n    vec2 d1yx = d1.yx * d1;\n    float norm = 1.0 / (d1s.x + d1s.y);\n    return 2.0 * (p * d1s + d0 * d1s.yx + (p.yx - d0.yx) * d1yx) * norm - p;\n}\n\n// this version numerically differentiates given 3 taps of the function.\nvec2 orthotomic(in vec2 fn_i, in vec2 fn, in vec2 fn_f, in vec2 p) {\n    return _orthotomic(fn, fn_d1(fn_i, fn_f), p);\n}\n\n\n\n// evolute using analytical derivatives\nvec2 ellipse_evolute(in float t) {\n    return _evolute(ellipse_0(t), ellipse_1(t), ellipse_2(t));\n}\n\n// orthotomic using analytical derivatives\nvec2 ellipse_orthotomic(in float t, in vec2 p) {\n    return _orthotomic(ellipse_0(t), ellipse_1(t), p);\n}\n\n// catacaustic using numerical derivatives\nvec2 ellipse_catacaustic(in float t, in vec2 p) {\n    return evolute(\n        ellipse_orthotomic(t - EPS, p),\n        ellipse_orthotomic(t, p),\n        ellipse_orthotomic(t + EPS, p)\n    );\n}\n\n\n\n// draw the analytical equation\nvec3 graphEllipse(in vec3 col, in vec2 ndc, in float lm, in float lw, in vec2 p) {\n\n    float tStep = 0.1;\n    float tMin = 0.0;\n    float tMax = min(iTime, TAU);\n\n    //*/ draw tangent bundles\n    for (float t = tMin; t < tMax; t += tStep) {\n        \n        vec2 ellipse_0t = ellipse_0(t);\n        vec2 ellipse_1t = ellipse_1(t);\n        // analytically compute the evolute\n        vec2 ellipse_evolute_0t = ellipse_evolute(t);\n        // numerically calculate the evolute first derivative\n        vec2 ellipse_evolute_1t = fn_d1(\n            ellipse_evolute(t - EPS),\n            ellipse_evolute(t + EPS)\n        );\n        // analytically compute the orthotomic\n        vec2 ellipse_orthotomic_0t = ellipse_orthotomic(t, p);\n        // numerically calculate the catacaustic\n        vec2 catacaustic_0t = ellipse_catacaustic(t, p);\n        // numerically calculate the catacaustic first derivative\n        vec2 catacaustic_1t = fn_d1(\n            ellipse_catacaustic(t - EPS, p),\n            ellipse_catacaustic(t + EPS, p)\n        );\n\n        // graph ellipse tangent bundle\n        col = mix(vec3(0.0, 0.6, 0.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_line( ndc, ellipse_1t, ellipse_0t )));\n        // graph evolute tangent bundle\n        col = mix(vec3(1.0, 0.0, 0.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_line( ndc, ellipse_evolute_1t, ellipse_evolute_0t )));\n        // graph orthotomic envelope of curvatures\n        col = mix(vec3(0.0, 0.0, 1.0), col, 0.8 + 0.2 * smoothstep(lm, lw, sd_circle( ndc, ellipse_0t, distance(ellipse_0t, p) )));\n        // graph catacaustic tangent bundle\n        col = mix(vec3(1.0, 0.7, 0.5), col, 0.6 + 0.4 * smoothstep(lm, lw, sd_line( ndc, catacaustic_1t, catacaustic_0t )));\n        \n    }//*/\n\n    float lastT = tMin - tStep;\n    vec2 last_ellipse = ellipse_0(lastT);\n    vec2 last_ellipse_evolute = ellipse_evolute(lastT);\n    vec2 last_ellipse_orthotomic = ellipse_orthotomic(lastT, p);\n    vec2 last_ellipse_catacaustic = ellipse_catacaustic(lastT, p);\n\n    //*/ draw envelopes\n    for (float t = tMin; t < tMax; t += tStep) {\n    \n        vec2 ellipse_0t = ellipse_0(t);\n        vec2 ellipse_evolute_0t = ellipse_evolute(t);\n        vec2 ellipse_orthotomic_0t = ellipse_orthotomic(t, p);\n        vec2 ellipse_catacaustic_0t = ellipse_catacaustic(t, p);\n\n        // graph ellipse envelope a little bolder\n        col = mix(vec3(0.0, 0.6, 0.0), col, smoothstep(lm * 2.0, lw * 2.0, sd_segment( ndc, last_ellipse, ellipse_0t )));\n        // graph evolute envelope\n        col = mix(vec3(1.0, 0.0, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_ellipse_evolute, ellipse_evolute_0t )));\n        // graph orthotomic envelope\n        col = mix(vec3(0.0, 0.0, 1.0), col, smoothstep(lm, lw, sd_segment( ndc, last_ellipse_orthotomic, ellipse_orthotomic_0t )));\n        // graph catacaustic envelope, lazily filter out the discontinuity (it's supposed to be there)\n        if (distance(last_ellipse_catacaustic, ellipse_catacaustic_0t) < 1.0)\n            col = mix(vec3(1.0, 0.6, 0.0), col, smoothstep(lm, lw, sd_segment( ndc, last_ellipse_catacaustic, ellipse_catacaustic_0t )));\n        \n        last_ellipse = ellipse_0t;\n        last_ellipse_evolute = ellipse_evolute_0t;\n        last_ellipse_orthotomic = ellipse_orthotomic_0t;\n        last_ellipse_catacaustic = ellipse_catacaustic_0t;\n        \n    }//*/\n    \n    return col;\n}\n\n\n\n// aspect, zoom, etc\nvec2 setupViewport(in vec2 fragCoord, in float zoom) {\n    // ndc with aspect\n    vec2 ndc = fragCoord/iResolution.xy * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    // graph zoom\n    return ndc * zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set up viewport\n    float zoom = PI;\n    vec2 ndc = setupViewport(fragCoord, zoom);\n\n    // AA line width\n    float px = zoom / iResolution.x;\n    float lw = 5.0 * px;\n    float lm = max(lw - px * 5.0, 0.0);\n    \n    // blank canvas\n    vec3 col = vec3(1.0);\n    \n    // graph axes\n    col = min(col, smoothstep(lm, lw, distance( ndc, ndc*vec2(1.0, 0.0) )));\n    col = min(col, smoothstep(lm, lw, distance( ndc, ndc*vec2(0.0, 1.0) )));\n    // graph lighter grid lines\n    col = min(col, 0.8 + 0.2 * smoothstep(lm * 2.0, lw * 2.0, fract(distance( ndc, ndc*vec2(1.0, 0.0) ))));\n    col = min(col, 0.8 + 0.2 * smoothstep(lm * 2.0, lw * 2.0, fract(distance( ndc, ndc*vec2(0.0, 1.0) ))));\n\n    // input incident point P from user mouse\n    vec2 p = vec2(1.0, 0.0);\n    if (iTime > TAU) {\n        p.x = 1.0 + EPS + sin(iTime);\n    }\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) {\n        p = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        p.x *= iResolution.x / iResolution.y;\n        p *= zoom;\n    }\n    \n    col = graphEllipse(col, ndc, lm, lw, p);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float EPS = (1.0 / 128.0);\nconst float PI =  3.141592;\nconst float TAU = 6.283185;\n\nfloat wedge(in vec2 a, in vec2 b) {\n    return a.x*b.y - b.x*a.y;\n}\n\nfloat sd_segment(vec2 xy, vec2 pt1, vec2 pt2) {\n    vec2 a = pt2 - pt1;\n\tvec2 b = xy - pt1;\n\tfloat h = dot(b, a) / dot(a, a);\n\treturn length(b - clamp(h, 0.0, 1.0) * a);\n}\n\nfloat sd_line(vec2 xy, vec2 m, vec2 b) {\n    vec2 c = xy - b;\n    float h = dot(c, m) / dot(m, m);\n    return length(c - h * m);\n}\n\nfloat sd_circle(vec2 xy, vec2 c, float r) {\n    return abs(distance(xy, c) - r);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}