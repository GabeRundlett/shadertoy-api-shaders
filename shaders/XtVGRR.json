{
    "Shader": {
        "info": {
            "date": "1472739571",
            "description": "Another domain repetition experiment.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtVGRR",
            "likes": 10,
            "name": "blok",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "domain",
                "repetition"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 723
        },
        "renderpass": [
            {
                "code": "/*\n\t\"blok\" by wjbgrafx\n\t\n\tbased on :\n\t\t\n\tRaymarched Reflections   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n\tPlaying with symmetries - Torus\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n\tRaymarching Primitives - Created by inigo quilez - iq/2013\n\thttps://www.shadertoy.com/view/Xds3zN\n\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\tArray and textureless GLSL 2D/3D/4D simplex noise functions.\n    Ian McEwan, Ashima Arts.\n\t\n\t2D and 3D Procedural Textures in WebGL\n\thttp://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t\n\tpyramid function from \"pyramids\"    Uploaded by avix in 2014-Jan-16\n\thttps://www.shadertoy.com/view/lsBGzG\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PHI \t\t\t\t\t1.618033988749895\n\n#define FAR                     300.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_FOV_FACTOR          1.5\n#define LOOK_AT                 vec3( 0.0, 4.0, 0.0 )\n#define LIGHT_COLOR\t\t\t\tvec3( 1.0 )\n#define LIGHT_ATTEN\t\t\t\t0.01\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                            in vec3 lightPos );\nfloat sdSphere( vec3 p, float s );\nfloat sdEllipsoid( in vec3 p, in vec3 r );\nfloat sdTorus( vec3 p, vec2 t );\n\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\nfloat pMod1(inout float p, float size); \nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset); \nvec2 pMirrorOctant (inout vec2 p, vec2 dist); \nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\nfloat fOctahedron(vec3 p, float r, float e);\n \nfloat pyramid( vec3 p, float h);  \nfloat modPyramid( vec3 p, float h, float baseScale ); \nfloat modOctahedron( vec3 p, float height, float scale );\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal );\n\nfloat snoise(vec3 v);\n\n//==============================================================================\n// MAP\n// ---\n\nvec2 map( vec3 p )\n{  \n\tfloat dist = 3.0;\n\tpReflect( p, normalize( vec3( 1.0, -1.0, 0.0 ) ), dist );\n\tpReflect( p, normalize( vec3( -1.0, -1.0, 0.0 ) ), dist );\n\n\tpMod1( p.z, 20.0 );\n\tvec3 p2 = p;\n\n\tp2.xz = rot( p2.xz, iTime * 0.19 );\n\tp2.xz = rotsim( p2.xz, 3.0 );\n\tp2.z -= 6.0;\n\n\tpMirrorOctant( p.yz, vec2( 6.0 ) );\n\n\tfloat objID = 1.0;\t      \n\tvec2 obj1 = vec2( fPlane( p, vec3( 0.0, 1.0, 0.0 ), 5.0 ), objID );\n\t\n\tobjID = 2.0;\t\n\tvec2 obj2 = \n\tvec2( modCutoutPyramid( p2 - vec3( 0.0, -5.0, 0.0 ), 7.0, 1.45 ), objID );\n\t                                                                   \n\tp2.xz = rot( p2.xz, iTime * -0.73 );\n\n\tobjID = 3.0;\n\tfloat d1 = fOctahedron( p2 - vec3( 0.0, -1.8, 0.0 ), 1.6, 10.0 ),\n\t      d2 = sdEllipsoid( p2 - vec3( 0.0, -1.8, 0.0 ), vec3( 1.55, 1.55, \n\t                                                                   4.75 ) );\n\tvec2 obj3 = vec2(max( d1, -d2 ), objID );\n\t      \n\tp2.xz = rot( p2.xz, iTime * 1.23 );\n\n\tobjID = 4.0;\n\tvec2 obj4 = vec2( modOctahedron( p2 - vec3( 0.0, -1.8, 0.0 ), 1.4, 1.1 ), \n\t                                                                   objID );\t\n\tobjID = 5.0;\n\tvec2 obj5 = vec2( sdTorus( p2 - vec3( 0.0, -4.7, 0.0 ), vec2( 3.9, 0.25 ) ),\n\t                                                                  objID );\t\n\tobjID = 1.0;\n\tvec2 obj6 = vec2( sdSphere( p2 - vec3( 1.6, 0.9, 1.6 ), 0.5 ), objID );\n\t\t                                                                  \n\tvec2 obj7 = vec2( sdSphere( p2 - vec3( -1.6, 0.9, -1.6 ), 0.5 ), objID );\n\t\n\tvec2 obj8 = vec2( sdSphere( p2 - vec3( 1.6, 0.9, -1.6 ), 0.5 ), objID );\n\t\t                                                                  \n\tvec2 obj9 = vec2( sdSphere( p2 - vec3( -1.6, 0.9, 1.6 ), 0.5 ), objID );\n\t\n\tvec2 closest = obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\tclosest = closest.s < obj3.s ? closest : obj3;\n\tclosest = closest.s < obj4.s ? closest : obj4;\n\tclosest = closest.s < obj5.s ? closest : obj5;\n\tclosest = closest.s < obj6.s ? closest : obj6;\n\tclosest = closest.s < obj7.s ? closest : obj7;\n\tclosest = closest.s < obj8.s ? closest : obj8;\n\tclosest = closest.s < obj9.s ? closest : obj9;\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID, vec3 rayDir )\n{    \n    vec3 clr = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tclr = vec3( 0.7, 0.8, 1.0 );\n\t}\n\telse if( objNum == 2.0 )\n    {\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.13 );\n\t\tclr = vec3( 0.45 + timeVal, 0.55 + timeVal, 0.7 + timeVal ); \n\t\t\n\t\tvec3 pos = distID.s * rayDir;\n\t\tpos.z += iTime * 3.0; \n\t\t\n\t\tfloat scale = 0.5,\n\t\t      complexity = 2.0,\n\t\t      mixVal = 0.875;\n\n\t\t// 2D and 3D Procedural Textures in WebGL\n        // http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t\t// wjb modified Perlin Noise 3D \n\t\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t\t// on white background - texture 21\n\t\tvec3 v = pos * scale;\n\t\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n\t    value = 0.75 + value * 0.25;\n\t    vec3 color = vec3( 1.0 - value );  // inverted  \t\t    \n\t\tclr = mix( color, clr, mixVal ); \n\t}\n\telse if ( objNum == 3.0 )\n\t{\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.17 );\n\t\tclr = vec3( 0.45 + timeVal, 0.55 + timeVal, 0.7 + timeVal );\n\t}\n\telse if ( objNum == 4.0 )\t\n\t{\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.23 );\n\t\tclr = vec3( 0.65 + timeVal, 0.7 + timeVal, 0.5 + timeVal ); \n\t}\n\telse if( objNum == 5.0 )\n    {\n\t\tfloat timeVal = 0.3 * sin( iTime * 0.29 );\n\t\tclr = vec3( 0.7 + timeVal, 0.65 + timeVal, 0.5 + timeVal ); \n\t}\n\t    \n    return clr;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // cam position moves into tunnel and up/down, side to side\n    vec3 camPos = vec3( 2.0 * sin( iTime * 0.43 ), \n                  4.0 + 2.0 * sin( iTime * 0.51 ), \n                                   iTime * 3.0 );                               \n    vec3 lookAt = camPos + vec3( 0.0, 0.0, camPos.z + 10.0 );\n    vec3 rayDir = getRayDir( camPos, normalize( lookAt - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = vec3( 0.0, 0.0, \n         camPos.z + 10.0 + 30.0 * sin( ( 20.0 + iTime ) * \n                                                   ( 0.04 * log( iTime ) ) ) );\n\tvec3 sceneColor = vec3( 0.0 );\n\tfloat timeVal = 0.3 * sin( iTime * 0.31 );\n\tvec3 skyClr  = vec3( 0.4 + timeVal, 0.5 + timeVal, 0.7 + timeVal ); \n\t\t                \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( ( camPos.z + FAR ) * 0.4, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID, lightPos );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID, lightPos ) \n\t                                                                    * 0.35;\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. \n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                             in vec3 lightPos )\n{    \n    // Light direction vector.\n    //vec3 lDir = LIGHT_POS - sp; \n    vec3 lDir = lightPos - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    // wjb added rayDir as argument in order to allow texturing of objects.\n    vec3 objCol = getObjectColor( sp, distID, rayDir );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + LIGHT_COLOR * spec * 2.0 ) * \n                                                                         atten;\n  \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Horizontal torus lying in xz plane at y = 0; t = vec2( lg. diam, sm. diam )\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//------------------------------------------------------------------------------\n\n// From Playing with symmetries - Torus\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n// HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf\n\n// Sign function that doesn't return 0\nfloat sgn(float x) \n{\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) \n{                           \n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) \n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) \n{\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\t\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist) \n{\n\tfloat s = sgn(p); \n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) \n{\n\tvec2 s = sgn(p);\t\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n//------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/lsBGzG\n// Pyramid with base on xz-plane at y=0.0, h = height, width, and depth\nfloat pyramid( vec3 p, float h) \n{\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n\n//------------------------------------------------------------------------------\n\n// Modified from pyramid(), above.\n// Pyramid with base on xz-plane at y=0.0, h = height, s = scaling factor for\n// length of an edge of the square pyramid base, where edge length = s * h, \n// i.e., h = 2.0, s = 0.5, base edge = 1.0; or h = 2.0, s = 2.0, base edge = 4.0\n// s MUST BE >= 0.5\n                        \nfloat modPyramid( vec3 p, float h, float s ) \n{\n\tvec3 q = abs( p );\n\tfloat scale = 1.0 / s;\n\treturn max( -p.y, ( q.x * scale + q.y + q.z * scale - h ) / 3.0 );\n}\n\n//------------------------------------------------------------------------------\n// wjb : This should replace cutoutPyramid, as it allows adjustment of size of\n// cutout.\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal )\n{\n\tvec3 p2 = p;\n\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\n\tfloat d1 = pyramid( p2, height ),\n\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ),  \n\t                                       height * ( scaleVal / 1.5 ), 1.35 );\n\treturn max( d1, -d2 );\n}\n//------------------------------------------------------------------------------\n// wjb: Joining two modPyramids to form an octahedron with variable base length.\n// scale MUST BE >= 0.5\n\nfloat modOctahedron( vec3 p, float height, float scale )\n{\n\tfloat d1 = modPyramid( p, height, scale );\n\tp.yz = rot( p.yz, PI );\n\tfloat d2 = modPyramid( p, height, scale );\n\treturn min( d1, d2 );\t\t\n}\n//------------------------------------------------------------------------------\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n// wjb note - This is the code from first version, newer version crashes Nvidia\n// Macro based version for GLSL 1.2 / ES 2.0\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging \n// of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D and 2D Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ---------------------------------\n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), \n                                                                  dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), \n                                                                           0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}