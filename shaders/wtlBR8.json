{
    "Shader": {
        "info": {
            "date": "1596770129",
            "description": "Click the squares top right to select tool.\nRight to left explanation:\nEraser,\nSand,\nWater,\nExplosive gas,\nFire,\nWater vapor,\nBomb,\nTank (A, D to move, ARROW RIGHT, ARROW LEFT to aim, SPACE to shoot),\nExplosion,\nBroken tank,\nEnemy (attacks player),\nLazer",
            "flags": 48,
            "hasliked": 0,
            "id": "wtlBR8",
            "likes": 29,
            "name": "Particle simulator Click to draw",
            "published": 3,
            "tags": [
                "simulation"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 1211
        },
        "renderpass": [
            {
                "code": "const ivec2 offsets[25] = ivec2[](\n    ivec2(-2, 2), ivec2(-1, 2), ivec2( 0, 2), ivec2( 1, 2), ivec2( 2, 2),\n    ivec2(-2, 1), ivec2(-1, 1), ivec2( 0, 1), ivec2( 1, 1), ivec2( 2, 1),\n    ivec2(-2, 0), ivec2(-1, 0), ivec2( 0, 0), ivec2( 1, 0), ivec2( 2, 0),\n    ivec2(-2,-1), ivec2(-1,-1), ivec2( 0,-1), ivec2( 1,-1), ivec2( 2,-1),\n    ivec2(-2,-2), ivec2(-1,-2), ivec2( 0,-2), ivec2( 1,-2), ivec2( 2,-2)\n);\nconst int offsetsIndices[25] = int[](\n    0, 1, 2, 3, 4,\n    5, 6, 7, 8, 9,\n    10, 11, 12, 13, 14,\n    15, 16, 17, 18, 19,\n    20, 21, 22, 23, 24\n);\nconst int indUULL = 0;const int indUUL = 1;const int indUU = 2;const int indUUR = 3;const int indUURR = 4;\nconst int indULL = 5;const int indUL = 6;const int indU = 7;const int indUR = 8;const int indURR = 9;\nconst int indLL = 10;const int indL = 11;const int indC = 12;const int indR = 13;const int indRR = 14;\nconst int indDLL = 15;const int indDL = 16;const int indD = 17;const int indDR = 18;const int indDRR = 19;\nconst int indDDLL = 20;const int indDDL = 21;const int indDD = 22;const int indDDR = 23;const int indDDRR = 24;\nfloat glowFactor(vec4 pixels[25], int cl){\n    float f = 0.;\n    #define GF(ind, cl) float(getClass(pixels[ind])==cl)\n    f +=\n        GF(indUULL,cl)*1. + GF(indUUL,cl)*4. + GF(indUU,cl)*7. + GF(indUUR,cl)*4. + GF(indUURR,cl)*1. +\n        GF(indULL,cl)*4. + GF(indUL,cl)*16. + GF(indU,cl)*26. + GF(indUR,cl)*16. + GF(indURR,cl)*4. +\n        GF(indLL,cl)*7. + GF(indL,cl)*26. + GF(indC,cl)*41. + GF(indR,cl)*26. + GF(indRR,cl)*7. +\n        GF(indULL,cl)*4. + GF(indDL,cl)*16. + GF(indD,cl)*26. + GF(indDR,cl)*16. + GF(indDRR,cl)*4. +\n        GF(indDDLL,cl)*1. + GF(indDDL,cl)*4. + GF(indDD,cl)*7. + GF(indDDR,cl)*4. + GF(indDDRR,cl)*1.\n    ;\n    f /= 273.0;\n\treturn f;\n}\nvec3 getColor(vec4 pixels[25]){\n    vec4 p = pixels[indC];\n    int cl = getClass(p);\n    vec3 color;\n    if(\n        cl == TANK ||\n        getClass(pixels[indU]) == TANK ||\n        getClass(pixels[indUR]) == TANK ||\n        getClass(pixels[indUL]) == TANK ||\n        getClass(pixels[indR]) == TANK ||\n        getClass(pixels[indL]) == TANK ||\n        getClass(pixels[indRR]) == TANK ||\n        getClass(pixels[indURR]) == TANK ||\n        getClass(pixels[indLL]) == TANK ||\n        getClass(pixels[indULL]) == TANK ||\n        getClass(pixels[indUUR]) == TANK ||\n        getClass(pixels[indUUL]) == TANK ||\n        getClass(pixels[indUU]) == TANK ||\n        getClass(pixels[indD]) == TANK ||\n        getClass(pixels[indDD]) == TANK ||\n        getClass(pixels[indDDRR]) == TANK ||\n        getClass(pixels[indDDLL]) == TANK ||\n        pixels[indDDL].x >= 0. && getClass(pixels[indDDL]) == TANK ||\n        pixels[indDR].x >= 0. && getClass(pixels[indDR]) == TANK ||\n        pixels[indDDR].x < 0. && getClass(pixels[indDDR]) == TANK ||\n        pixels[indDL].x < 0. && getClass(pixels[indDL]) == TANK\n    ){\n        color = TANK_COLOR;\n    }else if(\n        cl == TANK ||\n        getClass(pixels[indU]) == BROKEN_TANK ||\n        getClass(pixels[indUR]) == BROKEN_TANK ||\n        getClass(pixels[indUL]) == BROKEN_TANK ||\n        getClass(pixels[indR]) == BROKEN_TANK ||\n        getClass(pixels[indL]) == BROKEN_TANK ||\n        getClass(pixels[indRR]) == BROKEN_TANK ||\n        getClass(pixels[indURR]) == BROKEN_TANK ||\n        getClass(pixels[indLL]) == BROKEN_TANK ||\n        getClass(pixels[indULL]) == BROKEN_TANK ||\n        getClass(pixels[indUUR]) == BROKEN_TANK ||\n        getClass(pixels[indUUL]) == BROKEN_TANK ||\n        getClass(pixels[indUU]) == BROKEN_TANK ||\n        getClass(pixels[indD]) == BROKEN_TANK ||\n        getClass(pixels[indDD]) == BROKEN_TANK ||\n        getClass(pixels[indDDRR]) == BROKEN_TANK ||\n        getClass(pixels[indDDLL]) == BROKEN_TANK ||\n        pixels[indDDL].x >= 0. && getClass(pixels[indDDL]) == BROKEN_TANK ||\n        pixels[indDR].x >= 0. && getClass(pixels[indDR]) == BROKEN_TANK ||\n        pixels[indDDR].x < 0. && getClass(pixels[indDDR]) == BROKEN_TANK ||\n        pixels[indDL].x < 0. && getClass(pixels[indDL]) == BROKEN_TANK\n    ){\n        color = BROKEN_TANK_COLOR;\n    }else if(cl == SAND){\n        color = SAND_COLOR;\n    }else if(cl == WATER){\n        color = WATER_COLOR;\n    }else if(cl == GAS){\n        //color = GAS_COLOR;\n        color = EMPTY_COLOR;\n    }else if(cl == FIRE){\n        //vec3 c = FIRE_COLOR;\n        //c *= max(1.5/(1. + length(p.xy)*0.2), 0.2);\n        //c = min(c, 1.);\n        //color = c;\n        color = EMPTY_COLOR;\n    }else if(cl == WATER_VAPOR){\n        //color = WATER_VAPOR_COLOR;\n        color = EMPTY_COLOR;\n    }else if(cl == BOMB){\n        color = BOMB_COLOR;\n    }else if(cl == EXPLOSION){\n        color = EXPLOSION_COLOR;\n    }else if(cl == BROKEN_TANK){\n        color = BROKEN_TANK_COLOR;\n    }else if(\n            cl == AIRCRAFT || getClass(pixels[indD]) == AIRCRAFT || getClass(pixels[indDD]) == AIRCRAFT ||\n            getClass(pixels[indL]) == AIRCRAFT || getClass(pixels[indDDL]) == AIRCRAFT || getClass(pixels[indR]) == AIRCRAFT ||\n            getClass(pixels[indDDR]) == AIRCRAFT || getClass(pixels[indDLL]) == AIRCRAFT || getClass(pixels[indDDLL]) == AIRCRAFT ||\n            getClass(pixels[indDRR]) == AIRCRAFT || getClass(pixels[indDDRR]) == AIRCRAFT || getClass(pixels[indU]) == AIRCRAFT ||\n            getClass(pixels[indUL]) == AIRCRAFT || getClass(pixels[indUR]) == AIRCRAFT || getClass(pixels[indUU]) == AIRCRAFT\n    ){\n        color = AIRCRAFT_COLOR;\n    }else if(cl == LAZER){\n        color = LAZER_COLOR;\n    }else if(cl == MEGA_BOMB){\n        color = MEGA_BOMB_COLOR;\n    }else if(cl == DIRT){\n        color = DIRT_COLOR;\n    }else if(cl == CONCRETE){\n        color = CONCRETE_COLOR;\n    }else if(cl == CONCRETE_BROKEN){\n        color = CONCRETE_BROKEN_COLOR;\n    }else if(cl == NUKE){\n        color = NUKE_COLOR;\n    }else if(cl == GRASS){\n        color = GRASS_COLOR;\n    }else{\n    \tcolor = EMPTY_COLOR;\n   \t}\n    // Glow.\n    const int size = 8;\n    const int[size] cls = int[](BOMB, FIRE, GAS, WATER_VAPOR, LAZER, MEGA_BOMB, NUKE, GRASS);\n    const vec3[size] cols = vec3[](BOMB_COLOR, FIRE_COLOR, GAS_COLOR, WATER_VAPOR_COLOR, LAZER_COLOR, MEGA_BOMB_COLOR, NUKE_COLOR, GRASS_COLOR);\n    const float[size] facs = float[](4., 2., 1., 1., 8., 16., 16., 1.);\n    int unwind_breaker = 0; // I read somewhere but can't remember where, this would make the for loop not unwind, improving compile time.\n    for(int i=0; i<size+unwind_breaker; i++){\n    \tfloat fac = glowFactor(pixels, cls[i]) * facs[i];\n        color = mix(color, cols[i], fac);\n    }\n    /*// Glowing bullets.\n    float fac = glowFactor(pixels, BOMB);\n    color = mix(color, BOMB_COLOR, fac);\n    // Glowing fire.\n    fac = glowFactor(pixels, FIRE)*2.;\n    color = mix(color, FIRE_COLOR, fac);\n    // Glowing gas.\n    fac = glowFactor(pixels, GAS)*1.;\n    color = mix(color, GAS_COLOR, fac);\n    // Glowing water vapor.\n    fac = glowFactor(pixels, WATER_VAPOR)*1.;\n    color = mix(color, WATER_VAPOR_COLOR, fac);\n    // Glowing lazer.\n    fac = glowFactor(pixels, LAZER)*8.;\n    color = mix(color, LAZER_COLOR, fac);*/\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));*/\n    \n    ivec2 myCoords = ivec2(fragCoord);\n    \n    vec4 p = texelFetch(iChannel0, myCoords, 0);\n    \n    vec4 pixels[25];\n    for(int i=0; i<25; i++){\n    \t//pixels[i] = gp(myCoords + offsets[i]);\n    \tpixels[i] = texelFetch(iChannel0, myCoords + offsets[i], 0);\n    }\n    \n    // Render particles.\n    vec3 color = getColor(pixels);\n    \n    // Render GUI.\n    if(fragCoord.y >= iResolution.y - MENU_HEIGHT && iResolution.x - fragCoord.x < MENU_WIDTH * MENU_NUM_BUTTONS){\n        int fromRight = int((iResolution.x - fragCoord.x) / MENU_WIDTH);\n        if(fromRight == 0){\n        \tcolor = MENU_ERASER_COLOR;\n        }else if(fromRight == 1){\n        \tcolor = SAND_COLOR;\n        }else if(fromRight == 2){\n        \tcolor = WATER_COLOR;\n        }else if(fromRight == 3){\n        \tcolor = GAS_COLOR;\n        }else if(fromRight == 4){\n        \tcolor = FIRE_COLOR;\n        }else if(fromRight == 5){\n        \tcolor = WATER_VAPOR_COLOR;\n        }else if(fromRight == 6){\n        \tcolor = BOMB_COLOR;\n        }else if(fromRight == 7){\n        \tcolor = TANK_COLOR;\n        }else if(fromRight == 8){\n        \tcolor = EXPLOSION_COLOR;\n        }else if(fromRight == 9){\n        \tcolor = BROKEN_TANK_COLOR;\n        }else if(fromRight == 10){\n        \tcolor = AIRCRAFT_COLOR;\n        }else if(fromRight == 11){\n        \tcolor = LAZER_COLOR;\n        }else if(fromRight == 12){\n        \tcolor = MEGA_BOMB_COLOR;\n        }else if(fromRight == 13){\n        \tcolor = DIRT_COLOR;\n        }else if(fromRight == 14){\n        \tcolor = CONCRETE_COLOR;\n        }else if(fromRight == 15){\n        \tcolor = CONCRETE_BROKEN_COLOR;\n        }else if(fromRight == 16){\n        \tcolor = NUKE_COLOR;\n        }else if(fromRight == 17){\n        \tcolor = HOUSE_COLOR;\n        }else if(fromRight == 18){\n        \tcolor = GRASS_COLOR;\n        }\n    }\n    bool doAutoSpawn = texelFetch(iChannel0, ivec2(AUTO_SPAWN_AIRCRAFT, 0), 0).x > 0.5;\n    ivec2 topLeft = ivec2(iResolution.x*0.04, iResolution.y*0.95);\n    if(length(vec2(myCoords-topLeft)) < 5.){\n        if(doAutoSpawn){\n        \tcolor = mix(color, vec3(1.,0.,0.), 0.75);\n        }\n    }\n    \n    //\n    vec2 tankPos = texelFetch(iChannel0, ivec2(TANK_POSITION, 0), 0).xy;\n    if(myCoords == ivec2(tankPos)){\n    \tcolor.r = 1.;\n    }\n    // Crosshair.\n    if(tankPos.x != -1.){\n        vec2 tankDir = vec2(myCoords) - tankPos;\n        float tankShootAngle = texelFetch(iChannel0, ivec2(TANK_SHOOT_ANGLE, 0), 0).x;\n        vec2 aimDir = vec2(\n            cos(tankShootAngle),\n            sin(tankShootAngle)\n        );\n        float d = dot(tankDir, aimDir);\n        float cosA = d/length(tankDir);\n        const float minRange = 30.;\n        const float maxRange = 300.;\n        const float maxCosA = 0.9998;\n        if(d > minRange && d < maxRange && cosA > maxCosA){\n            //color.rgb = vec3(1.);\n            float forwardFactor = (d-minRange)/(maxRange-minRange);\n            forwardFactor *= (1.-forwardFactor);\n            float sideFactor = (cosA - maxCosA)/(1.-maxCosA);\n            color = mix(color, vec3(1), forwardFactor*sideFactor);\n        }\n    }\n    //color.r = tankShootAngle*0.1;\n    //gp(myCoords + offsets[i]);\n    \n    //\n    if(exist(p)){\n        //color += length(p.xy)*.01;\n        //color = mix(color, vec3(1., 0.8, 0.5), length(p.xy)*.01);\n        float f = 0.02;\n        if(getClass(p) == WATER_VAPOR){\n            f = 0.002;\n        }\n        color += vec3(1.0, 0.5, 0.125) * length(p.xy)*f;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Math.\n# define PI 3.1415926538\n# define SPEED 1.0\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_Q  = 81;\nconst int KEY_J  = 74;\nconst int KEY_K  = 75;\n\n# define EMPTY -1\nconst vec3 EMPTY_COLOR = vec3(0., 0., 0.)/255.;\n# define SAND 0\nconst vec3 SAND_COLOR = vec3(242., 198., 95.)/255.;\n# define WATER 1\nconst vec3 WATER_COLOR = vec3(51., 76., 122.)/255.;\n# define GAS 2\nconst vec3 GAS_COLOR = vec3(80., 163., 133.)/255.;\n# define FIRE 3\nconst vec3 FIRE_COLOR = vec3(214., 128., 51.)/255.;\n# define WATER_VAPOR 4\nconst vec3 WATER_VAPOR_COLOR = vec3(128., 128., 160.)/255.;\n# define BOMB 5\nconst vec3 BOMB_COLOR = vec3(255., 255., 0.)/255.;\n# define TANK 6\nconst vec3 TANK_COLOR = vec3(64., 127., 0.)/255.;\n# define EXPLOSION 7\nconst vec3 EXPLOSION_COLOR = vec3(255., 170., 102.)/255.;\n# define BROKEN_TANK 8\nconst vec3 BROKEN_TANK_COLOR = vec3(64., 64., 64.)/255.;\n# define AIRCRAFT 9\nconst vec3 AIRCRAFT_COLOR = vec3(192., 0., 127.)/255.;\n# define LAZER 10\nconst vec3 LAZER_COLOR = vec3(255., 0., 0.)/255.;\n# define MEGA_BOMB 11\nconst vec3 MEGA_BOMB_COLOR = vec3(0., 127., 127.)/255.;\n# define DIRT 12\nconst vec3 DIRT_COLOR = vec3(155., 118., 83.)/255.;\n# define CONCRETE 13\nconst vec3 CONCRETE_COLOR = vec3(100., 100., 100.)/255.;\n# define CONCRETE_BROKEN 14\nconst vec3 CONCRETE_BROKEN_COLOR = vec3(80., 80., 80.)/255.;\n# define NUKE 15\nconst vec3 NUKE_COLOR = vec3(0., 100., 255.)/255.;\n# define HOUSE 16\nconst vec3 HOUSE_COLOR = vec3(255., 255., 255.)/255.;\n# define GRASS 16\nconst vec3 GRASS_COLOR = vec3(76., 174., 5.)/255.;\n\n# define MENU_HEIGHT 20.\n# define MENU_WIDTH 20.\n# define MENU_NUM_BUTTONS 19.\n# define MENU_ERASER_COLOR vec3(0.5,0.5,0.5)\nconst int SELECTOR = 0;\nconst int MOUSE_TIME_DOWN = 1;\nconst int TANK_POSITION = 2;\nconst int TANK_SHOOT_ANGLE = 3;\nconst int TIME = 4;\nconst int AUTO_SPAWN_AIRCRAFT = 5;\n\n# define GP \\\nvec4 gp(ivec2 coords){\\\n    /*if(*/\\\n    /*    coords.x < 0 || coords.x >= int(iResolution.x) ||*/\\\n    /*\tcoords.y < 1 || coords.y >= int(iResolution.y)*/\\\n    /*){*/\\\n    /*\treturn vec4(0);*/\\\n    /*}*/\\\n    return texelFetch(iChannel0, coords, 0);\\\n}\\\nvec4 gp(vec2 coords){\\\n    return gp(ivec2(coords));\\\n}\n# define GET_INCOMING \\\nivec2 getIncoming(ivec2 coords, out vec4 particle){\\\n    vec4 pU, pUR, pUL, pR, pL, pDR, pDL, pD;\\\n    if(exist(pU = gp(coords + ivec2(0, 1))) &&\\\n    \t\tparticleCellDir(pU) == D){\\\n        particle = pU;\\\n        return coords + ivec2(0, 1);\\\n    }else if(exist(pUR = gp(coords + ivec2(1, 1))) &&\\\n        \tparticleCellDir(pUR) == DL){\\\n        particle = pUR;\\\n        return coords + ivec2(1, 1);\\\n    }else if(exist(pUL = gp(coords + ivec2(-1, 1))) &&\\\n        \tparticleCellDir(pUL) == DR){\\\n        particle = pUL;\\\n        return coords + ivec2(-1, 1);\\\n    }else if(exist(pR = gp(coords + ivec2(1, 0))) &&\\\n        \tparticleCellDir(pR) == L){\\\n        particle = pR;\\\n        return coords + ivec2(1, 0);\\\n    }else if(exist(pL = gp(coords + ivec2(-1, 0))) &&\\\n        \tparticleCellDir(pL) == R){\\\n        particle = pL;\\\n        return coords + ivec2(-1, 0);\\\n    }else if(exist(pDR = gp(coords + ivec2(1, -1))) &&\\\n        \tparticleCellDir(pDR) == UL){\\\n        particle = pDR;\\\n        return coords + ivec2(1, -1);\\\n    }else if(exist(pDL = gp(coords + ivec2(-1, -1))) &&\\\n        \tparticleCellDir(pDL) == UR){\\\n        particle = pDL;\\\n        return coords + ivec2(-1, -1);\\\n    }else if(exist(pD = gp(coords + ivec2(0, -1))) &&\\\n        \tparticleCellDir(pD) == U){\\\n        particle = pD;\\\n        return coords + ivec2(0, -1);\\\n    } else {\\\n        particle = vec4(0,0,0,0);\\\n        return ivec2(-1);\\\n    }\\\n}\n# define MOVE_PARTICLE \\\nvec4 moveParticle(vec4 p, ivec2 myCoords, out ivec2 targetCoordsOut){\\\n\t\\\n    vec4 pNextState = p;\\\n    \\\n    /* Simulate movement.*/\\\n    /* Determine this cell's state*/\\\n    if(exist(p)){\\\n    \t/* This cell's particle exist.*/\\\n        /* Check if particle tries to move out of cell.*/\\\n        vec4 targetP; /* Target particle.*/\\\n        int thisDir = particleCellDir(p);\\\n        ivec2 targetCoords = myCoords;\\\n        if(thisDir == U){\\\n        \ttargetCoords += ivec2(0,1);\\\n        } else if(thisDir == D){\\\n        \ttargetCoords += ivec2(0,-1);\\\n        } else if(thisDir == R){\\\n        \ttargetCoords += ivec2(1,0);\\\n        } else if(thisDir == L){\\\n        \ttargetCoords += ivec2(-1,0);\\\n        } else if(thisDir == UR){\\\n        \ttargetCoords += ivec2(1,1);\\\n        } else if(thisDir == UL){\\\n        \ttargetCoords += ivec2(-1,1);\\\n        } else if(thisDir == DR){\\\n        \ttargetCoords += ivec2(1,-1);\\\n        } else if(thisDir == DL){\\\n        \ttargetCoords += ivec2(-1,-1);\\\n        }\\\n        if(\\\n            !exist(gp(targetCoords)) &&\\\n            myCoords == getIncoming(/*ivec2 coords=*/targetCoords, /*out vec4 particle=*/targetP) &&\\\n            !((thisDir == D || thisDir == DR || thisDir == DL) && myCoords.y == 1) &&\\\n            !((thisDir == L || thisDir == UL || thisDir == DL) && myCoords.x == 0) &&\\\n            !((thisDir == R || thisDir == UR || thisDir == DR) && myCoords.x == int(iResolution.x)-1) &&\\\n            !((thisDir == U || thisDir == UR || thisDir == UL) && myCoords.y == int(iResolution.y)-1)\\\n        ){\\\n            /* This particle is going to the target.*/\\\n        \tdestroy(pNextState);\\\n        \ttargetCoordsOut = targetCoords;\\\n        } else {\\\n            /* Stay the same.*/\\\n            /* Move by velocity.*/\\\n            vec2 pos = getPos(pNextState);\\\n            pos += limSize(pNextState.xy);\\\n            pos = clamp(pos, 0., 1.-1e-5);\\\n            pNextState.zw = floor(pNextState.zw) + pos;\\\n            \\\n            targetCoordsOut = myCoords;\\\n        }\\\n    } else {\\\n    \t/* This cell's particle does not exist.*/\\\n        /* Look for particle moving into cell.*/\\\n        ivec2 incomingCoords = getIncoming(/*ivec2 coords=*/myCoords, /*out vec4 particle=*/pNextState);\\\n        if(incomingCoords.x != -1){\\\n        \tvec2 pos = getPos(pNextState);\\\n            pos += limSize(pNextState.xy);\\\n            pos = mod(pos.xy, 1.-1e-3);\\\n            pNextState.zw = floor(pNextState.zw) + pos;\\\n            \\\n            targetCoordsOut = incomingCoords;\\\n        } else {\\\n        \ttargetCoordsOut = myCoords;\\\n        }\\\n    }\\\n    return pNextState;\\\n}\n# define SHOULD_DETONATE_BOMB \\\nbool shouldDetonateBomb(int cl){\\\n    return cl != BOMB && cl != FIRE && cl != EXPLOSION && cl != WATER_VAPOR && cl != WATER && cl != LAZER;\\\n}\n# define SHOULD_DETONATE_MEGA_BOMB \\\nbool shouldDetonateMegaBomb(int cl){\\\n    return cl != BOMB && cl != MEGA_BOMB && cl != FIRE && cl != EXPLOSION && cl != WATER_VAPOR && cl != WATER && cl != LAZER && cl != AIRCRAFT && cl != GAS;\\\n}\n# define SHOULD_DETONATE_NUKE \\\nbool shouldDetonateNuke(int cl){\\\n    return cl != BOMB && cl != MEGA_BOMB && cl != NUKE && cl != FIRE && cl != EXPLOSION && cl != WATER_VAPOR && cl != WATER && cl != LAZER && cl != AIRCRAFT && cl != GAS;\\\n}\n# define CALC_IMPULSES \\\nvec4 calcImpulses(ivec2 myCoords, int iteration){\\\n    vec4 p = gp(myCoords);\\\n    \\\n\tvec4 pNextState = p;\\\n    \\\n    ivec2 tankPos = ivec2(texelFetch(iChannel0, ivec2(TANK_POSITION, 0), 0).xy);\\\n    int pClass = getClass(p);\\\n    \\\n    /* Simulate forces.*/\\\n    \\\n    /* Collisions.*/\\\n    /* Particle-particle.*/\\\n    const ivec2 offsets[8] = ivec2[](\\\n        ivec2( 0, 1),\\\n        ivec2(-1, 1),\\\n        ivec2( 1, 1),\\\n        ivec2(-1, 0),\\\n        ivec2( 1, 0),\\\n        ivec2(-1,-1),\\\n        ivec2( 1,-1),\\\n        ivec2( 0,-1)\\\n    );\\\n    const vec2 normals[8] = vec2[](\\\n        normalize(vec2( 0,-1)),\\\n        normalize(vec2( 1,-1)),\\\n        normalize(vec2(-1,-1)),\\\n        normalize(vec2( 1, 0)),\\\n        normalize(vec2(-1, 0)),\\\n        normalize(vec2( 1, 1)),\\\n        normalize(vec2(-1, 1)),\\\n        normalize(vec2( 0, 1))\\\n    );\\\n    const int directions[8] = int[](\\\n    \tU, UL, UR, L, R, DL, DR, D\\\n    );\\\n    int cellMoveDir = particleCellDir(p);\\\n    vec4 targets[8];\\\n    for(int i=0; i<8; i++){\\\n    \tivec2 targetCoords = myCoords + offsets[i];\\\n        vec4 target = gp(targetCoords);\\\n        int targetClass = getClass(target);\\\n        targets[i] = target;\\\n        int direction = directions[i];\\\n        if(exist(p)){\\\n            if(exist(target)){\\\n                /**/\\\n                vec2 normal = normals[i];\\\n                /* Remove bomb. */\\\n                const float MIN_EXPLODE_DIST_TANK = 20.;\\\n                if(pClass == BOMB && shouldDetonateBomb(targetClass)){\\\n                    if(length(vec2(myCoords) - vec2(tankPos)) > MIN_EXPLODE_DIST_TANK &&\\\n                       targetClass != CONCRETE && targetClass != CONCRETE_BROKEN && targetClass != FIRE){\\\n                    \tsetClass(pNextState, EXPLOSION);\\\n                    }else{\\\n                    \tsetClass(pNextState, FIRE);\\\n                    }\\\n                }\\\n                /* Remove mega bomb. */\\\n                if(pClass == MEGA_BOMB && shouldDetonateMegaBomb(targetClass) && exist(gp(targetCoords + offsets[i]))){\\\n                \tsetClass(pNextState, EXPLOSION);\\\n                    pNextState.xy += -normal*16384. * sqrt(SPEED);\\\n                }\\\n                /* Remove nuke. */\\\n                if(pClass == NUKE && shouldDetonateNuke(targetClass)){\\\n                \tsetClass(pNextState, EXPLOSION);\\\n                    pNextState.xy += -normal*1.e9 * SPEED;\\\n                }\\\n                \\\n                /* Move apart if stuck. */\\\n                if(exist(target) && cellMoveDir == direction){\\\n                    \\\n                    vec2 myNextPos = getPos(pNextState);\\\n                    /* -(Normal (C - (0.5, 0.5))) Normal + C*/\\\n                    myNextPos = -dot(normal, myNextPos-vec2(0.5,0.5)) * normal + myNextPos;\\\n                    pNextState.zw = floor(pNextState.zw) + myNextPos;\\\n                }\\\n                \\\n                /* Heat transfer. */\\\n                /*int tempP = getTemperature(p);*/\\\n                /*int tempPN = getTemperature(pNextState);*/\\\n                /*int tempT = getTemperature(target);*/\\\n                /*int diff = tempP - tempT;*/\\\n                /*int breaker = 0;*/\\\n                /*if(diff < 0){*/\\\n                /*\tbreaker = -1;*/\\\n                /*} else if (diff > 0){*/\\\n                /*\tbreaker = 1;*/\\\n                /*}*/\\\n                /*setTemperature(pNextState, tempPN - diff/8);*/\\\n                \\\n                /* Evaporate water by fire. */\\\n                if(pClass == WATER && targetClass == FIRE && hash(vec2(myCoords.x, myCoords.y + i*11) + vec2(iTime*0.04)) < 0.5){\\\n                    setClass(pNextState, WATER_VAPOR);\\\n                }\\\n                /* Gas force. */\\\n                float repulsor = 0.;\\\n                if(length(pNextState.xy) < 1e2){\\\n                    if(pClass == GAS){\\\n                        repulsor = 4.;\\\n                    }else if(pClass == FIRE){\\\n                        repulsor = 0.2;\\\n                    }else if(pClass == WATER_VAPOR){\\\n                        repulsor = 1.;\\\n                    }else if(pClass == EXPLOSION){\\\n                        repulsor = 4.;\\\n                    }\\\n                }\\\n                \\\n                /* Bomb force. */\\\n                if(targetClass == BOMB && shouldDetonateBomb(pClass) && length(vec2(myCoords) - vec2(tankPos)) > MIN_EXPLODE_DIST_TANK){\\\n                    pNextState.xy += normal*1. * SPEED;\\\n                }\\\n                /* Mega bomb force. */\\\n                /*if(targetClass == MEGA_BOMB && shouldDetonateMegaBomb(pClass)){*/\\\n                    /*pNextState.xy += normal*40.*100.;*/\\\n                /*}*/\\\n                /* Nuke force. */\\\n                /*if(targetClass == NUKE && shouldDetonateNuke(pClass)){*/\\\n                    /*pNextState.xy += normal*1.e8;*/\\\n                /*}*/\\\n                \\\n                /* Explosion force. */\\\n                if(pClass != EXPLOSION && pClass != FIRE && pClass != BOMB && targetClass == EXPLOSION){\\\n                    pNextState.xy += normal*40. * SPEED;\\\n                }\\\n                /* Test. */\\\n                /*if((pClass == CONCRETE || pClass == CONCRETE_BROKEN) && targetClass == GAS){*/\\\n                    /*setClass(pNextState, WATER_VAPOR);*/\\\n                /*}*/\\\n                \\\n                /* Tank evaporate water. */\\\n                if(pClass == WATER && targetClass == TANK){\\\n                    setClass(pNextState, WATER_VAPOR);\\\n                }\\\n                \\\n                /* Tank dig sand. */\\\n                if(pClass == SAND && targetClass == TANK && targetCoords == tankPos && direction == D &&\\\n                   (texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x > 0.5 || texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x > 0.5)){\\\n                    pNextState.y += 1.;\\\n                }\\\n                \\\n                /* Collision impulse.*/\\\n                /* Normal collision.*/\\\n                float collisionDampener = 0.98;\\\n                if(pClass == WATER || targetClass == WATER){\\\n                    collisionDampener = 0.9;\\\n                }else if(pClass == GAS || targetClass == GAS){\\\n                    collisionDampener = 0.9;\\\n                }else if(pClass == WATER_VAPOR || targetClass == WATER_VAPOR){\\\n                    collisionDampener = 0.9;\\\n                }\\\n                vec2 relVel = target.xy*collisionDampener - p.xy; /* Target velocity - this particle velocity.*/\\\n                \\\n                float relVelProj = dot(relVel, normal) + repulsor;\\\n                /*if(relVelProj < 0.){*/\\\n                    /*continue;*/ /* The particles are moving apart.*/\\\n                /*}*/\\\n                float el = 1.; /* 0.5 non-elastic, 1.0 elastic collision.*/\\\n                if(relVelProj > 2.){\\\n                    el = 1.; /* Allow for shock waves. */\\\n                }\\\n                float massA = getMass(p);\\\n                float massB = getMass(target);\\\n                float collisionMass = 1./(1./massA + 1./massB); /* Force / collisionMass = acceleration.*/\\\n                float impulse = collisionMass * relVelProj * el;\\\n                impulse = max(impulse, 0.);\\\n                pNextState.xy += normal * impulse/massA;\\\n                \\\n                /* Tank break. */\\\n                if(pClass == TANK && (impulse > 40. ||\\\n                  targetClass == LAZER)){\\\n                    setClass(pNextState, BROKEN_TANK);\\\n                }\\\n                \\\n                /* Broken tank explode. */\\\n                if(pClass == BROKEN_TANK && (impulse > 20. && hash(vec2(myCoords.x, myCoords.y + i*11) + vec2(iTime*0.04)) < 0.25 ||\\\n                  targetClass == LAZER)){\\\n                    setClass(pNextState, EXPLOSION);\\\n                }\\\n                /* Explode aircraft. */\\\n                if(pClass == AIRCRAFT && (targetClass == BOMB || targetClass != LAZER && impulse > 5.)){\\\n                    setClass(pNextState, EXPLOSION);\\\n                }\\\n                \\\n                /* Fire ignite gass. */\\\n                if(pClass == GAS && targetClass == FIRE){\\\n                    setClass(pNextState, FIRE);\\\n                }\\\n                \\\n                /* Fire put out by water. */\\\n                if(pClass == FIRE && (targetClass == WATER || targetClass == WATER_VAPOR)){\\\n                    destroy(pNextState);\\\n                }\\\n                /*Burn Grass*/\\\n                if(pClass == GRASS && (targetClass == FIRE || targetClass == EXPLOSION) && hash(vec2(myCoords.x, myCoords.y + i*11) + vec2(iTime*0.04)) < 0.2){\\\n                    setClass(pNextState, FIRE);\\\n                }\\\n            }else{\\\n            }\\\n        }else{\\\n            /* Fire spawn from explosion. */\\\n            if(targetClass == EXPLOSION && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.05){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = target.xy;\\\n            }\\\n            /* Fire spawn from energized materials. */\\\n            float energy;\\\n            if(exist(target) &&\\\n                (energy = pow(length(target.xy), 2.) * getMass(target)) > 800. &&\\\n                energy < 100000. &&\\\n                shouldDetonateMegaBomb(targetClass) &&\\\n                dot(normals[i], target.xy) <= 0. &&\\\n                hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.25\\\n                ){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = 0.*-target.xy;\\\n            }\\\n            /* Fire spread. */\\\n            if(targetClass == FIRE && hash(vec2(myCoords) + vec2(iTime*0.05)) < 0.0006){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = target.xy;\\\n            }\\\n            /* Broken tank burn. */\\\n            if(targetClass == BROKEN_TANK && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.05){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = target.xy;\\\n            }\\\n            /*Spawn aircrafts.*/\\\n            bool doAutoSpawn = texelFetch(iChannel0, ivec2(AUTO_SPAWN_AIRCRAFT, 0), 0).x > 0.5;\\\n            if(doAutoSpawn && myCoords == ivec2(iResolution.x*0.5, iResolution.y*0.95) && hash(vec2(myCoords.x, myCoords.y) + vec2(iTime*0.04)) < 6.e-3){\\\n            \tsetClass(pNextState, AIRCRAFT);\\\n            }\\\n        }\\\n    }\\\n    /* Fire bomb from tank. */\\\n    ivec2 tankPosOffset = ivec2(0, -4);\\\n    vec4 tank = texelFetch(iChannel0, myCoords + tankPosOffset, 0);\\\n    if(\\\n        iteration == 0 && getClass(tank) == TANK &&\\\n        tankPos == myCoords + tankPosOffset &&\\\n        texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x > 0.5 /*&&*/\\\n        /*ivec2(texelFetch(iChannel0, ivec2(TIME, 0), 0)).x % 8 == 0*/\\\n    ){\\\n        setClass(pNextState, BOMB);\\\n        float tankShootAngle = texelFetch(iChannel0, ivec2(TANK_SHOOT_ANGLE, 0), 0).x;\\\n        vec2 aimDir = vec2(\\\n            cos(tankShootAngle),\\\n            sin(tankShootAngle)\\\n        );\\\n        pNextState.xy = tank.xy + aimDir*15.;\\\n    }\\\n    \\\n    /* Fire put out by itself. */\\\n    if(pClass == FIRE && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.01){\\\n \t\tdestroy(pNextState);\\\n    }\\\n    /* Explosion put out by itself. */\\\n    if(pClass == EXPLOSION && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.02){\\\n \t\tsetClass(pNextState, FIRE);\\\n    }\\\n    /* Condensate water. */\\\n    if(pClass == WATER_VAPOR && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.0001){\\\n        setClass(pNextState, WATER);\\\n    }\\\n    /* Water force. */\\\n    const float waterForce = 0.1 * SPEED;\\\n    vec4 pD = gp(myCoords + ivec2(0, -1));\\\n    if(length(pNextState.xy) < 1e1){\\\n        if(pClass == WATER && exist(pD) && getClass(pD) == WATER){\\\n            vec4 left = targets[3];\\\n            vec4 right = targets[4];\\\n            if(exist(right) && getClass(right) == WATER){\\\n                if(exist(left) && getClass(left) == WATER){\\\n                    vec4 leftLeft = gp(myCoords + ivec2(-2,0));\\\n                    vec4 rightRight = gp(myCoords + ivec2(2,0));\\\n                    if(exist(rightRight) && getClass(rightRight) == WATER){\\\n                        if(exist(leftLeft) && getClass(leftLeft) == WATER){\\\n                            /* Do nothing.*/\\\n                        }else{\\\n                            pNextState.x -= waterForce;\\\n                        }\\\n                    }else if(exist(leftLeft) && getClass(leftLeft) == WATER){\\\n                        pNextState.x += waterForce;\\\n                    }else{\\\n                        /* Do nothing.*/\\\n                    }\\\n                }else{\\\n                    pNextState.x -= waterForce;\\\n                }\\\n            }else if(exist(left) && getClass(left) == WATER){\\\n                pNextState.x += waterForce;\\\n            } else{\\\n                /* Do nothing.*/\\\n            }\\\n        }\\\n    }\\\n    /*Spawn grass.*/\\\n    vec4 pU = gp(myCoords + ivec2(0, 1));\\\n    int pUClass = getClass(pU);\\\n    vec4 pUU = gp(myCoords + ivec2(0, 2));\\\n    int pUUClass = getClass(pUU);\\\n    if(exist(p) && getClass(p) == WATER && !exist(pU) && exist(pD) && (getClass(pD) == SAND || getClass(pD) == DIRT) && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.5){\\\n        setClass(pNextState, GRASS);\\\n    }\\\n    /*Remove grass.*/\\\n    vec4 pUUU;\\\n    int pUUUClass;\\\n    if(exist(p) && getClass(p) == GRASS &&\\\n        exist(pU) && (pUClass == SAND || pUClass == WATER) &&\\\n        exist(pUU) && (pUUClass == SAND || pUUClass == WATER) &&\\\n        exist((pUUU = gp(myCoords + ivec2(0,3)))) &&\\\n            ((pUUUClass = getClass(pUUU)) == SAND || pUUUClass == WATER) &&\\\n        hash(vec2(myCoords.x+1, myCoords.y) + vec2(iTime*0.04)) < 0.01){\\\n        setClass(pNextState, WATER_VAPOR);\\\n    }\\\n    /* Evaporate water by itself. */\\\n    if(pClass == WATER && pUClass != WATER && pUUClass != WATER && hash(vec2(myCoords.x+1, myCoords.y) + vec2(iTime*0.04)) < 0.0001){\\\n        setClass(pNextState, WATER_VAPOR);\\\n    }\\\n    /* Control enemy aircraft. */\\\n    if(pClass == AIRCRAFT){\\\n        /* Accelerate forward. */\\\n        vec2 dir = vec2(0,1);\\\n        float l = length(pNextState.xy);\\\n        if(l > 0.) dir = pNextState.xy/l;\\\n        pNextState.xy += dir*0.1;\\\n        /* Slow down to speed of 0.5. */\\\n        pNextState.xy /= max(l*2., 1.);\\\n        /*ivec2 toTank = tankPos - myCoords;*/\\\n        vec2 sideways = vec2(-dir.y, dir.x);\\\n        ivec2 frontLeft = ivec2(vec2(myCoords) + dir*100. + sideways*30.);\\\n        ivec2 frontRight = ivec2(vec2(myCoords) + dir*100. - sideways*30.);\\\n        if(\\\n            frontLeft.x > int(iResolution.x) || frontLeft.x < 0 || frontLeft.y > int(iResolution.y) || frontLeft.y < 0 ||\\\n            getClass(gp(frontLeft)) != EMPTY\\\n        ){\\\n            pNextState.xy -= sideways*0.05;\\\n        }else if(\\\n            frontRight.x > int(iResolution.x) || frontRight.x < 0 || frontRight.y > int(iResolution.y) || frontRight.y < 0 ||\\\n            getClass(gp(frontRight)) != EMPTY\\\n        ){\\\n            pNextState.xy += sideways*0.05;\\\n        }else if(tankPos.x != -1){\\\n            vec2 tankDir = vec2(tankPos) - vec2(myCoords);\\\n            if(dot(tankDir, sideways) > 0.){\\\n            \tpNextState.xy += sideways*0.002;\\\n            } else {\\\n            \tpNextState.xy -= sideways*0.002;\\\n            }\\\n        }\\\n    }\\\n    /* Fire lazer/mega bomb from aircraft. */\\\n    ivec2 aircraftPosOffset = ivec2(0, 4);\\\n    vec4 aircraft = texelFetch(iChannel0, myCoords + aircraftPosOffset, 0);\\\n    if(\\\n        tankPos.x != -1 && iteration == 0 && getClass(aircraft) == AIRCRAFT && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.0025 &&\\\n        dot(normalize(vec2(tankPos) - vec2(myCoords+aircraftPosOffset)), normalize(aircraft.xy)) > 0.9\\\n    ){\\\n        if(hash(vec2(myCoords+1) + vec2(iTime*0.04)) < 0.1){\\\n        \tsetClass(pNextState, MEGA_BOMB);\\\n            pNextState.xy = aircraft.xy*64.;\\\n        }else{\\\n        \tsetClass(pNextState, LAZER);\\\n        \tpNextState.xy = aircraft.xy;\\\n        }\\\n    }\\\n    /* Lazer. */\\\n    if(pClass == LAZER){\\\n       \tfloat l = length(pNextState.xy);\\\n        if(l == 0.){\\\n        \tpNextState.xy = normalize(vec2(-1,-1));\\\n            l = 1.;\\\n        }\\\n    \tpNextState.xy = pNextState.xy/l*10.;\\\n        if(hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.001){\\\n        \tdestroy(pNextState);\\\n        }\\\n    }\\\n    /* Particle-ground.*/\\\n    if(myCoords.y == 1 && pNextState.y < 0.){\\\n    \tpNextState.y = -0.5*pNextState.y;\\\n    \tpNextState.x *= 0.99;\\\n    }\\\n    /* Particle-ceiling.*/\\\n    if(myCoords.y == int(iResolution.y)-1 && pNextState.y > 0.){\\\n    \tpNextState.y = -0.5*pNextState.y;\\\n    \tpNextState.x *= 0.99;\\\n    }\\\n    /* Particle-left wall.*/\\\n    if(myCoords.x == 0 && pNextState.x < 0.){\\\n    \tpNextState.x = -0.5*pNextState.x;\\\n    \tpNextState.y *= 0.99;\\\n    }\\\n    /* Particle-right wall.*/\\\n    if(myCoords.x == int(iResolution.x)-1 && pNextState.x > 0.){\\\n    \tpNextState.x = -0.5*pNextState.x;\\\n    \tpNextState.y *= 0.99;\\\n    }\\\n    \\\n    /* Make sticky.*/\\\n\t/*vec2 myNextPos = getPos(pNextState);*/\\\n    /*myNextPos = mix(myNextPos, vec2(0.5,0.5), 0.1);*/\\\n    /*pNextState.zw = floor(pNextState.zw) + myNextPos;*/\\\n    \\\n    /*Concrete force*/\\\n    bool isSupported = false;\\\n    /*Break concrete*/\\\n    if(exist(p) && (pClass == CONCRETE || pClass == CONCRETE_BROKEN)){\\\n        vec4 below   = gp(myCoords + ivec2( 0,-1));\\\n        int belowClass = getClass(below);\\\n        \\\n        vec4 belowR  = gp(myCoords + ivec2( 1,-1));\\\n        int belowRClass = getClass(belowR);\\\n        \\\n        vec4 belowL  = gp(myCoords + ivec2(-1,-1));\\\n        int belowLClass = getClass(belowL);\\\n        \\\n        vec4 right   = gp(myCoords + ivec2( 1, 0));\\\n        int rightClass = getClass(right);\\\n        \\\n        vec4 left    = gp(myCoords + ivec2(-1, 0));\\\n        int leftClass = getClass(left);\\\n        \\\n        vec4 rightRight   = gp(myCoords + ivec2( 2, 0));\\\n        int rightRightClass = getClass(rightRight);\\\n        \\\n        vec4 leftLeft    = gp(myCoords + ivec2(-2, 0));\\\n        int leftLeftClass = getClass(leftLeft);\\\n        \\\n        vec4 rightRightD = gp(myCoords + ivec2( 2,-1));\\\n        int rightRightDClass = getClass(rightRightD);\\\n        \\\n        vec4 leftLeftD = gp(myCoords + ivec2(-2,-1));\\\n        int leftLeftDClass = getClass(leftLeftD);\\\n        \\\n        vec4 rightRightRight   = gp(myCoords + ivec2( 3, 0));\\\n        int rightRightRightClass = getClass(rightRightRight);\\\n        \\\n        vec4 leftLeftLeft    = gp(myCoords + ivec2(-3, 0));\\\n        int leftLeftLeftClass = getClass(leftLeftLeft);\\\n        \\\n        vec4 rightRightRightD = gp(myCoords + ivec2( 3,-1));\\\n        int rightRightRightDClass = getClass(rightRightRightD);\\\n        \\\n        vec4 leftLeftLeftD = gp(myCoords + ivec2(-3,-1));\\\n        int leftLeftLeftDClass = getClass(leftLeftLeftD);\\\n        if(\\\n            myCoords.y <= 1 ||\\\n            belowClass==CONCRETE || belowClass==SAND || belowClass==DIRT ||\\\n            exist(right) && (belowRClass==CONCRETE || belowRClass==SAND || belowRClass==DIRT) ||\\\n            exist(left) && (belowLClass==CONCRETE || belowLClass==SAND || belowLClass==DIRT) ||\\\n            exist(right) && exist(rightRight) && (rightRightDClass==CONCRETE || rightRightDClass==SAND || rightRightDClass==DIRT) ||\\\n            exist(left) && exist(leftLeft) && (leftLeftDClass==CONCRETE || leftLeftDClass==SAND || leftLeftDClass==DIRT) ||\\\n            exist(right) && exist(rightRight) && exist(rightRightRight) && (rightRightRightDClass==CONCRETE || rightRightRightDClass==SAND || rightRightRightDClass==DIRT) ||\\\n            exist(left) && exist(leftLeft) && exist(leftLeftLeft) && (leftLeftLeftDClass==CONCRETE || leftLeftLeftDClass==SAND || leftLeftLeftDClass==DIRT)\\\n        ){\\\n            isSupported = true;\\\n            if(pClass == CONCRETE){\\\n\t\t\t\tpNextState.x *= 0.8;\\\n                pNextState.y *= 0.8;\\\n                vec2 pos = getPos(pNextState);\\\n                pNextState = setPos(pNextState, mix(pos, vec2(0.5,0.5), 0.1));\\\n            }\\\n        }\\\n    }\\\n    if(exist(p) && pClass == CONCRETE && !isSupported){\\\n        setClass(pNextState, CONCRETE_BROKEN);\\\n    }\\\n    if(exist(p) && pClass == CONCRETE_BROKEN && isSupported && hash(vec2(myCoords.x, myCoords.y) + vec2(iTime*0.04)) < 0.005){\\\n        setClass(pNextState, CONCRETE);\\\n    }\\\n    /**/\\\n    float drag = 0.995;\\\n    /* Gravity.*/\\\n    if(true || !exist(pD)){\\\n        float gravity = -0.01;\\\n        if(isSupported){\\\n            gravity = 0.;\\\n        }else if(pClass == WATER_VAPOR){\\\n        \tgravity *= -1.;\\\n        }else if(pClass == FIRE){\\\n            gravity *= -1.;\\\n            drag = 0.99;\\\n        }else if(pClass == EXPLOSION){\\\n            gravity *= -100.;\\\n        }else if(pClass == AIRCRAFT){\\\n            gravity *= 0.;\\\n        }else if(pClass == LAZER){\\\n            gravity *= 0.;\\\n        }\\\n    \tpNextState.y += gravity * SPEED;\\\n        /*vec2 rad = vec2((myCoords - ivec2(iResolution*0.5)));*/\\\n        /*float l = length(rad);*/\\\n        /*pNextState.xy += -rad*10.0/(l*l*l+10.);*/\\\n    }\\\n    \\\n    /* Drag.*/\\\n    pNextState.xy *= pow(drag, SPEED);\\\n    \\\n    return pNextState;\\\n}\n# define SWAP_ABOVE_AND_CALC_IMPULSES \\\nvec4 swapAboveAndCalcImpulses(ivec2 myCoords, int iteration){\\\n    vec4 p = gp(myCoords);\\\n    ivec2 offset=ivec2(0,0);\\\n\t\\\n    if(exist(p) && getClass(p) != CONCRETE){\\\n        vec4 pU = gp(myCoords + ivec2(0, 1));\\\n        float pPriority = getPriority(p);\\\n        if(exist(pU) && getClass(pU) != CONCRETE){\\\n            float puPriority = getPriority(pU);\\\n            if(pPriority < puPriority){\\\n                vec4 pUU = gp(myCoords + ivec2(0, 2));\\\n                if(exist(pUU) && puPriority < getPriority(pUU) && getClass(pUU) != CONCRETE){\\\n                    /* Do nothing.*/\\\n                } else{\\\n                    /* Swap with above.*/\\\n                    offset= ivec2(0, 1);\\\n                }\\\n            }else{\\\n                /* Swap with below.*/\\\n                vec4 pD = gp(myCoords + ivec2(0, -1));\\\n                if(exist(pD) && getPriority(pD) < pPriority && getClass(pD) != CONCRETE){\\\n                    offset=  ivec2(0, -1);\\\n                }\\\n            }\\\n        }else{\\\n            /* Swap with below.*/\\\n            vec4 pD = gp(myCoords + ivec2(0, -1));\\\n            if(exist(pD) && getPriority(pD) < pPriority && getClass(pD) != CONCRETE){\\\n                 offset=  ivec2(0, -1);\\\n            } \\\n        }\\\n    }\\\n        /* Do nothing.*/\\\n    return calcImpulses(myCoords+offset, iteration);\\\n}\n# define TRACK_TANK \\\nivec2 trackTank(ivec2 tankCoords){\\\n\t/* Track tank. */\\\n    vec4 pC, pU, pUR, pUL, pR, pL, pDR, pDL, pD;\\\n    if(exist(pC = gp(tankCoords + ivec2( 0, 0))) && getClass(pC) == TANK){\\\n        return tankCoords + ivec2( 0, 0);\\\n    }else if(exist(pU = gp(tankCoords + ivec2( 0, 1))) && getClass(pU) == TANK){\\\n        return tankCoords + ivec2( 0, 1);\\\n    }else if(exist(pUR = gp(tankCoords + ivec2( 1, 1))) && getClass(pUR) == TANK){\\\n        return tankCoords + ivec2( 1, 1);\\\n    }else if(exist(pUL = gp(tankCoords + ivec2(-1, 1))) && getClass(pUL) == TANK){\\\n        return tankCoords + ivec2(-1, 1);\\\n    }else if(exist(pR = gp(tankCoords + ivec2( 1, 0))) && getClass(pR) == TANK){\\\n        return tankCoords + ivec2( 1, 0);\\\n    }else if(exist(pL = gp(tankCoords + ivec2(-1, 0))) && getClass(pL) == TANK){\\\n        return tankCoords + ivec2(-1, 0);\\\n    }else if(exist(pDR = gp(tankCoords + ivec2( 1,-1))) && getClass(pDR) == TANK){\\\n        return tankCoords + ivec2( 1,-1);\\\n    }else if(exist(pDL = gp(tankCoords + ivec2(-1,-1))) && getClass(pDL) == TANK){\\\n        return tankCoords + ivec2(-1,-1);\\\n    }else if(exist(pD = gp(tankCoords + ivec2( 0,-1))) && getClass(pD) == TANK){\\\n        return tankCoords + ivec2( 0,-1);\\\n    } else {\\\n        return ivec2(-1);\\\n    }\\\n}\\\n\nbool exist(vec4 p){\n\treturn p.z >= 1.;\n}\n\nvoid destroy(inout vec4 p){\n\tp.z = 0.;\n}\n\nvec2 getPos(vec4 p){\n\treturn mod(p.zw, 1.);\n}\n\nvec4 setPos(vec4 p, vec2 newPos){\n\treturn vec4(p.xy, floor(p.zw) + newPos);\n}\n\nint getClass(vec4 p){\n\treturn int(p.z)-1;\n}\n\nvoid setClass(inout vec4 p, int cl){\n\tp.z = mod(p.z, 1.) + float(cl+1);\n}\n\n/*int getTemperature(vec4 p){\n\treturn int(floor(p.w));\n}*/\n\n/*void setTemperature(inout vec4 p, int temp){\n\tp.w = mod(p.w, 1.) + float(temp);\n}*/\nconst float MASSES[17] = float[](\n    2.55, // Sand.\n    1.00, // Water.\n    0.01, // Gass.\n    0.01, // Fire.\n    0.01, // Water vapor.\n    9.00, // Bomb.\n   90.00, // TANK.\n    1.00, // Explosion.\n   90.00, // Broken tank.\n    2.55, // Aircraft.\n    3.00, // Lazer.\n10000.00, // Mega bomb.\n    1.50, // Dirt.\n   15.00, // Concrete.\n   15.00, // Concrete broken.\n    2.55, // Nuke.\n    1.00  // Grass.\n);\nfloat getMass(vec4 p){\n\treturn MASSES[getClass(p)];\n}\nconst float PRIORITIES[17] = float[](\n    2.,  // Sand.\n    1.,  // Water.\n    0.,  // Gass.\n    0.,  // Fire.\n    0.,  // Water vapor.\n    2.,  // Bomb.\n    2.,  // TANK.\n    0.,  // EXPLOSION.\n    2.,  // Broken tank.\n    2.,  // Aircraft.\n    2.,  // Lazer.\n    2.,  // Mega bomb.\n    2.,  // Dirt.\n    2.,  // Concrete.\n    2.,  // Concrete broken.\n    2.,  // Nuke.\n    2.   // Grass.\n);\nfloat getPriority(vec4 p){\n\treturn PRIORITIES[getClass(p)];\n}\n\nvec2 limSize(vec2 v){\n\tfloat l = dot(v,v);\n    if(l > 1.){\n    \tv /= sqrt(l);\n    }\n    return v;\n}\n\n# define C 0\n# define U 1\n# define D 2\n# define R 3\n# define L 4\n# define UR 5\n# define UL 6\n# define DR 7\n# define DL 8\n// Given the velocity of the particle, what other cell is it trying to reach?\nint particleCellDir(vec4 p){\n    vec2 pos = getPos(p);\n    vec2 nextPos = pos + limSize(p.xy);\n    if(nextPos.x >= 1.){\n    \t// Right.\n        if(nextPos.y >= 1.){\n        \t// Up.\n            return UR;\n        } else if(nextPos.y < 0.) {\n        \t// Down.\n            return DR;\n        } else {\n        \t// Vertical center.\n            return R;\n        }\n    } else if(nextPos.x < 0.){\n    \t// Left.\n        if(nextPos.y >= 1.){\n        \t// Up.\n            return UL;\n        } else if(nextPos.y < 0.) {\n        \t// Down.\n            return DL;\n        } else {\n        \t// Vertical center.\n            return L;\n        }\n    } else {\n        // Horizontal center.\n    \tif(nextPos.y >= 1.){\n        \t// Up.\n            return U;\n        } else if(nextPos.y < 0.) {\n        \t// Down.\n            /*if(getClass(p) == WATER){\n                if(p.x > 0.){\n                \treturn DR;\n                }else{\n                \treturn DL;\n                }\n            }*/\n            return D;\n        } else {\n        \t// Vertical center.\n            if(getClass(p) == WATER){\n                if(p.x > 0.){\n                \treturn R;\n                }else{\n                \treturn L;\n                }\n            }\n            return C;\n        }\n    }\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n/*\nbool getKeyToggle(int key){\\\n\treturn texelFetch( iChannel1, ivec2(key,2), 0 ).x > 0.5;\\\n}\\\nbool getKeyDown(int key){\\\n\treturn texelFetch( iChannel1, ivec2(key,0), 0 ).x > 0.5;\\\n}\\\nbool getKeyClick(int key){\\\n\treturn texelFetch( iChannel1, ivec2(key,1), 0 ).x > 0.5;\\\n}\\\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Particle.\n// p.xy = velocity right and up.\n// mod(p.zw, 1.) = position inside cell from left bottom.\n// floor(z) = class. 0 = empty, 1=sand.\n// floor(w) = temperature (celsius).\n\n// A particle can only move into an empty cell.\n// DL down left, D down center, DR down right, L center left, R center right, UL up left, U up center,  UR up right.\n// If there are multiple particles trying to move to the same cell, the order of prioritazion is U, UR, UL, R, L, DR, DL, D.\nGP\nGET_INCOMING\nMOVE_PARTICLE\n//SHOULD_DETONATE_BOMB\n//SHOULD_DETONATE_MEGA_BOMB\n//SHOULD_DETONATE_NUKE\n//CALC_IMPULSES\n//SWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nbool house(in vec2 fragCoord, in vec2 pos){\n    float d = length(fragCoord.xy - 0.5 - pos);\n    ivec2 diff = ivec2(fragCoord.xy - pos);\n    float rr = 3.;\n    if(\n    diff.x < 30 && diff.x > -30 && diff.y < 10 && diff.y > 0 ||\n    sdSegment( vec2(diff), vec2(-35, -7), vec2(1, 5)) < rr+1. ||\n    sdSegment( vec2(diff), vec2(35, -7), vec2(-1, 5)) < rr+1. ||\n    diff.x <= -30 && diff.x > -39 && diff.y < 79 && diff.y > -int(rr)-2 ||\n    diff.x >= 30 && diff.x < 39 && diff.y < 79 && diff.y > -int(rr)-2 ||\n    sdSegment( vec2(diff), vec2(-36, 36), vec2(0, 48)) < rr ||\n    sdSegment( vec2(diff), vec2(36, 36), vec2(0, 48)) < rr ||\n    sdSegment( vec2(diff), vec2(-36, 76), vec2(0, 88)) < rr ||\n    sdSegment( vec2(diff), vec2(36, 76), vec2(0, 88)) < rr ||\n    sdSegment( vec2(diff), vec2(0, 4), vec2(0, 88)) < rr\n\n    ){\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    bool mouseDown = iMouse.z > 0.;\n    bool clickedMenu = mouseDown && iMouse.y >= iResolution.y - MENU_HEIGHT && iResolution.x - iMouse.x < MENU_WIDTH * MENU_NUM_BUTTONS;\n    float mouseTimeDown = texelFetch(iChannel0, ivec2(MOUSE_TIME_DOWN, 0), 0).x;\n    int selector = int(texelFetch(iChannel0, ivec2(SELECTOR,0), 0 ).x);\n    if(myCoords.y > 0){\n    \n    \tvec4 p = gp(myCoords);\n        ivec2 targetCoords;\n        vec4 pNextState = moveParticle(/*vec4 p=*/p, /*ivec2 myCoords=*/ivec2(fragCoord), /*out ivec2 targetCoords*/targetCoords);\n\n        // Input.\n        bool keyJ = texelFetch(iChannel1, ivec2(KEY_J, 0), 0).x > 0.5;\n        bool keyK = texelFetch(iChannel1, ivec2(KEY_K, 0), 0).x > 0.5;\n        float hBoost = 300.*(float(keyK)-float(keyJ));\n        float vBoost = 100.*(-float(keyK)-float(keyJ));\n        // Draw.\n        if(selector == 0){ // Eraser.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 0.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 1){ // Sand.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 1.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 2){ // Water.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 2.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 3){ // Gas.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 3.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 4){ // Fire.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 4.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 5){ // Water vapor.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 5.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 6){ // Bomb.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 1.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 6.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 7){ // Tank.\n            if(mouseDown && !clickedMenu && mouseTimeDown < 0.){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 7.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 8){ // Explosion.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 8.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 9){ // Broken tank.\n            if(mouseDown && !clickedMenu && mouseTimeDown < 0.){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 9.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 10){ // Enemy.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 10.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 11){ // Lazer.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 11.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 12){ // Mega bomb.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 1.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 12.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 13){ // Dirt.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 5.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 13.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 14){ // Concrete.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 5.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 14.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 15){ // Concrete broken.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 5.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 15.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 16){ // Nuke.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 1.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 16.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 17){ // House.\n            if(mouseDown && !clickedMenu){\n                if(house(fragCoord, iMouse.xy)){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 14.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 18){ // Grass.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 2.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 17.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        }\n        // Control tank.\n        vec2 tankPos = texelFetch(iChannel0, ivec2(TANK_POSITION, 0), 0).xy;\n        const float tankAcceleration = 0.15;\n        const float tankMaxVel = 0.3;\n        if(exist(pNextState) && getClass(pNextState) == TANK && targetCoords == ivec2(tankPos)){\n            vec4 pD = gp(ivec2(tankPos) + ivec2(0, -1));\n            vec4 pDD = gp(myCoords + ivec2(0, -2));\n            vec4 pL = gp(ivec2(tankPos) + ivec2(-1, 0));\n            vec4 pR = gp(ivec2(tankPos) + ivec2(1, 0));\n            vec4 pU = gp(ivec2(tankPos) + ivec2(0, 1));\n            bool keyD = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x > 0.5;\n            bool keyA = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x > 0.5;\n            if(exist(pD)/* || exist(pDD)*/ || exist(pR) || exist(pL)){\n                if(keyD){\n                    pNextState.x += clamp(max(tankMaxVel - pNextState.x, 0.), -tankAcceleration, tankAcceleration);\n                    if(exist(pR)){\n                        pNextState.y += clamp(max(tankMaxVel - pNextState.y, 0.), -tankAcceleration, tankAcceleration);\n                    }\n                } else if(keyA){\n                    pNextState.x -= clamp(max(tankMaxVel + pNextState.x, 0.), -tankAcceleration, tankAcceleration);\n                    if(exist(pL)){\n                        pNextState.y += clamp(max(tankMaxVel - pNextState.y, 0.), -tankAcceleration, tankAcceleration);\n                    }\n                } else{\n                    if(exist(pDD)){\n                \t\tpNextState.x += clamp(-pNextState.x, -0.04, 0.04);\n                    }\n                }\n                if(exist(pDD)){\n                \tpNextState.y = max(pNextState.y, 0.);\n                }\n            }\n        }\n\t\t\n        // Initiate world.\n        if(iTime < 0.1){\n            pNextState.x = 0.1;\n            pNextState.y = 1.1;\n            pNextState.z = 0.5;\n            pNextState.w = 0.5;\n        }\n        \n        // Spawn buildings.\n        if(texelFetch(iChannel1, ivec2(KEY_E, 1), 0).x > 0.5){\n            pNextState.x = 0.0;\n            pNextState.y = 0.0;\n            pNextState.z = 0.5;\n            pNextState.w = 0.5;\n            if(myCoords.y < 50){\n                setClass(pNextState, SAND);\n            }else if(myCoords.y < 70){\n                setClass(pNextState, DIRT);\n            }else if(myCoords.y < 73){\n                setClass(pNextState, GRASS);\n            }\n            const int offsetsSize = 12;\n            float diff = 100.0/iResolution.x;\n            vec2 offsets[offsetsSize] = vec2[](\n                vec2(iResolution.x * (0.1 + diff*0.),80),\n                vec2(iResolution.x * (0.1 + diff*0.),80+82),\n                vec2(iResolution.x * (0.1 + diff*0.),80+82*2),\n                vec2(iResolution.x * (0.1 + diff*0.),80+82*3),\n                vec2(iResolution.x * (0.1 + diff*1.),80),\n                vec2(iResolution.x * (0.1 + diff*2.),80),\n                vec2(iResolution.x * (0.1 + diff*2.),80+82),\n                vec2(iResolution.x * (0.1 + diff*2.),80+82*2),\n                vec2(iResolution.x * (0.1 + diff*3.),80),\n                vec2(iResolution.x * (0.1 + diff*3.),80+82),\n                vec2(iResolution.x * (0.1 + diff*4.),80),\n                vec2(iResolution.x * (0.1 + diff*6.),80)\n            );\n            for(int i=0; i<offsetsSize; i++){\n                if(house(fragCoord, offsets[i])){\n                    pNextState.x = 0.;\n                    pNextState.y = 0.;\n                    pNextState.z = 14.5;\n                    pNextState.w = 0.5;\n                }\n            }\n            if(myCoords.y > 420 && myCoords.y < 425){\n                setClass(pNextState, WATER_VAPOR);\n            }\n        }\n        \n    \tfragColor = pNextState;\n    } else {\n        vec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        \n        // Game logic.\n        if(myCoords == ivec2(SELECTOR, 0)){\n            if(\n                mouseDown && iMouse.y >= iResolution.y - MENU_HEIGHT &&\n                iResolution.x - iMouse.x < MENU_WIDTH * MENU_NUM_BUTTONS && mouseTimeDown < 0.\n            ){\n                pNextState.x = min(floor((iResolution.x - iMouse.x) / MENU_WIDTH), MENU_NUM_BUTTONS-1.);\n            }\n            if(iTime < 0.1){\n            \tpNextState.x = 1.;\n            }\n        }else if(myCoords == ivec2(MOUSE_TIME_DOWN, 0)){\n            if(mouseDown){\n            \tpNextState.x += 1.;\n            }else{\n            \tpNextState.x = -1.;\n            }\n        }else if(myCoords == ivec2(TANK_POSITION, 0)){\n            if(mouseDown && !clickedMenu && mouseTimeDown < 0. && selector == 7){\n            \tpNextState.xy = iMouse.xy;\n            } else {\n            \t// Track tank.\n                pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n            }\n        }else if(myCoords == ivec2(TANK_SHOOT_ANGLE, 0)){\n            bool keyRight = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5;\n            bool keyLeft = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5;\n            if(keyLeft){\n            \tpNextState.x = mod(pNextState.x+0.02, 2.*PI);\n            }else if(keyRight){\n            \tpNextState.x = mod(pNextState.x-0.02, 2.*PI);\n            }\n        }else if(myCoords == ivec2(TIME, 0)){\n            pNextState.x += 1.;\n        }else if(myCoords == ivec2(AUTO_SPAWN_AIRCRAFT, 0)){\n            bool keyQ = texelFetch(iChannel1, ivec2(KEY_Q, 1), 0).x > 0.5;\n            if(keyQ){\n            \tpNextState.x = pNextState.x > 0.5? 0.: 1.;\n            }\n        }\n    \tfragColor = pNextState;\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nGP\n//GET_INCOMING\n//MOVE_PARTICLE\nSHOULD_DETONATE_BOMB\nSHOULD_DETONATE_MEGA_BOMB\nSHOULD_DETONATE_NUKE\nCALC_IMPULSES\nSWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    if(myCoords.y > 0){\n        vec4 p = gp(myCoords);\n        vec4 pNextState = swapAboveAndCalcImpulses(myCoords, 0);\n\n        fragColor = pNextState;\n    } else {\n    \tvec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        if(myCoords == ivec2(TANK_POSITION, 0)){\n            // Track tank.\n            pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n        }\n    \tfragColor = pNextState;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nGP\nGET_INCOMING\nMOVE_PARTICLE\n//SHOULD_DETONATE_BOMB\n//SHOULD_DETONATE_MEGA_BOMB\n//SHOULD_DETONATE_NUKE\n//CALC_IMPULSES\n//SWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    if(myCoords.y > 0){\n    \n    \tvec4 p = gp(myCoords);\n        ivec2 targetCoords;\n        vec4 pNextState = moveParticle(/*vec4 p=*/p, /*ivec2 myCoords=*/ivec2(fragCoord), /*out ivec2 targetCoords*/targetCoords);\n\n    \tfragColor = pNextState;\n    } else {\n        vec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        if(myCoords == ivec2(TANK_POSITION, 0)){\n            // Track tank.\n            pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n        }\n    \tfragColor = pNextState;\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nGP\n//GET_INCOMING\n//MOVE_PARTICLE\nSHOULD_DETONATE_BOMB\nSHOULD_DETONATE_MEGA_BOMB\nSHOULD_DETONATE_NUKE\nCALC_IMPULSES\nSWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    if(myCoords.y > 0){\n        vec4 p = gp(myCoords);\n        vec4 pNextState = swapAboveAndCalcImpulses(myCoords, 1);\n\n        fragColor = pNextState;\n    } else {\n    \tvec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        if(myCoords == ivec2(TANK_POSITION, 0)){\n            // Track tank.\n            pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n        }\n    \tfragColor = pNextState;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}