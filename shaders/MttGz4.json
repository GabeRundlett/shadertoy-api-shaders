{
    "Shader": {
        "info": {
            "date": "1468711886",
            "description": "Thrust SSC (SuperSonic Car)\nhttps://en.wikipedia.org/wiki/ThrustSSC\nFirst car to officially break the sound barrier.\n\nYoutube video here: https://www.youtube.com/watch?v=hliTD0YGq1Q",
            "flags": 41,
            "hasliked": 0,
            "id": "MttGz4",
            "likes": 114,
            "name": "[SH16B] Mach 1",
            "published": 3,
            "tags": [
                "speed"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 10289
        },
        "renderpass": [
            {
                "code": "\n///////////////////////////\n// PostFX\n///////////////////////////\n\nvec3 PostFX_ApplyVignetting( const in vec2 vUV, const in vec3 vInput, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tfloat fShade = mix( 1.0, 1.0 - fStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 PostFX_ApplyTonemap( const in vec3 vLinear, float fExposure )\n{\n\treturn 1.0 - exp2( vLinear * -fExposure );\t\n}\n\nvec3 PostFX_ApplyGamma( const in vec3 vLinear, float fGamma )\n{\n\treturn pow( vLinear, vec3(1.0/fGamma) );\t\n}\n\nvec3 PostFX_Apply( vec3 vColor, vec2 vUV, float fExposure, float fVignetteStrength, float fGamma )\n{\n    vColor = PostFX_ApplyVignetting( vUV, vColor, fVignetteStrength );\n    vColor = PostFX_ApplyTonemap( vColor, fExposure );\n    vColor = PostFX_ApplyGamma( vColor, fGamma );\n    return vColor;\n}\n\n///////////////////////////////////////////////\n\n///////////////////////////////////////////////\nfloat Blueprint_Grid( vec2 vGridUV, float fSpacing )\n{   \n    vec2 vScaledUV = vGridUV * fSpacing;\n    \n    vec2 vGridLinePos = fract( vScaledUV - 0.5 ) - 0.5;\n    \n    vec2 vToLine = abs(vGridLinePos) / fSpacing;\n    \n    float fAmount = min( vToLine.x, vToLine.y );\n    \n    fAmount = 1.0 - fAmount * 400.0;\n    \n    return clamp( fAmount, 0.0, 1.0);\n}\n\nfloat Blueprint_SampleDepth( vec2 vUV )\n{\n    return min( textureLod( iChannel0, vUV, 0.0 ).a, 10.0 );\n}\n\nvec3 Blueprint( const vec2 vUV )\n{\n    vec3 vColor = vec3(1.0);\n    \n    vec2 vPixelSize = 1.0 / iResolution.xy;\n    vec3 vDelta = vec3( -1.0, 0.0, 1.0 );\n    \n\tfloat fSample_tl = Blueprint_SampleDepth( vUV + vDelta.xx * vPixelSize );\n\tfloat fSample_tc = Blueprint_SampleDepth( vUV + vDelta.xy * vPixelSize );\n\tfloat fSample_tr = Blueprint_SampleDepth( vUV + vDelta.xz * vPixelSize );\n    \n\tfloat fSample_cl = Blueprint_SampleDepth( vUV + vDelta.yx * vPixelSize );\n\tfloat fSample_cc = Blueprint_SampleDepth( vUV + vDelta.yy * vPixelSize );\n\tfloat fSample_cr = Blueprint_SampleDepth( vUV + vDelta.yz * vPixelSize );\n\n    float fSample_bl = Blueprint_SampleDepth( vUV + vDelta.zx * vPixelSize );\n\tfloat fSample_bc = Blueprint_SampleDepth( vUV + vDelta.zy * vPixelSize );\n\tfloat fSample_br = Blueprint_SampleDepth( vUV + vDelta.zz * vPixelSize );\n    \n    vec2 edge;\n    edge.x = fSample_tl * -1.0 + fSample_tr * 1.0\n    \t \t + fSample_cl * -2.0 + fSample_cr * 2.0\n        \t + fSample_bl * -1.0 + fSample_br * 1.0;\n    \n    edge.y = fSample_tl * -1.0 + fSample_tc * -2.0 + fSample_tr * -1.0\n        \t + fSample_bl *  1.0 + fSample_bc * 2.0 + fSample_br * 1.0;\n    \n    float amount = clamp( (sqrt(length(edge))- 1.5) * 2.0 , 0.0, 1.0);\n\n    vec2 vGridUV = vUV;\n    vGridUV.x *= iResolution.x / iResolution.y;\n    amount += Blueprint_Grid(vGridUV, 8.0) * 0.2;\n    amount += Blueprint_Grid(vGridUV, 16.0) * 0.05;\n    amount += Blueprint_Grid(vGridUV, 80.0) * 0.05;\n    \n    vColor = mix( vec3(0.1,0.1,.25), vec3(.9,1,1), amount );\n    \n    return vColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 gBloomSize = min( vec2(320.0, 240.0), iChannelResolution[1].xy );\n    \n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n    // Show environment map\n\t//fragColor = texture( iChannel3, vUV ).rgba; return;    \n    \n    // Show raw scene render\n\t//fragColor = texture( iChannel0, vUV ).rgba; return;    \n    \n    // Show bloom buffer\n    //fragColor = texture( iChannel1, vUV ).rgba; return;    \n    \n\tvec4 vImageSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\tvec4 vBloomSample = textureLod( iChannel1, vUV * gBloomSize / iResolution.xy, 0.0 ).rgba;\n\n    const float fBloomAmount = 0.2;\n    \n    vec3 vResult = mix( vImageSample.rgb, vBloomSample.rgb, fBloomAmount );\n    \n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * 0.6) * gBloomSize / iResolution.xy, 0.0 ).rgb * 0.00015 * vec3(1,1,0);\n    \n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * -0.5) * gBloomSize / iResolution.xy, 0.0 ).rgb * 0.0015 * vec3(1,0,0);\n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * -0.525) * gBloomSize / iResolution.xy, 0.0 ).rgb * 0.0015 * vec3(0,1,0);\n    vResult += textureLod( iChannel1, (0.5 + (vUV - 0.5) * -0.55) * gBloomSize / iResolution.xy, 0.0 ).rgb * 0.0015 * vec3(0,0,1);\n\n    float fExposure = 3.0;\n    \n    float fBlend = clamp( (iTime - 64.0) * 0.1 , 0.0, 1.0 );\n    if ( iTime > 78.0 )\n    {\n        fBlend = 0.0;\n    }\n    fExposure *= 1.0 - fBlend;\n\n    vec3 vFinal = PostFX_Apply( vResult.rgb, vUV, fExposure, 0.9, 1.2 );   \n    \n    vec3 vBlueprintScene = vec3(0);\n    \n    {\n        vec2 vSceneUV = vUV; \n\n        vSceneUV -= 0.5;\n\t\tvSceneUV.x *= iResolution.x / iResolution.y;\n\n        vSceneUV *= 1.2;\n        float p = 0.1;\n        vSceneUV *= mat2( cos(p), sin(p), -sin(p), cos(p) );\n        \n        vSceneUV *= (0.3 + exp2( iTime) * 0.03) ;\n        \n        vSceneUV += 0.5;\n        \n        vec2 vPageUV = vSceneUV;        \n        //float t = 0.1;\n        //vPageUV -= 0.5;\n        //vPageUV *= mat2( cos(t), sin(t), -sin(t), cos(t) );\n        //vPageUV += 0.5;\n        //vPageUV.x += sin(iTime);\n\n        vPageUV -= 0.5;\n\t\tvPageUV.x /= iResolution.x / iResolution.y;\n        vPageUV += 0.5;        \n        \n        if ( any( greaterThan( vPageUV, vec2(1))) || any( lessThanEqual( vPageUV, vec2(0))) )\n        {\n            vBlueprintScene.rgb = textureLod( iChannel2, vSceneUV, 0.0 ).rgb;\n            vBlueprintScene.rgb *= textureLod( iChannel2, vSceneUV * 0.01, 0.0 ).rgb;\n            vBlueprintScene.rgb = sqrt( vBlueprintScene.rgb );\n            \n            vec2 vShadowPos = vPageUV + vec2(-0.001, 0.05);\n            vec2 vClosest = clamp( vShadowPos, vec2(0), vec2(1) );\n            float fDist = length( vClosest - vShadowPos );\n            vBlueprintScene.rgb *= clamp( fDist * 30.0, 0.0, 1.0) * 0.5 + 0.5;\n        }\n        else\n        {\n            vBlueprintScene = Blueprint( vPageUV );\n        }\n    }\n\n    float fBlueprint = step(iTime, 8.0);//step( 0.5, fract( (vUV.x + vUV.y * .5) * 0.1 + iTime ) ) ;\n    vFinal.rgb = mix( vFinal, vBlueprintScene, fBlueprint);\n\n    // Draw depth\n    //vFinal = vec3( 1.0 - exp2( abs(vImageSample.a) * -0.02 ) ); \n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Scene Render\n\n// This buffer was used like an environment map before shadertoy added cubemap support\n#if 0\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10.0\n\n#define PI 3.141592654\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    cam.vPos = LoadVec3( sampler, addr + ivec2(0,0) );\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + vec2(0,0), cam.vPos, fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y / iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n///////////////////////////\n// Scene\n///////////////////////////\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n    float mint = 0.02, tmax = 2.5;\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n///////////////////////////\n// Lighting\n///////////////////////////\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n///////////////////////////\n// Rendering\n///////////////////////////\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n    vec3 vRayOrigin = vInRayOrigin;\n    vec3 vRayDir = vInRayDir;\n    \n\tvec3 vResultColor = vec3(0.0);\n\tvec3 vPassContribution = vec3(1.0);\n            \n\tSceneResult firstTraceResult;\n    \n\tfor( int iPassIndex=0; iPassIndex<3; iPassIndex++ )\n\t{\t        \n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, kMaxTraceDist );\n        \n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n\t\tvec3 vPassColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.fObjectId < 0.0 )\n\t\t{\n            break; \n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -vRayDir), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvPassColor = \n                mix( surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive, surfaceLighting.vSpecular, vReflectance );\n        \n\t        vPassColor = Env_ApplyAtmosphere( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\t\t\n            \n            // Reflect Ray\n            vRayOrigin = surfaceInfo.vPos;\n            vRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n        }\n                \n\t\tvResultColor += vPassColor * vPassContribution;\n\t\tvPassContribution *= vReflectance;\t\t\t        \n    }\n    \n    vec4 vFinalSkyColor = Env_GetSkyColor( vRayOrigin, vRayDir );\n    vFinalSkyColor.rgb = Env_ApplyAtmosphere( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\t\t\n\tvResultColor += vFinalSkyColor.rgb * vPassContribution;\n    \n    vResultColor = FX_Apply( vResultColor, vInRayOrigin, vInRayDir, firstTraceResult.fDist );\n    \n    if ( firstTraceResult.fObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n    \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////\n// Utility Functions\n///////////////////////////\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<4; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n\n/////////////////////////\n// Scene Description\n/////////////////////////\n\n// Materials\n\n#define MAT_SKY \t\t-1.0\n#define MAT_MOUNTAIN \t0.0\n#define MAT_SAND \t\t2.0\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0); //fract( surfaceInfo.vPos + 0.1 );\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 0.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    surfaceInfo.vR0 = vec3( 0.01 );\n    vec3 vSand = texture( iChannel2, surfaceInfo.vPos.xz * 0.01).rgb;\n    vSand = vSand * vSand;\n    vec3 vMountain = texture( iChannel1, surfaceInfo.vPos.xz * 0.01).rgb;\n    vMountain = vMountain * vMountain;\n    \n    surfaceInfo.vAlbedo = mix(vSand, vMountain, clamp( surfaceInfo.vPos.y * 0.2, 0.0, 1.0) ); \n    \n    //surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vec3(1,1,1), clamp( (surfaceInfo.vPos.y - 55.0) * 0.2, 0.0, 1.0) ); \n            \n    \n    return surfaceInfo;\n}\n\n// Scene Description\n\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n\n    float fMountainDist = 50.0 - length(vPos.xz);\n    float fAngle = atan( vPos.x, vPos.z );\n    fMountainDist = max( fMountainDist, vPos.y - 10.0 + sin( fAngle * 50.0 ) * 5.0);\n    \n//    result = Scene_Union( result, SceneResult( fMountainDist, MAT_MOUNTAIN, vec3(0.0) ) );\n    //result = Scene_Subtract( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    //result = Scene_Intersection( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \n\t//float fHeight = 0.0;//1.0 - texture( iChannel1, vPos.xz * 0.1 - vec2(0, iTime) ).r;\n    \n    float fHeight = FBM_DXY( vPos.xz * 0.005, vec2(0.0), 0.8, -0.1).z;\n    fHeight = fHeight* fHeight * fHeight * fHeight;\n    fHeight = fHeight * 200.0;\n    fHeight = fHeight * (1.0 - exp2( length( vPos.xz ) * -0.003 ) );\n    \n    result = Scene_Union( result, SceneResult( vPos.y - fHeight, MAT_SAND, vec3(0.0) ) );\n                                              \n/*    float l = length( vPos.xz );\n    result = Scene_Union( result, SceneResult( vPos.y - 2.0 + exp(-l * 0.1) * 4.0, MAT_SAND, vec3(0.0) ) );\n    result = Scene_Union( result, SceneResult( vPos.y \n//                                              + sin(iTime + vPos.x * 8.0) * 0.02\n//                                              + sin(iTime * 2.0 + vPos.z * 8.0) * 0.02\n//                                              + sin(iTime * 3.0 + vPos.x * 10.0) * 0.01\n//                                              + sin(iTime * 4.0 + vPos.z * 10.0) * 0.01\n                                              , MAT_WATER, vec3(0.0) ) );*/\n        \n    return result;\n}\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, -0.8));\nvec3 g_vSunColor = vec3(1, 0.5, 0.25) * 5.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    //Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(-2.0, 5.0, 0.0), vec3( 0.5, 1, 0.5 ) );\n    \n    float fAO = 1.0;//Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * vec3(0.5, 1, 1);\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4(0.0);\n\t\n    vResult.rgb = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n\n\n    // Cloud\n    float fCloud = texture( iChannel3, vViewDir.xz * 0.01 / vViewDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult.rgb = mix( vResult.rgb, vec3(8.0), fCloud );\n    \n    \n    // Sun\n    //float NdotV = dot( g_vSunDir, vViewDir );\n    //vResult += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 2000.0;\n    \n    vResult.w = kFarDist;\n    \n\treturn vResult;\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n    return vColor;\n    /*\n\tfloat fFogFactor = Env_GetFogFactor( fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\n\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor);\n    \n    return mix( vFogColor, vColor, fFogFactor );\t    \n\t*/\n}\n\n// FX\n\nvec4 FX_ColDensity( vec3 vPos )\n{\n    float density = 0.0;\n    if (length( vPos ) < 5.0 )\n        density = 0.02;\n    return vec4(10,10,10, density);\n}\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n/*    float t= 0.03;\n    float f = 1.0;\n    for(int iter=0; iter<64; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = FX_ColDensity( p );\n        vec4 vEffect2 = FX_ColDensity( p + g_vSunDir * 0.1 ) ;\n        \n        vEffect.xyz *= clamp( (vEffect.w - vEffect2.w) / 0.1, 0.0, 1.0 );\n        \n        vColor = mix(vColor, vEffect.rgb, f * vEffect.w);\n        f = f * (1.0 - vEffect.w);\n        \n\t\tt += (0.04+t*0.012);        \n    }    */\n    \n    return vColor;\n}\n\n// Camera \n\nCameraState GetCameraState()\n{\n    CameraState camera;\n    \n    float fAngle = (iMouse.x / iResolution.x) * 3.14 * 2.0;\n    float fDist = 15.0;\n    \n    float fHeight = (iMouse.y / iResolution.y) * 15.0;\n    \n    camera.vPos = vec3( sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist );\n    camera.vTarget = vec3( 0.0, 2.0, 0.5 );\n    camera.fFov = 25.0;\n    \n    return camera;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n    vec4 vOldData = LoadVec4( iChannel0, ivec2(0,0) );\n \n    \n    vec3 vRayOrigin, vRayDir;\n\n// Environment map render\n#if 1\n    // Passthrough shader if previous value was valid\n\tif ( iFrame > 0 && vOldData.x == iResolution.x && vOldData.y == iResolution.y )\n    {\n        vFragColor = texture( iChannel0, vUV );\n        return;\n    }\n    \n    vRayOrigin = vec3(0.0, 1.0, 0.0);\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n    \n    float fHeading = vUV.x * PI;\n    if ( vUV.y > 0.5 )\n    {\n\t    vUV.y = 1.0 - vUV.y;\n        fHeading += PI;\n    }\n    float fElevation = mix( fSkyElevationMin, fSkyElevationMax, vUV.y * 2.0 );\n    \n    vRayDir.x = sin( fHeading ) * cos( fElevation );\n    vRayDir.y = sin( fElevation );\n    vRayDir.z = cos( fHeading ) * cos( fElevation );\n#else    \n    CameraState cam = GetCameraState();\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n#endif\n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n\n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    //vFragColor.r = fract( atan(vRayDir.x, vRayDir.z) / (PI * 2.0) );\n    \n    // Debug update frequency\n    //vFragColor.r = fract( iTime * 10.0 );\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n\n    vec4 textureA = texture( iChannel1, vec2(0,0) );\n    vec4 textureB = texture( iChannel2, vec2(0,0) );\n    vec4 textureC = texture( iChannel3, vec2(0,0) );\n\n    vec4 vFrameData = vec4( 0 );\n    // Don't stamp output as valud until input textures have loaded\n    if ( length(textureA.rgb) > 0.01 && length(textureB.rgb) > 0.01 && length(textureC.rgb) > 0.01 )\n    {  \n        vFrameData =  vec4( floor(iResolution.x), floor(iResolution.y), 0, 0 );\n    }\n    \n    StoreVec4( vec2(0,0), vFrameData, vFragColor, vFragCoord );\n}\n\n\n#endif\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Scene Render\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10.0\n\n#define PI 3.141592654\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    float fAperture;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 posAperture = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = posAperture.xyz;\n    cam.fAperture = posAperture.w;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( addr + vec2(0,0), vec4( cam.vPos, cam.fAperture ), fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y / iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n///////////////////////////\n// Scene\n///////////////////////////\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fLightDist )\n{\n    //return 1.0;\n    //return Scene_Trace( vRayOrigin, vRayDir, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n    float mint = 0.02, tmax = 5.0;\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.02, 0.40 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 ) * 0.75 + 0.25;    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n///////////////////////////\n// Lighting\n///////////////////////////\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n///////////////////////////\n// Rendering\n///////////////////////////\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n    vec3 vRayOrigin = vInRayOrigin;\n    vec3 vRayDir = vInRayDir;\n    \n\tvec3 vResultColor = vec3(0.0);\n\tvec3 vPassContribution = vec3(1.0);\n            \n\tSceneResult firstTraceResult;\n    \n\tfor( int iPassIndex=0; iPassIndex<3; iPassIndex++ )\n\t{\t        \n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, kMaxTraceDist );\n        \n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n\t\tvec3 vPassColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.fObjectId < 0.0 )\n\t\t{\n            break; \n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -vRayDir), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvPassColor = \n                mix( surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive, surfaceLighting.vSpecular, vReflectance );\n        \n\t        vPassColor = Env_ApplyAtmosphere( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\t\t\n    \t\tvPassColor = FX_Apply( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            // Reflect Ray\n            vRayOrigin = surfaceInfo.vPos;\n            vRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n        }\n                \n\t\tvResultColor += vPassColor * vPassContribution;\n\t\tvPassContribution *= vReflectance;\t\t\t        \n    }\n    \n    vec4 vFinalSkyColor = Env_GetSkyColor( vRayOrigin, vRayDir );\n    vFinalSkyColor.rgb = Env_ApplyAtmosphere( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\t\t\n\tvFinalSkyColor.rgb = FX_Apply( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\n    vResultColor += vFinalSkyColor.rgb * vPassContribution;\n    \n    //vResultColor = FX_Apply( vResultColor, vInRayOrigin, vInRayDir, firstTraceResult.fDist );\n    \n    if ( firstTraceResult.fObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n    \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////\n// Utility Functions\n///////////////////////////\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<4; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n\n/////////////////////////\n// Scene Description\n/////////////////////////\n\nstruct SceneState\n{\n    vec3 vCarPos;\n    float fThruster;\n    float fDustTrail;\n    float fCarVel;\n    float fEffect;\n};  \n    \nSceneState g_sceneState;\n    \n// Materials\n\n#define MAT_SKY \t\t-1.0\n#define MAT_SAND \t\t1.0\n\n//#define MAT_WATER \t\t0.0\n//#define MAT_GOLD \t\t2.0\n\n#define MAT_CHROME \t\t10.0\n#define MAT_CAR_PAINT\t11.0\n\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0); //fract( surfaceInfo.vPos + 0.1 );\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n        \n    if ( traceResult.fObjectId == MAT_CHROME )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.3 );\n\t    surfaceInfo.vAlbedo = vec3( 0.0 );\n    }\n    /*else\n    if ( traceResult.fObjectId == MAT_GOLD )\n    {\n        surfaceInfo.vR0 = vec3( 0.8, 0.6, 0.1 );\n\t    surfaceInfo.vAlbedo = vec3( 0.0 );\n        \n        float f = fract(surfaceInfo.vPos.y);\n        if ( f > 0.9 )\n        {\n            surfaceInfo.vEmissive = vec3( 1, 4, 8 ) * 100.0;\n        }\n    }\n    else\n    if ( traceResult.fObjectId == MAT_WATER )\n    {\n\t    surfaceInfo.vR0 = vec3( 0.01 );\n        surfaceInfo.fSmoothness = 1.0;\n        surfaceInfo.vBumpNormal.xy += FBM_DXY( surfaceInfo.vPos.xz * 2.0, vec2(0), 0.9, 0.2).yz * 0.2;\n        surfaceInfo.vBumpNormal = normalize( surfaceInfo.vBumpNormal );\n        vec3 vRefractedRay = refract( -vRayDir, surfaceInfo.vBumpNormal, 1.0 / 1.33 );\n        float fDepth = vRefractedRay.y;\n        float fRayLength = 2.0 / fDepth;\n        vec2 vUVOffset = vRefractedRay.xz * fRayLength;\n        surfaceInfo.vAlbedo = texture( iChannel0, surfaceInfo.vPos.xz + vUVOffset ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        \n        surfaceInfo.vAlbedo *= GetWaterExtinction( -fRayLength * 0.25 );\n    }*/\n    else\n    if ( traceResult.fObjectId == MAT_SAND )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.0 );\n\t    //surfaceInfo.vAlbedo = vec3( 1.0, 0.0, 0.0 );\n        vec2 vSandPos = surfaceInfo.vPos.xz + 0.2;\n        vec3 vSample1 = texture( iChannel0, vSandPos * 0.05).rgb;\n        //vSample1 = vSample1 * vSample1;\n        vec3 vSample2 = texture( iChannel0, vSandPos * 0.001).rgb;\n        //vSample2 = vSample2 * vSample2;\n        surfaceInfo.vAlbedo = vSample1 * vSample2;\n        //float f = FBM_DXY( surfaceInfo.vPos.xz * 3.0, vec2(0,0), 0.7, -0.5 ).z;\n        //f = f * f;\n        //surfaceInfo.vAlbedo = mix( vec3(0.2, 0.1, 0.05), vec3(0.6, 0.5, 0.2), f );\n        surfaceInfo.fSmoothness = 0.1;        \n        //surfaceInfo.fSmoothness = 1.0 - surfaceInfo.vAlbedo.r;        \n\n        \n        // heat haze\n        \n        //surfaceInfo.vR0 = vec3(0.02);\n        //surfaceInfo.fSmoothness = 0.95;\n        //surfaceInfo.vBumpNormal.xz += FBM_DXY(surfaceInfo.vPos.xz * 2.0, vec2(iTime, 0.0), 0.5, 0.5 ).xy * .1;\n        //surfaceInfo.vBumpNormal = normalize( surfaceInfo.vBumpNormal );\n        vec2 vMin = vec2(0.0, -97.5);\n        vec2 vMax = vec2(2.0, -95.0);\n        vec2 vUV = (surfaceInfo.vPos.xz - vMin) / (vMax - vMin);\n\t\tif ( vUV.x > 0.0 && vUV.x < 1.0 &&\n            vUV.y > 0.0 && vUV.y < 1.0 )\n        {\n            float fAmount = max(0.0, 1.0 - surfaceInfo.vAlbedo.r * 2.5);\n            surfaceInfo.vAlbedo = mix( vec3(0.1,0.1,.25), vec3(.9,1,1), fAmount );\n            \n\t\t\tsurfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        }\n    }\n    else\n    if ( traceResult.fObjectId == MAT_CAR_PAINT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\t    surfaceInfo.vAlbedo = vec3( 0.01, 0.01, 0.01 );\n        surfaceInfo.fSmoothness = 0.95;       \n    }\n    \n    if ( traceResult.fObjectId == MAT_CAR_PAINT || traceResult.fObjectId == MAT_CHROME )\n    {\n        vec3 vDirt = mix(texture(iChannel0, traceResult.vUVW.zy * vec2(0.2, 1.0)).rgb, texture(iChannel0, traceResult.vUVW.xy).rgb, abs(surfaceInfo.vNormal.z) ) ;\n        float fDirt = vDirt.r;\n        \n        float fMix = clamp( fDirt - traceResult.vUVW.y * 0.4, 0.0, 1.0 );\n        \n        vDirt = vDirt * vDirt * 0.15;\n\n        surfaceInfo.vAlbedo = mix( surfaceInfo.vAlbedo, vDirt, fMix );\n        surfaceInfo.vR0 = mix( surfaceInfo.vR0, vec3(0.01), fMix );\n        surfaceInfo.fSmoothness = mix( surfaceInfo.fSmoothness, 0.01, fMix ); \n    }\n    \n    return surfaceInfo;\n}\n\n// Scene Description\n\nfloat NozzleDist( vec2 vProfile, float r1, float r2, float l, float thickness )\n{\n    float f = vProfile.x  / l;\n    float fDist = vProfile.y - mix( r1, r2, f );\n    fDist = max( fDist, - fDist - thickness );\n    fDist = max( fDist, vProfile.x - l );\n    fDist = max( fDist, -vProfile.x  );    \n    \n    return fDist;\n}\n\nfloat ConvexCurveSectionDist( vec2 vProfile, float r1, float r2, float x1, float x2 )\n{    \n    float l = x2 - x1;\n    float curveDR = abs(r2 - r1);\n    float circleR = (l * l + curveDR * curveDR) / (2.0 * curveDR);\n    float fDist = length( vProfile - vec2(x2, r1 - circleR) )  - circleR;\n    \n    return fDist;\n}\n\nfloat ConcaveCurveSectionDist( vec2 vProfile, float r1, float r2, float x1, float x2 )\n{    \n    /*float l = x2 - x1;\n    float curveDR = abs(r2 - r1);\n    float circleR = (l * l + curveDR * curveDR) / (2.0 * curveDR);\n    float fDist = length( vProfile - vec2(0, r1 - circleR) )  - circleR;*/\n    \n    float l = x2 - x1;\n    float curveDR = r2 - r1;    \n    float circleR = (l * l + curveDR * curveDR) / (2.0 * curveDR);    \n    float fDist = circleR - length( vProfile - vec2(x1, r1 + circleR) );\n\n    fDist = max( fDist, vProfile.y - r2 );\n    \n    return fDist;\n}\n    \nSceneResult CarCentre_GetDistance( vec3 vPos )\n{\n    //vPos.y -= clamp(vPos.z, -3.0, 0.0) * 0.1;\n    vec2 vProfile = vec2( vPos.z, length( vPos.xy ) );\n    \n    const float fNoseStartRadius = 0.5;\n    const float fNoseEndRadius = 0.1;\n    const float fNoseLength = 3.0;\n    \n    const float fNoseDR = fNoseStartRadius - fNoseEndRadius;\n    \n    const float frontCurveCircleRadius = (fNoseLength * fNoseLength + fNoseDR * fNoseDR) / (2.0 * fNoseDR);    \n    \n    //float dist = length( vProfile - vec2(0, fNoseStartRadius-frontCurveCircleRadius) ) - frontCurveCircleRadius;\n    \n    float dist = ConvexCurveSectionDist( vProfile, fNoseStartRadius, fNoseEndRadius, -fNoseLength, 0.0 );\n    \n    const float fSpikeLength = 2.0;\n    dist = min(dist, vProfile.y - 0.05);\n\tdist = max(dist, (vProfile.y - 0.05 - (vProfile.x + (fNoseLength + fSpikeLength))) * (1.0 / sqrt(2.0))); // pointy tip    \n\n\t// cabin cone\n    const float fCCStartRadius = fNoseStartRadius;\n    const float fCCEndRadius = 1.0;\n    const float fCCLength = 5.0;\n    \n    float fCCRadius = ConcaveCurveSectionDist(vProfile, fCCStartRadius, fCCEndRadius, 0.0, fCCLength );\n    \n/*        if ( vProfile.x < 0.0 )\n        {\n            fCCRadius = 0.0;\n        }\n        if ( vProfile.x > fCCLength)\n        {\n            fCCRadius = fCCEndRadius;\n        }*/\n    \n     \n    if ( vProfile.x > 0.0 )\n    {\n    \tdist = min ( dist, fCCRadius );\n    }\n    \n    const float rRCEndRadius = 1.5;\n    float fRRadius = ConvexCurveSectionDist(vProfile, rRCEndRadius, fCCEndRadius, fCCLength, 15.0 );\n    \n    dist = min( dist, fRRadius );\n\n    // back end cap\n    dist = max( dist, vProfile.x - 14.0 );\n    \n    // taper body\n    dist = max( dist, vPos.x + vPos.z * 0.02 - 0.8 );\n    \n    // flatten base\n    dist = max( dist, -vPos.y - 0.6 );\n    \n    // Fin Vertical\n    \n    float fVFinDist = (vPos.y - vPos.z) / sqrt(2.0) + 8.0;\n    fVFinDist = max( fVFinDist, abs(vPos.x ) - 0.1 );\n    fVFinDist = max( fVFinDist, abs(vPos.y - 1.0 ) - 1.0 );\n    fVFinDist = max( fVFinDist, vPos.z - 13.8 );\n    dist = min( dist, fVFinDist );\n    \n    // Fin\n    vec3 vFinDir = normalize(vec3( 1.0, -0.5, -0.5 ));\n    float fFinDist = dot(vPos - vec3(0.0, 2.0, 11.5), vFinDir) ;\n    fFinDist = max( fFinDist, vPos.z - 16.0 );\n    fFinDist = max( fFinDist, abs(vPos.y - 2.0 ) - 0.1 );\n    dist = min( dist, fFinDist );\n    \n    SceneResult result = SceneResult( dist, MAT_CAR_PAINT, vec3(vPos) );\n\n    \n    if ( -vProfile.x > fNoseLength - 0.1 )\n    {\n        result.fObjectId = MAT_CHROME;\n    }\n    \n    //result = Scene_Union( result, SceneResult( vProfile.y - 0.05, MAT_CHROME, vec3(0.0) ) );\n    \n    //vPos.x *= 1.5;\n    //SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n    /*\n    vec3 vClosest = vPos;\n    vClosest.z = clamp( vClosest.z, 0.0, 4.0 );\n        \n    float fRadius = 1.0;\n    \n    fRadius = min( fRadius, smoothstep( 0.0, 1.0, vPos.z * 0.2 + 0.5) );\n    \n    float fRearRadius = clamp( vPos.z * 0.5 - 5.0 , 0.0, 1.0 );\n    fRadius = min( fRadius, sqrt( 1.0 - fRearRadius * fRearRadius )  );\n    //fRadius = max(fRadius, -vPos.z * 0.25 );\n\n    //{\n//    \tfRadius = smoothstep(0.0, 1.0, fRadius);\n//    }\n\n    //vClosest.xy = normalize(vClosest.xy) * min( length(vClosest.xy), fRadius );\n    \n    //float dist = length(vPos - vClosest) - 0.5;\n    float dist = length(vPos.xy) - fRadius;\n    dist = max( dist, -vPos.z + -10.0 );\n    dist = max( dist, vPos.z -8.0 );\n    \n    //dist /= 1.5;\n    */\n    \n    return result;\n}\n\nSceneResult CarEngine_GetDistance( vec3 vPos )\n{\n    //SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n    vec2 vProfile = vec2( vPos.z, length( vPos.xy ) );\n\n    float fDist = kMaxTraceDist;\n    \n    const float fEngineRadius1 = 1.0;\n    const float fEngineRadius2 = 0.9;\n    const float fEngineRearLength = 7.0;\n    \n    float fEngineRadiusCurr = mix( fEngineRadius1, fEngineRadius2, vProfile.x  / fEngineRearLength);\n    float fCylinderDist = vProfile.y - fEngineRadiusCurr;\n    fCylinderDist = max( fCylinderDist, -vProfile.x );\n    \n    fDist = min( fDist, fCylinderDist );\n    \n    const float fEngineFrontCurveLength = 1.5;\n    const float fEngineFrontCurveRadius = 0.6;\n    \n    float frontCurveDist = ConvexCurveSectionDist( vProfile, fEngineRadius1, fEngineFrontCurveRadius, -fEngineFrontCurveLength, 0.0 );\n    frontCurveDist = max( frontCurveDist, -vProfile.x - fEngineFrontCurveLength);\n    \n    \n    fDist = min( fDist, frontCurveDist );\n    \n    fDist = max( fDist, vProfile.x - fEngineRearLength);\n    \n    SceneResult result = SceneResult( fDist, MAT_CAR_PAINT, vec3(vPos) );\n\n    const float fEngineInnerCylinderRadius1 = fEngineFrontCurveRadius - 0.025;\n    const float fEngineInnerCylinderRadius2 = fEngineRadius2 - 0.0;\n    \n    result = Scene_Union( result, SceneResult( length( vProfile - vec2(-fEngineFrontCurveLength + 0.08, fEngineFrontCurveRadius - 0.2 )) - 0.22, MAT_CHROME, vec3(0.0) ) );\n    \n\n    float fGroovePos = floor(vProfile.x) + 0.5;\n    float fGrooveDist = abs( vProfile.x - fGroovePos ) - vProfile.y - 0.025 + fEngineRadiusCurr;\n    result = Scene_Subtract( result, SceneResult( fGrooveDist, MAT_CAR_PAINT, vec3(vPos) ) );\n    \n    float fInnerCylinderDist = vProfile.y - mix( fEngineInnerCylinderRadius1, fEngineInnerCylinderRadius2, (vProfile.x - fEngineFrontCurveLength) / (fEngineFrontCurveLength + fEngineRearLength) );    \n    //fInnerCylinderDist = max( fInnerCylinderDist, 1.0 - abs( vProfile.x - 5.0 ) );\n    result = Scene_Subtract( result, SceneResult( fInnerCylinderDist, MAT_CHROME, vec3(0.0) ) );\n\t\n    const float rearNozzleStart = fEngineRearLength - 1.0;\n    const float rearNozzleEnd = fEngineRearLength + 0.2;\n    float fRearNozzleDist = NozzleDist( vProfile - vec2(rearNozzleStart, 0.0), 0.4, 0.85, rearNozzleEnd - rearNozzleStart, 0.05 );\n    result = Scene_Union( result, SceneResult( fRearNozzleDist, MAT_CHROME, vec3(0.0) ) );\n    \n    const float rearNozzle2Start = fEngineRearLength - 0.2;\n    const float rearNozzle2End = fEngineRearLength + 0.4;\n    float fRearNozzle2Dist = NozzleDist( vProfile - vec2(rearNozzle2Start, 0.0), 0.5, 0.3, rearNozzle2End - rearNozzle2Start + 0.1, 0.05 );\n    result = Scene_Union( result, SceneResult( fRearNozzle2Dist, MAT_CHROME, vec3(0.0) ) );\n        \n    /*\n    vec3 vClosest = vec3(0.0);\n    vClosest.z = clamp( vPos.z, 0.0, 6.0 );\n\n    float dist = length( vPos - vClosest ) - 1.0;\n    \n    SceneResult result = SceneResult( dist, MAT_CAR_PAINT, vec3(0.0) );\n\n    float fRadialDist = length(vPos.xy);\n    result = Scene_Subtract( result, SceneResult( fRadialDist - 0.6, MAT_CHROME, vec3(0.0) ) );\n    \n\t*/\n    \n    if ( vPos.z < -1.3 )\n    {\n        result.fObjectId = MAT_CHROME;\n    }\n    return result;\n}\n\nSceneResult Car_GetDistance( const vec3 vPos )\n{\n    //SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    //SceneResult result = SceneResult( length( vPos - vec3( 0, 1, 0 ) ) - 2.0, MAT_GOLD, vec3(0.0) );\n    \n    vec3 vMirror = vPos;\n    vMirror.x = abs(vMirror.x);\n    \n    SceneResult result = CarEngine_GetDistance( vMirror - vec3( 1.4, 1.1, -2 ) );\n    //result = Scene_Union( result, CarEngine_GetDistance( vPos - vec3( 1.5, 1, -2 ) ) );\n    \n    result = Scene_Union( result, CarCentre_GetDistance( vMirror - vec3( 0, .7, -4 ) ) );\n    \n    result.vUVW = vPos;\n    \n    return result;\n}\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n\n    result = Scene_Union( result, Car_GetDistance( vPos - g_sceneState.vCarPos ) );\n    \n    \n    //result = Scene_Union( result, SceneResult( length( vPos - vec3( 0, 1, 0 ) ) - 2.0, MAT_GOLD, vec3(0.0) ) );\n    //result = Scene_Subtract( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    //result = Scene_Intersection( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \n\tfloat fHeight = 1.0;//1.0 - texture( iChannel1, vPos.xz * 0.1 - vec2(0, iTime) ).r;\n    \n    result = Scene_Union( result, SceneResult( vPos.y + fHeight * 0.5, MAT_SAND, vec3(0.0) ) );\n                                                  \n/*    float l = length( vPos.xz );\n    result = Scene_Union( result, SceneResult( vPos.y - 2.0 + exp(-l * 0.1) * 4.0, MAT_SAND, vec3(0.0) ) );\n    result = Scene_Union( result, SceneResult( vPos.y \n//                                              + sin(iTime + vPos.x * 8.0) * 0.02\n//                                              + sin(iTime * 2.0 + vPos.z * 8.0) * 0.02\n//                                              + sin(iTime * 3.0 + vPos.x * 10.0) * 0.01\n//                                              + sin(iTime * 4.0 + vPos.z * 10.0) * 0.01\n                                              , MAT_WATER, vec3(0.0) ) );*/\n        \n    return result;\n}\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, -0.8));\nvec3 g_vSunColor = vec3(1, 0.5, 0.25) * 5.0;\nvec3 g_vAmbientColor = vec3(0.5, 1, 1);\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    vec3 vThrusterLightCol = vec3( 1.0, 0.5, 0.3 ) * 1.0 * g_sceneState.fThruster;\n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, g_sceneState.vCarPos + vec3(1.4, 1.0, 5.8), vThrusterLightCol );\n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, g_sceneState.vCarPos + vec3(-1.4, 1.0, 5.8), vThrusterLightCol );\n    \n    float fAO = 1.0;//Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\t\n    float fElevation = atan( vViewDir.y, length(vViewDir.xz) );\n    float fHeading = atan( vViewDir.x, vViewDir.z );\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n\n    float fScaledElevation = 0.5 * ((fElevation - fSkyElevationMin) / (fSkyElevationMax - fSkyElevationMin));\n    if (fHeading < 0.0) fScaledElevation = 1.0 - fScaledElevation;\n    vec2 vUV = vec2( fract(fHeading / PI), fScaledElevation );\n    \n    //vResult = textureLod( iChannel3, vUV, 0.0 );\n    vResult = textureLod( iChannel3, vViewDir, 0.0 );\n    \n    //vResult = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n    // Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n    \n\treturn vResult;\t\n}\n\nfloat Env_GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.0015;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{\n\treturn vec3(0.4, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n\tfloat fFogFactor = Env_GetFogFactor( fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\n\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);\n    \n    vec3 vResult = mix( vFogColor, vColor, fFogFactor );\n\n    if ( g_sceneState.fEffect == 1.0 )\n    {        \n        vec3 vWorldPos = vRayOrigin + vRayDir * fDist;\n        if ( vWorldPos.y < 0.001 )\n        {\n\t\t\tvResult = vec3(1.0, 1.0, 0.02) * 0.25;          \n            vWorldPos.z -= iTime * 10.0;\n        }\n        else\n        {\n\t\t\tvResult = vec3(0.01, 1.0, 0.02) * 20.0;\n        }\n\n        vec3 vFractPos = abs(fract(vWorldPos - 0.2) - 0.5) * 2.0;\n        float f = max( max( vFractPos.x, vFractPos.y ), vFractPos.z );\n        vResult *= pow( f, 20.0 );\n    }\n\n    return vResult;\t    \n}\n\n// FX\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat FX_SmokeDensity(vec3 vPos)\n{\n    vec2 vProfile = vec2( vPos.z, length( vPos.xy) );\n    \n    vec2 vClamped;\n    vClamped.x = clamp( vProfile.x, 0.0, 10000.0 );\n    vClamped.y = 0.0;\n    \n    float t = vClamped.x / 500.0;\n    \n    float r = (1.0 - exp2( t * -30.0 )) * 10.0;\n    //float r = sqrt(t) * 10.0;\n    \n    \n    float l = length( vProfile - vClamped ) - r;\n    \n    // gradual fade\n    return l * exp2( t * -0.05 ) * g_sceneState.fDustTrail;\n}\n\nfloat FX_Noise( vec3 vPos )\n{\n    vec3 vNoisePos = vPos;\n    return noise( vNoisePos );\n}\n\nvec4 FX_ColDensity( vec3 vPos )\n{\n    float density = 0.0;\n\n \tvec3 vLocalCarPos = vPos - g_sceneState.vCarPos;\n    \n    vec3 vSmokePos = vec3( 0, 0.0, 10.0 );\n        \n    float n1 = FX_SmokeDensity( vLocalCarPos - vSmokePos );\n    vec3 vOffsetPos = vLocalCarPos + g_vSunDir * 0.3;\n    float n2 = FX_SmokeDensity( vOffsetPos - vSmokePos);\n    \n    vec3 vNoisePos = vLocalCarPos - vSmokePos;\n    float fNoiseSpeed = 50.0;\n    float fFreq = 3.5;\n    if ( vLocalCarPos.z > 10.0 )\n    {\n        vNoisePos = vPos;\n        fFreq = 1.5;\n        fNoiseSpeed = 20.0;\n        vNoisePos.y -= iTime;\n    }\n    else\n    {\n    \tvNoisePos.z -= iTime * 30.0;\n        \n    }\n\n    float fNoise1 = FX_Noise( vNoisePos * fFreq );\n    float fNoise2 = FX_Noise( (vNoisePos + g_vSunDir * 0.3) * fFreq );\n    \n    n1 += fNoise1 * 3.0;\n    n2 += fNoise2 * 3.0;\n    \n    if ( n1 < 0.0 )\n        density = min( 1.0, -n1 * 0.1);\n    else\n    \tdensity = -n1;\n    \n    float sh = clamp( (n2 - n1)* 0.5 + 0.1, 0.0, 1.0 );\n    \n    vec3 vCol = g_vSunColor * sh + g_vAmbientColor * 0.4;\n    \n    // Darken middle\n    vCol *= clamp( 1.0 + n1 * 0.25, 0.0, 1.0);\n    vCol *= vec3(1.0, 0.8, 0.65);\n\n    vec3 vMirror = vLocalCarPos;\n    vMirror.x = abs(vMirror.x);\n    \n    vec3 vFlamePos = vMirror - vec3( +1.4, 1.1, 5.2 );\n    float fFlameDist = length( vFlamePos.xy ) - 0.4;\n    fFlameDist = max( fFlameDist, -vFlamePos.z - 0.5 );\n    float fFlameFade = clamp( (vFlamePos.z + 0.2 ) * 0.25, 0.0, 1.0 );\n    fFlameDist += fFlameFade * fFlameFade;\n    \n    float fl = fFlameDist - fNoise1 * 0.5;\n    fl += 0.7 * (1.0 - g_sceneState.fThruster);\n    if ( fl < 0.0)\n    {\n        density = -fl * 0.5;\n    \tvCol = mix( vec3(0.01, 0.01, 1.) * 30.0, vec3( 1.0, 0.2, 0.05) * 30.0, pow( fFlameFade, 0.05) );\n    }\n    else\n    {\n        density = max( density, -fl );\n    }\n    \n    //vCol *= 10.0;\n    \n    return vec4(vCol, density);\n}\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n    float t= 0.03;\n    float f = 1.0;\n    float st = 0.03;\n    for(int iter=0; iter<64; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = FX_ColDensity( p );\n        if ( vEffect.w >= 0.0 )\n        {\n        \tvColor = mix(vColor, vEffect.rgb, f * vEffect.w);\n        \tf = f * (1.0 - vEffect.w);\n        \n            t += st;\n\t\t\tst += (0.04+st*0.012);     \n        }\n        else\n        {\n\t\t\tt += -vEffect.w + 0.03;\n            st = 0.03;\n        }\n            \n    }\n    \n    return vColor;\n}\n\n// Camera \n\n\nCameraState GetCameraState_MouseOrbitCar()\n{\n    CameraState camera;\n\n    float fAngle = (iMouse.x / iResolution.x) * 3.14 * 2.0;\n    float fDist = (iMouse.y / iResolution.y) * 40.0;\n    \n    float fHeight = 1.0;\n    \n    camera.vTarget = g_sceneState.vCarPos + vec3( 0.0, 1.0, 0.5 );\n    camera.vPos = camera.vTarget + vec3( sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist );\n    camera.fFov = 20.0;\n    \n    return camera;\n}\n\nstruct Sequence\n{\n    float fDt;\n    float fTime;\n    float fLength;\n    float fBlend;\n    float fSmoothBlend;\n};\n    \nSequence Sequence_Init( float fTime, float fDt )\n{\n    Sequence seq;\n    seq.fDt = fDt;\n    seq.fTime = fTime + fDt;\n    seq.fLength = 0.0;\n    seq.fBlend = 0.0;\n    seq.fSmoothBlend = 0.0;\n    return seq;\n}\n\nbool Sequence_Next( inout Sequence seq, float fLength )\n{\n    seq.fTime -= seq.fLength;\n    seq.fLength = fLength;\n    seq.fBlend = seq.fTime / fLength;\n    seq.fSmoothBlend = smoothstep( 0.0, 1.0, seq.fBlend );\n    \n    float fTestTime = seq.fTime - seq.fDt;\n    return fTestTime >= 0.0 && fTestTime < fLength;\n}\n\nstruct CarInt\n{\n    float s;\n    float u;\n    float a;\n};\n    \nvoid CarInt_Update( inout CarInt carInt, float fTime )\n{\n    carInt.s += carInt.u * fTime + .5 * carInt.a * fTime * fTime;\n    carInt.u += carInt.a * fTime;\n}\n\nfloat CarInt_GetDisplacement( CarInt carInt, float fTime )\n{\n    return carInt.s + carInt.u * fTime + .5 * carInt.a * fTime * fTime;    \n}\n\nfloat CarInt_GetVelocity( CarInt carInt, float fTime )\n{\n    return carInt.u + carInt.a * fTime;\n}\n\nvoid GetSceneState( out SceneState scene, out CameraState camera, float fTime, float fDt )\n{\n    scene.vCarPos = vec3(0.0);\n    scene.vCarPos.y -= 0.7;\n    scene.fThruster = 0.0;\n    scene.fDustTrail = 0.0;\n    scene.fCarVel = 0.0;\n    scene.fEffect = 0.0;\n\n    camera.vPos = vec3( 0.0, 1.0, -10.0 );\n    camera.vTarget = vec3( 0.0, 0.0, 0.0 );\n    camera.fFov = 15.0;\n    camera.fAperture = 0.5;\n    \n    float fCameraShake = 0.0;\n\n    //scene.fThruster = clamp( sin(iTime) * 0.5 + 0.5, 0.0, 1.0);\n    //scene.fDustTrail = scene.fThruster;\n    //    scene.vCarPos.z = -iTime * 100.0;//343.0;\n        \n    Sequence seq = Sequence_Init( fTime, fDt );\n\n    CarInt carInt;\n    carInt.s = 0.0;\n    carInt.u = 0.0;\n    carInt.a = 0.0;\n    \n    if ( Sequence_Next( seq, 8.0 ) )\n    {\n\t    scene.vCarPos.y = 0.0;\n    }\n\n    // Initial Vel\n    carInt.u = 100.0;    \n    if ( Sequence_Next( seq, 4.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = vec3( 0.0, 1.0, -100.0 );\n        camera.vPos = camera.vTarget + vec3( 10.0, -0.5, -5.0 );\n        \n        //camera.vTarget = camera.vPos + normalize(camera.vTarget - camera.vPos) * 100.0 * (1.0 - seq.fBlend * 0.9);\n    \t//camera.fAperture = 1.5;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    // vel +50 in 10 secs\n    carInt.a = 100.0 / 15.0;    \n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, -15.0 );\n        camera.vTarget.z += seq.fSmoothBlend * 20.0;\n        camera.vPos = camera.vTarget + vec3( -8.0, 1.5, -3.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, -4.5 );\n        camera.vPos = camera.vTarget + mix( vec3( -4.0, 2.0, -20.0 ), vec3( -30.0, 1.0, 40.0 ) ,seq.fBlend );\n        camera.vTarget.z += seq.fBlend * 10.0;\n        camera.fFov = mix( 25.0, 15.0, seq.fBlend );\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }    \n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.5, -2.5 );\n        camera.vPos = camera.vTarget + mix( vec3( 10.0, 3.0, -20.0 ), vec3( -10.0, 3.0, -20.0 ) ,seq.fSmoothBlend );\n        camera.fFov = 8.0;\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 3.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 1.5, 1.4, 5.5 );\n        camera.vPos = camera.vTarget + vec3( 3.0, -0.5 + seq.fSmoothBlend * 2.0, 4.0+ pow( seq.fBlend, 4.0) * 16.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = seq.fSmoothBlend;\n        fCameraShake = 1.0;\n    }\n\n    // vel +150 in 10 secs\n    carInt.a = 150.0 / 30.0;    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        // Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 35.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = seq.fBlend * 0.1;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, seq.fSmoothBlend * 10.5 );\n        camera.vPos = camera.vTarget + vec3( 10.0, 2.0, -30.0 );\n        camera.fFov = 15.0;\n    \tcamera.fAperture = 1.0;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 0.1 + seq.fSmoothBlend * 0.9;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    if ( Sequence_Next( seq, 15.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vTarget = scene.vCarPos + mix( vec3( 0.0, 1.0, 20.0 ), vec3( 0.0, 1.0, -15.0 ), seq.fBlend );\n\t    camera.vPos = camera.vTarget + vec3( -8.0, 2.0, 4.5 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.4;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        // Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 45.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 17.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vPos = vec3(0.0);\n        camera.vPos.z = -CarInt_GetDisplacement( carInt, 0.0 );\n        \n        camera.vPos += vec3( 12.0, 0.5, -650.0 );\n\t    camera.vTarget = camera.vPos + vec3( -4.0, 0.0, 10.0 );\n        \n        camera.fFov = 10.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    \n    camera.vTarget.y += (noise(camera.vPos * 0.2) - 0.5) * fCameraShake / length(camera.vTarget - camera.vPos);\n    \n    if ( Sequence_Next( seq, 1000.0 ) )\n    {\n        scene.vCarPos = vec3(0.0, 0.0, 0.0);\n        scene.fCarVel = 0.0;\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 0.0, 2.0 );\n        camera.vPos = camera.vTarget + vec3(sin(seq.fTime * 0.4) * 40.0, 20.0, cos(seq.fTime * 0.4) * 40.0 );        \n        \n        camera.fFov = 10.0;\n    \tcamera.fAperture = 5.0;\n        \n        scene.fThruster = 0.0;\n        scene.fDustTrail = 0.0;\n        fCameraShake = 0.0;\n\n        scene.fEffect = 1.0;\n\t}\n    \n    //camera = GetCameraState_MouseOrbitCar();\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n\n    float fTime = iTime;\n    \n    // Scrubbing\n    if (false)\n    if (iMouse.z > 0.0 )\n    {\n        fTime = iMouse.x * 100.0 / iResolution.x;\n    }\n       \n\n    CameraState camPrev;       \n    SceneState temp;\n    GetSceneState( temp, camPrev, fTime, - 1.0 / 60.0 );\n    \n    CameraState cam;       \n    GetSceneState( g_sceneState, cam, fTime, 0.0 );\n    \n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n    \n    //float l = abs( vRayDir.y ) / vRayOrigin.y;\n    //float fAmount = .0001 / (l + 0.02);\n    //vRayDir.yz += FBM_DXY(vUV * 30.0, vec2(0.0, -iTime * 3.0), 0.5, -0.0 ).xy * fAmount;\n \n    if ( iTime < 8.0 )        \n    {      \n        vec2 vCoord = vUV - 0.5;\n        vCoord.x *= iResolution.x / iResolution.y;\n        vRayOrigin = vec3( 100.0, 100.0, 100.0 );\n        vRayDir = vec3(0.0, -1.0, 0.0);\n\n        vec2 vRegion;\n        \n        vRegion = (vCoord + vec2(0,0.25)) * vec2(1.0, 2.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.0 && vRegion.x < 1.0 && vRegion.y >= 0.0 && vRegion.y < 1.0 )\n        {\n            vec2 vRangeMin = vec2( -13.0, -7.5 );\n            vec2 vRangeMax = vec2( 18.0, 7.5 );\n            vRayOrigin.zx = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.y = 20.0;\n            vRayDir = vec3(0.0, -1.0, 0.0);\n        }\n\n        vRegion = (vCoord + vec2(0,-0.78)) * vec2(1.0, 2.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.0 && vRegion.x < 1.0 && vRegion.y >= 0.0 && vRegion.y < 1.0 )\n        {\n            vec2 vRangeMin = vec2( -13.0, 0.1 );\n            vec2 vRangeMax = vec2( 18.0, 15. );\n            vRayOrigin.zy = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.x = 20.0;\n            vRayDir = vec3(-1.0, 0.0, 0.0);\n        }\n        \n        vRegion = (vCoord + vec2(.3,-0.12)) * vec2(3.0, 6.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.1 && vRegion.x < 0.9 && vRegion.y >= 0.0 && vRegion.y < 0.85 )\n        {\n            vec2 vRangeMin = vec2( -3.5, 0.1 );\n            vec2 vRangeMax = vec2( 3.5, 3.5 );\n            vRayOrigin.xy = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.z = -20.0;\n            vRayDir = vec3(0.0, 0.0, 1.0);\n        }\n\n        vRegion = (vCoord + vec2(-0.3,-0.12)) * vec2(3.0, 6.0) * 0.5 + 0.5;\n        if ( vRegion.x >= 0.1 && vRegion.x < 0.9 && vRegion.y >= 0.0 && vRegion.y < 0.85 )\n        {\n            vec2 vRangeMin = vec2( -3.5, 0.1 );\n            vec2 vRangeMax = vec2( 3.5, 3.5 );\n            vRayOrigin.xy = mix(vRangeMin, vRangeMax, vRegion );\n            vRayOrigin.z = 20.0;\n            vRayDir = vec3(0.0, 0.0, -1.0);\n        }\n    }\n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n    /*\n    if ( vColorLinAmdDepth.r > 400.0 || vColorLinAmdDepth.g > 400.0 || vColorLinAmdDepth.b > 400.0 )\n    {\n        vFragColor.rgb = vec3(1.0 * (sin(iTime * 10.0) * 0.5 + 0.5), 0.0, 0.0);\n    }\n    else\n    {\n        vFragColor.rgb *= .25;\n\t}\n\t*/    \n    \n    Cam_StoreState( vec2(0,0), cam, vFragColor, vFragCoord );\n    \n    Cam_StoreState( vec2(2,0), camPrev, vFragColor, vFragCoord );\n    \n\tStoreVec4( vec2(4,0), vec4(g_sceneState.fCarVel / 60.0), vFragColor, vFragCoord );\n}\n\n#if 1\nvoid mainVR( out vec4 vFragColor, in vec2 vFragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{   \n    \n    float fTime = iTime;\n    \n    CameraState camPrev;       \n    SceneState temp;\n    GetSceneState( temp, camPrev, fTime, - 1.0 / 60.0 );\n    \n    CameraState cam;       \n    GetSceneState( g_sceneState, cam, fTime, 0.0 );\n    \n    vec3 vRayOrigin, vRayDir;\n    \n    Cam_GetCameraRay( vec2(0.5), cam, vRayOrigin, vRayDir );\n    \n    vRayOrigin += fragRayOri;\n    vRayDir = fragRayDir;\n    \n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n    \n    \n    Cam_StoreState( vec2(0,0), cam, vFragColor, vFragCoord );\n    \n    Cam_StoreState( vec2(2,0), camPrev, vFragColor, vFragCoord );\n    \n\tStoreVec4( vec2(4,0), vec4(g_sceneState.fCarVel / 60.0), vFragColor, vFragCoord );    \n}\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Depth of field / motion blur effect\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    float fAperture;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 posAperture = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = posAperture.xyz;\n    cam.fAperture = posAperture.w;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( addr + vec2(0,0), vec4( cam.vPos, cam.fAperture ), fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y / iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n///////////////////////////////////////////////\n\n\nfloat GetCoC( float fDistance, float fPlaneInFocus, float fAperture )\n{\n\t// http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n    float fFocalLength = 0.15;\n    \n    if ( iMouse.z > 0.0 )\n    {\n        fFocalLength += (iMouse.y / iResolution.y) * 0.5;\n    }\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) /\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\n// Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec2 Hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n#define MOTION_BLUR_TAPS 32\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n    // output linear color\n    //fragColor = texture( iChannel0, vUV );\n    //return;\n    \n    vec4 vSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\t\n    float fDepth = abs(vSample.w);\n    \n    CameraState cameraStateCurr;\n    Cam_LoadState( cameraStateCurr, iChannel0, ivec2(0,0) );\n    \n    CameraState cameraStatePrev;\n    Cam_LoadState( cameraStatePrev, iChannel0, ivec2(2,0) );\n\n    vec4 vCarVel = LoadVec4( iChannel0, ivec2(4,0) );\n   \n    float fShutterAngle = 0.5;\n    \n    if ( iMouse.z > 0.0 )\n    {\n        fShutterAngle = (iMouse.x / iResolution.x);\n    }\n    \n    \n    cameraStatePrev.vPos = mix( cameraStateCurr.vPos, cameraStatePrev.vPos, fShutterAngle );\n    cameraStatePrev.vTarget = mix( cameraStateCurr.vTarget, cameraStatePrev.vTarget, fShutterAngle );\n    cameraStatePrev.fFov = mix( cameraStateCurr.fFov, cameraStatePrev.fFov, fShutterAngle );\n    cameraStatePrev.fAperture = mix( cameraStateCurr.fAperture, cameraStatePrev.fAperture, fShutterAngle );\n        \n    //cameraStatePrev.vTarget.z -= 2.0;\n    //cameraStatePrev.vPos.z -= 2.0;\n    \n    //cameraStatePrev.fFov -= 10.0;\n\n    if( vSample.a < 0.0 )\n    {\n    \tcameraStatePrev.vTarget.z += vCarVel.x * fShutterAngle;\n    \tcameraStatePrev.vPos.z += vCarVel.x * fShutterAngle;\n        \n    }    \n\n\n    \n\tvec3 vCameraPos, vRayDir;\n    Cam_GetCameraRay( vUV, cameraStateCurr, vCameraPos, vRayDir );\n        \n    vec3 vWorldPos = vCameraPos + vRayDir * fDepth;\n    \n    //fragColor.xyz = fract( vWorldPos );\n    //fragColor.a = 1.0;\n    //return;\n    \n    vec2 vPrevWindow = Cam_WorldToWindowCoord( vWorldPos, cameraStatePrev );\n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( vPrevWindow );\n\n    // No motion blur for FG objects\n    //if( vSample.a < 0.0 )\n    //{\n      //  vPrevUV = vUV;\n    //}\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = length(cameraStateCurr.vPos - cameraStateCurr.vTarget);\n    \n    float fCoC = GetCoC( abs(fDepth), fPlaneInFocus, cameraStateCurr.fAperture );\n    \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); // Start angle\n    \n    vResult.rgb = vec3(0.0);//vSample.rgb * fCoC;\n    fTot += 0.0;//fCoC;\n    \n    float fMotionBlurTaps = float(MOTION_BLUR_TAPS);\n    \n    float fAspect = iResolution.y / iResolution.x;\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<MOTION_BLUR_TAPS; i++)\n    {\n        vec2 vTapUV = mix( vUV, vPrevUV, f - .5);\n                \n        vec2 vRand = Hash23( vec3( vUV.x, vUV.y, fract(iTime * .123 + fIndex * 1.234) ) );\n        //float fRand = Hash2( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        \n        // http://blog.marmakoide.org/?p=1\n        \n        float fTheta = vRand.x * 3.14 * 2.0;//fRand * fGolden * fMotionBlurTaps;\n        //float fRadius = fCoC * sqrt( vRand.y ); // uniform disc\n        float fRadius = fCoC * pow( vRand.y, 0.4 ); // less dense centre\n        \n        //float fRadius = fCoC * sqrt( fRand * fMotionBlurTaps ) / sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta) * fAspect, cos(fTheta) ) * fRadius;\n        \n        //vTapUV.y = abs( vTapUV.y );\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;        \n        if( vTapUV.y < 1.0 / iResolution.y )\n        {\n            vTapSample = vec4(0.0);\n        }        \n        //if(vTapUV.y > 0.0)\n        if( sign(vTapSample.a) == sign(vSample.a) )\n        {\n  \t\t  \tfloat fCurrCoC = GetCoC( abs(vTapSample.a), fPlaneInFocus, cameraStateCurr.fAperture );\n            \n            float fWeight = fCurrCoC;\n            \n    \t\tvResult += vTapSample.rgb * fWeight;\n        \tfTot += fWeight;\n        }\n        f += 1.0 / fMotionBlurTaps;\n        fIndex += 1.0;\n    }\n    vResult /= fTot;\n        \n    // Draw depth\n    //vFinal = vec3(1.0) / abs(vSample.a);    \n    \n    // passthrough depth\n\tfragColor = vec4(vResult, vSample.a);\n\n    Cam_StoreState( vec2(0,0), cameraStateCurr, fragColor, fragCoord );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Bloom\n\n///////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 gBloomSize = min( vec2(320.0, 240.0), iResolution.xy );\n    \n\tvec2 vUV = fragCoord.xy / gBloomSize;\n    \n    if ( vUV.x > 1.0 ) discard;\n    if ( vUV.y > 1.0 ) discard;\n\n    // output linear color\n    //fragColor = texture( iChannel0, vUV );\n    //return;\n    \n    #define KERNEL_SIZE 8\n    #define BLOOM_STRENGTH 6.0\n    #define KERNEL_SIZE_F float(KERNEL_SIZE)    \n    \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fY = -KERNEL_SIZE_F;\n    for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ )\n    {\n        float fX = -KERNEL_SIZE_F;\n\t    for( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ )\n        {            \n\n            vec2 vOffset = vec2( fX, fY );\n            vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) / gBloomSize;\n\n            vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n\t        if( vTapUV.y < 1.0 / iResolution.y )\n            {\n               vTapSample = vec4(0.0);\n            }\n            \n            vec2 vDelta = vOffset / KERNEL_SIZE_F;\n            \n            float f = dot( vDelta, vDelta );\n            float fWeight = exp2( -f * BLOOM_STRENGTH );\n            vResult += vTapSample.xyz * fWeight;\n            fTot += fWeight;\n            \n\t        fX += 1.0;\n        }\n        \n        fY += 1.0;\n    }\n    vResult /= fTot; \n    \n    vec4 vPrevSample = textureLod( iChannel1, vUV* gBloomSize / iResolution.xy, 0.0 ).rgba;\n    vResult = max( vResult, vPrevSample.xyz * 0.3 );\n    //vResult += vPrevSample.xyz * 0.9;\n    \n\tfragColor = vec4(vResult, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define INVERT_STEREO\n\n//////////////////////////////////////\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    float fAperture;\n};\n   \nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}    \n\nstruct SceneState\n{\n    vec3 vCarPos;\n    float fThruster;\n    float fDustTrail;\n    float fCarVel;\n};  \n    \nSceneState g_sceneState;\n\nstruct Sequence\n{\n    float fTime;\n    float fLength;\n    float fBlend;\n    float fSmoothBlend;\n};\n    \nSequence Sequence_Init( float fTime )\n{\n    Sequence seq;\n    seq.fTime = fTime;\n    seq.fLength = 0.0;\n    seq.fBlend = 0.0;\n    seq.fSmoothBlend = 0.0;\n    return seq;\n}\n\nbool Sequence_Next( inout Sequence seq, float fLength )\n{\n    seq.fTime -= seq.fLength;\n    seq.fLength = fLength;\n    seq.fBlend = seq.fTime / fLength;\n    seq.fSmoothBlend = smoothstep( 0.0, 1.0, seq.fBlend );\n    \n    return seq.fTime >= 0.0 && seq.fTime < fLength;\n}\n\nstruct CarInt\n{\n    float s;\n    float u;\n    float a;\n};\n    \nvoid CarInt_Update( inout CarInt carInt, float fTime )\n{\n    carInt.s += carInt.u * fTime + .5 * carInt.a * fTime * fTime;\n    carInt.u += carInt.a * fTime;\n}\n\nfloat CarInt_GetDisplacement( CarInt carInt, float fTime )\n{\n    return carInt.s + carInt.u * fTime + .5 * carInt.a * fTime * fTime;    \n}\n\nfloat CarInt_GetVelocity( CarInt carInt, float fTime )\n{\n    return carInt.u + carInt.a * fTime;\n}\n\nvoid GetSceneState( out SceneState scene, out CameraState camera, float fTime )\n{\n    scene.vCarPos = vec3(0.0);\n    scene.fThruster = 0.0;\n    scene.fDustTrail = 0.0;\n    scene.fCarVel = 0.0;\n\n    camera.vPos = vec3( 0.0, 1.0, -10.0 );\n    camera.vTarget = vec3( 0.0, 0.0, 0.0 );\n    camera.fFov = 15.0;\n    camera.fAperture = 0.5;\n    \n    float fCameraShake = 0.0;\n\n    //scene.fThruster = clamp( sin(iTime) * 0.5 + 0.5, 0.0, 1.0);\n    //scene.fDustTrail = scene.fThruster;\n    //    scene.vCarPos.z = -iTime * 100.0;//343.0;\n        \n    Sequence seq = Sequence_Init( fTime );\n\n    CarInt carInt;\n    carInt.s = 0.0;\n    carInt.u = 0.0;\n    carInt.a = 0.0;\n    \n    if ( Sequence_Next( seq, 8.0 ) )\n    {\n    }\n\n    // Initial Vel\n    carInt.u = 100.0;    \n    if ( Sequence_Next( seq, 4.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = vec3( 0.0, 1.0, -100.0 );\n        camera.vPos = camera.vTarget + vec3( 10.0, -0.5, -5.0 );\n        \n        //camera.vTarget = camera.vPos + normalize(camera.vTarget - camera.vPos) * 100.0 * (1.0 - seq.fBlend * 0.9);\n    \t//camera.fAperture = 1.5;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    // vel +50 in 10 secs\n    carInt.a = 100.0 / 15.0;    \n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.5, -15.0 );\n        camera.vTarget.z += seq.fSmoothBlend * 20.0;\n        camera.vPos = camera.vTarget + vec3( -8.0, 0.5, -3.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 2.0, -4.5 );\n        camera.vPos = camera.vTarget + mix( vec3( -4.0, 2.0, -20.0 ), vec3( -30.0, 1.0, 40.0 ) ,seq.fBlend );\n        camera.vTarget.z += seq.fBlend * 10.0;\n        camera.fFov = mix( 25.0, 15.0, seq.fBlend );\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }    \n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.5, -2.5 );\n        camera.vPos = camera.vTarget + mix( vec3( 10.0, 3.0, -20.0 ), vec3( -10.0, 3.0, -20.0 ) ,seq.fSmoothBlend );\n        camera.fFov = 8.0;\n    \tcamera.fAperture = 1.5;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 3.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 1.5, 1.4, 5.5 );\n        camera.vPos = camera.vTarget + vec3( 3.0, -0.5 + seq.fSmoothBlend * 2.0, 4.0+ pow( seq.fBlend, 4.0) * 16.0 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = seq.fSmoothBlend;\n        fCameraShake = 1.0;\n    }\n\n    // vel +150 in 10 secs\n    carInt.a = 150.0 / 30.0;    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        // Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 35.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = seq.fBlend * 0.1;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n\n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.0, seq.fSmoothBlend * 10.5 );\n        camera.vPos = camera.vTarget + vec3( 10.0, 2.0, -30.0 );\n        camera.fFov = 15.0;\n    \tcamera.fAperture = 0.5;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 0.1 + seq.fSmoothBlend * 0.9;\n        fCameraShake = 1.0;\n    }\n    \n    CarInt_Update( carInt, seq.fLength );\n\n    if ( Sequence_Next( seq, 15.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vTarget = scene.vCarPos + mix( vec3( 0.0, 1.0, 20.0 ), vec3( 0.0, 1.0, -15.0 ), seq.fBlend );\n\t    camera.vPos = camera.vTarget + vec3( -8.0, 1.0, 4.5 );\n        camera.fFov = 20.0;\n    \tcamera.fAperture = 0.4;\n\n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n    \n    if ( Sequence_Next( seq, 5.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        // Tail fin cam\n\t    camera.vTarget = scene.vCarPos + vec3( 0.0, 1.8, 3.5 );\n        camera.vPos = camera.vTarget + vec3( 0.0, 1.2, 4.0 );\n        camera.fFov = 45.0;\n    \tcamera.fAperture = 0.3;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    CarInt_Update( carInt, seq.fLength );\n\n    carInt.a = 0.0;    \n    if ( Sequence_Next( seq, 17.0 ) )\n    {\n        scene.vCarPos.z = -CarInt_GetDisplacement( carInt, seq.fTime );\n        scene.fCarVel = -CarInt_GetVelocity( carInt, seq.fTime );\n\n        camera.vPos = vec3(0.0);\n        camera.vPos.z = -CarInt_GetDisplacement( carInt, 0.0 );\n        \n        camera.vPos += vec3( 12.0, 0.5, -650.0 );\n\t    camera.vTarget = camera.vPos + vec3( -4.0, 0.0, 10.0 );\n        \n        camera.fFov = 10.0;\n    \tcamera.fAperture = 0.5;\n        \n        scene.fThruster = 1.0;\n        scene.fDustTrail = 1.0;\n        fCameraShake = 1.0;\n    }\n    \n    //camera.vTarget.y += (noise(camera.vPos * 0.2) - 0.5) * fCameraShake / length(camera.vTarget - camera.vPos);\n    \n    \n    //camera = GetCameraState_MouseOrbitCar();\n}\n\n/////////////////////////////////////\n\nstruct C_Listener\n{\n    vec3 m_vPos;\n    mat3 m_ToWorld;\n    float m_fEarSeparation;\n    vec3 m_vEarDirL;\n    vec3 m_vEarDirR;\n};\n\nstruct C_MixerValues\n{\n    vec2 m_vPan;\n    vec2 m_vDopplerOffset;\n};\n\nstruct C_Source\n{\n    vec3 m_Pos;\n    float m_Volume;\n};    \n    \nC_Source g_SourceInfo[4];\n\n#define GET_VELOCITY(X, T) ((X(T + 0.1) - X(T)) / 0.1)\n\nvoid SetupListener( out C_Listener listener, const in vec3 vCameraCurrPos, const in mat3 mCameraCurrRot )\n{\n    listener.m_vPos = vCameraCurrPos;\n    listener.m_ToWorld = mCameraCurrRot;    \n    listener.m_fEarSeparation = 0.1;\n    listener.m_vEarDirL = normalize(vec3( -1.0, 0.0, 0.1));\n    listener.m_vEarDirR = normalize(vec3( 1.0, 0.0, 0.1));    \n}\n\n\nvoid GetMixerValues( const in C_Listener listener, const in C_Source source, out C_MixerValues mixerValues )\n{\n    vec3 vLocalEarPosL = vec3(-listener.m_fEarSeparation, 0.0, 0.0);\n    vec3 vLocalEarPosR = vec3( listener.m_fEarSeparation, 0.0, 0.0);\n    \n    vec3 vWorldEarPosL = listener.m_ToWorld * vLocalEarPosL + listener.m_vPos;\n    vec3 vWorldEarPosR = listener.m_ToWorld * vLocalEarPosR + listener.m_vPos;\n\n    vec3 vSourceToEarL = vWorldEarPosL - source.m_Pos;\n    vec3 vSourceToEarR = vWorldEarPosR - source.m_Pos;\n    \n    vec2 vDist = vec2(length(vSourceToEarL), length(vSourceToEarR));\n    const float kSpeedOfSound = 340.29;\n    mixerValues.m_vDopplerOffset = -vDist / kSpeedOfSound;\n    vec2 vVolume = vec2(source.m_Volume) / (vDist * vDist);\n\n    vec3 vWorldEarDirL = normalize( listener.m_ToWorld * listener.m_vEarDirL );\n    vec3 vWorldEarDirR = normalize( listener.m_ToWorld * listener.m_vEarDirR );\n    vec2 vPan = clamp(vec2( dot(normalize(vSourceToEarL), vWorldEarDirL), dot(normalize(vSourceToEarR), vWorldEarDirR) ) * 0.4 + 0.6 , 0.0, 1.0);\n    \n    mixerValues.m_vPan = vPan * vVolume;\n    \n#ifdef INVERT_STEREO\n    mixerValues.m_vPan = mixerValues.m_vPan.yx; // erm?!\n#endif\n}\n\n#define DOPPLER_PER_EAR\n\n#ifdef DOPPLER_PER_EAR\n\t#define MIX(SAMPLE_FN, TIME, MIXER_VALUES) (vec2(SAMPLE_FN(TIME + MIXER_VALUES.m_vDopplerOffset.x), SAMPLE_FN(TIME + MIXER_VALUES.m_vDopplerOffset.y)) * MIXER_VALUES.m_vPan);\n#else\n\t#define MIX(SAMPLE_FN, TIME, MIXER_VALUES) (SAMPLE_FN(TIME + dot(MIXER_VALUES.m_vDopplerOffset, vec2(0.5))) * MIXER_VALUES.m_vPan);\n#endif\n\n/////////////////////////////////////\n\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 / decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time/attack;//exp2( -(attack - time) * (5.0 / attack) );\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\n\nfloat Envelope( float time, float attack, float sustain, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time/attack;//exp2( -(attack - time) * (5.0 / attack) );\n\t}\n\n\ttime -= attack;\n\t\n\tif(time < sustain)\n\t{\n\t\treturn 1.0;\n\t}\n\n\ttime -= sustain;\n\t\n\treturn Envelope( time, decay );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\nfloat Hash( float x )\n{\n\treturn fract(sin(x * 1.2345678)*123456.78);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result / tot;\n}\n\n//////////////////////////////////////\n/*\nfloat GetSource0Sample(float t)\n{     \n    //return 0.0;\n    return Square(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n\n    //return FBM( t * 30.0, 0.5 );\n    //return Square(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    //return Saw(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    //return Cos(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    //return Tri(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n}\n\nvec3 GetSource0Pos(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n*/\n\nfloat GetSource0Sample(float t)\n{        \n    float s = FBM( t * 30.0 , 0.6 ) * 1.0\n        + Saw(t*(440.0 - g_sceneState.fCarVel)) * 0.1\n        + FBM( t * 30.0 , 0.4 ) * 2.0 * -g_sceneState.fCarVel / 300.0;\n        \n    return s;\n}\n\nvec3 GetSource0Pos(float t)\n{\n    return g_sceneState.vCarPos + vec3( 0.0, 0.0, 0.0 );\n}\n\n\nfloat GetSource1Sample(float t)\n{        \n    float s = FBM( t * 20.0 , 0.2 ) * 1.0 * g_sceneState.fThruster;\n        \n    return s;\n    // + Saw(220.1*t + 0.5) * 0.5;\n    \n    //return FBM( t * 30.0, 0.5 );\n    //return Square(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    //return Saw(220.1*t + 0.5);// * Envelope(fract(t), 0.05, 0.95);\n    //return Cos(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    //return Tri(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n}\n\nvec3 GetSource1Pos(float t)\n{\n    return g_sceneState.vCarPos + vec3( 0.0, 1.0, 5.8 );\n}\n\nfloat FBoom( float t )\n{\n    float fResult = 0.0;\n    \n    float a = 1.0;\n    \n    for ( int i=0; i<10; i++)\n    {      \n        if ( t > 0.0 )\n        {\n            fResult += SmoothNoise( t * 100.0 )*exp(-8.0*t) * a;\n       \t}\n        t -= 0.2;        \n\t    a *= 0.4;\n    }\n    return fResult;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float iTime = time;\n    \n    CameraState cam;       \n    GetSceneState( g_sceneState, cam, time );\n    \n\tvec3 vCameraCurrPos = cam.vPos;\n    mat3 mCameraCurrRot = Cam_GetWorldToCameraRotMatrix( cam );    \n    \n    C_Listener listener;\n    SetupListener( listener, vCameraCurrPos, mCameraCurrRot );\n\n    g_SourceInfo[0].m_Pos = GetSource0Pos(time);\n    g_SourceInfo[0].m_Volume = 50.0;\n\n    g_SourceInfo[1].m_Pos = GetSource1Pos(time);\n    g_SourceInfo[1].m_Volume = 50.0;\n    \n    vec2 vResult = vec2(0.0);    \n\n    C_MixerValues mixerValues;\n\n    GetMixerValues( listener, g_SourceInfo[0], mixerValues );\n    vResult += MIX( GetSource0Sample, time, mixerValues );\n\n    GetMixerValues( listener, g_SourceInfo[1], mixerValues );\n    vResult += MIX( GetSource1Sample, time, mixerValues );\n\n    vResult += FBoom( time - 61.85 ) * 8.0;\n    \n    if ( time < 8.0 || time > 75.0 )\n    {\n        vResult = vec2(0.0);\n    }\n    \n    return vResult;   \n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            },
            {
                "code": "// Scene Render\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10.0\n\n#define PI 3.141592654\n\n///////////////////////////\n// Data Storage\n///////////////////////////\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    cam.vPos = LoadVec3( sampler, addr + ivec2(0,0) );\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + vec2(0,0), cam.vPos, fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y / iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n///////////////////////////\n// Scene\n///////////////////////////\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n    float mint = 0.02, tmax = 2.5;\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n///////////////////////////\n// Lighting\n///////////////////////////\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n///////////////////////////\n// Rendering\n///////////////////////////\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n    vec3 vRayOrigin = vInRayOrigin;\n    vec3 vRayDir = vInRayDir;\n    \n\tvec3 vResultColor = vec3(0.0);\n\tvec3 vPassContribution = vec3(1.0);\n            \n\tSceneResult firstTraceResult;\n    \n\tfor( int iPassIndex=0; iPassIndex<3; iPassIndex++ )\n\t{\t        \n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, kMaxTraceDist );\n        \n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n\t\tvec3 vPassColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.fObjectId < 0.0 )\n\t\t{\n            break; \n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -vRayDir), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvPassColor = \n                mix( surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive, surfaceLighting.vSpecular, vReflectance );\n        \n\t        vPassColor = Env_ApplyAtmosphere( vPassColor, vRayOrigin, vRayDir, traceResult.fDist );\t\t\n            \n            // Reflect Ray\n            vRayOrigin = surfaceInfo.vPos;\n            vRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n        }\n                \n\t\tvResultColor += vPassColor * vPassContribution;\n\t\tvPassContribution *= vReflectance;\t\t\t        \n    }\n    \n    vec4 vFinalSkyColor = Env_GetSkyColor( vRayOrigin, vRayDir );\n    vFinalSkyColor.rgb = Env_ApplyAtmosphere( vFinalSkyColor.rgb, vRayOrigin, vRayDir, vFinalSkyColor.a );\t\t\n\tvResultColor += vFinalSkyColor.rgb * vPassContribution;\n    \n    vResultColor = FX_Apply( vResultColor, vInRayOrigin, vInRayDir, firstTraceResult.fDist );\n    \n    if ( firstTraceResult.fObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n    \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////\n// Utility Functions\n///////////////////////////\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<4; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n\n/////////////////////////\n// Scene Description\n/////////////////////////\n\n// Materials\n\n#define MAT_SKY \t\t-1.0\n#define MAT_MOUNTAIN \t0.0\n#define MAT_SAND \t\t2.0\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0); //fract( surfaceInfo.vPos + 0.1 );\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 0.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    surfaceInfo.vR0 = vec3( 0.01 );\n    vec3 vSand = texture( iChannel2, surfaceInfo.vPos.xz * 0.01).rgb;\n    vSand = vSand * vSand;\n    vec3 vMountain = texture( iChannel1, surfaceInfo.vPos.xz * 0.01).rgb;\n    vMountain = vMountain * vMountain;\n    \n    surfaceInfo.vAlbedo = mix(vSand, vMountain, clamp( surfaceInfo.vPos.y * 0.2, 0.0, 1.0) ); \n    \n    //surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vec3(1,1,1), clamp( (surfaceInfo.vPos.y - 55.0) * 0.2, 0.0, 1.0) ); \n            \n    \n    return surfaceInfo;\n}\n\n// Scene Description\n\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_SKY, vec3(0.0) );\n    \n\n    float fMountainDist = 50.0 - length(vPos.xz);\n    float fAngle = atan( vPos.x, vPos.z );\n    fMountainDist = max( fMountainDist, vPos.y - 10.0 + sin( fAngle * 50.0 ) * 5.0);\n    \n//    result = Scene_Union( result, SceneResult( fMountainDist, MAT_MOUNTAIN, vec3(0.0) ) );\n    //result = Scene_Subtract( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    //result = Scene_Intersection( result, SceneResult( length( vPos - vec3( 0, 3, 0 ) ) - 1.9, MAT_CHROME, vec3(0.0) ) );\n    \n\t//float fHeight = 0.0;//1.0 - texture( iChannel1, vPos.xz * 0.1 - vec2(0, iTime) ).r;\n    \n    float fHeight = FBM_DXY( vPos.xz * 0.005, vec2(0.0), 0.8, -0.1).z;\n    fHeight = fHeight* fHeight * fHeight * fHeight;\n    fHeight = fHeight * 200.0;\n    fHeight = fHeight * (1.0 - exp2( length( vPos.xz ) * -0.003 ) );\n    \n    result = Scene_Union( result, SceneResult( vPos.y - fHeight, MAT_SAND, vec3(0.0) ) );\n                                              \n/*    float l = length( vPos.xz );\n    result = Scene_Union( result, SceneResult( vPos.y - 2.0 + exp(-l * 0.1) * 4.0, MAT_SAND, vec3(0.0) ) );\n    result = Scene_Union( result, SceneResult( vPos.y \n//                                              + sin(iTime + vPos.x * 8.0) * 0.02\n//                                              + sin(iTime * 2.0 + vPos.z * 8.0) * 0.02\n//                                              + sin(iTime * 3.0 + vPos.x * 10.0) * 0.01\n//                                              + sin(iTime * 4.0 + vPos.z * 10.0) * 0.01\n                                              , MAT_WATER, vec3(0.0) ) );*/\n        \n    return result;\n}\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, -0.8));\nvec3 g_vSunColor = vec3(1, 0.5, 0.25) * 5.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    //Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(-2.0, 5.0, 0.0), vec3( 0.5, 1, 0.5 ) );\n    \n    float fAO = 1.0;//Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * vec3(0.5, 1, 1);\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4(0.0);\n\t\n    vResult.rgb = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n\n\n    // Cloud\n    float fCloud = texture( iChannel3, vViewDir.xz * 0.01 / vViewDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult.rgb = mix( vResult.rgb, vec3(8.0), fCloud );\n    \n    \n    // Sun\n    //float NdotV = dot( g_vSunDir, vViewDir );\n    //vResult += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 2000.0;\n    \n    vResult.w = kFarDist;\n    \n\treturn vResult;\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n    return vColor;\n    /*\n\tfloat fFogFactor = Env_GetFogFactor( fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\n\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor);\n    \n    return mix( vFogColor, vColor, fFogFactor );\t    \n\t*/\n}\n\n// FX\n\nvec4 FX_ColDensity( vec3 vPos )\n{\n    float density = 0.0;\n    if (length( vPos ) < 5.0 )\n        density = 0.02;\n    return vec4(10,10,10, density);\n}\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{\n/*    float t= 0.03;\n    float f = 1.0;\n    for(int iter=0; iter<64; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = FX_ColDensity( p );\n        vec4 vEffect2 = FX_ColDensity( p + g_vSunDir * 0.1 ) ;\n        \n        vEffect.xyz *= clamp( (vEffect.w - vEffect2.w) / 0.1, 0.0, 1.0 );\n        \n        vColor = mix(vColor, vEffect.rgb, f * vEffect.w);\n        f = f * (1.0 - vEffect.w);\n        \n\t\tt += (0.04+t*0.012);        \n    }    */\n    \n    return vColor;\n}\n\n// Camera \n\nCameraState GetCameraState()\n{\n    CameraState camera;\n    \n    float fAngle = (iMouse.x / iResolution.x) * 3.14 * 2.0;\n    float fDist = 15.0;\n    \n    float fHeight = (iMouse.y / iResolution.y) * 15.0;\n    \n    camera.vPos = vec3( sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist );\n    camera.vTarget = vec3( 0.0, 2.0, 0.5 );\n    camera.fFov = 25.0;\n    \n    return camera;\n}\n\n/*\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n    vec4 vOldData = LoadVec4( iChannel0, ivec2(0,0) );\n \n    \n    vec3 vRayOrigin, vRayDir;\n\n// Environment map render\n#if 1\n    // Passthrough shader if previous value was valid\n\tif ( iFrame > 0 && vOldData.x == iResolution.x && vOldData.y == iResolution.y )\n    {\n        vFragColor = texture( iChannel0, vUV );\n        return;\n    }\n    \n    vRayOrigin = vec3(0.0, 1.0, 0.0);\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n    \n    float fHeading = vUV.x * PI;\n    if ( vUV.y > 0.5 )\n    {\n\t    vUV.y = 1.0 - vUV.y;\n        fHeading += PI;\n    }\n    float fElevation = mix( fSkyElevationMin, fSkyElevationMax, vUV.y * 2.0 );\n    \n    vRayDir.x = sin( fHeading ) * cos( fElevation );\n    vRayDir.y = sin( fElevation );\n    vRayDir.z = cos( fHeading ) * cos( fElevation );\n#else    \n    CameraState cam = GetCameraState();\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n#endif\n    \n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n\n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    //vFragColor.r = fract( atan(vRayDir.x, vRayDir.z) / (PI * 2.0) );\n    \n    // Debug update frequency\n    //vFragColor.r = fract( iTime * 10.0 );\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n\n    vec4 textureA = texture( iChannel1, vec2(0,0) );\n    vec4 textureB = texture( iChannel2, vec2(0,0) );\n    vec4 textureC = texture( iChannel3, vec2(0,0) );\n\n    vec4 vFrameData = vec4( 0 );\n    // Don't stamp output as valud until input textures have loaded\n    if ( length(textureA.rgb) > 0.01 && length(textureB.rgb) > 0.01 && length(textureC.rgb) > 0.01 )\n    {  \n        vFrameData =  vec4( floor(iResolution.x), floor(iResolution.y), 0, 0 );\n    }\n    \n    StoreVec4( vec2(0,0), vFrameData, vFragColor, vFragCoord );\n}\n*/\n\nvoid mainCubemap( out vec4 vFragColor, in vec2 fragCoord, in vec3 vRayOrigin, in vec3 vRayDir )\n{\n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vec3(0, 1, 0), vRayDir );    \n\n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vFragColor = vColorLinAmdDepth;\n    \n    //vFragColor.r = fract( atan(vRayDir.x, vRayDir.z) / (PI * 2.0) );\n    \n    // Debug update frequency\n    //vFragColor.r = fract( iTime * 10.0 );\n    \n    if ( vColorLinAmdDepth.r > 40000.0 || vColorLinAmdDepth.g > 40000.0 || vColorLinAmdDepth.b > 40000.0 )\n    {\n        vFragColor = vec4(0.0);\n    }\n\n    if ( iFrame > 60 )\n    {\n        discard;\n    }\n    \n    /*\n    vec4 textureA = texture( iChannel1, vec2(0,0) );\n    vec4 textureB = texture( iChannel2, vec2(0,0) );\n    vec4 textureC = texture( iChannel3, vec2(0,0) );\n\n    vec4 vFrameData = vec4( 0 );\n    // Don't stamp output as valud until input textures have loaded\n    if ( length(textureA.rgb) > 0.01 && length(textureB.rgb) > 0.01 && length(textureC.rgb) > 0.01 )\n    {  \n        vFrameData =  vec4( floor(iResolution.x), floor(iResolution.y), 0, 0 );\n    } \n\t*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}