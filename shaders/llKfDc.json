{
    "Shader": {
        "info": {
            "date": "1549611507",
            "description": "Reimplementation of [url]https://www.shadertoy.com/view/4lsfzj[/url] with more surfaces, more transformations and better performance. Still just 27 lines though.",
            "flags": 49,
            "hasliked": 0,
            "id": "llKfDc",
            "likes": 8,
            "name": "Clebsch, Cayley & Other Cubics",
            "published": 3,
            "tags": [
                "raytrace",
                "cubic",
                "clebsch",
                "cayley",
                "27lines"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 604
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Clebsch, Cayley and other cubic surfaces\n//\n// The equation:\n//\n// X^3+Y^3+Z^3+k*T^3 = (X+Y+Z+T)^3\n//\n// in homogenous coordinates X,Y,Z,T, with parameter k, defines a cubic surface.\n//\n// k == 1.0: the Clebsch cubic surface, with 27 real lines, and\n// 10 Eckardt points where 3 of the lines meet.\n// k > 0.25: there are also 27 lines, but with fewer Eckhardt points.\n// k = 0.25: the Cayley cubic surface, with 4 nodal points and 9 lines.\n// 0 < k < 0.25: the surface is disconnected, with 3 lines in the main component.\n// k == 0: there is a single separate point\n// k < 0: the surface has a single component, containing 3 lines.\n//\n// Controls:\n// <Mouse>,<Up>,<Down> Change viewpoint\n// 'c': clip to sphere\n// 'l': show lines only\n// 'm': model transform\n// 'q': R4 quaternion rotation\n// 'r': rotate around y axis\n// 's': surface type: varying, Clebsch, Cayley\n// 'v': align surface vertically\n// 'x': show indication of settings\n//\n////////////////////////////////////////////////////////////////////////////////\n\n//const float PI =  3.141592654;\n\nconst float lwidth = 0.04;\nconst float lwidth2 = lwidth*lwidth;\nconst float scale = 1.0;\nconst float camera = 8.0;\nconst float clipradius = 5.0;\nconst float clipradius2 = clipradius*clipradius;\nbool linesonly = false;\nbool vertical = false;\nbool clipsphere = false;\nbool dorotate = false;\nint mtype = 0;\nint qtype = 0;\nint stype = 0;\n\nvec4 K; // K.w is cubic parameter. 1.0 is Clebsch, 0.25 is Cayley\nmat4 M, MINV; // P4 transformation and inverse\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// Quaternion multiplication as a matrix.\n// w coordinate is real element of quaternion\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y, x, \n               z, t,-x, y,\n              -y, x, t, z,\n              -x,-y,-z, t );\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\n// Returns matrix that reflects in n, optimized\nmat4 reflection(vec4 n) {\n  float k = 2.0/dot(n,n);\n  return mat4(1)-k*mat4(n.x*n, n.y*n, n.z*n, n.w*n);\n}\n\n// Rotate p to q.\n// p and q should be the same length!\nmat4 rotation(vec4 p, vec4 q) {\n  return reflection(-q)*reflection(p+q);\n}\n\n// Calculate the parameters for the last 12 lines.\n// I can't find my notes about how all this works.\nfloat beval(float a, float A, float B, float z, float w) {\n  return -0.5*(2.0*a*a*z + A + B)/(w*w - a*a);\n}\n\nfloat feval(float a, float A, float B, float z, float w) {\n  float b = beval(a,A,B,z,w);\n  float t = 2.0*(b*b*(-a + w) + a*z*z) + A - B;\n  return t;\n}\n\nvec2 lineparams(float K, float z, float w) {\n  float A = (K*8.0 + z*z*z + w*w*w - 1.0)/3.0;\n  float B =  z*z*w-z*w*w;\n  float eps = 1e-2;\n  float x0 = abs(w) + eps, f0 = feval(x0,A,B,z,w);\n  float x1 = x0 + eps, f1 = feval(x1,A,B,z,w);\n  // Start from abs(w) search for a bracketing interval\n  while (f1 < 0.0) {\n    float t = 2.0*x1 - x0;\n    x0 = x1; f0 = f1;\n    x1 = t; f1 = feval(x1,A,B,z,w);\n  }\n  // And apply bisection.\n  // Secant method doesn't help much here.\n  for (int i = 0; i < 10; i++) {\n    float x2 = (x0+x1)/2.0;\n    float f2 = feval(x2,A,B,z,w);\n    if (f2 < 0.0) {\n      x0 = x2; f0 = f2;\n    } else {\n      x1 = x2; f1 = f2;\n    }\n  }\n  float a = (x0+x1)/2.0;\n  return vec2(a,beval(a,A,B,z,w));\n}\n\nvec3 getColor(int i) {\n  if (i == -1) return vec3(0,0,0);\n  if (i == 0) return vec3(0.5,0.5,1);\n  if (i == 1) return vec3(1,0,0);\n  if (i == 2) return vec3(0,0,1);\n  if (i == 3) return 0.8*vec3(1);\n  if (i == 4) return vec3(1,1,0);\n  if (i == 5) return vec3(1,1,0);\n  if (i == 6) return vec3(1,1,0);\n  //if (i == 4) return vec3(0,1,0);\n  //if (i == 5) return vec3(0,1,1);\n  //if (i == 6) return vec3(1,0,1);\n  if (i == 7) return vec3(0.5,0.5,0.1);\n  return vec3(0);\n}\n\nfloat eval(vec4 p) {\n  // p is in world coordinates\n  p *= M;\n  float pI = dot(p,vec4(1));\n  return dot(K*p*p,p) - pI*pI*pI;\n}\n\n// X^3+Y^3+Z^3+K0*T^3 = (X+Y+Z+T)^3\n// Equation is: Kpp.p - (p.I)^3 = 0\n// A = Krr.r - (r.I)^3\n// B = 3(Krr.p -(p.I)(r.I)^2)\n// C = 3(Kpp.r -(p.I)^2(r.I))\n// D = Kpp.p - (p.I)^3\nint surface(vec4 p, vec4 r, float min, out vec3 t) {\n  vec4 I = vec4(1);\n  float pI = dot(p,I);\n  float rI = dot(r,I);\n\n  float A = dot(K*r*r,r) - rI*rI*rI;\n  float B = 3.0*(dot(K*r*r,p) - rI*rI*pI);\n  float C = 3.0*(dot(K*p*p,r) - pI*pI*rI);\n  float D = dot(K*p*p,p) - pI*pI*pI;\n\n  int nroots;\n  if (keypress(CHAR_Z) && abs(A) < abs(D)) {\n    nroots = cubic(vec4(D,C,B,A),t);\n    for (int i = 0; i < nroots; i++) {\n      t[i] = 1.0/t[i];\n    }\n  } else {\n    nroots = cubic(vec4(A,B,C,D),t);\n  }\n  if (nroots > 1 && t.x > t.y) t.xy = t.yx;\n  if (nroots > 2 && t.y > t.z) t.yz = t.zy;\n  if (nroots > 2 && t.x > t.y) t.xy = t.yx;\n  return nroots;\n}\n\n// Find the distance to the line in R3 but using\n// P4 coordinates.\nvoid tryline(vec4 p, vec4 q, vec4 r, int color,\n             inout float d2best, inout int colorindex) {\n  // Rotate lines in P4 so they project to correct\n  // position in R3 before calculating distance.\n  q = q*MINV; r = r*MINV;\n  if (abs(q.w) < abs(r.w)) {\n    vec4 t = q; q = r; r = t;\n  }\n  if (abs(q.w) < 1e-2) return;\n   r = q.w*r - r.w*q; // r.w = 0\n   p = q.w*p-q;\n   float pr = dot(p,r);\n   float d2 = (dot(p,p) - (pr*pr/dot(r,r)))/(q.w*q.w);\n   if (d2 < d2best) {\n      d2best = d2;\n      colorindex = color;\n   }\n}\n\nvoid trylines(vec4 p,float k,\n              inout float d2best,inout int colorindex) {\n#define tryline(x0,y0,z0,w0,x1,y1,z1,w1,c) \\\n  tryline(p,vec4(x0,y0,z0,w0),vec4(x1,y1,z1,w1),c,d2best,colorindex)\n  // It's tempting to put the lines in an array, but this\n  // performs badly on my laptop, perhaps a shortage of registers.\n  if (true) {\n    tryline(1,0,0,0, 0,1,-1,0, 3);\n    tryline(0,1,0,0, 1,0,-1,0, 3);\n    tryline(0,0,1,0, 1,-1,0,0, 3);\n  }\n  if (k >= 0.25) {\n    float A = 3.0, B = 3.0, C = 1.0-k;\n    float z0 = (-B - sqrt(B*B-4.0*A*C))/(2.0*A);\n    float z1 = (-B + sqrt(B*B-4.0*A*C))/(2.0*A);\n    if (true) {\n      tryline(0,0,z0,1, 1,-1,0,0, 4);\n      tryline(0,z0,0,1, 1,0,-1,0, 5);\n      tryline(z0,0,0,1, 0,1,-1,0, 6);\n      tryline(0,0,z1,1, 1,-1,0,0, 4);\n      tryline(0,z1,0,1, 1,0,-1,0, 5);\n      tryline(z1,0,0,1, 0,1,-1,0, 6);\n      tryline(z0,z1,0,1, 0,0,1,0, 4);\n      tryline(z0,0,z1,1, 0,1,0,0, 5);\n      tryline(0,z0,z1,1, 1,0,0,0, 6);\n      tryline(z1,z0,0,1, 0,0,1,0, 4);\n      tryline(z1,0,z0,1, 0,1,0,0, 5);\n      tryline(0,z1,z0,1, 1,0,0,0, 6);\n    }\n    if (k == 0.25) return;\n    vec2 t = lineparams(k,z0,z1);\n    float a = t[0], b = t[1];\n    tryline(a,-a,z0,1, b,z1,-b,1, 1);\n    tryline(a,z0,-a,1, b,-b,z1,1, 2);\n    tryline(-a,z0, a,1, z1,-b, b,1, 1);\n    tryline(-a,a,z0,1, z1, b,-b,1, 2);\n    tryline(z0, a,-a,1, -b, b,z1,1, 1);\n    tryline(z0,-a, a,1, -b,z1, b,1, 2);\n        \n    tryline(-b,z0,b,1, -a,a,z1,1, 1);\n    tryline(-b,b,z0,1, -a,z1,a,1, 2);\n    tryline(b,-b,z0,1, z1, -a,a,1, 1);\n    tryline(b,z0, -b,1, z1,a, -a,1, 2);\n    tryline(z0,b, -b,1, a,z1, -a,1, 1);\n    tryline(z0, -b,b,1, a, -a,z1,1, 2);\n  }\n#undef tryline\n}\n\nbool doscale = false;\nvec3 solve(vec4 p, vec4 r, float min, float k) {\n  M = mat4(1);\n  float theta = 0.0;\n  theta = iTime*0.2;\n  if (doscale) {\n    mat4 scalemat = mat4(1,0,0,0,\n                         0,0.2,0,0,\n                         0,0,1,0,\n                         0,0,0,0.5);\n    M  *= scalemat;\n  }\n  if (qtype == 0) {\n    // Quaternion rotation (one sided)\n    vec3 a = normalize(vec3(1,1,1));\n    M *= qmat(vec4(-sin(theta)*a,cos(theta)));\n  } else if (qtype == 1) {\n    vec3 a = vec3(0,1,0);\n    M *= qmat(vec4(-sin(theta)*a,cos(theta)));\n  } else if (qtype == 2) {\n    M *= mat4(cos(theta),0,sin(theta),0,\n              0,1,0,0,\n              -sin(theta),0,cos(theta),0,\n              0,0,0,1);\n  } else if (qtype == 3) {\n      // Nothing\n  }\n  if (vertical) {\n    M *= rotation(vec4(1,1,1,0), vec4(0,sqrt(3.0),0,0));\n  }\n  if (mtype == 1) {\n    mat4 m0 = mat4(-1,1,1,1,\n                   1,-1,1,1,\n                   1,1,-1,1,\n                   -1,-1,-1,1);\n    M *= m0;\n  } else if (mtype == 2) {\n    mat4 m0 = mat4(-1,1,1,-1,\n                   1,-1,1,-1,\n                   1,1,-1,-1,\n                   1,1,1,1);\n    M *= m0;\n  } else if (mtype == 3) {\n    mat4 m0 = mat4(-1,1,1,1,\n                   1,-1,1,1,\n                   1,1,-1,1,\n                   0,0,0,-4);\n    M *= m0;\n  } else if (mtype == 4) {\n    mat4 m0 = mat4(1,0,0,0,\n                   0,1,0,0,\n                   0,0,1,0,\n                  -1,-1,-1,-1);\n    M *= m0;\n  }\n  MINV = inverse(M);\n\n  vec3 res;\n  // Don't try to renormalize r here!\n  // We are now in P4\n  int nroots = surface(p*M,r*M,min,res);\n  vec3 color = vec3(0);\n  int start = 0;\n  for (int i = 0; i < nroots; i++) {\n    if (res[i] > min) {\n      start = i+1;\n      break;\n    }\n  }\n  for (int i = 0; i < nroots; i++) {\n    float t = res[i];\n    if (t < min) continue;\n    vec4 p1 = p+t*r; // World coordinates\n    if (clipsphere && dot(p1.xyz,p1.xyz)/(p1.w*p1.w) > clipradius2) continue;\n    float d2best = lwidth2;\n    int colorindex = 0;\n    trylines(p1,k,d2best,colorindex);\n    if (linesonly && colorindex == 0) continue;\n\n    float x0 = eval(p1);\n    vec2 eps = vec2(1e-2,0);\n    vec3 normal = vec3(eval(p1+eps.xyyy)-x0,\n                       eval(p1+eps.yxyy)-x0,\n                       eval(p1+eps.yyxy)-x0);\n    normal = normalize(normal);\n    \n    if (dot(vec3(r),normal) > 0.0) {\n      normal = -normal; // Face forwards\n    }\n    vec3 baseColor = mix(getColor(colorindex),\n                         getColor(0),\n                         smoothstep(0.5*lwidth,lwidth,sqrt(d2best)));\n    vec3 c = baseColor*ambient;\n    c += baseColor*diffuse*(max(0.0,dot(light,normal)));\n    float specular = pow(max(0.0,dot(reflect(light,normal),vec3(r))),4.0);\n    c += 0.5*specular*vec3(1.0,1.0,1.0);\n    //color = (0.9*c + 0.2*color);\n    color = c;\n    //if (dot(p1.xyz,p1.xyz)/(p1.w*p1.w) > 50.0) color *= 0.5;\n    break;\n  }\n  return sqrt(color);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    //p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nint mtypecount = 5;\nint qtypecount = 4;\nint stypecount = 3;\n\nint getstate(int i) {\n  if (i < 0) return 0;\n  if (i < stypecount) return i == stype? 1: 2;\n  i -= stypecount+1;\n  if (i < 0) return 0;\n  if (i < qtypecount) return i == qtype? 1: 2;\n  i -= qtypecount+1;\n  if (i < 0) return 0;\n  if (i < mtypecount) return i == mtype? 1: 2;\n  i -= mtypecount+1;\n  return 0;\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fragCoord, vec3 p, vec3 r);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  //runtests(); // Unit tests on Shadertoy!\n  mtype = (0+keycount(CHAR_M))%mtypecount;\n  qtype = (0+keycount(CHAR_Q))%qtypecount;\n  stype = keycount(CHAR_S)%stypecount;\n  vertical = keypress(CHAR_V);\n  clipsphere = keypress(CHAR_C);\n  linesonly = keypress(CHAR_L);\n  dorotate = keypress(CHAR_R);\n  //qtype = 0; stype = 1; mtype = 0;\n  vec2 uv = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  vec3 p = vec3(0.0, 0.0, camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 r = normalize(vec3(uv, -3.0));\n\n  light = transform(light);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  \n  mainVR(fragColor, fragCoord, p,r);\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fragCoord, vec3 p, vec3 r) {\n   float k;\n  if (stype == 0) {\n    k = 1.0 + 1.0*sin(0.2*iTime);\n  } else if (stype == 1) {\n    k = 1.0;\n  } else if (stype == 2) {\n    k = 0.25;\n  }\n  K = vec4(1,1,1,k);\n\n  light = normalize(vec3(0.0,1.0,1.0));\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n\n float t = 0.0;//-dot(p,r);\n  p += t*r;\n  vec3 color = solve(vec4(p,1),vec4(r,0),-t,k);\n  if (keypress(CHAR_X)) {\n    int N = mtypecount+1+qtypecount+1+stypecount;\n    vec2 xy = float(N)*fragCoord.xy/iResolution.x;\n    xy.x -= 0.5;\n    float gridx = round(xy.x);\n    int i = int(gridx);\n    int state = getstate(i);\n    if (state != 0) {\n      vec3 c = state==1?vec3(1,1,0):vec3(1);\n      float width = 0.25;\n      float eps = 0.02;\n      color = mix(color,c,1.0-smoothstep(width-eps, width+eps,distance(xy, vec2(gridx,1.0))));\n    }\n  }\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define cubic cubic0\n//#define cubic blinn_cubic // Blinn solver from @nilrem's https://www.shadertoy.com/view/4s2yRm\n#define TAU 6.28318530718\n#define PI 3.141592654\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nbool qdrtc(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return false;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = (x1 < x2)? vec2(x1,x2): vec2(x2,x1);\n  return true;\n}\n  \nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\nint qbc(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    X -= s*r;\n      // Newton-Raphson, simplified from Kahan to use\n      // a fixed length loop.\n      for (int i = 0; i < 4; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        X -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n  }\n  res.x = X;\n  if (!qdrtc(A,b1,c2,res.yz)) return 1;\n  if (res.x > res.y) res.xy = res.yx;\n  if (res.y > res.z) res.yz = res.zy;\n  return 3;\n}\n\nint cubic0(vec4 coeffs, out vec3 res) {\n  float A = coeffs[0], B = coeffs[1], C = coeffs[2], D = coeffs[3];\n  return qbc(A,B,C,D,res);\n}\n\n// Some alterative cubic solvers.\n//https://www.shadertoy.com/view/4dsfRS\nint cubic1(vec4 coeffs, out vec3 res) {\n  float a = coeffs[1]/coeffs[0];\n  float b = coeffs[2]/coeffs[0];\n  float c = coeffs[3]/coeffs[0];\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        res[0] = offset + uv.x + uv.y;\n        return 1;\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    res = vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n    if (res.x > res.y) res.xy = res.yx;\n    if (res.y > res.z) res.yz = res.zy;\n    if (res.x > res.y) res.xy = res.yx;\n    return 3;\n}\n// Cubic bezier - Signed Distance - NinjaKoala\n// https://www.shadertoy.com/view/4sKyzW\nint cubic2(vec4 coeffs, inout vec3 r)\n{\n\n\tfloat a = coeffs[1]/coeffs[0];\n\tfloat b = coeffs[2]/coeffs[0];\n\tfloat c = coeffs[3]/coeffs[0];\n\n\tfloat p = b - a*a/3.;\n\tfloat q = a * (2.*a*a - 9.*b)/27. + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.*p3/27.;\n\tfloat offset = -a/3.;\n    \n\tif(d >= 0.0) { // Single solution.\n\t\t\n        /*\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z)/2.;\n\t\tfloat v = (-q - z)/2.;\n\t\tu = sign(u)*pow(abs(u), 1./3.);\n\t\tv = sign(v)*pow(abs(v), 1./3.);\n\t\tr[0] = offset + u + v;\t\n\t\t*/\n        \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n\n\t\t// CHANGE\n\t\t// Single newton iteration to account for cancellation.\n\t\tfloat f = ((r[0] + a)*r[0] + b)*r[0] + c;\n\t\tfloat f1 = (3.*r[0] + 2. * a)*r[0] + b;\n\n\t\tr[0] -= f/f1;\n\n\t\treturn 1;\n\t}\n    \n\tfloat u = sqrt(-p/3.);\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t// Single newton iteration to account for cancellation\n\t// (once for every root).\n\n\tfloat f,f1;\n\tr[0] = offset + u * (m + m);\n\n\tf = ((r[0] + a)*r[0] + b)*r[0] + c;\n\tf1 = (3.*r[0] + 2. * a)*r[0] + b;\n\n\tr[0] -= f / f1;\n\n\tr[1] = offset - u * (n + m);\n\n\tf = ((r[1] + a)*r[1] + b) * r[1] + c;\n\tf1=(3.*r[1] + 2. * a)*r[1] + b;\n\n\tr[1] -= f / f1;\n\n\tr[2] = offset + u * (n - m);\n\n\tf = ((r[2] + a)*r[2] + b)*r[2] + c;\n\tf1 = (3.*r[2] + 2. * a)*r[2] + b;\n\n\tr[2] -= f / f1;\n    if (r.x > r.y) r.xy = r.yx;\n    if (r.y > r.z) r.yz = r.zy;\n    if (r.x > r.y) r.xy = r.yx;\n\n\treturn 3;\n}\n\n// https://www.shadertoy.com/view/3tyczd by oneshade\nint cubic3(vec4 coeffs, out vec3 roots) {\n    float a=coeffs[0],b=coeffs[1],c=coeffs[2],d=coeffs[3];\n    float denom = 3.0 * a * a;\n    float inflection = -b / (3.0 * a);\n\n    float p = c / a - b * b / denom;\n    float q = 2.0 * b * b * b / (27.0 * a * a * a) - b * c / denom + d / a;\n\n    float discr = q * q / 4.0 + p * p * p / 27.0;\n    int numRoots = discr > 0.0 ? 1 : 3;\n\n    roots = vec3(0);\n    if (numRoots == 1) {\n        if (4.0 * p * p * p > -27.0 * q * q && p < 0.0) {\n            roots[0] = -2.0 * sign(q) * sqrt(-p / 3.0) * cosh(acosh(-3.0 * abs(q) / (2.0 * p) * sqrt(-3.0 / p)) / 3.0) + inflection;\n        }\n\n        if (p > 0.0) {\n            roots[0] = -2.0 * sqrt(p / 3.0) * sinh(asinh(3.0 * q / (2.0 * p) * sqrt(3.0 / p)) / 3.0) + inflection;\n        }\n    }\n\n    if (numRoots == 3) {\n        float tspt = 2.0 * sqrt(-p / 3.0);\n        float ac = acos(3.0 * q / (2.0 * p) * sqrt(-3.0 / p));\n        roots[0] = tspt * cos( ac              / 3.0) + inflection;\n        roots[1] = tspt * cos((ac -       TAU) / 3.0) + inflection;\n        roots[2] = tspt * cos((ac - 2.0 * TAU) / 3.0) + inflection;\n        if (roots.x > roots.y) roots.xy = roots.yx;\n        if (roots.y > roots.z) roots.yz = roots.zy;\n        if (roots.x > roots.y) roots.xy = roots.yx;\n    }\n\n    return numRoots;\n}\n\n// https://www.shadertoy.com/view/7tBGzK by oneshade\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float u = b / (3.0 * a);\n\n    // Depress to x^3 + px + q by substituting x-b/3a\n    // This can be found by substituting x+u and solving for u so that the x^3\n    // term gets eliminated (then of course dividing by the leading coefficient)\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n\n    // Everything blows up when p=0 so give this case special treatment\n    // Also, GLSL doesn't like negative pows(), even when its valid so we also have to treat this carefully.\n    if (abs(p) < 1e-9) { roots.x = -sign(q) * pow(abs(q), 1.0 / 3.0) - u; return 1; }\n\n    // Hyperbolic solution for one real root (see https://en.wikipedia.org/wiki/Cubic_equation)\n    if (4.0 * p * p * p + 27.0 * q * q > 0.0) { // Check depressed cubic discriminant\n        float ip = 3.0 / abs(p), sp = sqrt(ip), k = 0.5 * q * ip * sp;\n        if (p > 0.0) roots.x = -2.0 / sp * sinh(asinh(k) / 3.0) - u;\n        else roots.x = -2.0 / sp * cosh(acosh(abs(k)) / 3.0) * sign(q) - u;\n        return 1;\n    }\n\n    // Solve by mapping an inverse smoothstep between the critical points\n    // I found a whole lot simplified right out so now it probably looks rather obfuscated\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    // Factor out the root to solve for the rest as a quadratic\n    float h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u; // Undo the change in variable\n\n    return 3;\n}\n\nint cubic4(vec4 coeffs, out vec3 res) {\n  float A = coeffs[0], B = coeffs[1], C = coeffs[2], D = coeffs[3];\n  int nroots = solveCubic(A,B,C,D,res);\n  return nroots;\n}\n\n/*\nCC0 1.0 Universal (CC0 1.0)\nTo the extent possible under law, the author has waived all \ncopyright and related or neighboring rights to this work.\nhttp://creativecommons.org/publicdomain/zero/1.0\n*/\n\n//const float NaN = intBitsToFloat(~0);\nfloat NaN = uintBitsToFloat(0x7f800001u);\n\nfloat Linear(float b, float a)\n{\n    return -b / a;\n}\n\nint Quadratic(float c, float b, float a, out vec2 res)\n{\n    if (a == 0.) {\n        res[0] = Linear(c, b); // handle malformed eqn\n        return 1;\n    }\n    float n = b * b - 4. * a * c; // discriminant\n    if (n < 0.0) return 0;\n    res = .5 / a * (sign(a) * sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n    return 2;\n}\n\n\n// spalmer, https://www.shadertoy.com/view/flyGDD\n// http://en.wikipedia.org/wiki/Cubic_equation \"General cubic formula\"\n// evaluated using complex arithmetic only as much as absolutely required.\n//vec3 Cubic(float d, float c, float b, float a)\nint cubic5(vec4 coeffs, out vec3 res) {\n  float a = coeffs[0], b = coeffs[1], c = coeffs[2], d = coeffs[3];\n    if (a == 0.) {\n        return Quadratic(d, c, b, res.xy); // handle malformed eqn\n        return 2;\n    }\n    float h = 27.*a*a\n    , o = -1./3./a\n    , p = b*b - 3.*a*c\n    , j = (2.*b*b - 9.*a*c) * b\n    , q = j + h*d\n    , g = q*q - 4.*p*p*p // discriminant\n    ;\n    //vec3 r;\n    if (g > 0.) { // 1-root case all real arithmetic\n        float y = .5*(q + sqrt(g)), z = sign(y) * pow(abs(y), 1./3.); //scbrt(y);\n        res = vec3((b + z + p/z) * o, NaN, NaN);\n        return 1;\n    } else { // 3-root case requires complex arithmetic\n        const vec2 E = vec2(-.5, sqrt(.75)); // primitive cube root of complex unity\n        vec2 u = vec2(q, sqrt(-g)) // q +- sqrt(-g) complex result\n        , C = sin(vec2(acos(0.), 0.) + atan(u.y, u.x) / 3.) \n            * pow(.25 * dot(u, u), 1./6.) // inlined trigonometry\n        , s1 = vec2(E.x * C.x - E.y * C.y\n                  , E.x * C.y + E.y * C.x)\n        , s0 = vec2(E.x * C.x + E.y * C.y\n                  , E.x * C.y - E.y * C.x);\n        res = (vec3(\n            (1. + p / dot(C , C )) * C .x,\n            (1. + p / dot(s0, s0)) * s0.x,\n            (1. + p / dot(s1, s1)) * s1.x\n          ) + b) * o;\n        if (a < 0.)\n            res.xz = res.zx; // order 3-root case\n    }\n    return 3;\n}\n\nfloat cbrt(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0);\n}\n\nint CubicSpalmer(float d, float c, out vec3 roots) // b = 0, a = 1\n{\n    float l = c / 3.\n    , s = l*l*l\n    , m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        roots[0] = v - l / v; // Blinn single cbrt idea\n        return 1;\n    }\n    // 2 or 3 distinct roots\n    float t = atan(sqrt(-m), -sign(c)*(d));\n    roots = 2. * sign(l)*sqrt(l) * cos((t - PI * vec3(0,2,4))/3.);\n    return 3;\n}\n\n// solve x³ + cx + d = 0\nint CubicDepressed(float d, float c, out vec3 roots)\n{\n    //vec3 k = vec3(d, c, 0.);\n//    return Cubiciq(k); // ok\n//    return CubicBloxard(k); // ok\n//    return Cubiciq(d, c);\n//    return CubicBloxard(d, c); // ok\n//    return CubicCardano(d, c); // busted WIP\n//    return CubicSpalmerSaved(d, c);\n    return CubicSpalmer(d, c,roots);\n}\n\n// by spalmer\nint CubicDepress(vec4 k, out vec3 roots)\n{\n    float a = k.x, b = k.y/a, c = k.z/a, d = k.w/a, // a = 1.\n        x = b/-3.; // inflection point\n    int nroots = CubicDepressed((c - 2.*x*x)*x + d, c + b*x,roots);\n    roots += x;\n    return nroots;\n}\n\n// From https://www.shadertoy.com/view/4s2yRm by @nilrem\n// Finds roots of homogeneous cubic polynomial Ax³ + 3Bx² + 3Cx + D   (Ax³ + 3Bx²w + 3Cxw² + Dw³)\n// Algorithm by Jim Blinn, see https://courses.cs.washington.edu/courses/cse590b/13au/lecture_notes\n// This implementation directly converts the roots from homogeneous to cartesian space\nint blinn_cubic(vec4 a, out vec3 roots)\n{\n   float A = a[0], B = a[1]/3.0, C = a[2]/3.0, D = a[3];\n\n    // Hessian coefficients\n    float d_1 = A*C - B*B;\n    float d_2 = A*D - B*C;\n    float d_3 = B*D - C*C;\n\n    // Hessian determinant ( = cubic discriminant)\n    float d   = (4.0 * d_1 * d_3) - (d_2 * d_2);\n\n\n    if ( d <= 0.0 )     // one real root (a double root if d=0, a triple root if d_1=d_2=d_3=d=0)\n    {\n        // Subscript b for \"bar\", t for \"tilde\"\n\n        // Depressed polynomial coefficients\n        float A_t;  // A or D\n        float C_b;  // 1/2 H(t, u)\n        float D_b;  // J(t, u)\n\n        // save predicate B³D >= AC³ to avoid multiple evaluations\n        bool B3D_ge_AC3 = B*B*B*D >= A*C*C*C;\n\n        if ( B3D_ge_AC3 )\n        {\n            // Algorithm A, t = 1, u = 0\n            A_t = A;\n            C_b = d_1;\n            D_b = -2.0 * B * d_1 + A * d_2;\n        } else\n        {\n            // Algorithm D, t = 0, u = 1  (reversed order of coefficients)\n            A_t = D;\n            C_b = d_3;\n            D_b = -D * d_2 + 2.0 * C * d_3;\n        }\n\n        float T0   = -sgn(D_b) * abs(A_t) * sqrt(-d);\n        float T1   = -D_b + T0;\n        float p    = cbrt( T1*0.5 );\n        float q    = T1 == T0  ? -p : -C_b/p;\n        float x_t1 = C_b <= 0. ? p + q : -D_b / (p*p + q*q + C_b);\n\n        // Get back from tilde'ed space to homogeneous space and invert result if algorithm D\n        float x1   = B3D_ge_AC3 ? x_t1 - B : -D;\n        float w1   = B3D_ge_AC3 ? A : x_t1 + C;\n\n        // Convert from homogeneous to cartesian space\n        roots.x    = x1/w1;\n    }\n    else    // d > 0    // three real roots (with potentially one double root)\n    {\n        // variables subscripted with A and D according to algorithms A and D\n        // t is the angle theta\n        // x_L/w_L is the first root, x_S/w_S the second root, x_M/w_M the third root\n\n        // Use both algorithms A and D to find the first two roots\n        // Same C_b and D_b as before, according to algorithm A's and D's choices of t,u\n\n        // 0.866025403784 -> sqrt(3)/2\n\n        // Algorithm A\n        float C_bA  = d_1;\n        float D_bA  = -2.0 * B * d_1 + A*d_2;\n\n        float t_A   = 0.333333333333 * abs( atan( A*sqrt(d), -D_bA) );\n        float x_t1A = 2.0 * sqrt(-C_bA) * cos( t_A );\n        float x_t3A = 2.0 * sqrt(-C_bA) * ( -0.5 * cos(t_A) - 0.866025403784 * sin(t_A) );\n        float x_tL  = (x_t1A + x_t3A > 2.0 * B) ? x_t1A : x_t3A;\n\n        // Get back from tilde'ed space, same as before\n        float x_L   = x_tL - B;\n        float w_L   = A;\n\n        roots.x     = x_L/w_L;\n\n\n        // Algorithm D\n        // same as Algorithm A except for choice of t,u (and thus inverted result)\n        float C_bD  = d_3;\n        float D_bD  = -D * d_2 + 2.0 * C * d_3;\n\n        float t_D   = 0.333333333333 * abs( atan( D*sqrt(d), -D_bD) );\n        float x_t1D = 2.0 * sqrt(-C_bD) * cos( t_D );\n        float x_t3D = 2.0 * sqrt(-C_bD) * ( -0.5 * cos(t_D) - 0.866025403784 * sin(t_D) );\n        float x_tS  = (x_t1D + x_t3D < 2.0 * C) ? x_t1D : x_t3D;\n\n        // Get back from tilde'ed space, same as before\n        float x_S   = -D;\n        float w_S   = x_tS + C;\n\n        roots.y     = x_S/w_S;\n\n\n        // Third root from the first two (no more to and from tilde'ed space here)\n        float E   =  w_L * w_S;\n        float F   = -x_L * w_S - w_L * x_S;\n        float G   =  x_L * x_S;\n\n        float x_M =  C*F - B*G;\n        float w_M = -B*F + C*E;\n\n        roots.z   = x_M/w_M;\n    }\n\n    return d <= 0.0 ? 1 : 3;   // return number of roots\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}