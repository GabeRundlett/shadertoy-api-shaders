{
    "Shader": {
        "info": {
            "date": "1502033967",
            "description": "This is my first try at making a water scene with raymarching. Most of the things that compose this scene are just wrong and not physically based, I just tried to use things that came to my mind that could look ok.",
            "flags": 0,
            "hasliked": 0,
            "id": "4slBD2",
            "likes": 20,
            "name": "Water scene",
            "published": 3,
            "tags": [
                "clouds",
                "water",
                "scene"
            ],
            "usePreview": 1,
            "username": "piluve",
            "viewed": 2122
        },
        "renderpass": [
            {
                "code": "/*\n\tWater scene - nachocpol@gmail.com\n*/\n\n#define AA 1\n\nconst float kE  = 2.71828;\nconst float kPi = 3.14159265359;\n\nconst int kSteps = 246;\nconst float kMinD = 1.0;\nconst float kMaxD = 300.0;\nconst float kDelD = 0.01;\n\nconst vec3 kSunColor = vec3(1.0,0.7,0.5);\nconst vec3 kToSun = vec3(0.4,0.35,-0.8);\n\nstruct Hit\n{\n    float Dist;\n    float MaterialId;\n};\n\n/*\n\tBase 2d noise function.\n\t[0,1]\n*/\nvec3 noise( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n/*\n\tBase 3d noise function.\n\t[0,1]\n*/\nfloat noise3D( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n   \t\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,17)*q.z;\n\n\tvec2 rg = mix( mix( texelFetch( iChannel1, (uv           )&255, 0 ),\n\t\t\t\t        texelFetch( iChannel1, (uv+ivec2(1,0))&255, 0 ), f.x ),\n\t\t\t\t   mix( texelFetch( iChannel1, (uv+ivec2(0,1))&255, 0 ),\n\t\t\t\t        texelFetch( iChannel1, (uv+ivec2(1,1))&255, 0 ), f.x ), f.y ).yx;    \n    \n\treturn mix( rg.x, rg.y, f.z );\n    // return -1.0+2.0*mix( rg.x, rg.y, f.z ); [-1,1]\n}\n\nfloat noise3DFbm5(vec3 p)\n{\t\n    const int iter = 5;\n    float n = 0.0;\n    float f = 1.0;\n    float a = 1.0;\n    for(int i=0;i<iter;i++)\n    {\n        n += noise3D(p * f) * a;\n        f*=2.7;\n        a*=0.45;\n    }\n    return n/float(iter);\n}\n\nvec3 Translate(vec3 p,vec3 t)\n{\n    return p - t;\n}\n\nfloat Cube(vec3 p,vec3 size)\n{\n    return length(max(abs(p)-size,0.0));\n}\n\nfloat Sphere(vec3 p,float rad)\n{\n    return length(p) - rad;\n}\n    \nfloat Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat Plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat Water(vec3 p)\n{\n    // To-Do normalize in the FBM!?\n    \n    float t = iTime * 0.75;\n    \n    // Gravity waves\n    // Using gerstner could work better in this case as\n    // gravity waves are more constant, it would also give\n    // the chance to add the choppyness parameter\n    float wg = 0.0;\n    float ag = 1.78;\n    float fg = 0.15;\n    for(int i = 0; i < 3; i++)\n    {\n        float n = noise((p.xz * fg) + t).x;\n        // The noise, or the plane equation is reversed, so \n        // here we flip the noise (I should actually check where \n        // does the problem come from)\n        n = -pow(n,1.6);\n        wg += n * ag;\n        ag *= 0.25;\n        fg *= 2.7;\n    }\n    \n    // Choppy waves\n    // By choppy waves, I refer to waves with sharp edges that are\n    // generated by the wind.\n    // Here I'm generating it with some fractal noise.\n    // More than 6 iterations won't add much to the image.\n    // Also, for the height pass we could remove some of the iterations or\n    // even remove the choppy waves as the normals will give lots of details\n    float wc = 0.0;\n    float ac = 0.5;\n    float fc = 0.4;\n    for(int i = 0;i<5;i++)\n    {\n        float n = noise((p.xz * fc) + (t*1.15)).x;\n        n = (n * 2.0) - 1.0;\n        wc += n*ac;\n        ac *= 0.23;\n        fc *= 3.0; // High values will start to cause more spec aliasing\n    }\n    wc = abs(wc);\n\t\n    float w = (wg) + wc;\n    return w;\n}\n\n\n/*\n\tScene definition\n*/\nHit Scene(vec3 p)\n{  \n    // Hit struct\n    Hit hit;\n\t\n    vec4 wDef = vec4(0.0,1.0,0.0,0.0);\n    float w = Plane(p,wDef);\n    w += Water(p);\n    \n    hit.Dist = w;\n    hit.MaterialId = 1.0;\n    \n    return hit;\n}\n\n/*\n\tReturns the normal at the given point\n*/\nvec3 SceneNormal(vec3 p) \n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 nor = vec3\n    (\n        Scene(p + eps.xyy).Dist - Scene(p - eps.xyy).Dist,\n        Scene(p + eps.yxy).Dist - Scene(p - eps.yxy).Dist,\n        Scene(p + eps.yyx).Dist - Scene(p - eps.yyx).Dist\n    );\n    return normalize(nor);\n}\n\n/*\n\tMarchs trough the scene\n*/\nHit Raymarch(vec3 ro,vec3 rd)\n{\n    // make this all floats to change the step increment\n    float curD = kMinD;\n    for(int i=0;i<kSteps;i++)\n    {\n        Hit h = Scene(ro + curD * rd);\n        float dist = h.Dist;\n        if (dist < kDelD) \n        {\n\t\t\treturn Hit(curD,h.MaterialId);\n        }\n        curD += dist;\n        if (curD >= kMaxD) \n        {\n            return Hit(kMaxD,-1.0);\n        }\n    }\n    return Hit(kMaxD,-1.0);\n}\n\n/*\n\tReturns a rotation matrix to look at the given target.\n*/\nmat3 LookAt(vec3 origin, vec3 target, float roll) \n{\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec4 ShadeClouds(vec3 ro,vec3 rd)\n{    \n    // Cloud layer volume height\n    float cloudH \t\t= 400.0;\n    \n    // March into a cube that represents the cloud layer\n    float minD\t\t\t= 50.0;\n    float maxD \t\t\t= 5000.0;\n    float delD \t\t\t= 10.0;\t// affects plane travel distance calculations!!!\n    float curD \t\t\t= minD;\n   \tvec3 cloudCubeLayer = vec3(5000.0,cloudH,5000.0);\n\tfor(float d=minD;d<maxD;d+=delD)\n    {\n        // Increasing the delta here affects a lot the\n        // result (as banding effects appear)\n        vec3 p = ro + rd * d;\n        float c = Cube(Translate(p,vec3(0.0,700.0,-500.0)),cloudCubeLayer);\n        if(c < delD)\n        {\n            curD = d;\n            break;\n        }\n    }\n    \n    // Start marching into the cloud layer\n    if(curD != minD)\n    {\n        // Initial position\n        vec3 cP \t= ro + rd * curD;\n        vec3 wind \t= vec3(iTime * 1.0, iTime * -5.0 , iTime * 1.0);\n        \n        // Find the distance we´ll travel in the media\n        vec3 p0 = vec3(0.0,700.0,0.0);\n        vec3 pn = vec3(0.0,1.0,0.0);\n        float d = dot(pn,(p0-cP))/dot(pn,rd);\n       \t\n        // Density sampling\n        float acumDensity = 0.0;\n        float acumDist    = 0.0;\n        int vSteps        = 64;\n\t\tfloat stepSize    = d / float(vSteps);\n        \n        // General\n        float cloudiness = 0.22;\n        float scale = 0.003;\n        \n        // So... Here I´m making all the vSteps count, maybe thats a bad aproach\n        // and I could just go with a fixed stepSize and if the ray exits the cloud\n        // just break the loop\n        for(int i = 0;i<vSteps;i++)\n        {\n            vec3 p \t\t\t\t= cP + rd * acumDist;\n            acumDist \t\t\t+= stepSize;\n            float curDensity \t= noise3DFbm5((p+wind) * scale);\n            acumDensity \t\t+= clamp(curDensity-cloudiness,0.0,1.0);\n        }\n        // Should we normalize acumDensity????\n        float opacity\t= 1.0 / pow(kE,acumDensity);\n        vec3 col \t\t= (kSunColor) + vec3(0.2);\n        // Fade with distance\n        float fade \t\t= 1.0 - clamp(distance(ro,cP)/4000.0,0.0,1.0);\n        return vec4(col*30.0,(1.0-opacity)*fade);\n    }\n    \n    // Just return black,no clouds here!\n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nvec3 ShadeSky(vec3 ro,vec3 rd,bool doClouds)\n{\n    // Clouds\n    vec4 clouds = vec4(0.0);\n    if(doClouds)\n    {\n        clouds \t\t= ShadeClouds(ro,rd);\n        clouds.xyz \t*= clouds.w;\n    }\n\n    // Sun\n    float s \t\t\t= pow(max(dot(normalize(kToSun),rd),0.0),1200.0) * 10.0;\n    \n    // Atmosphere\n    float h\t\t\t\t= clamp(rd.y,0.0,1.0);\n    vec3 horizon \t\t= vec3(0.8,0.8,0.85);\n    vec3 sky \t\t\t= vec3(0.0,0.3,0.8);\n    float skyIntensity \t= 3.0;\n    \n    vec3 composite \t\t= (mix(horizon,sky,pow(h,0.21)) * skyIntensity) + \n        \t\t\t\t  (kSunColor * s);\n    composite \t\t\t+= clouds.xyz;\n    return composite;\n}\n\nvec3 ShadeWater(vec3 p,vec3 rd,vec3 ro)\n{\n    vec3 n \t\t= SceneNormal(p);\n    vec3 toEye \t= normalize(ro-p);\n    vec3 toSun \t= vec3(0.1,0.5,-0.8);\n    vec3 h \t\t= normalize(normalize(kToSun) - rd);\n    \n    // Specular\n    float s \t= pow(max(dot(n,h),0.0),300.0);\n    vec3 spec \t= kSunColor * s * 10.0;\n    \n    // Diffuse\n    float lamb \t= max(dot(n,toSun),0.5);\n    \n    // Fresnel\n    float f\t \t= max(pow(dot(n,toEye),0.3),0.1);\n    vec3 fres \t= 1.0-(vec3(1.0) * (f + 0.15));\n    fres \t\t= clamp(fres,vec3(0.0),vec3(1.0));\n    \n    // Optics\n    vec3 wBaseColor = vec3(0.0,0.1,0.3) * 0.5;\n    vec3 sN \t\t= normalize(n * vec3(1.0,1.0,1.0));\n    vec3 rDir \t\t= normalize(-reflect(toEye,sN));\n    vec3 reflec \t= ShadeSky(p,rDir,true);\n    reflec \t\t\t= reflec / (reflec + vec3(1.0));\n    reflec\t\t\t*= 5.0;\n    //vec3 opticsColor= mix(reflec,wBaseColor,max(pow(dot(n,toEye),0.2) +0.2,0.01));\n    vec3 opticsColor= mix(reflec,wBaseColor,clamp((1.0 - fres.x) + 0.05,0.0,1.0));\n    \n    // Color\n    vec3 wCol \t= (opticsColor * lamb) + spec;\n    wCol \t\t+= fres*1.0;\n   \n    // Fog\n    float distToCam = distance(p,ro) - 100.0;\n    return mix(wCol,vec3(0.8,0.8,0.85)*3.0,clamp(distToCam/400.0,0.0,1.0));\n}\n\n/*\n\tMain shading method\n*/\nvec3 Shade(vec3 p,vec3 rd,vec3 ro,Hit hit)\n{      \n    // We didnt hit anything shade sky\n    if(hit.Dist >= kMaxD)\n    {\n        return ShadeSky(ro,rd,true);\n    }\n     \n    if(int(hit.MaterialId) == 1)\n    {\n        return ShadeWater(p,rd,ro);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else  \n    \t// Setup camera\n        vec2 uv  = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n#endif\n        vec3 ro \t= vec3(2.0,3.0,30.0);\n      \t\n        mat3 camRot = LookAt(ro,vec3(0.0,1.0,0.0),0.0);\n        vec3 rd \t= normalize(camRot * vec3(uv,1.6));\n\n        // Check intersection\n        vec3 color;\n        Hit hit = Raymarch(ro,rd);\n        vec3 p \t= ro + rd * hit.Dist;\n        color \t= Shade(p,rd,ro,hit);\n        \t\n        // Tonemap and gamma correct\n        color \t= color / (color + vec3(1.0));\n        color \t= pow(color,vec3(1.0/2.2));\n        tot \t+= color;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}