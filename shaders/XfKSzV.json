{
    "Shader": {
        "info": {
            "date": "1715469118",
            "description": "yeah so, this was a thing I made in Blender years ago and I just set it as my phone wallpaper, so I figured, now that I'm better at shadertoy, why not replicate it here? I imagine this could be faster with an analytical intersection function.",
            "flags": 32,
            "hasliked": 0,
            "id": "XfKSzV",
            "likes": 39,
            "name": "dodecahedron͏",
            "published": 3,
            "tags": [
                "raymarching",
                "mirror",
                "recursion",
                "dark"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "//#define bufferless\n//#define borthrallaMode\n//#define ultra \n//  ^ TRY THIS ^ //\n\nconst int bounces = 4096;\n\n\n\nconst float phi = (1.+sqrt(5.))*.5;\nfloat dodecahedron(vec3 p){\n\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p);\n\tfloat a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    return max(max(a,b),c)-phi*n.y;\n} // Stolen *ahem* Permanently Borrowed™ from https://www.shadertoy.com/view/XtKfWW\n\n#define n(x) m=min(m, x)\nfloat df(vec3 p){\n    float m = 1e9;\n    \n    //n(length(p) - .9);\n    n(dodecahedron(p));\n    \n    #ifdef borthrallaMode\n        m = max(m, .6 - length(p));\n    #endif\n    \n      \n    return m;\n}\n\nvec3 norm(vec3 p, float e){\n    return normalize(vec3(\n        df(p + vec3(e, 0, 0)) - df(p - vec3(e, 0, 0)),\n        df(p + vec3(0, e, 0)) - df(p - vec3(0, e, 0)),\n        df(p + vec3(0, 0, e)) - df(p - vec3(0, 0, e))\n    ));\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = \n    #ifdef bufferless\n    iMouse.z > 0.?(2.*iMouse.xy-r)/r.y:vec2(iTime/2., .3); // Bufferless mouse controls.\n    #else\n    texelFetch(iChannel0, ivec2(0), 0).xy;\n    #endif\n    \n    vec3 o = vec3(0);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*\n    #ifdef borthrallaMode\n    2.\n    #else\n    3.\n    #endif\n    ;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec2 camUV = cuv * .5;\n    vec3 dirV = vec3(sin(camUV.x)*cos(camUV.y), cos(camUV.x)*cos(camUV.y), sin(camUV.y));\n    dirV = normalize(dir * dirV.y + right * dirV.x + up * dirV.z);\n\n    vec3 p = o;\n    float d, t = 0.;\n    for (int i = 128; i-->0;){\n        p = o + dirV * t;\n        d = df(p);\n        t += d*1.1;\n        if (d < 0.) i--;\n    }\n    \n    vec3 normal = norm(p, 1e-4);\n    float edge = 1.-dot(norm(p, 32./r.y), normal);\n\n    if (length(p) > 2.){ // Skybox\n        O = vec4(0);\n        if (dirV.z < 0.){\n            t = (o.z + 1.) / -dirV.z;\n            p = o + dirV * t;\n            O = vec4(1.) / (1. + p.x*p.x*2. + p.y*p.y);\n        }\n        return;\n    }\n\n    // Surface reflection\n    float fresnel = pow(1.+dot(normal, dirV), 5.);\n    float tempFresnel;\n    \n    if (edge > 1e-4){ // Outer frame styling\n        O = vec4(0);\n        return;\n    } \n            \n    // Recursive reflection stuff!\n    \n    O = vec4(1,0,0,1);\n    // Set to red to debug \n    \n    float totalT = t;\n    t = 0.;\n    float attenuation = 1.;\n    p += dirV * \n    #ifdef borthrallaMode\n    .05\n    #else\n    .1\n    #endif\n    ;\n    // Light bar thickness. Cannot be zero. \n    normal = norm(p, 1e-4);\n    edge = 1.-dot(norm(p, .05), normal);\n    \n    if (edge > 1e-4){ // First visible light\n        O = vec4(1);\n        return;\n    }\n\n    for (int b = 0; b<bounces; b++){\n        for (int i = 0; i<\n        #ifdef ultra\n        int(max(exp(-float(b))*128., 32.))\n        #else\n        int(max(exp(-float(b))*64., 12.))\n        #endif\n        ; i++){\n            \n            d = df(p);\n            p -= dirV * d;\n            totalT -= d;\n\n        }\n        \n        normal = norm(p, 1e-4);\n        edge = 1.-dot(norm(p, \n        #ifdef ultra\n        .01\n        #else\n        .05\n        #endif\n        ), normal);\n        //tempFresnel = pow(1.-dot(normal, dirV), 5.);\n        \n        attenuation *= \n        #ifdef ultra\n        .95\n        #else\n        .9\n        #endif\n        ;\n        \n        if (edge > 1e-4){\n            O = vec4(attenuation);\n            break;\n        }\n        \n        dirV = reflect(dirV, normal);\n        p += dirV;\n    }\n    \n    O = mix(O, vec4(0), fresnel);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float pi = 3.14159265;\nvoid mainImage( out vec4 O, vec2 U ){\n\n    if (U.x > 1.) return;\n\n    O = texelFetch(iChannel0, ivec2(0), 0);\n\n    vec2 r = iResolution.xy;\n    vec2 muv = iMouse.z>0.?(2.*iMouse.xy-r)/r.y:O.xy;\n    \n    O.xy = mix(\n        O.xy + vec2(.2/60., (.3-O.y)*.1),\n        muv,\n    O.z);\n    O.x = mod(O.x+pi, 2.*pi)-pi;\n    O.z = mix(O.z, iMouse.z>0.?.2:0., 1e-2);\n    O.w = muv.x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}