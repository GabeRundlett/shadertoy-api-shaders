{
    "Shader": {
        "info": {
            "date": "1619529562",
            "description": "\n",
            "flags": 32,
            "hasliked": 0,
            "id": "Nsj3Wm",
            "likes": 5,
            "name": "RGB SMNCA - Slackermanz",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "diffusion",
                "automata",
                "life",
                "chaos",
                "cellular",
                "conway",
                "gameoflife",
                "cellularautomata",
                "cellularautomata",
                "cgol"
            ],
            "usePreview": 1,
            "username": "SlackermanzCA",
            "viewed": 648
        },
        "renderpass": [
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nprecision highp int;\nprecision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n\nconst int MAXSNH = 10;\nconst int SCNH_COUNT = 24;\nconst int SCNH_COUNT_CHAN =  8;\n\nivec4 wsize_unpack(uint ui32) {\n\tivec4 \twsize;\n\t\t\twsize[0] = int(\t ui32 \t\t\t& uint(0x00000FFF) );\n\t\t\twsize[1] = int( (ui32 >> 12) \t& uint(0x00000FFF) );\n\t\t\twsize[2] = int( (ui32 >> 24)\t& uint(0x0000000F) );\n\t\t\twsize[3] = int( (ui32 >> 28)\t& uint(0x0000000F) );\n\treturn \twsize; }\n\nivec4 minfo_unpack(uint ui32) {\n\tivec4 \tminfo;\n\t\t\tminfo[0] = int( (ui32 >>  4) \t& uint(0x00000FFF) );\n\t\t\tminfo[1] = int(\t(ui32 >> 16) \t& uint(0x00000FFF) );\n\t\t\tminfo[2] = int(\t ui32 \t\t \t& uint(0x0000000F) );\n\t\t\tminfo[3] = int(\t(ui32 >> 28) \t& uint(0x0000000F) );\n\treturn \tminfo; }\n\nivec2 eval2_unpack(uint ui32) {\n\tivec2 \teval2;\n\t\t\teval2[0] = int( (ui32      ) \t& uint(0x0000FFFF) );\n\t\t\teval2[1] = int(\t(ui32 >> 16) \t& uint(0x0000FFFF) );\n\treturn \teval2; }\n\nivec4 eval4_unpack(uint ui32) {\n\tivec4 \teval4;\n\t\t\teval4[0] = int( (ui32      ) \t& uint(0x000000FF) );\n\t\t\teval4[1] = int(\t(ui32 >>  8) \t& uint(0x000000FF) );\n\t\t\teval4[2] = int(\t(ui32 >> 16) \t& uint(0x000000FF) );\n\t\t\teval4[3] = int(\t(ui32 >> 24) \t& uint(0x000000FF) );\n\treturn \teval4; }\n\nuint[8] eval8_unpack(uint ui32) {\n\tuint[8]\teval8;\n\t\t\teval8[0] = uint( (ui32      ) \t& uint(0x0000000F) );\n\t\t\teval8[1] = uint( (ui32 >>  4) \t& uint(0x0000000F) );\n\t\t\teval8[2] = uint( (ui32 >>  8) \t& uint(0x0000000F) );\n\t\t\teval8[3] = uint( (ui32 >> 12) \t& uint(0x0000000F) );\n\t\t\teval8[4] = uint( (ui32 >> 16) \t& uint(0x0000000F) );\n\t\t\teval8[5] = uint( (ui32 >> 20) \t& uint(0x0000000F) );\n\t\t\teval8[6] = uint( (ui32 >> 24) \t& uint(0x0000000F) );\n\t\t\teval8[7] = uint( (ui32 >> 28) \t& uint(0x0000000F) );\n\treturn \teval8; }\n\nfloat gdv(ivec2 off, int v) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n\tivec4\tdm\t\t= ivec4(iResolution.x,iResolution.y,1,0);\n\tvec4 \tfc \t\t= gl_FragCoord;\n\tvec2\tdc\t\t= vec2( dm[0]/dm[2], dm[1]/dm[2] );\n\tfloat\tcx\t\t= mod(fc[0]+float(off[0]), dc[0]) + floor(fc[0]/dc[0])*dc[0];\n\tfloat\tcy\t\t= mod(fc[1]+float(off[1]), dc[1]) + floor(fc[1]/dc[1])*dc[1];\n\tvec4 \tpxdata \t= texelFetch( txdata, ivec2(cx, cy), 0);\n\treturn \tpxdata[v]; }\n\nvec3 nhd( ivec2 nbhd, ivec2 ofst, float psn, float thr, int col ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -float(nbhd[0]); i <= float(nbhd[0]); i+=1.0) {\n\t\tfor(float j = -float(nbhd[0]); j <= float(nbhd[0]); j+=1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= float(nbhd[0]) && dist > float(nbhd[1]) && dist != 0.0 ) {\n\t\t\t\tcval = gdv(ivec2(int(i)+ofst[0],int(j)+ofst[1]),col);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } }\n\treturn vec3( c_value, c_valid, c_total ); }\n\n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nfloat nh16_t_02(ivec2 nh, vec3[MAXSNH] rings){\n\tfloat e0_sum = 0.0;\n\tfloat e1_sum = 0.0;\n\tif(nh[0] == 0) { nh[0] = 1; }\n\tif(nh[0] > MAXSNH) { nh[0] = MAXSNH; }\n\tif(nh[0] <= nh[1]) { nh[1] = 0; }\n\tfor(int i = nh[1]; i < nh[0]; i++) {\n\t\te0_sum = e0_sum + rings[i][0];\n\t\te1_sum = e1_sum + rings[i][2]; }\n\treturn e0_sum / e1_sum; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//  PatternConfigData\n\tuint[48] SCD = uint[48] (\n\t\t3u, 9u, 12u, 12u, 13u, 1u, 8u, 10u, \n\t\t2u, 5u, 6u, 0u, 3u, 4u, 0u, 10u, \n\t\t2u, 4u, 6u, 5u, 0u, 1u, 7u, 14u, \n\t\t15u, 8u, 0u, 2u, 1u, 7u, 15u, 2u, \n\t\t8u, 8u, 3u, 5u, 1u, 9u, 11u, 8u, \n\t\t7u, 9u, 7u, 2u, 8u, 6u, 2u, 4u );\n\t\t\n\tuint[4] UBI = uint[4] (\n\t\t3381820956u, 1175436038u, 1788799421u, 696621573u );\n\t\t\n\tuint[48] UBV = uint[48] (\n\t\t1205682255u, 2045161636u, 547426430u, 1097105929u, \n\t\t652076278u, 1596149433u, 1213552863u, 3046415871u, \n\t\t730997574u, 2758318584u, 3645698113u, 985032273u, \n\t\t881500359u, 1494925827u, 1148408577u, 3334150709u, \n\t\t4048207263u, 2883048323u, 1114080772u, 499677996u, \n\t\t823602436u, 311811541u, 2035998513u, 507661684u, \n\t\t3709321582u, 65073978u, 642291892u, 776259900u, \n\t\t3598141797u, 3121169556u, 2446880420u, 1459516446u, \n\t\t2543447128u, 3790498444u, 418142298u, 1524730152u, \n\t\t344629599u, 1637917938u, 4122409199u, 4291737202u, \n\t\t320331416u, 1872345092u, 2286312465u, 1614695590u, \n\t\t2573465828u, 1980634842u, 1359788091u, 1191793090u );\n\t\t\n\tfloat SCL = 93.532906;\n\tfloat PZM = 0.950000;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tvec4\tfc \t\t= gl_FragCoord;\t\t\t\t//\tOrigin Pixel Coordinates\n\tfloat \tpsn\t\t= 65536.0;\t\t\t\t\t//\tTexture Precision\n\tfloat \tmnp \t= 1.0 / psn;\t\t\t\t//\tMinimum value of a precise step\n\tivec4\twsize\t= ivec4(iResolution.x,iResolution.y,1,0);\t//\tLayout Information\n\tivec4 \tminfo \t= ivec4(0,0,0,0);\t//\tMouse State Information\n\tfloat \tdiv_idx\t= floor((fc[0]*float(wsize[2]))/(float(wsize[0])))\n\t\t\t\t\t+ floor((fc[1]*float(wsize[2]))/(float(wsize[1])))*float(wsize[2]);\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tOrigin value references\n\tivec2\torigin  = ivec2(0,0);\n\tfloat \tref_r \t= gdv( origin, 0 );\n\tfloat \tref_g \t= gdv( origin, 1 );\n\tfloat \tref_b \t= gdv( origin, 2 );\n\n//\tOutput Values\n\tfloat \tres_r \t= ref_r;\n\tfloat \tres_g \t= ref_g;\n\tfloat \tres_b \t= ref_b;\n\n//\tNeighbourhood Rings\n\tvec3[MAXSNH] rings_r;\n\tfor(int i = 0; i < MAXSNH; i++) {\n\t\trings_r[i] = nhd( ivec2(i+1, i), origin, psn, 0.0, 0 ); }\n\n\tvec3[MAXSNH] rings_g;\n\tfor(int i = 0; i < MAXSNH; i++) {\n\t\trings_g[i] = nhd( ivec2(i+1, i), origin, psn, 0.0, 1 ); }\n\n\tvec3[MAXSNH] rings_b;\n\tfor(int i = 0; i < MAXSNH; i++) {\n\t\trings_b[i] = nhd( ivec2(i+1, i), origin, psn, 0.0, 2 ); }\n\n//\tParameters\n\tfloat s  = mnp * 16.0 *  64.0;\n\tfloat b  = mnp * 16.0 *  24.0;\n\tfloat n  = mnp * 16.0 *  16.0;\n\tfloat cy = mnp * 16.0 *  32.0 * (32.0 / sqrt(SCL));\n\tfloat li = mnp * 16.0 *  32.0;\t//\tdivide by 4 if used with cyclic\n\tfloat lu = mnp * 16.0 *  16.0;\n\n//\tGet Neighbourhood Values\n\tfloat[SCNH_COUNT_CHAN] nhv_r;\n\t\tnhv_r[0] = nh16_t_02(ivec2(SCD[0],  SCD[1]),  rings_r);\n\t\tnhv_r[1] = nh16_t_02(ivec2(SCD[2],  SCD[3]),  rings_r);\n\t\tnhv_r[2] = nh16_t_02(ivec2(SCD[4],  SCD[5]),  rings_r);\n\t\tnhv_r[3] = nh16_t_02(ivec2(SCD[6],  SCD[7]),  rings_r);\n\t\tnhv_r[4] = nh16_t_02(ivec2(SCD[8],  SCD[9]),  rings_g);\n\t\tnhv_r[5] = nh16_t_02(ivec2(SCD[10], SCD[11]), rings_g);\n\t\tnhv_r[6] = nh16_t_02(ivec2(SCD[12], SCD[13]), rings_b);\n\t\tnhv_r[7] = nh16_t_02(ivec2(SCD[14], SCD[15]), rings_b);\n\n\tfloat[SCNH_COUNT_CHAN] nhv_g;\n\t\tnhv_g[0] = nh16_t_02(ivec2(SCD[16], SCD[17]), rings_g);\n\t\tnhv_g[1] = nh16_t_02(ivec2(SCD[18], SCD[19]), rings_g);\n\t\tnhv_g[2] = nh16_t_02(ivec2(SCD[20], SCD[21]), rings_g);\n\t\tnhv_g[3] = nh16_t_02(ivec2(SCD[22], SCD[23]), rings_g);\n\t\tnhv_g[4] = nh16_t_02(ivec2(SCD[24], SCD[25]), rings_b);\n\t\tnhv_g[5] = nh16_t_02(ivec2(SCD[26], SCD[27]), rings_b);\n\t\tnhv_g[6] = nh16_t_02(ivec2(SCD[28], SCD[29]), rings_r);\n\t\tnhv_g[7] = nh16_t_02(ivec2(SCD[30], SCD[31]), rings_r);\n\n\tfloat[SCNH_COUNT_CHAN] nhv_b;\n\t\tnhv_b[0] = nh16_t_02(ivec2(SCD[32], SCD[33]), rings_b);\n\t\tnhv_b[1] = nh16_t_02(ivec2(SCD[34], SCD[35]), rings_b);\n\t\tnhv_b[2] = nh16_t_02(ivec2(SCD[36], SCD[37]), rings_b);\n\t\tnhv_b[3] = nh16_t_02(ivec2(SCD[38], SCD[39]), rings_b);\n\t\tnhv_b[4] = nh16_t_02(ivec2(SCD[40], SCD[41]), rings_r);\n\t\tnhv_b[5] = nh16_t_02(ivec2(SCD[42], SCD[43]), rings_r);\n\t\tnhv_b[6] = nh16_t_02(ivec2(SCD[44], SCD[46]), rings_g);\n\t\tnhv_b[7] = nh16_t_02(ivec2(SCD[46], SCD[47]), rings_g);\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUniform Buffer Unpacking\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tuint[48*4] \teval4;\n\tfor(int i = 0; i < 48; i++) {\n\t\tivec4 eval4_ivec = eval4_unpack(UBV[i]);\n\t\tfor(int j = 0; j < 4; j++) { eval4[i*4+j] = uint(eval4_ivec[j]); } }\n\n//\tAdjust eval4 values\n\tfloat[48*4] eval4_f;\n\tfloat\t\tfc_scale \t= 0.0;\n\tfloat\t\tub_scale \t= (float(wsize[2]) == 1.0) ? SCL * 0.5 : SCL;\n\tfloat \t\tzm_scale \t= PZM;\n\n\tfc_scale = ub_scale;\n\n\tfor(int i = 0; i < 48*4; i++) {\n\t\teval4_f[i] = (((1.0 / float(eval4[i])) * 1.5) - (0.3 * (1.0 / float(eval4[i])))) * fc_scale; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tTransition Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tfloat res_r_0  = ref_r;\n\tfloat res_r_1  = ref_r;\n\tfloat res_r_2  = ref_r;\n\tfloat res_r_3  = ref_r;\n\tfloat blr_r_0  = 0.0;\n\tfloat blr_r_1  = 0.0;\n\tfloat blr_r_2  = 0.0;\n\tfloat blr_r_3  = 0.0;\n\n\tfor(int i = 0; i < 2; i++) {\n\t\tblr_r_0 = blr_r_0 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_0 = res_r_0 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_0 = res_r_0 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_0 = res_r_0 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_0 = res_r_0 - s; } }\n\tres_r_0 = (res_r_0 + blr_r_0) / (1.0 + b * 2.0);\n\n\tfor(int i = 2; i < 4; i++) {\n\t\tblr_r_1 = blr_r_1 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_1 = res_r_1 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_1 = res_r_1 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_1 = res_r_1 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_1 = res_r_1 - s; } }\n\tres_r_1 = (res_r_1 + blr_r_1) / (1.0 + b * 2.0);\n\n\tfor(int i = 4; i < 6; i++) {\n\t\tblr_r_2 = blr_r_2 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_2 = res_r_2 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_2 = res_r_2 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_2 = res_r_2 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_2 = res_r_2 - s; } }\n\tres_r_2 = (res_r_2 + blr_r_2) / (1.0 + b * 2.0);\n\n\tfor(int i = 6; i < 8; i++) {\n\t\tblr_r_3 = blr_r_3 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_3 = res_r_3 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_3 = res_r_3 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_3 = res_r_3 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_3 = res_r_3 - s; } }\n\tres_r_3 = (res_r_3 + blr_r_3) / (1.0 + b * 2.0);\n\n\tfloat res_g_0  = ref_g;\n\tfloat res_g_1  = ref_g;\n\tfloat res_g_2  = ref_g;\n\tfloat res_g_3  = ref_g;\n\tfloat blr_g_0  = 0.0;\n\tfloat blr_g_1  = 0.0;\n\tfloat blr_g_2  = 0.0;\n\tfloat blr_g_3  = 0.0;\n\n\tfor(int i = 8; i < 10; i++) {\n\t\tblr_g_0 = blr_g_0 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_0 = res_g_0 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_0 = res_g_0 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_0 = res_g_0 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_0 = res_g_0 - s; } }\n\tres_g_0 = (res_g_0 + blr_g_0) / (1.0 + b * 2.0);\n\n\tfor(int i = 10; i < 12; i++) {\n\t\tblr_g_1 = blr_g_1 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_1 = res_g_1 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_1 = res_g_1 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_1 = res_g_1 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_1 = res_g_1 - s; } }\n\tres_g_1 = (res_g_1 + blr_g_1) / (1.0 + b * 2.0);\n\n\tfor(int i = 12; i < 14; i++) {\n\t\tblr_g_2 = blr_g_2 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_2 = res_g_2 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_2 = res_g_2 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_2 = res_g_2 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_2 = res_g_2 - s; } }\n\tres_g_2 = (res_g_2 + blr_g_2) / (1.0 + b * 2.0);\n\n\tfor(int i = 14; i < 16; i++) {\n\t\tblr_g_3 = blr_g_3 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_3 = res_g_3 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_3 = res_g_3 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_3 = res_g_3 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_3 = res_g_3 - s; } }\n\tres_g_3 = (res_g_3 + blr_g_3) / (1.0 + b * 2.0);\n\n\tfloat res_b_0  = ref_b;\n\tfloat res_b_1  = ref_b;\n\tfloat res_b_2  = ref_b;\n\tfloat res_b_3  = ref_b;\n\tfloat blr_b_0  = 0.0;\n\tfloat blr_b_1  = 0.0;\n\tfloat blr_b_2  = 0.0;\n\tfloat blr_b_3  = 0.0;\n\n\tfor(int i = 16; i < 18; i++) {\n\t\tblr_b_0 = blr_b_0 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_0 = res_b_0 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_0 = res_b_0 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_0 = res_b_0 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_0 = res_b_0 - s; } }\n\tres_b_0 = (res_b_0 + blr_b_0) / (1.0 + b * 2.0);\n\n\tfor(int i = 18; i < 20; i++) {\n\t\tblr_b_1 = blr_b_1 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_1 = res_b_1 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_1 = res_b_1 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_1 = res_b_1 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_1 = res_b_1 - s; } }\n\tres_b_1 = (res_b_1 + blr_b_1) / (1.0 + b * 2.0);\n\n\tfor(int i = 20; i < 22; i++) {\n\t\tblr_b_2 = blr_b_2 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_2 = res_b_2 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_2 = res_b_2 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_2 = res_b_2 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_2 = res_b_2 - s; } }\n\tres_b_2 = (res_b_2 + blr_b_2) / (1.0 + b * 2.0);\n\n\tfor(int i = 22; i < 24; i++) {\n\t\tblr_b_3 = blr_b_3 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_3 = res_b_3 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_3 = res_b_3 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_3 = res_b_3 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_3 = res_b_3 - s; } }\n\tres_b_3 = (res_b_3 + blr_b_3) / (1.0 + b * 2.0);\n\n\tint vir = 0;\n\tfloat viblur_r = 0.0;\n\tfloat vari_0r = abs(ref_r - res_r_0);\n\tfloat vari_1r = abs(ref_r - res_r_1);\n\tfloat vari_2r = abs(ref_r - res_r_2);\n\tfloat vari_3r = abs(ref_r - res_r_3);\n\tif(vari_0r < vari_1r) { vari_0r = vari_1r; vir = 1; }\n\tif(vari_0r < vari_2r) { vari_0r = vari_2r; vir = 2; }\n\tif(vari_0r < vari_3r) { vari_0r = vari_3r; vir = 3; }\n\tif(vir == 0) { res_r = res_r_0; viblur_r = blr_r_0; }\n\tif(vir == 1) { res_r = res_r_1; viblur_r = blr_r_1; }\n\tif(vir == 2) { res_r = res_r_2; viblur_r = blr_r_2; }\n\tif(vir == 3) { res_r = res_r_3; viblur_r = blr_r_3; }\n\n\tint vig = 0;\n\tfloat viblur_g = 0.0;\n\tfloat vari_0g = abs(ref_g - res_g_0);\n\tfloat vari_1g = abs(ref_g - res_g_1);\n\tfloat vari_2g = abs(ref_g - res_g_2);\n\tfloat vari_3g = abs(ref_g - res_g_3);\n\tif(vari_0g < vari_1g) { vari_0g = vari_1g; vig = 1; }\n\tif(vari_0g < vari_2g) { vari_0g = vari_2g; vig = 2; }\n\tif(vari_0g < vari_3g) { vari_0g = vari_3g; vig = 3; }\n\tif(vig == 0) { res_g = res_g_0; viblur_g = blr_g_0; }\n\tif(vig == 1) { res_g = res_g_1; viblur_g = blr_g_1; }\n\tif(vig == 2) { res_g = res_g_2; viblur_g = blr_g_2; }\n\tif(vig == 3) { res_g = res_g_3; viblur_g = blr_g_3; }\n\n\tint vib = 0;\n\tfloat viblur_b = 0.0;\n\tfloat vari_0b = abs(ref_b - res_b_0);\n\tfloat vari_1b = abs(ref_b - res_b_1);\n\tfloat vari_2b = abs(ref_b - res_b_2);\n\tfloat vari_3b = abs(ref_b - res_b_3);\n\tif(vari_0b < vari_1b) { vari_0b = vari_1b; vib = 1; }\n\tif(vari_0b < vari_2b) { vari_0b = vari_2b; vib = 2; }\n\tif(vari_0b < vari_3b) { vari_0b = vari_3b; vib = 3; }\n\tif(vib == 0) { res_b = res_b_0; viblur_b = blr_b_0; }\n\tif(vib == 1) { res_b = res_b_1; viblur_b = blr_b_1; }\n\tif(vib == 2) { res_b = res_b_2; viblur_b = blr_b_2; }\n\tif(vib == 3) { res_b = res_b_3; viblur_b = blr_b_3; }\n\n\tres_r = res_r - n;\n\tres_g = res_g - n;\n\tres_b = res_b - n;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tChannel Communication\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tCyclic\n/*\tfloat[6] cyw;\n\t\tcyw[0] = cy * -1.0;\n\t\tcyw[1] = cy *  1.0;\n\t\tcyw[2] = cy * -1.0;\n\t\tcyw[3] = cy *  1.0;\n\t\tcyw[4] = cy * -1.0;\n\t\tcyw[5] = cy *  1.0;\n\t\tfloat\tcyc_r = ( res_r * 1.0 \t\t+ res_g * cyw[0] \t+ res_b * cyw[1] ) / (1.0 + (cyw[0]+cyw[1]));\n\t\tfloat\tcyc_g = ( res_r * cyw[3]\t+ res_g * 1.0 \t\t+ res_b * cyw[2] ) / (1.0 + (cyw[2]+cyw[3]));\n\t\tfloat\tcyc_b = ( res_r * cyw[4]\t+ res_g * cyw[5] \t+ res_b * 1.0\t ) / (1.0 + (cyw[4]+cyw[5]));\n\tres_r = cyc_r; res_g = cyc_g; res_b = cyc_b;\n/**/\n\n//\tInterpolate\n/*\tfloat dt_rb = viblur_r / (b * 2.0);\n\tfloat dt_gb = viblur_g / (b * 2.0);\n\tfloat dt_bb = viblur_b / (b * 2.0);\n\tfloat\tinp_r = (res_r \t* 1.0 \t+ dt_gb *  li \t+ dt_bb *  li\t) / ( 1.0 + li * 2.0 );\n\tfloat\tinp_g = (dt_rb \t*  li \t+ res_g * 1.0 \t+ dt_bb\t*  li\t) / ( 1.0 + li * 2.0 );\n\tfloat\tinp_b = (dt_rb \t*  li\t+ dt_gb *  li \t+ res_b * 1.0\t) / ( 1.0 + li * 2.0 );\n\tres_r = inp_r;\n\tres_g = inp_g;\n\tres_b = inp_b;\n/**/\n\n//\tUnterpolate\n/*\tfloat\tunp_r = (res_r \t  \t* 1.0 \t+ res_g \t* -lu \t+ res_b \t* -lu\t) / ( 1.0 - lu * 2.0 );\n\tfloat\tunp_g = (res_r \t\t* -lu \t+ res_g \t* 1.0 \t+ res_b \t* -lu\t) / ( 1.0 - lu * 2.0 );\n\tfloat\tunp_b = (res_r \t\t* -lu\t+ res_g \t* -lu \t+ res_b \t* 1.0\t) / ( 1.0 - lu * 2.0 );\n\tres_r = unp_r;\n\tres_g = unp_g;\n\tres_b = unp_b;\n/**/\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 32.0) {\n        res_r = round(mod(float(iFrame),3.0));\n        res_g = round(mod(float(iFrame),5.0));\n        res_b = round(mod(float(iFrame),7.0)); }\n    if (iFrame == 0) { res_r = reseed(0); res_g = reseed(1); res_b = reseed(2); }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}