{
    "Shader": {
        "info": {
            "date": "1689351969",
            "description": "reference at https://www.shadertoy.com/view/tsBBWW by demofox;\nreference at https://blog.csdn.net/weixin_44176696/article/details/119791772 by AkagiSenpai",
            "flags": 32,
            "hasliked": 0,
            "id": "stycDG",
            "likes": 4,
            "name": "Disney Principle BRDF",
            "published": 3,
            "tags": [
                "importancesampling",
                "brdf",
                "path"
            ],
            "usePreview": 1,
            "username": "73begonia",
            "viewed": 437
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float intersect_plane(Ray ray, vec3 center, vec3 normal)\n{\n    float denom = dot(ray.rd, normal);\n    float t = dot(center - ray.ro, normal) / denom;\n\treturn t > 0.0 ? t : c_superFar;\n}\n\nbool intersect_light(Ray r, inout HitResult res)\n{\n\tfloat t = intersect_plane(r, light_position, light_normal);\n\n\tvec3 p = ray_at(r, t);\n\tif(all(lessThan(abs(light_position - p).xz, vec2(light_size * 0.5))) && t < res.distance) {\n\t\tres.distance = t;\n        res.viewDir = r.rd;\n        res.hitPoint = p;\n        res.normal = light_normal;\n        return true;\n\t}\n\n\treturn false;\n}\n\nvec3 sample_light(vec2 rng)\n{\n\treturn light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * light_size;\n}\n\nbool iQuad(in Ray r, inout HitResult res, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, r.rd) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = r.ro;\n    vec3 q = r.ro + r.rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(r.rd.x) > 0.1f)\n    {\n        dist = (intersectPos.x - r.ro.x) / r.rd.x;\n    }\n    else if (abs(r.rd.y) > 0.1f)\n    {\n        dist = (intersectPos.y - r.ro.y) / r.rd.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - r.ro.z) / r.rd.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < res.distance)\n    {\n        res.distance = dist;\n        res.viewDir = r.rd;\n        res.hitPoint = r.ro + res.distance * r.rd;\n        res.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool iSphere(in Ray r, inout HitResult res, in vec4 sphere)\n{\n\tvec3 m = r.ro - sphere.xyz;\n\n\tfloat b = dot(m, r.rd);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\tfloat discr = b * b - c;\n\n\tif(discr < 0.0)\n\t\treturn false;\n    \n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < res.distance)\n    {\n        res.distance = dist;  \n        res.viewDir = r.rd;\n        res.hitPoint = r.ro + r.rd * res.distance;\n        res.normal = normalize((r.ro+r.rd*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid SceneTrace(in Ray r, inout HitResult res)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.7f, 0.7f, 0.7f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }\n\t}    \n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.7f, 0.7f, 0.7f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.7f, 0.7f, 0.7f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(1.0f, 0.1f, 0.1f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.1f, 1.0f, 0.1f);\n            res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            res.material.roughness = 1.0f;\n        }        \n    }    \n    \n    // light\n    /*\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        \n        if (iQuad(r, res, A, B, C, D))\n        {\n            res.material.baseColor = vec3(0.0f, 0.0f, 0.0f);\n            res.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n        }        \n    }\n    */\n    \n    {\n        if(intersect_light(r, res))\n        {\n            res.material.baseColor = vec3(0.0f, 0.0f, 0.0f);\n            res.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n        }\n    }\n    \n\tif (iSphere(r, res, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        res.material.baseColor = vec3(1.0f, 0.59f, 0.60f);\n        res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        res.material.roughness = 0.1;\n        res.material.subsurface = 0.0;\n        res.material.specular = 0.5;\n        res.material.metallic = 0.9;\n        res.material.anisotropic = 0.0;\n    } \n    \n\tif (iSphere(r, res, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        res.material.baseColor = vec3(0.56f, 1.0f, 0.53f);\n        res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        res.material.roughness = 0.25;\n        res.material.subsurface = 1.0;\n        res.material.specular = 1.0;\n        res.material.metallic = 0.9;\n        res.material.anisotropic = 1.0;\n    }    \n    \n\tif (iSphere(r, res, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        res.material.baseColor = vec3(0.49f, 0.48f, 1.0f);\n        res.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        res.material.roughness = 0.1;\n        res.material.specular = 0.5;\n    }    \n}\n\nbool test_visibility(vec3 p1, vec3 p2)\n{\n    const float eps = 1e-5;\n    \n    Ray r = Ray(p1, normalize(p2 - p1));\n    r.ro += eps * r.rd;\n    \n    HitResult res;\n    res.distance = c_superFar;\n    SceneTrace(r, res);\n    \n    if(res.distance > distance(p1, p2) - 2.0 * eps)\n        return true;\n    \n    return false;\n}\n\nvec3 pathTracing(in HitResult hit)\n{\n    vec3 Lo = vec3(0.);\n    vec3 history = vec3(1.);\n    \n    for(int bounce = 0; bounce < c_numBounces; bounce++)\n    {\n        vec3 V = -hit.viewDir;\n        vec3 N = hit.normal;\n        \n        vec2 uv = sobolVec2(uint(iFrame+1), uint(bounce));\n        uv = CranleyPattersonRotation(uv);\n        vec3 L = SampleHemisphere(uv.x, uv.y);\n        L = toNormalHemisphere(L, hit.normal);\n        //vec3 L = toNormalHemisphere(SampleHemisphere(), hit.normal);\n        \n        float pdf = 1.0 / c_twopi;\n        float cosine_o = max(0., dot(V, hit.normal));\n        float cosine_i = max(0., dot(L, hit.normal));\n        vec3 tangent, bitangent;\n        getTangent(N, tangent, bitangent);\n        \n        vec3 f_r = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n        \n        Ray randomRay;\n        randomRay.ro = hit.hitPoint;\n        randomRay.rd = L;\n        \n        HitResult newHit;\n        newHit.distance = c_superFar;\n        SceneTrace(randomRay, newHit);\n        \n        if(newHit.distance == c_superFar)\n        {\n            Lo += texture(iChannel1, randomRay.rd).rgb * history * f_r * cosine_i / pdf;\n            break;\n        }\n        \n        vec3 Le = newHit.material.emissive;\n        Lo += history * Le * f_r * cosine_i / pdf;\n        hit = newHit;\n        history *= f_r * cosine_i / pdf;\n    }\n    \n    return Lo;\n}\n\nvec3 hdrColor(vec3 L) \n{\n    vec3 color = texture(iChannel1, L).rgb;\n    return color;\n}\n\nvec3 pathTracingImportanceSampling(HitResult hit) \n{\n    vec3 Lo = vec3(0);\n    vec3 history = vec3(1);\n    \n    for(int bounce = 0; bounce< c_numBounces; bounce++) \n    {\n        vec3 V = -hit.viewDir;\n        vec3 N = hit.normal;\n        \n        vec2 uv = sobolVec2(uint(iFrame+1), uint(bounce));\n        uv = CranleyPattersonRotation(uv);\n        float xi_3 = RandomFloat01();\n        \n        vec3 L = SampleBRDF(uv.x, uv.y, xi_3, V, N, hit.material);\n        \n        float NdotL = dot(N, L);\n        if(NdotL <= 0.0) break;\n        \n        Ray randomRay;\n        randomRay.ro = hit.hitPoint;\n        randomRay.rd = L;\n        \n        HitResult newHit;\n        newHit.distance = c_superFar;\n        SceneTrace(randomRay, newHit);\n        \n        vec3 tangent, bitangent;\n        getTangent(N, tangent, bitangent);\n        \n        vec3 f_r = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n        \n        float pdf_brdf = brdf_Pdf(V, N, L, hit.material);\n        if(pdf_brdf <= 1e-7) break;\n        \n        if(newHit.distance == c_superFar)\n        {\n            vec3 color = texture(iChannel1, L).rgb;\n            Lo += history * color * f_r * NdotL / pdf_brdf;\n            break;\n        }\n        \n        vec3 Le = newHit.material.emissive;\n        Lo += history * Le * f_r * NdotL / pdf_brdf;\n        hit = newHit;\n        history *= f_r * NdotL / pdf_brdf;\n    }\n    return Lo;\n}\n\nvec3 pathTracingImportanceSampling2(in HitResult hit)\n{\n    vec3 Lo = vec3(0);\n    vec3 history = vec3(1);\n    \n    for(int bounce = 0; bounce < c_numBounces; bounce++)\n    {\n        vec3 V = -hit.viewDir;\n        vec3 N = hit.normal;\n        \n        {\n            vec3 pos_ls = sample_light(vec2(RandomFloat01(), RandomFloat01()));\n            vec3 l_nee = pos_ls - hit.hitPoint;\n            float rr_nee = dot(l_nee, l_nee);\n            l_nee /= sqrt(rr_nee);\n            float G = max(0., dot(hit.normal, l_nee)) * max(0., -dot(l_nee, light_normal)) / rr_nee;\n            vec3 L = l_nee;\n            \n            if(G > 0.0)\n            {\n                float light_pdf = 1.0 / (light_area * G);\n                float brdf_pdf = brdf_Pdf(V, N, L, hit.material);\n                float w = light_pdf / (light_pdf + brdf_pdf);\n                \n                vec3 tangent, bitangent;\n                getTangent(N, tangent, bitangent);\n                vec3 brdf = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n                \n                if(test_visibility(hit.hitPoint, pos_ls))\n                {\n                    vec3 Le = hit.material.baseColor;\n                    Lo += history * (Le * w * brdf) / light_pdf;\n                }\n            }\n        }\n        \n        {\n            vec3 V = -hit.viewDir;\n            vec3 N = hit.normal;\n\n            vec2 uv = sobolVec2(uint(iFrame+1), uint(bounce));\n            uv = CranleyPattersonRotation(uv);\n            float xi_3 = RandomFloat01();\n\n            vec3 L = SampleBRDF(uv.x, uv.y, xi_3, V, N, hit.material);\n\n            float NdotL = dot(N, L);\n            if(NdotL <= 0.0) break;\n\n            Ray randomRay;\n            randomRay.ro = hit.hitPoint;\n            randomRay.rd = L;\n\n            HitResult newHit;\n            newHit.distance = c_superFar;\n            SceneTrace(randomRay, newHit);\n\n            vec3 tangent, bitangent;\n            getTangent(N, tangent, bitangent);\n        \n            vec3 f_r = brdf_Evaluate_aniso(V, N, L, tangent, bitangent, hit.material);\n\n            float pdf_brdf = brdf_Pdf(V, N, L, hit.material);\n            if(pdf_brdf <= 1e-7) break;\n\n            if(newHit.distance == c_superFar)\n            {\n                vec3 color = texture(iChannel1, L).rgb;\n                Lo += history * color * f_r * NdotL / pdf_brdf;\n                break;\n            }\n\n            vec3 Le = newHit.material.emissive;\n            Lo += history * Le * f_r * NdotL / pdf_brdf;\n            hit = newHit;\n            history *= f_r * NdotL / pdf_brdf;\n        }\n    }\n    \n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    light_size = 8.0f;\n    light_area = light_size * light_size;\n    light_position = vec3(0.0f, 12.4f, 30.0f);\n    light_normal = vec3(0.f, -1.f, 0.f);\n    \n    vec3 ro = vec3(0.);\n    float cameraDistance = 1.0 / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);\n    vec3 rt = vec3((fragCoord/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    rt.y /= aspectRatio;\n    \n    vec3 rd = normalize(rt - ro);\n    \n    vec3 color = vec3(0.);\n    Ray r;\n    r.ro = ro;\n    r.rd = rd;\n    \n    HitResult firstHit;\n    firstHit.distance = c_superFar;\n    SceneTrace(r, firstHit);\n    \n    if(firstHit.distance == c_superFar)\n    {\n        color = texture(iChannel1, r.rd).rgb;\n    }\n    else\n    {\n        vec3 Le = firstHit.material.emissive;\n        vec3 Li;\n        for(int i = 0; i < c_numSPP; i++)\n        {\n            Li += pathTracingImportanceSampling2(firstHit);\n        }\n        Li /= float(c_numSPP);\n        color = Le + Li;\n    }\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    color = vec3(1.0) - exp(-1.0 * color);\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float c_minimumRayHitTime = 0.01f;\nconst float c_rayPosNormalNudge = 0.01f;\nconst float c_superFar = 10000.0f;\nconst float c_FOVDegrees = 90.0f;\nconst int   c_numBounces = 8;\nconst int   c_numSPP = 32;\n\nconst float c_pi = 3.1415926535;\nconst float c_twopi = 2.0f * c_pi;\n\nfloat light_size;\nfloat light_area;\nvec3  light_position;\nvec3  light_normal;\n\nuint  seed;\n\nconst uint V[8*32] = uint[](\n    2147483648U, 1073741824U, 536870912U, 268435456U, 134217728U, 67108864U, 33554432U,\n    16777216U, 8388608U, 4194304U, 2097152U, 1048576U, 524288U, 262144U, 131072U, 65536U,\n    32768U, 16384U, 8192U, 4096U, 2048U, 1024U, 512U, 256U, 128U, 64U, 32U, 16U, 8U, 4U, 2U, 1U,\n    2147483648U, 3221225472U, 2684354560U, 4026531840U, 2281701376U, 3422552064U,\n    2852126720U, 4278190080U, 2155872256U, 3233808384U, 2694840320U, 4042260480U,\n    2290614272U, 3435921408U, 2863267840U, 4294901760U, 2147516416U, 3221274624U,\n    2684395520U, 4026593280U, 2281736192U, 3422604288U, 2852170240U, 4278255360U,\n    2155905152U, 3233857728U, 2694881440U, 4042322160U, 2290649224U, 3435973836U,\n    2863311530U, 4294967295U,\n    2147483648U, 3221225472U, 1610612736U, 2415919104U, 3892314112U, 1543503872U,\n    2382364672U, 3305111552U, 1753219072U, 2629828608U, 3999268864U, 1435500544U,\n    2154299392U, 3231449088U, 1626210304U, 2421489664U, 3900735488U, 1556135936U,\n    2388680704U, 3314585600U, 1751705600U, 2627492864U, 4008611328U, 1431684352U,\n    2147543168U, 3221249216U, 1610649184U, 2415969680U, 3892340840U, 1543543964U,\n    2382425838U, 3305133397U,\n    2147483648U, 3221225472U, 536870912U, 1342177280U, 4160749568U, 1946157056U,\n    2717908992U, 2466250752U, 3632267264U, 624951296U, 1507852288U, 3872391168U,\n    2013790208U, 3020685312U, 2181169152U, 3271884800U, 546275328U, 1363623936U,\n    4226424832U, 1977167872U, 2693105664U, 2437829632U, 3689389568U, 635137280U,\n    1484783744U, 3846176960U, 2044723232U, 3067084880U, 2148008184U, 3222012020U,\n    537002146U, 1342505107U,\n    2147483648U, 1073741824U, 536870912U, 2952790016U, 4160749568U, 3690987520U,\n    2046820352U, 2634022912U, 1518338048U, 801112064U, 2707423232U, 4038066176U,\n    3666345984U, 1875116032U, 2170683392U, 1085997056U, 579305472U, 3016343552U,\n    4217741312U, 3719483392U, 2013407232U, 2617981952U, 1510979072U, 755882752U,\n    2726789248U, 4090085440U, 3680870432U, 1840435376U, 2147625208U, 1074478300U,\n    537900666U, 2953698205U,\n    2147483648U, 1073741824U, 1610612736U, 805306368U, 2818572288U, 335544320U,\n    2113929216U, 3472883712U, 2290089984U, 3829399552U, 3059744768U, 1127219200U,\n    3089629184U, 4199809024U, 3567124480U, 1891565568U, 394297344U, 3988799488U,\n    920674304U, 4193267712U, 2950604800U, 3977188352U, 3250028032U, 129093376U,\n    2231568512U, 2963678272U, 4281226848U, 432124720U, 803643432U, 1633613396U,\n    2672665246U, 3170194367U,\n    2147483648U, 3221225472U, 2684354560U, 3489660928U, 1476395008U, 2483027968U,\n    1040187392U, 3808428032U, 3196059648U, 599785472U, 505413632U, 4077912064U,\n    1182269440U, 1736704000U, 2017853440U, 2221342720U, 3329785856U, 2810494976U,\n    3628507136U, 1416089600U, 2658719744U, 864310272U, 3863387648U, 3076993792U,\n    553150080U, 272922560U, 4167467040U, 1148698640U, 1719673080U, 2009075780U,\n    2149644390U, 3222291575U,\n    2147483648U, 1073741824U, 2684354560U, 1342177280U, 2281701376U, 1946157056U,\n    436207616U, 2566914048U, 2625634304U, 3208642560U, 2720006144U, 2098200576U,\n    111673344U, 2354315264U, 3464626176U, 4027383808U, 2886631424U, 3770826752U,\n    1691164672U, 3357462528U, 1993345024U, 3752330240U, 873073152U, 2870150400U,\n    1700563072U, 87021376U, 1097028000U, 1222351248U, 1560027592U, 2977959924U, 23268898U,\n    437609937U\n);\n\nuint grayCode(uint i) {\n    return i ^ (i>>1);\n}\n\nfloat sobol(uint d, uint i) {\n    uint result = 0U;\n    uint offset = d * 32U;\n    for(uint j = 0U; i!=0U; i >>= 1, j++)\n        if((i & 1U)!=0U) result ^= V[j+offset];\n    return float(result) * (1.0f/float(0xFFFFFFFFU));\n}\n\nvec2 sobolVec2(uint i, uint b) {\n    float u = sobol(b*2U, grayCode(i));\n    float v = sobol(b*2U+1U, grayCode(i));\n    return vec2(u, v);\n}\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Material\n{\n    vec3 baseColor;\n    vec3 emissive;\n    float subsurface;\n    float metallic;\n    float specular;\n    float specularTint;\n    float roughness;\n    float anisotropic;\n    float sheen;\n    float sheenTint;\n    float clearcoat;\n    float clearcoatGloss;\n    float IOR;\n    float transmission;\n};\n\nstruct HitResult\n{\n    float distance;\n    vec3 hitPoint;\n    vec3 viewDir;\n    vec3 normal;\n\n    Material material;\n};\n\nvec3 ray_at(in Ray ray, float t)\n{\n\treturn ray.ro + t * ray.rd;\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01()\n{\n    return float(wang_hash(seed)) / 4294967296.0;\n}\n\nvec3 SampleHemisphere() {\n    float z = RandomFloat01();\n    float r = max(0.0, sqrt(1.0 - z*z));\n    float phi = 2.0 * c_pi * RandomFloat01();\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec3 SampleHemisphere(float xi_1, float xi_2) {\n    float z = xi_1;\n    float r = max(0.0, sqrt(1.0 - z*z));\n    float phi = 2.0 * c_pi * xi_2;\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec3 toNormalHemisphere(vec3 v, vec3 N) {\n    vec3 helper = vec3(1, 0, 0);\n    if(abs(N.x)>0.999) helper = vec3(0, 0, 1);\n    vec3 tangent = normalize(cross(N, helper));\n    vec3 bitangent = normalize(cross(N, tangent));\n    return v.x * tangent + v.y * bitangent + v.z * N;\n}\n\nvec2 CranleyPattersonRotation(vec2 p) {\n    uint pseed = seed;\n    float u = float(wang_hash(pseed)) / 4294967296.0;\n    float v = float(wang_hash(pseed)) / 4294967296.0;\n    p.x += u;\n    if(p.x>1.) p.x -= 1.;\n    if(p.x<0.) p.x += 1.;\n    p.y += v;\n    if(p.y>1.) p.y -= 1.;\n    if(p.y<0.) p.y += 1.;\n    return p;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nfloat sqr(float x) {\n    return x*x;\n}\n\nfloat SchlickFresnel(float u) {\n    float m = clamp(1.-u, 0., 1.);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\n\nfloat GTR1(float NdotH, float a) {\n    if (a >= 1.) return 1./c_pi;\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return (a2-1.) / (c_pi*log(a2)*t);\n}\nfloat GTR2(float NdotH, float a) {\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return a2 / (c_pi * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n    return 1. / (c_pi * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH\n    ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG) {\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1. / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {\n    return 1. / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvoid getTangent(vec3 N, inout vec3 tangent, inout vec3 bitangent) {\n    vec3 helper = vec3(1, 0, 0);\n    if(abs(N.x)>0.999) helper = vec3(0, 0, 1);\n    bitangent = normalize(cross(N, helper));\n    tangent = normalize(cross(N, bitangent));\n}\n\n// 余弦加权的法向半球采样\nvec3 SampleCosineHemisphere(float xi_1, float xi_2, vec3 N) {\n    // 均匀采样 xy 圆盘然后投影到 z 半球\n    float r = sqrt(xi_1);\n    float theta = xi_2 * 2.0 * c_pi;\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    float z = sqrt(1.0 - x * x - y * y);\n\n    // 从 z 半球投影到法向半球\n    vec3 L = toNormalHemisphere(vec3(x, y, z), N);\n    return L;\n}\n\n// GTR2 重要性采样\nvec3 SampleGTR2(float xi_1, float xi_2, vec3 V, vec3 N, float alpha) {\n    \n    float phi_h = 2.0 * c_pi * xi_1;\n    float sin_phi_h = sin(phi_h);\n    float cos_phi_h = cos(phi_h);\n\n    float cos_theta_h = sqrt((1.0-xi_2)/(1.0+(alpha*alpha-1.0)*xi_2));\n    float sin_theta_h = sqrt(max(0.0, 1.0 - cos_theta_h * cos_theta_h));\n\n    // 采样 \"微平面\" 的法向量 作为镜面反射的半角向量 h \n    vec3 H = vec3(sin_theta_h*cos_phi_h, sin_theta_h*sin_phi_h, cos_theta_h);\n    H = toNormalHemisphere(H, N);   // 投影到真正的法向半球\n\n    // 根据 \"微法线\" 计算反射光方向\n    vec3 L = reflect(-V, H);\n\n    return L;\n}\n\n// GTR1 重要性采样\nvec3 SampleGTR1(float xi_1, float xi_2, vec3 V, vec3 N, float alpha) {\n    \n    float phi_h = 2.0 * c_pi * xi_1;\n    float sin_phi_h = sin(phi_h);\n    float cos_phi_h = cos(phi_h);\n\n    float cos_theta_h = sqrt((1.0-pow(alpha*alpha, 1.0-xi_2))/(1.0-alpha*alpha));\n    float sin_theta_h = sqrt(max(0.0, 1.0 - cos_theta_h * cos_theta_h));\n\n    // 采样 \"微平面\" 的法向量 作为镜面反射的半角向量 h \n    vec3 H = vec3(sin_theta_h*cos_phi_h, sin_theta_h*sin_phi_h, cos_theta_h);\n    H = toNormalHemisphere(H, N);   // 投影到真正的法向半球\n\n    // 根据 \"微法线\" 计算反射光方向\n    vec3 L = reflect(-V, H);\n\n    return L;\n}\n\n// 按照辐射度分布分别采样三种 BRDF\nvec3 SampleBRDF(float xi_1, float xi_2, float xi_3, vec3 V, vec3 N, in Material material) {\n    float alpha_GTR1 = mix(0.1, 0.001, material.clearcoatGloss);\n    float alpha_GTR2 = max(0.001, sqr(material.roughness));\n    \n    // 辐射度统计\n    float r_diffuse = (1.0 - material.metallic);\n    float r_specular = 1.0;\n    float r_clearcoat = 0.25 * material.clearcoat;\n    float r_sum = r_diffuse + r_specular + r_clearcoat;\n\n    // 根据辐射度计算概率\n    float p_diffuse = r_diffuse / r_sum;\n    float p_specular = r_specular / r_sum;\n    float p_clearcoat = r_clearcoat / r_sum;\n\n    // 按照概率采样\n    float rd = xi_3;\n\n    // 漫反射\n    if(rd <= p_diffuse) {\n        return SampleCosineHemisphere(xi_1, xi_2, N);\n    } \n    // 镜面反射\n    else if(p_diffuse < rd && rd <= p_diffuse + p_specular) {    \n        return SampleGTR2(xi_1, xi_2, V, N, alpha_GTR2);\n    } \n    // 清漆\n    else if(p_diffuse + p_specular < rd) {\n        return SampleGTR1(xi_1, xi_2, V, N, alpha_GTR1);\n    }\n    return vec3(0, 1, 0);\n}\n\nvec3 brdf_Evaluate_aniso(vec3 V, vec3 N, vec3 L, vec3 X, vec3 Y, in Material material)\n{\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if(NdotL < 0. || NdotV < 0.) return vec3(0);\n\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n\n    // 各种颜色\n    vec3 Cdlin = material.baseColor;\n    float Cdlum = 0.3 * Cdlin.r + 0.6 * Cdlin.g  + 0.1 * Cdlin.b;\n    vec3 Ctint = (Cdlum > 0.) ? (Cdlin/Cdlum) : (vec3(1.));   \n    vec3 Cspec = material.specular * mix(vec3(1), Ctint, material.specularTint);\n    vec3 Cspec0 = mix(0.08*Cspec, Cdlin, material.metallic); // 0° 镜面反射颜色\n    vec3 Csheen = mix(vec3(1), Ctint, material.sheenTint);   // 织物颜色\n\n    // 漫反射\n    float Fd90 = 0.5 + 2.0 * LdotH * LdotH * material.roughness;\n    float FL = SchlickFresnel(NdotL);\n    float FV = SchlickFresnel(NdotV);\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // 次表面散射\n    float Fss90 = LdotH * LdotH * material.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\n    // 镜面反射 -- 各向异性\n    float aspect = sqrt(1.0 - material.anisotropic * 0.9);\n    float ax = max(0.001, sqr(material.roughness)/aspect);\n    float ay = max(0.001, sqr(material.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n\n    // 清漆\n    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));\n    float Fr = mix(0.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n    // sheen\n    vec3 Fsheen = FH * material.sheen * Csheen;\n    \n    vec3 diffuse = (1.0/c_pi) * mix(Fd, ss, material.subsurface) * Cdlin + Fsheen;\n    vec3 specular = Gs * Fs * Ds;\n    vec3 clearcoat = vec3(0.25 * Gr * Fr * Dr * material.clearcoat);\n\n    return diffuse * (1.0 - material.metallic) + specular + clearcoat;\n}\n\nvec3 brdf_Evaluate(vec3 V, vec3 N, vec3 L, in Material material)\n{\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if(NdotL < 0. || NdotV < 0.) return vec3(0.);\n\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n\n    // 各种颜色\n    vec3 Cdlin = material.baseColor;\n    float Cdlum = 0.3 * Cdlin.r + 0.6 * Cdlin.g  + 0.1 * Cdlin.b;\n    vec3 Ctint = (Cdlum > 0.) ? (Cdlin/Cdlum) : (vec3(1.));   \n    vec3 Cspec = material.specular * mix(vec3(1), Ctint, material.specularTint);\n    vec3 Cspec0 = mix(0.08*Cspec, Cdlin, material.metallic); // 0° 镜面反射颜色\n    vec3 Csheen = mix(vec3(1), Ctint, material.sheenTint);   // 织物颜色\n\n    // 漫反射\n    float Fd90 = 0.5 + 2.0 * LdotH * LdotH * material.roughness;\n    float FL = SchlickFresnel(NdotL);\n    float FV = SchlickFresnel(NdotV);\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // 次表面散射\n    float Fss90 = LdotH * LdotH * material.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n     \n    // 镜面反射 -- 各向同性\n    float alpha = max(0.001, sqr(material.roughness));\n    float Ds = GTR2(NdotH, alpha);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs = smithG_GGX(NdotL, material.roughness);\n    Gs *= smithG_GGX(NdotV, material.roughness);\n\n    // 清漆\n    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));\n    float Fr = mix(0.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);\n\n    // sheen\n    vec3 Fsheen = FH * material.sheen * Csheen;\n    \n    vec3 diffuse = (1.0/c_pi) * mix(Fd, ss, material.subsurface) * Cdlin + Fsheen;\n    vec3 specular = Gs * Fs * Ds;\n    vec3 clearcoat = vec3(0.25 * Gr * Fr * Dr * material.clearcoat);\n\n    return diffuse * (1.0 - material.metallic) + specular + clearcoat;\n}\n\nfloat brdf_Pdf(vec3 V, vec3 N, vec3 L, in Material material) {\n    float NdotL = dot(N, L);\n    float NdotV = dot(N, V);\n    if(NdotL < 0. || NdotV < 0.) return 0.;\n\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n     \n    // 镜面反射 -- 各向同性\n    float alpha = max(0.001, sqr(material.roughness));\n    float Ds = GTR2(NdotH, alpha); \n    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));   // 清漆\n\n    // 分别计算三种 BRDF 的概率密度\n    float pdf_diffuse = NdotL / c_pi;\n    float pdf_specular = Ds * NdotH / (4.0 * dot(L, H));\n    float pdf_clearcoat = Dr * NdotH / (4.0 * dot(L, H));\n\n    // 辐射度统计\n    float r_diffuse = (1.0 - material.metallic);\n    float r_specular = 1.0;\n    float r_clearcoat = 0.25 * material.clearcoat;\n    float r_sum = r_diffuse + r_specular + r_clearcoat;\n\n    // 根据辐射度计算选择某种采样方式的概率\n    float p_diffuse = r_diffuse / r_sum;\n    float p_specular = r_specular / r_sum;\n    float p_clearcoat = r_clearcoat / r_sum;\n\n    // 根据概率混合 pdf\n    float pdf = p_diffuse   * pdf_diffuse \n              + p_specular  * pdf_specular\n              + p_clearcoat * pdf_clearcoat;\n\n    pdf = max(1e-7, pdf);\n    return pdf;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}