{
    "Shader": {
        "info": {
            "date": "1580635378",
            "description": "Tough 2020...",
            "flags": 32,
            "hasliked": 0,
            "id": "tt3XR7",
            "likes": 90,
            "name": "Coronavirus-2020",
            "published": 3,
            "tags": [
                "dof",
                "virus"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 5881
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// From Virgill: https://www.shadertoy.com/view/ltKGzc\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    fragColor=vec4(0,0,0,1);\n \tif( uv.y>.1 && uv.y<.9 )\n    {\n       \tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p*vec3(5.3983,5.4472,6.9371));\n    p+=dot(p.yzx,p.xyz+vec3(21.5351,14.3137,15.3219));\n    return fract(p.x*p.y*p.z*95.4337);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat line(vec3 p, float h, float r)\n{\n  p.y-=clamp(p.y, 0.0, h);\n  return length(p)-r;\n}\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n    \tfloat a=1./(1.+n.y);\n    \tfloat b=-n.x*n.z*a;\n    \tb1=vec3(1.-n.x*n.x*a,-n.x,b);\n    \tb2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct=cos(t),st=sin(t);\n    vec2 q=p;\n\tp.x=ct*q.x+st*q.y;\n    p.y=-st*q.x+ct*q.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a,b,-k);\n}\n\nconst float PI=3.14159265359;\nconst float PHI=1.61803398875;\n\n// iq's inverse spherical fibonnacci: https://www.shadertoy.com/view/lllXz4\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel1, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\n\nint id=0;\n\nvec4 get_corona_params(vec3 p)\n{\n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),100.);\n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n    // bending\n    rot2d(q.xy,(hash13(fibo.xyz)*2.-1.)*q.y*.45);\n    return vec4(q,0.1+0.088*hash13(fibo.xyz+vec3(13.399,71.137,151.11)));\n}\n\nvec3 movement(vec3 p)\n{\n    float t=mod(iTime,1.5)/1.5;\n    p*=1.-0.02*clamp(sin(6.*t)*exp(-t*4.),-2.,2.);\n\trot2d(p.xz, iTime*0.05);\n    rot2d(p.xy,iTime*0.02);\n\treturn p;\n}\n\nfloat map(vec3 p)\n{\n    p=mod(p-vec3(4.),8.)-4.;\n   \tp=movement(p);\n    float d0=sphere(p*vec3(.9,1.,.98),1.)-0.1*texcube(iChannel0, p*.8, normalize(p)).x;\n    vec4 q=get_corona_params(p);\n\n    float d1=line(q.xyz,q.w*3.,0.07);\n    \n    if(d0>d1)id=1;\n    \n    d0=smin(d0,d1,0.1);\n    \n    d1=sphere(q.xyz-vec3((q.w*2.-.2)*0.2,q.w*3.+0.05,0.),0.05+q.w*0.4);\n    d0=smin(d0,d1,0.2);\n    \n    d1=line(q.xyz-vec3(0,q.w*3.,0.), q.w*3., 0.02+0.07*q.y);\n    d0=smax(d0,-d1,0.12);\n        \n    return d0*.55;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec3 eps=vec3(0.001,0,0);\n    return normalize(vec3(map(p+eps.xyz)-map(p-eps.xyz),\n                     map(p+eps.yxz)-map(p-eps.yxz),\n                     map(p+eps.yzx)-map(p-eps.yzx)));\n}\n\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\n{\n    float mid=0.;\n    vec3 p=ro+near*rd;\n    float sgn=sign(map(p));\n    for (int i=0; i<6; i++)\n    { \n        mid=(near+far)*.5;\n        p=ro+mid*rd;\n        float d=map(p);\n        if(abs(d)<0.001)break;\n        d*sgn<0. ? far=mid : near=mid;\n    }\n    return (near+far)*.5;\n}\n\n#define FAR 30.0\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n\tfloat sgn=sign(d);\n    float told=0.;\n\tbool doBisect=false;\n\n   \tfor(int i=0;i<128;++i)\n    {         \n        d=map(ro+t*rd);\n        if (sign(d)!=sgn)\n        {\n            doBisect=true;\n            break;\n        }\n        \n        if(d<0.003&&t>FAR)\n        \tbreak;\n        \n        told=t;\n        t+=d;\n    }\n    if (doBisect)t=bisect(ro,rd,told,t);\n    return t;\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=m*p*2.;\n    f+=.25*noise(p); p=m*p*2.;\n    f+=.125*noise(p); p=m*p*2.;\n    f+=.0625*noise(p); p=m*p*2.;\n    f+=.03125*noise(p);\n    return f/0.984375;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r+=w*(d-map(p+n*d));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 n, float d, float i) \n{ \n    float o,v; \n    for(o=0.;i>0.;i--) \n        o+=(i*d+map(p+n*i*d))/exp2(i); \n    return o; \n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float s = 1.0,t = 0.01,h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = map(ro + rd*t);\n        s = min( s, 16.*h/t );\n        if( s<0.0001 ) break;\n        t += clamp( h, .01, .05 );\n    }\n    return clamp(s,.0,1.);\n}\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 n, float t, vec3 p)\n{    \n    id=0;\n    float d=map(p);\n    vec3 ld0=normalize(vec3(1,1.2,-1.3));\n    \n    if(id==1)\n    {\n        n=bump_mapping(movement(p), n, 0.0265);\n    }\n\n    float dif=max(0.,dot(ld0,n));\n    float spe=pow(max(0.,dot(rd,reflect(ld0,n))), 24.0);\n    float bac=max(0.,dot(-ld0,n));\n    float amb=clamp(0.3+0.7*n.y,0.0,1.0);\n    float sca=sss(p,-n,.6,6.);\n    float fre=clamp(1.-dot(n,-rd),0.,1.);\n\tfloat sha=shadow(p,ld0);\n    vec3 mate=vec3(1.9,0.352,0.45)*.5+pow(texcube(iChannel1, 3.*movement(p), n).x,8.5)*vec3(.5);\n    \n    \n    float ao=get_ao(p,n)*1.5;\n    \n    vec3 col=(4.0*dif+0.5*bac+1.*amb+5.5*fre)*mate*ao+3.5*spe*vec3(1);\n    col*=sha;\n  \tcol+=1.*mate*sca*sca;\n    col*=0.2;\n    col*=clamp(pow(length(p)/1.5,2.),0.,1.);\n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 bg(vec2 p)\n{\n    vec3 col=vec3(0.05,0.25,0.05)*pow(fbm(p*4.),2.);\n    col+=vec3(0.8,0.1,0.3)*pow(fbm(p*6.),15.)*80.;\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p=q*2.0-1.;\n    p.x*=iResolution.x/iResolution.y;\n\n    vec3 ro=vec3(1,2,-6.);\n    vec3 ta=vec3(0,0,0);\n     // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n    \tro=vec3(0.,0,-3)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*5.;\n     \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(vec3(0,1,0),f));\n    vec3 u=normalize(cross(f,r));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.x,p.y,2.8));\n    \n    vec3 col=bg(p);\n    \n    float t=0.01;\n    t=intersect(ro,rd);\n    if(t<FAR)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        col=lighting(ro, rd,n,t,pos);\n    }\n    float depth=clamp(0.033*t, 0.,1.);\n\tcol=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\tfragColor=vec4(col.xyz,abs(.2-depth)*1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}