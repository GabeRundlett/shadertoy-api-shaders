{
    "Shader": {
        "info": {
            "date": "1656596058",
            "description": "Tries to generate quasi random Lightning Flashes faster than a texture lookup. You can pick the parameters with the mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "fddBDM",
            "likes": 7,
            "name": "Cheap Lightning Flashes",
            "published": 3,
            "tags": [
                "voronoi",
                "mouse",
                "fast",
                "fake",
                "cheap",
                "lightning",
                "cellular",
                "flash"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nHis versions are pretty extensively commented so give it a read.\n\nThis is trying to emulate quasi random flashes of lightning to be used with a\nlightning map. This works by moving two differently angled square grids over \neach other. You can clearly see it if you increase the bias to like 0.8. \n\nI also have a slightly worse tiling function sflashyTiling, that doesn't produce\nperfectly round flashes, but they are a bit faster. Its bias works a bit\ndifferent so adjust it seperatly. I can't tell them appart in my clouds, so I \nwould recomend trying the cheaper variant. \n\nI changed a number of things to make it simpler and easier to understand. \nYou can also select a number of parameters with the mouse.\n- GridRes controls the size of the first grid sample\n- Degree is controlled by the y-axis of the mouse. It selects the degree of \n      rotation of each grid is offset to each other. You should avoid multiple \n      of 45 degrees and a few degrees around it.\n- Scale selects the size difference for each grid layer. Note that values \ngreater than about +-10% will make the edges rounded.\n- Bias controls the size of the flashes and a bit their number. \n- Offset controls how much the grids are offset from each other or with iTime\nthe speed of the flashes. \n\nIf you want see if this is faster than a texture lookup see the \nhere (https://www.shadertoy.com/view/sd3fDM).\n*/\n\n// Text on Screen from Piperoman https://www.shadertoy.com/view/XllSWl\nfloat DigitBin(const in int x) {\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces) {\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// makes YlGnBu_r colormap with polynimal 6 from https://www.shadertoy.com/view/Nd3fR2\nvec3 YlGnBu_r(float t) {\n    const vec3 c0 = vec3(0.016999,0.127718,0.329492);\n    const vec3 c1 = vec3(1.571728,0.025897,2.853610);\n    const vec3 c2 = vec3(-4.414197,5.924816,-11.635781);\n    const vec3 c3 = vec3(-12.438137,-8.086194,34.584365);\n    const vec3 c4 = vec3(67.131044,-2.929808,-58.635788);\n    const vec3 c5 = vec3(-82.372983,11.898509,47.184502);\n    const vec3 c6 = vec3(31.515446,-5.975157,-13.820580);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec2 uv) {\n    vec2 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define pi              3.1415926536\n// makes a tiling flashing pattern https://www.desmos.com/calculator/kcmr5ftqqw\nfloat flashyTiling(vec2 uv, float degree, float scale, vec2 offset, float bias) {\n    float grid1 = sphereGrid(uv - offset); // first grid\n    \n    // choose a deg/scale and precalulate this when you picked your paramters\n    float rad = (pi* degree)/180.; //degree to radians\n    mat2 m = mat2(cos(rad), -sin(rad), sin(rad), cos(rad)); // rotation matric\n    m *= scale; // this make the rmatrix also scale\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = sphereGrid(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (-grid1 -grid2 +bias)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate\n    return comb; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n// sine grid, a bit faster than spheregrid\nfloat bubble(vec2 uv) {\n    vec2 d = sin(uv*pi); //remove pi for pi sized grid\n    return abs(d.x*d.y);    \n}\n\n// makes a faster tiling flashing pattern, but not perfectly spherical anymore \n// https://www.desmos.com/calculator/qsqd4w4sq6\nfloat sflashyTiling(vec2 uv, float degree, float scale, vec2 offset, float bias) {\n    float grid1 = bubble(uv - offset); // first grid\n    \n    // choose a deg/scale and precalulate this when you picked your paramters\n    float rad = (pi* degree)/180.; //degree to radians\n    mat2 m = mat2(cos(rad), -sin(rad), sin(rad), cos(rad)); // rotation matric\n    m *= scale; // this make the rmatrix also scale\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = bubble(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (grid1 +grid2 +bias-2.)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate to catch rounding errors\n    return comb; //0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 4.0; //Hex Grid Size\n    float bias = .2; //size and kind of number of the flashes\n    vec2 offset = vec2(iTime*.2, iTime*1.); //movement\n    \n    // mouse controls\n    float scale = .93; //default values for preview\n    float degree = 55.; // default values for preview\n    if(iMouse.x > 0.0)\t{\n        vec4 mouse = iMouse / iResolution.y;\n        scale = .17 * mouse.x +.85;  // value range .85-1.15\n        degree = mouse.y  * 90.; // it's a square gird going going larger than 90 is pointless\n    }\n        \n    //UV needs to be offset by a large vector from the 0,0, and avoiding 120/90/60 ... deg\n    vec2 offset2 = vec2(379., 769.); // two arbitrary large prime numbers\n    vec2 uv = vec2(fragCoord/iResolution.y); // uv scaled and offset\n    uv = (uv+offset2)*gridRes;\n    \n    float vor = flashyTiling(uv, degree, scale, offset, bias); // generating cell Tilling    \n    \n    vec3 vColour = YlGnBu_r(vor); // applying cosmetic colormap\n    \n    // Text portion\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 3.0;\t\n    vec2 vFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n    \n    if(iMouse.x > 0.0)\t{\n        // Plot Mouse Pos Point\n\t    float fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\t    vColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n        \n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-62.0, 6.0);\n\t\tfloat fValue2 = scale;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = degree;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    fragColor = vec4(vColour,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}