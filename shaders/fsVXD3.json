{
    "Shader": {
        "info": {
            "date": "1635425078",
            "description": "Creates a photon-sieve-like pattern, and then I animated it... and then messed with a old' school VFX shown on a CRT kinda effect. \nFullscreen reccomended. \nMess with the pixel-size via \"pixelZoom\" or set ABS_RESOLUTION 0 and define a fixed numLines",
            "flags": 32,
            "hasliked": 0,
            "id": "fsVXD3",
            "likes": 19,
            "name": "HypnoThing '79",
            "published": 3,
            "tags": [
                "circles",
                "retro",
                "tv",
                "crt",
                "trig"
            ],
            "usePreview": 0,
            "username": "hjd3481",
            "viewed": 517
        },
        "renderpass": [
            {
                "code": "#define ABS_RESOLUTION 0\n///////////////////////////////////////////////////\n\n//ABS_RESOLUTION\nconst float numLines = 480.0;\nconst float numHoriz = numLines*1.66;\n\n// fixed pixel-size\nconst float pixelZoom = 0.1;\n\n///////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#if ABS_RESOLUTION\n    //fixed number of pixels\n    vec2 pixels = vec2( numHoriz, numLines );\n#else\n    //resolution-independant pixel-size\n    vec2 pixels = vec2(iResolution) * vec2(pixelZoom);\n#endif //ABS_RESOLUTION\n    \n    //unit UVs   \n    vec2 uv= fragCoord/iResolution.xy;\n\n    //get background 'tv signal' texture.\n    vec2 tvuv = uv;\n    \n    //quantize vertical lines for 'pixellated' image\n    tvuv.y = floor(tvuv.y * pixels.y) / pixels.y;\n\n    vec3 signal = texture(iChannel0,tvuv).rgb;\n\n    //the 'TV' picture\n    vec3 col = signal; \n\n    //noise\n    col =  mix( col + 0.5, col * 0.8, hash12(fragCoord + iTime));\n        \n    //two lines is one wavelength ( -1 +1 )\n    float lineUpDown = sin(PI*pixels.y*uv.y);  \n        \n    //abs to get 'arches' +1 +1\n    float scanlines = abs(lineUpDown);         \n    \n    //brick pattern ( offset based on alternating line )\n    float bricker = fract(uv.x*pixels.x + sign(lineUpDown)*0.25); \n    \n    //the horizontal pixel border\n    float pixelMaskX = abs( sin(PI*bricker) );\n    \n    vec3 preMask = col;\n    \n    //darken by pixel-border mask\n    col *= pixelMaskX * scanlines; \n           \n    //create the 3 red, green and blue phosphor masks. \n    vec3 shiftRGB = vec3(0.0,1.0,2.0); \n    vec3 barsRGB = abs(sin( PI * clamp( bricker * 3.0 - shiftRGB, 0.0, 1.0) ));\n    vec3 rgbMask = barsRGB * vec3(1.1, 0.6, 1.2); //balance channels / colours\n    \n    //add non-rgb-filtered back in for better white-values and a bit of a 'glow'\n    col *= rgbMask + (preMask * 0.5); \n    \n    col *= 1.33; //overall brighten  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n///////////////////////////////////////////////////",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 Rotate( in vec2 v, in float t )\n{\n     return  v.x * vec2( sin(t), cos(t) ) + v.y * vec2( -cos(t), sin(t) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n       \n    vec2 uv = (fragCoord)/ iResolution.xy; \n\n    //save off the passthough uvs for previous-frame lookup per frag\n    vec2 uvPass = uv;\n    \n    //get (0,0) in centre\n    uv.xy -= 0.5f;\n    \n    //make -1 : +1\n    uv.xy *= 2.0f;\n    \n    //get a square aspect\n    uv.x *= (iResolution.x/iResolution.y);\n   \n    //Make some holes\n    float i =  0.0f;\n   \n    const float radA = 0.06;\n    const float radB = 0.01;\n   \n    const int numRings = 16;\n    const float recipRing = 1.0f / float(numRings-1);\n    for(int iRing=0; iRing < numRings; ++iRing)\n    {\n        float unitRing = float(iRing) * recipRing;\n           \n        int numHoles = int( mix(1.0, 45.0, unitRing ));\n        float recipHole = 1.0f/float(numHoles);\n\n        for( int iHole=0; iHole < numHoles; ++iHole)\n        {\n            float unitHole = float(iHole)*recipHole;\n    \n            float holeRad = mix( radB, radA, 1.0f-unitRing ); //per hole for per hole randomniess inside the ring\n\n            vec2 p = vec2(0);\n\n            float ringRadius = ((1.0f-((1.0f-unitRing)*(1.0f-unitRing)))) * 0.95;\n                        \n            //shift the angle based on time and ring index\n            unitHole += (float(iRing)-float(numRings/3)) * 0.97131212 * iTime * 0.01;\n\n            p = vec2( sin(unitHole*TWOPI), cos(unitHole*TWOPI)) * ringRadius;\n\n            float d = distance( p, uv );        \n\n            i += smoothstep( holeRad+0.005, holeRad-0.005, d );\n\n        }\n    }\n    \n    vec3 col = vec3(i);\n  \n        \n    //get some coloured dots around the main holes ( easily modified to do chromatic blur etc. )        \n    vec3 bl = vec3(0.0);\n        \n    float rT = iTime * 0.91;\n    const float sz = 0.013;\n    bl += texture( iChannel0, uvPass + Rotate(vec2(-sz,0.0f),rT)).rgb * vec3(1.0,0.01,0.0);    \n    bl += texture( iChannel0, uvPass + Rotate(vec2(sz,0.0f),rT)).rgb * vec3(0.8,0.7,0.0);    \n    bl += texture( iChannel0, uvPass + Rotate(vec2(0.0f,-sz),rT)).rgb * vec3(0.02,1.0,0.0);    \n    bl += texture( iChannel0, uvPass + Rotate(vec2(0.0f,sz),rT)).rgb * vec3(0.0,0.05,1.2);\n       \n    col += (bl*0.095) ;\n  \n    \n    //scale&fade\n    vec3 prev = texture( iChannel0, ((uvPass-0.5)*1.01)+0.5 ).rgb;    \n    col += prev*0.62;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586476925286766559",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}