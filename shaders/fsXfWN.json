{
    "Shader": {
        "info": {
            "date": "1644852242",
            "description": "trees",
            "flags": 8,
            "hasliked": 0,
            "id": "fsXfWN",
            "likes": 69,
            "name": "Frosted Forest",
            "published": 3,
            "tags": [
                "tree"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 921
        },
        "renderpass": [
            {
                "code": "//Frosted Forest by eiffie\n\n#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=1.,shadowCone=0.5;\n//Beestie based on marius's strandbeest leg https://www.shadertoy.com/view/ltG3z1\n//which is based on...\n// Visualizing Theo Jansen's Strandbeest basic leg linkage\n// http://www.strandbeest.com/\n// See http://www.strandbeest.com/beests_leg.php for names & values.\n\n// distance from point p to line segment ab\nvec2 seg(vec2 a, vec2 b, vec2 p){\n  vec2 pa=p-a,ba=b-a;\n  float t=dot(pa,ba)/dot(ba,ba);\n  float d=length(pa-ba*clamp(t,0.0,1.0));\n  return vec2(d,max(d,0.5-abs(t-0.5)));\n}\n// intersect point between two 2d circles (x,y,r)\nvec2 intersect(vec3 c0, vec3 c1) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y, dxy.x) * (h/d);\n    return p2 + rxy;\n}\nfloat iZ,iY;\nfloat DEB(vec3 p0){\n  const float a = .38,b = .415,c = .393,d = .401,e = .558,f = .394,g = .367;\n  const float h = .657,i = .49,j = .50,k = .619,l = .078,m = .15;\n  float sx=1.0,dB=max(abs(p0.x)-2.0,abs(p0.z)-3.75);\n  if(p0.x<0.0){sx=-1.0;p0.z-=0.5;}\n  float t=(-time*1.5+(sin(-time*0.1)+2.0)*floor(mod(p0.z,10.))+1.57*sx)*sx;\n  float x=sx*p0.x-0.2;\n  vec2 crank = vec2(0, 0);         \n  vec2 axle = crank - vec2(a, -l);\n  vec2 pedal = crank + vec2(m*cos(t), -m*sin(t));\n  vec2 uv=vec2(-x,-p0.y);\n  // draw \"frame\"\n  vec2 ds = seg(vec2(0, l), axle, uv);\n  ds = min(ds, seg(vec2(0, l), crank, uv));\n  ds = min(ds, seg(pedal, crank, uv));\n  // compute linkage points\n  vec2 P1 = intersect(vec3(pedal, j), vec3(axle, b));  // bej\n  vec2 P2 = intersect(vec3(axle, c), vec3(pedal, k));  // cgik\n  vec2 P3 = intersect(vec3(P1, e), vec3(axle, d));  // edf\n  vec2 P4 = intersect(vec3(P3, f), vec3(P2, g)); // fgh\n  vec2 P5 = intersect(vec3(P4, h), vec3(P2, i));  // hi\n  ds = min(ds, seg(P1, axle, uv));\n  ds = min(ds, seg(P3, axle, uv));\n  ds = min(ds, seg(P1, P3, uv));\n  ds = min(ds, seg(P2, P4, uv));\n  ds = min(ds, seg(P2, P5, uv));\n  ds = min(ds, seg(P4, P5, uv));\n  ds = min(ds, seg(pedal, P1, uv));\n  ds = min(ds, seg(pedal, P2, uv));\n  ds = min(ds, seg(P2, axle, uv));\n  ds = min(ds, seg(P3, P4, uv));\n  float z=abs(fract(p0.z)-0.5)-0.2;\n  float d2=max(ds.y,z);\n  float d3=min(length(uv),length(uv-axle));\n  float d1=sqrt(ds.x*ds.x+z*z);\n  d1=min(min(min(d1,min(d2,d3))-0.01,(1.2-fract(p0.z))*iZ),abs(p0.x)+0.2);\n  return max(d1,abs(p0.z)-3.75);\n}\nfloat reed(vec3 p){return max(length(p.xz)-.02+p.y*.02,abs(p.y-.5)-.5);}\nfloat DE(vec3 p0){\n  const float zd=30.;\n  float x=-zd*1.5+iTime*.25;\n  vec3 p=p0+vec3(x,sin(p0.x+2.*sin(p0.z))*.08-.95,-zd-3.);\n  float db=max(abs(p.y)-1.,max(abs(p.x)-2.,abs(p.z)-3.75));\n  if(db<.2)db=DEB(p);\n  p=p0;\n  float rnd=1.5+sin(floor(p.x*.5)+floor(p.z*.5));\n  float dy=.2*clamp(p.y+.4,0.,1.);\n  p+=sin(p.zxy+2.*sin(p.yzx))*dy;\n  \n  float dg=min(p.y,db),d=10.,dr=1.;\n  bool tree=p.x<-x || abs(p.z-zd-3.)>2.75;\n  p.xz=mod(p.xz,2.)-1.;\n  p.xz=abs(p.xz);\n  p.xz-=p.y*p.y*.3;\n  if(!tree){p*=2.;dr*=2.;rnd=-1.;}\n  d=reed(p)/dr;\n  \n  for(int i=0;i<3;i++){if(float(i)>rnd)continue;\n    p.y-=.42;\n    p*=2.;dr*=2.;\n    p.xz=abs(vec2(p.x+p.z,p.x-p.z))*.707;\n    p.xz-=p.y*p.y*.3;\n    d=min(d,reed(p)/dr);\n  }\n  \n  return min(db,min(dg*2.,d*(1.-.5*dy)/iY));\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0,1,0)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 bg(vec3 rd){\n  float d=max(0.,rd.x+rd.y+rd.z);\n  return vec3(d*d*.25)+rd*.05;\n}\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<12;i++){\n  if(t>lightDist)break;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t)+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\nvec3 path(float t){return vec3(t+.1+cos(t*.23)*2.,.3+.1*sin(t),t);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=min(time,81.85)*0.5;//camera, lighting and object setup\n vec3 ro=path(tim); \n vec3 rd=lookat(path(tim+.1)-ro)*normalize(vec3((2.0*gl_FragCoord.xy-size.xy)/size.y,2.0)); \n focalDistance=1.0;iZ=1./rd.z;iY=1.+max(0.,2.*rd.y);\n aperture=0.007*focalDistance;\n vec3 rt=normalize(cross(vec3(0,1,0),rd)),up=cross(rd,rt);//just need to be perpendicular\n vec3 lightColor=vec3(1.0,0.5,0.25),L=normalize(vec3(.4,.4,.2)),bcol=bg(rd);\n vec4 col=vec4(bcol,0.);//color accumulator, .w=alpha\n float t=0.0,d=1.,h[8]=float[8](0.,0.,0.,0.,0.,0.,0.,0.);//distance traveled\n int H=0;\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>50.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  d=DE(ro+rd*t);\n  if(d<rCoC){h[H++]=t;}//d+=.5*rCoC*linstep(rCoC,-rCoC,d);}\n  d*=0.8+0.2*rand2();//add in noise to reduce banding and create fuzz\n  t+=d;\n }\n for(int i=7;i>=0;i--){if(h[i]==0.)continue;\n   vec3 p=ro+rd*h[i];//back up to previos checkpoint\n   float rCoC=CircleOfConfusion(t);\n   float d=DE(p),Drd=DE(p+rd*rCoC),Drt=DE(p+rt*rCoC),Dup=DE(p+up*rCoC);\n   vec3 N=normalize(rd*(Drd-d)+rt*(Drt-d)+up*(Dup-d));\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   vec3 scol=vec3(0.4*(1.0+dot(N,L)+.2));//difffuse\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   p+=N*max(0.,-d+0.001);//avoid self shadow\n   scol*=FuzzyShadow(p,L,1.5,shadowCone,rCoC);//now stop the shadow march at light distance\n   float alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   scol=mix(scol,bcol,t/50.);\n   col=mix(col,vec4(scol,min(col.w+alpha,1.)),alpha);//blend in the new color \n }\n fragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define bps 4.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 5.0; \n  else if(n<3.0)n= -2.0; \n  else if(n<4.0)n= 4.0; \n  else if(n<5.0)n= 7.0; \n  else if(n<6.0)n= 4.0; \n  else if(n<7.0)n= 2.0; \n  else n=0.0;\n  return vec2(n,r); \n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major +3rd\n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,1.757,0.001);//silly fm synth instruments \n instr sitar=instr(2.0,.2,8.0,0.0,0.51,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(500.0,.5,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.1252,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.505,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2;\n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.0625)+nofs(b2*0.25)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n2+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y/(1.+abs(n0.x)*.25);\n   if(mod(i,1.)<1.){\n     a+=I(n0.x+67.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.)*.25);\n     a+=I(n0.x+72.0,time,t0,sitar)*n0.y/(3.+abs(n0.x+7.)*.25);\n   }\n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+65.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+64.,time,t1,epiano)*n1.y*.125; \n     a+=I(n1.x+60.,time,t1,epiano)*n1.y*.125; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     a+=I(n1.x+24.0,t1/bps+0.008*sin(t1*3.0),t1,bassdrum)*2.0;\n     //a+=I(n2.x+31.0,t1/bps+0.008*sin(t1*2.0),t1,bassdrum)*2.0;\n     \n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+52.0,time,t2,bass)*n2.y;\n       a+=I(n2.x+97.0,time+Sin(t2*372.0),t2,stick)*n2.y*.15;\n     \n      // a+=I(96.0,time,t2,stick)*n2.y*.25;\n       \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}