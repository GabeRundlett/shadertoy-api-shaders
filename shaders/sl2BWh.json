{
    "Shader": {
        "info": {
            "date": "1652230788",
            "description": "forwards and backwards reaching inverse kinematics\nhttp://andreasaristidou.com/FABRIK.html\n\nmess around with the parameters in the common tab",
            "flags": 32,
            "hasliked": 0,
            "id": "sl2BWh",
            "likes": 6,
            "name": "fun with FABRIK",
            "published": 3,
            "tags": [
                "inversekinematics"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////\n//Go to Common tab to change parameters\n///////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = getUV(iResolution.xy, fragCoord);\n    float pxunit = 1.0/iResolution.y; //a pixel in uv coordinates\n    \n    float d = 999.0; //distance to line segments\n    float n = 999.0; //distance to nodes\n\n    //read out segment data\n    for (int i = segments-1; i >= 0; i--){\n        vec2 s = texelFetch( iChannel0, ivec2(i,0),0).xy;\n        vec2 e = texelFetch( iChannel0, ivec2(i,0),0).zw;\n        d = min(d, sdfLine(s, e, width, uv));\n        n = min(n, distance(uv, e));\n        if (i == 0){\n            n = min(n, distance(uv, s))-0.01;\n        }\n    }\n    vec3 col = background_col;\n    if (show_sdf){\n        col = vec3(sin(d*100.0)/4.0 + 0.8 - d);\n    } else {\n        if (show_particles){\n            float p = 0.0;\n            if (do_current){\n                p = hash(floor((uv - current*float(iFrame))*80.0));\n            } else {\n                p = abs(mod(iTime/400.0,1.0)-hash(floor(uv*80.0)));\n            }\n            col = mix(particle_col, col, smoothstep(0.0,0.005,p));\n        }\n        col = mix(worm_col, col, smoothstep(0.0,pxunit*2.0,d));\n    }\n    if (show_nodes){\n        col = mix(segment_col, col, smoothstep(0.0,pxunit,d+width));\n        col = mix(node_col, col, smoothstep(0.0,pxunit,n));\n        col = mix(worm_col, col, smoothstep(0.0,pxunit,n+pxunit));\n        vec2 head = texelFetch( iChannel0, ivec2(segments-1,0),0).zw;\n        col = mix(node_col, col, smoothstep(0.0,pxunit,abs(distance(uv,head)-0.02)));\n     }\n   \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 reach(vec2 s, vec2 e){\n    vec2 d = s-e;\n    if (d == vec2(0)){ //fixes case where the start and end are the same (beginning of sim)\n        d = vec2(0.0001);\n    }\n    return normalize(d)*segmentLength + e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(0);\n    vec2 e = vec2(0);\n    vec4[segments] segs;\n\n    if (int(fragCoord.x) < segments && int(fragCoord.y) == 0){\n        //read data\n        for (int i = 0; i < segments; i++){\n            segs[i] = texelFetch( iChannel0, ivec2(i,0),0);\n            if (do_current){\n                segs[i] += vec4(current,current);\n            }\n        }\n        if (dragable_nodes){ //dragable node mode\n            bool node_clicked = texelFetch( iChannel0, ivec2(0,1),0).z == 1.0;\n            int clicked = int(texelFetch( iChannel0, ivec2(0,1),0).w);\n            if (node_clicked && clicked != -1){\n                //loop from clicked up\n                //loop from clicked down\n                for (int i = clicked; i < segments; i++){\n                    vec2 mc = getUV(iResolution.xy, iMouse.xy);\n                    if (i == clicked){\n                       segs[i].xy = mc;\n                    } else {\n                       segs[i].xy = segs[i-1].zw;\n                    }\n                    segs[i].zw = reach(segs[i].zw, segs[i].xy);\n                }\n                for (int i = clicked-1; i >=0; i--){\n                    vec2 mc = getUV(iResolution.xy, iMouse.xy);\n                    if (i == clicked-1){\n                       segs[i].zw = mc;\n                    } else {\n                       segs[i].zw = segs[i+1].xy;\n                    }\n                    segs[i].xy = reach(segs[i].xy, segs[i].zw);\n                }\n            }\n        } else { //basic\n            for (int i = segments-1; i >=0; i--){\n                if (i == segments-1){\n                    segs[i].zw = texelFetch( iChannel0, ivec2(0,1),0).xy;\n                } else {\n                    segs[i].zw = segs[i+1].xy;\n                }\n                segs[i].xy = reach(segs[i].xy, segs[i].zw);\n            }\n        }\n        if (is_anchored){ //anchored mode\n            for (int i = 0; i < segments; i++){\n                if (i == 0){\n                    segs[i].xy = anchor;\n                } else {\n                    segs[i].xy = segs[i-1].zw;\n                }\n                segs[i].zw = reach(segs[i].zw, segs[i].xy);\n            }\n        }\n        //write this segment's data\n        s = segs[int(fragCoord.x)].xy;\n        e = segs[int(fragCoord.x)].zw;\n    }\n    \n    if (floor(fragCoord) == vec2(0,1)){\n        //mouse position\n        vec2 m = getUV(iResolution.xy, iMouse.xy);\n        if (followMouse){\n            vec2 p = texelFetch( iChannel0, ivec2(0,1),0).xy;\n            vec2 d = m-p;\n            s = (length(d) < speed ? d : normalize(d)*speed) + p;\n        } else {\n            s = m;\n        }\n        \n        //sets clicked segment\n        if (iMouse.z > 0.0 && dragable_nodes){\n            e.x = 1.0;\n            e.y = texelFetch( iChannel0, ivec2(0,1),0).w;\n            if (e.y == -1.0){\n                float mindist = 999.0;\n                for (int i = 0; i <= segments; i++){\n                    vec2 mc = getUV(iResolution.xy, abs(iMouse.zw));\n                    vec2 p = vec2(0);\n                    if (i < segments){\n                        p = texelFetch( iChannel0, ivec2(i,0),0).xy;\n                    } else {\n                        p = texelFetch( iChannel0, ivec2(i-1,0),0).zw;\n                    }\n                    float d = distance(mc,p);\n                    if (d <= 0.02 && d < mindist){\n                        e.y = float(i);\n                    }\n                }\n            }\n        } else {\n            e.y = -1.0;\n        }\n    }\n    fragColor = vec4(s,e);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//if true, chain will follow mouse at given speed. if false, chain will be attached to mouse\nconst bool followMouse = false; \n//chain is bounded to the anchor point\nconst bool is_anchored = false;\n//chain is dragged by current\nconst bool do_current = true;\n//chain nodes can be individually clicked and dragged (will disable following)\nconst bool dragable_nodes = false;\n\nconst int segments = 5;\nconst float segmentLength = 0.05;\nconst float width = 0.05;\nconst float speed = 0.01;\nconst vec2 current = vec2(0,-0.01);\nconst vec2 anchor = vec2(0,1);\n\n//show the vertices of the line segments (best used with dragable nodes)\nconst bool show_nodes = true;\n//shows particles that move downwards with current\nconst bool show_particles = true;\n//shows sdf of chain\nconst bool show_sdf = false;\n//shows target in follow mode\nconst bool show_target = true;\n\nconst vec3 worm_col = vec3(1);\nconst vec3 node_col = vec3(1,0.5,0);\nconst vec3 background_col = vec3(0,0.25,0.5);\nconst vec3 particle_col = vec3(0,0.5,1);\nconst vec3 segment_col = vec3(0);\nconst vec3 target_col = vec3(1,0,0);\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdfLine(vec2 a, vec2 b, float r, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2) - r;\n}\n\nvec2 getUV( vec2 res, vec2 coord ){\n    vec2 uv = coord/res;\n    uv.x = (uv.x-0.5) * (res.x/res.y);\n    return uv;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}