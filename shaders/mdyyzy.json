{
    "Shader": {
        "info": {
            "date": "1696255883",
            "description": "Unlimited bomb works!\nKlee must be happy :)",
            "flags": 64,
            "hasliked": 0,
            "id": "mdyyzy",
            "likes": 7,
            "name": "Infinite Jumpy Dumpty",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "alphardex",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "// Thanks to this lib——lygia. (https://github.com/patriciogonzalezvivo/lygia)\n#define RESOLUTION iResolution.xy\n#define RAYMARCH_SAMPLES 128\n#define RAYMARCH_MULTISAMPLE 1\n#define RAYMARCH_BACKGROUND vec3(0.)\n#define RAYMARCH_CAMERA_FOV 2.\n\n#define COLOR_1 vec3(.757,.765,.729)\n#define COLOR_2 vec3(.553,.239,.227)\n#define COLOR_3 vec3(.278,.039,.063)\n#define COLOR_4 vec3(.001,.001,.001)\n#define COLOR_5 vec3(.745,.596,.341)\n#define COLOR_6 vec3(.302,.082,.098)\n\n#define BG_COLOR vec3(0.)\n\n// -- Here boilerplate code starts :) (Plz jump to line 754) --\n\n#define RAYMARCH_MATERIAL_FNC raymarchCustomMaterial\nvec3 raymarchCustomMaterial(vec3 ray,vec3 pos,vec3 nor,vec3 map);\n\n#ifndef RAYMARCH_CAMERA_MATRIX_FNC\n#define RAYMARCH_CAMERA_MATRIX_FNC raymarchCamera\n#endif\n\n#ifndef RAYMARCH_RENDER_FNC\n#define RAYMARCH_RENDER_FNC raymarchDefaultRender\n#endif\n\n#ifndef RAYMARCH_CAMERA_FOV\n#define RAYMARCH_CAMERA_FOV 3.0\n#endif\n\n#ifndef RAYMARCH_CAMERA_SCALE\n#define RAYMARCH_CAMERA_SCALE 0.11\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_SAMPLES\n#define RAYMARCH_SAMPLES 64\n#endif\n\n#ifndef RAYMARCH_MIN_DIST\n#define RAYMARCH_MIN_DIST 1.0\n#endif\n\n#ifndef RAYMARCH_MAX_DIST\n#define RAYMARCH_MAX_DIST 20.0\n#endif\n\n#ifndef RAYMARCH_MIN_HIT_DIST\n#define RAYMARCH_MIN_HIT_DIST 0.00001 * t\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef FNC_RAYMARCHCAST\n#define FNC_RAYMARCHCAST\n\nRAYMARCH_MAP_TYPE raymarchCast( in vec3 ro, in vec3 rd ) {\n    float tmin = RAYMARCH_MIN_DIST;\n    float tmax = RAYMARCH_MAX_DIST;\n   \n\n    \n    float t = tmin;\n    RAYMARCH_MAP_MATERIAL_TYPE m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    for ( int i = 0; i < RAYMARCH_SAMPLES; i++ ) {\n        RAYMARCH_MAP_TYPE res = RAYMARCH_MAP_FNC( ro + rd * t );\n        if ( res.RAYMARCH_MAP_DISTANCE < RAYMARCH_MIN_HIT_DIST || t > tmax ) \n            break;\n        t += res.RAYMARCH_MAP_DISTANCE;\n        m = res.RAYMARCH_MAP_MATERIAL;\n    }\n\n    #if defined(RAYMARCH_BACKGROUND) || defined(RAYMARCH_FLOOR)\n    if ( t > tmax ) \n        m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    #endif\n\n    return RAYMARCH_MAP_TYPE( m, t );\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCH_SAMPLES_AO\n#define RAYMARCH_SAMPLES_AO 5\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHAO\n#define FNC_RAYMARCHAO\n\nfloat raymarchAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < RAYMARCH_SAMPLES_AO; i++ ) {\n        float hr = 0.01 + 0.12 * float(i) * 0.2;\n        float dd = RAYMARCH_MAP_FNC( hr * nor + pos ).RAYMARCH_MAP_DISTANCE;\n        occ += (hr-dd)*sca;\n        sca *= 0.9;\n        if( occ > 0.35 ) \n            break;\n    }\n    return saturate( 1.0 - 3.0 * occ ) * (0.5+0.5*nor.y);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHNORMAL\n#define FNC_RAYMARCHNORMAL\n\nvec3 raymarchNormal(vec3 pos, vec2 pixel) {\n   vec2 offset = vec2(1.0, -1.0) * pixel;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal(vec3 pos, float e) {\n   vec2 offset = vec2(1.0, -1.0) * e;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal( in vec3 pos ) {\n   return raymarchNormal(pos, 0.5773 * 0.0005);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCHSOFTSHADOW_ITERATIONS\n#define RAYMARCHSOFTSHADOW_ITERATIONS 16\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHSOFTSHADOW\n#define FNC_RAYMARCHSOFTSHADOW\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax, float k ) {\n    float res = 1.0;\n    float t = tmin;\n    float ph = 1e20;\n    for (int i = 0; i < RAYMARCHSOFTSHADOW_ITERATIONS; i++) {\n        float h = RAYMARCH_MAP_FNC(ro + rd*t).RAYMARCH_MAP_DISTANCE;\n\n        if (t > tmax)\n            break;\n\n        else if (h < 0.001) {\n            res = 0.0;\n            break;\n        }\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax) { return raymarchSoftShadow(ro, rd, tmin, tmax, 12.0); }\nfloat raymarchSoftShadow( vec3 ro, vec3 rd) { return raymarchSoftShadow(ro, rd, 0.05, 5.0); }\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHNORMAL\n#define FNC_RAYMARCHNORMAL\n\nvec3 raymarchNormal(vec3 pos, vec2 pixel) {\n   vec2 offset = vec2(1.0, -1.0) * pixel;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal(vec3 pos, float e) {\n   vec2 offset = vec2(1.0, -1.0) * e;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal( in vec3 pos ) {\n   return raymarchNormal(pos, 0.5773 * 0.0005);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_SAMPLES\n#define RAYMARCH_SAMPLES 64\n#endif\n\n#ifndef RAYMARCH_MIN_DIST\n#define RAYMARCH_MIN_DIST 1.0\n#endif\n\n#ifndef RAYMARCH_MAX_DIST\n#define RAYMARCH_MAX_DIST 20.0\n#endif\n\n#ifndef RAYMARCH_MIN_HIT_DIST\n#define RAYMARCH_MIN_HIT_DIST 0.00001 * t\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef FNC_RAYMARCHCAST\n#define FNC_RAYMARCHCAST\n\nRAYMARCH_MAP_TYPE raymarchCast( in vec3 ro, in vec3 rd ) {\n    float tmin = RAYMARCH_MIN_DIST;\n    float tmax = RAYMARCH_MAX_DIST;\n   \n\n    \n    float t = tmin;\n    RAYMARCH_MAP_MATERIAL_TYPE m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    for ( int i = 0; i < RAYMARCH_SAMPLES; i++ ) {\n        RAYMARCH_MAP_TYPE res = RAYMARCH_MAP_FNC( ro + rd * t );\n        if ( res.RAYMARCH_MAP_DISTANCE < RAYMARCH_MIN_HIT_DIST || t > tmax ) \n            break;\n        t += res.RAYMARCH_MAP_DISTANCE;\n        m = res.RAYMARCH_MAP_MATERIAL;\n    }\n\n    #if defined(RAYMARCH_BACKGROUND) || defined(RAYMARCH_FLOOR)\n    if ( t > tmax ) \n        m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    #endif\n\n    return RAYMARCH_MAP_TYPE( m, t );\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCH_SAMPLES_AO\n#define RAYMARCH_SAMPLES_AO 5\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHAO\n#define FNC_RAYMARCHAO\n\nfloat raymarchAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < RAYMARCH_SAMPLES_AO; i++ ) {\n        float hr = 0.01 + 0.12 * float(i) * 0.2;\n        float dd = RAYMARCH_MAP_FNC( hr * nor + pos ).RAYMARCH_MAP_DISTANCE;\n        occ += (hr-dd)*sca;\n        sca *= 0.9;\n        if( occ > 0.35 ) \n            break;\n    }\n    return saturate( 1.0 - 3.0 * occ ) * (0.5+0.5*nor.y);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCHSOFTSHADOW_ITERATIONS\n#define RAYMARCHSOFTSHADOW_ITERATIONS 16\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHSOFTSHADOW\n#define FNC_RAYMARCHSOFTSHADOW\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax, float k ) {\n    float res = 1.0;\n    float t = tmin;\n    float ph = 1e20;\n    for (int i = 0; i < RAYMARCHSOFTSHADOW_ITERATIONS; i++) {\n        float h = RAYMARCH_MAP_FNC(ro + rd*t).RAYMARCH_MAP_DISTANCE;\n\n        if (t > tmax)\n            break;\n\n        else if (h < 0.001) {\n            res = 0.0;\n            break;\n        }\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax) { return raymarchSoftShadow(ro, rd, tmin, tmax, 12.0); }\nfloat raymarchSoftShadow( vec3 ro, vec3 rd) { return raymarchSoftShadow(ro, rd, 0.05, 5.0); }\n\n#endif\n\n#ifndef LIGHT_POSITION\n#define LIGHT_POSITION vec3(0.0, 10.0, -50.0)\n#endif\n\n#ifndef LIGHT_COLOR\n#define LIGHT_COLOR vec3(0.5)\n#endif\n\n#ifndef RAYMARCH_AMBIENT\n#define RAYMARCH_AMBIENT vec3(1.0)\n#endif\n\n#ifndef RAYMARCH_BACKGROUND\n#define RAYMARCH_BACKGROUND vec3(0.0)\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_FNC\n#define RAYMARCH_MAP_MATERIAL_FNC \n#endif\n\n#ifndef RAYMARCH_MATERIAL_FNC\n#define RAYMARCH_MATERIAL_FNC(RAY, POSITION, NORMAL, ALBEDO) raymarchDefaultMaterial(RAY, POSITION, NORMAL, ALBEDO)\n#endif\n\n#ifndef FNC_RAYMARCHMATERIAL\n#define FNC_RAYMARCHMATERIAL\n\nvec3 raymarchDefaultMaterial(vec3 ray, vec3 position, vec3 normal, RAYMARCH_MAP_MATERIAL_TYPE color) {\n    vec3  env = RAYMARCH_AMBIENT;\n\n    if ( sum(color) <= 0.0 ) \n        return RAYMARCH_BACKGROUND;\n\n    vec3 ref = reflect( ray, normal );\n    float occ = raymarchAO( position, normal );\n\n    #if defined(LIGHT_DIRECTION)\n    vec3  lig = normalize( LIGHT_DIRECTION );\n    #else\n    vec3  lig = normalize( LIGHT_POSITION - position);\n    #endif\n    \n    vec3  hal = normalize( lig-ray );\n    float amb = saturate( 0.5+0.5*normal.y );\n    float dif = saturate( dot( normal, lig ) );\n    float bac = saturate( dot( normal, normalize(vec3(-lig.x, 0.0,-lig.z))) ) * saturate( 1.0-position.y );\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( saturate(1.0+dot(normal,ray) ), 2.0 );\n    \n    dif *= raymarchSoftShadow( position, lig, 0.02, 2.5 );\n    dom *= raymarchSoftShadow( position, ref, 0.02, 2.5 );\n\n    vec3 light = vec3(0.0);\n    light += 1.30 * dif * LIGHT_COLOR;\n    light += 0.40 * amb * occ * env;\n    light += 0.50 * dom * occ * env;\n    light += 0.50 * bac * occ * 0.25;\n    light += 0.25 * fre * occ;\n\n    return RAYMARCH_MAP_MATERIAL_FNC(color) * light;\n}\n\nvec3 raymarchMaterial(vec3 ray, vec3 position, vec3 normal, vec3 albedo) {\n    return RAYMARCH_MATERIAL_FNC(ray, position, normal, albedo);\n}\n\n#if defined(STR_MATERIAL)\nvoid raymarchMaterial( in vec3 ro, in vec3 rd, inout Material mat) { \n    RAYMARCH_MAP_TYPE res = raymarchCast(ro, rd);\n\n    vec3 col = vec3(0.0);\n    vec3 m = res.rgb;\n    float t = res.a;\n\n    vec3 pos = ro + t * rd;\n    vec3 nor = raymarchNormal( pos );\n    float occ = raymarchAO( pos, nor );\n\n    mat.albedo = res;\n    mat.normal = nor;\n    mat.ambientOcclusion = occ;\n\n    #if defined(SHADING_SHADOWS)\n    vec3 ref = reflect( rd, nor );\n    vec3 lig = normalize( LIGHT_POSITION );\n\n    vec3  hal = normalize( lig-rd );\n    float amb = saturate( 0.5+0.5*nor.y);\n    float dif = saturate( dot( nor, lig ));\n    float bac = saturate( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))))*saturate( 1.0-pos.y);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( saturate(1.0+dot(nor,rd) ), 2.0 );\n\n    dif *= raymarchSoftShadow( pos, lig, 0.02, 2.5 );\n    dom *= raymarchSoftShadow( pos, ref, 0.02, 2.5 );\n\n    mat.shadows = 1.30 * dif;\n    mat.shadows += 0.40 * amb * occ;\n    mat.shadows += 0.50 * dom * occ;\n    mat.shadows += 0.50 * bac * occ;\n    mat.shadows += 0.25 * fre * occ * 0.25;\n    #endif\n}\n#endif\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef RAYMARCHCAST_TYPE\n#define RAYMARCHCAST_TYPE vec4\n#endif\n\n#ifndef FNC_RAYMARCHDEFAULT\n#define FNC_RAYMARCHDEFAULT\n\nvec4 raymarchDefaultRender( in vec3 ray_origin, in vec3 ray_direction ) { \n    vec3 col = vec3(0.0);\n    \n    RAYMARCHCAST_TYPE res = raymarchCast(ray_origin, ray_direction);\n    float t = res.RAYMARCH_MAP_DISTANCE;\n\n    vec3 pos = ray_origin + t * ray_direction;\n    vec3 nor = raymarchNormal( pos );\n    col = raymarchMaterial(ray_direction, pos, nor, res.RAYMARCH_MAP_MATERIAL);\n\n    return vec4( saturate(col), t );\n}\n\n#endif\n\n#ifndef ENG_RAYMARCHING\n#define ENG_RAYMARCHING\nvec4 raymarch(vec3 camera, vec3 ta, vec2 st) {\n    mat3 ca = RAYMARCH_CAMERA_MATRIX_FNC(camera, ta);\n    \n#if defined(RAYMARCH_MULTISAMPLE)\n    vec4 color = vec4(0.0);\n    vec2 pixel = 1.0/RESOLUTION;\n    vec2 offset = rotate( vec2(0.5, 0.0), HALF_PI/4.);\n\n    for (int i = 0; i < RAYMARCH_MULTISAMPLE; i++) {\n        vec3 rd = ca * normalize(vec3((st + offset * pixel)*2.0-1.0, RAYMARCH_CAMERA_FOV));\n        color += RAYMARCH_RENDER_FNC( camera * RAYMARCH_CAMERA_SCALE, rd);\n        offset = rotate(offset, HALF_PI);\n    }\n    return color/float(RAYMARCH_MULTISAMPLE);\n#else\n    vec3 rd = ca * normalize(vec3(st*2.0-1.0, RAYMARCH_CAMERA_FOV));\n    return RAYMARCH_RENDER_FNC( camera * RAYMARCH_CAMERA_SCALE, rd);\n#endif\n}\n\nvec4 raymarch(vec3 camera, vec2 st) {\n    return raymarch(camera, vec3(0.0), st);\n}\n\n#endif\n\n// -- Here boilerplate code ends :) --\n\nvec3 worldPosToJumpyDumpty(vec3 p){\n    p.x-=1.5;\n    p.z-=iTime*2.;\n    p.y-=abs(sin(iTime*5.))*.2;\n    p=opRepite(p,vec3(3.));\n    return p;\n}\n\nvec3 raymarchCustomMaterial(vec3 ray,vec3 pos,vec3 nor,vec3 map){\n    vec3 posOrigin=pos;\n    \n    if(sum(map)<=0.){\n        return RAYMARCH_BACKGROUND;\n    }\n    \n    vec3 col=vec3(0.);\n    \n    // ambient\n    col+=map*.2;\n    \n    // diffuse and shadow\n    vec3 lightPos=vec3(2.,5.,10.);\n    vec3 lightDir=normalize(lightPos-pos);\n    float diff=max(dot(lightDir,nor),0.);\n    float shadow=raymarchSoftShadow(pos,lightDir,.05,1.5);\n    col+=map*diff*shadow;\n    \n    // specular\n    vec3 reflectDir=reflect(-lightDir,nor);\n    vec3 viewDir=normalize(-ray);\n    vec3 halfVec=normalize(lightDir+viewDir);\n    float spec=pow(max(dot(nor,halfVec),0.),32.);\n    col+=map*spec;\n    \n    if(pos.y>2.){\n        return RAYMARCH_BACKGROUND;\n    }\n    \n    pos=worldPosToJumpyDumpty(pos);\n    \n    if(map==COLOR_1){\n        // head\n        \n        // eye\n        vec2 uv1=pos.xy;\n        uv1.x=abs(uv1.x);\n        uv1/=vec2(.75,.5);\n        uv1-=vec2(-.15,.4);\n        float c1=circleSDF(uv1);\n        float eye=1.-smoothstep(.15,.151,c1);\n        col=mix(col,COLOR_3,eye);\n        \n        // mouth\n        vec2 uv2=pos.xy;\n        uv2.x=abs(uv2.x);\n        uv2.y-=.4;\n        uv2.y*=-1.;\n        float c2=lineSDF(uv2,vec2(0.),vec2(.05));\n        float mouth=1.-smoothstep(.0125,.01251,c2);\n        col=mix(col,COLOR_3,mouth);\n    }else if(map==COLOR_4){\n        // belt\n        vec2 uv3=pos.xy;\n        uv3/=vec2(.4);\n        uv3-=vec2(-.5,-.18);\n        uv3=fract(uv3);\n        float c3=circleSDF(uv3);\n        float polka=1.-smoothstep(.15,.151,c3);\n        col=mix(col,COLOR_5,polka);\n    }else if(map==COLOR_2){\n        // body\n        \n        vec2 uv4=pos.xy;\n        uv4/=vec2(.4);\n        uv4-=vec2(-.5,.05);\n        uv4.y/=.6;\n        uv4.y*=-1.;\n        float c4=triSDF(uv4);\n        float tri=1.-smoothstep(1.8,1.81,c4);\n        col=mix(col,COLOR_6,tri);\n        \n        vec2 uv5=pos.xy;\n        uv5/=vec2(.4);\n        uv5-=vec2(-.5,-1.05);\n        float c5=uv5.y;\n        float stripe=smoothstep(.09,.1,c5)-smoothstep(.19,.2,c5);\n        col=mix(col,COLOR_5,stripe);\n        \n        vec2 uv6=pos.xy;\n        uv6/=vec2(.4);\n        uv6-=vec2(-.7,-1.9);\n        uv6.y/=.7;\n        uv6.x/=1.4;\n        float c6=heartSDF(uv6);\n        float heart=1.-smoothstep(1.8,1.81,c6);\n        col=mix(col,COLOR_5,heart);\n    }\n    \n    // fog\n    float fog=exp(-.000005*pow(posOrigin.z,6.));\n    col=mix(col,RAYMARCH_BACKGROUND,1.-fog);\n    \n    return col;\n}\n\nvec4 jumpyDumpty(vec3 p,vec4 res){\n    \n    vec3 p1=p;\n    float head=sphereSDF(p1,.69);\n    head=opIntersection(head,boxSDF(p1-vec3(0.,1.3,0.),vec3(1.)));\n    res=opUnion(res,vec4(COLOR_1,head));\n    \n    \n    vec3 p2=p;\n    p2.x=abs(p2.x);\n    float ear=ellipsoidSDF(rotate(p2-vec3(.45,.7,0.),-PI/3.,vec3(0.,0.,1.)),vec3(.1,.25,.1));\n    res=opUnion(res,vec4(COLOR_1,ear),.025);\n    \n    \n    vec3 p3=p;\n    p3.y-=.3;\n    p3.y/=.8;\n    float body=coneSDF(p3-vec3(0.,-.6,0.),.75,.5,1.);\n    body=opIntersection(body,boxSDF(p3-vec3(0.,-1.,0.),vec3(1.)));\n    body*=.8;\n    res=opUnion(res,vec4(COLOR_2,body));\n    \n    \n    vec3 p4=p;\n    p4.y-=.14;\n    p4.y/=.8;\n    p4/=1.05;\n    p4.y*=-1.;\n    float skirt=coneSDF(p4-vec3(0.,-.6,0.),.75,.5,1.);\n    skirt=opIntersection(skirt,boxSDF(p4-vec3(0.,-1.,0.),vec3(1.)));\n    skirt*=.8;\n    p4*=1.05;\n    skirt=opIntersection(skirt,boxSDF(p4-vec3(0.,.8,0.),vec3(1.)));\n    res=opUnion(res,vec4(COLOR_2,skirt));\n    \n    \n    \n    vec3 p5=p;\n    p5.y-=.24;\n    p5.y/=.8;\n    p5/=1.04;\n    float belt=coneSDF(p5-vec3(0.,-.6,0.),.75,.5,1.);\n    belt=opIntersection(belt,boxSDF(p5-vec3(0.,-1.,0.),vec3(1.)));\n    belt*=.8;\n    p5*=1.04;\n    belt=opIntersection(belt,boxSDF(p5-vec3(0.,.8,0.),vec3(1.)));\n    res=opUnion(res,vec4(COLOR_4,belt));\n    return res;\n}\n\nvec4 raymarchMap(vec3 p){\n    vec4 res=vec4(1.);\n    \n    \n    \n    vec3 p1=p;\n    p1=worldPosToJumpyDumpty(p1);\n    res=jumpyDumpty(p1,res);\n    \n    \n    vec3 p2=p;\n    res=opUnion(res,vec4(vec3(1.),planeSDF(p2)+.75));\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=ratio(uv,iResolution.xy);\n    vec3 col=vec3(0.);\n    \n    vec3 camera=vec3(-30.,15.,50.);\n    col=raymarch(camera,uv).rgb;\n    \n    fragColor=vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 34841,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kai-gamer-240922295/lets-go-crimson-knight"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifndef FNC_RATIO\n#define FNC_RATIO\nvec2 ratio(in vec2 st, in vec2 s) {\n    return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                step(s.x,s.y));\n}\n#endif\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float radians){\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, -s, s, c);\n}\n#endif\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 st, in float radians, in vec2 center) {\n    return rotate2d(radians) * (st - center) + center;\n}\n\nvec2 rotate(in vec2 st, in float radians) {\n    #ifdef CENTER_2D\n    return rotate(st, radians, CENTER_2D);\n    #else\n    return rotate(st, radians, vec2(.5));\n    #endif\n}\n\nvec2 rotate(vec2 st, vec2 x_axis) {\n    #ifdef CENTER_2D\n    st -= CENTER_2D;\n    #endif\n    vec2 rta = vec2( dot(st, vec2(-x_axis.y, x_axis.x)), dot(st, x_axis) );\n    #ifdef CENTER_2D\n    rta += CENTER_2D;\n    #endif\n    return rta;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis, in vec3 center) {\n    return (rotate4d(axis, radians) * vec4(xyz - center, 1.)).xyz + center;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis) {\n    #ifdef CENTER_3D\n    return rotate(xyz, radians, axis, CENTER_3D);\n    #else\n    return rotate(xyz, radians, axis, vec3(0.));\n    #endif\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis, in vec4 center) {\n    return rotate4d(axis, radians) * (xyzw - center) + center;\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis) {\n    #ifdef CENTER_4D\n    return rotate(xyzw, radians, axis, CENTER_4D);\n    #else\n    return rotate(xyzw, radians, axis, vec4(0.));\n    #endif\n}\n#endif\n\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n#ifndef FNC_SUM\n#define FNC_SUM\n\nfloat sum( float v ) { return v; }\nfloat sum( vec2 v ) { return v.x+v.y; }\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\nfloat sum( vec4 v ) { return v.x+v.y+v.z+v.w; }\n\n#endif\n\n#ifndef FNC_LOOKAT\n#define FNC_LOOKAT\n\nmat3 lookAt(vec3 forward, vec3 up) {\n    vec3 xaxis = normalize(cross(forward, up));\n    vec3 yaxis = up;\n    vec3 zaxis = forward;\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nmat3 lookAt(vec3 target, vec3 eye, vec3 up) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nmat3 lookAt(vec3 target, vec3 eye, float roll) {\n    vec3 up = vec3(sin(roll), cos(roll), 0.0);\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = normalize(cross(xaxis, zaxis));\n    return mat3(xaxis, yaxis, zaxis);\n}\n\n#endif\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\n\nfloat rectSDF(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nfloat rectSDF(vec2 p, float b, float r) {\n    return rectSDF(p, vec2(b), r);\n}\n\nfloat rectSDF(in vec2 st, in vec2 s) {\n    st = st * 2. - 1.;\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n\nfloat rectSDF(in vec2 st, in float s) {\n    return rectSDF(st, vec2(s) );\n}\n\nfloat rectSDF(in vec2 st) {\n    return rectSDF(st, vec2(1.0));\n}\n\n#endif\n\n#ifndef FNC_CROSSSDF\n#define FNC_CROSSSDF\nfloat crossSDF(in vec2 st, in float s) {\n    vec2 size = vec2(.25, s);\n    return min(rectSDF(st.xy, size.xy),\n               rectSDF(st.xy, size.yx));\n}\n#endif\n#ifndef FNC_HEARTSDF\n#define FNC_HEARTSDF\nfloat heartSDF(vec2 st) {\n    st -= vec2(0.5, 0.8);\n    float r = length(st) * 5.0;\n    st = normalize(st);\n    return r - ((st.y * pow(abs(st.x), 0.67)) / (st.y + 1.5) - (2.0) * st.y + 1.26);\n}\n#endif\n#ifndef FNC_HEXSDF\n#define FNC_HEXSDF\nfloat hexSDF(in vec2 st) {\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * .866025 + st.y * .5);\n}\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_LINESDF\n#define FNC_LINESDF\nfloat lineSDF( in vec2 st, in vec2 a, in vec2 b ) {\n    vec2 b_to_a = b - a;\n    vec2 to_a = st - a;\n    float h = saturate(dot(to_a, b_to_a)/dot(b_to_a, b_to_a));\n    return length(to_a - h * b_to_a );\n}\n\nfloat lineSDF(vec3 p, vec3 a, vec3 b) {\n    \n    return length(cross(p - a, p - b))/length(b - a);\n}\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_POLYSDF\n#define FNC_POLYSDF\nfloat polySDF(in vec2 st, in int V) {\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a ) * r;\n}\n#endif\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n\n#ifndef FNC_RHOMBSDF\n#define FNC_RHOMBSDF\nfloat rhombSDF(in vec2 st) {\n    return max(triSDF(st),\n               triSDF(vec2(st.x, 1. - st.y)));\n}\n#endif\n#ifndef FNC_SPIRALSDF\n#define FNC_SPIRALSDF\nfloat spiralSDF(vec2 st, float t) {\n    st -= 0.5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_STARSDF\n#define FNC_STARSDF\nfloat starSDF(in vec2 st, in int V, in float s) {\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + .5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)),\n                   st));\n}\n#endif\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n\n#ifndef FNC_VESICASDF\n#define FNC_VESICASDF\nfloat vesicaSDF(in vec2 st, in float w) {\n    vec2 offset = vec2(w*.5,0.);\n    return max( circleSDF(st-offset),\n                circleSDF(st+offset));\n}\n#endif\n#ifndef FNC_FLOWERSDF\n#define FNC_FLOWERSDF\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2.0 - 1.0;\n    float r = length(st) * 2.0;\n    float a = atan(st.y, st.x);\n    float v = float(N) * 0.5;\n    return 1.0 - (abs(cos(a * v)) *  0.5 + 0.5) / r;\n}\n#endif\n\n#ifndef FNC_BOXFRAMESDF\n#define FNC_BOXFRAMESDF\n\nfloat boxFrameSDF( vec3 p, vec3 b, float e ) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n#endif\n#ifndef FNC_BOXSDF\n#define FNC_BOXSDF\n\nfloat boxSDF( vec3 p ) {\n    vec3 d = abs(p);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_CAPSULESDF\n#define FNC_CAPSULESDF\n\nfloat capsuleSDF( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p-a, ba = b-a;\n    float h = saturate( dot(pa,ba)/dot(ba,ba) );\n    return length( pa - ba*h ) - r;\n}\n\n#endif\n#ifndef FNC_CONESDF\n#define FNC_CONESDF\n\nfloat coneSDF( in vec3 p, in vec3 c ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat coneSDF( in vec3 p, in vec2 c, float h ) {\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat coneSDF( in vec3 p, in float r1, float r2, float h ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n#endif\n#ifndef FNC_BOXSDF\n#define FNC_BOXSDF\n\nfloat boxSDF( vec3 p ) {\n    vec3 d = abs(p);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#endif\n\n#ifndef FNC_CUBESDF\n#define FNC_CUBESDF\nfloat cubeSDF(vec3 p, float s)  { return boxSDF(p, vec3(s)); }\n#endif\n#ifndef FNC_CYLINDERSDF\n#define FNC_CYLINDERSDF\n\nfloat cylinderSDF( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF( vec3 p, float h ) {\n    return cylinderSDF( p, vec2(h) );\n}\n\nfloat cylinderSDF( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_DODECAHEDRONSDF\n#define FNC_DODECAHEDRONSDF\n\nfloat dodecahedronSDF(vec3 p) {\n    vec3 n = normalize(vec3(PHI,1.0,0.0));\n    p = abs(p);\n    float a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    \n    return (max(max(a,b),c)-n.x);\n}\n\nfloat dodecahedronSDF(vec3 p, float radius) {\n    vec3 n = normalize(vec3(PHI,1.0,0.0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;\n}\n\n#endif\n#ifndef FNC_ELLIPSOIDSDF\n#define FNC_ELLIPSOIDSDF\n\nfloat ellipsoidSDF( in vec3 p, in vec3 r ) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n#endif\n#ifndef FNC_HEXPRISMSDF\n#define FNC_HEXPRISMSDF\n\nfloat hexPrismSDF( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_ICOSAHEDRONSDF\n#define FNC_ICOSAHEDRONSDF\n\nfloat icosahedronSDF(vec3 p, float radius) {\n    float q = 2.61803398875; \n    vec3 n1 = normalize(vec3(q, 1,0));\n    vec3 n2 = vec3(0.57735026919);  \n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\n#endif\n#ifndef FNC_LINKSDF\n#define FNC_LINKSDF\nfloat linkSDF( vec3 p, float le, float r1, float r2 ) {\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n#endif\n#ifndef FNC_OCTAHEDRONSDF\n#define FNC_OCTAHEDRONSDF\n\nfloat octahedronSDF(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n#ifdef OCTAHEDRON_EXACT_DISTANCE\n    \n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n\n    \n#else\n    \n    return m*0.57735027;\n#endif\n}\n\n#endif\n#ifndef FNC_OCTOGONPRISMSDF\n#define FNC_OCTOGONPRISMSDF\n\nfloat octogonPrismSDF( in vec3 p, in float r, float h ) {\n   vec3 k = vec3( -0.9238795325,   \n                  0.3826834323,   \n                  0.4142135623 ); \n   \n   p = abs(p);\n   p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n   p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n   \n   p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n   vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n   return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n#endif\n#ifndef FNC_PLANESDF\n#define FNC_PLANESDF\nfloat planeSDF( vec3 p ) { \n   return p.y; \n}\n\nfloat planeSDF(vec3 p, vec3 planePoint, vec3 planeNormal) {\n    return (dot(planeNormal, p) + dot(planeNormal, planePoint)) / length(planeNormal);\n}\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_PYRAMIDSDF\n#define FNC_PYRAMIDSDF\n\nfloat pyramidSDF( in vec3 p, in float h )  {\n   float m2 = h*h + 0.25;\n   \n   \n   p.xz = abs(p.xz);\n   p.xz = (p.z>p.x) ? p.zx : p.xz;\n   p.xz -= 0.5;\n\n   \n   vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n   float s = max(-q.x,0.0);\n   float t = saturate( (q.y-0.5*p.z)/(m2+0.25) );\n   \n   float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n   float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n   \n   float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n   \n   \n   return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n#endif\n#ifndef FNC_SPHERESDF\n#define FNC_SPHERESDF\nfloat sphereSDF(vec3 p) { return length(p); }\nfloat sphereSDF(vec3 p, float s) { return sphereSDF(p) - s; }\n#endif\n#ifndef FNC_TETRAHEDRONSDF\n#define FNC_TETRAHEDRONSDF\nfloat tetrahedronSDF(vec3 p, float h)  {\n    vec3 q = abs(p);\n    \n    float y = p.y;\n    float d1 = q.z-max(0.,y);\n    float d2 = max(q.x*.5 + y*.5,.0) - min(h, h+y);\n    return length(max(vec2(d1,d2),.005)) + min(max(d1,d2), 0.0);\n}\n#endif\n#ifndef FNC_TORUSSDF\n#define FNC_TORUSSDF\nfloat torusSDF( vec3 p, vec2 t ) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\n\nfloat torusSDF(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n#endif\n#ifndef FNC_TRIPRISMSDF\n#define FNC_TRIPRISMSDF\n\nfloat triPrismSDF( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n#endif\n\n#ifndef FNC_OPONION\n#define FNC_OPONION\n\nfloat opOnion( in float d, in float h ) {\n    return abs(d)-h;\n}\n\n#endif\n#ifndef FNC_OPREPITE\n#define FNC_OPREPITE\n\nvec2 opRepite( in vec2 p, in float s ) {\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 opRepite( in vec3 p, in vec3 c ) {\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRepite( in vec2 p, in vec2 lima, in vec2 limb, in float s ) {\n    return p-s*clamp(floor(p/s),lima,limb);\n}\n\nvec3 opRepite( in vec3 p, in vec3 lima, in vec3 limb, in float s ) {\n    return p-s*clamp(floor(p/s),lima,limb);\n}\n\n#endif\n#ifndef FNC_OPREVOLVE\n#define FNC_OPREVOLVE\n\nvec2 opRevolve( in vec3 p, float w ) {\n    return vec2( length(p.xz) - w, p.y );\n}\n\n#endif\n#ifndef FNC_OPREVOLVE\n#define FNC_OPREVOLVE\n\nfloat opRound( in float d, in float h ) {\n    return d - h;\n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_OPSUBSTRACTION\n#define FNC_OPSUBSTRACTION\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1, d2); }\nvec4  opSubtraction( vec4 d1, vec4 d2 ) { return (-d1.a > d2.a) ? -d1 : d2; }\n\nfloat opSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec4 opSubtraction( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.a+d1.a)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_OPINTERSECTION\n#define FNC_OPINTERSECTION\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opIntersection( float d1, float d2, float k ) {\n    float h = saturate( 0.5 - 0.5*(d2-d1)/k );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_OPUNION\n#define FNC_OPUNION\n\nfloat opUnion( float d1, float d2 ) { return min(d1, d2); }\nvec4  opUnion( vec4 d1, vec4 d2 ) { return (d1.a < d2.a) ? d1 : d2; }\n\nfloat opUnion( float d1, float d2, float k ) {\n    float h = saturate( 0.5 + 0.5*(d2-d1)/k );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec4 opUnion( vec4 d1, vec4 d2, float k ) {\n    float h = saturate( 0.5 + 0.5*(d2.a - d1.a)/k );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n#endif\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float radians){\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, -s, s, c);\n}\n#endif\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 st, in float radians, in vec2 center) {\n    return rotate2d(radians) * (st - center) + center;\n}\n\nvec2 rotate(in vec2 st, in float radians) {\n    #ifdef CENTER_2D\n    return rotate(st, radians, CENTER_2D);\n    #else\n    return rotate(st, radians, vec2(.5));\n    #endif\n}\n\nvec2 rotate(vec2 st, vec2 x_axis) {\n    #ifdef CENTER_2D\n    st -= CENTER_2D;\n    #endif\n    vec2 rta = vec2( dot(st, vec2(-x_axis.y, x_axis.x)), dot(st, x_axis) );\n    #ifdef CENTER_2D\n    rta += CENTER_2D;\n    #endif\n    return rta;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis, in vec3 center) {\n    return (rotate4d(axis, radians) * vec4(xyz - center, 1.)).xyz + center;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis) {\n    #ifdef CENTER_3D\n    return rotate(xyz, radians, axis, CENTER_3D);\n    #else\n    return rotate(xyz, radians, axis, vec3(0.));\n    #endif\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis, in vec4 center) {\n    return rotate4d(axis, radians) * (xyzw - center) + center;\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis) {\n    #ifdef CENTER_4D\n    return rotate(xyzw, radians, axis, CENTER_4D);\n    #else\n    return rotate(xyzw, radians, axis, vec4(0.));\n    #endif\n}\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef RANDOM_SCALE\n#if defined(RANDOM_HIGHER_RANGE)\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#if defined(RANDOM_SINLESS)\n    return fract(sin(x) * 43758.5453);\n#else\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#endif\n}\n\nfloat random(in vec2 st) {\n#if defined(RANDOM_SINLESS)\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#if defined(RANDOM_SINLESS)\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#if defined(RANDOM_SINLESS)\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy+33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n#endif\n\n#ifndef FNC_RAYMARCHCAMERA\n#define FNC_RAYMARCHCAMERA\n\nmat3 raymarchCamera( in vec3 ro, in vec3 ta, in vec3 up ) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = up;\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 raymarchCamera( in vec3 ro, in vec3 ta, float cr ) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 raymarchCamera( in vec3 ro, in vec3 ta ) {\n    return raymarchCamera( ro, ta, vec3(0.0, 1.0, 0.0) );\n}\n\nmat3 raymarchCamera( in vec3 ro ) {\n    return raymarchCamera( ro, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0) );\n}\n\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}