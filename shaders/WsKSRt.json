{
    "Shader": {
        "info": {
            "date": "1574745303",
            "description": "Recreating the Hiptunes album cover.\n\nhttp://hiptunesalbum.com/\nhttps://soundcloud.com/kickblips/sets/hiptunes\n",
            "flags": 96,
            "hasliked": 0,
            "id": "WsKSRt",
            "likes": 5,
            "name": "Hiptunes",
            "published": 3,
            "tags": [
                "skyline",
                "hiptunes"
            ],
            "usePreview": 0,
            "username": "stellartux",
            "viewed": 775
        },
        "renderpass": [
            {
                "code": "#define CURVED_SKY 1\n#define SHOW_BUILDING 1\n\n#define CAMERA_OFFSET sin(iTime * .1) * .024, cos(iTime * .2) * .012\n#define MIN_DIST 0.0012\n#define MAX_DIST .95\n#define RAY_STEPS 15u\n#define BUILDING_BLUE vec3(0.173, 0.153, 0.231)\n#define OUTLINE_COLOR vec3(0.271, 0.267, 0.4)\n#define OFFSET cos(iTime) * .001\n\nconst float PI = acos(-1.);\nconst vec3 buildingPos = vec3(-0.45, -0.45, 1.);\nconst vec3 buildingDims = vec3(.1, .5, .09);\nconst float buildingAngle = -PI / 12.;\n\nfloat sdBuilding(vec3 p) {\n   float h = -buildingDims.y + OFFSET;\n   return min(min(min(min(\n       sdBox(p, vec3(buildingDims.xz, -h).xzy),\n       sdBox(p + vec3(-.006, h, 0.), vec3(.11, .01, .11))),\n       sdBox(p + vec3(-.06, h-.02, 0.), vec3(.033, .04, .05))),\n       sdBox(p + vec3(0.06, h-.02, .01), vec3(.004, .1, .004))),\n       sdBox(p + vec3(0.08, h-.02, .02), vec3(.004, .05, .004)));\n}\n\nfloat window(vec2 uv, vec2 thickness) {\n    if (uv.x < thickness.x\n        || uv.y < thickness.y \n        || uv.x > 1. - thickness.x \n        || uv.y > 1. - thickness.y)\n        return 0.;\n    else return 1.; \n}\n\nfloat windowRepeats(vec2 uv, vec2 rep) {\n    return window(mod(uv * rep, 1.), vec2(0.14, .1));\n}\n\nvec2 wallCoords(vec3 p) {\n    vec3 q = (abs(p * rotateY(buildingAngle / 2.)) - buildingDims / 2.);\n    if (abs(q.x) > abs(q.z)) {\n        return q.zy;\n    } else \n        return q.xy;\n}\n\nvec3 colorBuilding(vec3 p, vec3 dims) {\n    if (p.y > buildingPos.y + buildingDims.y - .04) return BUILDING_BLUE;\n    else {\n   \t\tvec3 c = texture(iChannel0, mod(p.xy + vec2(0., .425), vec2(1.))).rgb;\n        p *= rotateY(-buildingAngle);\n        vec2 uv = wallCoords(p);\n        uv.y -= OFFSET;\n        c = mix(BUILDING_BLUE, c, windowRepeats(uv, vec2(24.8, 9.)));\n        return c;    \n    }\n}\n\nvec3 raymarchScene( vec3 ro, vec3 rd, vec2 uv, vec2 bguv) {\n\tvec3 p = ro;\n    float min_dist_so_far = 1.;\n    float d = 0.;\n    \n    #if (SHOW_BUILDING)\n    for (uint s = 0u; s < RAY_STEPS; s++) {\n    \td = sdBuilding((p - buildingPos) * rotateY(buildingAngle));\n      \tif (d > MAX_DIST) break;\n        min_dist_so_far = min(d, min_dist_so_far);\n        if (d < MIN_DIST) return colorBuilding(p, buildingDims);\n        \n        p += d * rd;\n    }\n    if (min_dist_so_far < 0.003) return OUTLINE_COLOR;\n    #endif\n    \n    #if (CURVED_SKY)\n    vec2 st = (ro + rd).xy + vec2(.65, 0.383);\n    st *= vec2(.57, 1.31);\n    return texture(iChannel0, st).rgb;\n    #else\n    return texture(iChannel0, bguv * .9 + vec2(CAMERA_OFFSET) * vec2(.1,.5) + vec2(.05, iTime * .00001)).rgb;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 bguv = fragCoord / iResolution.xy;\n    vec2 uv = 2.*(fragCoord / iResolution.xy - vec2(.5));\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(CAMERA_OFFSET, 0.);\n    vec3 rd = normalize(vec3(uv, 2.45));\n\n    vec3 col  = raymarchScene(ro, rd, uv, bguv);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 20379,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kickblips/business-pastel-when-the-sun?in=kickblips/sets/hiptunes"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// off top of head\n\nfloat dSquare(vec2 p, float len) {\n    float l = len * .5;\n    return min(l - abs(p.x), l - abs(p.y));\n}\n\nmat2 rotate2d(float a) {\n    float b = cos(a);\n    return mat2(b, -sin(a), sin(a), b);\n}\n\nmat3 rotateY(float a) {\n    float s = sin(a);\n    float c = cos(a);\n \treturn mat3(\n    \tc, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n    );   \n}\n\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Buffer for the animated sky texture\n\n// change how boxy the sky is\n// small numbers are calm, big numbers are busy\n// most of the variety happens between 0.3 and 15.0\n// even numbers are smooth, odd numbers are rough, don't know why\n#define MAGIC 8.\n\nfloat floatingSquare (vec2 uv, float initialSize, float time, float rotationSpeed, float height, float id) {\n    float s = 27./(14. + id/20.);\n    float clock = mod(time, s) / s;\n    float size = initialSize * (.98 - pow(2. * clock - .8, MAGIC));\n\treturn step(0., dSquare((uv + vec2(-initialSize*.707, clock * (1.82 - initialSize) * height)) * rotate2d(rotationSpeed * clock), size));  \n}\n\nfloat squareLayer (vec2 uv, float time, float size, float height) {\n\tvec2 space = uv;\n    space *= size;\n    float id = floor(space.x);\n    space.x = mod(space.x, 1.);\n    return floatingSquare(space * 3., abs(cos(id)) * height * .6, time, sin(id) * .6, height * 1.2, id);\n}\n\nfloat squaresLayer (vec2 uv, float time, float height) {\n    return squareLayer(uv - vec2(1., 0.), time * .2, 4., 16. / height)\n        + squareLayer(uv, time, 1.45, height * .8)\n        + squareLayer(uv + vec2(2., -0.04), time * .5, 1.8, height * 1.2)\n        + squareLayer(uv + vec2(3.5, 0.04), time * 1.3, 3.1, height * 1.33)\n        ;\n}\n\nfloat squareBoundary (vec2 uv, float time, float height) {\n    float id = floor(uv.x * 19.);\n    float col = step(0., uv.y + cos(id+time)*sin(2.*id)*.06);\n    \n    col += squaresLayer(uv, time, height);\n    col -= squaresLayer(vec2(uv.x + 0.37, -uv.y + 0.06), time, height);\n    return col;\n}\n\nvec3 squareMix (vec2 uv, float time, vec3 c1, vec3 c2, float height) {\n    return mix(c1, c2, clamp(squareBoundary(uv, time, height), 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord / iResolution.xy - vec2(.5));\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.;\n    vec2 uuv = vec2(-uv.x, uv.y);\n    float t = 40. + iTime * .2;\n    \n    \n    vec3 col = vec3(.741, .756, .596);\n    col = squareMix(uv + vec2(0., 4.65), t, col, vec3(0.471, 0.667, 0.612), .7);\n    col = squareMix(uuv + vec2(12., 4.1), t, col, vec3(0.373, 0.643, 0.671), .8);\n    col = squareMix(uv + vec2(23., 3.5), t, col, vec3(0.337, 0.541, 0.612), 1.);\n    col = squareMix(uuv + vec2(35., 2.7), t, col, vec3(0.318, 0.431, 0.537), 1.2);\n    col = squareMix(uv + vec2(47., 1.8), t, col, vec3(0.294, 0.345, 0.459), 1.4);\n    col = squareMix(uuv + vec2(59.4, .6), t, col, vec3(0.271, 0.267, 0.4), 2.3);\n    col = squareMix(uv + vec2(81., -1.2), t, col, vec3(0.235, 0.220, 0.325), 2.6);\n    col = squareMix(uuv + vec2(93.3, -3.), t, col, vec3(0.200, 0.169, 0.251), 3.4);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}