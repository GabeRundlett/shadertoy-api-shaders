{
    "Shader": {
        "info": {
            "date": "1458524701",
            "description": "An visualisation of how a detrend function works. I use this to deflicker video and timelapse luminance. May or may not be of use to someone.<br/><br/>White= input data, Red= the trend error offset, Green= output data.<br/><br/>Try the WINDOWs in [Buf A]",
            "flags": 32,
            "hasliked": 0,
            "id": "lsdXR7",
            "likes": 12,
            "name": "Detrend",
            "published": 3,
            "tags": [
                "math",
                "filter",
                "graph",
                "data",
                "multipass",
                "detrend"
            ],
            "usePreview": 0,
            "username": "dine909",
            "viewed": 986
        },
        "renderpass": [
            {
                "code": "/*\nBy dine909\n\nBelow is just the graph display, the detrend function is on [Buf A]\n*/\n#define IF_LT(a_,b_) step(a_-b_,0.)\n#define IF_GT(a_,b_) step(b_-a_,0.)\n\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\nfloat render(vec2 uv,float d)\n{\n    return clamp(antiAlias(d), 0.0, 1.0);\n\n}\nfloat lineseg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n\n    return  (1.0 - d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col=vec3(0.);\n\n    vec4 txp=texture(iChannel0,vec2(uv.x,0.));\n    vec4 txlp=texture(iChannel0,vec2(uv.x-(1./iResolution.x),0.));\n\n    float d=0.;\n\n    d=lineseg(uv,vec2(uv.x,txlp.x),vec2(uv.x,txp.x));\n    col+=vec3(8.)*render(uv,d)*IF_GT(uv.x,txp.w);\t\n\n    d=lineseg(uv,vec2(uv.x,txlp.z),vec2(uv.x,txp.z));\n    col+=vec3(.4)*render(uv,d);\t\n\n    \n    d=lineseg(uv,vec2(uv.x,txlp.y),vec2(uv.x,txp.y));\n    col+=vec3(0.,1.,0.)*render(uv,d)*IF_LT(uv.x,txp.w);\t\n\n    d=lineseg(uv,vec2(txlp.w,1.),vec2(txp.w,0.));\n    col+=vec3(0.,0.,1.)*render(uv,d);\t\n\n    d=lineseg(uv,vec2(uv.x,0.5+txlp.x-txlp.y),vec2(uv.x,0.5+txp.x-txp.y));\n    col+=vec3(.4,0.,0.)*render(uv,d);\t\n    col+=vec3(1.,0.,0.)*render(uv,d)*IF_LT(uv.x,txp.w);\t\n\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//try these windows out, they reject one, some or all noise from the main cosine trend.\n\n//#define WINDOW 10.\n//#define WINDOW 25.\n#define WINDOW 200.\n\n//uncomment this to continue smoothing passes of same signal, else a new one will be generated for every pass.\n//#define MULTIPASS\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n#define IF_LT(a_,b_) step(a_-b_,0.)\n#define IF_GT(a_,b_) step(b_-a_,0.)\n\n#define store(what,value) storeValue( what, value, \tfragColor, fragCoord )\n#define isinit IF_GT(float(iFrame),0.5)\n#define noinit IF_LT(float(iFrame),0.5)\n#define load(what,value,default) vec4 value=(loadValue(iChannel0,what)*isinit )+(noinit*default)\n\nvec4 loadValue(sampler2D tex, in vec2 re )\n{\n    return texture( tex, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return max(d1,d2);\n}\nfloat opS(float a,float b) { return min(2.-b,a); }\n\nfloat box( in vec2 p, in vec2 a, in vec2 b )\n{\n\n    return  1.-max(-isInside(p,a),-isInside(-p,-b));\n}\n\nfloat getY(float t){\n    //\tt+=iTime*0.1;\n    t*=3.;\n    float r=rand(vec2(iDate.w+t,t*iTime));\n    float y=sin(t*20.)*0.075;\n    y+=sin(t*40.)*0.075;\n    y*=0.5;\n    y+=0.5+0.45*cos(iDate.w+(t*2.));\n    y+=r*0.04;\n    //    y+=0.5;\n    return y;\n}\n\nconst vec2 txParams=vec2(0.,1.);\n#define pHighWindow params.x\n#define pLowWindow params.y\n#define pAverage params.z\n#define pValCount params.w\n\nvoid detrend(inout vec4 params,inout vec4 tx,in float procframe){\n    pLowWindow =  floor(WINDOW / 2.) ;\n    pHighWindow = floor(WINDOW - pLowWindow);\n\n    //  for(int i=0;i<2000;i++)\n    pValCount = 0.;\n    pAverage = 0.;\n    int jv=int( procframe - pLowWindow );\n    for(int j=0;j<2000;j++){ //pseudo while(true)\n        if ( jv >= 0 && jv < int(iResolution.x) ) {\n            vec4 ltx=texture(iChannel0,vec2(float(jv)/iResolution.x,0.));\n            pValCount++;\n            pAverage+=ltx.x;\n        }\n\n        jv++;\n        if(jv>=int( procframe + (pHighWindow) )) break;\n    }\n    tx.y =pAverage/ pValCount;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    load(txParams,params,vec4(0.));\n    vec4 col=vec4(0.);\n    if(fragCoord.y<1.){ \n        vec4 tx=texture(iChannel0,uv);\n\n        float procframe=mod(float(iFrame),iResolution.x);\n         if(procframe==0.)\n        #ifdef MULTIPASS\n            {\n                tx.x=tx.y;\n                params*=0.;            \n            }\n        else \n            if(iFrame==0)\n            #endif\n        {\n            float data = getY(uv.x);\n            tx*=0.; \n            tx.xyz=vec3(data);\n            params*=0.;            \n        }\n           \n        float procx=procframe/iResolution.x;\n\n        //detrend\n        if(isInside(uv,vec2(procx,0.))>0.)\n        {\n            detrend(params,tx,procframe);\n        }\n        col=vec4(tx.x,(tx.y),tx.z,procx);\t\n    }\n\n    fragColor = vec4(col);\n\n    store(txParams,params);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}