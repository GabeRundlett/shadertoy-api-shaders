{
    "Shader": {
        "info": {
            "date": "1469209443",
            "description": "Controls: arrow keys / space / shift",
            "flags": 48,
            "hasliked": 0,
            "id": "MtdGDn",
            "likes": 5,
            "name": "Platformer template",
            "published": 3,
            "tags": [
                "game",
                "template",
                "platformer"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "#define collidersNum 5\n\nconst vec2 txPlayerPos = vec2(5., 5.);\nconst vec2 txWorldPos = vec2(7., 7.);\n\nconst vec2 playerWH = vec2(0.09, 0.09);\n\nstruct colType {\n\tvec4 posWH;\n};\ncolType colliders[collidersNum];\n\nvec4 loadValue(in vec2 re)\n{\n    return texture(iChannel0, (re + 0.5) / iChannelResolution[0].xy);\n}\n\nfloat dist(vec2 a, vec2 b) {\n\treturn sqrt((b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    colliders[0].posWH = vec4(0., 0.1, 100., 0.2);\n    colliders[1].posWH = vec4(0., 0.7, 0.2, 1.5);\n    colliders[2].posWH = vec4(0.9, 0.4, 0.2, 0.06);\n    colliders[3].posWH = vec4(1.3, 0.65, 0.2, 0.06);\n    colliders[4].posWH = vec4(3.0, 0.7, 0.2, 1.5);\n    vec4 col;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = uv;\n    r.x *= iResolution.x/ iResolution.y;\n    \n\tfragColor.rgb = vec3(0.2, 0.5, 0.3);\n    \n    vec2 worldPos = loadValue(txWorldPos).xy;\n    vec2 playerPos = loadValue(txPlayerPos).xy;\n    vec2 playerWorldPos = playerPos + worldPos;\n    \n    if (abs(mod(r.x + worldPos.x, 0.3)) < 0.05) fragColor = vec4(0.3, 0.3, 0.3, 1.);\n    \n    // colliders\n    for (int i = 0; i < collidersNum; i++) {\n        col = colliders[i].posWH;\n        if (r.y + worldPos.y < col.y + col.w / 2. && r.y + worldPos.y > col.y - col.w / 2. &&\n           r.x + worldPos.x < col.x + col.z / 2. && r.x + worldPos.x > col.x - col.z / 2.) {\n            fragColor.rgb = vec3(0.4, 0., 0.);\n        }\n    }\n    if (dist(playerPos, r) < playerWH.x / 2.) fragColor = vec4(0., 0., 0., 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define gravity vec2(0., -5.)\n#define collidersNum 5\n\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst vec2 txPlayerPos = vec2(5., 5.);\nconst vec2 txWorldPos = vec2(7., 7.);\nconst vec2 txInertiaPos = vec2(9., 9.);\n\nconst vec2 playerWH = vec2(0.09, 0.09);\nconst vec2 worldWH = vec2(3., 1.);\n\nstruct colType {\n\tvec4 posWH;\n};\ncolType colliders[collidersNum];\n\nvoid storeValue(vec2 txPos, vec4 value, inout vec4 fragColor, vec2 fragCoord) {\n\tif (abs(txPos.x - fragCoord.x) < 1. && abs(txPos.y - fragCoord.y) < 1.)\n        fragColor = value;\n}\n\nvec4 loadValue(in vec2 re)\n{\n    return texture(iChannel0, (re + 0.5) / iChannelResolution[0].xy);\n}\n\nbool isInside(vec2 p, vec4 rectPosWH) {\n\tif (abs(rectPosWH.x - p.x) < rectPosWH.z / 2. &&\n        abs(rectPosWH.y - p.y) < rectPosWH.w / 2.) return true;\n    \n    return false;\n}\n\nbool doCollide(vec4 rectA, vec4 rectB) {\n\n    if ( rectA.x - rectA.z / 2. < rectB.x + rectB.z / 2.&&\n       rectA.x + rectA.z / 2. > rectB.x - rectB.z / 2. &&\n       rectA.y + rectA.w / 2. > rectB.y - rectB.w / 2. &&\n       rectA.y - rectA.w / 2. < rectB.y + rectB.w / 2. ) return true;\n    \n    return false;\n}\n\nbool isCollidedByAny(vec2 playerWorldPos) {\n    \n    for (int i = 0; i < collidersNum; i++) {\n        \n        if (doCollide(vec4(playerWorldPos, playerWH), colliders[i].posWH)) {\n            return true;\n        }\n\n    }\n\treturn false;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    float midW = ratio / 2.;\n    \n    colliders[0].posWH = vec4(0., 0.1, 100., 0.2);\n    colliders[1].posWH = vec4(0., 0.7, 0.2, 1.5);\n    colliders[2].posWH = vec4(0.9, 0.4, 0.2, 0.06);\n    colliders[3].posWH = vec4(1.3, 0.65, 0.2, 0.06);\n    colliders[4].posWH = vec4(3.0, 0.7, 0.2, 1.5);\n    \n    vec2 prevPlayerPos = vec2(0.5, 0.5);\n    vec2 prevWorldPos = vec2(0., 0.);\n    vec2 prevInertia = vec2(0., 0.);\n    vec2 playerPos;\n    vec2 worldPos;\n    vec2 playerWorldPos;\n    vec2 inertia;\n    vec4 col;\n    \n    // read prev state\n    if (iFrame > 0) {\n    \tprevPlayerPos = loadValue(txPlayerPos).xy;\n        prevWorldPos = loadValue(txWorldPos).xy;\n        prevInertia = loadValue(txInertiaPos).xy;\n    }\n    \n    inertia = prevInertia;\n    inertia.y = max(inertia.y + iTimeDelta*gravity.y, -1.);\n    \n    // input\n    vec2 controlsMove = vec2(0.0);\n    bool wantToJump = false;\n    if( texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x > 0.5 ) controlsMove.x = 0.02;\n    if( texture( iChannel1, vec2(KEY_LEFT, 0.25) ).x > 0.5 ) controlsMove.x = -0.02;\n    if( texture( iChannel1, vec2(KEY_SHIFT, 0.25) ).x > 0.5 ) controlsMove.x *= 2.;\n    if( texture( iChannel1, vec2(KEY_SPACE, 0.25) ).x > 0.5 ) wantToJump = true;\n    \n    // TODO: handle jump\n    if (wantToJump) {\n    \tinertia.y = 1.;\n    }\n    \n    worldPos = prevWorldPos;\n    playerPos = prevPlayerPos + controlsMove + inertia * iTimeDelta;\n    playerWorldPos = playerPos + worldPos;\n    \n    // collisions\n    bool controlsMovePossible = true;\n    bool inertiaMovePossible = true;\n    \n    bool movePossible = !isCollidedByAny(playerWorldPos);\n    \n    if (!movePossible) {\n        \n        playerPos = prevPlayerPos + controlsMove;\n    \tplayerWorldPos = playerPos + worldPos;\n        \n        controlsMovePossible = !isCollidedByAny(playerWorldPos);\n        \n        if (!controlsMovePossible) {\n            playerPos = prevPlayerPos + inertia * iTimeDelta;\n    \t\tplayerWorldPos = playerPos + worldPos;\n            \n            inertiaMovePossible = !isCollidedByAny(playerWorldPos);\n        }\n        \n        if (!inertiaMovePossible) {\n            playerPos = prevPlayerPos;\n    \t\tplayerWorldPos = playerPos + worldPos;\n            inertia.y /= 2.; // TODO: think about gap issue\n        }\n    }\n    \n    // worldPos\n    if (playerPos.x > midW && worldPos.x < worldWH.x - 2.*midW) {\n        worldPos.x += playerPos.x - midW;\n        playerPos.x = midW;\n    } else if (playerPos.x > midW) {\n    \tworldPos.x = min(worldPos.x, worldWH.x);\n    } else if (worldPos.x > 0.) {\n    \tworldPos.x = max(worldPos.x + playerPos.x - midW, 0.);\n        playerPos.x = midW;\n    }\n        \n\t// \n    playerPos = clamp(playerPos, vec2(0.), vec2(ratio, 1.));\n    storeValue(txPlayerPos, vec4(playerPos, 1., 1.), fragColor, fragCoord);\n    storeValue(txWorldPos, vec4(worldPos, 1., 1.), fragColor, fragCoord);\n    storeValue(txInertiaPos, vec4(inertia, 1., 1.), fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}