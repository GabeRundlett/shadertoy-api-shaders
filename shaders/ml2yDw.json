{
    "Shader": {
        "info": {
            "date": "1691867824",
            "description": "Demodulation shader showdown qualifier",
            "flags": 0,
            "hasliked": 0,
            "id": "ml2yDw",
            "likes": 10,
            "name": "Demodulation 2023 qualifier",
            "published": 3,
            "tags": [
                "showdown",
                "demodulation"
            ],
            "usePreview": 0,
            "username": "kostik1337",
            "viewed": 166
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define INF (1./0.)\n#define rep(p,s) (mod(p,(s))-(s)/2.)\n#define mr(t) (mat2(cos(t),-sin(t),sin(t),cos(t)))\n#define PI 3.1415926535\n\n#define BPM 130.\n#define beat (time/60.*BPM)\n\nfloat ffti(float t) {\n  return iTime * exp(t*2.);\n}\n\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\n\nfloat hash(float t) {return fract(sin(t)*45325.32165);}\nfloat hash(vec2 t) {return hash(dot(t,vec2(1.44,2.46423)));}\n\nfloat mybox(vec3 p, vec3 s, float h) {\n  float m1 = box(p,s);\n  float m = INF;\n  for(float i=0.;i<3.;++i) {\n    p += s*vec3(\n      hash(h+i),\n      hash(h+1.22+i)+time,\n      hash(h+1.77+i)\n    );\n    s *= .69;\n    p=rep(p, 2.*s);\n    m=min(m, box(p, s/1.7));\n  }\n  return max(-m, m1);\n}\n\n\nvec3 glow = vec3(0.);\n\nfloat map(vec3 p) {\n  p.x += time*.3;\n  vec3 op=p;\n  float m=INF;\n  \n  for(float i=0.; i<2.;++i) {\n    p = op;\n    float sx = .5;\n    if(i==1.) p.x += .5*sx;\n    vec2 cell = vec2(0.);\n    cell.x = floor(p.x / sx);\n    p.x = rep(p.x, sx);\n    \n    float sy = mix(.2, 1.5, hash(cell.x));\n    p.y += ffti(hash(cell.x+1.32))*.15 * (i==1. ? -1. : 1.);\n    cell.y = floor(p.y/sy);\n    p.y = rep(p.y, sy);\n    \n    vec3 bs = vec3(sx/7., sy/2.2, mix(.02, .08, hash(cell)));\n    //float m1=box(p, bs);\n    float m1=mybox(p, bs, hash(cell+2.11));\n    if(hash(cell+1.12 + floor(beat))<.3) {\n      glow += vec3(1.,1.2,1.5)*.002/(m1+.01) * exp(-3.*fract(beat));\n    }\n    m = min(m, m1);\n  }\n  \n  return min(m, -op.z+.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float blur=smoothstep(0., 1.5, dot(uv,uv));\n\n  vec3 c=vec3(0.);\n  vec3 O=vec3(0.,0.,-6.), D=vec3(uv, 6.);\n  D += .2*(hash(uv+time)-.5) * blur;\n  D = normalize(D);\n  O.yz *= mr(-PI/4.);\n  D.yz *= mr(-PI/4.);\n  if(fract(beat/32.)<.5) {\n    O.xy *= mr(PI/4.);\n    D.xy *= mr(PI/4.);\n  }\n  \n  float d=0.,i;\n  for(i=0.;i<64.;++i) {\n    vec3 p=O+D*d;\n    float m=map(p);\n    d += m;\n    if(m<.001*d) {\n      break;\n    }\n  }\n  c += exp(-d*.07) * pow(max(0., 1.-i/32.), 3.);\n  c += glow;\n  c = sqrt(c);\n  c *= mix(1., .3, blur);\n\t\n\tfragColor = vec4(c, 0.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}