{
    "Shader": {
        "info": {
            "date": "1581480878",
            "description": "Shiny",
            "flags": 32,
            "hasliked": 0,
            "id": "tldSzf",
            "likes": 28,
            "name": "City of Future",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "glass",
                "city",
                "lensflare"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 1135
        },
        "renderpass": [
            {
                "code": "// Fork of \"Crystal City\" by omgadev. https://shadertoy.com/view/tt3SW7\n// 2020-02-09 04:29:40\n\n//\n// Added huge lensflare filter kernel to try to keep up with shiny pixels from frame to frame.\n//\n// Added coloring and fudged the normals for more realism. Minor tweaks to liven up the scene. \n//\n// Removed original limit of 2 reflection bounces, now stops when contribution to pixel color drops low.\n//\n\nvec4 image(vec2 U) {\n    vec4 S = texelFetch(iChannel0, ivec2(U), 0);\n    vec4 V = texelFetch(iChannel1, ivec2(U), 0);\n    vec2 pos = V.xy;\n    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n\n    vec4 O = S;\n    O += sunflare(U, R, pos, T);\n\n    O.rgb *= smoothstep(vec3(0.875),vec3(0.5,0.5,0.6),vec3(length(0.5-U/R)));\n    return O;\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 lightColor = normalize(vec3(0.8, 1.0, 1.0));\nvec3 skyColor1 = normalize(vec3(0.2, 0.6, 1.0));\nvec3 skyColor2 = normalize(vec3(0.8, 0.9, 1.0));\nvec3 buildingColor = vec3(0., 0., 0.);\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat GetDist(vec3 pos)\n{\n\tfloat dist = 99999999.;\n\n\tfor (float j = 0.; j < 6.; j++) {\n\t\tfloat s = exp2(5. - j);\n\t\tvec3 c = vec3(0.5 * s, -2., 0.5 * s);\n\t\tvec3 p = vec3(mod(pos.x, s), pos.y, mod(pos.z, s));\n\t\tvec3 b = vec3(0.1, 0.4, 0.1) * s;\n\t\tvec3 q = abs(p - c) - b;\n\t\tfloat d = length(max(q, 0.0)) + min(vmax(q), 0.0);\n\t\tdist = min(dist, d);\n\t}\n    {\n        const float j = 7.;\n\t\tfloat s = exp2(5. - j);\n\t\tvec3 c = vec3(0.5 * s, -2., 0.5 * s);\n\t\tvec3 p = vec3(mod(pos.x, s), pos.y, mod(pos.z + ((j == 7.) ? iTime*(-1.+2.*mod(floor(pos.x/s),2.0)) : 0.0), s));\n\t\tvec3 b = vec3(0.1, (j == 7.) ? 0.1 : 0.4,(j == 7.) ? 0.35 : 0.1) * s;\n\t\tvec3 q = abs(p - c) - b;\n\t\tfloat d = length(max(q, 0.0)) + min(vmax(q), 0.0);\n\t\tdist = min(dist, d);\n    }\n\tdist = min(dist, pos.y + 2.25-0.125);\n\n\treturn dist;\n}\n\nvec3 GetNormal(vec3 point) {\n\tfloat d = GetDist(point);\n\tvec2 e = vec2(0, 0.01);\n\treturn normalize(vec3(\n\t\td - GetDist(point - e.yxx),\n\t\td - GetDist(point - e.xyx),\n\t\td - GetDist(point - e.xxy)\n\t));\n}\n\nvec3 SkyColor(vec3 lightDir, vec3 rayDir) {\n    vec3 color = mix(skyColor2, skyColor1, 0.5+0.5*rayDir.y);\n    float hor = 1.-abs(rayDir.y);\n    hor *= hor;\n    hor *= hor;\n    return color+hor*0.0625*0.75;\n}    \n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir) {\n\tfloat rayLength = 0.;\n\n    for(int j = 0; j < 500; j++) {\n\t\tfloat dist = GetDist(rayOrigin + rayDir * rayLength);\n\t\trayLength += dist;\n\n        if (rayLength >= 128.) {\n\t\t\tbreak;\n        }\n        if (dist < 0.01) {\n            return rayLength;\n        }\n\t}\n\n\treturn 128.;\n}\n\nvec4 GetColor(vec3 rayOrigin, vec3 lightDir, vec3 rayDir) {\n\tvec3 totalColor = vec3(0);\n\tvec3 r = vec3(1.);\n    float viewDist = 0.0;\n    float rayLength = 0.0;\n    for(int j = 0; j < 100; j++) {\n\t\tfloat dist = GetDist(rayOrigin + rayDir * rayLength);\n\t\trayLength += dist;\n        \n\t\tif (rayLength >= 128.) {\n\t\t\tbreak;\n        }\n            \n        if (dist < 0.01) {\n            vec3 point = rayOrigin + rayLength * rayDir;\n\n            vec3 baseColor = buildingColor+0.25+0.25*sin(vec3(24,17,22)*floor(vec3(5,2,4)*point));\n            baseColor = mix(baseColor,vec3(0.03125),smoothstep(0.4375,0.46875,abs(0.5-fract(vec3(2,3,4)*point))));\n\n            vec3 color = baseColor;\n\n            vec3 cellI = floor(vec3(2.5,3.125,2.5)*point)+0.25;\n            vec3 imperfections = vec3(1,0.75,1)*texture(iChannel0,fract(vec2(cellI.x+cellI.z,cellI.y)/1024.)).xyz;\n            vec3 normal = GetNormal(point);\n            normal = normalize(mix(normal,imperfections,0.5*0.25*0.125));\n\n            color *= 0.0625 + 0.9375 * lightColor * clamp(dot(-lightDir, normal), 0., 1.);\n            color += lightColor * pow(max(dot(reflect(-lightDir, normal), rayDir), 0.), 32.);\n            \n            vec3 sky = SkyColor(lightDir, rayDir);\n            float attenuation = clamp(rayLength / 128., 0., 1.);\n            color = mix(color, sky, attenuation);\n            color *= r;\n            totalColor += color;\n\n            float farFade = clamp((128.-rayLength)*0.25, 0., 1.);\n            vec3 glassTint = max(abs(rayOrigin.y-point.y)+length(normal.xz)*2.-16.*abs(normal.y),2.) /(1.+baseColor);\n            r = min(r / glassTint,farFade);\n\n            if(viewDist==0.0) viewDist = rayLength;\n\n            rayDir = reflect(rayDir, normal);\n            rayOrigin = point;\n            rayLength = 0.02*4.;\n\n            if(vmax(r)<0.0625) break;\n        }\n\t}\n    {\n            vec3 sky = SkyColor(lightDir, rayDir);\n            vec3 color = sky + lightColor*pow(max(dot(-lightDir, rayDir)*128.-127., 0.), 32.)*16.;\n            color *= r;\n            totalColor += color;\n    }\n\n    return vec4(totalColor,viewDist);\n    \n}\n\n\nvec4 image(vec2 U) {\n\tvec2 uv = (U - 0.5 * R) / R.y;\n\tvec3 rayDir = normalize(vec3(uv, 0.5));\n\tvec3 camPos = vec3(-3.+2.75-1.*sin(iTime*0.41)+0.25*sin(iTime*0.11), -1.+2.+2.*sin(iTime*0.31), iTime * 5.);\n    //camPos.yz*=0.25;\n\tvec3 lightDir = normalize(vec3(-5, -3, -1));\n\trayDir = rotate(rayDir, vec3(0., 1., 0.), sin(iTime) * 0.1 + 1.);\n    lightDir = rotate(lightDir, vec3(0., 1., 0.), iTime * 0.125 + 0.);\n\n    vec4 color = GetColor(camPos, lightDir, rayDir);\n    color.rgb = mix(sqrt(432.0/7.0)*color.rgb*color.rgb,sqrt((8.0/7.0)*color.rgb-(1.0/7.0)),greaterThan(color.rgb,vec3(1./6.)));\n    return color;\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//const int[16] mult0 = int[](3,5,6,10,12,17,20,24,29,34,40,58,68,116,136,232);\nconst int[] mult0 = int[](3,5,6,10,12,17,20,24,29,34,40,58,68);\nconst ivec2[4] mult1 = ivec2[](ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(1,2));\nvec4 image(vec2 U) {\n    vec2 R = iResolution.xy;\n    ivec2 pos0 = ivec2(U);\n    vec4 O = texelFetch(iChannel1, pos0, 0);\n    float hi = 0.0;\n    for(int i0 = 0; i0 < mult0.length(); i0++) {\n        for(int i1 = 0; i1 < 4; i1++) {\n            ivec2 off1 = mult0[i0]*mult1[i1];\n            for(int i2 = 0; i2 < 2; i2++) {\n                ivec2 off2 = i2==0?off1:ivec2(-off1.y,off1.x);\n                for(int i3 = 0; i3 < 2; i3++) {\n                    ivec2 off = i3==0?off2:-off2;\n                    vec4 V = texelFetch(iChannel1, pos0+off, 0);\n                    vec2 pos = floor(V.xy)+0.5;\n                    if(distance(U,pos)<distance(U,O.zw)) {\n                        O.zw=pos;\n                    }\n                    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                    float lu=sunflare(U, R, pos, T);\n                    if(hi<lu) {\n                        hi=lu;\n                        O.xy=pos;\n                    }\n                }\n            }\n        }\n    }\n    float hiApprox = 0.0;\n    vec2 hiPos = O.zw;\n    {\n        const int SIZE = 3;\n        ivec2 pos1 = ivec2(O.zw);\n        for(int i0 = -SIZE; i0 <= SIZE; i0++) {\n            for(int i1 = -SIZE; i1 <= SIZE; i1++) {\n                ivec2 off = ivec2(i0,i1);\n                vec4 V = texelFetch(iChannel1, pos1+off, 0);\n                vec2 pos = floor(V.xy)+0.5;\n                vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                float lu=sunflare(U, R, pos, T);\n                if(hi<lu) {\n                    hi=lu;\n                    O.xy=pos;\n                }\n            }\n        }\n    }\n    \n    {\n        vec2 pos1 = floor(hiPos)+0.5;\n        for(int i0 = -1; i0 <= 0; i0++) {\n            for(int i1 = -1; i1 <= 0; i1++) {\n                {\n                    vec2 pos = pos1+vec2(i0,i1);\n                    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                    float lu=sunflare(U, R, pos, T);\n                    if(hi<lu) {\n                        hi=lu;\n                        O.xy=pos;\n                    }\n                }\n                {\n                    vec2 pos = U+vec2(i0,i1);\n                    vec4 T = texelFetch(iChannel0, ivec2(pos), 0);\n                    float lu=sunflare(U, R, pos, T);\n                    if(hi<lu) {\n                        hi=lu;\n                        O.xy=pos;\n                    }\n                }\n            }\n        }\n    }\n\n    O.zw=vec2(0);\n    return O;\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec4 M;\nvec2 R;\n#define MAIN void mainImage(out vec4 O,vec2 U){M=iMouse;R=iResolution.xy;O=image(U);}\n\nfloat sinpi(float v) {return sin(radians(180.0)*v);}\nvec2  sinpi(vec2  v) {return sin(radians(180.0)*v);}\nvec3  sinpi(vec3  v) {return sin(radians(180.0)*v);}\nvec4  sinpi(vec4  v) {return sin(radians(180.0)*v);}\nfloat cospi(float v) {return cos(radians(180.0)*v);}\nvec2  cospi(vec2  v) {return cos(radians(180.0)*v);}\nvec3  cospi(vec3  v) {return cos(radians(180.0)*v);}\nvec4  cospi(vec4  v) {return cos(radians(180.0)*v);}\nfloat tanpi(float v) {return tan(radians(180.0)*v);}\nvec2  tanpi(vec2  v) {return tan(radians(180.0)*v);}\nvec3  tanpi(vec3  v) {return tan(radians(180.0)*v);}\nvec4  tanpi(vec4  v) {return tan(radians(180.0)*v);}\nfloat atanpi(vec2 v) {return atan(v.y,v.x)/radians(180.0);}\nfloat vmax(vec2 v) {return max(v.x, v.y);}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {return min(v.x, v.y);}\nfloat vmin(vec3 v) {return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {return min(min(v.x, v.y), min(v.z, v.w));}\n\nfloat lum(vec4 t) {return dot(vec4(0.25,0.625,0.125,0),max(t,0.));}\nfloat flare(vec2 U, vec2 R, vec2 sunPos, float strength1, float strength2) {\n    const float K_n0 = 5.0, K_f0 = K_n0, K_r0 = 0.50, K_o0 = 0.5;\n    const float K_n1 = 3.0, K_f1 = K_n1, K_r1 = 1., K_o1 = 0.0;\n    const float K_n2 = 4.0, K_f2 = K_n2*K_f1, K_r2 = K_f2/K_n1, K_o2 = 0.5+0.0*fract((K_f2*K_f1)*0.5);\n        \n    float lenSun = distance(sunPos,U)/R.y*strength1+strength2;\n    float angle = atanpi(sunPos-U);\n    float flare2 = 5.0*exp2(-2.-2.*lenSun-7.*lenSun*abs(0.5-fract(sunPos.x/R.x*K_r2+K_o2+K_f2*angle)));\n    float flare1 = 6.0*exp2(-3.-3.*lenSun-7.*lenSun*abs(0.5-fract(sunPos.x/R.x*K_r1+K_o1+K_f1*angle)));\n    float flare0 = 9.0*exp2(-3.-3.*lenSun-7.*lenSun*abs(0.5-fract(sunPos.x/R.x*K_r0+K_o0+K_f0*angle)));\n    flare0 = sqrt(flare0);\n    return flare0 + flare1 + flare2;\n}\nfloat flare(vec2 U, vec2 R, vec2 sunPos) {return flare(U,R,sunPos,2.0,1.0);}\n\nvec4 calcSunFlare(vec2 U, vec2 R, vec2 pos, float luma, float dist) {\n    const vec4 M1 = vec4(800,300,80,0)/vec4(800,450,800,450);\n    //vec4 M1 = M/R.xyxy;\n    const vec4 M2 = vec4(200,350,400,400)/vec4(800,450,800,450);\n    //vec4 M2 = M/R.xyxy;\n    float distanceFactor = clamp(log2(dist*2.)-4.,0.,1.);\n    float strength1 = (mix(M2.x,M2.z,distanceFactor)-0.0)*64.;\n    float strength2 = (mix(M2.y,M2.w,distanceFactor)-0.5)*4.0;\n    float distancy = 1.0-0.*distanceFactor;//clamp(distancy0,0.,1.);//clamp(2.-T.w/64.,0.,1.);\n    //float strength = strength0;//exp2(4.-2.*strength);\n    float luminosity = clamp(luma*16.*M1.x-16.*M1.y,0.,1.);\n    float lensflare = clamp(flare(U,R,pos,strength1,strength2)*16.*M1.z-16.*M1.w,0.,1.);\n    return vec4(distancy,luminosity,lensflare,strength1);\n}\nfloat sunflare(vec2 U, vec2 R, vec2 pos, vec4 tex) {\n    vec3 f = calcSunFlare(U,R,pos,lum(tex),tex.w).xyz;\n    return f.x*f.y*f.z;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}