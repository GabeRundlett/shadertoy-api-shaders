{
    "Shader": {
        "info": {
            "date": "1622065647",
            "description": "Just me playing around with Shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "sll3WH",
            "likes": 3,
            "name": "First Shader Fun",
            "published": 3,
            "tags": [
                "fun",
                "shader"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 299
        },
        "renderpass": [
            {
                "code": "float res = 7.;\nint seed = 50152;\nfloat pixel = 0.;\n\nint mod2(int v, int m)\n{\n    return int(mod(float(v), float(m)));\n}\nfloat GetDigitOfPi(int i)\n{\n    float[] randomDigitsPi = float[](\n        3799.6274,9567.3518,8575.2724,\n        8912.2793,8183.0119,4912.9833,\n        6733.6244,0656.6430,8602.1394,\n        9463.9522,4737.1907,0217.9860,\n        9437.0277,0539.2171,6939.9375\n    );\n    return randomDigitsPi[abs(mod2(randomDigitsPi.length() + i, randomDigitsPi.length()))];\n}\nfloat GetDigitOfPi(float i)\n{\n    return GetDigitOfPi(int(i));\n}\n\nvec3 Hash32(vec2 src)\n{\n    src = mod(src,50.);\n    float x = floor(src.x);\n    float y = floor(src.y);\n    {\n        float _x = x;\n        float _y = y;\n        x *= _x;\n        y *= _y;\n        \n        y += _x;\n        x += _y;\n    }\n    float rand1 = GetDigitOfPi(y * GetDigitOfPi(seed + 2) + GetDigitOfPi(seed + 4));\n    float rand2 = GetDigitOfPi(x * GetDigitOfPi(seed + 3) + GetDigitOfPi(seed + 5));\n    \n    vec3 hash = vec3(fract(floor(src) * vec2(rand1,rand2)),0);\n    hash += dot(hash, hash+GetDigitOfPi(seed + 6));\n    \n    hash.z = length(hash)+rand1+rand2;\n    \n    return fract(hash);\n}\n\nfloat cirkle(vec2 uv)\n{\n    float dist = length(uv);\n    float m = smoothstep(.2, .05, dist);\n    \n    return m;\n}\n\nfloat Pixels(int n, bool left)\n{\n    if(left)\n        return pixel*float(n) -.5;\n    return .5 - pixel*float(n);\n}\nfloat Pixels(int n)\n{\n    return Pixels(n,false);\n}\nfloat Pixel(bool left){\n    return Pixels(1,left);\n}\nfloat Pixel(){\n    return Pixels(1,false);\n}\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * res;\n    pixel = iResolution.x / iResolution.y * res / iResolution.x;\n    \n    uv += vec2(iTime,sin(iTime));\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec3 col = vec3(0);\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x,y);\n            vec3 pos = Hash32(id + offset) -.5;\n            vec3 addCol = hsv2rgb(vec3(pos.z, 1 ,cirkle(gv + pos.xy - offset)));\n            col += addCol;\n        }\n    }\n    \n    /*if(\n        gv.x >= Pixel() || gv.x <= Pixel(true) || \n        gv.y >= Pixel() || gv.y <= Pixel(true)   ) col.r = 1.;\n    */\n    fragColor = vec4(col,1);\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}