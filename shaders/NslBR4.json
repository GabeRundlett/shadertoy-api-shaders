{
    "Shader": {
        "info": {
            "date": "1644551082",
            "description": "wall experiments",
            "flags": 0,
            "hasliked": 0,
            "id": "NslBR4",
            "likes": 11,
            "name": "wall experiments",
            "published": 3,
            "tags": [
                "wallexperiments"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "///modificado por jorge2017a2\n//referencia\n//https://www.shadertoy.com/view/3sfGWB\n///by  StanislavPetrovV\n//https://github.com/StanislavPetrovV/Advanced_RayMarching\n//https://www.youtube.com/watch?v=2fcO9RUOGg4\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/distfunctions2d\n ///aportacion by ocb --11-feb-2022\n \nconst float FOV = 1.0;\nconst int MAX_STEPS = 128;\nconst float MAX_DIST = 100.;\nconst float EPSILON = 0.001;\n#define PI 3.14159265\n#define TAU (2.*PI)\n\n\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 normal) {\n    normal = abs(normal);\n    normal = pow(normal, vec3(5.0));\n    normal /= normal.x + normal.y + normal.z;\n    return (texture(tex, p.xy * 0.5 + 0.5) * normal.z +\n            texture(tex, p.xz * 0.5 + 0.5) * normal.y +\n            texture(tex, p.yz * 0.5 + 0.5) * normal.x).rgb;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdQuads( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n    vec2 e3 = p0 - p3;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n    vec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e3.y - e0.y*e3.x );\n    vec2 d = min( min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                 \t   vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) )),\n                       vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 pared01(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);\n    vec3 p0=p;\n    p.x= opRep1D(p.x, 4.5 );\n    vec3 p1=p;\n    vec3 p2=p;\n    \n    vec2 uv=p1.xy;\n    vec2 uvRef=uv-vec2(0.1,0.2);\n    vec3 col=vec3(1.0);\n    vec3 bcol = vec3(0.55,0.55,0.6);\n    vec3 mcol = vec3(0.25,0.25,0.3);\n    \n    \n    float bl0 = sdQuads(vec2(0.1,0.1),vec2(-0.1,0.15),vec2(-0.1,-1.5),vec2(0.1,-1.5),uvRef);\n    float bl1 = sdQuads(vec2(0.5,-0.05),vec2(0.1,0.05),vec2(0.1,-1.5),vec2(0.5,-1.5),uvRef);\n    float bl2 = sdQuads(vec2(-0.1,0.05),vec2(-0.3,-0.1),vec2(-0.3,-1.5),vec2(-0.1,-1.5),uvRef);\n    float bl3 = sdQuads(vec2(-0.3,-0.3),vec2(-0.6,-0.3),vec2(-0.6,-1.5),vec2(-0.3,-1.5),uvRef);\n    float blD = unionSDF(bl0,bl1);\n    float blD1 = unionSDF(bl2,bl3);\n    float blD2 = unionSDF(blD,blD1);\n    \n    uv=p2.xy;\n    uvRef=uv-vec2(1.25,0.2);\n    float ml0 = sdQuads(vec2(0.1,-0.2),vec2(-0.1,-0.25),vec2(-0.1,-1.5),vec2(0.1,-1.5),uvRef);\n    float ml1 = sdQuads(vec2(0.5,0.1),vec2(0.1,-0.05),vec2(0.1,-1.5),vec2(0.5,-1.5),uvRef);\n    float ml2 = sdQuads(vec2(-0.1,-0.2),vec2(-0.3,-0.15),vec2(-0.3,-1.5),vec2(-0.1,-1.5),uvRef);\n    float ml3 = sdQuads(vec2(-0.3,-0.3),vec2(-0.65,-0.3),vec2(-0.65,-1.5),vec2(-0.3,-1.5),uvRef);\n    float mlD = unionSDF(ml0,ml1);\n    float mlD1 = unionSDF(ml2,ml3);\n    float mlD2 = unionSDF(mlD,mlD1);\n    \n    float dfin = unionSDF(blD2,mlD2);\n    float  d1=sdBox( uv-vec2(0.25,-0.45), vec2(0.25,0.25) );\n    float  d2=sdBox( uv-vec2(1.1,-0.45), vec2(0.25,0.25) );\n    dfin= differenceSDF(dfin, d1);\n    dfin= differenceSDF(dfin, d2);\n    \n    p.z=abs(p.z)-1.0;\n    float d3=sdBox(p, vec3(1.5,1.5,0.15) );\n    dfin= intersectSDF(dfin, d3);\n    float d4=sdBox(p-vec3(0.0,-0.2,0.0), vec3(2.5,0.05,0.15) );\n    float d5=sdBox(p-vec3(0.0,-1.0,0.0), vec3(2.5,0.25,0.15) );\n    dfin = unionSDF(dfin,d4);\n    dfin = unionSDF(dfin,d5);    \n      res =opU2(res, vec2(dfin,100.0));\n      return res;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec3 tmp, op = p;\n    vec2 res;\n    // plane\n    float planeDist=p.y+1.0;\n    //float planeID = 2.0;\n    float planeID = 101.0;\n    vec2 plane = vec2(planeDist, planeID);\n    res=plane;\n    vec2 re1= pared01(p);\n    res =opU2(res, re1);\n    return res;\n}\n\nvec3 getMaterial(vec3 p, float id, vec3 normal) {\n    vec3 m;\n    switch (int(id)) \n    {\n        case 1:\n        m = vec3(0.9, 0.0, 0.0); break;\n\n        case 2:\n        m = vec3(0.2 + 0.4 * mod(floor(p.x*0.5) + floor(p.z*0.5), 2.0)); break;\n\n        case 3:\n            m = vec3(0.7, 0.8, 0.9); break;\n\n        case 4:\n            vec2 i = step(fract(0.5 * p.xz), vec2(1.0 / 10.0));\n            m = ((1.0 - i.x) * (1.0 - i.y)) * vec3(0.37, 0.12, 0.0); break;\n        case 100:\n            m = triPlanar(iChannel0, p , normal); m=m*m; break;\n        case 101:\n            m = triPlanar(iChannel1, p , normal);  break;\n            \n      }  \n    return m;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    vec2 hit, object;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + object.x * rd;\n        hit = map(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = map(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat getAmbientOcclusion(vec3 p, vec3 normal) {\n    float occ = 0.0;\n    float weight = 1.0;\n    for (int i = 0; i < 8; i++) {\n        float len = 0.01 + 0.02 * float(i * i);\n        float dist = map(p + normal * len).x;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\nvec3 getLight(vec3 p, vec3 rd, float id, vec3 plightPos ) \n{   vec3 lightPos = plightPos;\n    vec3 L = normalize(lightPos - p);\n    vec3 N = getNormal(p);\n    vec3 V = -rd;\n    vec3 R = reflect(-L, N);\n    vec3 color = getMaterial(p, id, N);\n    vec3 specColor = vec3(0.6, 0.5, 0.4);\n    vec3 specular = 1.3 * specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.0);\n    vec3 diffuse = 0.9 * color * clamp(dot(L, N), 0.0, 1.0);\n    vec3 ambient = 0.05 * color;\n    vec3 fresnel = 0.15 * color * pow(1.0 + dot(rd, N), 3.0);\n\n    // shadows\n    float shadow = getSoftShadow(p + N * 0.02, normalize(lightPos));\n    // occ\n    float occ = getAmbientOcclusion(p, N);\n    // back\n    vec3 back = 0.5 * color * clamp(dot(N, -L), 0.0, 1.0);\n    return  (back+ambient + fresnel) * occ + (specular * occ + diffuse) * shadow;    \n}\n\nmat3 getCam(vec3 ro, vec3 lookAt) {\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(vec3(0, 1, 0), camF));\n    vec3 camU = cross(camF, camR);\n    return mat3(camR, camU, camF);\n}\n\nvoid mouseControl(inout vec3 ro) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    pR(ro.yz, m.y * PI * 0.39 - 0.39);\n    pR(ro.xz, m.x * TAU);\n}\n\nvec3 render(vec2 uv) \n{\n    vec3 col = vec3(0);\n    vec3 background = vec3(0.5, 0.8, 0.9);\n    \n     float t;\n    t=mod(iTime*0.5,500.0);\n        \n    vec3 ro=vec3(0.0,-0.5,0.15);\n   ro.x=t;\n    //mouseControl(ro);\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   rd= rotate_y(rd, radians(90.0));\n    vec3 light_pos1= vec3(-10.0, 120.0, 10.0 );\n \tvec3 light_pos2= vec3(10.0, 30.0, -25.0 );\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec2 object = rayMarch(ro, rd);\n\n    if (object.x < MAX_DIST) {\n        vec3 p = ro + object.x * rd;\n        col += getLight(p, rd, object.y,light_pos2);\n        //col += getLight(p, rd, object.y,light_pos1);\n        //col/=2.0;\n        // fog\n        col = mix(col, background, 1.0 - exp(-1e-7 * object.x * object.x * object.x));\n    } else \n    {\n        //col += background - max(0.7 * rd.y, 0.0);\n        ///by ocb --11-feb-2022\n          col += smoothstep(.45,.9,texture(iChannel1,vec2(.1/rd.y-.02*iTime,.3*rd.z)).z) + background - max(0.7 * rd.y, 0.0);\n    }\n    return col;\n}\n\nvec2 getUV(vec2 offset, vec2 frag) \n{   return (2.0 * (frag.xy + offset) - iResolution.xy) / iResolution.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec3 color= render( getUV(vec2(0.0), fragCoord)  );  \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}