{
    "Shader": {
        "info": {
            "date": "1633379926",
            "description": "Something started over the break - and just playing around in the updated shadertoy.. ",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcSWn",
            "likes": 16,
            "name": "Box Node Connections",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "reflection",
                "refraction",
                "transparent"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Box Node Connections\n    10/3/21 @byt3_m3chanic\n    \n    Just playing with a simple fold/mirror formula / simple box and tube with\n    a little refraction.\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n// updaetd with some AA - reduce to 1.0 if too slow\n#define AA 2.0\n\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq thanks for the sdf's!\n\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//globals\nmat2 rx, ry;\nfloat tmod=0.,ga2=0.,ga4=0.,ga5=0.;\nvec3 hit,hitPoint;\n\n//fold\nvoid octa(inout vec4 p, float k1, float k2, float k3, float k4)  \n{\n    p.y = abs(p.y);\n    if (p.x + p.y<0.0) p.xy = -p.yx;\n    if (p.x + p.z<0.0) p.xz = -p.zx;\n    if (p.x - p.y<0.0) p.xy = p.yx;\n    if (p.x - p.z<0.0) p.xz = p.zx;\n    p.xyz = p.xyz*k1 - (k1 - 1.0);\n}\n\nconst float zoom = 23.5;\nconst float cell = 24.;\nconst float hlf = cell/2.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    vec3 pp = p;\n    \n    if(ga4>0.) p.xz*=rot(ga4*PI/2.);\n    if(ga5>0.) p.y+=ga5*cell;\n    \n    p.y=mod(p.y+hlf,cell)-hlf;\n  \n    vec4 P = vec4(p.xyz, 1.0);\n    float spc = 6.;\n    \n    for(int j=0;j<2;j++) { \n        octa(P, 1.,1.,1.,1.); \n        P.xyz = abs(P.zxy)-spc;\n    }\n    vec3 q = P.xyz;\n\n    q.x = abs(q.x)-spc;\n    q.z = abs(q.z)-spc;\n\n    vec3 fq = q;\n    fq.x=abs(fq.x)-1.6;\n    fq.y=abs(abs(fq.y)-.4)-.2;\n    float mainbox = sdbox(q,vec3(1.25));\n    float cutbox =  sdbox(vec3(q.xy,abs(q.z))-vec3(0,0 ,1.35),vec3(.65,.65,3.75 ));\n    float frame = sdbox(fq,vec3(.1,.1,.75));\n\n    mainbox = min(mainbox, frame);\n    mainbox = max(mainbox, -cutbox);\n    if(mainbox<res.x) res = vec2(mainbox/P.w,2.);\n\n    float frame2 = sdframe(q,vec3(1.475),.225)-.0125;\n    if(frame2<res.x) res = vec2(frame2/P.w,4.);\n\n    float dv = .45+.25*sin(q.z*.75);\n    float beams = length(q.xy)-dv;\n\n    if(beams<res.x) {\n        res = vec2(beams/P.w,3.);\n        hit=pp+vec3(0,ga2*cell,0);\n    }\n    \n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n//iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d,1.);\n    vec3 lpos =  vec3(18,18,18);\n    lpos.xz*=ry;\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.1);\n    if(m==3.) h = hsv2rgb(vec3(p.x*.003+hitPoint.y*.0125,.8,.5));\n    if(m==4.) h=vec3(.4);\n \n    return diff*h;\n}\n\nvoid image( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n\n    tmod = mod(time, 10.);\n    float t7 = lsp(0.0, 5.0, tmod);\n    float t9 = lsp(4.0, 10.0, tmod);\n\n    ga4 = eoc(t7);\n    ga4 = ga4*ga4*ga4;\n    ga4 = ga4+floor(time*.1);\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga2 = t9+floor(time*.1);\n    ga5 = (t9);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0, 0, zoom);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1.  - .5) * PI;\n\n    rx = rot(x+.18); ry = rot(y-.58);\n\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(.0015);\n    vec3 p = ro + rd;\n    \n    float atten = .95;\n    float k = 1., d = 0.;\n    \n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x*.75;\n        p += rd * d *k;\n        \n        float fresnel=0.;\n        if (d*d < 1e-7) {\n            hitPoint=hit;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .55;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            if(m==4.||m==1.) {\n                rd=reflect(-rd,n);\n                p+=n*.025;\n            } else {\n                vec3 rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>50.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 F){\n    vec4 C = vec4(0);\n    float px=.25;\n    if(AA==1.0) {image(C,F); O=C; return;}\n   \n    vec4 C2;\n    \n    image(C2,F.xy+vec2(px,-px));\n    C.rgb+=C2.rgb;\n    image(C2,F.xy+vec2(-px,px));\n    C.rgb+=C2.rgb;\n    \n    C/=AA;\n    \n    O = vec4(C);\n}\n\n// end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}