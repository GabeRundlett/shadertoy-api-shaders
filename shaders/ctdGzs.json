{
    "Shader": {
        "info": {
            "date": "1682954678",
            "description": "The study consist of observing the perception of the square edges. When a plain color A is displayed inside a background of plain color B, A will form edges (4 for a square). This displays how A can have a consistent edges across colors;",
            "flags": 0,
            "hasliked": 0,
            "id": "ctdGzs",
            "likes": 3,
            "name": "Color Stud - Tetrachord PXIV-1b",
            "published": 3,
            "tags": [
                "interactionofcolor"
            ],
            "usePreview": 0,
            "username": "Slals",
            "viewed": 122
        },
        "renderpass": [
            {
                "code": "float rectSDF(vec2 uv, vec2 s) {\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\nfloat fill(float x, float s) {\n    return step(x, s);\n}\n\n// From easy RGB : xyz -> RGB\nvec3 colorWheel(float x, float y, float z) {\n    vec3 c = vec3(\n        x * 3.2406 + y * -1.5372 + z * -0.4986,\n        x * -0.9689 + y * 1.8758 + z * 0.0415,\n        x * 0.0557 + y * -0.204 + z * 1.057\n    );\n    \n    float t = 0.0031308;\n    if (c.r > t)\n        c.r = 1.055 * (pow(c.r, (1.0 / 2.4))) - 0.055;\n    else\n        c.r = 12.92 * c.r;\n    \n    if (c.g > t)\n        c.g = 1.055 * (pow(c.g, (1.0 / 2.4))) - 0.055;\n    else\n        c.g = 12.92 * c.g;\n    \n    if (c.b > t)\n        c.b = 1.055 * (pow(c.b, (1.0 / 2.4))) - 0.055;\n    else\n        c.b = 12.92 * c.b;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.43;\n\n    uv *= 2.0;\n    \n    vec2 M = iMouse.xy / iResolution.xy;\n    \n    \n    float fRed = 0.0, fGreen = 0.0, fBlue = 0.0;\n    \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec3 modulator = colorWheel(M.x, M.y, sin(iTime * 0.2));\n    \n    vec3 refAColor = modulator;\n    vec3 refBColor = modulator.bgr;\n    \n    vec3[] pcts = vec3[](\n        vec3(0.0528634, 0.050209, 0.0123966),\n        vec3(0.319672, 0.2823529, 0.132653),\n        vec3(0.1307189, 0.1156069, 0.1173469)\n    );\n    \n    int I = 0;\n    vec2 bPos = vec2(0.0);\n    \n    if (i.x == 0.0 && i.y == 1.0) {\n        bPos.x = -1.0;\n    } else if (i.x == 0.0 && i.y == 0.0) {\n        I = 1;\n        bPos = vec2(-1.0);\n    } else if (i.x == 1.0 && i.y == 0.0) {\n        I = 2;\n        bPos.y = -1.0;\n    } else if (i.x == 1.0 && i.y == 1.0) {\n        I = 3;\n    } else {\n        refAColor = vec3(0.0);\n        refBColor = vec3(0.0);\n    }\n    \n    if (iMouse.z >= 1.0) {\n        vec3 a = refAColor;\n        refAColor = refBColor;\n        refBColor = a;\n    }\n    \n    for (int i = 0; i < I; i++) {\n        fRed += pcts[i].r;\n        fGreen += pcts[i].g;\n        fBlue += pcts[i].b;\n    }\n    \n    float B = fill(rectSDF(f + bPos, vec2(1.0)), 0.52);\n\n    vec3 color = refAColor.rgb * (1.0 + vec3(fRed, fGreen, fBlue)) * fill(rectSDF(f, vec2(1.0)), 1.0);\n    color = B == 1.0 ? refBColor.rgb * (1.0 + vec3(fBlue, fGreen, fRed)) : color;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}