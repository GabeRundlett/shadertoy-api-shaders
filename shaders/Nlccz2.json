{
    "Shader": {
        "info": {
            "date": "1660557467",
            "description": "Infinite zoom effect with yin-yang symbol. Let the code golfing begin!\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Nlccz2",
            "likes": 6,
            "name": "Yin-Yang Zoom (311 chars)",
            "published": 3,
            "tags": [
                "zoom",
                "recursion",
                "infinite",
                "yinyang",
                "golf"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "// from Xor: 311 chars (with initializing O to zero)\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy*.5,\n    p = vec2(0, .5), s;\n    \n    float i = 1.,\n        z = exp(-mod(iTime * .7, 4.6)),\n        w = z / R.y, l = w;\n    \n    u = ((u - R) / R.y + sin(iTime + p*66.) * .3) * z +\n         --z * p / .9;\n         \n    for (O = p.xxxx; l<.2; w /= .1)\n        \n        s = sign(u),\n        l = length(u*s - p),\n        z = length(u),\n        O += smoothstep(w+w, 0., min(max(--z,.5*s.y-l*s.x+w), abs(z))) * i,\n        i *= s.y,\n        u -= p*s,\n        u /= .1;\n}\n/**/\n\n// from Xor: 307 chars, but using O -= O which does not work on all platforms (such as iPad app)\n\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy*.5,\n    p = vec2(0, .5), s;\n    \n    float i = 1.,\n        z = exp(-mod(iTime * .7, 4.6)),\n        w = z / R.y, l = w;\n    \n    u = ((u - R) / R.y + sin(iTime + p*66.) * .3) * z +\n         --z * p / .9;\n         \n    for (O -= O; l<.2; w /= .1)\n        \n        s = sign(u),\n        l = length(u*s - p),\n        z = length(u),\n        O += smoothstep(w+w, 0., min(max(--z,.5*s.y-l*s.x+w), abs(z))) * i,\n        i *= s.y,\n        u -= p*s,\n        u /= .1;\n}\n/**/\n\n\n/*\n// Original golf attempt by fenix (444 chars)\n\n#define n length\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    vec3 R = iResolution;\n    vec2 p = vec2(0., .5);\n    float i = 1.,\n        z = pow(.1, mod(iTime * .3, 2.)),\n        w = z * 2. / R.y;\n        \n    O -= O;\n    for (u = ((2.* u - R.xy) / R.y + vec2(sin(iTime), cos(iTime)) * .3) * z +\n         (z - 1.) * p * 1.111;; w *= 10.)\n    {\n        float l = n(u - p),\n            m = n(u + p),\n            d = n(u),\n            e = -d * w,\n            r = clamp(float(u.x > 0. && d < 1. && l > 0.5)\n                + smoothstep(-1. + e, -1. - e, -d) * float(m < .5), 0., 1.)\n                + smoothstep(e, 0., -abs(d - 1.));\n             \n        O += i * r;\n        \n        if (l < .2)\n            u = (u - p) * 10.;\n        else if (m < .2)\n            u = (u + p) * 10.,\n            i = -i;\n        else break;\n    }\n}\n/**/\n\n/*\n// Original:\nconst vec2 p1 = vec2(0.0, 0.5);\n\n// Based on Antialized Circle by Dmitry https://www.shadertoy.com/view/tsySWy\nfloat aaCircle(vec2 uv, float wd)\n{\n    // 2. draw anti-aliased circle\n    float d = length(uv);\n    float circle = smoothstep(0.0, d * wd, abs(d - 1.0));\n\n    // 3. result\n    return 1.0 - circle;\n}\n\nfloat aaFilledCircle(vec2 uv, float wd)\n{\n    // 2. draw anti-aliased circle\n    float d = length(uv);\n    float circle = smoothstep(1.0 - d * wd, 1.0 + d * wd, d);\n\n    // 3. result\n    return 1.0 - circle;\n}\n\nfloat drawYY(in vec2 u, inout float l1, inout float l2, float wd)\n{\n    l1 = length(u - p1);\n    l2 = length(u + p1);\n    float r = aaCircle(u, wd);\n    if (u.x > 0.0 && length(u) < 1.0)\n    {\n        r = max(0.0, 1.0 - r);\n    }\n    if (l1 < 0.50 && length(u) < 1.0 - wd)\n    {\n        r -= aaFilledCircle((u - p1) * 2.0, wd);\n    }\n    if (l2 < 0.50)\n    {\n        r += aaFilledCircle((u + p1) * 2.0, wd);\n    }\n    return clamp(r, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    float invert = 1.0;\n    float flip = 1.0;\n    float time = mod(iTime * 0.3, 2.0);\n    float zoom = pow(.1, time);\n    float wd = zoom * 2./(min(iResolution.x, iResolution.y));\n\tu = (2.* u - iResolution.xy) / iResolution.y;\n    u += vec2(sin(iTime), cos(iTime)) * 0.3;\n    vec2 ou = u;\n    vec2 p3 = p1 * (2.0 - 0.88888);\n    u = (u + p3) * zoom - p3;\n    float l1, l2;\n    O = vec4(0);\n    int step;\n    for ( step = 0; step < 5; ++step)\n    {\n        O += invert * vec4(drawYY(u * flip, l1, l2, wd));\n        wd *= 10.0;\n        if (l1 <= 0.11)\n        {\n            u = (u - p1) * 10.0;\n        }\n        else if (l2 <= 0.11)\n        {\n            u = (u + p1) * 10.0;\n            invert = -invert;\n        }\n        else break;\n    }\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}