{
    "Shader": {
        "info": {
            "date": "1511560226",
            "description": "I've been experimenting with pre integrated subsurface scattering. This was a basic experiment to understand how to use/tweak it. The subsurface scattering is precalculated in a LUT in buffer A.",
            "flags": 32,
            "hasliked": 0,
            "id": "4tXBWr",
            "likes": 50,
            "name": "Flesh",
            "published": 3,
            "tags": [
                "sss"
            ],
            "usePreview": 1,
            "username": "Nesvi7",
            "viewed": 2399
        },
        "renderpass": [
            {
                "code": "//By Nestor Vina\n\nvec3 dof(sampler2D buffer, vec2 uv, float distanceOfFocus){    \n\tvec3 finalColor = vec3(0);\n    const float squareEdge = 2.0;\n    const float iters = (squareEdge*2.0+1.0)*(squareEdge*2.0+1.0);\n    float l = abs(distanceOfFocus-texture(buffer,uv).a);\n    float radiousOfDepth = 7.0;\n    float dofLevel = clamp((l-radiousOfDepth )*0.1,0.0,1.0);    \n    \n    for( float i = -squareEdge; i <= squareEdge; i++)\n        for( float j = -squareEdge; j <= squareEdge; j++)\n            finalColor += texture(buffer,uv+vec2(i,j)*0.0015*dofLevel).xyz;\n        \n    finalColor /= iters;\n    return finalColor;\n}\n\nvec3 GammaCorrection(vec3 inColor){\n\tconst vec3 gammaExp = vec3(1.0/2.2);\n    return pow(inColor,gammaExp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = vec4(dof(iChannel0,uv,7.0f*5.0),1.0);\n    fragColor.xyz = GammaCorrection(fragColor.xyz);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Pre Integrated sss LUT\n//Based on GPU pro 2 Pre Integrated subsurface scattering by Penner\n\n#define samples 360.0f\n#define PI 3.14159265359f\n\n\nfloat Gaussian ( float v, float r )\n{\n\treturn 1.0f/sqrt(2.0f*PI*v)*exp(-(r*r)/(2.0f*v));\n}\n\nvec3 Scatter ( float r )\n{\n    return Gaussian ( 0.0064f * 1.414f , r ) * vec3( 0.233f , 0.455f , 0.649f ) +\n    \t   Gaussian ( 0.0484f * 1.414f , r ) * vec3( 0.100f , 0.336f , 0.344f ) +\n    \t   Gaussian ( 0.1870f * 1.414f , r ) * vec3( 0.118f , 0.198f , 0.000f ) +\n    \t   Gaussian ( 0.5670f * 1.414f , r ) * vec3( 0.113f , 0.007f , 0.007f ) +\n    \t   Gaussian ( 1.9900f * 1.414f , r ) * vec3( 0.358f , 0.004f , 0.000f ) +\n    \t   Gaussian ( 7.4100f * 1.414f , r ) * vec3( 0.078f , 0.000f , 0.000f ) ;\n}\n\n\nvec3 CalculateSS( float r, float angle ){\n    vec2 L = vec2(1.0f,0.0f);\n\tfloat stepOffset = 2.0f*PI/samples;\n    \n    float angleOffset = 0.0f;\n    \n    vec3 totalLight = vec3(0.0f);\n    vec3 totalWeights = vec3(0.0f);\n    \n    for( float i = 0.0f; i < samples; i++){\n    \t\n        float segment = 2.0f * r * sin(angleOffset*0.5f);\n        \n        float surfacePointAngle =  angle + angleOffset + 2.0f * PI;\n        float NdotL = max(0.0f,cos(surfacePointAngle));\n        \n        vec3 weights = Scatter(segment);\n        totalWeights += weights;\n        totalLight += NdotL * weights;\n        \n        angleOffset += stepOffset;\n    }\n    \n    return totalLight/totalWeights;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if( texelFetch(iChannel0,ivec2(0,0),0).a == iResolution.x)\n        discard;\n    else{\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\tfragColor.rgb = CalculateSS(1.0f/(uv.y*2.0f),uv.x*PI);\n        \n        fragColor.a = fragCoord.x == 0.0f && fragCoord.y == 0.0f ? iResolution.x : 0.0f;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//By Nestor Vina\n//#define iqMethodComparison\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 RotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat Random( in vec3 value){\n\treturn fract(sin(dot(value,vec3(1274.0546,1156.01549,1422.65229)))*15554.0);    \n}\n\nfloat Noise3D( in vec3 uv ){\n    vec3 index = floor(uv);\n    vec3 frac = fract(uv);\n    \n    float a = Random(index);\n    float b = Random(index+vec3(1.0,0.0,0.0));\n    float c = Random(index+vec3(0.0,1.0,0.0));\n    float d = Random(index+vec3(1.0,1.0,0.0));\n    \n    float f = Random(index+vec3(0.0,0.0,1.0));\n    float g = Random(index+vec3(1.0,0.0,1.0));\n    float h = Random(index+vec3(0.0,1.0,1.0));\n    float i = Random(index+vec3(1.0,1.0,1.0)); \n    \n    frac = frac*frac*(3.0 - 2.0 * frac);\n    \n    return mix(mix(mix(a,b,frac.x),mix(c,d,frac.x),frac.y),\n    \t   mix(mix(f,g,frac.x),mix(h,i,frac.x),frac.y),\n           frac.z);    \n}\n\nfloat FBMNoise3D6( in vec3 uv){\n    float fbm = Noise3D(uv*0.1)*0.5;\n    fbm += Noise3D(uv*0.2)*0.25;\n    fbm += Noise3D(uv*0.4)*0.125;\n    fbm += Noise3D(uv*0.8)*0.0625;\n    fbm += Noise3D(uv*0.16)*0.03125;\n    fbm += Noise3D(uv*0.32)*0.03125;    \n    return fbm;\n}\n\nvec2 Map( vec3 p) {\n    \n    float noise = sqrt(sqrt(FBMNoise3D6(p*6.0f)));\n    noise = mix(noise,FBMNoise3D6(p*15.0f),0.1f);\n    \n    float sdf = length(p) -10.0f;\n    float defTime = iTime;\n    float deformation = sin(p.x*0.7f+defTime)*sin(p.y*0.03f)*sin(p.z*0.1f)*3.0f;\n\n    sdf += noise;\n    sdf += deformation;\n        \n    return vec2(sdf, noise);    \n}\n\nvec2 Intersect( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < 100; i++ ) {\n        vec2 distResult = Map( origin + dir * depth );\n        depth += distResult.x;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}        \n\t\tif ( distResult.x < 0.02 ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\t\n\t}\n\treturn vec2(end,-1.0);\n}\n\nvec3 RayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 Normal( vec3 pos ) {\n\tconst float normal_step = 0.02;\t\n\tconst vec3 dx = vec3( normal_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, normal_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, normal_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tMap( pos + dx ).x - Map( pos - dx ).x,\n\t\t\tMap( pos + dy ).x - Map( pos - dy ).x,\n\t\t\tMap( pos + dz ).x - Map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n\n//iq's penner approximattion (see comments)\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    \n    return vec3(pndl) + \n           vec3(1.0,0.2,0.05)*0.250*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n}\n\n//My in-progress attempt\nvec3 nsss( float ndl, float ir ){\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 )*0.4f;\n    \n    float inndle4 = 1.0f-nndl; inndle4 *= inndle4; inndle4 *= inndle4;\n    \n\treturn vec3(pndl) + vec3(0.2f,0.02f,0.01f)*inndle4*ir*4.0f;\n}\n\nvec3 material( vec3 p, vec3 n, vec3 eye, float ao, vec2 screenCoords ) {    \n    \n    vec3 lightDir = normalize(vec3(1.0f,-1.0f,-0.5f));\n    \n    float powao = ao*ao*ao;\n    vec3 matColor = mix(vec3(0.713f,0.25f,0.2f),vec3(0.2,0.0f,0.0f), powao);\n    \n    vec3 dir = normalize(p-eye);    \n    float spec = pow(max(0.0f,dot(lightDir,reflect(dir,n))),40.0f)*(1.0f-ao);\n    \n    float ndotl = dot(-lightDir,n);\n    float bndotl = dot(-lightDir,normalize(p));    \n    float smallCurvature = (1.0f-ao)*0.05f;\n    \n    #ifdef iqMethodComparison\n        vec3 ss; \n        vec3 bss; \n    \tfloat mouseCurvatureControl = (iMouse.y / iResolution.y-0.5f)*2.0f;\n        if(screenCoords.x < 0.5f){\n            ss = sss(-bndotl,0.15f+smallCurvature + mouseCurvatureControl);\n            bss = sss(-bndotl,0.15f+smallCurvature + mouseCurvatureControl);\n        }\n        else{\n            ss = texture(iChannel0, vec2(ndotl*0.5f+0.5f,0.15f+smallCurvature+mouseCurvatureControl)).rgb;\n            bss = texture(iChannel0, vec2(bndotl*0.5f+0.5f,0.15f+smallCurvature+mouseCurvatureControl)).rgb;\n        }\n    \n    #else\n        vec3 ss = texture(iChannel0, vec2(ndotl*0.5f+0.5f,0.15f+smallCurvature)).rgb;\n        vec3 bss = texture(iChannel0, vec2(bndotl*0.5f+0.5f,0.15f+smallCurvature)).rgb;\n    #endif\n    \n    return matColor * mix(bss,ss,1.0f-ao) + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = RayDir( 45.0, iResolution.xy, fragCoord.xy );\n\tvec3 eye = vec3( 0.0, 0.0, 50.0 );\n\n\tmat3 rot = RotationXY( vec2(0,2.0f*PI*(iMouse.x/iResolution.x)));\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n    vec2 rayResult = Intersect( eye, dir, 0.0, 1000.0 );\n    \n\tfloat depth = rayResult.x;\n    \n\tif ( depth >= 1000.0 ) {        \n\t\tfragColor = vec4(0.0f,0.0f,0.0f,depth);\n        return;\n\t}\n\t\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = Normal( pos );\n    vec3 fogColor = vec3(0.3f,0.3f,0.3f);\n    \n    fragColor = vec4(material( pos, n, eye, rayResult.y, fragCoord/iResolution.xy ), depth);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}