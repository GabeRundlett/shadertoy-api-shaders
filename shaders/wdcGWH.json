{
    "Shader": {
        "info": {
            "date": "1568362480",
            "description": "I was watching One Strange Rock by NatGeo and this had to be done. \n\nEdit: Now working on Intel chips, thanks to @adx through the Discord server.",
            "flags": 32,
            "hasliked": 0,
            "id": "wdcGWH",
            "likes": 14,
            "name": "NotOurHome",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "space"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 681
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/XdfGDH by mrharicot.\nfloat normpdf(in float x, in float sigma)\n{\n    return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //declare stuff\n    const int mSize = 7;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec4 final_colour = vec4(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n\n    vec2 uv = fragCoord.xy / iResolution.xy, mou = iMouse.z < 0.5 ? vec2( 0.5 ) : iMouse.xy / iResolution.y, p = gl_FragCoord.xy / iResolution.y;\n\n\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture( iChannel0, ( fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy, 0.0 );\n\n        }\n    }\n\n\n    final_colour = final_colour/(Z*Z);\n\n\tfragColor = texture( iChannel0, uv );\n    \n    float r = 1.0, b = r - 0.7;\n    \n    fragColor = mix( final_colour, fragColor, smoothstep( r, b, length( ( ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y ) ) ) );\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float eps = 1e-3, freq = 2.7, ampl = 0.34, hei = 0.7;\n#define STARS\n\n// Hash By Dave Hoskins.\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// Thanks Dave for your Sine-Less hashes.\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat noise( vec2 uv )\n{\n\n    vec2 lv = fract( uv );\n    lv *= lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n\n    vec2 top = vec2( hash( id + vec2( 0, 1 ) ), hash( id + vec2( 1 )    ) );\n    vec2 bot = vec2( hash( id ),                hash( id + vec2( 1, 0 ) ) );\n\n    float dY = mix( top.x, top.y, lv.x );\n    float dX = mix( bot.x, bot.y, lv.x );\n\n    return mix( dX, dY, lv.y );\n\n}\n\nfloat fbmO( vec2 uv )\n{\n\n    float amp = 1.0, fre = 1.0, tot = 0.0, div = 0.0;\n\n    for( int i = 0; i < 3; ++i )\n    {\n\n        tot += amp * noise( uv * fre );\n        amp *= ampl;\n        fre *= freq;\n\n    }\n\n    return tot * hei;\n\n}\n\nfloat fbmT( vec2 uv )\n{\n\n    float amp = 1.0, fre = 1.0, tot = 0.0, div = 0.0;\n\n    for( int i = 0; i < 3; ++i )\n    {\n\n        tot += amp * noise( uv * fre );\n        div += amp;\n        amp *= 0.7;\n        fre *= 2.0;\n\n    }\n\n    return tot / div;\n\n}\n\nfloat cir( vec2 uv, float r, float b, vec2 mou )\n{\n\n    return smoothstep( r, r - b, length( uv - mou ) );\n\n}\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n\n}\n\nfloat mapO( vec3 p, float time )\n{\n\n    return length( p + vec3( 0, 150, 0 ) ) - 150.0 + fbmO( p.xz + vec2( 0, time * 0.5 ) );\n    \n}\n\nfloat fbm( vec2 uv )\n{\n\n    float amp = 1.0, fre = 1.0, tot = 0.0, div = 0.0;\n\n    for( int i = 0; i < 8; ++i )\n    {\n\n        tot += amp * noise( uv * fre );\n        amp *= ampl;\n        fre *= freq;\n\n    }\n\n    return tot * hei;\n\n}\n\nfloat map( vec3 p, float time )\n{\n    \n    return length( p + vec3( 0, 150, 0 ) ) - 150.0 + fbm( p.xz + vec2( 0, time * 0.5 ) );\n    //return min( p.y + 1.0, length( p - vec3( 0, 0, 4.2 ) ) - 1.0 );\n\n}\n\n// Thanks to @adx \"[code]inout[/code] means make a copy of the existing contents when entering the function\" \nfloat ray( vec3 ro, vec3 rd, out float d, inout vec3 colO, float time )\n{\n\n    float t = 0.0;\n\n    for( int i = 0; i < 256; ++i )\n    {\n\n        d = map( ro + rd * t, time );\n\n        if( abs( d ) < eps || t > 15.0 ) break;\n\n        t += 0.5 * d;\n        colO.g += 0.006;\n        colO.b += 0.005;\n\n    }\n\n    return t;\n\n}\n\n// iq's suggestion here: https://www.shadertoy.com/view/td3GW8\nvec3 gra( vec3 pos, float time )\n{\n    \n    vec4 n = vec4( 0 );\n    \n    for( int i = min( iFrame, 0 ); i < 4; i++ )\n    {\n        vec4 s = vec4( pos, 0 );\n        s[i] += eps;\n        n[i] = map( s.xyz, time );\n    }\n    \n    return normalize( n.xyz-n.w );\n}\n\nvec3 pla( float t )\n{\n\n    return mix(\n                vec3( 0.0, 0.1, 0.15 ),\n                vec3( 0.0, 0.4, 0.5 ),\n                t\n    \t\t  );\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd, float tim )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n        \n        float h = map( ro + rd * t, tim );\n        \n        if( h < eps ) return 0.0;\n        res = min( res, 2.0 * h / t );\n        t += h;\n    \n    }\n    \n    return res;\n    \n}\n\nvec3 sha( vec3 ro, vec3 rd, float tim )\n{\n    \n    float d = 0.0; vec3 colO = vec3( 0 );\n\n    float t = ray( ro, rd, d, colO, tim );\n    vec3 p = ro + rd * t, col = vec3( 0 ), n = gra( p, tim ), lig = vec3( 0.8, 0.2, 1 );\n    lig = normalize( lig );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n\tvec3 ref = reflect( rd, n );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float bac = max( 0.0, 0.2 + 0.8 * dot( n, blig ) );\n    float sha = softShadows( p, lig, tim );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 ); \n    col += 0.2 * amb;\n    col += pla( 0.5 ) * dif;\n    col *= 0.7 * sha;\n    col += vec3( 0.1, 0.15, 0.0 ) * bac;\n    col += vec3( 0.25, 0.3, 0.35 ) * spe;\n    col += colO;\n    //col = clamp( mix( vec3( 0.7 ), col, fbm( p.xz + vec2( 0, tim * 0.5 ) ) ), 0.0, 1.0 );\n\n    // Fog by dila.\n    col /= 0.2 * ( 6.0 + pow( t, 4.0 ) );\n    // Inverse.\n    //col *= 0.3 * ( 1.0 + t );\n\n    return pow( col, vec3( 0.4545 ) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    float tim = iTime * 0.5;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n    vec3 colO = vec3( 0 );\n    \n    vec3 ro = vec3( 0 );\n    vec3 rd = normalize( vec3( uv, 1 ) );\n    float terH = 0.0;\n    iMouse.z < 0.5 ? terH = 0.2 : terH = mou.y;\n    ro.y += terH - mapO( ro, tim );\n    //rd.xz *= rot( noise( vec2( 0.1 * sin( iTime * 0.8 ) ) ) );\n    // Uncomment for Lucy in the Sky with Diamonds...\n    /*ro.yz *= rot( mapO( rd, tim ) );\n    rd.yz *= rot( mapO( ro, tim ) );*/\n    float d = 0.0, t = ray( ro, rd, d, colO, tim );\n    vec3 p = ro + rd * t;\n\n    vec3 col = vec3( 0 ), back = vec3( 0 );\n\n    float l = length( uv ), s = smoothstep( 0.507, 0.487, l ), ti = iTime * 0.05;\n    vec2 uvM = uv * 5.0;\n    back = mix(\n        mix( back, vec3( 0, 0.3, 1 ), s ),\n        pla( fbm( vec2( ti, 0 ) + uvM + fbm( vec2( 0, ti ) + uvM ) ) ),\n        smoothstep(\n            0.5,\n            0.49,\n            l\n        )\n    );\n\n    float shadow = smoothstep( 0.6, 0.45, length( uv + vec2( 0 ) ) ), sta = 0.0, siz = 0.0025, h = siz * 0.25;\n\tfloat shadowO = smoothstep( 0.6, 0.45, length( uv - vec2( 0.2 ) ) );\n    \n    //back = vec3( shadow - shadowO );\n    back = mix( back, vec3( 0 ), shadow - shadowO );\n    \n    #ifdef STARS\n    for( int i = 0; i < 300; ++i )\n    {\n    \n        vec2 n = hash22( vec2( i ) );\n        vec2 pO = ( -iResolution.xy * sin( n * 1000.0 * iDate.z ) ) / iResolution.y;\n        \n        sta += cir( uv, siz, h, pO ); \n        \n    }\n    \n    vec3 backO = vec3( 0 );\n    \n    if( sta > 0.1 )\n        \n        backO += 1.0 * vec3( hash( ( uv * 10.0 ) * tim ) );\n    \n    back = mix( backO, back, s );\n    \n    #endif\n\n    d < eps ? col = sha( ro, rd, tim ) : col = back;\n\n    fragColor = vec4( col, 1 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}