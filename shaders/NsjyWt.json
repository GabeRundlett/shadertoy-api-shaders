{
    "Shader": {
        "info": {
            "date": "1644326883",
            "description": "More experiments with instrument synthesis. Added stereo.",
            "flags": 8,
            "hasliked": 0,
            "id": "NsjyWt",
            "likes": 6,
            "name": "Music - Ballad",
            "published": 3,
            "tags": [
                "music"
            ],
            "usePreview": 1,
            "username": "ersh",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float bpm = 70.;\nfloat T;\nfloat seed;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float t) {\n    float p = ((seed+=1.) + mod(t, 21.435214) * 1500. + 50.0);\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat mixc(float a, float b, float r) { return mix(a, b, clamp(0., 1., r)); }\n\n//float note2freq(float note) { return 440. * exp2(-10./12.) * exp2(note/12.); }\nfloat note2freq(float note) { return 440. * exp2(-2./12.) * exp2(note/12.); }    // transposed to the current key\n\nfloat sinhz(float x) { return sin(6.2831*x); }\nfloat saw(float x) { return abs((fract(x-0.25)-0.5)*2.)*2.-1.; }\nfloat sawt(float x) { return fract(x-0.5)*2.-1.; }\n\nfloat distort(float x) { return sin(3.1415926/2.*x*2.); }\n\nfloat kick(float t) { return distort(t*40.*sin(0.3/(t+0.0001))*exp(-t*30.)*0.35); }\nfloat hh(float t, float decay) { return hash11(mod(t,1./4500.))*(exp(-t*decay) + t*200.*clamp(1.-t*100.,0.,1.)); }\nfloat snare2(float t) { return t*3. * hash11(floor(t*8000.)/8000.)*exp(-t*10.); }\nfloat snare(float t) { return snare2(t) + hash11(t)*sawt(t*40.)*smoothstep(0.08,0.,t); }\n\nfloat padsynth(float t, float note) {\n    float freq = note2freq(note);\n    float h1 = saw(freq*t) + saw(freq*t*2.)/2. + saw(freq*t*3.)/6. + saw(freq*t*4.)/5. + sawt(freq*t*8.)/10.;\n    float h2 = sinhz(freq*t) + sinhz(freq*t*2.)/2.;\n    return mixc(h1, h2, 1.-exp(-t*2.));\n}\n\nfloat basssynth(float t, float note, float soft) {\n    float freq = note2freq(note-24.);\n    float p = freq*t;   //    p = p/smoothstep(0.,0.1,p);\n    float h1 = sawt(p) * (1. + sin(0.1/(t+0.00001))*0.3), h2 = sinhz(p), h3 = sinhz(p/2.);\n    return (mixc(h1, h2, 1.-exp(-t*1.2) + soft) + h2/3. + h3)*exp(-t*0.2);\n}\nfloat basssynth(float t, float note) { return basssynth(t, note, 0.); }\n\nfloat t(float offset) { return T - 60./bpm*4. * offset; }\nfloat m(float repeat, float offset) { return mod(T - 60./bpm*4. * offset, 60./bpm*4. * repeat); }\nfloat m(float repeat) { return m(repeat, 0.); }\n#define T(a,b)   (float(a)/float(b))\n#define T1(a)    (1./float(a))\n#define M(a,b)   m(float(a)/float(b))\n#define M1(a)    m(1./float(a))\n#define MM(a,b,c,d)  m(float(a)/float(b), float(c)/float(d))\n\nfloat s(float offset, float len) { return step(60./bpm*4. * offset, T) * (1. - step(60./bpm*4. * (offset+len), T)); }\nfloat s(float offset) { return step(60./bpm*4. * offset, T); }\nfloat ss(float offset, float len, float decay) {\n    return step(60./bpm*4. * offset, T)\n        * (1. - smoothstep(60./bpm*4. * (offset+len), 60./bpm*4. * (offset+len+decay), T))\n    ;\n}\nfloat ss(float offset, float len) { return ss(offset, len, 0.5); }\nfloat st(float offset1, float offset2) { return step(60./bpm*4. * offset1, T) * (1. - step(60./bpm*4. * offset2, T)); }\n\nvec2 pan(float smpl, float a) { return vec2(smpl * cos(a), smpl * (1.-cos(a)))*1.5; }\n\n#define DETUNE(FUNC, TIME, NOTE)  (FUNC(TIME, NOTE) + FUNC(TIME, NOTE+0.2) + FUNC(TIME, NOTE-0.1))/6.\n#define DETUNE2(FUNC, TIME, NOTE)  (FUNC(TIME, NOTE) + FUNC(TIME, NOTE-0.2) + FUNC(TIME, NOTE+0.1))/6.\n#define SYNTH(TIME, NOTE)               vec2(DETUNE(padsynth, TIME, NOTE)*0.7, DETUNE2(padsynth, TIME, NOTE)*0.7)\n#define VIBRATO(FREQ, DEPTH)           (1. + sinhz(T*FREQ)*DEPTH)\n#define TREMOLO(FREQ, DEPTH)           sinhz(T*FREQ)*DEPTH\n#define V                               VIBRATO(5.5, 0.3)\n#define ORGAN(TIME, NOTE)               distort(DETUNE(padsynth, TIME, NOTE)+DETUNE(padsynth, TIME, NOTE+12.)*0.4)*0.2\n\n#define BASSSYNTH(TIME, NOTE)       vec2(DETUNE(basssynth, TIME, NOTE), DETUNE2(basssynth, TIME, NOTE))\n\nvec2 drumpat() {\n    return vec2(0.\n        + kick(m(1.))\n        + kick(m(1., 1./2.+1./16.))*0.3\n        + kick(m(1., 1./2.+1./8.))\n        + hh(M(1,8), 50.)*0.2\n        + hh(MM(1,8,1,16), 10.)*0.08\n        + snare(m(T1(2), T1(4)))\n    );\n}\n\nvec2 pat1(float time) {\n    T = time;\n    T = m(4.);\n    return vec2(0)\n        + drumpat()\n\n        + BASSSYNTH(m(4.), 0.) * s(0., 1.)\n        + BASSSYNTH(m(4., 1.), -4.) * s(1., 1.)\n        + BASSSYNTH(m(4., 2.), -2.) * s(2., 1.)\n        + BASSSYNTH(m(4., 3.), -7.) * s(3., 1./2.)\n        + BASSSYNTH(m(4., 3.+2./4.), -5.) * s(3.+2./4., 1./4.)\n        + BASSSYNTH(m(4., 3.+3./4.), -2.) * s(3.+3./4., 1./4.)\n\n        + SYNTH(t(0.)+2., -12. + 7.) * ss(0., 1./8.)*0.3\n        + SYNTH(t(1./8.), 3.) * ss(3./8., 1./8.)\n        + SYNTH(t(3./8.), 2.) * ss(4./8., 1./8.)\n        + SYNTH(t(4./8.), 3.) * ss(5./8. + 1./16., 1./8., 1.)\n        + SYNTH(t(7./8.), 0.) * ss(7./8., 1./8., 1.5)\n\n        + SYNTH(t(2.+1./8.), 3.) * ss(2.+3./8., 1./8.)\n        + SYNTH(t(2.+3./8.), 2.) * ss(2.+4./8., 1./8.)\n        + SYNTH(t(2.+5./8.), 3.) * ss(2.+5./8. + 1./16., 1./8.)\n        + SYNTH(t(2.+7./8.), 0.) * ss(2.+7./8., 1./8.)\n\n        + SYNTH(t(3.), 3.) * ss(3.+1./8.+1./16., 1./8.)\n        + SYNTH(t(3.+3./8.), 2.) * ss(3.+3./8., 1./8., 0.75)\n        ;\n}\n\nvec2 pat2(float time) {\n    T = time;\n    T = m(4.);\n    float[] ts1 = float[] (\n        0.,\n        1. + 1./4. + 1./8.,\n        1. + 1./4. + 1./8. + 1./16.,\n        1. + 1./2.,\n        \n        2.,\n        3. - 1./8.,\n        3.,\n        3. + 3./16.,\n        3. + 6./16.,\n        3. + 10./16.,\n        3. + 13./16.\n    );\n    return vec2(0)\n        + pat1(time)\n\n        + pan(\n              (ORGAN(time+0.3, 12. + 7.)\n            + ORGAN(time+0.3, 12. + 3.))/2. * V * st(ts1[0], ts1[1])\n            + (ORGAN(time, 12. + 5.)\n            + ORGAN(time, 12. + 2.))/2. * st(ts1[1], ts1[2])\n            + (ORGAN(time, 12. + 7.)\n            + ORGAN(time, 12. + 3.))/2. * st(ts1[2], ts1[3])\n            + (ORGAN(time, 12. + 3.)\n            + ORGAN(time, 12. + 0.))/2. * V * ss(ts1[3], ts1[4]-ts1[3]-1./8., 1./6.)\n\n            + (ORGAN(t(2.)+0.3, 12. + 5.)\n            + ORGAN(t(2.)+0.3, 12. + 2.))/2. * V * st(ts1[4], ts1[5])\n            + ORGAN(t(2.)+2., 12. + 3.)    * V * st(ts1[5], ts1[6])\n            + ORGAN(t(2.)+2., 12. + 2.)    * V * st(ts1[6], ts1[7])\n            + ORGAN(t(2.)+2., 12. + 0.)    * V * st(ts1[7], ts1[8])\n            + ORGAN(t(2.)+2.,       7.)    * V * st(ts1[8], ts1[9])\n            + ORGAN(t(2.)+2., 12. + 2.)    * V * ss(ts1[9], 1./4., 1./8.)\n            , m(2.)*0.4)\n        ;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    T = time;\n    seed = 10.;\n\n    float p1 = m(16.);\n    float p2 = m(16., 8.);\n    return p1 < p2 ? pat1(p1) : pat2(p2);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}