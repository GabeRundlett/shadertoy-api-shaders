{
    "Shader": {
        "info": {
            "date": "1563342431",
            "description": "Use the mouse to rotate around the gyroid.\nhttps://en.wikipedia.org/wiki/Gyroid",
            "flags": 0,
            "hasliked": 0,
            "id": "wtfSRS",
            "likes": 4,
            "name": "gyroid SDF",
            "published": 3,
            "tags": [
                "raymarching",
                "interactive",
                "sdf",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "zzggbb",
            "viewed": 958
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\n// rays that go further than this return the background color\n#define MAX_DIST 100.0\n\n// maximum iterations in the ray casting algorithm\n#define MAX_ITERS 150\n\n/*\nthe ray casting algorithm stops once it reaches \nthis distance from the scene\n*/\n#define CAST_RAY_EPSILON 0.01\n\n#define EYE_DISTANCE 30.0\n\n#define RADIUS 10.0\n\n#define BACKGROUND_COLOR vec3(0.1)\n\nfloat linscale(float x, float x1, float x2, float y1, float y2) {\n    return (y2-y1) / (x2-x1) * (x-x1) + y1;\n}\n\nfloat osc(float m, float M) {\n\treturn linscale(sin(iTime), -1., 1., m, M);\n}\n\nfloat displace(vec3 p, float k) {\n\treturn sin(k*p.x)*sin(k*p.y)*sin(k*p.z);\n}\n\nfloat torus_sdf(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sphere_sdf(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat box_sdf(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n           + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat gyroid_sdf(vec3 p) {\n\treturn dot(sin(p.xyz), cos(p.yzx)) + osc(-1.3, 1.3);\n}\n\nfloat sdf_union(float a, float b) {\n\treturn min(a, b);\n}\n\nfloat sdf_intersect(float a, float b) {\n\treturn max(a, b);    \n}\n\n// scene defined by signed distance function\nfloat scene_sdf(vec3 p) {\n    float gyroid_dist = 0.33*abs(gyroid_sdf(p));\n    #if 1\n    \tfloat bounding_dist = torus_sdf(p, vec2(RADIUS, 5.0));\n    #else\n    \tfloat bounding_dist = box_sdf(p, vec3(7.5, 7.5, 7.5));\n    #endif\n\tfloat base_shape = sdf_intersect(gyroid_dist, bounding_dist);\n\treturn base_shape;\n}\n\n// normal vector to the scene at point 'p'\nvec3 scene_norm(vec3 p) {\n\t// specific to the gyroid_sdf function\n    return normalize(vec3(\n    \tcos(p.x)*cos(p.y) - sin(p.x)*sin(p.z),\n        cos(p.y)*cos(p.z) - sin(p.x)*sin(p.y),\n        cos(p.x)*cos(p.z) - sin(p.y)*sin(p.z) \n    ));\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n\tfloat res = 1.0; \n    for(float t=mint; t<maxt;) { \n\t\tfloat h = scene_sdf(ro + rd*t); \n        if(h<0.001) \n            return 0.0; \n        \n        res = min(res, k*h/t ); \n        t += h; \n    } \n    return res; \n}\n\nfloat cast_ray(vec3 eye, vec3 ray) {\n\tray = normalize(ray);\n    \n    float total_dist = 0.0;\n    float current_dist;\n    \n    for (int i=0; i<MAX_ITERS; i++) {\n    \tcurrent_dist = scene_sdf(eye + total_dist * ray);\n        \n        // we're inside the scene \n        if (current_dist <= CAST_RAY_EPSILON)\n           break;\n        \n        total_dist += current_dist;\n        \n    }\n    return total_dist;\n}\n\n// get color of point 'p' from perspective of 'eye' using phong model\nvec3 phong(vec3 eye, vec3 p) {\n    vec3 light_pos = vec3(0.0,0.0,0.0);\n    \n    // give each side of the surface a different color\n    float side = sign(gyroid_sdf(p));\n    \n    \n    vec3 ambient_color = vec3(0.00,0.00,0.00);\n    float Ia = 0.5; // ambient strength\n    float Id = 0.5; // diffuse strength\n    float Is = 0.5; // specular strength\n    float sh = 64.0; // shininess\n    \n    vec3 N = scene_norm(p); \t\t// normal vector\n    vec3 L = normalize(light_pos - p);  // light vector\n    vec3 V = normalize(eye - p);\t\t// view vector\n\n    if (dot(V, N) < 0.0)\n        N = -N;\n    \n    vec3 surface_color = N*0.5+0.5;\n    \n    vec3 R = normalize(reflect(-L, N)); // reflection vector\n    \n    // ambient light contribution\n    vec3 La = Ia * ambient_color;\n    \n    // diffuse light contribution\n    vec3 Ld = Id * surface_color * max(0.0, dot(N, L));\n    \n    // specular light contribution\n    vec3 Ls = Is * surface_color * pow(max(0.0, dot(V, R)), sh);\n        \n    return La + Ld + Ls;\n}\n\nvec2 intersect(vec3 eye, vec3 ray, vec3 sphere) {\n    /*\n    If the ray from eye intersects with the sphere, returns\n    the distance to the intersection point and 1.0 as the 2nd component.\n\n    If there is no intersection, returns all zeros.\n    */\n    eye = normalize(eye);\n    ray = normalize(ray);\n\n    float a = pow(dot(ray, eye - sphere), 2.0);\n    float b = (dot(eye-sphere,eye-sphere) - pow(RADIUS, 2.0));\n    float c = a - b;\n    if (c >= 0.0) {\n        float d = -dot(ray, eye - sphere) - sqrt(c);\n        return vec2(d, 1.0);\n    }\n    return vec2(0.0, 0.0);\n}\n\nvec3 render(vec3 eye, vec3 ray) {\n    vec2 intersection = intersect(eye, ray, vec3(0.0));\n    if (intersection.y == 1.0) {\n        float dist = cast_ray(eye, ray);\n        if (dist >= MAX_DIST) return BACKGROUND_COLOR;\n        vec3 p = eye + (dist * ray);\n        return phong(eye, p);    \n    } else {\n        return BACKGROUND_COLOR;\n    }\n\n} \n\nmat3 lookat(vec3 eye, vec3 at, vec3 up) {\n    vec3 f = normalize(at - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = normalize(cross(s, f));\n    return mat3(s, u, -f);\n}\n\nvec3 sphere2xyz(float yaw, float pitch) {\n    return vec3(sin(pitch)*cos(yaw), cos(pitch), sin(pitch)*sin(yaw));\n}\n\nvec2 screen_space(vec2 pixel, vec2 dim) {\n\treturn (pixel - 0.5*dim) / min(dim.x, dim.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = screen_space(fragCoord.xy, iResolution.xy);\n    float mx = iMouse.x / iResolution.x;\n    float my = iMouse.y / iResolution.y;\n    \n    // default mouse position, if mouse isn't on screen\n    if (mx < 0.01) mx = .5*cos(iTime/2.0)+.5;\n    if (my < 0.01) my = .25;\n    \n    float yaw = linscale(mx, 0.0, 1.0, -PI, PI);\n    float pitch = linscale(my, 0.0, 1.0, 0.0, PI);    \n    vec3 eye = EYE_DISTANCE * sphere2xyz(yaw, pitch);\n    vec3 at = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 ray = lookat(eye, at, up) * normalize(vec3(p, -1.0));\n    vec3 color = render(eye, ray);\n    fragColor = vec4(sqrt(color), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}