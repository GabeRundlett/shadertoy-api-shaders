{
    "Shader": {
        "info": {
            "date": "1473934811",
            "description": "Shows how to compute a binary heap in buffer A and then draw lines for branches in buffer B. I believe it has some bugs still. A branch per pixel. New random tree each 20 seconds (when at 60 FPS).",
            "flags": 32,
            "hasliked": 0,
            "id": "4lKGzw",
            "likes": 7,
            "name": "Tree Computation",
            "published": 3,
            "tags": [
                "2d",
                "tree",
                "heap"
            ],
            "usePreview": 0,
            "username": "emh",
            "viewed": 877
        },
        "renderpass": [
            {
                "code": "vec2 restorePoint(vec2 point) {\n    return point * 2.0 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvn = restorePoint(uv);\n    vec4 color = texture(iChannel0, uv);\n    vec2 point = restorePoint(color.zw);\n    float d = distance(uvn, point);\n    fragColor.a = 1.0;\n    if (color.x > 0.0 || color.z > 0.0) {\n    \t//fragColor = vec4(vec3(0.0, 0.0, color.x * 1.0e3 * color.y) + vec3(color.z, 0.0, 0.0), 1.0);\n        float g = color.x * 1000.0 * pow(color.y, 0.5);\n        fragColor = vec4(vec3(0.0, g, 0.0) + vec3(color.z, 0.0, 0.0), 1.0);\n    } else {\n        //fragColor = vec4(vec3(0.5), 1.0);\n        fragColor = vec4(vec3(0.5 + uv.y / 2.0, 0.5, 0.5), 1.0);\n    }\n    //fragColor = vec4(vec3(color.x) * 10.0, 1.0);\n\t//fragColor = vec4(vec3(d) * 200.0, 1.0);\n    //fragColor = vec4(vec3(d) * 10.0, 1.0);\n    //fragColor.xy = color.xy;\n    //fragColor = vec4(vec3(color.z), 1.0);\n    //fragColor.xy = texture(iChannel1, uv).xy;\n    //fragColor.r = texture(iChannel1, uv).z;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653589793238462643383\n\n#define REDRAW_INTERVAL 20.0\n\n#define Thickness 0.001\n\n#define iRes iChannelResolution[0]\n\n// Simple random function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\n#define INIT_VALUE1 storePoint(vec2(1.0))\n#define INIT_VALUE2 storePoint(vec2(0.0))\n#define INIT_VALUE vec4(INIT_VALUE1, INIT_VALUE2)\n\nvec2 restorePoint(vec2 point) {\n    return point * 2.0 - 1.0;\n}\n\nvec2 storePoint(vec2 point) {\n    return (point + 1.0) / 2.0;\n}\n\nvec4 doMain(vec2 fragCoord, vec2 uv) {\n    vec4 prev = texture(iChannel0, uv);\n    vec2 coord = fragCoord;\n    int height = int(iRes.y);\n    float eps = 1.0;\n    vec2 uvn = restorePoint(uv);\n    \n    // test\n    /*\n    vec2 point = vec2(uvn.x, uvn.y);\n    prev.xy = storePoint(point);\n    prev.zw = storePoint(point+vec2(1.0)/iRes.xy);\n    prev.zw = storePoint(vec2(0.0));\n\t*/\n    \n    if (prev.xy == INIT_VALUE1 && coord.x < eps && coord.y < eps) {\n        vec2 point = vec2(0.0, -1.0);\n        float radius = 0.2;\n        float angle = PI / 2.0;\n        vec2 point2 = storePoint(point + vec2(cos(angle), sin(angle)) * radius);\n        point = storePoint(point);\n        return vec4(point2, point);\n    }\n    \n    const int iterations = 1;\n    int index = int(coord.y) * int(height) + int(coord.x);\n    int maxi = 0;\n    for (int i = 0; i < iterations; i++) {\n        if (index == 0) {\n            maxi = i;\n            break;\n        }\n        int parentIndex = (index - 1) / 2;\n        vec2 pv2 = vec2(mod(float(parentIndex), float(height)), float(parentIndex / int(height))) / iRes.xy;\n        vec4 parentValue = texture(iChannel0, pv2);\n        \n        if (i == 0 && prev.xy == INIT_VALUE1 && parentValue.xy != INIT_VALUE1) {\n            \n            vec2 point = restorePoint(parentValue.xy);\n            vec2 point2 = restorePoint(parentValue.zw);\n            \n            float radius = distance(point, point2) * 0.9;\n            vec2 pp2 = point - point2;\n            float prevAngle = atan(pp2.y, pp2.x);\n            \n            float at = atan(uvn.y - point.y, uvn.x - point.x);\n            float atNorm = (at + PI) / (2.0 * PI);\n            float angle = random(11.7 + at + uv.x + uv.y + iTime);\n            //float angle = random(11.7 + floor(at * 5.0) + iTime);\n            angle = prevAngle + (angle * 2.0 - 1.0) * PI / 4.0;\n            vec2 newPoint = point + vec2(cos(angle), sin(angle)) * radius;\n            newPoint = storePoint(newPoint);\n            vec2 parentPoint = storePoint(point);\n            float storeAngle = (angle + PI) / (2.0 * PI);\n            return vec4(newPoint, parentPoint);\n        } else {\n            break;\n        }\n        index = parentIndex;\n    }\n    //if (prev.xy == INIT_VALUE1) {\n    \n    //}\n    return prev;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iRes.xy;\n    \n    // initialize\n    if (mod(float(iFrame), REDRAW_INTERVAL * 60.0) < 10.0) {\n        fragColor = INIT_VALUE;\n    } else {\n    \tfragColor = doMain(fragCoord, uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.141592653589793238462643383\n\n#define REDRAW_INTERVAL 20.0\n\n#define Thickness 0.001\n\n#define iRes iChannelResolution[0]\n\n// from http://stackoverflow.com/questions/15276454/is-it-possible-to-draw-line-thickness-in-a-fragment-shader\n\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  // median to (p1, p2) vector\n  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));\n}\n\n// end from\n\n\n// Simple random function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\n#define INIT_VALUE1 storePoint(vec2(1.0))\n#define INIT_VALUE2 storePoint(vec2(0.0))\n#define INIT_VALUE vec4(INIT_VALUE1, INIT_VALUE2)\n\nvec2 restorePoint(vec2 point) {\n    return point * 2.0 - 1.0;\n}\n\nvec2 storePoint(vec2 point) {\n    return (point + 1.0) / 2.0;\n}\n\n/*\nvec2 getParent(vec2 pv) {\n    int height = int(iRes.y);\n    int index = int(pv.y * iRes.y) * int(height) + int(pv.x * iRes.x);\n    int parentIndex = (index - 1) / 2;\n    float x = mod(float(parentIndex), float(height));\n    float y = float(parentIndex / height);\n    vec2 pv3 = vec2(x, y) / iRes.xy;\n    vec4 parentValue = texture(iChannel0, pv3);\n    vec2 point2 = restorePoint(parentValue.xy);\n    return point2;\n}\n\nvec2 getClosestPointOnLine(vec2 point, vec2 endPoint1, vec2 endPoint2) {\n    vec2 p1 = endPoint1;\n    vec2 p2 = point;\n    vec2 v = endPoint2 - endPoint1;\n    vec2 pr = p1 + dot((p2 - p1), v) * v / dot(v, v);\n    return pr;\n}\n*/\n\nvec4 doMain(vec2 fragCoord, vec2 uv) {\n    vec4 prev2 = texture(iChannel1, uv);\n    vec2 coord = fragCoord; //uv * iRes.xy;\n    int height = int(iRes.y);\n    float eps = 1.0;\n    \n    vec2 uvn = restorePoint(uv);\n    \n    \n    if (prev2.x == INIT_VALUE.x) {\n        prev2.x = 0.0;\n        prev2.y = 1.0;\n        prev2.z = 0.0;\n    }\n\n    const int area = 10;\n    const int area2 = area * 2;\n    \n    // why * 2.0? was found \"experimentally\"\n    float numAreasHeight = ceil(float(height / area2)) * 2.0;\n\n    //float frame = mod(float(iFrame), ceil(iRes.x * iRes.y / float(area2 * area2)));\n    //float frame = mod(float(iFrame), numAreasHeight * numAreasHeight);\n    float frame = float(iFrame);\n    float frameX = mod(frame, numAreasHeight) * float(area2);\n    float frameY = floor(frame / numAreasHeight) * float(area2);\n    float xoffset = frameX / iRes.x;\n    float yoffset = frameY / iRes.y;\n\n    for (int i = -area; i < area; i++) {\n        for (int j = -area; j < area; j++) {\n            vec2 pv = uv + vec2(float(i), float(j)) / iRes.xy;\n            pv.x = fract(pv.x + xoffset);\n            pv.y = fract(pv.y + yoffset);\n            vec4 val = texture(iChannel0, pv);\n            if (val == INIT_VALUE) {\n                continue;\n            }\n            vec2 point = restorePoint(val.xy);\n            vec2 point2 = restorePoint(val.zw);\n\n            //vec2 point2 = getParent(pv);\t\t\t\t\n            float z = drawLine(uvn, point, point2);\n            if (uvn == point || uvn == point2) {\n                z = 1.0;\n            }\n            float maxdist = 0.001;\n            float z2 = distance(uvn, point);\n            float z3 = distance(uvn, point2);\n            if (z2 >= maxdist) {\n                z2 = 0.0;\n            } else {\n                z2 = 1.0;\n            }\n            if (z3 >= maxdist) {\n                z3 = 0.0;\n            } else {\n                z3 = 1.0;\n            }\n\n            prev2.x += 0.0001 * z;\n            if (z > 0.0) {\n                prev2.y = 1.0 / (1.0 / prev2.y + 1.0);\n            }\n\n            // draw nodes\n            //prev2.z = max(prev2.z, max(z2, z3));\n        }\n    }\n    \n    return prev2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iRes.xy;\n    \n    // initialize\n    if (mod(float(iFrame), REDRAW_INTERVAL * 60.0) < 10.0) {\n        fragColor = INIT_VALUE;\n    } else {\n    \tfragColor = doMain(fragCoord, uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}