{
    "Shader": {
        "info": {
            "date": "1606060610",
            "description": "driving crazy car",
            "flags": 8,
            "hasliked": 0,
            "id": "wstfWj",
            "likes": 5,
            "name": "driving crazy car",
            "published": 3,
            "tags": [
                "drivingcrazycar"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "//---------Modificado por jorgefloresP....jorge2017a1---22/nov/2020\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n\n\n// by nothings\n// Derived fromn by Lou's Pseudo 3d page\n// http://www.gorenfeld.net/lou/pseudo/\n// and from space harrier glsl sandbox demo\n\n\n\n// hash from iq's live coded apple\nfloat hash(float n)\n{\n\treturn fract(sin(n)*43758.54);\n}\n\nfloat roadpoint(float n)\n{\n\tif (hash(n+0.5) > 0.75)\n\t\treturn 0.0;\n\tfloat z = (hash(n)-0.5)*2.2;\n\treturn sign(z) * pow(abs(z),2.0);\n}\n\n// cubic interpolator\nfloat noise(float x)\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\tfloat p0 = roadpoint(p);\n\tfloat p1 = roadpoint(p+1.0);\n\tfloat p2 = roadpoint(p+2.0);\n\tfloat p3 = roadpoint(p+3.0);\n\tfloat a = (-p0*0.5 + 1.5*p1 - 1.5*p2 + p3*0.5);\n\tfloat b = p0 - 2.5*p1 + 2.0*p2 - 0.5*p3;\n\tfloat c = 0.5*p2 - 0.5*p0;\n\tfloat d = p1;\n\treturn d + f*(c + f*(b + f*a));\n}\t\n\nfloat road_offset(float pos)\n{\n\treturn noise(pos/80.0)*10.0\n\t\t+ noise(pos/500.0)*80.0; // add some \"long-range\" curves\n}\n\nfloat road_slope(float pos)\n{\t\n\treturn (road_offset(pos+4.0) - road_offset(pos-4.0))/8.0;\t\n}\n\n\nvec2 pix(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 position = fragCoord.xy / iResolution.yy;\n\t//position = pix(position, 0.01);  //por @z0rg \n    \n    \n\tfloat y = position.y-0.62;\n\tif (position.y > 0.6) {\n\t\tfragColor = vec4(0.2, 0.6, 1.0, 1.0);\n\t\t// enable this \"return\" statement not to draw the ceiling\n\t\treturn;\n\t} \n\ty = -y;\n\n\t// y ranges from 0.02 to 0.62\n\tfloat z = 1.0 / y; // yscreen = y/z, so z = y / yscreen\n\t// z ranges from ~1.5 to 50\n\tfloat speed = 4.5;\n\tfloat dist = pow(z,0.75); // fudge this so the distance doesn't get too aliasy\n\tfloat spacing = 7.0;\n\tfloat bottom_trackpos = iTime*speed*spacing + 1.4*spacing;\n\tfloat trackpos = (dist+iTime*speed)*spacing;\n\tfloat xcenter = -iResolution.x/iResolution.y*0.5;\n\n\t// using average_slope instead of base_slope smooths the camera movement\n\tfloat averaged_slope = (road_slope(bottom_trackpos) + road_slope(bottom_trackpos - speed)) / 2.0;\n\tfloat base_slope = road_slope(bottom_trackpos);\n\tfloat slope = averaged_slope*0.75; // at 1.0 we're always looking strictly forward\n\tfloat slope_offset = (0.62-y) * slope * 8.0; // dunno why 8.0\n\n\tfloat x = (position.x + xcenter - slope_offset) * z; // xscreen = x/z, so x = xscreen * z\n\n\t// compute the road \"view vector\" based on the bottom of the screen\n\tfloat road_point = road_offset(bottom_trackpos);\n\troad_point = road_point - slope*3.5; // move inside the curves\n\troad_point = road_point  + sin(iTime*1.0)*0.05;// + 1.5*(mouse.x-0.5);\n\n\tx -= road_point;\n\t\n\t// compute the course path at the current point\n\tx += road_offset(trackpos);\n\n\tfloat xa = abs(x);\n\tfloat phase = sin(trackpos);\n\tfloat state = phase > 0.0 ? 0.0 : 1.0;\n\tfloat darken = state == 0.0 ? 1.0 : 0.5;\n    \n    \n    vec2 p=position+vec2(-0.4+x*0.0125, 0.0);\n    float sdb1=box( p-vec2(0.5,0.15), vec2(0.2,0.08)); //grande\n    float sdLlantaIzq=box( p-vec2(0.3,0.1), vec2(0.02,0.05)); \n    float sdLlantaDer=box( p-vec2(0.7,0.1), vec2(0.02,0.05)); \n    \n    float sdLineaA=box( p-vec2(0.5,0.1), vec2(0.15,0.0015)); \n    float sdLineaB=box( p-vec2(0.5,0.12), vec2(0.15,0.0015)); \n    \n    \n    float sdLucesA=box( p-vec2(0.35,0.19), vec2(0.015,0.035)); \n    float sdLucesB=box( p-vec2(0.65,0.19), vec2(0.015,0.035)); \n    \n    \n    float sdVentanaA= sdHexagon( p-vec2(0.5,0.24), 0.12 );\n    float sdVentanaB= sdHexagon( p-vec2(0.5,0.24), 0.1 );\n        \n    \n    sdb1 = SS(sdb1);\n    sdLlantaIzq= SS(sdLlantaIzq);\n    sdLlantaDer= SS(sdLlantaDer);\n    \n    sdLineaA= SS(sdLineaA);\n    sdLineaB= SS(sdLineaB);\n    \n    \n    sdLucesA= SS(sdLucesA);\n    sdLucesB= SS(sdLucesB);\n    \n    sdVentanaA= SS(sdVentanaA);\n    sdVentanaB= SS(sdVentanaB);\n    \n        \n    vec3 col =vec3 (0.0);\n    col=mix(col, vec3(1.0), sdVentanaA);\n    col=mix(col, vec3(0.0,0.0,1.0), sdVentanaB);\n    \n    col=mix(col, vec3(1.0), sdb1);\n    col=mix(col, vec3(0.0), sdLlantaIzq);\n    col=mix(col, vec3(0.0), sdLlantaDer);\n    col=mix(col, vec3(0.3), sdLineaA);\n    col=mix(col, vec3(0.3), sdLineaB);\n    \n    col=mix(col, vec3(0.8,0.8,0.5), sdLucesA);\n    col=mix(col, vec3(0.8,0.8,0.5), sdLucesB);\n    \n    \n    \n    \n    \n\tif (xa > 1.6)\n\t\tfragColor = vec4(0,1,0,1) * mix(1.0,darken * phase,y); // messing around here <<---\n\telse if (xa > 1.4) {\n\t\tfragColor = (state==0.0 ? vec4(1,0,0,1) : vec4(1,1,1,1));\n\t}\n\telse if (state==0.0 && abs(xa-0.45) < 0.05)\n\t\tfragColor = vec4(1,1,1,1);\n\telse\n\t\tfragColor = vec4(0.5,0.5,0.5,1.0);\n        \n        \n   \n   fragColor =mix(fragColor, vec4(col,1.0),sdVentanaA);\n   fragColor =mix(fragColor, vec4(col,1.0),sdVentanaB);\n    \n   fragColor =mix(fragColor, vec4(col,1.0),sdb1);\n   fragColor =mix(fragColor, vec4(col,1.0),sdLlantaIzq);\n   fragColor =mix(fragColor, vec4(col,1.0),sdLlantaDer);\n    \n    \n    fragColor =mix(fragColor, vec4(col,1.0),sdLineaA);\n    fragColor =mix(fragColor, vec4(col,1.0),sdLineaB);\n    \n    fragColor =mix(fragColor, vec4(col,1.0),sdLucesA);\n    fragColor =mix(fragColor, vec4(col,1.0),sdLucesB);\n    \n   \n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Referencia  BC: Straw Hat Pirates\n//\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\n\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circ(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//modificado por jorge2017a1\n//https://www.johndcook.com/blog/2016/03/10/creating-police-siren-sounds-with-frequency-modulation/\n#define pi 3.141516\n\nfloat  sirena(float t, float f_c, float f_m, float beta)\n{\n    //# t    = time\n    //# f_c  = carrier frequency\n    //# f_m  = modulation frequency\n    //# beta = modulation index\n    return sin(2.0*pi*f_c*t - beta*sin(2.0*f_m*pi*t));\n\n        \n \n}     \n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    float f_m;\n    \n    float f_c=1500.0;\n    \n    float t1=mod(time,7.0);\n    if (t1<3.5)\n    \t f_m=8.0;  \n    else\n         f_m=2.0;  \n        \n    \n    float beta=100.0;\n   \n    float tt =time;\n    float sir=  sirena(tt,  f_c,f_m,  beta);\n    return vec2(sir);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}