{
    "Shader": {
        "info": {
            "date": "1715929355",
            "description": "Showcasing bloom. Got a bit carried away with the scene. Nothing is rendered in any physical way, everything is hand-tuned to look somewhat accurate. The scene rendering is very sloppy, but the bloom is done properly.",
            "flags": 32,
            "hasliked": 0,
            "id": "XcySWd",
            "likes": 19,
            "name": "Bloom Warehouse",
            "published": 3,
            "tags": [
                "raytracing",
                "light",
                "bloom",
                "glow",
                "scene",
                "volumetrics",
                "ssr"
            ],
            "usePreview": 0,
            "username": "Real_NC",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// Sum bloom with original image, then apply tonemapping and sRGB correction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Begin with rendered image\n    fragColor.rgb = texture(iChannel0, uv).rgb;\n    \n    // Add bloom. The weird coordinate input is to compensate for rounding when mipmaps are made.\n    if(iMouse.x <= fragCoord.x)\n    fragColor.rgb += texture(iChannel1, uv*floor(iResolution.xy/pow(2.0,float(BLOOM_MIP)))/iResolution.xy).rgb*0.08;\n    \n    // tonemap luminance to intensity\n    fragColor.rgb = aces_approx(fragColor.rgb);\n    // encode intensity to sRGB, ready to be sent to a display.\n    fragColor.rgb = srgb_encode(fragColor.rgb); \n    \n}\n\n\n\n/// Use the mouse to compare with/without bloom!",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Image is drawn here in linear space\n\nvec4 noise3D(vec3 p)\n{\n    vec4 n = vec4(0);\n    for(float a = 1.0; a >= 0.05; a *= 0.7)\n    {\n        n += texture(iChannel0, p) - 0.5;\n        p += vec3(2.11, 3.51, 1.41);\n        p *= mat3(0.36,-0.80,0.48,0.48,0.6,0.64,-0.8,0,0.6);\n        p *= 1.3;\n    }\n    return n*0.5;\n}\n\nvec4 renderSample(vec3 ro, vec3 rd)\n{\n    float floorD = -ro.y/rd.y;\n    vec3 floorHit = ro + floorD*rd;\n    if (floorD <= 0.0) floorD = 1e9;\n    \n    float boxD = boxIntersection(ro - vec3(0.02,0.3,2.0), rd, vec3(0.01,0.02,0.4)).x;\n    if (boxD == -1.0) boxD = 1e9;\n    \n    float wallD = -ro.x/rd.x;\n    vec3 wallHit = ro + wallD*rd;\n    if (wallD <= 0.0) wallD = 1e9;\n    \n    else{\n        if(wallD < floorD)\n        {\n            if(wallHit.z*12.0 >= floor(wallHit.z*12.0)+0.6 && getSunlight(wallHit) < 0.01) // Hacky fake window. Don't tell anyone.\n            {\n                wallD = (-ro.x - 0.02)/rd.x;\n                wallD = min(wallD, (ceil(wallHit.z*12.0)/12.0 - ro.z)/rd.z);\n                wallHit = ro + wallD*rd;\n            }\n        }\n    }\n    if (min(wallD, floorD) == 1e9) return vec2(AMBIENT,20.0).xxxy;\n    \n    vec3 hit;\n    if(wallD <= min(floorD, boxD)) hit = wallHit;\n    else if(floorD <= boxD)\n    {\n        hit = floorHit;\n    }\n    else\n    {\n        hit = ro + rd*boxD;\n    }\n    \n    vec3 col;\n    if(hit == wallHit) col = (vec3(0.8)+0.05*noise3D(hit*2.4 + 1.0).rgb)*smoothstep(-0.06, 0.0, hit.x);\n    else if(hit == floorHit)\n    {\n        col = vec3(0.4)+0.1*noise3D(hit*2.4).x;\n    }\n    else\n    {\n        if(hit.y <= 0.29)\n        col = LAMP_COL*50.0;\n        else col = vec3(0.1);\n    }\n    \n    float ao1 = max(hit.y, hit.x);\n    col *= (ao1/(ao1+0.5))*0.8 + 0.2;\n    \n    col *= 0.05+getSceneLight(hit);\n    \n    col = mix(vec3(AMBIENT), col, smoothstep(3.0, 2.0, log(distance(hit,ro))));\n    \n    \n    \n    return vec4(col, distance(hit,ro)*(hit == floorHit ? 1.0 : -1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT_CAMERA\n\n    fragColor = renderSample(ro, rd);\n    \n    fragColor.rgb = max(fragColor.rgb*2.0, vec3(0)); // Clamp negative colors to 0, not needed unless I made a mistake\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Bloom radius describes the radius of the blur window\n// Bloom mip dictates which mipmap level blooming will be performed on\n\n#define BLOOM_RADIUS 0.26\n#define BLOOM_MIP 2\n\n#define VOLUMETRICS true\n\n// Approximate ACES tonemapper from https://64.github.io/tonemapping/#filmic-tone-mapping-operators\n// written by Krzysztof Narkowicz\nvec3 aces_approx(vec3 v)\n{\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// sRGB EOTF-1 from ttg\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n\n// sRGB EOTF\n/*\nvec3 srgb_decode (vec3 v) {\n    return mix(v/12.92,pow((v+.055)/1.055, vec3(2.4)),lessThan(vec3(.04045),v));\n}\n*/\n\n// SDFs from Inigo Quilez at https://iquilezles.org/articles/distfunctions/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Intersection functions from iq, modified because normal is not used here\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\n// Rotation Matrix Functions:\n// based off of https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\nmat3 translateTo( vec3 F )\n{\n    vec3 f = -normalize(F);\n    vec3 s = normalize(cross(f, vec3(0,1,0)));\n    vec3 u = normalize(cross(s, f));\n    \n    return mat3(\n    s.x, u.x, -f.x,\n    s.y, u.y, -f.y,\n    s.z, u.z, -f.z);\n}\n\n\nmat3 translateFrom( vec3 F )\n{\n    return inverse(translateTo(F));\n}\n\n\n\n\n\n\n\n\n\n\n//Poorly made functions to render the scene, ignore these!!!\n#define AMBIENT 0.02\n#define LAMP_COL vec3(1,0.2,0.2)\n\n#define INIT_CAMERA \\\n    vec2 fuv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\\\n    vec3 ro = vec3(1.0,0.45, 0);\\\n    vec3 rd = normalize(vec3(fuv, 1.4));\\\n    vec3 lookVector = vec3(-0.4-smoothstep(5.5, 7.0, abs(mod(iTime, 15.0)-7.5))*0.2-0.05,smoothstep(5.5, 7.0, abs(mod(iTime, 15.0)-7.5))*0.4-0.05,1);\\\n    lookVector.x += cos(iTime*0.2)*0.2;\\\n    lookVector.y += cos(iTime*0.24)*0.12;\\\n    ro -= lookVector*0.2;\\\n    rd *= translateTo(lookVector);\n    \nfloat getSunlight(vec3 p)\n{\n    vec2 c = vec2(p.z + p.x*0.2, p.y + p.x*0.8 - 1.6);\n    c.x = c.x - round(c.x*0.25)*4.0;\n    \n    float d = sdBox(c, vec2(0.2));\n    \n    return smoothstep(max(0.05*p.x, 0.01), -0.05*p.x, d);\n}\n\nfloat getLamplight(vec3 p)\n{\n    vec3 p2 = p - vec3(0.02,0.26,2.0);\n    p2.z = max(abs(p2.z) - 0.3, 0.0); \n    float d = length(p2);\n    float f = 0.3/((d + 0.3)*(d + 0.3));\n    \n    f *= smoothstep(0.05, -0.2*(d+0.1), p2.y + d*0.1);\n    \n    return f;\n}\n\nvec3 getSceneLight(vec3 p)\n{\n    return getSunlight(p)*8.0 + getLamplight(p)*LAMP_COL;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Screen-space reflections, for fun.\n\nvec4 noise3D(vec3 p)\n{\n    vec4 n = vec4(0);\n    for(float a = 1.0; a >= 0.05; a *= 0.7)\n    {\n        n += texture(iChannel2, p) - 0.5;\n        p += vec3(2.11, 3.51, 1.41);\n        p *= mat3(0.36,-0.80,0.48,0.48,0.6,0.64,-0.8,0,0.6);\n        p *= 1.3;\n    }\n    return n*0.5;\n}\n\nvec3 worldPointToFrustrum(vec3 p, vec3 dir, vec3 origin)\n{\n    p -= origin;\n    p *= translateFrom(dir);\n    \n    p.xy /= p.z/1.4;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT_CAMERA\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    // Do not do volumetrics like this. It works, but it's super inefficient with a fixed step size.\n    if(VOLUMETRICS){\n    for(float d = texelFetch(iChannel1, ivec2(fragCoord)%1024, 0).r*0.2; d <= min(20.0, abs(fragColor.w)); d += 0.2)\n    {\n        fragColor.rgb += getSceneLight(ro + rd*d)*0.0012;\n        if(ro.y + rd.y*d >= 2.0) break;\n    }}\n    \n    if (fragColor.w >= 0.0)\n    {\n        vec3 hit = ro + rd*fragColor.w;\n        \n        vec3 ref = reflect(rd, normalize(vec3(0,1,0) + noise3D(hit*4.0).rgb*0.03));\n        \n        float prevdif = 1e9;\n        float dif;\n        vec2 prevssr = uv;\n        vec3 prevhit;\n        \n        for (int i = 0; i <= 25; i++)\n        {\n            hit += ref*0.15*fragColor.w*(1.0+float(i)*0.1);\n            vec2 ssr = worldPointToFrustrum(hit, lookVector, ro).xy*iResolution.y/iResolution.xy + 0.5;\n            \n            dif = abs(texelFetch(iChannel0, ivec2(ssr*iResolution.xy), 0).w) - distance(hit, ro);\n            \n            if (dif <= 0.0) \n            {\n                ssr = (abs(prevdif)*ssr+abs(dif)*prevssr)/(abs(dif)+abs(prevdif));\n                float contribution = 0.026*smoothstep(25.0, 10.0, float(i))*smoothstep(0.0, 0.15, min(0.5-abs(ssr.y-0.5), 0.5-abs(ssr.x-0.5)));\n                fragColor.rgb += texture(iChannel0, ssr, 0.0).rgb*contribution;\n\n                \n                break;\n            }\n            \n            prevdif = dif;\n            prevssr = ssr;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Downsample buffer B to specified resolution\n// Apply horizontal Gaussian pass\n\n// Note, 2.6 is a random number which provides a good cutoff for the sampling window. Anything lower and sharp edges become visible.\n\nvec3 t (ivec2 p)\n{\n    return texelFetch(iChannel0, p, BLOOM_MIP).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    ivec2 w = textureSize(iChannel0, BLOOM_MIP);\n    if(fc.x >= w.x || fc.y >= w.y) discard;\n    \n    int rad = int(ceil(float(w.y)*BLOOM_RADIUS));\n    float co = 2.6/BLOOM_RADIUS/float(w.y);\n    \n    vec3 col = vec3(0);\n    float weight;\n    float wsum = 0.0;\n\n    for(int x = max(-rad, -fc.x); x <= min(rad, w.x - fc.x - 1); x++)\n    {\n        weight = exp(-float(x*x)*co*co);\n        col += weight*t(ivec2(fc.x + x, fc.y));\n        wsum += weight;\n    }\n    col /= wsum;\n    \n    fragColor.rgb = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Apply vertical Gaussian pass, slightly modified from before because we no longer have to downsample the image.\n\n\n\n\nvec3 t (ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    ivec2 w = textureSize(iChannel0, BLOOM_MIP);\n    if(fc.x >= w.x || fc.y >= w.y) discard;\n    \n    int rad = int(ceil(float(w.y)*BLOOM_RADIUS));\n    float co = 2.6/BLOOM_RADIUS/float(w.y);\n    \n    vec3 col = vec3(0);\n    float weight;\n    float wsum = 0.0;\n\n    for(int y = max(-rad, -fc.y); y <= min(rad, w.y - fc.y - 1); y++)\n    {\n        weight = exp(-float(y*y)*co*co);\n        col += weight*t(ivec2(fc.x, fc.y + y));\n        wsum += weight;\n    }\n    col /= wsum;\n    \n    fragColor.rgb = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}