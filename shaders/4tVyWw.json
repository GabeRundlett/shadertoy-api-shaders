{
    "Shader": {
        "info": {
            "date": "1536573849",
            "description": "Another 4D cube. For the 4D->3D projection, you can switch between orthographic and perspective projections, in line 12.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVyWw",
            "likes": 44,
            "name": "4D Cube",
            "published": 3,
            "tags": [
                "3d",
                "4d",
                "tesseract",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 2470
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Another 4D cube. For the 4D->3D projection, you can switch\n// between orthographic and perspective projections, in line 12.\n\n// See https://www.shadertoy.com/view/ftcyW4 for an example of\n// rendering faces rather than edges.\n\n// 0 = orthographics\n// 1 = perspective\n#define PROJECTION 1\n\n    \n#define AA 3   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n// capsule functions\n//-------------------------------------------------------------------\n\n// intersection\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// distance\nvec3 dCapsule( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb, float rad )\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n\t\n    float oad  = dot( oa, rd );\n    float dba  = dot( rd, ba );\n    float baba = dot( ba, ba );\n    float oaba = dot( oa, ba );\n\t\n    vec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n    th.x = max(   th.x, 0.0 );\n    th.y = clamp( th.y, 0.0, 1.0 );\n\t\n    vec3 p = pa + ba*th.y;\n    vec3 q = ro + rd*th.x;\n\t\n    return vec3( length( p-q )-rad, th );\n}\n\n// normal\nvec3 nCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (pa - h*ba)/r;\n}\n\n//-------------------------------------------------------------------\n\nvec3 parallelogramIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    \n    vec3 n = cross( a, b );\n    vec3 q = cross( rd, p );\n    \n    float i = 1.0/dot( rd, n );\n    \n    float u = dot( q, a )*i;\n    float v = dot( q, b )*i;\n    float t = dot( n, p )*i;\n\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec3(-1.0);\n    \n    return vec3( t, u, v );\n}\n\n//-------------------------------------------------------------------\n\nconst float rad = 0.06;\n\nfloat intersect( in vec3 ro, in vec3 rd, in vec3 v[16], out ivec2 oObject )\n{\n    float tmp;\n    \n    float res = 1e10;\n\n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = i ^ (1<<j); // change one bit/dimension\n        if( a<b )          // skip edge if already visited\n        {\n            tmp = iCapsule( ro, rd, v[a], v[b], rad );\n            if( tmp>0.0 && tmp<res )\n            {\n                res = tmp; \n                oObject = ivec2(a,b);\n            }\n        }\n    }\n\n    return (res<1e9)?res:-1.0;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 v[16], in ivec2 obj )\n{\n    return nCapsule( pos, v[obj.x], v[obj.y], rad );\n}\n\nfloat softShadowCapsule( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    const float k = 16.0;\n    vec3 t = dCapsule( ro, rd, a, b, r );\n    return clamp( k*t.x/max(t.z,0.0001), 0.0, 1.0 );\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float t = 1.0;\n    \n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = i ^ (1<<j); // change one bit/dimension\n        if( a<b )           // skip edge if already visited\n        {\n            t = min( t, softShadowCapsule( ro, rd, v[a], v[b], rad ) );\n        }\n    }    \n\n    return t;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float seed, in vec3 v[16] )\n{ \n    vec3 col = vec3(0.04) + 0.03*rd.y;\n\n    ivec2 obj;\n    float t = intersect(ro,rd,v,obj);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, v, obj );\n            \n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = vec3(0.4);\n\n        // lighting        \n        float occ = 0.7+0.3*nor.y;\n        vec3  lig = normalize( vec3(0.4, 0.8, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        float sha = (dif>0.001) ? calcShadow( pos+0.02*nor, lig, v ) : 0.0;\n\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0 ),16.0)*dif*sha*\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 1.5*dif*vec3(1.10,0.80,0.70)*sha;\n        lin += 0.5*amb*vec3(0.70,0.80,1.00)*occ;\n        lin += 1.0*fre*vec3(1.20,1.10,1.00)*occ*(0.1+0.9*sha*dif);\n        col = col*lin;\n        col += 15.00*spe*vec3(1.00,0.90,0.70);\n    }\n   \n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat2 rot( float a )\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 transform( in vec4 p )\n{\n    #if PROJECTION==0\n    p.yz = rot( iTime*0.13+1.0)*p.yz;\n    #endif\n    p.zw = rot(-iTime*1.0+0.0)*p.zw;\n    \n    #if PROJECTION==0\n    return p.xyz;               // orthogonal projection\n    #else\n    return 3.0*p.xyz/(3.0+p.w); // perspective projection\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // rotate 4D cube\n    vec3 v[] = vec3[]( transform(vec4(-1,-1,-1,-1)),\n                       transform(vec4(-1,-1,-1, 1)),\n                       transform(vec4(-1,-1, 1,-1)),\n                       transform(vec4(-1,-1, 1, 1)),\n                       transform(vec4(-1, 1,-1,-1)),\n                       transform(vec4(-1, 1,-1, 1)),\n                       transform(vec4(-1, 1, 1,-1)),\n                       transform(vec4(-1, 1, 1, 1)),\n                       transform(vec4( 1,-1,-1,-1)),\n                       transform(vec4( 1,-1,-1, 1)),\n                       transform(vec4( 1,-1, 1,-1)),\n                       transform(vec4( 1,-1, 1, 1)),\n                       transform(vec4( 1, 1,-1,-1)),\n                       transform(vec4( 1, 1,-1, 1)),\n                       transform(vec4( 1, 1, 1,-1)),\n                       transform(vec4( 1, 1, 1, 1)));\n    \n    // camera (static)\n    vec3 ro = vec3( 3.8, 2.0, 3.3 );\n    vec3 ta = vec3( 0.0,-0.3, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime + 17.1*float(m) + 37.4*float(n);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, seed, v );\n\n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // cheap dither to remove banding from background\n    tot += 0.5*sin(fragCoord.x)*sin(fragCoord.y)/256.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}