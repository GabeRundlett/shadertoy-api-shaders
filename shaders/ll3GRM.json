{
    "Shader": {
        "info": {
            "date": "1472884796",
            "description": "Just playing around with one of the many interesting snippets that Fabrice Neyret has magically managed to conjure up. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "ll3GRM",
            "likes": 170,
            "name": "Rounded Voronoi Borders",
            "published": 3,
            "tags": [
                "voronoi",
                "bump",
                "cell",
                "border",
                "trabeculae"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 7231
        },
        "renderpass": [
            {
                "code": "/*\n\tRounded Voronoi Borders\n\t-----------------------\n\n\tFabrice came up with an interesting formula to produce more evenly distributed Voronoi values. \n\tI'm sure there are more interesting ways to use it, but I like the fact that it facilitates \n\tthe creation of more rounded looking borders. I'm sure there are more sophisticated ways to \n\tproduce more accurate borders, but Fabrice's version is simple and elegant.\n\n\tThe process is explained below. The link to the original is below also.\n\n\tI didn't want to cloud the example with too much window dressing, so just for fun, I tried \n\tto pretty it up by using as little code as possible.\n\n\t// 2D version\n\t2D trabeculum - FabriceNeyret2\n\thttps://www.shadertoy.com/view/4dKSDV\n\n\t// 3D version\n\thypertexture - trabeculum - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltj3Dc\n\n\t// Straight borders - accurate geometric solution.\n\tVoronoi - distances - iq\n\thttps://www.shadertoy.com/view/ldl3W8\n\n*/\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*.75 + .25; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*.35 + .65; \n    \n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if-statements,\"\n// but the clever bit at the end came from Fabrice.\n//\n// Using a bit of science and art, Fabrice came up with the following formula to produce a more \n// rounded, evenly distributed, cellular value:\n\n// d1, d2, d3 - First, second and third closest points (nodes).\n// val = 1./(1./(d2 - d1) + 1./(d3 - d1));\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc.\n    \n    float r = 0.;\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\tr = dot(o, o);\n            \n            // 1st, 2nd and 3rd nearest squared distances.\n            d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n            d.y = max(d.x, min(d.y, r)); // 2nd.\n            d.x = min(d.x, r); // Closest.\n                       \n\t\t}\n\t}\n    \n\td = sqrt(d); // Squared distance to distance.\n    \n    // Fabrice's formula.\n    return min(2./(1./max(d.y - d.x, .001) + 1./max(d.z - d.x, .001)), 1.);\n    // Dr2's variation - See \"Voronoi Of The Week\": https://www.shadertoy.com/view/lsjBz1\n    //return min(smin(d.z, d.y, .2) - d.x, 1.);\n    \n}\n\nvec2 hMap(vec2 uv){\n    \n    // Plain Voronoi value. We're saving it and returning it to use when coloring.\n    // It's a little less tidy, but saves the need for recalculation later.\n    float h = Voronoi(uv*6.);\n    \n    // Adding some bordering and returning the result as the height map value.\n    float c = smoothstep(0., fwidth(h)*2., h - .09)*h;\n    c += (1.-smoothstep(0., fwidth(h)*3., h - .22))*c*.5; \n    \n    // Returning the rounded border Voronoi, and the straight Voronoi values.\n    return vec2(c, h);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Moving screen coordinates.\n\tvec2 uv = fragCoord/iResolution.y + vec2(-.1, .025)*iTime;\n    \n    // Obtain the height map (rounded Voronoi border) value, then another nearby. \n    vec2 c = hMap(uv);\n    vec2 c2 = hMap(uv + .004);\n    \n    // Take a factored difference of the values above to obtain a very, very basic gradient value.\n    // Ie. - a measurement of the bumpiness, or bump value.\n    float b = max(c2.x - c.x, 0.)*16.;\n    \n    // Use the height map value to produce some color. It's all made up on the spot, so don't pay it\n    // too much attention.\n    //\n    vec3 col = vec3(1, .05, .25)*c.x; // Red base.\n    float sv = Voronoi(uv*16. + c.y)*.66 + (1.-Voronoi(uv*48. + c.y*2.))*.34; // Finer overlay pattern.\n    col = col*.85 + vec3(1, .7, .5)*sv*sqrt(sv)*.3; // Mix in a little of the overlay.\n    col += (1. - col)*(1.-smoothstep(0., fwidth(c.y)*3., c.y - .22))*c.x; // Highlighting the border.\n    col *= col; // Ramping up the contrast, simply because the deeper color seems to look better.\n    \n    // Taking a pattern sample a little off to the right, ramping it up, then combining a bit of it\n    // with the color above. The result is the flecks of yellowy orange that you see. There's no physics\n    // behind it, but the offset tricks your eyes into believing something's happening. :)\n    sv = col.x*Voronoi(uv*6. + .5);\n    col += vec3(.7, 1, .3)*pow(sv, 4.)*8.;\n    \n    // Apply the bump - or a powered variation of it - to the color for a bit of highlighting.\n    col += vec3(.5, .7, 1)*(b*b*.5 + b*b*b*b*.5);\n\t \n    \n    // Basic gamma correction\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}