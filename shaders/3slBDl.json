{
    "Shader": {
        "info": {
            "date": "1589286687",
            "description": "an exact SDF that generalizes the circle and the square. it can also give the closest point on the surface!",
            "flags": 0,
            "hasliked": 0,
            "id": "3slBDl",
            "likes": 9,
            "name": "Square + Circle SDF",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 647
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec2 nonzero_sign(vec2 p) {\n    return max(sign(p),vec2(0))*2.-1.;\n}\n\nmat2 sort(vec2 p) {\n    if (p.x > p.y) return mat2(0,1,1,0);\n    return mat2(1);\n}\n\nconst float PI = acos(-1.);\nvec3 rounded_square(vec2 p, float radius, float sharpness, float offset) {\n    //first we abs and sort the vector so we can work with the symmetries of the square\n    vec2 sgn = nonzero_sign(p);\n    p = abs(p);\n    mat2 perm = sort(p);\n    p *= perm;\n    p.y += sharpness;\n\n    //get closest point on defining sphere for axis\n    float rad = sharpness + radius;\n    vec2 closest = normalize(p)*rad;\n\n    //normalize the closest point so it lies within the axis\n    if (closest.x > closest.y-sharpness) {\n        float k = sharpness;\n        float y = closest.y;\n        closest.y = (k + sqrt(2.*rad*rad-k*k))/2.;\n        closest.x = closest.y - k;\n    }\n\n    //calculate the distance\n    float side = sign(length(p)-rad);\n    float dist = length(p-closest)*side;\n\n    //map the closest point back to global coordinates\n    closest += normalize(p-closest)*offset*side;\n    if (side == 0.) closest = p;\n    vec2 closest_global = (closest-vec2(0,sharpness))*transpose(perm)*sgn;\n    return vec3(dist-offset, closest_global);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.; mouse*=3.;\n    \n    float radius = sin(iTime)*0.25+0.75;\n    float sharpness = pow(asin(sin(iTime*2.5))/PI+1.,8.);\n    float offset = sin(iTime*0.65)*0.25+0.25;\n    \n    float dist = rounded_square(uv, radius, sharpness, offset).x;\n    fragColor = vec4(shadeDistance(dist), 1.);\n\n    float mousedist = rounded_square(mouse, radius, sharpness, offset).x;\n    vec2 mousepoint = rounded_square(mouse, radius, sharpness, offset).yz;\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        fragColor *= antialias(distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n        fragColor = mix(vec4(1,0,0,0), fragColor, antialias(distance(mousepoint, uv) - 0.03));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}