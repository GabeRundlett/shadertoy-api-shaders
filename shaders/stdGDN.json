{
    "Shader": {
        "info": {
            "date": "1636162598",
            "description": "Playing with inverse kinematics.",
            "flags": 0,
            "hasliked": 0,
            "id": "stdGDN",
            "likes": 18,
            "name": "Wowie!",
            "published": 3,
            "tags": [
                "2d",
                "ik",
                "fabrik"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "// Wowie! by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define saturate(x) clamp((x), 0., 1.)\n\nstruct seg\n{\n    vec2 p0, p1;\n    float len, r, c;\n};\n\nfloat sm(float a, float b, float q)\n{\n    float d = saturate((b - a) / q + .5);\n    float m = -.125 * q * d * (1. - d);\n    return mix(a, b, d) - m;\n}\n\nfloat line(vec2 p, float r, vec2 a, vec2 b)\n{\n    vec2 a2b = b - a,\n         a2p = p - a;\n    return length(a2p\n                - saturate(dot(a2p, a2b) / dot(a2b, a2b))\n                * a2b) - r;\n}\n\nvoid solveIK(vec2 root, vec2 target, inout seg segs[6])\n{\n    #define P0 segs[i].p0\n    #define P1 segs[i].p1\n    \n    for(int i = 5; i > -1; --i)\n    {\n        P1 = target;\n        P0 = P1 + normalize(P0 - P1) * segs[i].len;\n        target = P0;\n    }\n    \n    vec2 dir = normalize(segs[0].p1 - segs[0].p0);\n    \n    for(int i = 0; i < 6; ++i)\n    {\n        P0 = root;\n        \n        vec2 newDir = normalize(P1 - P0);\n        float t = dot(dir, newDir) * -.5 + .5;\n        t *= segs[i].c;\n        \n        newDir = normalize(mix(newDir, dir, t));\n        \n        P1 = P0 + newDir * segs[i].len;\n        \n        dir = newDir;\n        root = P1;\n    }\n    #undef P0\n    #undef P1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    seg segs[6] = seg[]\n    (\n        seg(vec2(-.1),  vec2(.01), .1, .025,  1. ),\n        seg(vec2(.02), vec2(-.01), .1, .02,   1. ),\n        seg(vec2(-.02), vec2(.03), .1, .015,  .75),\n        seg(vec2(.04), vec2(.03), .1, .0125, .5 ),\n        seg(vec2(.04), vec2(-.05), .1, .01,   .25),\n        seg(vec2(-.06), vec2(.05), .1, .0075, 0. )\n    );\n\n    vec2 target = vec2(sin(iTime), sin(iTime * 1.333)) * .4;\n    vec2 root = vec2(-.5);\n    \n    float d = 1000.;\n\n    solveIK(root, target, segs);\n    solveIK(root, target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    vec2 flip = vec2(-1, 1);\n\n    solveIK(root, target * flip, segs);\n    solveIK(root, target * flip, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(uv * flip, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    solveIK(root * flip, -target, segs);\n    solveIK(root * flip, -target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(-uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    solveIK(root, -target, segs);\n    solveIK(root, -target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(-uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    vec3 col = vec3(.8,.55,.05);\n    \n    \n    float blush = smoothstep(.2, 0., length(vec2(.4, 0) - abs(uv + vec2(0,.1))));\n    col = mix(col, vec3(1,.2,.2), blush * .3);\n    \n    \n    float eyeball = length(abs(uv) - vec2(.2, 0)) - .1;\n    \n    vec2 posPup = vec2(-.2, 0) + normalize(target - vec2(-.2,0)) * .07;\n    float pupL = length(uv - posPup) - .01;\n    \n    posPup = vec2(.2, 0) + normalize(target - vec2(.2,0)) * .07;\n    float pupR = length(uv - posPup) - .01;\n    \n    float outline = abs(eyeball) - .002;\n    outline = smoothstep(fwidth(outline), 0., outline);\n    eyeball = smoothstep(fwidth(eyeball), 0., eyeball);\n    pupL = smoothstep(fwidth(pupL), 0., pupL);\n    pupR = smoothstep(fwidth(pupR), 0., pupR);\n    \n    col = mix(col, vec3(.9), eyeball);\n    col *= 1. - outline;\n    col *= 1. - max(pupL, pupR);\n    \n    \n    float mouth = line(abs(uv + vec2(0.,.25)), .07, vec2(0), vec2(.2, 0) * (length(target) * 2.));\n    mouth = smoothstep(0.,fwidth(mouth), mouth);\n    col *= mouth;\n    \n    \n    float ball = length(uv - target) - .04;\n    outline = abs(ball) - .002;\n    outline = min(outline, abs(min(ball, d)) - .001);\n    \n    d = smoothstep(fwidth(d), 0., d);\n    ball = smoothstep(fwidth(ball), 0., ball);\n    outline = smoothstep(0., fwidth(outline), outline);\n    col = mix(col, vec3(.6,.45,0.), d);\n    col = mix(col, vec3(1,.4,.8), ball) * outline;\n    \n    col *= smoothstep(1., .3, length(fragCoord / iResolution.xy - .5));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}