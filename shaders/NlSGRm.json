{
    "Shader": {
        "info": {
            "date": "1623515428",
            "description": "Another simple example with Ray Marching's shading function to build a square floor.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlSGRm",
            "likes": 1,
            "name": "Ray Marching - 003",
            "published": 3,
            "tags": [
                "raymarching",
                "environment",
                "squares"
            ],
            "usePreview": 0,
            "username": "catafest",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "//constants \nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n/*\nhttps://en.wikipedia.org/wiki/Ray_tracing_(graphics)\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\np - point \nsd -  signed distance value\ncol - color\nclosest_object - closest object \n*/\n\n// surface by signed distance and color for \nstruct Surface {\n    float sd; \n    vec3 col;\n};\n// floor by point and color \nSurface Floor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n// define a scene function by point \nSurface Scene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.1*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface closest_object = Floor(p, floorColor);\n  return closest_object;\n}\n// the main Ray Marching funtion\n/*\n*/\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface closest_object; \n  // steps for ray marching\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    closest_object = Scene(p);\n    depth += closest_object.sd;\n    if (closest_object.sd < PRECISION || depth > end) break;\n  }\n  \n  closest_object.sd = depth;\n  \n  return closest_object;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 background_Color = vec3(0.1, 0.7, 0.9);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface the_floor = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (the_floor.sd > MAX_DIST) {\n    col = background_Color; // then the ray didn't hit anything and fill with background_Color\n  } else \n  {\n    // show closest_object\n    float dif = clamp(0.7, 0.6, 1.); // diffuse reflection\n    col = dif * the_floor.col + background_Color * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}