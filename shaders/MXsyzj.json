{
    "Shader": {
        "info": {
            "date": "1726446633",
            "description": "Failing experiment.\nOnly halfway done and it is already running too slow",
            "flags": 48,
            "hasliked": 0,
            "id": "MXsyzj",
            "likes": 11,
            "name": "SDF_Skating_at_night",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 1,
            "username": "kosalos",
            "viewed": 100
        },
        "renderpass": [
            {
                "code": "// -------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundCone( vec3 p, vec3 a, vec3 b, float r1, float r2 ) {\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// -------------------------------------------------------\n\n#define hitTest(c,d) if(d<dist) { dist=d; colorCode=c; } \n\nfloat drawSkater(vec3 pt) {\n    dist = 1e24;\n    colorCode = COLOR_MISS;\n  \n    float dd = length(pt-hips);\n    if(dd > 35.) return dd-20.;\n    \n    // body, chest --------------\n    hitTest(COLOR_DRESS,sdRoundCone(pt,hips,bodyTop,SBODY.y,SBODY.z));\n    hitTest(COLOR_DRESS,sdRoundCone(pt,bodyTop,chest1,SCHEST.y,SCHEST.z));\n    hitTest(COLOR_DRESS,sdRoundCone(pt,bodyTop,chest2,SCHEST.y,SCHEST.z));\n\n    // head --------------\n    const float neckWidth = SHEAD.y * 0.35;\n    hitTest(COLOR_FLESH,sdRoundCone(pt,bodyTop,neck,neckWidth,neckWidth));\n    hitTest(COLOR_FLESH,sdSphere(pt-head,SHEAD.y));\n    \n    // hair --------------\n    hitTest(COLOR_HAIR,sdRoundCone(pt,hairBot,hair,SHAIR.y,SHAIR.z));\n    hitTest(COLOR_HAIR,sdRoundCone(pt,tail1a,tail1b,0.9,1.3));\n    hitTest(COLOR_HAIR,sdRoundCone(pt,tail2a,tail2b,0.9,1.3));\n\n    // skirt -------------\n    mat3 rr = mat3(skirt1,skirt2,skirt3);\n    const vec2 skt = vec2(2.4,0.3);\n    const vec2 skb = vec2(7.,0.5);\n    vec3 skirtTop = hips - vec3(0,1,0) * rr;\n    rr = MAT3zy(sin(iTime) * 0.3) * rr;   // skirt bottom swish\n    vec3 skirtBot = hips - vec3(0,7,0) * rr;\n    rr = inverse(rr);\n    for(float i=0.;i<1.;i+= 0.15) {\n        vec2 sk = skt + (skb-skt)*i;\n        vec3 skirt = skirtTop + (skirtBot-skirtTop)*i;\n        hitTest(COLOR_DRESS,sdTorus((pt-skirt) * rr,sk));\n    }\n\n    // arms\n    const float tw = SHAND.z * 0.5;\n    hitTest(COLOR_DRESS,sdRoundCone(pt,bodyTop,lshoulder,SSHOULDER.y,SSHOULDER.z));\n    hitTest(COLOR_DRESS,sdRoundCone(pt,lshoulder,lelbow,SELBOW.y,SELBOW.z));\n    hitTest(COLOR_FLESH,sdRoundCone(pt,lelbow,lwrist,SWRIST.y,SWRIST.z));\n    hitTest(COLOR_HAND, sdRoundCone(pt,lwrist,lhand,SHAND.y,SHAND.y));\n    hitTest(COLOR_HAND, sdRoundCone(pt,lwrist,lthumb,tw,tw));\n    \n    hitTest(COLOR_DRESS,sdRoundCone(pt,bodyTop,rshoulder,SSHOULDER.y,SSHOULDER.z));\n    hitTest(COLOR_DRESS,sdRoundCone(pt,rshoulder,relbow,SELBOW.y,SELBOW.z));\n    hitTest(COLOR_FLESH,sdRoundCone(pt,relbow,rwrist,SWRIST.y,SWRIST.z));\n    hitTest(COLOR_HAND, sdRoundCone(pt,rwrist,rhand,SHAND.y,SHAND.y));\n    hitTest(COLOR_HAND, sdRoundCone(pt,rwrist,rthumb,tw,tw)); \n    \n    // staff\n    rr = mat3(staff1,staff2,staff3);\n    hitTest(COLOR_SKATE,sdBox((pt-staff) * inverse(rr), vec3(0.1,0.15,6.)));\n    hitTest(COLOR_BULB,sdSphere(pt-bulb,0.5));\n\n    // legs\n    hitTest(COLOR_DRESS,sdRoundCone(pt,lthigh,lknee,STHIGH.y,STHIGH.z));\n    hitTest(COLOR_FLESH,sdRoundCone(pt,lknee,lankle,SCALF.y,SCALF.z));\n    hitTest(COLOR_HAND,sdRoundCone(pt,lfoot1,lfoot2,SFOOT.y,SFOOT.z));\n    rr = mat3(lskate1,lskate2,lskate3);\n    vec3 skate = lfoot1 + vec3(0.,-1.,-1.7) * rr;\n    hitTest(COLOR_SKATE,sdBox((pt-skate) * inverse(rr), vec3(0.1,0.15,2.7)));\n\n    hitTest(COLOR_DRESS,sdRoundCone(pt,rthigh,rknee,STHIGH.y,STHIGH.z));\n    hitTest(COLOR_FLESH,sdRoundCone(pt,rknee,rankle,SCALF.y,SCALF.z));\n    hitTest(COLOR_HAND,sdRoundCone(pt,rfoot1,rfoot2,SFOOT.y,SFOOT.z));\n    rr = mat3(rskate1,rskate2,rskate3);\n    skate = rfoot1 + vec3(0.,-1.,-1.7) * rr;\n    hitTest(COLOR_SKATE,sdBox((pt-skate) * inverse(rr), vec3(0.1,0.15,2.7)));\n    \n    // streamer\n    for(int i=0;i<sCount;++i) \n        hitTest(COLOR_BULB,sdSphere(pt - q[sBase+i].xyz,0.1));\n\n    return dist;\n}\n\n// -------------------------------------------------------\n\nvec2 Dist(vec3 pt) {   // returns: closest distance, colorCode\n    vec2 hit = vec2(1000,COLOR_MISS);\n    float tmp = drawSkater(pt);\n\n    if(tmp < hit.x) {\n        hit.x = tmp;\n        hit.y = colorCode;\n    }\n\n    return hit;\n}\n\nvec3 Normal(vec3 pt) {\n    const float EPSILON = .1;\n    vec3 norm = drawSkater(pt) - vec3(\n        drawSkater(pt-vec3(EPSILON, 0., 0.)), \n        drawSkater(pt-vec3( 0.,EPSILON, 0.)), \n        drawSkater(pt-vec3( 0., 0.,EPSILON)));\n    return normalize( norm );\n}\n\nvec4 March(vec3 beg,vec3 dir) { \n    float mdist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 120; ++stps ) {\n        pos = beg + dir * mdist;\n        float obj = drawSkater( pos );\n        mdist += obj;\n\n        if(mdist > 300.) return vec4( pos,COLOR_MISS);\n        if(pos.z < -300.) return vec4( pos,COLOR_MISS);        \n        if(obj < 0.01) return vec4(pos, colorCode);  // hit object.  distance, colorCode\n    }\n    \n    return vec4( pos,COLOR_MISS);\n}\n\n// --------------------------------------------------------------\n\nvec3 colorList[] = vec3[](\n    vec3(0.), // miss\n    vec3(0.9,0.5,0.4), // flesh\n    vec3(0.,0.3,0.9),  // dress\n    vec3(0.7,0.4,0.1), // hand\n    vec3(0.8,0.3,0.1), // hair\n    vec3(0.8),         // skate\n    vec3(1.,1.,0.)     // bulb\n);\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv *= .5; // field of view\n    \n#ifdef MANUAL_CONTROL    \n    vec3 cam = vec3(0.,22., -35.);\n#else\n    vec3 cam = vec3(0.,5., -90.);\n#endif\n\n    vec3 camdir = normalize(vec3(uv, 1.));\n \n    getSettings(iChannel0);    \n    O = vec4(0.);\n    \n    vec4 hit = March(cam,camdir); // position, color code\n\n    // ice rink -----------\n    vec2 oval = vec2(uv.x * 0.4,uv.y * 0.8);\n    if(length(oval) < 0.3) \n        O = vec4(0.1,0.2,0.4,0.);\n   \n    if(hit.w != COLOR_MISS) {\n        O.xyz = colorList[int(hit.w)];\n\n#ifndef MANUAL_CONTROL \n        vec3 dir = normalize(bulb - hit.xyz );\n        vec3 norm = Normal(hit.xyz);\n        float difu = 0.5 + dot(norm, dir);\n        \n        if(hit.w != COLOR_BULB)\n          O *= difu;\n#endif\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define MANUAL_CONTROL\n\n// storage for joint angles\n#define LELBOW    0  // angles managed by keyframes\n#define LWRIST    1   \n#define LHAND     2\n#define RELBOW    3  \n#define RWRIST    4  \n#define RHAND     5  \n#define LTHIGH    6\n#define LCALF     7\n#define LFOOT     8\n#define RTHIGH    9\n#define RCALF     10\n#define RFOOT     11\n\n#define POSITION  12  // angles handled manually\n#define BODY      13 \n#define NECK      14  \n#define HEAD      15   \n#define LSHOULDER 16  \n#define RSHOULDER 17   \n#define HAIR1     18\n#define HAIR2     19\n#define HAIR3     20\n#define SKIRT     21\n// positioned and rotated body parts ready for drawing\n#define hips     q[22].xyz \n#define bodyTop  q[23].xyz\n#define skirt1   q[24].xyz // mat3 for skirt Torus\n#define skirt2   q[25].xyz\n#define skirt3   q[26].xyz\n#define neck     q[27].xyz\n#define head     q[28].xyz\n#define hairBot  q[29].xyz\n#define hair     q[30].xyz\n#define tail1a   q[31].xyz\n#define tail1b   q[32].xyz\n#define tail2a   q[33].xyz\n#define tail2b   q[34].xyz\n#define chest1   q[35].xyz\n#define chest2   q[36].xyz\n#define lshoulder q[37].xyz\n#define lelbow   q[38].xyz\n#define lwrist   q[39].xyz\n#define lhand    q[40].xyz\n#define lthumb   q[41].xyz\n#define rshoulder q[42].xyz\n#define relbow   q[43].xyz\n#define rwrist   q[44].xyz\n#define rhand    q[45].xyz\n#define rthumb   q[46].xyz\n#define staff1   q[47].xyz // mat3\n#define staff2   q[48].xyz\n#define staff3   q[49].xyz\n#define staff    q[50].xyz\n#define lthigh   q[51].xyz\n#define lknee    q[52].xyz\n#define lankle   q[53].xyz\n#define lfoot1   q[54].xyz\n#define lfoot2   q[55].xyz\n#define lskate1  q[56].xyz // mat3\n#define lskate2  q[57].xyz\n#define lskate3  q[58].xyz\n#define rthigh   q[59].xyz\n#define rknee    q[60].xyz\n#define rankle   q[61].xyz\n#define rfoot1   q[62].xyz\n#define rfoot2   q[63].xyz\n#define rskate1  q[64].xyz // mat3\n#define rskate2  q[65].xyz\n#define rskate3  q[66].xyz\n#define bulb     q[67].xyz\n#define sBase      68\n#define sCount     32\n#define QSIZE     101\n\nconst float\n    COLOR_MISS  = 0.,\n    COLOR_FLESH = 1.,\n    COLOR_DRESS = 2.,\n    COLOR_HAND  = 3.,\n    COLOR_HAIR  = 4.,\n    COLOR_SKATE = 5.,\n    COLOR_BULB  = 6.,\n    SHIPS = 25.;   // Y distance from origin\n    \nconst vec3 \n    SBODY = vec3(5.5,1.5,2.),  // capsule length, radius1, radius2\n    SHEAD = vec3(3.8,2.3,0.),\n    SCHEST = vec3(1.5,1.5,1.2),\n    SHAIR = vec3(3.,1.5,2.4),\n    SSHOULDER = vec3(3.,1.7,1.5),\n    SELBOW = vec3(5.,1.5,1.),\n    SWRIST = vec3(5.,0.7,0.4),\n    SHAND = vec3(2.,0.5,0.4),\n    STHIGH = vec3(5.5,1.,1.),\n    SCALF = vec3(6.5,1.,0.5),\n    SFOOT = vec3(1.,0.8,0.5);\n\nvec4[QSIZE] q;\n\nconst mat3 identityMatrix = mat3(1.);\n\nfloat dist;\nfloat colorCode;\nmat3 rotations = identityMatrix;\n\n// -------------------------------------------------------\n\nmat3 MAT3xy(float ANG) { float s = sin(ANG),c=cos(ANG); return mat3( c,s,0, -s,c,0, 0,0,1 ); }\nmat3 MAT3xz(float ANG) { float s = sin(ANG),c=cos(ANG); return mat3( c,0,s,  0,1,0, -s,0,c); }\nmat3 MAT3zy(float ANG) { float s = sin(ANG),c=cos(ANG); return mat3( 1,0,0,  0,c,s, 0,-s,c); }\n\nvoid updateRotations(vec4 angles) {\n    if(angles.x != 0.) rotations = MAT3xy(angles.x) * rotations;\n    if(angles.y != 0.) rotations = MAT3xz(angles.y) * rotations;\n    if(angles.z != 0.) rotations = MAT3zy(angles.z) * rotations;\n}\n\n// ----------------------------------------------------------\n\nvoid getSettings(sampler2D channel) { \n    ivec2 addr = ivec2(0,0);\n    \n    for(int i=0;i<QSIZE;++i) {\n        q[i] = texelFetch(channel,addr,0);\n        ++addr.x;\n    }\n}\n\nvoid saveSettings(inout vec4 O, in vec2 U) {\n    ivec2 I = ivec2(U);\n\n    if(I.y == 0 && I.x < QSIZE) \n        O = q[I.x];\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n    return (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n   \nbool getKeyClick(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float PI = acos(-1.);\n\nfloat oldRandom = -1.;\n\nfloat random(vec2 c) { // 0...1\n    oldRandom += sin( dot( vec2(1.317 - c.x,19.753 + c.y), c) *413.7972); \n    return fract(oldRandom);\n} \n\n// -----------------------------------\n// keyframe data\n// x = keyframe angle 1\n// y = keyframe angle 2\n// z = interpolation ratio 0...1\n// w = interpolation speed\n\nconst vec2 angleRange[] = vec2[](\n    vec2(-1.5,1.5), // LELBOW \n    vec2(0.,-2.),  // LWRIST\n    vec2(-1.,1.), // LHAND   \n    vec2(-1.5,1.5), // RELBOW  \n    vec2(0.,-2.),  // RWRIST\n    vec2(-1.,1.), // RHAND\n    vec2(-.3,.3), // LTHIGH\n    vec2( 1.,0.), // LCALF\n    vec2(-0.4,0.4), // LFOOT\n    vec2(-.3,.3), // RTHIGH\n    vec2( 1.,0.), // RCALF\n    vec2(-0.4,0.4)  // RFOOT\n);\n\nvoid keyFrameInit(int index) {    // coldstart\n  q[index] = vec4(0.,0.,0.,0.01);\n}\n\nvoid keyFrameUpdate(int index) {  // interpolate between keyframes\n    q[index].z += q[index].w;\n    if(q[index].z >= 1.0) {       // reached keyframe 2\n        q[index].x = q[index].y;  // keyframe 2 = the new 'old' keyframe\n        \n        // new keyframe 2\n        vec2 angles = angleRange[index];        \n        q[index].y = angles.x + (angles.y-angles.x) * random(vec2(iTime,q[index].x));\n        \n        q[index].z = 0.;  // reset interpolation amount\n        q[index].w = 0.01 + random(vec2(iTime * 2.,q[index].y)) * 0.025; // speed update\n    }\n}\n\nfloat keyFrameAngle(int index) {\n    return mix(q[index].x,q[index].y,q[index].z);\n}\n\n// -----------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    ivec2 I = ivec2(U);\n    if(I.x >= QSIZE || I.y > 1) return;\n    getSettings(iChannel0);\n\n    if(iFrame == 0) {\n        q[BODY] = vec4(0.);\n        for(int i=LELBOW;i<=RFOOT;++i)\n            keyFrameInit(i);\n    }\n    \n    for(int i=LELBOW;i<=RFOOT;++i)\n        keyFrameUpdate(i);\n    \n    // -------------------------------------\n#ifdef MANUAL_CONTROL       // (at top of Common tab)\n    if(iMouse.z > 0.) {     // mouse down or dragged\n        q[BODY].z += (iResolution.y * 0.5 - iMouse.y) * 0.001;\n        q[BODY].y += (iResolution.x * 0.5 - iMouse.x) * 0.001;\n    }\n\n    const float rr = 0.1;\n    if(getKeyState(81,iChannel3)) q[BODY].x -= rr; // Q\n    if(getKeyState(87,iChannel3)) q[BODY].x += rr; // W\n    if(getKeyState(65,iChannel3)) q[BODY].y -= rr; // A\n    if(getKeyState(83,iChannel3)) q[BODY].y += rr; // S\n    if(getKeyState(90,iChannel3)) q[BODY].z -= rr; // Z\n    if(getKeyState(88,iChannel3)) q[BODY].z += rr; // X\n#else\n    float angle = iTime * 0.3;  // skating in a circle\n    q[POSITION].x = cos(angle) * 70.;        \n    q[POSITION].z = 60. + sin(angle) * 70.;\n    q[POSITION].y = 15. + sin(angle) * 40.;\n    q[BODY].y = PI-angle;\n#endif\n\n    // prepare body parts for display\n    // -------------------------------------\n    rotations = identityMatrix;\n    updateRotations(q[BODY]);    \n\n    // body, skirt, neck, head, chest\n    hips = q[POSITION].xyz + vec3(0,SHIPS,0);    \n    bodyTop = hips + vec3(0.,SBODY.x,0.) * rotations;\n    neck = bodyTop + vec3(0.,SHEAD.x * .8,0.) * rotations;\n    lshoulder = bodyTop + vec3( SSHOULDER.x,0.,0.) * rotations;\n    rshoulder = bodyTop + vec3(-SSHOULDER.x,0.,0.) * rotations;\n    chest1 = hips - vec3( SCHEST.x,-3.,2.) * rotations;\n    chest2 = hips - vec3(-SCHEST.x,-3.,2.) * rotations;\n    skirt1 = rotations[0].xyz;\n    skirt2 = rotations[1].xyz;\n    skirt3 = rotations[2].xyz;\n    \n    // hair, pigtails\n    mat3 save = rotations;\n    updateRotations(q[HEAD]);    \n    head = neck + vec3(0.,SHEAD.x * 0.45,0.) * rotations;\n    hairBot = head + vec3(0., -.35, 0.2) * rotations;\n    hair = hairBot + vec3(0.,1.,0.5) * rotations;\n    tail1a = hair + vec3(0.5,1.,0.5) * rotations;\n    tail1b = tail1a + vec3(1. + sin(iTime) * 2.,-9.,2.5) * rotations;\n    tail2a = hair + vec3(-0.5,1.,0.5) * rotations;\n    tail2b = tail2a + vec3(-1. - sin(iTime) * 2.2,-9.,2.5) * rotations;\n    \n    // arms\n    rotations = save;\n    float a = keyFrameAngle(LELBOW);\n    updateRotations(vec4(0.,a*0.5,a,0.));    \n    lelbow = lshoulder + vec3(0,-SELBOW.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(LWRIST),0.));    \n    lwrist = lelbow + vec3(0,-SWRIST.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(LHAND),0.));    \n    lhand = lwrist + vec3(0,-SHAND.x,0.) * rotations;\n    updateRotations(vec4(0.,PI * 0.2,0.,0.)); \n    lthumb = lwrist + vec3(0,-SHAND.x,0.) * rotations;\n        \n    rotations = save;\n    a = keyFrameAngle(RELBOW);\n    updateRotations(vec4(0.,a*0.5,a,0.));    \n    relbow = rshoulder + vec3(0,-SELBOW.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(RWRIST),0.));    \n    rwrist = relbow + vec3(0,-SWRIST.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(RHAND),0.));    \n    rhand = rwrist + vec3(0,-SHAND.x,0.) * rotations;\n    updateRotations(vec4(-PI * 1.2,0.,0.,0.)); \n    rthumb = rwrist + vec3(0,SHAND.x,0.) * rotations;\n    staff1 = rotations[0].xyz;\n    staff2 = rotations[1].xyz;\n    staff3 = rotations[2].xyz;    \n    staff = rhand + vec3(-1.,-0.5,-5.) * rotations;\n    bulb = rhand + vec3(-1.,-0.5,-11.) * rotations;   \n    q[sBase + (iFrame % sCount)].xyz = bulb; // streamer\n\n    // legs\n    rotations = save;\n    lthigh = hips + vec3(SSHOULDER.x * 0.5,-2.,0.5) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(LTHIGH),0.));    \n    lknee = lthigh + vec3(0,-STHIGH.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(LCALF),0.));    \n    lankle = lknee + vec3(0,-SCALF.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(LFOOT),0.));    \n    lfoot1 = lankle + vec3(0,-SFOOT.x,0.2) * rotations;\n    lfoot2 = lfoot1 + vec3(0,-0.3,-2.5) * rotations;\n    lskate1 = rotations[0].xyz;\n    lskate2 = rotations[1].xyz;\n    lskate3 = rotations[2].xyz;\n    rotations = save;\n    rthigh = hips + vec3(-SSHOULDER.x * 0.5,-2.,0.5) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(RTHIGH),0.));    \n    rknee = rthigh + vec3(0,-STHIGH.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(RCALF),0.));    \n    rankle = rknee + vec3(0,-SCALF.x,0.) * rotations;\n    updateRotations(vec4(0.,0.,keyFrameAngle(RFOOT),0.));    \n    rfoot1 = rankle + vec3(0,-SFOOT.x,0.2) * rotations;\n    rfoot2 = rfoot1 + vec3(0,-0.3,-2.5) * rotations;\n    rskate1 = rotations[0].xyz;\n    rskate2 = rotations[1].xyz;\n    rskate3 = rotations[2].xyz;\n    \n    saveSettings(O,U);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}