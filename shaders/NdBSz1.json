{
    "Shader": {
        "info": {
            "date": "1619620350",
            "description": "UV-mapped hexagonal tiling on an icosahedron, See: https://en.wikipedia.org/wiki/Goldberg_polyhedron\n\nInstead of mesh tessellation this shader derives the tiling directly from polar angles.\nThis way the performance is independent of the number of tiles.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdBSz1",
            "likes": 14,
            "name": "Class II Goldberg Polyhedron ",
            "published": 3,
            "tags": [
                "uv",
                "sphere",
                "hexagon",
                "tile",
                "polyhedron"
            ],
            "usePreview": 0,
            "username": "Lichtso",
            "viewed": 407
        },
        "renderpass": [
            {
                "code": "#define rotate_around(angle, center) \\\n    mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, center.x, center.y, 1.0)* \\\n    mat3( \\\n        cos(angle), -sin(angle), 0.0, \\\n        sin(angle), cos(angle), 0.0, \\\n        0.0, 0.0, 1.0 \\\n    )* \\\n    mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -center.x, -center.y, 1.0)\n\nconst mat3 rotate_m60 = rotate_around(radians(-60.0), vec2(0.5));\nconst mat3 rotate_p60 = rotate_around(radians(60.0), vec2(0.5));\nconst float M_PI = radians(180.0);\nconst float icosahedron_radius_by_edge_length = sin(M_PI*2.0/5.0);\nconst float inversesqrt5 = inversesqrt(5.0);\nconst vec3 ICOSAHEDRON_VERTICES[12] = vec3[](\n    vec3(0.0, -1.0, 0.0),\n    vec3(-0.27639320492744446, -inversesqrt5, -0.8506507873535156),\n    vec3(-0.8944271802902222, -inversesqrt5, -1.6430361299034693e-16),\n    vec3(-0.27639320492744446, -inversesqrt5, 0.8506507873535156),\n    vec3(0.7236068248748779, -inversesqrt5, 0.525731086730957),\n    vec3(0.7236068248748779, -inversesqrt5, -0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, -0.8506507873535156),\n    vec3(-0.7236068248748779, inversesqrt5, -0.525731086730957),\n    vec3(-0.7236068248748779, inversesqrt5, 0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, 0.8506507873535156),\n    vec3(0.8944271802902222, inversesqrt5, 1.6430361299034693e-16),\n    vec3(0.0, 1.0, 0.0)\n);\n\nfloat line_plane_intersection(vec3 origin, vec3 direction, vec3 point_on_plane, vec3 plane_normal) {\n    float determinant = dot(direction, plane_normal);\n    float zero = 0.0;\n    if(determinant == 0.0)\n        return zero/zero;\n    float parallel_distance = dot(point_on_plane-origin, plane_normal)/determinant;\n    return parallel_distance;\n}\n\nfloat line_sphere_intersection(vec3 origin, vec3 direction, float radius, out vec3 intersections[2]) {\n    float a = dot(direction, direction);\n    float b = -dot(direction, origin);\n    float c = dot(origin, origin) - radius*radius;\n    float d = (b*b)-a*c;\n    if(d < 0.0)\n        return -1.0;\n    d = sqrt(d);\n    direction /= a;\n    intersections[0] = origin+direction*(b-d);\n    intersections[1] = origin+direction*(b+d);\n    return b-d;\n}\n\nconst float blending_region = 0.1;\n\nbool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {\n    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);\n    return dot(direction, aux_a) > 0.0;\n}\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices) {\n    vec3 bary;\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float numerator = dot(direction, cross(b, c));\n        float denominator = 1.0+inversesqrt5+dot(direction, b)+dot(direction, c);\n        bary[i] = 10.0/M_PI*atan(numerator, denominator);\n    }\n    bary /= dot(vec3(1.0), bary);\n    return bary;\n}\n\nvec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices) {\n    vec4 planes[3];\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float tangent = tan(M_PI/10.0*barycentric[i]);\n        planes[i].x = tangent*(1.0+inversesqrt5);\n        planes[i].yzw = cross(b, c)-tangent*(b+c);\n    }\n    vec3 l_g0 = planes[0].x * planes[1].yzw - planes[0].yzw * planes[1].x;\n    vec3 l_g1 = planes[0].z * vec3(planes[1].w, 0.0, -planes[1].y) + planes[0].w * vec3(-planes[1].z, planes[1].y, 0.0) + planes[0].y * vec3(0.0, -planes[1].w, planes[1].z);\n    vec4 p = l_g0.y * vec4(0.0, -planes[2].w, 0.0, planes[2].y) + l_g0.z * vec4(0.0, planes[2].z, -planes[2].y, 0.0) + l_g1.y * vec4(planes[2].z, 0.0, -planes[2].x, 0.0) + l_g1.z * vec4(planes[2].w, 0.0, 0.0, -planes[2].x) + vec4(l_g1.x, -l_g1.x, l_g0.x, -l_g0.x) * planes[2].yxwz;\n    return -p.yzw/p.x;\n}\n\nvec3 rotate_cube_coord(vec3 cube_coord) {\n    return vec3(\n        cube_coord.y-cube_coord.z,\n        cube_coord.z-cube_coord.x,\n        cube_coord.x-cube_coord.y\n    );\n}\n\nvec3 round_cube_coord(vec3 barycentric) {\n    vec3 rounded = round(barycentric);\n    vec3 diff = abs(rounded-barycentric);\n    if(diff.x > diff.y && diff.x > diff.z)\n        rounded.x = -rounded.y-rounded.z;\n    else if(diff.y > diff.z)\n        rounded.y = -rounded.x-rounded.z;\n    else\n        rounded.z = -rounded.x-rounded.y;\n    return rounded;\n}\n\nvec3 color_at_field(int gp_index, int triangle_latitude, int triangle_longitude, ivec3 cube_coord, vec2 tex_coord) {\n    ivec2 parallelogram_coord = cube_coord.xy;\n    if((triangle_longitude&1) == 1) {\n        parallelogram_coord = ivec2(3*gp_index)-parallelogram_coord;\n    }\n    if(triangle_longitude >= 2) {\n        parallelogram_coord[1] += 3*gp_index;\n    }\n    parallelogram_coord[1] = parallelogram_coord[1]*2+parallelogram_coord[0]%2;\n    parallelogram_coord[0] = (parallelogram_coord[0]+gp_index*2)/2-gp_index;\n    parallelogram_coord[1] = (parallelogram_coord[1]+gp_index*3)/3-gp_index;\n    int parallelogram_width = 1+gp_index/2*3+gp_index%2;\n    parallelogram_coord += ivec2(1+triangle_latitude*(parallelogram_width+2), 2);\n    return vec3(normalize(tex_coord-vec2(0.5))*0.3+vec2(0.8), 0.7);\n    // return cube_coord/gp_index;\n    // return vec3(parallelogram_coord.xy, 0.0)/float(gp_index*4);\n    // const float checker_board = 0.25;\n    // return normalize(vec3(cube_coord)/float(gp_index))*((mod(tex_coord.s, checker_board) < checker_board*0.5 != mod(tex_coord.t, checker_board) < checker_board*0.5) ? 1.0 : 0.8);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float planet_radius = 20.0;\n    \n    vec3 view_ray_origin = vec3(0.0, 0.0, planet_radius*10.0);\n    vec3 view_ray_hit = vec3(fragCoord/iResolution.xy*2.0-vec2(1.0), 0.0);\n    view_ray_hit.x *= iResolution.x/iResolution.y;\n    view_ray_hit.xy *= planet_radius*1.2;\n    vec3 view_ray_direction = normalize(view_ray_hit-view_ray_origin);\n\n    vec3 intersections[2];\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(line_sphere_intersection(view_ray_origin, view_ray_direction, planet_radius, intersections) < 0.0)\n        return;\n    vec3 surface_normal = normalize(intersections[0]);\n    \n    float rotate_y = (iMouse.x/iResolution.x-0.5+iTime*0.02)*M_PI*2.0;\n    float rotate_x = (iMouse.y/iResolution.y-0.5)*M_PI;\n    surface_normal = (mat4(\n        cos(rotate_y), 0.0, sin(rotate_y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rotate_y), 0.0, cos(rotate_y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rotate_x), sin(rotate_x), 0.0,\n        0.0, -sin(rotate_x), cos(rotate_x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*vec4(surface_normal, 1.0)).xyz;\n\n    // Triangles and Barycentric\n    vec3 spherical = surface_normal;\n    float longitude = 1.0-acos(spherical[1])/M_PI;\n    float latitude = atan(spherical[0], spherical[2])/M_PI;\n    int triangle_latitude_south = int(mod((2.9+latitude)*2.5, 5.0));\n    int triangle_latitude_north = int(mod((3.1+latitude)*2.5, 5.0));\n    ivec3 pole_indices;\n    int triangle_longitude;\n    int triangle_latitude;\n    if(side_of_half_plane(spherical, 1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south)) {\n        pole_indices = ivec3(1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south, 0);\n        triangle_longitude = 0;\n        triangle_latitude = triangle_latitude_south;\n    } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n        pole_indices = ivec3(6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5, 11);\n        triangle_longitude = 3;\n        triangle_latitude = triangle_latitude_north;\n    } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 1+triangle_latitude_north) &&\n              side_of_half_plane(spherical, 1+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n        pole_indices = ivec3(6+(triangle_latitude_north+1)%5, 6+triangle_latitude_north, 1+triangle_latitude_north);\n        triangle_longitude = 2;\n        triangle_latitude = triangle_latitude_north;\n    } else {\n        pole_indices = ivec3(1+triangle_latitude_south, 1+(triangle_latitude_south+1)%5, 6+(triangle_latitude_south+1)%5);\n        triangle_longitude = 1;\n        triangle_latitude = triangle_latitude_south;\n    }\n    int gp_index = int(planet_radius/(icosahedron_radius_by_edge_length*3.0));\n    vec3 barycentric = cart_to_bary(spherical, pole_indices)*float(gp_index);\n    ivec3 cube_coord = ivec3(gp_index)-ivec3(rotate_cube_coord(round_cube_coord(rotate_cube_coord(barycentric))));\n    vec3 center_diff;\n\n    // Fix Edge Cases\n    if(cube_coord.x == gp_index*3 || cube_coord.y == gp_index*3 || cube_coord.z == gp_index*3) {\n        center_diff = barycentric*3.0-vec3(cube_coord);\n        if((triangle_longitude&1) == 1) {\n            center_diff *= -1.0;\n        }\n        switch(int(floor(longitude*6.0))) {\n            case 0:\n                triangle_latitude = (5-triangle_latitude)%5;\n            case 5:\n                switch(triangle_latitude) {\n                    case 1:\n                        center_diff = -center_diff.yzx;\n                        break;\n                    case 2:\n                        center_diff = center_diff.zxy;\n                        break;\n                    case 3:\n                        center_diff = center_diff.yzx;\n                        break;\n                    case 4:\n                        center_diff = -center_diff.zxy;\n                        break;\n                }\n                triangle_latitude = 0;\n                break;\n            case 3:\n            case 4:\n                cube_coord = ivec3(0.0, gp_index*3, 0.0);\n                triangle_latitude = triangle_latitude_south;\n                triangle_longitude = 3;\n                break;\n            case 1:\n            case 2:\n                cube_coord = ivec3(gp_index*3, 0.0, 0.0);\n                triangle_latitude = triangle_latitude_north+4;\n                triangle_longitude = 0;\n                break;\n        }\n    } else {\n        switch(triangle_longitude) {\n            case 3:\n                if(cube_coord.y == 0) {\n                    cube_coord.xy = cube_coord.yx;\n                    barycentric = vec3(-barycentric.y, float(gp_index)-barycentric.z, float(gp_index)-barycentric.x);\n                    triangle_latitude += 4;\n                }\n                break;\n            case 2:\n                if(cube_coord.x == 0) {\n                    cube_coord.yz = ivec2(gp_index*3)-cube_coord.yz;\n                    barycentric = vec3(-barycentric.x, float(gp_index)-barycentric.y, float(gp_index)-barycentric.z);\n                    triangle_longitude -= 1;\n                    triangle_latitude += 4;\n                } else if(cube_coord.z == 0) {\n                    cube_coord.xy = ivec2(gp_index*3)-cube_coord.xy;\n                    barycentric = vec3(float(gp_index)-barycentric.x, float(gp_index)-barycentric.y, -barycentric.z);\n                    triangle_longitude += 1;\n                }\n                break;\n            case 1:\n                if(cube_coord.y == 0) {\n                    cube_coord.xz = ivec2(gp_index*3)-cube_coord.xz;\n                    barycentric = vec3(float(gp_index)-barycentric.x, -barycentric.y, float(gp_index)-barycentric.z);\n                    triangle_longitude += 1;\n                } else if(cube_coord.z == 0) {\n                    cube_coord.xy = ivec2(gp_index*3)-cube_coord.xy;\n                    barycentric = vec3(float(gp_index)-barycentric.x, float(gp_index)-barycentric.y, -barycentric.z);\n                    triangle_longitude -= 1;\n                }\n                break;\n            case 0:\n                if(cube_coord.x == 0) {\n                    cube_coord.xy = cube_coord.yx;\n                    barycentric = vec3(float(gp_index)-barycentric.z, -barycentric.x, float(gp_index)-barycentric.y);\n                    triangle_latitude += 4;\n                }\n                break;\n        }\n        center_diff = barycentric*3.0-vec3(cube_coord);\n        if((triangle_longitude&1) == 1) {\n            center_diff *= -1.0;\n        }\n    }\n    triangle_latitude %= 5;\n\n    // Texture Coordinates\n    vec2 tex_coord = vec2(0.5)+0.75*vec2(center_diff.z, (center_diff.x-center_diff.y)/sqrt(3.0))/3.0;\n    vec3 edge_blending = (abs(center_diff)-vec3(1.0-blending_region))/blending_region*0.5;\n    edge_blending = smoothstep(vec3(0.0), vec3(1.0), edge_blending);\n    if((triangle_longitude&1) == 1) {\n        center_diff *= -1.0;\n    }\n    \n    float sum = 1.0-max(max(max(edge_blending.x, edge_blending.y), edge_blending.z), 0.0);\n    fragColor.rgb = sum*color_at_field(gp_index, triangle_latitude, triangle_longitude, cube_coord, tex_coord);\n    \n    // Texture Blending\n    #if 0\n    for(int i = 0; i < 3; ++i) {\n        if(edge_blending[i] > 0.0) {\n            int s = int(sign(center_diff[i]));\n            ivec3 dir = ivec3(0);\n            dir[i] = 2*s;\n            dir[(i+1)%3] = -s;\n            dir[(i+2)%3] = -s;\n            ivec3 neighbor_coord = cube_coord+dir;\n            vec2 neighbor_tex_coord = tex_coord;\n            switch(triangle_longitude) {\n                case 3:\n                case 0:\n                    if(neighbor_coord.x < 0) {\n                        neighbor_tex_coord = (rotate_p60*vec3(tex_coord, 1.0)).xy;\n                    } else if(neighbor_coord.y < 1) {\n                        neighbor_tex_coord = (rotate_m60*vec3(tex_coord, 1.0)).xy;\n                    }\n                    break;\n            }\n            fragColor.rgb += edge_blending[i]*color_at_field(gp_index, triangle_latitude, triangle_longitude, neighbor_coord, neighbor_tex_coord);\n            sum += edge_blending[i];\n        }\n    }\n    fragColor.rgb /= sum;\n    #endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}