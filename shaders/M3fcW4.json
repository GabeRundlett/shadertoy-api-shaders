{
    "Shader": {
        "info": {
            "date": "1726165622",
            "description": "origianals https://www.shadertoy.com/view/XXfcD4 https://www.shadertoy.com/view/X3XcWN",
            "flags": 0,
            "hasliked": 0,
            "id": "M3fcW4",
            "likes": 4,
            "name": "space cat",
            "published": 3,
            "tags": [
                "space",
                "cat"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 70
        },
        "renderpass": [
            {
                "code": "\n#define TAU 6.28318530718\n#define MAX_ITER 6\n#define FREQ 1.0\n#define SPEED 0.5\nvec3 colors[MAX_ITER]=vec3[]\n(\n    vec3(1.0,0.0,0.0),\n    vec3(0.0,0.8,0.0),\n    vec3(0.0,0.0,1.0),    \n    vec3(1.0,0.8,0.0),\n    vec3(0.0,0.8,1.0),    \n    vec3(1.0,0.0,1.0)\n);\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nvec2 hash22(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff)-vec2(0.5);\n}\n#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 1.0; // how strong is the diffuse lightning\nconst float globalSpecular = 0.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 16.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(1.0, 3.0, 5.0); // position of the light source\nconst vec3 lightColor = vec3(1.0); // color of the light source\nconst vec3 ambientColor = vec3(0.584,0.529,0.427); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat tetrahedron( vec3 p, float h )\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x-0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nvec2 GetDist(vec3 p) {  \n    float d = 999.0;\n    float mat = 0.0;\n    float scale = 0.7;\n    \n    p /= scale;\n        \n    float s = ellipsoid(p,vec3(1.8,1.2,1.8)*1.3);\n    \n    s = max(s,-p.y-0.8);\n    \n    float ear = 999.0;\n    \n    {\n        vec3 ep = p;\n        \n        ep /= 0.9;\n        \n        ep.x = abs(ep.x);\n        \n        ep -= vec3(1.4,1.0,1.2);\n        \n        ep.yz *= Rot(-0.2);\n        ep.xy *= Rot(0.5);\n        \n        ear = tetrahedron(ep,0.8);\n        \n        ear *= 0.9;\n    }\n    \n    s = smin(s,ear,0.1);\n    \n    float eyes = 999.0;\n    \n    {\n        vec3 ep = p;\n        \n        ep.x = abs(p.x);\n        \n        ep -= vec3(0.6,0.2,2.3);\n        \n        ep.xy *= Rot(0.08);\n        \n        eyes = capsule(ep.zxy,0.3,0.025);\n    }\n    \n    s = min(s,eyes);\n    \n    float mouth = 999.0;\n    \n    {\n        vec3 mp = p;\n        \n        mp -= vec3(0.18,-0.3,2.4);\n        \n        float k = abs(mod(mp.x*20.0,6.0) - 3.0);\n        \n        \n          mp.y -= k*0.025;\n        mouth = capsule(mp.zxy,0.3,0.025);\n    }\n    \n    s = min(s,mouth);\n    \n    float whiskers = 999.0;\n    \n    {\n        vec3 wp = p;\n        \n        wp.xy = abs(wp.xy);\n        \n        wp -= vec3(1.3,0.026,2.1);\n        \n        wp.xy *= Rot(-0.15);\n        \n        float k = sin((wp.x - 5.0) * 5.0)* 0.5 + 0.5;\n        \n        k *= 0.02;\n        \n        wp.y += k;\n        \n        whiskers = capsule(wp.zxy,0.7,0.025);\n    }\n    \n    s = min(s,whiskers);\n    \n    d = min(d,s);\n    mat = (d==s) ? 0.0 : mat;\n    \n    mat = (s==eyes) ? 1.0 : mat;\n    mat = (s==mouth) ? 1.0 : mat;\n    mat = (s==whiskers) ? 1.0 : mat;\n    \n    d *= scale;\n    \n    return vec2(d,mat);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    float k = 0.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        k += 1.0;\n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec3(dO,mat,k);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * round(max(0.0, dot(normal, toLight)) + 0.3);\n      vec3 specularFactor = lightCol * round(pow(max(0.0, dot(toEye, reflection)), specularExponent))\n                     * specularCoeff;\n   \n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n    \n    diffuseFactor *= round(ss);\n    diffuseFactor *= ao;\n    \n    //diffuseFactor = round(diffuseFactor);   \n    \n    return ambientFactor + diffuseFactor + specularFactor;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\nfloat easeFade(float x)\n{\n    return 1.-(2.*x-1.)*(2.*x-1.)*(2.*x-1.)*(2.*x-1.);\n}\nfloat holeFade(float t, float life, float lo)//lifeOffset\n{\n    return easeFade(mod(t-lo,life)/life);\n}\nvec2 getPos(float t, float life, float offset, float lo)\n{\n    return vec2(cos(offset+floor((t-lo)/life)*life)*iResolution.x/2.,\n    sin(2.*offset+floor((t-lo)/life)*life)*iResolution.y/2.);\n\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n \n#define iterations 10\n#define formuparam 0.73\n\n#define volsteps 10\n#define stepsize 0.2\n\n#define zoom   0.10\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.630\n#define saturation 0.2150\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat time = iTime*0.1;\nvec2 coord = fragCoord * 2. - iResolution.xy;\n    // Normalized pixel coordinates (from 0 to 1)\nvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    float holeSize = iResolution.y/10.;\n    float holeLife = 2.;\n    \n    \n    vec3 final;\n    for (int i = 0; i<4; i++) {\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(float(i),2.*float(i)+4.,4.*float(i)+16.));\n\n        float s = holeSize;\n        float lifeOffset = float(i)/2.;\n\n        vec2 pos = getPos(iTime, holeLife, float(i)*4.5,lifeOffset);\n\n        float d = distance(coord,pos)/s;\n        d = 1./d-.1;\n        \n        final += mix(vec3(0),col, d)*holeFade(iTime,holeLife,lifeOffset);\n    }\n\nvec2 uv2 = (fragCoord-.5*iResolution.xy)/iResolution.y;\nuv2.x+=0.1;\nuv2.y-=0.063;\nvec2 uv3 = (fragCoord-.5*iResolution.xy)/iResolution.y;\nuv3.x-=0.1;\nuv3.y-=0.065;\nvec3 dir=vec3(uv*zoom,1.);\n    \tvec3 from=vec3(1.,.5,0.5);\nfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.3-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-0.61*PI+1.);\n    ro.xz *= Rot(-0.5*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n    vec3 bg = vec3(0.6);\n    vec3 col = bg;\n   \n    vec3 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        if (rm.y == 0.0) {\n            col = vec3(0.769,0.773,0.718);\n        } else if (rm.y == 1.0) {\n            col = vec3(-10.3);\n        }\n        \n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro,rd);\n        col = mix(col,bg,1.0 - exp(-0.0004*d*d));\n    }\n    \n    float c = 0.7;\n    float b = 0.0;\n    col = c * (col*v*.01-0.5) + 0.5 + b;\n    vec3 greyscale = vec3(dot(col,vec3(0.299,0.587,0.114)));\n    col = mix(greyscale,col,1.3);\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    \n    col = pow(col+final, vec3(.4545));\t// gamma correction\n    \n    \n    if (rm.z > 30.0) {\n        col *= 0.0;\n    }\n    // uv should be the 0-1 uv of texture...\n\n    vec2 p = mod(uv*FREQ*TAU, TAU)-250.0;\n\tvec2 i = vec2(p);\n\tfloat inten = .005; //Increase for more glow\n    vec3 color = vec3(1);\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1))); //Offset time per wave\n        //Distort\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        //Add to total color. 1-color to account for inverting average later\n        color+=(1.0-colors[n]) \n         *(1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten))));\n\t}\n\tcolor /= float(MAX_ITER);\n    //Exponential, invert\n    color = vec3(1)-pow(color,vec3(2));\n    //Darken on curve\n    color = pow(abs(color), vec3(6.0));\n    //Brighten a bit\n    color = clamp(color + vec3(0.2), 0.0, 1.0);\n    //Background if you want\n\n\tfragColor = vec4(color*col, 1.0);\n    \n     uv2 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n      uv3 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor+= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.35)*0.05, 1.0);\n     fragColor+= vec4(happy_star(uv3, anim) * vec3(0.35,0.2,0.35)*0.05, 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}