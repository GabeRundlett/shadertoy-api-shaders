{
    "Shader": {
        "info": {
            "date": "1510814867",
            "description": "Please read instructions under the \"Image\" tab for full controls and optimization. \n\nMANY FEATURES ARE DISABLED. PLEASE ENABLE THE DEFINES TO SEE ALL FEATURES. Thanks!\n\nhttps://youtu.be/pKY_-Kgs_1Q\nhttps://youtu.be/_Kh7GcYLM3I\n\n",
            "flags": 112,
            "hasliked": 0,
            "id": "lllBRn",
            "likes": 71,
            "name": "Tower Of Light",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "reflection",
                "terrain",
                "raymarch",
                "cloud",
                "texture",
                "water",
                "light",
                "shadows",
                "raytrace",
                "tower",
                "shapes",
                "trees",
                "lighthouse"
            ],
            "usePreview": 1,
            "username": "ingagard",
            "viewed": 3268
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////////////////\n// Copyright © 2017 Kim Berkeby (email: mr.kimb@hotmail.com)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n////////////////////////////////////////////////////////////////////////////////////////////\n/*\n Youtube version of the shader (great thanks to Adrian Chlubek, aka afl_ext):\n\n https://youtu.be/pKY_-Kgs_1Q\n https://youtu.be/_Kh7GcYLM3I\n\n CONTROLS:\n ---------\n Hold left mouse button and move mouse to pitch and rotate camera.\n  \n D     ZOOM OUT\n E     ZOOM IN\n\nF1     ZOOM OUT (alternative)\nF2     ZOOM IN  (alternative)\n\n R     CAMERA UP\n F     CAMERA DOWN\n  \n\n Notice:\n If you want to invert the mouse look, please enable #define INVERT_MOUSE_Y in Buf A.\n\n\n Toggle effects by pressing folloving keys:\n ------------------------------------------\n\n 2-key  = Grain filter  on/off                   (default on)\n 3-key  = Chromatic aberration  on/off           (default on)    \n 4-key  = God Rays  on/off                       (default on)\n 5-key  = Lens flare  on/off                     (default on)\n\n ---------------------------------------------------------------------------------\n *********************************************************************************\n\n MANY FEATURES ARE DISABLED. PLEASE ENABLE THE DEFINES TO SEE ALL FEATURES. Thanks!\n\n *********************************************************************************\n ---------------------------------------------------------------------------------\n \n\n TO INCREASE PERFORMANCE OR VIEW:\n --------------------------------\n  \n  Delete one or several defines from Buf C:\n \n  #define TERRAIN   (removing this will make the shader ONLY render the tower model)\n  #define TREES\n  #define QUALITY_REFLECTIONS\n  #define QUALITYFOLIAGE\n  #define GRASS\n  #define SHADOWS\n  #define PERFORM_AO_PASS\n  #define BRIDGE\n  #define BOAT\n\n  Delete one or several defines from Buf D:\n \n  #define PERFORM_AO_PASS\n  #define PERFORM_AA_PASS    (deleting this will cause a lot of noise)\n  #define SHADOWS\n\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http://mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n https://iquilezles.org/\n\n Music by Muse Muh Nur:\n https://soundcloud.com/musa-muh-nur/nature-sounds-beautiful\n\n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*/\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// POST EFFECTS BUFFER\n//////////////////////////////////////////////////////////////////////////////////////\n// Channel 0 = Buffer A. Read data from data-buffer.\n// Channel 1 = LowRes noise texture. Used in fast noise functions.\n// Channel 2 = Buffer C. Get the colors of the render from the last buffer.\n// Channel 3 = Music ( https://soundcloud.com/musa-muh-nur/nature-sounds-beautiful )\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define read(memPos) (  texelFetch(iChannel0, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define PI acos(-1.)\n  #pragma optimize(off) \n\nmat3 cameraMatrix;\n\nvec3 sunPos=vec3(0.);\n\nfloat CalcSum(vec2 uvPos) \n{\n    vec4 col = textureLod(iChannel2, uvPos,0.);\n    float sum = (col.r+col.g+col.b)*0.333;\n    return mix(0.,sum,step(0.75,sum-col.a));\n}\n\n#define VOLUMESAMPLES 24\nfloat GetVolumetrics(vec2 pos, vec2 uv)\n{\n    float sum \t = 0.;\n    float weight = 1. / float(VOLUMESAMPLES);\n    vec2 dir = pos-uv;\n    \n    for(int i = 0; i < VOLUMESAMPLES; i++)\n    {\n        sum += CalcSum(uv);\n        uv += dir * .036;\n    }\n    \n    return sum * weight * 0.4;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare)\n{\n\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 5.0);  \n  if (visibility<=0.006) return vec3(0.);\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;\n  float sunIntensity = (1.0/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  vec3 color;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  // check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  // only draw if not covered by any object\n  if (readAlpha( sunScreenPos/2.0 +0.5)<0.50)\n  {\n    // create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      color.rg = vec2(abs((sin(i*53.))), 0.65);\n      color.b = abs((cos(i*25.)));\n      offSet += offSetStep;\n\n      size = 0.05+((1.-sin(i*0.54))*0.28);\n      dist = pow(length(sunScreenPos-offSet), 1.20);\n\n      flareColor += mix(vec3(0.), sunIntensity*(10.*size) * color, smoothstep(size, size-dist, dist))/(1.0-size);\n    }\n\n      flareColor = mix(flareColor,flareColor*.1, max(0.,visibility));\n  flareColor += (vec3(1.0, .0, .0)  * pow(visibility, 1.)*.5);\n  }\n  flareColor*=mix(2., .2, smoothstep(0., 1., visibility)); \n\n  \n  }\n    \n  // flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  // sun glow\n  sunSpot+=vec3(1.0, 0.96, 0.90)*sunIntensity*.75;\n  sunSpot+=vec3(1.0, 0.76, 0.20)*visibility*0.245;\n    \n  return flareColor+(sunSpot*(1.0-alpha));\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  // read values from buffer\n  vec3 effects = readRGB(ivec2(120, 0));  \n  vec3 effects2 = readRGB(ivec2(122, 0)); \n  float turn = read(ivec2(1, 10));\n  sunPos = readRGB(ivec2(50, 0));\n  // setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  vec3 camData  = readRGB(ivec2(52, 0));  \n\n  vec3 rayOrigin = vec3(camData.z*cos(camRot.x), camData.y,camData.z*sin(camRot.x) );\n     rayOrigin.y = readRGB(ivec2(62, 0)).y;\n    cameraMatrix  = setCamera( rayOrigin, vec3(0., camData.y+(11.*camRot.y), 0. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec2 d = abs((uv - 0.5) * 2.0);\n  d = pow(d, vec2(2.0, 2.0));\n  float minDist = -1000.0;\n\n\n  vec4 color;\n\n  // chromatic aberration?\n  if (effects.z>0.)\n  {\n    vec2 offSet = (uv.xy*2.-1.)/iResolution.xy*1.5;\n    color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);\n    \n  }\n  // no chromatic aberration \n  else\n  {\n      color.rgb = texture(iChannel2, uv).rgb;\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  // add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x);\n\n  // grain noise\n  if (effects.y>0.)\n  {\n    vec2 grainTexPos = ((fragCoord.xy + iTime*60.0*vec2(10, 35.))*0.6)/iChannelResolution[0].xy;\n    vec2 filmNoise = textureLod( iChannel1, grainTexPos, 0. ).rb;\n  }\n\n  if (effects2.y>0.)\n  {\n    // perform volumetric light ray pass if looking into the sun\nfloat sunVisibility = max(0.,dot(sunPos, rayDir));\n    if(sunVisibility>0.)\n    {\n          vec2 sunScreenPos = GetScreenPos(sunPos);\n           color.rgb += mix(0.,GetVolumetrics(sunScreenPos/2.0 +0.5, uv),pow(sunVisibility,6.));\n    }\n  } \n    \n  fragColor =  vec4(pow(color.rgb, vec3(1.0/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.32 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 12403,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/musa-muh-nur/nature-sounds-beautiful"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// DATA BUFFER  -  CAMERA CONTROL AND KEYBOARD CHECKS\n//////////////////////////////////////////////////////////////////////////////////////\n// Channel 0 = Keyoard input. Used to capture key-presses.\n// Channel 1 = LowRes noise texture. Used in fast noise functions.\n// Channel 2 = This buffer (A). Read and write data to update this shader.\n// Channel 3 = Lichen texture. Used to create landscape height map and textures.\n  #pragma optimize(off) \n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  //#define INVERT_MOUSE_Y \n\n  // R    CAM UP\n  #define UP_KEY 82     \n  // F    CAM DOWN\n  #define DOWN_KEY 70      \n  // D     ZOOM OUT\n  #define ZOOMOUT_KEY 68\n  // E     ZOOM IN\n  #define ZOOMIN_KEY 69\n  // F1     ZOOM OUT (alternative)\n  #define ZOOMOUT_KEY_ALT 112\n  // F2     ZOOM IN (alternative)\n  #define ZOOMIN_KEY_ALT 113\n\n\n// noise functions by IQ (somewhat modified to fit my usage)\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n//////////////////////////////////////////////////\n\n\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz)*0.0005;\n\n  float mainHeight = -2.3+fastFBM(p*0.025)*max(11., abs(22.*noise2D(p2))); \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(200., 240., length(p.xz-vec2(0., 120.))));\n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(250., 300., length(p.xz-vec2(100., -100.))));\n\n  return   terrainHeight*1.4;\n}\n\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n  // read and save effect values from buffer  \n  vec3 effects =  mix(vec3(-1.0, 1.0, -1.0), readRGB(ivec2(120, 0)), step(1.0, float(iFrame)));\n  effects.y*=1.0+(-2.*float(keyPress(50))); //2-key  Grain Filter\n  effects.z*=1.0+(-2.*float(keyPress(51))); //3-key  ChromaticAberration\n\n  vec3 effects2 =  mix(vec3(1.0, 1.0, 1.0), readRGB(ivec2(122, 0)), step(1.0, float(iFrame)));\n  effects2.y*=1.0+(-2.*float(keyPress(52))); //4-key  God Rays\n  effects2.x*=1.0+(-2.*float(keyPress(53))); //5-key  lens flare\n\n  fragColor.rgb = mix(effects, fragColor.rgb, step(1., length(fragCoord.xy-vec2(120.0, 0.0))));  \n  fragColor.rgb = mix(effects2, fragColor.rgb, step(1., length(fragCoord.xy-vec2(122.0, 0.0))));\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{ \n  const vec3 offSet = vec3(-143, 0., 292);\n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  vec3 sunPos = mix(normalize( vec3(1.730, 0.13, .700) ), readRGB(ivec2(50, 0)), step(1.0, float(iFrame)));\n  vec3 camData = mix(vec3(0., 7., 68.), readRGB(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = mix(vec2(4.73, 0.), readRGB(ivec2(57, 0)).xy, step(1.0, float(iFrame))); \n  vec3 oldOrigin = readRGB(ivec2(62, 0));\n    \n  if (iMouse.z>0.)\n  {\n    // setup camera and ray direction\n    camRot.x=(mo.x*12.); \n    #ifdef INVERT_MOUSE_Y \n      camRot.y=6.-((mo.y)*12.);\n#else\n  camRot.y=-6.+((mo.y)*12.);\n#endif\n}\ncamRot.y = clamp(camRot.y, -3., 3.);\n\n\nToggleEffects(fragColor, fragCoord);\n\ncamData.z-=0.3*float(keyClick(ZOOMIN_KEY) || keyClick(ZOOMIN_KEY_ALT));\ncamData.z+=0.3*float(keyClick(ZOOMOUT_KEY) || keyClick(ZOOMOUT_KEY_ALT));\ncamData.z=clamp(camData.z, 4., 100.);\n\n\ncamData.y+=0.3*float(keyClick(UP_KEY));\ncamData.y-=0.3*float(keyClick(DOWN_KEY));\ncamData.y=clamp(camData.y, 6., 30.);\n\n// adding a small amount of camRot.y just to check if the camera has been moved in ANY way when later doing AA pass\nvec3 rayOrigin = vec3(offSet.x+camData.z*cos(camRot.x), camData.y+(0.0001*camRot.y), offSet.z+camData.z*sin(camRot.x) );    \nmat3 ca = setCamera( rayOrigin, vec3(0., camData.y+(11.*camRot.y), 0. ), 0.0 );\nvec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n                    \n// prevent camera from going below terrain\nfloat groundH = GetTerrainHeight(rayOrigin)+3.;   \nrayOrigin.y= max(rayOrigin.y, groundH);\ncamData.y = max(camData.y, groundH);\n\nfragColor.rgb = mix(sunPos, fragColor.rgb, step(1., length(fragCoord.xy-vec2(50.0, 0.0))));\nfragColor.rgb = mix(camData, fragColor.rgb, step(1., length(fragCoord.xy-vec2(52.0, 0.0))));\nfragColor.rgb = mix(rayOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(62.0, 0.0))));\nfragColor.rgb = mix(oldOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(60.0, 0.0))));\n        \nfragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., length(fragCoord.xy-vec2(57.0, 0.0))));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// TERRAIN BUFFER  -   RENDERS TERRAIN AND BRIDGE\n//////////////////////////////////////////////////////////////////////////////////////\n// Channel 0 = Fine noise texture. Used in noise functions.\n// Channel 1 = LowRes noise texture. Used in fast noise functions.\n// Channel 2 = Buffer A. Read data from data-buffer.\n// Channel 3 = Lichen texture. Used to create landscape height map and textures.\n#define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n#pragma optimize(off) \n#define NO_UNROLL(X) (X + min(0,iFrame))\n\n// Delete one or several of below defines to increase performance\n#define TERRAIN \n#define TREES\n#define QUALITY_REFLECTIONS\n#define QUALITYFOLIAGE\n#define GRASS\n#define SHADOWS\n//#define PERFORM_AO_PASS\n#define BRIDGE\n//#define BOAT\n//#define ACCURATE_BOAT_REFLECTION\n\n// Try enabling below define if shader doesn´t compile\n//#define LOWRES_TEXTURES\n\nfloat hash(float h)\n{\n  return fract(sin(h) * 43758.5453123);\n} \n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  vec4 dist;\n  float treeDist;\n  float depth;\n};\n\n    \nfloat treeDist;\nvec2 cloudPos=vec2(0.);\nvec3 wind=vec3(0.);\nvec3 sunPos=vec3(0.);\n\n\n// noise functions by IQ (somewhat modified to fit my usage)\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define addPos vec2(1.0, 0.0)\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\n\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\nfloat terrainNoise(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x )\n{\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n\n  float res = mix(mix( terrainNoise(p), terrainNoise(p + addPos.xy), f.x), \n    mix( terrainNoise(p + addPos.yx), terrainNoise(p + addPos.xx), f.x), f.y);\n  return res;\n}\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n#define pR(p, a) (p)*=r2(a)\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n#define GetHorizon(p) sdEllipsoid(p, vec3(1000., 50., 1000.))\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) { //yes, this might not be the best thing numerically.\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat GetCloudHeightBelow(vec3 p)\n{         \n  vec3 p2 = (p*0.00015)+vec3(-iTime*0.0013, 0., -iTime*0.00165);\n\n  float i =-0.6+(textureLod(iChannel0,p2,0.50).r*1.5); \n  p2*=1.52;\n  i +=(-1.0+2.0*textureLod(iChannel0,p2,0.40).g)*0.5; \n  p2*=2.53;\n  i += (-1.0+2.0*textureLod(iChannel0,p2,0.30).b)*.25; \n  p2*=2.51;\n  i -= (-1.0+2.0*textureLod(iChannel0,p2,0.20).r)*0.12;\n\n  return i-0.1;\n}\n\nvec4 TraceCloudsBelow( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{ \n\n  const vec3 sunColor = vec3(1.0, 0.53, 0.37); \n  vec4 cloudCol=vec4(vec3(1.0, 0.53, 0.37)*1.3, 0.0);\n\n  float density = 0.0, dist = 0.0;\n\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float densAdd=0.;\n  float shadowDensity;\nfloat add=1.;\n    int i=0;\n  float t = (550.0-origin.y)/direction.y;\n  \n  for ( int ii=i; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos = origin+direction*t;  \n    density = GetCloudHeightBelow(rayPos);          \n      \n\n    if (density>0.01)\n    {    \n\n      densAdd = 0.12*density*max(0.,add);\n      shadowDensity = GetCloudHeightBelow(rayPos+(sunPos*90.)); \n        \n     cloudCol.rgb += densAdd*max(0.,(density-shadowDensity))*sunColor;  \n     cloudCol.rgb-=1.4*shadowDensity*densAdd; \n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n        add-=densAdd;\n        if (add<0. || cloudCol.a > 0.99) break; \n\n    } \n    t+=2.;\n  }\n         \n\n  // mix clouds color with sky color\n  cloudCol.rgb = mix(cloudCol.rgb, vec3(0.97), smoothstep(100., 4960., t)); \n  cloudCol.a = mix(cloudCol.a, 0., smoothstep(0., 4860., t));\n    \n  return cloudCol;\n}\n\nconst mat2 r2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz)*0.0005;\n\n  float mainHeight = -2.3+fastFBM(p*0.025)*max(11., abs(22.*noise2D(p2))); \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n     \n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;  p2 *= r2D;       \n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;  p2 *= r2D;          \n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight));\n      \n  vec2 offPos = p.xz-vec3(-143, 0., 292).xz;\n  terrainHeight=mix(-0.6, terrainHeight,smoothstep(180., 220., length(offPos-vec2(100., -185.))));\n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(150., 320., length((p.z*2.5)-vec3(-143, 0., 292).z+320.)));\n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(50.,300., length(offPos-vec2(800., -450.))));\n\n  return   terrainHeight;\n}\n\n\nfloat GetMountainHeight( vec3 p)\n{\n  vec2 p2 = p.xz*0.02;\n\n  float d = .24+(0.65*noise(p2*.25));\n  d = 120.0 * d * d ;\n\n  float height = d * noise(p2); \n  p2 *= r2D;   d *= 0.49;\n  height += d * noise(p2); \n  p2 *= r2D;   d *= 0.46;\n  height += d * noise(p2); \n  p2 *= r2D;   d *= 0.43;\n  height += d * noise(p2); \n  p2 *= r2D;  d *= 0.4;\n  height += d * noise(p2); \n  p2 *= r2D;\n\n  height += pow(abs(noise(p2*.002)), 8.0)*400.-5.0;\n\n height=mix(-200., height*0.5, smoothstep(600., 1100., length(p.xz-vec3(-143, 0., 292).xz-vec2(1800., -700.))));\n  height=mix(0., height, smoothstep(600., 850., length(vec3(-143, 0., 292).xz-p.xz)));\n  return  height;\n}\n\n\n#define GetWaterWave(p) (((-0.5+(0.5*(noise2D((p.xz+ vec2(-iTime*0.3, iTime*0.25))*2.60, 0.2)))) + (-0.5+(0.5*(noise2D((p.xz+ vec2(-iTime*-.48, iTime*-0.25))*1.60, 0.2)))))*0.5 )\n\nfloat GetTreeHeight( vec2 p, vec2 realP, float terrainHeight)\n{\n  float tree =textureLod(iChannel1, (p*0.05), 0.).r-0.13;\n\n\n  float randomFactor = 50.*(noise(p));\n  // remove trees near tower\n  tree=mix(0., tree, smoothstep(80.+randomFactor, 100.+randomFactor, length(realP-vec2(-143, 292))));\n  // remove trees in distance (out at sea)\n  tree=mix(0., tree, smoothstep(230., 340., length(realP-vec2(100., 0.))));\n tree=mix(0., tree, smoothstep(2.20, 2.30, terrainHeight));\n  return max(0., tree-0.4);\n}\n\nfloat GetStoneHeight(vec2 p, float terrainHeight)\n{\n  float height = textureLod(iChannel3, p*0.075, .1).x;\n  // create small stones at the coast line\n  float heightAdd =textureLod(iChannel1, p*0.008, 1.).x*2.;\n  heightAdd *= mix(1., 0., smoothstep(0.423, 0.7, length(0.1-terrainHeight)));\n  terrainHeight+=heightAdd;\n      \n  // add stones to hills\n  height = mix(0., mix(height, 0., smoothstep(4.0, 6.0, terrainHeight)), smoothstep(-.10, 0.10, terrainHeight));\n  height=mix(0., height, smoothstep(2.5, 4.0, length(p-vec2(-143, 292))));\n\n  return max(0., height);\n}\n\nfloat GetBoulderHeight( vec2 p, float terrainHeight)\n{\n  if (terrainHeight<1.8) return 0.;\n\n  float height = pow(textureLod(iChannel3, p*0.02, .1).x, 0.5)*0.8;\n  height += textureLod(iChannel3, (p*r2D)*0.04, .0).x*0.05;\n  height += textureLod(iChannel1, p*0.1, .1).x*0.01;\n  height = mix(0., height-0.45, step(0.5, height));\n\n  height*=.54;\n  height*=12.;\n\n  height=mix(0., height, smoothstep(1.80, 2.70, terrainHeight));\n  // no boulders near tower\n  height=mix(0., height, smoothstep(6., 19., length(p-vec2(-143, 292))));\n  return max(0., height);\n}\n\n\nfloat GetFoliageHeight(vec3 p, float terrainHeight, float boulderHeight, float stoneHeight)\n{\n  float fol =  textureLod(iChannel1, ((wind.xy*1.6*cos(p.x+p.y))+p.xz)*0.3, 0.1).r;\n  fol = mix(.0, fol, step(0.5, fol));\n  fol=mix(fol, 0., smoothstep(1.80, .270, terrainHeight));\n  fol=mix(fol, 0., smoothstep(0.24, 0.3, stoneHeight));\n\n  fol=mix(fol, 0., smoothstep(0.03, 0.2, boulderHeight));\n  // no foliage near tower\n  fol=mix(0., fol, smoothstep(4., 9., length(p.xz-vec3(-143, 0., 292).xz)));\n\n  return max(0., fol);\n}\n\nvec3 AddWind(vec3 p, vec2 wind, vec3 offSet)\n{\n  p-=offSet;\n  pR(p.xy, (wind.x-wind.y)*0.35);\n  pR(p.zy, (wind.y+wind.x)*0.35);   \n  return p+offSet;\n}\nvec3 TranslateBridge(vec3 p)\n{  \n  p = p-vec3(-143, 0., 292)-vec3(-.5, 1.75, 15.);  \n  p.xz*=r2(1.7);\n  return p;\n}\n\nvec3 TranslateBoat(in vec3 p)\n{\n  p = p-vec3(-143, 0., 292)-vec3(-8., 1.3, 33.); \n  p.xz*=r2(3.14);\n  return AddWind(p, wind.xy, vec3(-2., 0, -5.));\n}\n\nvec3 TranslateBuoy(in vec3 p)\n{\n  p = p-vec3(-143, 0., 292)-vec3(62., 2.2, -30.); \n  return AddWind(p, wind.xy, vec3(2., 0., -1.));\n}\n\nfloat MapMountains(in vec3 p)\n{       \n  return p.y -  GetMountainHeight(p);\n}\n\n\n\nfloat MapBoat(vec3 p)\n{\n  p=TranslateBoat(p);\n  // AABB\n  if (sdBox(p+vec3(0., 0., .50), vec3(1.7, 1.0, 4.))>1.) return 10000.;\n\n  // hull exterior  \n  float centerDist =length(p.x-0.);    \n  float centerAdd = 0.07*-smoothstep(0.04, 0.1, centerDist);\n  float frontDist = max(0.01, 1.3-max(0., (0.25*(0.15*pow(length(p.z-0.), 2.)))));\n  float widthAdd =mix(0.06*(floor(((p.y+frontDist) + 0.15)/0.3)), 0., step(2., length(0.-p.y)));\n\n  float d= fCylinder( p, 1.45+widthAdd, 1.3+centerAdd+widthAdd);  \n  d =min(d, sdEllipsoid( p- vec3(0, 0, 1.250), vec3(1.45+widthAdd, 1.465+centerAdd, 1.+centerAdd+widthAdd))); \n  d =min(d, sdEllipsoid( p- vec3(0, 0, -1.20), vec3(1.45+widthAdd, 1.465+centerAdd, 3.+centerAdd+widthAdd))); \n\n  // hull cutouts\n  d= max(d, -fCylinder( p- vec3(0, 0.25, -0.10), 1.3+widthAdd, 1.4));  \n  d =max(d, -max(sdEllipsoid( p- vec3(0, 0.05, -.60), vec3(1.25+widthAdd, 1.2, 3.40)),-sdBox(p-vec3(0.,0.,4.), vec3(3., 10., 3.1)))); \n\n  // cut of the to part of the hull to make the boat open\n\n  d=max(d, -sdBox(p-vec3(0., 1.05+centerAdd, 0.), vec3(10., frontDist, 14.)));\n\n  // seats\n  return min(d, min(sdBox(p-vec3(0., -0.5, 0.9), vec3(1.3, 0.055, 0.35)), sdBox(p-vec3(0., -0.5, 0.9-2.2), vec3(1.3, 0.055, 0.35))));\n}\n\nfloat MapBridge(vec3 p)\n{\n  p=TranslateBridge(p);\n  // AABB\n  if (sdBox(p-vec3(10., -1.0, 0.0), vec3(11.5, 2.50, 2.25))>3.) return 10000.;\n\n  vec3 bPos = p+vec3(0.36, 0.0, 0.0);\n  // bottom planks\n  pModInterval1(bPos.x, 0.35, 0., 60.);\n  float d= sdBox(bPos-vec3(0., 0.0, 0.1), vec3(0.12, 0.08, 1.80));\n\n  // bearing balks\n  bPos = p-vec3(-1.75, -0.726, -2.);\n  pModInterval1(bPos.x, 3.2, 0., 7.);\n  d= min(d, sdBox(bPos-vec3(0., .0, 2.1), vec3(0.15, 0.15, 2.00)));\n  float m = pModInterval1(bPos.z, 4.2, 0., 1.);\n  d= min(d, sdCappedCylinder(bPos+vec3(0., 0.55, 0.), vec2(0.2, 2.8-m)));\n\n  // side rails      \n  bPos = p-vec3(10.8, 0., -1.7);\n  m = pModInterval1(bPos.z, 3.60, 0., 1.);\n   m = pModInterval1(bPos.y, 1.40, 0., 1.-m);\n     \n  d= min(d, sdBox(bPos, vec3(10., 0.14, .12)));\n\n  return d;\n}\n// Simple terrain map. Skip boulders, foliage and waves\nvec4 MapTerrainReflections( vec3 p)\n{\n    treeDist = 10000.;\n  float boatDist= 10000.;\n  float bridgeDist=10000.;\n  float height = GetTerrainHeight(p); \n  float tHeight= height + GetStoneHeight(p.xz, height);\n  tHeight*=1.4;\n  if (tHeight>0.)\n  {\n    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;  \n               \n      #ifdef TREES   \n      vec3 treePos = p-vec3(0.,tHeight+2.,0.);\n      vec2 mm = floor( treePos.xz/8.0 );\t\n\ttreePos.xz = mod( treePos.xz, 8.0 ) - 4.0;\n\n      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);\n      \n      if(treeHeight>0.05)\n      {             \n          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));\n                     treeDist+=(noise(p*1.26)*.6285);\n         treeDist+=(noise(p*3.26)*.395);\n           treeDist+=(noise(p*6.26)*.09825);\n      }\n    #endif\n  }\n  #ifdef BRIDGE\n    bridgeDist=MapBridge(p);   \n  #endif\n    #ifdef BOAT\n    #ifdef ACCURATE_BOAT_REFLECTION\n    boatDist=MapBoat(p); \n    #else\n    // fake boat by using ellipsoid\n    boatDist=sdEllipsoid( TranslateBoat(p)- vec3(0, -0.20, -1.0), vec3(1.65, 1., 3.40));\n    #endif\n    \n  #endif\n\n    // mask tower position by placing a cone\n    return  vec4(min(treeDist,min(min(boatDist, bridgeDist), min(p.y - max(tHeight, 0.), sdConeSection(p-vec3(-143, 0., 292)-vec3(0., 13., 0.), 10.45, 3.70, 1.70)))), boatDist, bridgeDist, tHeight);\n}\n\n  // Full terrain map. Excludes tower mask\n  vec4 MapTerrain( vec3 p)\n{       \n  float boatDist= 10000.;\n  float bridgeDist=10000.;\n  treeDist = 10000.;\n  float water=0.;\n  float height = GetTerrainHeight(p); \n  float tHeight=mix(height, 4., smoothstep(12., 1.98, length(p.xz-vec3(-143, 0., 292).xz))); \n  float boulderHeight = GetBoulderHeight(p.xz, height);\n  float stoneHeight = GetStoneHeight(p.xz, tHeight);\n  tHeight+= mix(stoneHeight, 0., step(0.1, boulderHeight));\n\n  tHeight= mix(tHeight-.20, tHeight*1.4, smoothstep(0.0, 0.25, tHeight));\n\n  if (tHeight>0.)\n  {\n    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;\n\n    tHeight+=boulderHeight;\n      \n                   #ifdef TREES   \n      vec3 treePos = p-vec3(0.,tHeight+2.,0.);\n      vec2 mm = floor( treePos.xz/8.0 );\t\n\ttreePos.xz = mod( treePos.xz, 8.0 ) - 4.0;\n      \n      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);\n      \n      if(treeHeight>0.05)\n      {\n          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));\n                     treeDist+=(noise(p*1.26)*.6285);\n         treeDist+=(noise(p*3.26)*.395);\n           treeDist+=(noise(p*6.26)*.09825);\n      }\n    #endif\n      \n    #ifdef GRASS\n      tHeight+=GetFoliageHeight(p, height, stoneHeight, boulderHeight);\n    #endif\n\n  } else\n  {\n    water = GetWaterWave(p);\n  }\n\n    \n  #ifdef BRIDGE\n    bridgeDist=MapBridge(p);    \n  #endif\n    #ifdef BOAT\n    boatDist=MapBoat(p);\n  #endif\n    \n    return vec4(min(treeDist,min(min(boatDist, bridgeDist), p.y -  max(tHeight, -water*0.05))), boatDist, bridgeDist, height);\n}\n \nfloat MapWater(vec3 p)\n{\n  return p.y - (-GetWaterWave(p)*0.05);\n}\n\n#define calcFolNormal( pos, th, bh, sh ) normalize( vec3(GetFoliageHeight(pos+vec3(0.02, 0.0, 0.0).xyy, th, bh, sh) - GetFoliageHeight(pos-vec3(0.02, 0.0, 0.0).xyy, th, bh, sh), 0.5*2.0*vec3(0.02, 0.0, 0.0).x, GetFoliageHeight(pos+vec3(0.02, 0.0, 0.0).yyx, th, bh, sh) - GetFoliageHeight(pos-vec3(0.02, 0.0, 0.0).yyx, th, bh, sh) ) )\n#define calcNormal( pos) normalize( vec3(MapTerrain(pos+vec3(0.02, 0.0, 0.0).xyy).x - MapTerrain(pos-vec3(0.02, 0.0, 0.0).xyy).x, 0.5*2.0*vec3(0.02, 0.0, 0.0).x, MapTerrain(pos+vec3(0.02, 0.0, 0.0).yyx).x - MapTerrain(pos-vec3(0.02, 0.0, 0.0).yyx).x ) )\n#define calcNormalWater( pos) normalize( vec3(MapWater(pos+vec3(0.02, 0.0, 0.0).xyy) - MapWater(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*vec3(0.02, 0.0, 0.0).x, MapWater(pos+vec3(0.02, 0.0, 0.0).yyx) - MapWater(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n#define calcNormalMountains( pos) normalize( vec3(MapMountains(pos+vec3(0.02, 0.0, 0.0).xyy) - MapMountains(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*vec3(0.02, 0.0, 0.0).x, MapMountains(pos+vec3(0.02, 0.0, 0.0).yyx) - MapMountains(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n#define calcTexNormal(sam, p) ( vec3(normalize(vec3(textureLod(sam, p + vec2(-0.001, 0), 0.).r-textureLod(sam, p + vec2(+0.001, 0), 0.).r, textureLod(sam, p + vec2(0, -0.001), 0.).r-textureLod(sam, p + vec2(0, +0.001), 0.).r, .02))) * 0.5 + 0.5 )\n\nvec4 TraceFoliage( vec3 origin, vec3 direction, int steps, vec3 foliageMainColor)\n{\n  vec4 folCol = vec4(foliageMainColor, 0.);\n  float t = .0;\n  vec3 random = vec3(0.);\n  vec3 rayPos, nn;\n  float dif =0.0, densAdd =.0;\n  float folHeight = 0.0;\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    random = vec3(0.081*cos(float(i)));\n    rayPos = random+origin+direction*t;\n\n    float terrainHeight =GetTerrainHeight(rayPos);\n    float boulderHeight = GetBoulderHeight(rayPos.xz, terrainHeight);\n    float stoneHeight = GetStoneHeight(rayPos.xz, terrainHeight);\n    stoneHeight= mix(stoneHeight, 0., step(0.1, boulderHeight));  \n    folHeight = GetFoliageHeight(rayPos, terrainHeight, boulderHeight, stoneHeight);\n\n\n    if (folHeight>0.06)\n    {\n      nn= calcFolNormal(rayPos, terrainHeight, boulderHeight, stoneHeight);  \n      dif = max(0., dot( nn, sunPos ));\n      folCol.rgb+=0.1*dif;\n      folCol.a+=(1.-folCol.a)*0.1;\n    } \n    if (folCol.a>1.) break;\n\n    t+=0.015;\n  }\n\n  return clamp(folCol, 0., 1.);\n}\n\n\nbool TraceTerrainReflection( vec3 origin, vec3 direction, int steps)\n{\n  float precis = 0.00, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrainReflections( rayPos).x;\n    precis = 0.006*t;\n\n    if (dist<precis || t>400.0)\n    {             \n      return !(t>400.0);\n    }\n\n    t += dist;\n  }\n\n  return false;\n}\n\nRayHit TraceTerrain( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  vec4 dist = vec4(1000000.);\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrain( rayPos);\n    precis =0.001*t;\n\n    if (dist.x<precis || t>maxDist)\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;  \n      result.treeDist = treeDist;  \n      result.hitPos = origin+((direction*t));    \n      break;\n    }\n\n    t += dist.x*0.5;\n  }\n\n  return result;\n}\n\nRayHit TraceMountains( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  float dist=0.;\n  \n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapMountains( rayPos);\n    precis = 0.001*t;\n\n    if (dist<precis || t>maxDist)\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist.x = dist;   \n      result.hitPos = origin+((direction*t));    \n      break;\n    }\n\n    t += dist*1.;\n  }\n\n  return result;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res =1., t = 0.0, h;\n  vec3 rayPos = vec3(origin+direction*t);\n\n  for ( int i=0; i<NO_UNROLL(20); i++ )\n  {\n    h = MapTerrain(rayPos).x;\n\n    res = min( res, 8.5*h/t );\n    t += clamp( h, 0.01, 0.25);\n    if ( h<0.005 ) break;\n    rayPos = vec3(origin+direction*t);\n  }\n  return clamp( res, 0.0, 1.0 );\n}\nfloat SoftShadowTower( in vec3 origin, in vec3 direction, float res)\n{\n  float t = 0.0, h;\n  vec3 rayPos = vec3(origin+direction*t);\n\n  for ( int i=0; i<NO_UNROLL(11); i++ )\n  {\n\n    h = sdConeSection(rayPos-vec3(-143, 0., 292)-vec3(0., 12., 0.), 10.45, 2.40, 1.40);\n\n    res = min( res, 6.5*h/t );\n    t += clamp( h, 0.4, 1.5);\n    if ( h<0.005 ) break;\n    rayPos = vec3(origin+direction*t);\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\n#define colorStep 0.004\n  #define gradStep 0.0022\n\n  // create rain bow opposite direction to the sun\n  vec3 CalculateRainbow(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace)\n{  \n  float visibility = pow(max(0., dot(vec3(sunPos.x*-1., 0., sunPos.z*-1.), rayDir)), 20.0);  \n\n  // rainbow colors based on center distance\n  float colorPos = 0.05;\n  vec3 color = mix(vec3(0.), vec3(1.0, 0, 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ; \n  colorPos+=colorStep;\n  color = mix(color, vec3(1.0, 0.5, 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ; \n  colorPos+=colorStep;\n  color = mix(color, vec3(1.0, 1., 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.0, 1., 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.0, .20, 1.), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.0, .0, .9), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.3, .0, 1.), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(0.), smoothstep(colorPos, colorPos+gradStep, visibility)) ;                                   \n\n  // tone rainbow colors to transparent the closer to rayDir = 0.0 we get\n  return color*visibility*2.15*mix(0., 1.0,smoothstep(0.3, 0., length(0.3-rayDir.y)));\n}\n\n// set sky color tone. \nvec3 GetSkyColor(vec3 rayDir)\n{ \n    float sun = mix(0.,pow( clamp( 0.5 + 0.5*dot(sunPos,rayDir), 0.0, 1.0 ), 3.0 ),smoothstep(.33, .0, rayDir.y));\n    float sun2 = clamp( 0.75 + 0.25*dot(sunPos,rayDir), 0.0, 1.0 );\n    \n    vec3 col = mix(vec3(156,140,164)/255., vec3(166,134,150)/255.,smoothstep(0.8, 0.00, rayDir.y)*sun2);\n    col = mix(col, vec3(239,181,169)/255.,smoothstep(0.4, .0, rayDir.y)*sun2);\n    col = mix(col, vec3(255,190,136)/255.,smoothstep(.4, 1.0, sun));\n    col = mix(col, vec3(255,135,103)/255.,smoothstep(.8, 1.0, sun));\n    return col;\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<NO_UNROLL(3); i++ )\n  {\n    float hr = 0.01 + 0.15*float(i);\n    vec3 aopos =  nor * hr + pos;\n    float dd = MapTerrain( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.96;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 GetLightTerrain(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float illuminance)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);\n\n  float occ = 1.;\n  #ifdef PERFORM_AO_PASS\n    occ = calcAO(shadowPos, normal );\n  #endif\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n\n  #ifdef SHADOWS\n    float shadow=1.;\n  shadow = SoftShadow(shadowPos, sunPos);\n  shadow = min(shadow, SoftShadowTower(shadowPos, sunPos, shadow));\n  shadow = max(illuminance, shadow);\n  dif*=shadow;\n  #endif\n    \n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  lightTot += 3.*dif*sunColor;\n\n  lightTot += .65*amb*vec3(0.35, 0.45, 0.6)*occ;  \n  lightTot += 0.60*skylight*clamp(GetSkyColor(reflectDir), 0., 1.)*occ;\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  lightTot = mix( lightTot, lightTot*2., fre );\n\n  return clamp(lightTot, 0.22, 10.);\n}\n\nvec3 GetLightMountains(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n    \n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n\n  lightTot += 3.*dif*sunColor;\n\n  lightTot += .65*amb*vec3(0.35, 0.45, 0.6);  \n  lightTot += 0.60*skylight*clamp(GetSkyColor(reflectDir), 0., 1.);\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  lightTot = mix( lightTot, lightTot*2., fre );\n\n  return clamp(lightTot, 0.22, 10.);\n}\n\nvec3 GetLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  vec3 reflectDir = reflect( rayDir, normal );\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 3.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  const vec3 reflection = vec3(1.0);\n  vec3 lightTot = vec3(0.0);\n\n  lightTot += 3.*dif*sunColor;\n\n  vec3 skyCol = GetSkyColor(reflectDir);\n\n  lightTot += 0.5*amb*vec3(0.35, 0.45, 0.6);  \n  lightTot += 0.70*skylight*skyCol;\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  lightTot = mix( lightTot, lightTot+skyCol, fre );\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  float mixValue = smoothstep(50., 15000., depth);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  // horizontal fog\n  vec3 fogColor = sunColor*0.7;  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 0.5, sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  // vertical fog\n  const float heightAmount = .008;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))/rayDir.y;\n  color = mix(color, fogColor, min(0.5, fogAmount));\n}\n// https://www.shadertoy.com/view/MtsGWH\nvec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = texture( sam, p.yz );\n  vec4 y = texture( sam, p.zx );\n  vec4 z = texture( sam, p.xy );\n  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\nvec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = textureLod( sam, p.yz ,0.);\n  vec4 y = textureLod( sam, p.zx ,0.);\n  vec4 z = textureLod( sam, p.xy ,0.);\n  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n\n#define MOSSCOLOR (vec3(29, 39, 31)/255.)\n#define MOSSCOLOR2 (vec3(74, 80, 59)/315.)\n#define TREECOLOR col.rgb = (0.2+(0.8*abs(noise(marchResult.hitPos*2.))))*vec3(.9, 1., .8)*0.3;\n\nvec3 GetBridgeTexture(RayHit marchResult)\n{\n  vec3 checkPos = TranslateBridge(marchResult.hitPos); \n  vec3 woodTexture = vec3(BoxMap(iChannel1, vec3(checkPos.z*0.01, checkPos.yx*0.31), (marchResult.normal), 0.5).r);\n  vec3 bridgeColor =  woodTexture*(0.6+(0.4*noise(checkPos.zx*17.)));\n  float n = noise2D(checkPos.xz*1.3);\n  return mix(bridgeColor*MOSSCOLOR2, bridgeColor, smoothstep(-.64-(2.*n), 2.269-(2.*n), marchResult.hitPos.y));\n}\n\nvec3 GetBoatTexture(RayHit marchResult)\n{\n  vec3 checkPos = TranslateBoat(marchResult.hitPos); \n  vec3 bCol= vec3(62, 52, 47)*1.3/255.;\n  float frontDist = max(0., (0.25*(0.16*pow(length(checkPos.z-0.), 2.))));\n  float n = 1.+(0.2*noise(vec3(checkPos.zx*0.01, checkPos.x)*34.));\n  n *= 0.9+(0.1*noise2D(checkPos.xy*26.));  \n  bCol = mix(vec3(0.6), bCol*n, step(-0.625, checkPos.y-frontDist));\n  bCol = mix(vec3(0.05), bCol, step(0.08, length(-.7-(checkPos.y-frontDist))));\n  bCol = mix(bCol*0.8, bCol*1.2, smoothstep(0., 0.18, length(-0.23-(checkPos.y-frontDist))));   \n  bCol = mix(bCol, bCol*0.47, smoothstep(0.0, 0.32, length(0.-mod(checkPos.y-frontDist, 0.3)))); \n  return mix(bCol, bCol*0.8, smoothstep(-.1, 0.8, noise2D(checkPos.xz*3.7)));  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  wind= (vec3(0.05, -0.1, -0.1)*(cos((iTime)*2.)*sin((iTime)*.5)));\n  cloudPos = vec2(-iTime*1.3, -iTime*1.65);\n  sunPos =  readRGB(ivec2(50, 0));\n  vec3 camData  = readRGB(ivec2(52, 0));  \n\n  // setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  vec3 rayOrigin = vec3(vec3(-143, 0., 292).x+camData.z*cos(camRot.x), camData.y, vec3(-143, 0., 292).z+camData.z*sin(camRot.x) );    \n  rayOrigin.y = readRGB(ivec2(62, 0)).y;\n  mat3 ca = setCamera( rayOrigin, vec3(vec3(-143, 0., 292).x, camData.y+(11.*camRot.y), vec3(-143, 0., 292).z ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n    \n\n  // create sky color fade\n  vec4 color = vec4(0.,0.,0.,10000.);\n  color.rgb  =  GetSkyColor(rayDir);\n\n  // add volumetric clouds (top)\n  if (rayDir.y>0.)\n  {  \n    vec4 cloudColor=TraceCloudsBelow(rayOrigin, rayDir, color.rgb, 90);    \n\n      \n    // make clouds slightly light near the sun\n    float sunVisibility = pow(max(0., dot(sunPos, rayDir)), 2.0)*0.25;\n    color.rgb = mix(color.rgb, max(vec3(0.), mix(cloudColor.rgb,cloudColor.rgb,.6)+sunVisibility), cloudColor.a);  \n    color.rgb +=  CalculateRainbow(rayDir, rayOrigin, screenSpace);\n            \n  \n    // color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);       \n    color.a+=cloudColor.a*0.86;\n  }\n    \n  #ifdef TERRAIN\n\n    vec3 skyColor = GetSkyColor(rayDir);\n    RayHit marchResult = TraceTerrain(rayOrigin, rayDir, 500, 1000.);\n\n\n    // is terrain hit?\n    if (marchResult.hit)\n    { \n      vec3 col;\n      float alpha=1.0;\n\n      float specLevel=1.;\n      col=color.rgb;\n\n      vec3 light;\n\n      float terrainHeight =marchResult.dist.w;\n      float stoneHeight = GetStoneHeight(marchResult.hitPos.xz, terrainHeight);     \n      float treeHeight =GetTreeHeight(marchResult.hitPos.xz,marchResult.hitPos.xz, terrainHeight);\n   \n      // check if terrain is below water level\n      if (terrainHeight<-stoneHeight && marchResult.dist.x!=marchResult.dist.z && marchResult.dist.x!=marchResult.dist.y)\n      {\n        marchResult.normal = calcNormalWater(marchResult.hitPos);  \n        \n        vec3 terrainHit = rayOrigin+((rayDir*marchResult.depth)*0.985);\n        vec3 refDir = reflect(rayDir, marchResult.normal);\n        vec4 testClouds = vec4(0.);        \n        col = vec3(0.3);\n\n        vec3 bottomColor =  clamp(vec3(textureLod(iChannel3, marchResult.hitPos.xz*0.13, 0.2).r*clamp( dot( calcTexNormal(iChannel3, (marchResult.hitPos.xz*0.1)+marchResult.normal.xz), sunPos ), 0.0, 1.0 )*vec3(1., 0.9, 0.7)), 0.2, 0.6);\n\n        col = mix(col, bottomColor, smoothstep(-0.65, -0.33, terrainHeight));\n\n        // calculate water fresnel  \n        float fresnel = pow(1.0-abs(dot(rayDir, marchResult.normal)), 4.);  \n\n        // col.rgb  = mix(col*.7, col.rgb, smoothstep(-3.0, -0.15, marchResult.hitPos.y));\n        col = col+((sunColor*pow(max(0., dot(sunPos, rayDir)), 5.0))*0.5);\n\n        vec3 reflection = col;\n\n        #ifdef QUALITY_REFLECTIONS\n          // get cloud reflections for water\n          testClouds = TraceCloudsBelow(terrainHit, refDir, skyColor, 30);\n        // cast rays from water surface onto terrain. If terrain is hit, color water dark in these areas.    \n        if (TraceTerrainReflection(terrainHit, refDir, 40))\n        {\n          reflection  = mix(col, vec3(.01, 0.03, .0), 0.9);\n        }\n        #endif\n\n\n          light = GetLightWater(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n        col=mix(mix(col.rgb, testClouds.rgb, testClouds.a), mix(col.rgb, testClouds.rgb, testClouds.a), smoothstep(0., 0.7, fresnel)); \n        col=mix(mix(col.rgb, reflection, 0.5), reflection, smoothstep(0., 0.3, fresnel)); \n        col=mix(mix(col.rgb, ((col+noise2D((marchResult.hitPos.xz)*24., 1.0))+vec3(0.5, 0.4, .1))*0.3, smoothstep(0., 1.0, marchResult.hitPos.y)), col+(0.5*fresnel), smoothstep(0., 0.3, fresnel)); \n\n\n        col=col*light;\n\n        col = mix(col, skyColor, smoothstep(320., 400., marchResult.depth));\n      } \n      // terrain is ABOVE water level  \n      else\n      {\n         marchResult.normal = calcNormal(marchResult.hitPos);  \n\n          float boulderHeight = GetBoulderHeight(marchResult.hitPos.xz, terrainHeight)-treeHeight;     \n          float foliageHeight = GetFoliageHeight(marchResult.hitPos, terrainHeight, boulderHeight, stoneHeight)-treeHeight;     \n\n          float noiseMedium = noise(marchResult.hitPos*23.3);\n          float noiseLarge = noise(marchResult.hitPos*0.3); \n          vec4 fColor = vec4(0.0);\n\n          //texture bridge\n          if ( length(marchResult.dist.x-marchResult.dist.z)<0.01)\n          {\n            col.rgb = GetBridgeTexture(marchResult);\n              specLevel*=1.45*col.r;\n          }\n          //texture boat\n          else if ( length(marchResult.dist.x-marchResult.dist.y)<0.01)\n          { \n            col.rgb = GetBoatTexture(marchResult);\n            specLevel*=col.r;\n          }\n          else if ( length(marchResult.dist.x-marchResult.treeDist)<0.01)\n          { \n       \n           TREECOLOR;\n           \n          }\n          // texture terrain\n          else\n          {\n            // create terrain texture\n            #ifdef LOWRES_TEXTURES\n            vec3 colorRocks= vec3(BoxMapFast(iChannel3, marchResult.hitPos*0.61, (marchResult.normal), 0.5).r);\n            vec3 colorRocks2 = vec3(BoxMapFast(iChannel3, marchResult.hitPos*0.11, (marchResult.normal), 0.5).r);\n            #else\n            vec3 colorRocks= vec3(BoxMap(iChannel3, marchResult.hitPos*0.61, (marchResult.normal), 0.5).r);\n            vec3 colorRocks2 = vec3(BoxMap(iChannel3, marchResult.hitPos*0.11, (marchResult.normal), 0.5).r);           \n            #endif\n              \n            colorRocks = mix(colorRocks, colorRocks2, 0.5);\n\n            float moss =  0.75*(1.2+noiseMedium);\n            vec3 grassCol = vec3(.15, .14, .10);\n            vec3 dirtCol =vec3(.2, .16, .14);\n            col =colorRocks;\n\n            float mossAmount = mix(mix(1., 0.47, max(0., noiseMedium)), 0., max(0., marchResult.normal.z));\n\n            // create boulder texture\n            vec3 boulderColor = mix(colorRocks2, colorRocks*1.4, marchResult.normal.y);\n            // add boulder moss\n            boulderColor = mix(boulderColor*(0.6+(0.5*noiseMedium)), vec3(0.48+(0.4*abs(noiseMedium))), smoothstep(0., .7, noiseLarge));\n            boulderColor = mix(mix(moss*MOSSCOLOR2, boulderColor*0.67, max(0., noiseMedium)), boulderColor, max(0., marchResult.normal.z));\n\n            // add stone moss\n            vec3 stoneColor = mix(colorRocks2, colorRocks*1.4, marchResult.normal.y);\n            stoneColor = mix(stoneColor*(0.8+(0.2*noiseMedium)), vec3(0.8), smoothstep(0., 1.5, noiseMedium));\n            stoneColor = mix(mix(moss*MOSSCOLOR*1.4, stoneColor, smoothstep(0.7, 0.9, stoneHeight)), boulderColor*(0.74+(0.5*noiseMedium)), smoothstep(.0, 2.57, terrainHeight));\n\n         \n            vec3 foliageCol = mix(vec3(216., 156, 101)/255., vec3(216., 156, 101)/355., smoothstep(0.20, .50, max(0., noiseMedium)));\n            foliageCol = mix(vec3(0.16), foliageCol, smoothstep(0.0, 0.74, max(0., foliageHeight)));\n               \n        \n                  // apply textures\n            col.rgb = mix(col.rgb, stoneColor, smoothstep(0.02, 0.7, stoneHeight));\n            col.rgb = mix(col.rgb, boulderColor, smoothstep(0.02, .30, boulderHeight));   \n            col.rgb = mix(col.rgb, foliageCol, step(0.01, foliageHeight));\n              \n            specLevel = mix(specLevel, 5.*stoneColor.r, step(.03, stoneHeight));\n            specLevel = mix(specLevel, mix((3.2*boulderColor.r), 1.5*boulderColor.r, mossAmount), step(.03, boulderHeight));\n            specLevel = mix(specLevel, 0.15, step(.03, foliageHeight));\n              \n          #ifdef QUALITYFOLIAGE\n            fColor = TraceFoliage(marchResult.hitPos+marchResult.normal*0.004, rayDir, 32, vec3(0.55, 0.36, 0.45));    \n          #endif\n          }      \n\n          // get lightning based on material\n          light = GetLightTerrain(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin, 0.0);   \n          col = col*light;         \n          col =mix( col,  saturate(mix(col, fColor.rgb* vec3(1., 0.7, 0.47), 0.55)), fColor.a );       \n      }\n      \n\n      col = mix(col, (col+sunColor)*0.6, smoothstep(70., 600., marchResult.depth));\n\n      ApplyFog(col, skyColor, rayOrigin, rayDir, marchResult.depth);\n      color.rgb = col; \n      color.a= marchResult.depth;\n    } \n    else  // if main trace missed terrain, continue from last ray postion and trace mountains\n    {\n      RayHit marchResult2 = TraceMountains(rayOrigin+(rayDir*marchResult.depth*0.7), rayDir, 100, 1000.);\n\n      // mountains hit\n      if (marchResult2.hit)\n      {\n        marchResult2.normal = calcNormalMountains(marchResult2.hitPos);  \n \n        // adding some slight haze at mountain bottom\n        vec3 col = vec3(0.5);\n\n        vec3 light = GetLightMountains(0.6, marchResult2.normal, marchResult2, rayDir, rayOrigin);   \n        col = col*light;\n        col = mix(col, (col+sunColor)*0.6, smoothstep(70., 600., marchResult2.depth));\n        col = mix(mix(col,vec3(.9, 0.7, 0.57)*(.4+1.27*abs(noise((marchResult2.hitPos.xz-vec2(iTime*17.0,0))*0.02))),0.5),col,smoothstep(0.,70.,marchResult2.hitPos.y));\n\n        ApplyFog(col, skyColor, rayOrigin, rayDir, marchResult.depth);\n        color.rgb = col; color.a=500.;\n      }\n    }\n  #endif\n    \n  fragColor = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// TOWER BUFFER  -   RENDERS TOWER ONLY\n//////////////////////////////////////////////////////////////////////////////////////\n// Channel 0 = Buffer C. Capture rendered data from previous buffer\n// Channel 1 = Buffer D. This buffer for use in AA pass.\n// Channel 2 = Buffer A. Read data from data-buffer.\n// Channel 3 = Organic3 texture. Used to create tower stone look.\n#define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n#define PI 3.14159265359\n#pragma optimize(off) \n#define NO_UNROLL(X) (X + min(0,iFrame))\n\n// Delete one or several of below defines to increase performance\n//#define PERFORM_AO_PASS\n#define PERFORM_AA_PASS\n#define SHADOWS\n//#define HIGH_QUALITY\n\n// Try enabling below define if shader doesn´t compile\n//#define LOWRES_TEXTURES\n\nvec3 sunPos = normalize( vec3(0.50, 1.0, 1.0) );\n\nfloat winDist=100000.0;\nfloat dekoDist=100000.0;\nfloat steelDist=100000.0;\nfloat lampDist=100000.0;\nfloat doorDist=100000.0;\n\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float winDist;\n  float dekoDist;\n  float steelDist;\n  float glassDist;\n  float lampDist;\n  float doorDist;\n};\n\n\nfloat noise(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat fCylinderH(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat fCylinderV(vec3 p, float r, float height) {\n  float d = length(p.yz) - r;\n  d = max(d, abs(p.x) - height);\n  return d;\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n  return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nvec2 pModPolar(in vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a, angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return p;\n}\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n#define pR(p, a) (p)*=r2(a)\n\n\n  float pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) { //yes, this might not be the best thing numerically.\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\n\nfloat SmallWindow( vec3 p)\n{\n  // AABB\n  if ( sdBox(p-vec3(-.65, 1.17, 0.0), vec3(1.))<0.1) \n  {\n    // window base\n    float d= sdBox(p-vec3(-.65, 1.17, 0.0), vec3(0.08, 0.4, 0.4));       \n    // window cutouts\n    d= max(d, -sdBox(p-vec3(-.06, 1.17, 0.0), vec3(0.54, 0.36, .36))); \n    d= max(d, -sdBox(p-vec3(-.22, 1.17, 0.0), vec3(0.54, 0.32, .32))); \n    // deco above window  \n    d= min(d, sdBox(p-vec3(-0.58, 1.6, 0.), vec3(0.165, 0.04, 0.5)));\n    // window steel vertical \n    steelDist= min(steelDist, sdBox(p-vec3(-.62, 1.17, 0.0), vec3(0.02, 0.32, 0.02))); \n    // window steel horizontal \n    vec3 winPos = p-vec3(-.62, 1.03, 0.0);\n    pModInterval1(winPos.y, 0.25, 0., 1.0);\n    steelDist= min(steelDist, sdBox(winPos, vec3(0.007, 0.018, 0.38))); \n    // deco below window  \n    d= min(d, sdBox(p-vec3(-.59, .71, 0.), vec3(0.13, 0.05, 0.45)));\n    d= min(d, sdBox(p-vec3(-.59, 0.69, 0.), vec3(0.18, 0.025, 0.50)));\n    // deco in the middle below window\n    d= min(d, sdBox(p-vec3(-0.70, .49, 0.), vec3(0.25, 0.2, 0.07)));   \n    d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.32, .25, 0.), 0.23, 1.63), 0.03);\n    return d;\n  }\n  else\n  {\n      return 10000.;\n  }\n}\n\n\nfloat Window( vec3 p)\n{\n  // window base\n  float d= sdBox(p-vec3(-0.58, 1.07, 0.), vec3(0.075, 0.6, 0.4));\n\n  if (d<2.0)\n  {  \n    // window cutouts\n    d = max(d, -sdBox(p-vec3(-0.28, 1.07, 0.), vec3(0.25, 0.60, 0.34)));\n    d= max(d, -sdBox(p-vec3(-0.21, 1.05, 0.), vec3(1.4, 0.5, 0.25))); \n    d= min(d, sdBox(p-vec3(-0.58, 1.7, 0.), vec3(0.325, 0.06, 0.48)));\n\n    // window steel vertical \n    steelDist= min(steelDist, sdBox(p-vec3(-0.55, 1.17, 0.), vec3(0.01, 0.60, 0.02))); \n\n    // window steel horizontal \n    vec3 winPos = p-vec3(-0.55, 0.75, 0.);\n    pModInterval1(winPos.y, 0.30, 0., 2.0);        \n    steelDist= min(steelDist, sdBox(winPos, vec3(0.01, 0.02, 0.4))); \n\n    d=min(d, max(max(fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.42, 0.13), -sdBox(p-vec3(-0.5, 1.49, 0.), vec3(1., 0.27, 1.5))), -fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.38, 0.53)));\n\n    d= min(d, sdBox(p-vec3(-.52, .42, 0.), vec3(0.13, 0.05, 0.45)));\n    d= min(d, sdBox(p-vec3(-.52, 0.40, 0.), vec3(0.18, 0.025, 0.50)));\n\n    // lower decoration \n    d= min(d, sdBox(p-vec3(-0.55, .20, 0.4), vec3(0.15, 0.2, 0.05)));   \n    d= min(d, sdBox(p-vec3(-0.55, .20, -0.4), vec3(0.15, 0.2, 0.05)));\n    d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.3, .0, 0.), 0.23, 1.63), 0.02);\n\n    // upper decoration \n    dekoDist=min(dekoDist, sdBox(p-vec3(-0.55, 2.63, 0.), vec3(0.3, 0.45, 0.12)));    \n    dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(p-vec3(-0.22, 2.45, -0.1), 0.21, 0.63), 0.03);\n  }\n  return d;\n}\n\n\n\n\n#define radius 1.6\n#define outRad 1.82\n#define inRad 1.12\n\nfloat Map(  vec3 p)\n{\n\n  p.y-=21.25;\n  float  d=100000.0;\n  vec3 checkPos = p;\n  winDist=dekoDist=steelDist=lampDist=doorDist = 100000.0;\n  d=sdCappedCylinder(p-vec3(0.0, -3.0, 0), vec2(3.20, 12.45));\n  if (d>.2) return d;\n\n  float noiseScale=(1.+(0.01*abs(noise(p*22.))));\n  float noiseScale2=(1.+(0.03*abs(noise(p*13.))));\n\n  d = sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45));\n\n  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius*noiseScale, 1.80));\n  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4*noiseScale, 1.7*noiseScale));\n  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8*noiseScale, 2.6*noiseScale));\n\n  // roof /////////////////\n  dekoDist=min(dekoDist, sdConeSection(p-vec3(0., 6.7, 0), 0.40, 1.2, 0.8)); \n\n  checkPos = p;\n  checkPos.xz = pModPolar(checkPos.xz, 26.0);   \n  checkPos-=vec3(1.2, 6.7, 0);\n  pR(checkPos.xy, 0.5);\n\n  dekoDist=fOpUnionChamfer(dekoDist, sdCappedCylinder(checkPos, vec2(0.08, 0.47)), 0.1); // roof\n\n  steelDist=min(steelDist, sdSphere(p-vec3(0., 6.6, 0), 1.05));    \n  vec3 pp = p-vec3(0., 8., 0);\n  float m = pModInterval1(pp.y, -0.14, 0.0, 2.);         \n  steelDist=min(steelDist, sdSphere(pp, 0.20+(0.12*m)));   \n  steelDist = fOpUnionChamfer(steelDist, sdCapsule(p-vec3(0., 8., 0), vec3(0, 0., 0), vec3(0, 1.0, 0), 0.013), 0.1);\n\n  checkPos = p;\n  // deko and windows steel top\n  checkPos.xz = pModPolar(p.xz, 12.0);\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(outRad+0.05, 3.6, 0), vec2(0.03, .42))); // top railing\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(inRad-0.06, 4.4, 0), vec2(0.02, 1.45))); // window grid\n  steelDist=min(steelDist, sdBox(checkPos-vec3(inRad-0.19, 6.25, 0), vec3(0.25, .3, 0.25)));\n  steelDist=fOpIntersectionChamfer(steelDist, -sdBox(checkPos-vec3(inRad+0.20, 6.25, 0), vec3(0.19, 0.24, 0.19)), 0.12);\n  // top window grid\n  pp = p-vec3(0.0, 4.4, 0);\n  pModInterval1(pp.y, 0.4, 0.0, 2.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(inRad-0.02, .02)));  \n\n  // top railing\n  pp = p-vec3(0.0, 3.55, 0);\n  m = pModInterval1(pp.y, 0.15, 0.0, 3.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(outRad+0.05, mix(0.02, .035, step(3., m)))));\n\n  #ifdef HIGH_QUALITY  \n  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));\n  // lamp\n  lampDist = sdEllipsoid(p-vec3(0., 4.9, 0), vec3(0.5, 0.6, 0.5)*(1.+abs(0.1*cos(p.y*50.))));\n  lampDist = min(lampDist, sdCappedCylinder(p-vec3(0.0, 4.5, 0), vec2(0.12, 1.2)));    \n  d=min(d, lampDist);\n  #endif\n    \n  // tower \"rings\"\n  pp = p-vec3(0.0, 4., 0);\n  m = pModInterval1(pp.y, 1.8, 0.0, 1.);  \n  dekoDist=min(dekoDist, sdTorus(pp, vec2(inRad, mix(.11, 0.15, step(1., m)))));                  \n\n  // upper \"rings\"\n  pp = p-vec3(0.0, -0.6, 0);\n  m = pModInterval1(pp.y, -1.05, 0.0, 1.);   \n  dekoDist=min(dekoDist, sdTorus(pp, vec2(mix(radius+0.15, radius+0.08, step(1., m)), 0.15)));                  \n\n\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -.35, 0), vec2(radius-0.05, .15)));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, -.5, 0), radius+0.02, .15));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.18, 0), radius+0.35, 0.15));  \n\n  // upper decoration\n  pp = p-vec3(0.0, 2.7, 0);     \n  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.10, .30)); pp.y-=.15;\n  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.28, 0.18)); pp.y-=.15;\n  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.46, 0.18));\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  dekoDist = max(dekoDist, -fCylinderV(checkPos-vec3(0.0, 2.4, 0), 0.6, 2.63));\n\n  // middle and lower \"rings\"\n  pp = p-vec3(0.0, -9., 0);\n  m = pModInterval1(pp.y, -2.3, 0.0, 1.);    \n  dekoDist=min(dekoDist, sdTorus(pp, vec2( mix( radius+0.6, 2.42, step(1., m)), .25))); \n\n  #ifdef HIGH_QUALITY\n  // windows cutouts   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  d=max(d, -sdBox(checkPos-vec3(2.20, 1.07, 0.), vec3(3.25, 0.6, 0.4))); \n  checkPos.xz = pModPolar(p.xz, 5.0); \n  pp = checkPos-vec3(2.50, -6.83, 0.);\n  pModInterval1(pp.y, 3.5, 0.0, 1.);         \n  d= max(d, -sdBox(pp, vec3(1.3, 0.35, 0.35)));  \n  #endif\n\n  // upper windows   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  winDist = min(winDist, Window(checkPos-vec3(2.20, 0, 0.))); \n\n  // small windows  (upper deco)\n  checkPos.xz = pModPolar(p.xz, 5.0); \n\n  pp = checkPos-vec3(2.10, -2.44, 0.0);\n  m=pModInterval1(pp.y, -3.5, 0., 1.);\n\n  pp-=mix(vec3(0.), vec3(0.28, 0.0, 0.), m);\n  dekoDist=min(dekoDist, sdBox(pp, vec3(0.3, 0.4, 0.12)));   \n  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(pp+vec3(-.30, -0.4, 0.0), 0.21, 0.63), .03); \n  dekoDist = max(dekoDist, -fCylinder(pp+vec3(-.40, .22, 0.0), 0.51, 0.63));  \n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -2.26 - (m*3.55), 0), vec2(radius+0.25, .15)*(1.0+(m*0.14))));\n\n  // small windows  \n  pp = checkPos-vec3(2.82, -8.0, 0.);\n  m=pModInterval1(pp.y, 3.5, 0., 1.);\n  winDist = min(winDist, SmallWindow(pp+mix(vec3(0.), vec3(0.28, 0.0, 0.), m)));   \n\n  #ifdef HIGH_QUALITY\n  // make tower hollow\n  d=max(d, -sdConeSection(p-vec3(0.0, -6.0, 0.), 5., 2.3, 1.55));\n  #endif\n    \n  dekoDist=min(dekoDist, sdTorus(p-vec3(0., -15.2, 0), vec2(2.5, .75*noiseScale2))); \n  \n  dekoDist=min(dekoDist, fCylinder(p-vec3(-0.05, -12.95, 2.25), 0.7, 0.5)); \n\n  // create door opening    \n  float doorOpening = min(sdBox(p-vec3(-0.05, -13.9, 2.5), vec3(1.3, 1.4, 4.6)), fCylinder(p-vec3(-0.05, -12.75, 2.5), 0.6, 4.6));\n\n  dekoDist = min(fOpPipe(dekoDist, doorOpening, 0.13), max(dekoDist, -doorOpening));\n\n  checkPos.xz = pModPolar(p.xz, 8.0);\n  d=fOpIntersectionChamfer(d, -fCylinderH(checkPos-vec3(2.95, -15.4, 0), 0.2, 3.6), 0.5);    \n  checkPos.xz = pModPolar(p.xz, 16.0);\n  d=fOpUnionChamfer(d, fCylinderH(checkPos-vec3(2.2, -10.3, 0), 0.03, 0.8), 0.4);    \n\n  d=max(d, -sdBox(p-vec3(-0., -14., 2.7), vec3(0.6, 1.3, 4.6)));    \n  d=max(d, -fCylinder(p-vec3(-0., -12.7, 2.5), 0.6, 4.6));    \n\n  // door   \n  doorDist =sdBox(p-vec3(-0., -13.6, 2.0), vec3(0.6, 1.3, 0.4)); \n\n  // door cutout     \n  pp = p-vec3(-0.28, -13., 2.4);\n  pModInterval1(pp.x, 0.46, 0., 1.);     \n  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.25, 0.08)));   \n  pp = p-vec3(-0.28, -13.8, 2.4);   \n  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.4, 0.08))); pp.x-=0.46;\n  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.4, 0.08))); \n\n  pp = p-vec3(-0., -15.20, 3.30);\n  pp.z+=0.3; pp.y-=0.15;\n  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  \n  pp.z+=0.3; pp.y-=0.15;\n  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  \n      pp.z+=0.3; pp.y-=0.15;\n  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  \n  d=min(d, steelDist);\n  d=min(d, dekoDist);\n  d=min(d, winDist);\n  d=min(d, doorDist);\n  return  d;\n}\n\n\n\n\nfloat MapGlass(  vec3 p)\n{   \n\n  p.y-=21.25;\n  vec3 checkPos = p;\n  // tower windows\n  float d = sdCappedCylinder(p-vec3(0.0, 5.0, 0), vec2(1.00, .8));\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  // upper windows\n  #ifdef HIGH_QUALITY\n  d = min(d, sdBox(checkPos-vec3(1.550, 1.1, 0.), vec3(0.01, .60, 0.3)));   \n  #else\n  d = min(d, sdBox(checkPos-vec3(1.62, 1.1, 0.), vec3(0.01, .60, 0.3)));   \n  #endif  \n  checkPos.xz = pModPolar(p.xz, 5.0);\n  // middle and lower windows \n  #ifdef HIGH_QUALITY\n  checkPos-=vec3(2.03, -6.8, 0.);\n  #else\n  checkPos-=vec3(2.18, -6.8, 0.);\n  #endif\n    float m=pModInterval1(checkPos.y, 3.5, 0., 1.);\n  return min(d, sdBox(checkPos+mix(vec3(0.), vec3(0.28, 0.0, 0.), m), vec3(0.01, 0.4, .3)));\n}\n\n\n#define calcNormal( pos ) normalize( vec3(Map(pos+vec3(0.02, 0.0, 0.0).xyy) - Map(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*0.02, Map(pos+vec3(0.02, 0.0, 0.0).yyx) - Map(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n\n  float SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 1.0, t = 0.0, h;\n  for ( int i=0; i<NO_UNROLL(16); i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 7.5*h/t );\n    t += clamp( h, 0.02, 0.15);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nRayHit March( vec3 origin, vec3 direction, float maxDist)\n{\n  RayHit result;\n  float t = 0.0, dist = 0.0, glassDist=100000.0;\n  vec3 rayPos = vec3(0.);\n    float td=0.;\n  float precis=.0;\n  for ( int i=0; i<NO_UNROLL(120); i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n    #ifdef HIGH_QUALITY\n    if(glassDist>0.05)\n    { \n      glassDist = min(glassDist, MapGlass(rayPos));\n    }\n    #else\n    glassDist =MapGlass(rayPos);\n    dist=min(dist,glassDist); \n    #endif\n    precis = 0.001*t;\n    if (dist<precis || t>maxDist )\n    {\n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+direction*(t-td);   \n      result.winDist = winDist;\n      result.dekoDist = dekoDist;\n      result.glassDist = glassDist;\n      result.steelDist = steelDist;\n      result.lampDist = lampDist;\n      result.doorDist = doorDist;\n      break;\n    }\n    td= dist*0.65;\n      t+=td;\n  }    \n\n\n  return result;\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<NO_UNROLL(3); i++ )\n  {\n    float hr = 0.01 + 0.1*float(i);\n    vec3 aopos =  nor * hr + pos;\n    float dd = Map( aopos );\n    occ += -(dd-hr)*sca;\n    sca *= 0.93;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// set sky color tone. \nvec3 GetSkyColor(vec3 rayDir)\n{ \n  float sun = mix(0., pow( clamp( 0.5 + 0.5*dot(sunPos, rayDir), 0.0, 1.0 ), 3.0 ), smoothstep(.33, .0, rayDir.y));\n  float sun2 = clamp( 0.75 + 0.25*dot(sunPos, rayDir), 0.0, 1.0 );\n\n  vec3 col = mix(vec3(156, 140, 164)/255., vec3(166, 134, 150)/255., smoothstep(0.8, 0.00, rayDir.y)*sun2);\n  col = mix(col, vec3(239, 181, 169)/255., smoothstep(0.4, .0, rayDir.y)*sun2);\n  col = mix(col, vec3(255, 190, 136)/255., smoothstep(.4, 1.0, sun));\n  col = mix(col, vec3(255, 135, 103)/255., smoothstep(.8, 1.0, sun));\n\n  col = mix(col, col+vec3(1.0, 0.96, 0.90), pow(max(0., dot(sunPos, rayDir)), 14.0));\n\n  return col;\n}\n\n\n\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)\n{         \n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float occ = 1.;\n  #ifdef PERFORM_AO_PASS\n    occ = calcAO( rayHit.hitPos, normal );\n  #endif\n\n    vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 );\n\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.; \n  #ifdef SHADOWS\n    shadow = SoftShadow(rayHit.hitPos+normal*0.001, sunPos);\n  #endif\n    dif*=shadow;\n\n  lightTot += 1.6*dif*sunColor;\n\n  lightTot += 0.75*amb*vec3(0.35, 0.45, 0.6)*occ;  \n  lightTot += 0.270*skylight*GetSkyColor(reflectDir)*occ;\n  lightTot += 1.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 2.0)*occ;\n  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );\n  lightTot = mix( lightTot, lightTot+ vec3(3.)*vec3(0.9, 0.6, 0.57), fre );\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  float mixValue = smoothstep(50., 15000., pow(depth, 2.)*0.03);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  // horizontal fog\n  vec3 fogColor = mix(sunColor*0.7, skyColor, mixValue);  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 0.5, sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  // vertical fog\n  const float heightAmount = .008;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))/rayDir.y;\n  color = mix(color, fogColor, fogAmount);\n}\n\n// https://www.shadertoy.com/view/MtsGWH\nvec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = texture( sam, p.yz );\n  vec4 y = texture( sam, p.zx );\n  vec4 z = texture( sam, p.xy );\n  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\nvec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = textureLod( sam, p.yz ,0.4);\n  vec4 y = textureLod( sam, p.zx ,0.4);\n  vec4 z = textureLod( sam, p.xy ,0.4);\n  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nvec4 GetMaterial(vec3 rayDir, inout RayHit rayHit, vec2 fragCoord, inout float specSize)\n{\n  vec2 center;\n  float dist;\n\n  float specLevel=1.;\n  specSize=12.8;\n\n  #ifdef LOWRES_TEXTURES\n  vec3 tex =  BoxMapFast(iChannel3, rayHit.hitPos*0.22, rayHit.normal, 0.5).rgb; \n  vec3 dirtTex =  BoxMapFast(iChannel3, (rayHit.hitPos+vec3(10000.0))*0.13, rayHit.normal, 0.5).rgb;   \n  #else\n  vec3 tex =  BoxMap(iChannel3, rayHit.hitPos*0.22, rayHit.normal, 0.5).rgb; \n  vec3 dirtTex =  BoxMap(iChannel3, (rayHit.hitPos+vec3(10000.0))*0.13, rayHit.normal, 0.5).rgb;   \n  #endif\n\n  float noiseTex = abs(noise(rayHit.hitPos*0.2));\n\n  vec3 scratches = dirtTex*tex;\n\n  vec3 altCol =dirtTex;\n\n\n  vec3 col = mix(mix(tex, vec3(1.3), 0.6), 0.7*dirtTex, smoothstep(0.196, 0.36, scratches.r));\n  altCol = mix(altCol, vec3(1.), smoothstep(0.196, 0.32, scratches.b));\n\n\n  col = mix(altCol, col, smoothstep(.6, .61, length(12.65-rayHit.hitPos.y)));   \n  col = mix(altCol, col, smoothstep(.60, .61, length(15.9-rayHit.hitPos.y))); \n  col = mix(altCol, col, smoothstep(.80, .81, length(19.85-rayHit.hitPos.y)));   \n  col = mix(col, altCol, smoothstep(25.15, 25.16, rayHit.hitPos.y));      \n\n  if (length(rayHit.dist-rayHit.winDist)<0.01)\n  {\n    specSize=10.;\n    col = mix(vec3(1.), vec3(0.37), smoothstep(0.156, 0.24, scratches.b))*(1.0+(noiseTex*0.15));\n    specLevel=mix(4., 0.45, col.r);\n  } else if (length(rayHit.dist-rayHit.dekoDist)<0.01)\n  {  \n    specLevel=2.; \n    specSize=20.;\n    col=altCol;\n  } else if (length(rayHit.dist-rayHit.steelDist)<0.01)\n  {  \n    float fre = clamp(1.0+dot(rayHit.normal, rayDir), 0.0, 1.0);\n    vec3 reflectDir = reflect( rayDir, rayHit.normal );\n    specLevel=2.2; \n    specSize=6.2;\n    col = mix(tex, vec3(1.1), smoothstep(0.14, 0.26, scratches.r));\n    col = mix(col, mix(col, GetSkyColor(reflectDir), 0.4), fre);\n  } else if (length(rayHit.dist-rayHit.doorDist)<0.01)\n  {       \n    specLevel=1.2;  \n    specSize=10.2;\n\n    col = mix(vec3(0.85), vec3(0.19), smoothstep(0.14, 0.3, scratches.r));\n  } \n  else\n  {\n    vec3 dirtMask = mix(col, min(col, dirtTex), smoothstep(0.13, 0.22, scratches.r));\n    col=mix(dirtMask, col, 0.2+(0.8*smoothstep(0., 0.84, rayHit.dekoDist)));\n    col=mix(dirtMask, col, 0.2+(0.8*smoothstep(0., 0.42, rayHit.winDist)));\n  }\n\n  vec3 moss =  mix(col, tex*vec3(0.356, 0.415, 0.328), 0.7);\n  moss = mix(moss, col, smoothstep(4.5, 10., rayHit.hitPos.y));\n  col = mix(col, moss, smoothstep(-.75, 0.1, 0.3+abs(noise(rayHit.hitPos*4.))-(0.11*rayHit.hitPos.y)));\n\n  specLevel = mix(2.*specLevel, specLevel*0.3, smoothstep(0.14, 0.26, scratches.b));\n\n\n  col *= 0.1+(max(0.7, dirtTex.b));   \n\n  // make specs irregular by using texture intensity to scale the values\n  specLevel*=tex.r;\n  specSize*=tex.r;\n        \n  #ifdef HIGH_QUALITY   \n  // color lamp\n  col = mix(vec3(1.0), col, smoothstep(0., 1.1, length(rayHit.dist-rayHit.lampDist)));\n  specLevel = mix(3., specLevel, step(0.01, length(rayHit.dist-rayHit.lampDist)));\n  specSize = mix(6., specSize, step(0.01, length(rayHit.dist-rayHit.lampDist)));\n  #endif\n    \n  return vec4(col, specLevel);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  sunPos =  readRGB(ivec2(50, 0));\n  vec3 camData  = readRGB(ivec2(52, 0));  \n\n  // setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n\n  vec3 rayOrigin = vec3(camData.z*cos(camRot.x), camData.y, camData.z*sin(camRot.x) );    \n  rayOrigin.y = readRGB(ivec2(62, 0)).y;\n  mat3 ca = setCamera( rayOrigin, vec3(0., camData.y+(11.*camRot.y), 0. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  // vec4 color = vec4(0.2,0.2,0.16,1000000000.);//texture(iChannel0, uv);\n  vec4 color = textureLod(iChannel0, uv,0.);\n\n  float bufferDepth = color.a;\n  color.a=0.;\n\n  RayHit marchResult = March(rayOrigin, rayDir, min(110.,bufferDepth));\n\n  // only draw if ray hit is closer to camera origin than the same position in the buffer.\n    if (marchResult.hit)\n    {\n      float specSize = 1.0;\n      marchResult.normal = calcNormal(marchResult.hitPos);  \n        \n     #ifdef HIGH_QUALITY   \n     vec4 col = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n      // get lightning based on material\n      vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n      // apply lightning\n      color.rgb = col.rgb*light;\n\n      ApplyFog(color.rgb, GetSkyColor(rayDir), rayOrigin, rayDir, marchResult.depth);\n\n    \n     #else\n     if (marchResult.dist==marchResult.glassDist)\n     {       \n     vec3 sky= GetSkyColor(rayDir*=vec3(-1., 1., -1.));\n     color.rgb= mix(mix(color.rgb*0.4, sky, length(sky)*0.36), color.rgb, step(0.05, marchResult.glassDist));    \n     }\n     else\n     {\n        \n      vec4 col = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n      // get lightning based on material\n      vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n      // apply lightning\n      color.rgb = col.rgb*light;\n\n      ApplyFog(color.rgb, GetSkyColor(rayDir), rayOrigin, rayDir, marchResult.depth);\n     }  \n     #endif\n        \n      color.a+=1.;\n    }\n  \n\n    #ifdef HIGH_QUALITY\n    vec3 sky= GetSkyColor(rayDir*=vec3(-1., 1., -1.));\n    color.rgb= mix(mix(color.rgb*0.4, sky, length(sky)*0.36), color.rgb, step(0.05, marchResult.glassDist));\n    #endif\n \n    \n #ifdef PERFORM_AA_PASS\n    // Perform AA pass\n    if( iFrame>0 && bufferDepth<5000.) \n    {\n            // if the camera is kept steady, switch to fine AA pass.\n            if(length(readRGB(ivec2(62, 0))-readRGB(ivec2(60, 0)))>0.)           \n       {\n            // better for moving cameras\n            vec3 oldColor = textureLod(iChannel1, uv,1.0).rgb;\n            color.rgb = mix(color.rgb,oldColor,max(0.2,0.85*(clamp(bufferDepth,1.,100.)/500.)));\n       }      \n            else\n            {\n                  // good for static camera\n             vec3 oldColor = texelFetch(iChannel1, ivec2(fragCoord-0.5), 0 ).rgb;\n            color.rgb = mix( oldColor, color.rgb, 0.15 );\n            }\n    }   \n  #endif\n\n  fragColor = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}