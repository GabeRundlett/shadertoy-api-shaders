{
    "Shader": {
        "info": {
            "date": "1652126598",
            "description": "more gyroid experiments",
            "flags": 0,
            "hasliked": 0,
            "id": "ftjBDh",
            "likes": 41,
            "name": "Abstract Patterns #6",
            "published": 3,
            "tags": [
                "noise",
                "abstract",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 937
        },
        "renderpass": [
            {
                "code": "\n// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 5.;\nconst float shell = .3;\nconst float carve = .3;\nconst float falloff = 1.8;\nconst float blend = .02;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 100.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 3.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -= iTime * a;\n        d = smin(d, abs(dot(sin(p),cos(p.yzx))/scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += sin(p.z*10.+iTime*20.)*0.002;\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    float dither = hash12(fragCoord);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 0.;\n    const float count = 17.;\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*dither;\n        pos += ray*dist;\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-iTime);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}