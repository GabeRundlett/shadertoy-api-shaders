{
    "Shader": {
        "info": {
            "date": "1683137000",
            "description": "Apollonian Gasket / Soddy Circles with color and bump-mapping (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "DltGW2",
            "likes": 27,
            "name": "Shaded Gasket",
            "published": 3,
            "tags": [
                "apollonian",
                "bumpmap",
                "gasket",
                "soddy"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "// \"Shaded Gasket\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Based on fizzer's \"Apollonian Gasket Möbius\" (WtdSDf); this method\n  provides disk coordinates and radii, but not iteration counts for the\n  disks shown.\n  \n  A simpler version is mla's (e.g.) \"Colourful Apollonian III\" (wdsfWX);\n  this uses colors based on iteration counts, but not proper coordinates\n  for the disks shown (note how the shading can vary inside each disk).\n  \n  Since both quantities are used here - for combining normal-based bump\n  mapping with different disk colors, disk radius (log) is used as a\n  proxy for the iteration count.\n \n  See \"Indra's Pearls\" for lots of info, but only the simplest color\n  renderings appear in the book.\n  \n  The Möbius code has been reformulated.\n*/\n\n#define AA  1 // (= 0/1)\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\n#define N_CIRC  3  // odd value (>= 3)\n\nvec3 limCirc[N_CIRC + 1], invCirc[N_CIRC + 1], ltDir;\nvec2 sAzEl;\nconst int maxIt = 64;\nconst float pi = 3.1415927;\n\nstruct Mob {\n  vec2 a, b, c, d;\n};\n\nvec2 CMul (vec2 a1, vec2 a2)\n{\n  return vec2 (a1.x * a2.x - a1.y * a2.y, a1.x * a2.y + a1.y * a2.x);\n}\n\nvec2 CConj (vec2 a)\n{\n  return vec2 (a.x, - a.y);\n}\n\nfloat CModSq (vec2 a)\n{\n  return a.x * a.x + a.y * a.y;\n}\n\nvec2 CDiv (vec2 a1, vec2 a2)\n{\n  return CMul (a1, CConj (a2)) / CModSq (a2);\n}\n\nvec2 MobOp (Mob m, vec2 z)\n{\n  return CDiv (CMul (z, m.a) + m.b, CMul (z, m.c) + m.d);\n}\n\nMob MobInv (Mob m)\n{\n  return Mob (m.d, - m.b, - m.c, m.a);\n}\n\nMob MobProd (Mob m1, Mob m2)\n{\n  return Mob (CMul (m1.a, m2.a) + CMul (m1.b, m2.c), CMul (m1.a, m2.b) + CMul (m1.b, m2.d),\n     CMul (m1.c, m2.a) + CMul (m1.d, m2.c), CMul (m1.c, m2.b) + CMul (m1.d, m2.d));\n}\n\nvec3 MobToCirc (Mob m, vec3 c)\n{\n  vec2 z;\n  z = MobOp (m, c.xy - CDiv (vec2 (c.z * c.z, 0.), CConj (c.xy + CDiv (m.d, m.c))));\n  return vec3 (z, length (z - MobOp (m, c.xy + vec2 (c.z, 0.))));\n}\n\nMob CircToMob (vec3 c)\n{\n  Mob m;\n  m = Mob (vec2 (c.z, 0.), c.xy, vec2 (0.), vec2 (1., 0.));\n  return MobProd (MobProd (m, Mob (vec2 (0.), vec2 (1., 0.), vec2 (1., 0.), vec2 (0.))),\n     Mob (m.d, m.b * vec2 (-1., 1.), m.c, m.a));\n}\n\nvoid CircInit ()\n{\n  float a, r, rs;\n  a = pi / float (N_CIRC);\n  r = 1. / cos (a);\n  rs = sqrt (r * r - 1.);\n  for (int j = 0; j < N_CIRC; j ++) {\n    limCirc[j] = vec3 (sin (2. * a * float (j) - vec2 (0.5 * pi, 0.)) * r, rs) * (r - rs);\n    invCirc[j] = vec3 (sin (2. * a * float (j) + vec2 (0.5 * pi, 0.)) * r, rs);\n  }\n  limCirc[N_CIRC] = vec3 (0., 0., 1.);\n  invCirc[N_CIRC] = vec3 (0., 0., r - rs);\n}\n\n#define DDOT(x) dot ((x), (x))\n\nvec4 PCirc (vec2 p, vec2 pm)\n{\n  Mob mm, m;\n  vec3 g, gi, w;\n  vec2 z, cm;\n  float eps;\n  bool done;\n  eps = 1e-9;\n  CircInit ();\n  z = p;\n  mm = Mob (vec2 (1., 0.), vec2 (0.), vec2 (0.), vec2 (1., 0.));\n  if (DDOT (pm) > 0.0005 && DDOT (pm) < 1.) {\n    cm = pm * vec2 (-1., 1.) / DDOT (pm);\n    m = CircToMob (vec3 (cm, sqrt (DDOT (cm) - 1.)));\n    z = MobOp (m, z);\n    mm = MobProd (m, mm);\n  }\n  for (int it = VAR_ZERO; it < maxIt; it ++) {\n    done = true;\n    for (int j = 0; j <= N_CIRC; j ++) {\n      gi = invCirc[j];\n      if (DDOT (z - gi.xy * vec2 (1., -1.)) < gi.z * gi.z) {\n        g = gi;\n        done = false;\n        break;\n      }\n    }\n    if (! done) {\n      if (g.x == 0.) g.x = eps;\n      m = CircToMob (g);\n      z = MobOp (m, z);\n      mm = MobProd (m, mm);\n    } else break;\n  }\n  mm = MobInv (mm);\n  if (CModSq (mm.c) == 0.) mm.c = vec2 (eps, 0.);\n  w.z = 1.;\n  for (int j = 0; j <= N_CIRC; j ++) {\n    g = MobToCirc (mm, limCirc[j]);\n    if (g.z > 0. && g.z < 1.) {\n      w.xy = (p - g.xy) / g.z;\n      w.z = DDOT (w.xy);\n      if (w.z < 1.) break;\n    }\n  }\n  return vec4 (w, g.z);\n}\n\nvec3 BgCol (vec3 v)\n{\n  vec4 col4;\n  vec3 u, c;\n  vec2 f;\n  v.xz = Rot2D (v.xz, sAzEl.x);\n  v.xy = Rot2D (v.xy, sAzEl.y);\n  col4 = vec4 (0.);\n  for (int ky = -1; ky <= 1; ky ++) {\n    for (int kx = -1; kx <= 1; kx ++) {\n      u = v;\n      f = 0.0025 * vec2 (kx, ky);\n      u.yz = Rot2D (u.yz, f.y);\n      u.xz = Rot2D (u.xz, f.x);\n      c = vec3 (1. - Minv2 (smoothstep (0.03, 0.05, abs (fract (16. *  vec2 (atan (u.z, - u.x),\n         asin (u.y)) / pi) - 0.5)))) * (0.6 + 0.4 * u.y);\n      col4 += vec4 (min (c, 1.), 1.) * (1. - 0.15 * dot (f, f));\n    }\n  }\n  return col4.rgb / col4.a;\n}\n\nvec3 Color (vec2 p, vec2 pm)\n{\n  vec4 p4;\n  vec3 col, vn;\n  float nDotL;\n  p4 = PCirc (p.yx, pm.yx);\n  col = vec3 (0.);\n  if (p4.z < 1.) {\n    vn = vec3 (p4.xy, sqrt (1. - p4.z)).xzy;\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = HsvToRgb (vec3 (fract (0.75 - 0.9 * log2 (p4.w) / log2 (float (maxIt))), 1., 1.));\n    col = col * (0.2 +  0.8 * nDotL * nDotL) + vec3 (0.2) * pow (max (dot (ltDir,\n       reflect (vec3 (0., -1., 0.), vn)), 0.), 64.);\n    col = mix (col, BgCol (vn), 0.3);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, uvv, pm;\n  float tCur, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (abs (uv.x) < 1.) {\n    sAzEl = vec2 (0.2 * pi * tCur, 0.1 * pi);\n    ltDir = vec3 (0., 1., 0.);\n    ltDir.xy = Rot2D (ltDir.xy, 0.2 * pi);\n    ltDir.xz = Rot2D (ltDir.xz, -0.7 * pi);\n    pm = (mPtr.z > 0. && Maxv2 (abs (mPtr.xy * canvas)) < 0.5 * canvas.y) ? mPtr.xy : vec2 (0.);\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      if (length (uvv) < 1.) col += (1. / naa) * Color (1.05 * uvv, pm);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}