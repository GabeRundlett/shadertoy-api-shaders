{
    "Shader": {
        "info": {
            "date": "1624748163",
            "description": "At shader jam for the release of livecode.demozoo.org\nhttps://twitter.com/psenough/status/1408454513111994371\n\nHappy birthday M4tt",
            "flags": 96,
            "hasliked": 0,
            "id": "ftj3WV",
            "likes": 17,
            "name": "go hard",
            "published": 3,
            "tags": [
                "jam"
            ],
            "usePreview": 0,
            "username": "sp4ghet",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "#define backbuffer iChannel1\n#define fft iChannel0\n#define ffts iChannel0\n#define bass texture(ffts, vec2(.001)).r\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pt = uv - .5;\n    vec2 ar = vec2(iResolution.y / iResolution.x, 1);\n    pt /= ar;\n\n    int n = int(100.*pow(bass,5.)) + 1;\n    vec3 c = vec3(0.);\n    \n    for(int i=0; i<n; i++){\n        pt *= .99;\n        pt -= .001 * bass * vec2(1.,0.) * r2d(TAU*20.*bass);\n        uv = (pt*ar) + .5;\n        \n        c += texture(backbuffer, uv).aaa;\n    }\n    c /= float(n);\n\n\n    c = c / (1. + c);\n    float lum = dot(c.rgb, vec3(.2126, .7152, .0722));\n    float shad = smoothstep(.4, .01, lum);\n    float high = smoothstep(.3, 1., lum);\n    c = c * shad * vec3(.4, 1., 1.5) + c * (1.-shad*high) + c*high*vec3(.99,.6,.8);\n    fragColor = vec4(c,1.0);\n}\n  ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 27684,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/yoxtellar/210317-wrld-is-mine-yox-vip-mastering"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvec4 map(vec3 q){\n  vec4 d = vec4(1000, 0,0,0);\n  vec3 p = q;  \n   \n  float ns = random(vec3(p.xz * .1,0));\n  ns += random(vec3(p.xz * .1 + ns, 0)) * .2;\n  p.y += ns;\n  p.y += .5;\n  float pl = p.y;\n  chmin(d, vec4(pl, 0,0,0));\n  \n  p = q;\n  float beat = time * 175. / 60.;\n  float t = 0.5 + 0.5 * cos(PI * exp(-3. * fract(.5*beat)));\n  float x = length(p.xz) - 1.;\n  float y = p.y;\n  float th = atan(y,x);\n  float ph = atan(p.z, p.x);\n  float r = length(vec2(x,y)) - 2.25;\n  p = vec3(r,th,ph);\n  p.y += p.z*(1. + t);\n  p.y = mod(p.y, .2) - .1;\n  \n  p.r = abs(p.r) - 2.;\n  \n  float tr = box(p, vec3(.05, .05, PI));\n  chmin(d, vec4(tr,0,0,0));\n  \n  p = q;\n  t = 0.5 + 0.5 * cos(PI * exp(-3. * fract(.5*beat + .5)));\n  float sc = .3;\n  float fr = 10000.;\n  for(int i=0; i<5; i++){\n      p *= r3d(PI * (.15 + t), normalize(vec3(-1, 1, 0)));\n      fr = min(fr, octahedron(p, sc));\n      p = abs(p);\n      sc *= .43;\n      p -= sc*1.5;\n  }\n  chmin(d, vec4(fr, 0,0,0));\n  \n  \n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n  return normalize(vec3(\n    e.xyy * map(p + e.xyy).x +\n    e.yxy * map(p + e.yxy).x +\n    e.yyx * map(p + e.yyx).x +\n    e.xxx * map(p + e.xxx).x\n  ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tvec2 pt = uv - 0.5;\n    vec2 ar = vec2(iResolution.y / iResolution.x, 1);\n\tpt /= ar;\n  \n\tvec3 c = vec3(0);\n  \n  vec3 ro = vec3(1.,1.,-1.5);\n  vec3 fo = vec3(1,0,0);\n  vec3 rov = normalize(fo-ro);\n  vec3 cu = normalize(cross(rov,up));\n  vec3 cv = cross(cu,rov);\n  vec3 rd = mat3(cu,cv,rov) * normalize(vec3(pt, 1));\n  \n  float t = 0., precis = 0.;\n  vec3 p = ro;\n  vec4 d;\n  for(int i=0; i<128; i++){\n      p = ro + rd*t;\n      d = map(p);\n      t += d.x * .5;\n      precis = t * .001;\n      if(abs(d.x) < precis || t > 20.){\n        break;\n      }\n  }\n  \n  vec3 lpos = vec3(1, 4, .5);\n  if(abs(d.x) < precis){\n    vec3 l = normalize(lpos - p);\n    vec3 n = normal(p, vec2(precis, -precis));\n    \n    float ao = 0.;\n    for(float i=1.; i<=10.; i++){\n      ao += map(p + n*i*.1).x / (i*.1);\n    }\n    ao /= 10.;\n    \n    c = vec3(ao) * max(dot(n,l), .1);\n  }\n  \n  \n  float v = dot(c.rgb, vec3(.2126, .7152, .0722));\n  float beat = time * 175. / 60.;\n  float tm = 0.5 + 0.5 * cos(PI * exp(-4. * fract(beat)));\n  vec2 st = pt;\n  float s = rectSDF(st, vec2(1, 2))*.3 - .25;\n  st *= r2d(PI*.5*tm);\n  s = max(s, -crossSDF(st, 1.)+.075);\n  s = step(s, 0.);\n  st = abs(pt);\n  s *= step(0., sin(PI*.5 + 100.*(st.x + st.y) - TAU*tm));\n  v = mix(v, 0., s);\n  \n  v *= 1.5 - length(pt);\n  \n  fragColor = vec4(v);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define time iTime\n\n\n#define saturate(x) clamp((x), 0, 1)\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\n\nconst vec3 up = vec3(0,1,0);\n\n\n\nmat2 r2d(float t){\n  float c = cos(t), s = sin(t);\n  return mat2(c,s,-s,c);\n}\n\nmat3 r3d(float angle, vec3 axis){\n      vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}\n\n\nfloat random(vec3 p){\n    float noise = 0.;\n\n    vec3 seed = vec3(-4. ,-2.,0.5);\n\n    float amp = 1.;\n    float gain = 0.5;\n    float lacunarity = 1.4;\n\n    float warp = 1.3;\n    float warpTrk = .7;\n    float warpTrkGain = 1.5;\n\n    mat3 rotMatrix = r3d(.3, seed);\n\n    for(int i = 0; i < 5; i++){\n        p += sin(p.zxy*warpTrk)*warp;\n        noise += sin(dot(cos(p.yzx), sin(p.zxy)))*amp;\n\n        p *= rotMatrix;\n        p *= lacunarity;\n\n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n\n    return noise*.5;\n}\n\nvoid chmin(inout vec4 a, vec4 b){\n    a = a.x < b.x ? a : b;\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return min(0., max(p.x, max(p.y, p.z))) + length(max(p,0.));\n}\n\nfloat octahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    // iq's original version\n  \tvec3 q;\n    if( r.x < 0.0 ) {q = p.xyz;}\n    else if( r.y < 0.0 ){ q = p.yzx;}\n    else if( r.z < 0.0 ){ q = p.zxy;}\n    else {return m*0.57735027;}\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat rectSDF(vec2 st, vec2 size){\n  return max(abs(st).x * size.x, abs(st).y * size.y);\n}\n\nfloat crossSDF(vec2 st, float s){\n  vec2 size = vec2(.25, s);\n  return min(rectSDF(st, size.xy),\n    rectSDF(st, size.yx));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}