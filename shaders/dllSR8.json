{
    "Shader": {
        "info": {
            "date": "1674385444",
            "description": "RayMarch",
            "flags": 0,
            "hasliked": 0,
            "id": "dllSR8",
            "likes": 1,
            "name": "RayMarch11111",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "___HackerMann___",
            "viewed": 185
        },
        "renderpass": [
            {
                "code": "#define RAYMARCH_MAX_ITERATIONS 1000\n#define MAX_DISTANCE 1000.0\n#define EPS 0.0001\n\nfloat soft_min(in float lhs, in float rhs, in float radius) {\n    float h = clamp(0.5 + 0.5 * (lhs - rhs) / radius, 0.0, 1.0);\n    return mix(lhs, rhs, h) - radius * h * (1.0 - h);\n}\n\nfloat sphere_sdf(in vec3 position, in vec3 centre, in float radius) {\n    return length(position - centre) - radius;\n}\n\nfloat torus_sdf(in vec3 position, in float R, in float r) {\n    vec2 q = vec2(length(position.xz) - R, position.y);\n    return length(q) - r;\n}\n\nfloat scene_sdf(in vec3 position) {\n    //position = floor(position);\n\n    float sphere_h = (pow(-1.5 * sin(0.23123 * iTime + 0.123), 4.0) - 1.8) * 0.2;\n    float sphere = sphere_sdf(position, vec3(0, sphere_h, 0), 0.25);\n    float torus  = torus_sdf(position, 0.5, 0.13);\n\n    return soft_min(sphere, torus, 0.5);\n}\n\nvec3 calculate_normal(in vec3 pos) {\n    vec2 eps = vec2(EPS, 0);\n\n    return normalize(vec3(\n        scene_sdf(pos + eps.xyy) - scene_sdf(pos - eps.xyy),\n        scene_sdf(pos + eps.yxy) - scene_sdf(pos - eps.yxy),\n        scene_sdf(pos + eps.yyx) - scene_sdf(pos - eps.yyx)\n    ));\n}\n\nfloat march_shadow(in vec3 ray_origin, in vec3 to_light_direction, in float min_t, in float max_t, in float k) {\n    float result = 1.0;\n\n    for (float t = min_t; t <= max_t;) {\n        float h = scene_sdf(ray_origin + t * to_light_direction);\n\n        if (h < EPS)\n            return 0.0;\n\n        result = min(result, k * h / t);\n        t += h;\n    }\n\n    return result;\n}\n\nfloat ray_march(in vec3 ray_origin, in vec3 ray_direction, out int steps) {\n    float dist = 0.0;\n\n    steps = 0;\n    for (; steps < RAYMARCH_MAX_ITERATIONS; ++steps) {\n        float depth = scene_sdf(ray_origin + dist * ray_direction);\n        if (depth <= EPS)\n            return depth + dist;\n\n        dist += depth;\n\n        if (depth > MAX_DISTANCE)\n            return MAX_DISTANCE;\n    }\n\n    return MAX_DISTANCE;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec3 ambient_color = vec3(0.6);\n\n    vec2 uv = 2.0 * frag_coord / iResolution.xy - vec2(1);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ray_origin = vec3(0, 2, -4);\n    vec3 ray_direction = normalize(vec3(uv, 0) - ray_origin);\n    vec3 texture_sample = texture(iChannel0, ray_direction).rgb;\n\n    int steps;\n    float dist = ray_march(ray_origin, ray_direction, steps);\n    if (60.0 < dist) {\n        frag_color = vec4(texture_sample, 1);\n        return;\n    }\n    \n    vec3 hit_pos = ray_origin + dist * ray_direction;\n    vec3 normal = calculate_normal(hit_pos);\n    \n    vec3 light_position = 10.0 * vec3(sin(1.5 * iTime), 1, cos(1.5 * iTime));\n    vec3 to_light_direction = normalize(light_position - hit_pos);\n\n    float brightness = max(dot(normal, to_light_direction), ambient_color.r);\n    float to_light_dist = length(light_position - hit_pos);\n    brightness /= 0.006 * to_light_dist * to_light_dist;\n\n    vec3 reflected = reflect(ray_direction, normal);\n    float specular_power = 200.0;\n    float specular_brightness = pow(max(0.0, dot(reflected, to_light_direction)), specular_power);\n\n    float fresnel_power = 7.0;\n    float fresnel_factor = pow(1.0 - dot(normal, -ray_direction), fresnel_power);\n    \n    vec3 albedo = vec3(hit_pos * 0.5 + vec3(0.5));\n    vec3 color = brightness * albedo;\n\n    float shadow = march_shadow(hit_pos + EPS * normal * 4.0, to_light_direction, 0.0, 10000.0, 2.2);\n    shadow = exp(shadow) / exp(1.0);\n    shadow = (shadow + ambient_color.r + 0.8) / (1.0 + ambient_color.r + 0.8);\n    color = shadow * albedo;\n    \n    color += fresnel_factor * 0.35;\n    color += specular_brightness;\n\n    frag_color = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}