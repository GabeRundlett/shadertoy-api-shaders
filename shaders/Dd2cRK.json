{
    "Shader": {
        "info": {
            "date": "1687915070",
            "description": "Slower and offset",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd2cRK",
            "likes": 4,
            "name": "Tapestry 7b",
            "published": 3,
            "tags": [
                "ifs"
            ],
            "usePreview": 0,
            "username": "iterati",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "vec4 getHex(vec2 p)\n{\n    vec2 s = vec2(1, ROOT_3);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nfloat sinT( float l )\n{\n    return (sin(((iTime * 2. * PI) / l) + (0.5 * PI)) * 0.5) + 0.5;\n}\n\nfloat sawT( float l )\n{\n    return abs((mod(iTime / l, 1.) - 0.5) * 2.0);\n}\n\nfloat sawT( float l, float p )\n{\n    return abs((mod((iTime / l) + p, 1.) - 0.5) * 2.0);\n}\n\nfloat ampT( float l, float a, float b)\n{\n    return abs(cos((iTime / l) * a * 2. * PI) * cos((iTime / l) * b * 2. * PI) * 0.5 - 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = (fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 uv_ur = uv0;\n    uv_ur.x -= (iResolution.x / iResolution.y) * 0.5;\n    uv_ur.y -= 0.5;\n    \n    vec2 uv_ll = uv0;\n    uv_ll.x += (iResolution.x / iResolution.y) * 0.5;\n    uv_ll.y += 0.5;\n\n    // move origin to upper left\n    uv0.x += (iResolution.x / iResolution.y) * 0.5;\n    uv0.y -= 0.5;\n\n    // get hex grid\n    vec2 h0 = getHex(uv0 * 0.5).xy;\n    vec2 h = h0;\n\n    vec3 col = vec3(0.); \n    vec3 finalColor = vec3(0.0);\n\n    float d = 0.;\n\n    // grid scaling\n    float x = mix(0.7, 1., sawT(36.));               // 3,3,2,2\n    float y = mix(-0.2, 0.2, sawT(30.));             // 5,3,2\n    float z = mix(-0.25, 0.25, sawT(21.));           // 7,3\n\n    // shape props\n    int sides = 6;\n    float r = mix(1.1, 0.25, sawT(33.));             // 11,3\n\n    // color variation\n    float c = iTime / 65.;                           // 13,5\n    float l = mix(1., -1., sawT(29.));               // 29\n    float k = mix(-1., 1., ampT(17., 2., 3.));       // 17\n    float o = mix(1., -1., ampT(19., 2., 3.));       // 19\n\n    const float iterations = 5.;\n    for (float i = 0.0; i < iterations; i++) {\n        // scale grid\n        float xx = x + (y * (i / iterations)) + (exp(length(uv0 * z)) * 0.25);\n        h = getHex(xx * h * ROOT_3 * ROT).xy;\n\n        // phased shape change by layer\n        float mp = mix(0., 1., sawT(23.));           // 23\n        float m = mix(1., float(sides) - 1., sawT(21., mp * i / iterations)); // 7,3 \n\n        // get sdf value\n        d = sdStar(h, r / ROOT_3, sides, m);\n\n        // cutoff value (line width)\n        float stepv = 0.0025 * (i + 1.) * xx;\n        d = 1. - step(stepv, abs(d));\n        \n        // get color\n        col = palette(c + (l * (i / iterations)) + (k * length(uv_ur * 0.1)) + (o * length(uv_ll * 0.1)));\n        col *= d;\n        \n        // add to pixel accumulator\n        if (finalColor == vec3(0.)) {\n            finalColor += col;\n        }\n        //if (col != vec3(0.)) {\n        //    finalColor = col;\n        //}\n    }\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926538\n#define ROOT_3 1.7320508\nconst mat2 ROT = mat2(cos(PI / 6.), sin(PI / 6.), -sin(PI / 6.), cos(PI / 6.));\n\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nint _N = 2;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}