{
    "Shader": {
        "info": {
            "date": "1634357982",
            "description": "Trying to create a simple but faithful recreation of the beloved planet Jupiter.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsVSzR",
            "likes": 12,
            "name": "Planet - Jupiter",
            "published": 3,
            "tags": [
                "procedural",
                "planet",
                "gasgiant",
                "gas",
                "jupiter",
                "giant"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 706
        },
        "renderpass": [
            {
                "code": "// ####### Planet - Jupiter #######\n// Made by Jacob Bingham (Zi7ar21) on October 16th, 2021\n\n// Last Updated on October 18th, 2021 at 12:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NsVSzR\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nThis is my attempt at creating a simple but faithful recreation of the beloved planet Jupiter.\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// ##### Constants #####\n\nconst float pi = 3.141592653589793;\n\n// ##### Parameters #####\n\n#define fov 0.5\n\n#define exposure 1.0\n\n// ##### Hashes #####\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p *= 0.1031;\n    p  = fract(p);\n    p *= p+33.33;\n    p *= p+p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n    p3 *= 0.1031;\n    p3  = fract(p3);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract( (p3.x+p3.y)*p3.z );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4 *= vec4(0.1031, 0.1030, 0.0973, 0.1099);\n    p4  = fract(p4);\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract( (p4.xxyz+p4.yzzw)*p4.zywx );\n}\n\n// ##### Additional Functions #####\n\nfloat dotp(vec2 vector) { return dot(vector, vector); }\nfloat dotp(vec3 vector) { return dot(vector, vector); }\nfloat dotp(vec4 vector) { return dot(vector, vector); }\n\nvec2 rotate(vec2 vector, float rotation)\n{\n    float s = sin(rotation), c = cos(rotation);\n    return vec2(vector.x*c-vector.y*s, vector.x*s+vector.y*c);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos( 2.0*pi*(c*t+d) );\n}\n\n// https://www.schemecolor.com/jupiter-planet-colors.php\nvec3 jupiter_palette(float t)\n{\n    const vec3 c0 = vec3( 64,  68,  54)/256.0; // #404436\n    const vec3 c1 = vec3(167, 156, 134)/256.0; // #A79C86\n    const vec3 c2 = vec3(210, 207, 218)/256.0; // #D2CFDA\n    const vec3 c3 = vec3(211, 156, 126)/256.0; // #D39C7E\n    const vec3 c4 = vec3(144,  97,  77)/256.0; // #90614D\n    const vec3 c5 = vec3(200, 139,  58)/256.0; // #C88B3A\n\n    vec3 interpolated_color =\n    t > 0.0/5.0 && t < 1.0/5.0 ? mix( c0, c1, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 1.0/5.0 && t < 2.0/5.0 ? mix( c1, c2, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 2.0/5.0 && t < 3.0/5.0 ? mix( c2, c3, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 3.0/5.0 && t < 4.0/5.0 ? mix( c3, c4, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 4.0/5.0 && t < 5.0/5.0 ? mix( c4, c5, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    vec3(0.0);\n\n    return interpolated_color;\n}\n\n// ##### Noise #####\n\nfloat noise(float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n\n    float u = smoothstep(0.0, 1.0, f);\n\n    float h0 = hash11(i+0.0);\n    float h1 = hash11(i+1.0);\n\n    return mix(h0, h1, u);\n}\n\nfloat noise(vec3 p, int octave)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;\n    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;\n\n    /* // Not Spherically Uniform\n    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    */\n\n    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );\n    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );\n    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );\n    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );\n    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );\n    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );\n    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );\n    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );\n\n    vec2 s0 = sin(r0), c0 = cos(r0);\n    vec2 s1 = sin(r1), c1 = cos(r1);\n    vec2 s2 = sin(r2), c2 = cos(r2);\n    vec2 s3 = sin(r3), c3 = cos(r3);\n    vec2 s4 = sin(r4), c4 = cos(r4);\n    vec2 s5 = sin(r5), c5 = cos(r5);\n    vec2 s6 = sin(r6), c6 = cos(r6);\n    vec2 s7 = sin(r7), c7 = cos(r7);\n\n    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);\n    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);\n    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);\n    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);\n    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);\n    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);\n    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);\n    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);\n\n    float t0 = dot( v0, f-vec3(0.0, 0.0, 0.0) );\n    float t1 = dot( v1, f-vec3(1.0, 0.0, 0.0) );\n    float t2 = dot( v2, f-vec3(0.0, 1.0, 0.0) );\n    float t3 = dot( v3, f-vec3(1.0, 1.0, 0.0) );\n    float t4 = dot( v4, f-vec3(0.0, 0.0, 1.0) );\n    float t5 = dot( v5, f-vec3(1.0, 0.0, 1.0) );\n    float t6 = dot( v6, f-vec3(0.0, 1.0, 1.0) );\n    float t7 = dot( v7, f-vec3(1.0, 1.0, 1.0) );\n\n    return 0.5*(mix(mix(mix(t0, t1, u.x), mix(t2, t3, u.x), u.y), mix(mix(t4, t5, u.x), mix(t6, t7, u.x), u.y), u.z)+1.0);\n}\n\nvec3 distortion_noise(vec3 p, float t)\n{\n    const int octave = -1;\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;\n    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;\n\n    /* // Not Spherically Uniform\n    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    */\n\n    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );\n    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );\n    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );\n    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );\n    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );\n    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );\n    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );\n    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );\n\n    vec2 s0 = sin(r0), c0 = cos(r0);\n    vec2 s1 = sin(r1), c1 = cos(r1);\n    vec2 s2 = sin(r2), c2 = cos(r2);\n    vec2 s3 = sin(r3), c3 = cos(r3);\n    vec2 s4 = sin(r4), c4 = cos(r4);\n    vec2 s5 = sin(r5), c5 = cos(r5);\n    vec2 s6 = sin(r6), c6 = cos(r6);\n    vec2 s7 = sin(r7), c7 = cos(r7);\n\n    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);\n    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);\n    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);\n    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);\n    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);\n    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);\n    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);\n    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);\n\n    /*\n    v0 = vec3(rotate(v0.xz, t), v0.y).xzy;\n    v1 = vec3(rotate(v1.xz, t), v1.y).xzy;\n    v2 = vec3(rotate(v2.xz, t), v2.y).xzy;\n    v3 = vec3(rotate(v3.xz, t), v3.y).xzy;\n    v4 = vec3(rotate(v4.xz, t), v4.y).xzy;\n    v5 = vec3(rotate(v5.xz, t), v5.y).xzy;\n    v6 = vec3(rotate(v6.xz, t), v6.y).xzy;\n    v7 = vec3(rotate(v7.xz, t), v7.y).xzy;\n    */\n\n    v0 = vec3(rotate(v0.xy, t), v0.z);\n    v1 = vec3(rotate(v1.xy, t), v1.z);\n    v2 = vec3(rotate(v2.xy, t), v2.z);\n    v3 = vec3(rotate(v3.xy, t), v3.z);\n    v4 = vec3(rotate(v4.xy, t), v4.z);\n    v5 = vec3(rotate(v5.xy, t), v5.z);\n    v6 = vec3(rotate(v6.xy, t), v6.z);\n    v7 = vec3(rotate(v7.xy, t), v7.z);\n\n    return mix(mix(mix(v0, v1, u.x), mix(v2, v3, u.x), u.y), mix(mix(v4, v5, u.x), mix(v6, v7, u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 p)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        value += atten*noise(scale*p, i);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value/accum;\n}\n\n// ##### Rendering #####\n\nstruct rayData {\n    float tMin;\n    float tMax;\n    bool hit;\n    bool expire;\n    vec3 normal;\n};\n\nrayData traceSphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRad)\n{\n    rayData raycastOut;\n\n    raycastOut.tMin = -1.0;\n    raycastOut.tMax = -1.0;\n    raycastOut.hit = false;\n    raycastOut.expire = false;\n    raycastOut.normal = vec3(0.0);\n\n    vec3 oc = ro-sphPos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc)-sphRad*sphRad;\n    float h = b*b-c;\n\n    if(h < 0.0)\n    {\n        return raycastOut;\n    }\n\n    h = sqrt(h);\n\n    raycastOut.tMin = -b-h;\n    raycastOut.tMax = -b+h;\n    raycastOut.hit = true;\n    raycastOut.normal = normalize(ro+rd*raycastOut.tMin);\n\n    return raycastOut;\n}\n\nrayData process_hit(rayData raycast0, rayData raycast1)\n{\n    if(raycast0.hit)\n    {\n        if(raycast1.hit)\n        {\n            rayData raycastOut;\n\n            raycastOut.tMin = min(raycast0.tMin, raycast1.tMin);\n            raycastOut.tMax = max(raycast0.tMax, raycast1.tMax);\n\n            raycastOut.hit  = true;\n\n            raycastOut.expire  = false;\n\n            raycastOut.normal  = raycast0.tMin < raycast1.tMin ? raycast0.normal : raycast1.normal;\n\n            return raycastOut;\n        }\n\n        return raycast0;\n    }\n\n    return raycast1;\n}\n\nrayData trace(vec3 ro, vec3 rd)\n{\n    return traceSphere(ro, rd, vec3(0.0), 0.5);\n}\n\nvec3 skyColor(vec3 rd)\n{\n    return vec3(0.000, 0.000, 0.000);\n}\n\nfloat shade_point(vec3 ro, vec3 rd, vec3 normal, vec3 hitPos, vec3 lightPos)\n{\n    vec3 lightDir = lightPos-hitPos;\n    float lightIntensity = ( 1.0/max(dot(lightDir, lightDir), 0.001) );\n    lightDir = normalize(lightDir);\n\n    return max(dot(normal, lightDir), 0.0)*lightIntensity;\n}\n\nfloat shade_sun(vec3 ro, vec3 rd, vec3 normal, vec3 lightDir)\n{\n    return max(dot(normal, lightDir), 0.0);\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    rayData t = trace(ro, rd);\n\n    if(!t.hit)\n    {\n        return skyColor(rd);\n    }\n\n    vec3 hitPos = ro+rd*t.tMin;\n    vec3 normal = t.normal;\n\n    //vec3 lightPos = vec3( 2.0*sin(0.25*pi*iTime), 2.0, 2.0*cos(0.25*pi*iTime) );\n    vec3 lightPos = vec3(10.0, 0.0, 10.0);\n\n    //float lambert = 500.0*shade_point( ro, rd, normal, hitPos, lightPos);\n    float lambert = 3.0*shade_sun( ro, rd, normal, normalize(lightPos) );\n\n    vec3 surfacePos = normalize(hitPos);\n\n    float noise0 = fbm( 10.0*(vec3(rotate(surfacePos.xz, -0.005*2.0*pi*iTime), surfacePos.y).xzy) )-0.5;\n    float noise1 = fbm(  8.0*(vec3(rotate(surfacePos.xz,  0.001*2.0*pi*iTime), surfacePos.y).xzy)+(surfacePos.y*4.0*noise0) );\n    //float noise1 = fbm(  8.0*(vec3(rotate(surfacePos.xz,  0.001*2.0*pi*iTime), surfacePos.y).xzy)+distortion_noise(20.0*surfacePos, 0.125*2.0*pi*iTime) );\n    float noise2 = noise( (48.0*surfacePos.y)+(6.0*noise1) );\n\n    vec3 baseColor = vec3(noise2);\n    //vec3 baseColor = jupiter_palette(noise2)*noise2;\n\n    return baseColor*lambert;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 upvect = vec3(0.0, 1.0, 0.0);\n\n    if(iMouse.z > 0.0)\n    {\n        vec2 mouseUV = 2.0*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n        //camPos = vec3(mouseUV, 2.0);\n        camPos = vec3( 2.0*sin(2.0*pi*mouseUV.x), 2.0*mouseUV.y, 2.0*cos(2.0*pi*mouseUV.x) );\n    }\n\n    mat3 rotmat;\n\n    rotmat[2] = normalize(target-camPos);\n    rotmat[0] = normalize( cross(rotmat[2], upvect) );\n    rotmat[1] = cross(rotmat[0], rotmat[2]);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize( rotmat*vec3(fov*uv, 1.0) );\n\n    vec3 color = radiance(ro, rd);\n\n    color = clamp(1.0-exp(-max(color, 0.0)*exposure), 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}