{
    "Shader": {
        "info": {
            "date": "1689731545",
            "description": "Saw these hilarious little frogs and wanted to practice SDF modeling one. This shader is a combination of ray marching, SDF modeling, and a smattering of techniques (mostly from or inspired by iq). Tried to comment it well and stay organized!",
            "flags": 0,
            "hasliked": 0,
            "id": "cdSBD1",
            "likes": 67,
            "name": "Rain Frog",
            "published": 3,
            "tags": [
                "raymarching",
                "cute",
                "cute",
                "sdf",
                "character",
                "animal",
                "creature",
                "frog"
            ],
            "usePreview": 0,
            "username": "tristanantonsen",
            "viewed": 797
        },
        "renderpass": [
            {
                "code": "// Ray marching constants\n#define MAX_STEPS 300\n#define SURF_DIST 0.001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Noise\n////////////////////////////////////////////////////////////////\n\n// Hash & voronoi from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// From or adapted from iq: https://iquilezles.org/articles/distfunctions/\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n// Also from or adapted from iq: https://iquilezles.org/articles/distfunctions/\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -(m.x+1.)*TAU + PI * 0.95);\n    return p;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) {\n\n    float f = 0.06; // ribbet frequency\n    vec3 p = orbitControls(vec3(po.x, po.y, po.z)); // track mouse\n    vec3 pSym = vec3(abs(p.x),p.y,p.z);\n    \n    vec2 res = vec2(1.0);\n    \n    // ribbet timing\n    float w = 1.5;\n    float rt = sin(w * iTime);\n    rt = max(rt, sin(w * iTime + PI/3.));\n    rt = rt * 0.5 + 1.;\n    \n    // Body\n    float body = sdEllipsoid(p, vec3(0.), vec3(0.7, 0.5, 0.7) * 1. + (0.025 * rt));\n    body = opSmoothUnion(body,sdEllipsoid(p, vec3(0.,-0.1,0.025), vec3(0.8, 0.5, 0.75)), 0.1);\n    \n    // Head\n    vec3 pr = rotX(p+vec3(0., -0.25, 0.4), -PI/3.);\n    float head = sdEllipsoid(pr, vec3(0.), vec3(0.38, 0.325, 0.4));\n    res.x = opSmoothUnion(body, head, 0.3);\n    res.x += 0.0 * sin(50.*head) * smoothstep(1.,0.,5.*head);\n\n    // eyelid\n    float lid = sdEllipsoid(pSym, vec3(0.24,0.444 + (0.01 * rt), -0.525), vec3(0.16, 0.14, 0.16));\n    res.x = opSmoothUnion(res.x, lid, 0.04);\n    \n    // eye\n    float eye = sdSphere(pSym, vec3(0.27,0.43 + (0.012 * rt),-0.58),0.115);\n    res.x -= 0.02 * sin(60.*eye) * smoothstep(1.,0.,20.*eye);\n    if (eye-0.005 < res.x) {res.y = 2.0;};\n    res.x = opSmoothUnion(res.x, eye, 0.006);\n\n    //nose\n    float nose = sdSphere(p, vec3(0.,0.45,-0.67),0.01);\n    res.x = opSmoothUnion(res.x, nose, 0.25);\n\n\n    // mouth/face\n    pr = rotX(p+vec3(0., -0.12, 0.655), -0.35);\n    float face = sdEllipsoid(pr, vec3(0.), vec3(0.27, 0.3, 0.1));\n    float faceBool = sdEllipsoid(pr+vec3(0.,0. + (0.032 * rt),0.02), vec3(0.), vec3(0.26, 0.4, 0.04));\n    res.x = opSmoothSubtraction(res.x, faceBool, 0.02);\n    res.x = opSmoothUnion(res.x, face, 0.01);\n\n    // Ribbet\n    float rb = sdSphere(p, vec3(0.,0.0,-0.6),0.16);\n    res.x = opSmoothUnion(res.x,rb,0.2 * rt);\n    \n    // Arms\n    vec3 elbow = vec3(0.62,-0.3,-0.4);\n    vec3 shoulder = vec3(0.5,-0.1,-0.4);\n    vec3 wrist = vec3(0.57,-0.45,-0.45);\n    float upperArm = sdCapsule(pSym, shoulder,elbow, 0.08);\n    res.x = opSmoothUnion(res.x, upperArm, 0.1);\n    res.x += 0.01 * sin(40.*upperArm) * smoothstep(1.,0.,5.*upperArm);\n    float foreArm = sdCapsule(pSym, elbow+vec3(0.,-0.05,0.), wrist, 0.08);\n    res.x = opSmoothUnion(res.x, foreArm, 0.05);\n\n    // Fingers\n    float f1 = sdCapsule(pSym, wrist-vec3(0.,0.03,0.03), wrist-vec3(0.15,0.02,0.005), 0.04);\n    float f2 = sdCapsule(pSym, wrist-vec3(0.,0.03,0.03), wrist-vec3(0.2,0.04,0.06), 0.04);\n    float f3 = sdCapsule(pSym, wrist-vec3(0.,0.03,0.03), wrist-vec3(0.15,0.05,0.12), 0.04);\n\n    res.x = opSmoothUnion(res.x, f1, 0.04);\n    res.x = opSmoothUnion(res.x, f2, 0.04);\n    res.x = opSmoothUnion(res.x, f3, 0.04);\n    \n    // Legs\n    vec3 knee = vec3(0.55,-0.45,0.425);\n    float upperLeg = sdCapsule(pSym, vec3(0.4,-0.2,.475),knee, 0.07);\n    res.x = opSmoothUnion(res.x, upperLeg, 0.1);\n    res.x += 0.01 * sin(40.*upperLeg) * smoothstep(1.,0.,5.*upperLeg);\n\n    // Butt\n    float c = sdSphere(pSym, vec3(0.15,-0.15,.65),0.115);\n    res.x = opSmoothUnion(res.x, c, 0.15);\n\n    // Toes\n    float t1 = sdCapsule(pSym, knee-vec3(0.,0.03,0.), knee-vec3(-0.18, 0.05,0.12), 0.04);\n    float t2 = sdCapsule(pSym, knee-vec3(0.,0.03,0.), knee-vec3(-0.13, 0.05,0.18), 0.04);\n    float t3 = sdCapsule(pSym, knee-vec3(0.,0.03,0.), knee-vec3(-0.06, 0.05,0.18), 0.04);\n    \n    res.x = opSmoothUnion(res.x, t1, 0.04);\n    res.x = opSmoothUnion(res.x, t2, 0.04);\n    res.x = opSmoothUnion(res.x, t3, 0.04);\n\n    // Ground\n    float gnd = sdRoundedCylinder(po+vec3(0.,0.78,0.) , 0.8, 0.1, 0.15);\n    if (gnd-0.005 < res.x) {res.y = 3.0;};\n    res.x = opUnion(res.x, gnd);    \n        \n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\n// from iq: https://iquilezles.org/articles/rmshadows/\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // camera orientation from https://raytracing.github.io/books/RayTracingInOneWeekend.html\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(-0.4 + 0.01 * sin(0.5*iTime), -0.2, 2.);\n    vec3 ro = vec3(-0.4 + 0.1 * cos(0.5*iTime), 0.5, -5.);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    vec3 col = mix(vec3(0.8, 0.8, 0.55), vec3(0.45, 0.55, 0.35), smoothstep(0.0, 1.0, uv.y));\n    fragColor = vec4(col, 1.);\n\tfragColor += mix(vec4(0.1), vec4(0.0, 0.15, 0.0, 1.0), v); // vignette\n    fragColor *= mix(vec4(0.5,0.6,0.6,1.), vec4(1.), smoothstep(-1.,1.,uv.x)); // darken left\n    \n    float vb = voronoi( 2. * vec3(2.,1.,1.) * vec3(uv, 1.)).x;\n    fragColor.xyz *= mix(0.7,1.,smoothstep(0.,1.,vb));\n\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n\n        // Simple surface texture\n        if (d.y == 1.) N += voronoi( 50.*pr).x * 0.13;\n        \n        // Lighting (partial phong shading)\n        vec3 lightPos1 = vec3(1, 1,-1);\n        float light1 = dot(N, normalize(lightPos1))*.5+.5;\n        light1 *= 1.5;\n        vec3 L1 = vec3(1, 1,-1);\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 lightVal = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        \n        // Specular highlights\n        vec3 R = reflect(L1, N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        vec3 color;\n\n        // Color assignment\n        // Color assignment method adapted from iq: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=8470s\n        // A breakdown in my other shader: https://www.shadertoy.com/view/cdlBDl\n        if (d.y == 1.) color = vec3(0.3, 0.5, 0.2) + specular * 0.0006; // body\n        if (d.y == 2.) color = vec3(0.05) + specular * 0.004; // eyes\n        if (d.y == 3.) color = vec3(0.15, 0.25, 0.1);\n        \n        // Skin colors\n        float c = 1. - voronoi( 10.*pr).x;\n        // blended based on distance from a point above the frog\n        float tFac = mix(0., 1., smoothstep(0.,1., length(p-vec3(0.,0.7,0.5))-0.5));\n        color = mix(color, vec3(0.16, 0.16, 0.1), c * (1.-tFac));\n        \n        // shadows\n        float res = softShadow(p+N*0.01, normalize(lightPos1-p), 0.01, 5., 2.);\n        \n        if (p.y <= -0.525) {\n            float res2 = softShadow(p+N*0.01, vec3(0.,1.,0.), 0.01, 5., 2.);\n            color *= 1.0 - mix(0.4,0.,smoothstep(0.,1., res2));;\n        }\n        \n        color *= 1.0 - mix(0.3,0.,smoothstep(0.,1., res));\n        \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.35 * res;\n        \n        \n        fragColor = vec4(lightVal*color, 1.0);\n    }\n   \n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}