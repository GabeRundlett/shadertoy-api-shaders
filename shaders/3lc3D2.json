{
    "Shader": {
        "info": {
            "date": "1609720573",
            "description": "\"The Sea in Spring\"\n composed in 1929 by Michio Miyagi",
            "flags": 8,
            "hasliked": 0,
            "id": "3lc3D2",
            "likes": 34,
            "name": "[♪]Haru No Umi",
            "published": 3,
            "tags": [
                "raymarching",
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 691
        },
        "renderpass": [
            {
                "code": "//---Haru No Umi\n// by Catzpaw 2021\n\n\n#define ZERO min(0,iFrame)\n\n#define ITER 300\n#define NEAR 0.1\n#define FAR 50.0\n#define EPS 5e-5\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//SDF\nfloat sdBox(vec3 p,vec3 b){p=abs(p)-b;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}\nfloat sdOH(vec3 p,float s){p=abs(p);return (p.x+p.y*2.+p.z-s)*.577;}\nfloat sdCC(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(r,h);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdWedge(vec3 p,vec3 b,vec2 h){p.xz=abs(p.xz);p.y+=p.x*h.x+p.z*h.y;p=abs(p)-b;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}\n\n//ROOF BENDING\nvec3 bend(vec3 p){\n    float v=p.x*0.1;\n    p.y-=5.5;\n    p.y-=(1.+p.y*.4)*v*v*v*v;\n    p.x*=1.0-0.013*p.y*p.y;\n    return p;\n}\n\n//SCENE\nfloat map(vec3 p,out int id){\n    id=2;\n    p=abs(p);\n    float d=length(p-vec3(0,6,0));\n    vec3 q;\n    if(d>10.0)return d*.5;\n    d=FAR;\n\n    //main pillar\n    q=p;\n    d=min(d,sdCC   (q-vec3(2.8,6.93,0.0),0.2,0.5));\n    q.xy*=rot(.03);\n    d=min(d,sdCC   (q-vec3(3.0,0.0,0.0),6.8,0.5-p.y*.02));\n    d=min(d,sdBox  (q-vec3(3.0,0.5,0.0),vec3(.1,.25,2.6)));\n    d=min(d,sdWedge(q-vec3(3.0,0.6,0.0),vec3(.05,.1,.7),vec2(0.0,-0.3)));\n    d=min(d,sdBox  (q-vec3(3.0,2.3,0.0),vec3(.1,.25,2.6)));\n    d=min(d,sdWedge(q-vec3(3.0,2.4,0.0),vec3(.05,.1,.7),vec2(0.0,-0.3)));\n    d=min(d,sdWedge(q-vec3(3.0,5.9,0.0),vec3(.7,.1,.05),vec2(-0.3,0.0)));\n\n    //side pillar\n    q=p;q.xy*=rot(.03);\n    d=min(d,sdCC   (q-vec3(3.0,0.00,2.0),3.0,0.3-p.y*.02));\n    d=min(d,sdWedge(q-vec3(3.0,0.65,2.0),vec3(.05,.1,.5),vec2(0.0,-0.3)));\n    d=min(d,sdWedge(q-vec3(3.0,2.45,2.0),vec3(.05,.1,.5),vec2(0.0,-0.3)));\n    d=min(d,sdBox  (q-vec3(3.0,3.05,2.0),vec3(.3,.1,.3)));\n\n    //side pillar top\n    vec3 r=p-vec3(2.9,3.3,2.0);\n    d=min(d,sdBox(r+vec3(0,0.05,0),vec3(.4,.05,.4)));\n    r.xz*=rot(0.78);r.xz*=.4;\n    float d2=FAR;//hiwada material\n    d2=min(d2,sdOH(r,.3));\n\n    //main beam\n    q=p;\n    d=min(d,sdBox  (q-vec3(0.0,6.7,0.0),vec3(.4,1.,.2)));\n\n    q=bend(p);\n    d=min(d,sdBox  (q-vec3(0.0,0.0,0.0),vec3(5.0,0.4,0.2)));\n    d=min(d,sdWedge(q-vec3(0.0,0.5,0.0),vec3(5.1,0.1,0.3),vec2(0.0,0.3)));\n    d=min(d,sdBox  (q-vec3(0.0,0.35,0.0),vec3(5.1,0.1,0.3)));\n    d=min(d,sdBox  (q-vec3(0.0,2.0,0.0),vec3(5.0,0.4,0.3)));\n    d=min(d,sdWedge(q-vec3(0.0,2.6,0.0),vec3(5.5,0.3,0.4),vec2(0.0,0.3)));\n    d=min(d,sdBox  (q-vec3(0.0,2.4,0.0),vec3(5.5,0.3,0.4)));\n\n    //ridge\n    float d3=FAR;//bronze material\n    d3=min(d3,sdWedge(q-vec3(0.0,3.2,0.0),vec3(5.7,0.1,0.15),vec2(0.0,0.3)));\n    d3=min(d3,sdWedge(q-vec3(0.0,3.4,0.0),vec3(5.9,0.1,0.15),vec2(0.0,0.3)));\n\n    //roof\n    q.yz*=rot(.52);\n    d=min(d,max(sdBox(q-vec3(0.0,2.6,-.9),vec3(5.6,.1,.7)),\n               -sdBox(q-vec3(3.9,2.6,0.9),vec3(3,.5,1.5))));\n    d2=min(d2,max(sdBox(q-vec3(0,2.7,-.9),vec3(5.7,.1,.8)),\n                 -sdBox(q-vec3(4.,2.7,1),vec3(3,.5,1.5))));\n\n    if(abs(d)<min(abs(d2),abs(d3))){\n        id=2;\n        return d;\n    }\n    if(abs(d2)<abs(d3)){\n        id=3;\n        return d2;\n    }\n    id=4;\n    return d3;\n}\n\n//WAVE\nvec3 wave(vec3 p){\n    float t=iTime*5.;\n    float x=sin(t    +p.x*5.3+p.z*4.5)\n           +sin(t*2.0+p.x*5.1+p.z*2.6)\n           +sin(t*1.1+p.x*3.1+p.z*2.4);\n    float z=sin(t    +p.x*3.5+p.z*7.1)\n           +sin(t*2.0+p.x*3.1+p.z*5.4)\n           +sin(t*1.1+p.x*2.6+p.z*2.3);\n    return normalize(vec3(x,10.+length(p)*2.,z));\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    int z;\n    return normalize(e.xxx*map(p+e.xxx*EPS,z)+e.xyy*map(p+e.xyy*EPS,z)+\n                     e.yxy*map(p+e.yxy*EPS,z)+e.yyx*map(p+e.yyx*EPS,z));\n}\n\n//RAYMARCHING\nfloat trace1(vec3 ro,vec3 rd,out vec3 p,out int id){\n    id=1;\n    float t=NEAR;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        if(p.y<0.){//water surface\n            t=-ro.y/rd.y;\n            p=ro+rd*t;\n            id=1;\n            break;\n        }\n        float d=map(p,id);\n        if(abs(d)<EPS){//object surface\n            break;\n        }\n        if(t>FAR){\n            t=-ro.y/rd.y;\n            p=ro+rd*t;\n            id=1;\n            break;//horizon\n        }\n        t+=step(d,1.)*d*.4+d*.4;\n    }\n    return t;\n}\nfloat trace2(vec3 ro,vec3 rd,out vec3 p,out int id){\n    id=0;\n    float t=NEAR;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        float d=map(p,id);\n        if(abs(d)<EPS){//object surface\n            break;\n        }\n        if(t>FAR){//sky\n            id=0;\n            break;\n        }\n        t+=step(d,1.)*d*.4+d*.4;\n    }\n    return t;\n}\n\n//SKY\nconst vec3 sunDir=normalize(vec3(.6,.1,.5));\nconst vec3 sunCol=vec3(.9,.8,.7);\nvec3 sky(vec3 rd){\n\tfloat sun=max(0.,dot(rd,sunDir));\n\tvec3 s=mix(vec3(.17,.16,.18),vec3(.35,.25,.15),pow(1.-max(rd.y,0.),6.));\n\ts*=smoothstep(-.3,.0,rd.y);\n\ts+=sunCol*sun*sun*.3;\n\ts+=sunCol*pow(sun,500.)*1.5;\n\treturn clamp(s,0.,1.);\n}\n\n//WATER\nvec3 bottom(vec3 rd){\n    float v=abs(dot(normalize(rd),vec3(0,1,0)));\n    vec3 c=mix(vec3(0),vec3(.3,.3,.2)*sunCol,v);\n    return c;\n}\n\nvec3[5] cp0=vec3[](vec3(4,3,-20),vec3(0,18,-10),vec3(0,3,-40),vec3(0,1,-10),vec3(0,3,-10));\nvec3[5] cp1=vec3[](vec3(0,2,-10),vec3(0,3,-10),vec3(0,.5,3),vec3(0,15,-15),vec3(0,1,-25));\nfloat[5] cr0=float[](0.,-.5,0.,-3.,-3.14);\nfloat[5] cr1=float[](.6,-4.,0.,-6.,-3.14);\nfloat[5] ct0=float[](0.,-1.,-.05,0.,.1);\nfloat[5] ct1=float[](.2,.1,.5,-.3,-.05);\nfloat[5] cv0=float[](1.,.6,2.,.6,1.);\nfloat[5] cv1=float[](.6,.6,1.,.6,1.);\n\nvec3[3] matCol=vec3[](vec3(.90,.15,.15),vec3(.20,.15,.10),vec3(.30,.45,.40));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m=iMouse.xy/iResolution.xy;\n    //SETUP\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),ro,rd;\n\n    //CAMERA\n    const float cl=11.;\n    float ct=mod(iTime,cl)/cl;\n    int cc=int(mod(floor(iTime/cl),5.));\n\n    ro=mix(cp0[cc],cp1[cc],ct);\n    ro.xz*=rot(mix(cr0[cc],cr1[cc],ct));\n    rd=normalize(vec3(uv,mix(cv0[cc],cv1[cc],ct)));\n    rd.yz*=rot(mix(ct0[cc],ct1[cc],ct));\n    rd.xz*=rot(mix(cr0[cc],cr1[cc],ct));\n    \n   //GET SURFACE AND MATERIAL ID\n    int  id;\n    float t=NEAR;\n    if(rd.y<0.){\n        t=trace1(ro,rd,p,id);\n        if(id==1){\n            vec3 w=wave(p);\n            vec3 rr=refract(rd,w,1.343);\n            if(rr.y==0.){\n                rd=reflect(rd,w);\n                ro=p;\n                t=trace2(ro,rd,p,id);\n            }else{\n                rd=rr;\n            }\n        }\n    }else{\n        t=trace2(ro,rd,p,id);\n    }\n\n    //SHADING\n    if(id==0)c=sky(rd);\n    if(id==1)c=mix(sky(rd),bottom(rd),t/FAR);\n    if(id>1){\n        n=normal(p);\n        c=matCol[id-2]*sunCol*(dot(sunDir,n)+1.)*.5;\n    }\n    c+=mix(vec3(0),sunCol,pow((dot(rd,sunDir)+1.)*.4,3.));\n    fragColor=vec4(clamp(c,0.,1.),1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---Haru No Umi\n// by Catzpaw 2021\n\n//MUSIC\n//『春の海』(The Sea in Spring)\n// composed by Michio Miyagi 1929\n\n//---Music Renderer\n// by Catzpaw 2019\n// https://www.shadertoy.com/view/tttGzB\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =100.;\t//beats per minute\nconst float steps=480.;\t//block length\nconst float start=2.;   //start count (beats)\n\n//STATE\nfloat gtime=0.;\t//time\nint   gchord=0;\t//chord\nfloat garp=0.;\t//arpeggio pattern\nfloat gdyn=1.;\t//dynamics\n\n//RANDOM ARP PATTERN GENERATOR\n/*\nfloat hash(float s){s=fract(s*.13);s*=s+33.33;return fract(s+s*s);}\nfloat pgen(float s,float r){\n    int p=0;\n    for(int i=0;i<16;i+=2){p+=int(hash(s)*r)<<i;s+=1.;}\n    return float(p);\n}\n*/\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){\n    vec2 v=pow(abs(i*p.x),vec2(1./p.y));\n    return clamp(sign(i)*v,-1.,1.)*p.z;\n}\n\n//CHORD\n//  global int gchord ...hex tetrad chord pattern\n/*\nfloat chord(float n){ // n:place in gchord (0-3)\n    float c=0.;\n    if(n>2.)c+=float((gchord>>8)&15);\n    if(n>1.)c+=float((gchord>>4)&15);\n    if(n>0.)c+=float(gchord&15);\n    return c; // return:relative note number to add to root note\n}\n*/\n\n//ARPEGGIATOR\n//  vec3 p( pattern, step_length, pattern_steps)\n//    arp_gate :p.pattern ...1bit pattern 1-16 steps 0:off 1:on\n//    arp_chord:p.pattern ...2bit pattern 1-8 steps 0-3:note\n/*\nfloat arp_gate(float t,vec3 p){\n    float l=15.*p.y/bpm;\n    float g=float((int(p.x)>>int(mod(t/l,p.z)))&1);\n    return (g>0.)?mod(t,l):-1.; // return:gate time or note off (-1)\n}\nfloat arp_chord(float t,vec3 p){\n    return chord(float((int(p.x)>>int(floor(mod(t/(15.*p.y/bpm),p.z))*2.))&3));\n}\n*/\n\n//FREQUENCY FROM MIDI NOTE NUMBER\n//single note\nfloat freq(float n){\n    return pow(2.,(n-69.)/12.)*base*6.283;\n}\n//with tetrad chord\n/*\nvec4 freq4(float n){\n    vec4 r;\n    r.x=freq(n);\n    r.y=gchord>0?freq(n+chord(1.)):0.;\n    r.z=gchord>16?freq(n+chord(2.)):0.;\n    r.w=gchord>256?freq(n+chord(3.)):0.;\n    return r;\n}\n*/\n\n//SOUND GENERATORS\n//  sequence => note pattern => instrument => oscillator\n\n//OSC\nfloat osc_saw(float x,float v){return clamp(mod(x/6.283,1.)*2.-1.,-1.,1.)*v;}\nfloat osc_sin(float x,float v){return clamp(sin(x)*v,-1.,1.);}\nfloat osc_sqr(float x,float v){return clamp(sign(sin(x))*v,-1.,1.);}\nfloat osc_noise(float x,float v){x=floor(x*1e3/v)*1e-3;return fract(sin(x*1717.17)*1313.13)*2.-1.;}\nfloat osc_metal(float x,float v){return fract(sin(x*v*171.17)*313.13)*2.-1.;}\n\n//ENVELOPE\n//const vec4 env0=vec4(0.00,.2,0.60,1.50); //piano\nconst vec4 env1=vec4(0.10,.4,0.50,0.50); //woodwind\n//const vec4 env2=vec4(0.20,.6,0.50,0.50); //string\n//const vec4 env3=vec4(0.00,.2,0.90,1.50); //synth\nconst vec4 env4=vec4(0.00,.2,0.60,1.50); //koto\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\nfloat env_ad(float x,float a,float d){return min(x/max(a,1e-4),max(0.,1.-(x-a)/max(d,1e-4)));}\nfloat env_adsr(float x,vec4 e,float g){return max(0.,min(1.,x/max(e.x,1e-4))-min(1.-e.z,max(x-e.x,0.)*(1.-e.z)/max(e.y,1e-4))-max(x-g,0.)*e.z/max(e.w,1e-4));}\n\n//PERCUSSION INSTRUMENTS (time)\n/*\nfloat bass_drum(float x){return osc_sin(x*freq(46./(1.+x*2.)),8.*env_d(x,.11));}\nfloat snare_drum(float x){return (osc_noise(x,.194)*env_d(x,.15)+osc_sin(x*freq(53./(1.+x*.2)),8.*env_d(x,.4)));}\nfloat hihat(float x,float d){return osc_metal(x,2.5)*env_d(x,d);}\n*/\n\n//MELODIC INSTRUMENTS (freq)\n/*\nfloat vibe(float f){return osc_sin(f+osc_sin(f*8.+osc_sin(f*.02,1.),.3),1.5);}\nfloat harpsi(float f){return osc_saw(f*4.+osc_sin(f*18.,.5),1.3);}\nfloat organ(float f){return osc_sin(f,1.3)+osc_sin(f*.5,1.)+osc_sin(f*2.,1.)+osc_sin(f*4.,.5);}\nfloat reed(float f){return osc_sin(f,1.)*osc_sqr(f*3.,1.);}\nfloat flute(float f){return osc_sin(f,1.)*osc_sin(f*2.,1.);}\nfloat sawlead(float f){return osc_saw(f,1.)+osc_saw(f*2.01,1.);}\nfloat sqrlead(float f){return osc_sqr(f,.7)+osc_sqr(f*2.01,.7);}\nfloat synlead(float f){return osc_saw(f,1.)*osc_sqr(f*3.02,1.);}\n*/\n\n//MELODIC INSTRUMENTS (freq,time)\n/*\nfloat piano(float f,float x){return osc_sin(f+osc_sin(f,env_d(x,.5))+osc_sin(f*3.,env_d(x,2.)*.8),1.);}\nfloat epiano(float f,float x){return osc_sin(f+osc_sin(f*15.,.04)+osc_sin(f*.99,.4),1.);}\nfloat bass(float f,float x){return osc_sin(f*.5+osc_sin(f*4.,env_d(x,.06)*.5)+osc_sin(f,env_ad(x,.1,.2)*.4),2.)*env_d(x,.6);}\nfloat bell(float f,float x){return osc_sin(f+osc_sin(f*3.4,env_d(x,1.)*.2)+osc_sin(f*4.,.5),1.);}\nfloat guitar(float f,float x){return osc_sin(f+osc_sin(f*8.,env_d(x,.05)*.3)+osc_sin(f*5.,env_ad(x,.03,5.)*.3),2.);}\nfloat aguitar(float f,float x){return osc_sin(f+osc_sin(f*8.,env_d(x,.05)*.3)+osc_sin(f*2.5,env_ad(x,.03,5.)*.3),2.);}\n*/\nfloat koto(float f,float x){\n    return osc_sin(f+osc_sin(f*9.,env_d(x,.1))+osc_sin(f*3.,env_ad(x,.05,3.)),2.);}\nfloat shakuhachi(float f,float x){\n    return osc_sin(f*.5+osc_sin(f,.5)+osc_sin(f*2.,.5)+osc_noise(x,.2)*env_ad(x,.04,.45)*.3,1.);}\n\n//NOTE OPERATORS\nfloat bup(float x){return min(x*(bpm/30.)-1.,0.);}\nfloat bdwn(float x){return max(1.-x*(bpm/30.),0.);}\nfloat pral(float x){float y=20./bpm;return ((x>y/2.)&&(x<y))?2.:0.;}\nfloat mord(float x){float y=20./bpm;return ((x>y/2.)&&(x<y))?-2.:0.;}\nfloat tril(float x){return sign(sin(3.14+x*bpm*6.28/15.))+1.;}\n\n//NOTE PATTERNS\n//P( note length, num of notes) ...pattern init\n//T( position)                  ...set trigger (for percussion)\n//N( position, note)            ...set note (for melody)\n//NN( position, note)           ...set note without gate\n//NU( position, note)           ...set note with bend up\n//ND( position, note)           ...set note with bend down\n//NP( position, note)           ...set note with pral triller\n//NM( position, note)           ...set note with mordent\n//NT( position, note)           ...set note with trill\n//X( position, macro)           ...execute macro (CHORD_mM7 etc.)\n//X( position, code)            ...execute code (gchord=0x333; etc.)\n#define P(l,s) float x=1e3,y=15.*float(l)/bpm,z=0.,v=mod(t,y*float(s));\n#define T(s) if(v>float(s)*y){x=v-float(s)*y;}\n#define N(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n);}\n#define NN(s,n) if(v>float(s)*y){z=float(n);}\n//#define NU(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+bup(x);}\n//#define ND(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+bdwn(x);}\n#define NP(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+pral(x);}\n#define NM(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+mord(x);}\n//#define NT(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+tril(x);}\n//#define X(s,n) if(v>float(s)*y){x=v-float(s)*y;n;}\n\n#define R -1e3\n#define C  60.\n#define Cs 61.\n#define Db 61.\n#define D  62.\n#define Ds 63.\n#define Eb 63.\n#define E  64.\n#define F  65.\n#define Fs 66.\n#define Gb 66.\n#define G  67.\n#define Gs 68.\n#define Ab 68.\n#define A  69.\n#define As 70.\n#define Bb 70.\n#define B  71.\n#define HI  12.+\n#define LO -12.+\n\n/*\n#define CHORD_3        gchord=0x484;\n#define CHORD_4        gchord=0x575;\n#define CHORD_5        gchord=0x757;\n#define CHORD_M        gchord=0x534;\n#define CHORD_on3      gchord=0x453;\n#define CHORD_on5      gchord=0x345;\n#define CHORD_sus4     gchord=0x525;\n#define CHORD_sus4on4  gchord=0x552;\n#define CHORD_sus4on5  gchord=0x255;\n#define CHORD_7        gchord=0x334;\n#define CHORD_7sus4    gchord=0x325;\n#define CHORD_7alt     gchord=0x424;\n#define CHORD_M7       gchord=0x434;\n#define CHORD_M7sus4   gchord=0x425;\n#define CHORD_m        gchord=0x543;\n#define CHORD_mon3     gchord=0x354;\n#define CHORD_mon5     gchord=0x435;\n#define CHORD_m7       gchord=0x343;\n#define CHORD_mM7      gchord=0x443;\n#define CHORD_add9     gchord=0x734;\n#define CHORD_madd9    gchord=0x743;\n#define CHORD_add9on5  gchord=0x552;\n*/\n\n//#define DYN_ff gdyn=1.0;\n//#define DYN_f  gdyn=0.9;\n#define DYN_mf gdyn=0.8;\n//#define DYN_mp gdyn=0.7;\n//#define DYN_p  gdyn=0.6;\n//#define DYN_pp gdyn=0.5;\n\n/*\n#define ARP4_up 58596.\n#define ARP4_down 6939.\n#define ARP4_updown 18148.\n#define ARP4_downup 47387.\n#define ARP4_p1 18118.\n#define ARP4_p2 4656.\n\n#define ARP3_up 18724.\n#define ARP3_down 24966.\n#define ARP3_updown 25700.\n#define ARP3_downup 17990.\n#define ARP3_p1 4486.\n#define ARP3_p2 8480.\n*/\n\n//NOTE PATTERNS:percussion\n/*\nvec2 bd(float t,float p){\n    float g=arp_gate(t,vec3(p,1.,16.));\n    return g<0.?vec2(0):amp(vec2(.6*bass_drum(g*1.05),.6*bass_drum(g*.95)),vec3(1,2.2,1));\n}\nvec2 sd(float t,float p){\n    float g=arp_gate(t,vec3(p,1.,16.));\n    return g<0.?vec2(0):vec2(.4*snare_drum(g*.995),.4*snare_drum(g*1.005));\n}\nvec2 hh(float t,float p1,float p2){\n    float g=arp_gate(t,vec3(p1,1.,16.));\n    vec2 r=g<0.?vec2(0):vec2(.2)*hihat(g,.08);\n    g=arp_gate(t,vec3(p2,2.,8.));r+=g<0.?vec2(0):vec2(.2)*hihat(g,.3);\n    return r;\n}\n*/\n\n//NOTE PATTERNS:koto\nvec2 ko(float x,float n){\n\tfloat fl=freq(n)*x,fr=fl*1.005;fl*=.995;\n    return vec2(koto(fl,x)*env_adsr(x,env4,.1),koto(fr,x)*env_adsr(x,env4,.1))*gdyn;\n}\nvec2 ko1(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,E)\n    N(5.1,A)\n    N(5.8,B)\n    N(6.6,A)\n    N(7.5,E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko2(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,E)\n    N(5.1,A)\n    N(5.8,B)\n    N(6.6,HI D)\n    N(7.5,HI E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko3(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,B)\n    N(5.1,HI D)\n    N(5.8,B)\n    N(6.6,A)\n    N(7.5,HI E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko4(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,HI E)\n    N(5.1,B)\n    N(5.8,A)\n    N(6.6,F)\n    N(7.5,E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko5(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,E)\n    N(5.1,F)\n    N(5.8,A)\n    N(6.6,B)\n    N(7.5,HI E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\n\n//NOTE PATTERNS:shakuhachi\nvec2 sh(float x,float n){\n    n+=sin(x*24.)*min(max(0.,x-.5),.01)+12.;\n\tfloat fl=freq(n)*x,fr=fl*1.0043;fl*=.9957;\n    return vec2(shakuhachi(fl,x)*env_adsr(x,env1,2.5),shakuhachi(fr,x)*env_adsr(x,env1,2.5))*gdyn;\n}\nvec2 sh1(float t,float o){\n    P(2,16)\n    N(15,D)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh2(float t,float o){\n    P(2,16)\n    N(0,E)\n    N(8,G)\n    N(10.9,E)\n    NN(11.5,D)\n    NN(12,LO B)\n    N(14,LO A)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh3(float t,float o){\n    P(2,16)\n    NM(0,LO B)\n    N(14,R)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh4(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(10.25,R)\n    N(12,D)\n    NN(13,E)\n    NN(14,G)\n    NN(15,A)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh5(float t,float o){\n    P(2,16)\n    N(0,B)\n    N(7.25,A)\n    NN(8,B)\n    N(15.75,R)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh6(float t,float o){\n    P(2,16)\n    N(4,E)\n    NP(7,D)\n    NN(8,LO B)\n    N(15,LO A)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh7(float t,float o){\n    P(2,16)\n    N(0,LO B)\n    N(10,R)\n    N(12,LO E)\n    N(14,E)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh8(float t,float o){\n    P(2,16)\n    N(0,E)\n    N(12,G)\n    NN(14,E)\n    NN(15,D)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh9(float t,float o){\n    P(2,16)\n    NM(0,E)\n    N(12,R)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\n\n//SEQUENCE\n#define TRACK t=time;v=vec2(0);\n#define   SEGNO(block,blocks)        if(t>float(block)*l){t=mod(t-float(block)*l,float(blocks)*l);\n#define     REP(block,blocks,repend) if((t>float(block)*l)&&(t<=float(block)*l+float(repend)*l)){t=mod(t-float(block)*l,float(blocks)*l);\n#define       SEQ(block,patterns)    if(t>float(block)*l){v=patterns;v*=d;}\n#define     NEXT                     }\n#define   DS                         }\n#define END                          o+=v;\nvoid sequence(float time,float l,float d,inout vec2 o){vec2 v=vec2(0);float t=time;\n\n    DYN_mf\n\n    TRACK //1 shakuhachi\n      SEGNO(0,10)\n        SEQ(1,sh1(t,0.))\n        SEQ(2,sh2(t,0.))\n        SEQ(3,sh3(t,0.))\n        SEQ(4,sh4(t,0.))\n        SEQ(5,sh5(t,0.))\n        SEQ(6,sh6(t,0.))\n        SEQ(7,sh7(t,0.))\n        SEQ(8,sh8(t,0.))\n        SEQ(9,sh9(t,0.))\n      DS\n    END\n\n    TRACK //2 koto\n      SEGNO(0,10)\n        REP(0,2,4)\n          SEQ(0,ko1(t,0.))\n          SEQ(1,ko2(t,0.))\n        NEXT\n        REP(4,4,8)\n          SEQ(0,ko3(t,0.))\n          SEQ(1,ko4(t,0.))\n          SEQ(2,ko5(t,0.))\n          SEQ(3,ko4(t,0.))\n        NEXT        \n        REP(8,2,10)\n          SEQ(0,ko1(t,0.))\n          SEQ(1,ko2(t,0.))\n        NEXT\n      DS\n    END\n\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.3\n#define MASTER_PRESSURE 1.1\n#define DELAY_REPEAT    9\n#define DELAY_WET       0.4\n#define DELAY_FEEDBACK  0.85\n#define DELAY_TIME      0.05\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;vec2 o=vec2(0),v=vec2(0);\n    if(time>170.){vol=(180.-min(time,180.))/10.;}\n    time-=start*60./bpm;if(time<0.)return o;\n    gtime=time;\n    sequence(time,l,1.,o);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;gtime-=r;\n        sequence(time,l,d,o);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}