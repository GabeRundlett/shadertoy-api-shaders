{
    "Shader": {
        "info": {
            "date": "1613295800",
            "description": "Detecting collisions between 3D SDFs (can be applied to other dimensions easily as well). The potential collision point is calculated in Buffer A to avoid having to recalculate it for each pixel (which is SLOW).",
            "flags": 32,
            "hasliked": 0,
            "id": "wltBRl",
            "likes": 21,
            "name": "3D SDF-SDF Collision Detection",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "collision",
                "sdf",
                "collisiondetection"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 1418
        },
        "renderpass": [
            {
                "code": "/*\nNote that the \"strings\" the shapes are hanging off of are also part of\ntheir distance fields so they get included as colliders.\n*/\n\nstruct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nSurface surfMin(in Surface a, in Surface b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nSurface mapScene(in vec3 p) {\n    float d1 = sdf1(p, iTime);\n    float d2 = sdf2(p, iTime);\n\n    Surface box = Surface(d1, vec3(0.0), vec3(0.0, 0.0, 1.0), vec3(1.0), 4.0);\n    Surface horseshoe = Surface(d2, vec3(0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 16.0);\n\n    p.y += 4.0;\n    Surface table = Surface(sdBox(p, vec3(5.0, 0.25, 5.0)) - 0.1, vec3(0.0), vec3(0.8, 0.4, 0.4), vec3(1.0), 4.0);\n\n    float hangerDist = sdCapsule(p - vec3(4.25, 4.5, 0.0), 4.5, 0.2);\n    hangerDist = min(hangerDist, sdCapsule(p.yxz - vec3(9.0, 1.75, 0.0), 2.5, 0.2));\n    Surface hanger = Surface(hangerDist, vec3(0.0), vec3(1.2, 0.8, 0.6), vec3(0.0), 0.0);\n\n    p.y -= 4.0;\n    vec3 hitPos = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    Surface hit = Surface(length(p - hitPos) - 0.25, vec3(0.0), vec3(1.0), vec3(0.0), 0.0);\n\n    return surfMin(box, surfMin(horseshoe, surfMin(table, surfMin(hanger, hit))));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 15.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            vec3 n = getNormal(p);\n            fragColor.rgb = scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            vec3 closest = texelFetch(iChannel0, ivec2(0), 0).xyz;\n            if (sdf1(closest, iTime) < 0.0) { // The SDFs are colliding (the choice of SDF doesn't matter btw)\n                fragColor.rg = vec2(1.0, 0.0);\n            }\n\n            break;\n        }\n\n        t += scene.dist;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Settings (completely overkill but buffers have saved me)\n#define ITERATIONS 1500\n#define DESCENT_RATE 0.005\n#define EPSILON 0.001\n#define DELTA 0.001\n\n// Animated positions\n#define horseshoePos(t) vec3(-5.0 * sin(cos(t * 1.5) * 1.25), 5.0 * cos(cos(t * 1.5) * 1.25) - 3.0, 0.0)\n#define boxPos(t) vec3(-5.0 * vec2(0.7) * sin(cos(t * 1.5) * 1.25), 3.0 - 5.0 * cos(cos(t * 1.5) * 1.25)).xzy\n\n// Utilities\nvoid Rotate(inout vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    p *= mat2(c, -s, s, c);\n}\n\n// Rotate on axis, from tdhooper (https://www.shadertoy.com/view/WlKyzW) who in turn got it from blackle\nvoid RotateAxis(inout vec3 p, in vec3 ax, in float ro) {\n    p = mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCapsule(in vec3 p, in float h, in float r) {\n    return length(vec3(p.x, max(0.0, abs(p.y) - h), p.z)) - r;\n}\n\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b, in float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(p - clamp(p, -s, s)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\nfloat sdHorseshoe(in vec3 p, in vec2 c, in vec3 w, in float r) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p.xy = mat2(-c.x, c.y, c.y, c.x) * p.xy;\n    p.xy = vec2((p.y > 0.0) ? p.x : -l * sign(c.x), (p.x > 0.0) ? p.y : l);\n    p.xy = vec2(p.x, abs(p.y - r)) - w.xy;\n    float d = length(max(p.xy, 0.0)) + min(0.0, max(p.x, p.y));\n    vec2 w2 = vec2(d, abs(p.z) - w.z);\n    return length(max(w2, 0.0)) + min(max(w2.x, w2.y), 0.0);\n}\n\n// SDFs\nfloat sdf1(in vec3 p, in float t) {\n    vec3 bp = boxPos(t);\n\n    float str = sdLine(p, vec3(-0.5, 5.0, 0.0), bp, 0.05);\n\n    p -= bp;\n    RotateAxis(p, vec3(0.58), t);\n    RotateAxis(p, vec3(0.7, 0.0, 0.7), -cos(t));\n\n    float b = sdBox(p, vec3(0.4, 1.0, 0.6)) - 0.1;\n    return min(b, str);\n}\n\nfloat sdf2(in vec3 p, in float t) {\n    vec3 hp = horseshoePos(t);\n    float osc = -cos(t * 2.0);\n\n    vec3 e = vec3(0.0, 1.0, 0.0);\n    Rotate(e.xy, osc);\n    Rotate(e.xz, t);\n    e += hp * vec3(1.0, -1.0, 1.0);\n    float str = sdLine(p, vec3(0.5, 5.0, 0.0), e, 0.05);\n\n    p.y *= -1.0;\n    p -= hp;\n    Rotate(p.xz, t);\n    Rotate(p.xy, osc);\n\n    float h = (sdHorseshoe(p, vec2(sin(0.25), cos(0.25)), vec3(1.0, 0.25, 0.2), 1.0) * 0.75) - 0.075;\n    return min(h, str);\n}\n\n// Gradients (numeric)\nvec3 grad1(in vec3 p, in float t) {\n    vec2 eps = vec2(DELTA, 0.0);\n    return vec3(sdf1(p + eps.xyy, t) - sdf1(p - eps.xyy, t),\n                sdf1(p + eps.yxy, t) - sdf1(p - eps.yxy, t),\n                sdf1(p + eps.yyx, t) - sdf1(p - eps.yyx, t)) / (2.0 * DELTA);\n}\n\nvec3 grad2(in vec3 p, in float t) {\n    vec2 eps = vec2(DELTA, 0.0);\n    return vec3(sdf2(p + eps.xyy, t) - sdf2(p - eps.xyy, t),\n                sdf2(p + eps.yxy, t) - sdf2(p - eps.yxy, t),\n                sdf2(p + eps.yyx, t) - sdf2(p - eps.yyx, t)) / (2.0 * DELTA);\n}\n\n// Gradient descent solver\n#define fmax(p, t) max(sdf1(p, t), sdf2(p, t))\nvec3 grad(in vec3 p, in float t) {\n    vec2 eps = vec2(DELTA, 0.0);\n    return vec3(fmax(p + eps.xyy, t) - fmax(p - eps.xyy, t),\n                fmax(p + eps.yxy, t) - fmax(p - eps.yxy, t),\n                fmax(p + eps.yyx, t) - fmax(p - eps.yyx, t)) / (2.0 * DELTA);\n}\n\nvec3 findClosest(in vec3 seed, in float t) {\n    vec3 closest = seed;\n    for (int i=0; i < ITERATIONS; i++) {\n        vec3 g = grad(closest, t);\n        closest -= g * DESCENT_RATE;\n        if (length(g) < EPSILON) {\n            break;\n        }\n    }\n\n    return closest;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor.xyz = findClosest(boxPos(iTime), iTime); // Starting with least nonconvex object seems to work best\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}