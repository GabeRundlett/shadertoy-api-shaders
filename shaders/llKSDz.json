{
    "Shader": {
        "info": {
            "date": "1483973444",
            "description": "mid-height: perceived color associated to each wavelength from 360 to 790 nm\nabove: without the gamma conversion.\nvery top: perceived color associated to each frequency\n\n( based on h3r2tic's https://www.shadertoy.com/view/4dVSDy )",
            "flags": 0,
            "hasliked": 0,
            "id": "llKSDz",
            "likes": 46,
            "name": "visible spectrum",
            "published": 3,
            "tags": [
                "spectrum",
                "rainbow",
                "hue",
                "perception",
                "wavelength",
                "cie",
                "xyzcolorspace"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2734
        },
        "renderpass": [
            {
                "code": "// based on SebH's https://www.shadertoy.com/view/MdKSzc\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n    \nvec3 xyzToRgb(vec3 XYZ)\n{\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );\n}\n\n#define SPECTRUM_START 360\n#define SPECTRUM_BIN   43\n#define SPECTRUM_STEP  10\n\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \n\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \n// intersect the intersection point may be stored in the floats i_x and i_y.\n\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    vec2 s1 = p1-p0, s2 = p3-p2;\n\n    float d = cross2(s1,s2),\n          s = cross2(s1, p0-p2) / d,\n          t = cross2(s2, p0-p2) / d;\n\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\n         ? p0 + t*s1    // Collision detected\n         : p0;\n}\n\nvec3 constrainXYZToSRGBGamut(vec3 col)\n{\n    vec2 xy = col.xy / (col.x + col.y + col.z);\n    \n    vec2 red   = vec2(0.64,   0.33  ),\n         green = vec2(0.3,    0.6   ),\n         blue  = vec2(0.15,   0.06  ),\n         white = vec2(0.3127, 0.3290);\n    \n    const float desaturationAmount = 0.1;\n    xy = mix(xy, white, desaturationAmount);\n    \n    xy = intersectSegment(xy, white, red,   green);\n    xy = intersectSegment(xy, white, green, blue );\n    xy = intersectSegment(xy, white, blue,  red  );\n    \n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 uv )\n{\n\tuv /= iResolution.xy;\n    \n    // Draw XYZ curves at the bottom\n\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\n    \n    \n    // Display XYZ spectrum curve\n\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\n   \n\n    // Spectrum -> xyz -> rgb absorption gradient\n\n    float spectrum[SPECTRUM_BIN];\n    for(int i=0; i<SPECTRUM_BIN; ++i)\n    {\n      #if 1\n        spectrum[i] = 0.014;// uniform band distribution\n      #else\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\n    \t      X = xFit_1931(w),\n    \t      Y = yFit_1931(w),\n    \t      Z = zFit_1931(w);\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\n      #endif\n    }\n    \n\n \n#define sqr(x) ((x)*(x))\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\n#define S 1.\n//#define S ((2.*uv.y-1.)*10.)\n    \n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\n        \n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\n    float spectrum2[SPECTRUM_BIN],\n        depth = uv.x * 1000.;\n    for(int i=0; i<SPECTRUM_BIN; ++i)\n    {\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\n    }\n    \n    vec3 colorXYZ = vec3(0),\n        color2XYZ = vec3(0);\n    for(int i=0; i<SPECTRUM_BIN; ++i)\n    {\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \n             dw = float(SPECTRUM_STEP);\n\n        vec3 xyzFit = dw * xyzFit_1931(w);        \n        colorXYZ  += spectrum [i] * xyzFit;\n        color2XYZ += spectrum2[i] * xyzFit;\n\t}\n    \n    vec3 color = xyzToRgb(colorXYZ),\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\n    \n\n    // perceived colors at the top\n\n    if(uv.y > .5) {\n\t\toutColor =  uv.y > .75 && uv.y < .9\n           ? color2                                  // without gamma transform\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\n        if ( uv.y < .55 || uv.y > .97 )           \n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\n    }\n\n    \n\tfragColor = vec4(outColor,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}