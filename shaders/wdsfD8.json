{
    "Shader": {
        "info": {
            "date": "1588189916",
            "description": "Messing with PBR BRDF's",
            "flags": 0,
            "hasliked": 0,
            "id": "wdsfD8",
            "likes": 18,
            "name": "Interference fractal",
            "published": 3,
            "tags": [
                "brdf"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 546
        },
        "renderpass": [
            {
                "code": "#define fracaxis normalize(vec3(2.+sin(iTime),2,3.+cos(iTime)))\n#define fracangle 1.\n#define fracscale 1.2\n#define fracshift vec4(0.05*sin(0.2*iTime), 0.1,0.+0.05*cos(0.2*iTime),0.)\n\n//fractal matrix\nmat4 fmat;\n\nfloat sdFract(vec3 p)\n{\n    vec4 cp = vec4(p,1.);\n    for(int i = 0; i < 16; i++)\n    {\n        cp = fmat*cp + fracshift;\n        mengerFold(cp);\n    }\n    return sdBox(cp.xyz + fracshift.xyz, vec3(0.5))/cp.w;\n}\n\nvec3 sdFractCol(vec3 p)\n{\n    p.xy = mod(p.xy + vec2(2.), vec2(4.)) - vec2(2);\n    vec4 cp = vec4(p,1.);\n    vec3 c = vec3(1,2,1);\n    for(int i = 0; i < 6; i++)\n    {\n        cp = fmat*cp + fracshift;\n        mengerFold(cp);\n        c = min(c,cp.xyz); \n    }\n    return tanh(abs(c));\n}\n\nvec2 map(vec3 p)\n{\n    p.xy = mod(p.xy + vec2(2.), vec2(4.)) - vec2(2);\n    vec2 d = vec2(sdFract(p), 0);\n    d = minid( vec2(p.z + 1., 1), d);\n    return d;\n}\n\nvec4 normal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\tvec4 r = k.xyyx*map(p + k.xyy*dx).x +\n\t\t\t k.yyxx*map(p + k.yyx*dx).x +\n\t\t\t k.yxyx*map(p + k.yxy*dx).x +\n\t\t\t k.xxxx*map(p + k.xxx*dx).x;\n    //the normal and the averaged distance\n    return vec4(normalize(r.xyz), r.w*0.25);\n}\n\nvec4 march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    vec2 d;\n    for(int i = 0; i < MAXI; i++)\n    {\n        d = map(p + td*r);\n        if(d.x <= LOD*td) break;\n        if(td > MAXD) \n        {\n            d.y = -1.;\n            break;\n        }\n        td += d.x;\n    }\n    td += d.x - LOD*td; //better surface\n    return vec4(p + td*r, d.y); //position and ID\n}\n\n#define AOscale 30.\nfloat AO(vec3 p, vec3 n, float td)\n{\n    vec2 de = map(p+AOscale*n*td*LOD);\n    return max(0.,tanh(de.x/(AOscale*td*LOD)));\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    LOD = 1.4/max(iResolution.x,iResolution.y);\n    fmat = fracscale*rotationMatrix(fracaxis, fracangle);\n    \n    vec2 uv = (pos - 0.5*iResolution.xy)/iResolution.x;\n    vec2 angle = (iMouse.z>0.)?(vec2(2.*PI, PI)*iMouse.xy/iResolution.xy - vec2(0,PI*0.5)):vec2(PI+0.2*iTime, 0.);\n\tvec3 r = getRay(angle, uv), cr = getRay(angle, vec2(0));\n    vec3 p = -0.6*cr;\n    \n    vec4 res = march(p, r);\n    float td = distance(res.xyz,p);\n    p = res.xyz;\n    \n    vec3 L = vec3(0,1,0);\n   \n    col.xyz = vec3(0.);\n    if(res.w < 0.)\n    {\n        col.xyz = sky(r);\n    }\n    else\n    {\n        vec4 n = normal(p, td*LOD);\n    \tmat a = materials[int(res.w)];\n        if(res.w == 0.)\n        \ta.albedo = sdFractCol(p - n.xyz*n.w);\n        float ao = AO(p, n.xyz, td);\n        //a few light sources\n       \tcol.xyz += BRDF(-r, vec3(cos(0.5),0,sin(0.5)), n.xyz, a);\n        col.xyz += BRDF(-r, vec3(0,cos(1.),sin(1.)), n.xyz, a);\n        col.xyz += BRDF(-r, vec3(0,sin(1.),cos(1.)), n.xyz, a)*3.;\n        col.xyz += BRDF(-r, vec3(0,-sin(1.),-cos(1.)), n.xyz, a);\n        col.xyz*=ao*sky(vec3(1.,0.,0.));\n    }\n    col = vec4(HDRmapping(col.xyz, 6.),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sdSph( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid mengerFold(inout vec4 z) \n{\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a; z.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a; z.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a; z.z += a;\n}\n\nvec2 minid(vec2 a, vec2 b)\n{\n    return (a.x<b.x)?a:b;\n}\n\nstruct mat\n{\n    vec3 albedo;\n    vec3 emiss;\n    float rough;\n    float metal;\n};\n    \nmat materials[3] = mat[3](mat(vec3(1.,0.02,0), vec3(0), 0.4, 0.2),\n    \t\t\t          mat(vec3(0.9,0.9,1.), vec3(0), 0.6, 0.2),\n                          mat(vec3(0.5,0.9,0.2), vec3(0), 0.1, 0.4));\n\n                  \n#define MAXD 64.\n#define MAXI 128\n#define FOV 1.5\nfloat LOD;\n\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat NGGX(vec3 n, vec3 h, float a)\n{\n    float a2 = sqr(a);\n    return a2/(PI*sqr( sqr( max(dot(n,h),0.) )*(a2-1.) + 1.));\n}\n\nfloat GGX(vec3 n, vec3 o, float a)\n{\n    float ndoto = max(dot(n,o),0.);\n    return ndoto/mix(1., ndoto, sqr(a+1.)*0.125);\n}\n\nfloat GS(vec3 n, vec3 i, vec3 o, float a)\n{\n    return GGX(n,i,a)*GGX(n,o,a);\n}\n\nvec3 IR(float D, float k0, vec3 k1)\n{\n    //interference effect here ->\n    return (0.25+ k0*( 1. - cos(2.*PI*pow(vec3(D), -k1)) ))/D ;\n}\n\nvec3 BRDF(vec3 i, vec3 o, vec3 n, mat m)\n{\n    vec3 h = normalize(i + o);\n    vec3 F0 = mix(vec3(0.04), m.albedo, m.metal);\n    vec3 FS = F0 + (1.0 - F0) * pow(1.0 - max(dot(h, i), 0.0), 5.0);\n    vec3 DFG = NGGX(n,h,m.rough)*GS(n,i,o,m.rough)*FS;\n    float denom = max(dot(n, i), 0.001) * max(dot(n, o), 0.001);\n    return (m.albedo*(1.-FS)/PI +\n            DFG*IR(denom, 1., vec3(1.,1.1,1.2)))*max(0., dot(n,o));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nvec3 sky(vec3 r)\n{\n    vec3 c = vec3(.009, .288, .828);\n\tc = mix(vec3(1.), c, .9);\n\tc *= .5;\n    float atmo = tanh(10.*(r.z-0.05))*0.4 + 0.5 + 0.1*r.z;\n    \n    vec3 g = vec3(atmo);  \n    vec3 A0 = pow(c, g);\n    vec3 B0 = 1.-pow(vec3(1.)-c, 1.-g);\n    \n    vec3 A = A0*(1.-A0);\n    vec3 B = B0*(1.-B0);\n    \n    return mix(A, B, g);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}