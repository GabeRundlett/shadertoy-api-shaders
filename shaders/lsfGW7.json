{
    "Shader": {
        "info": {
            "date": "1371670289",
            "description": "A poorly modelled samurai sword.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsfGW7",
            "likes": 6,
            "name": "Sword",
            "published": 3,
            "tags": [
                "ray",
                "marching",
                "csg",
                "sword"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 1007
        },
        "renderpass": [
            {
                "code": "// by nikos papadopoulos, 4rknova / 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define USE_MOUSE\n\n#define EPSILON\t\t\t\t0.0005\n#define EPSILON_M\t\t\t0.01\n#define PI\t\t\t\t\t3.14159265359\n#define PI2\t\t\t\t\tPI * 0.5\n#define RADIAN\t\t\t\t180.0 / PI\n\n#define RMARCH_MAX_STEPS \t128\n#define SMARCH_MAX_STEPS\t64\n\n#define PENUMBRA_K\t\t\t20.0\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\nstruct Light\t{ vec3 p, d, s; };\nstruct Material { vec3 d, s; float e; };\n\nCamera c;\nLight  l;\n\nvec3  translate\t(vec3 v, vec3 t)\t { return v - t; }\nfloat opu\t\t(float d1, float d2) { return min( d1, d2); }\nfloat ops\t\t(float d1, float d2) { return max( d1,-d2); }\nfloat opi\t\t(float d1, float d2) { return max( d1, d2); }\n\nfloat ds_sphere\t(vec3 p, float r)\t\t\t{ return length(p) - r; }\nfloat ds_plane\t(vec3 p, vec4 n)\t\t\t{ return dot(p,normalize(n.xyz)) + n.w; }\t\t\t\t \nfloat du_boxr\t(vec3 p, vec3 b, float r)\t{ return length(max(abs(p)-b,0.0)) - r; }\nfloat du_floor\t(vec3 p, vec3 c, vec3 b, float r)\n{\n\tvec3 q = mod(p, c) - 0.5 * c;\n\tq.y = p.y;\n\treturn du_boxr(q,b,r);\n}\n\nfloat du_base (vec3 p)\n{\n\tfloat d = du_boxr(translate(p,vec3(-4.0,0.0,5.0)), vec3(0.5, 10.0, 2.5), 0.0);\n\t\t  d = opu(d, du_boxr(translate(p,vec3(4.0,0.0,5.0)), vec3(0.5, 10.0, 2.5), 0.0));\n\t\t  d = opu(d, du_boxr(translate(p,vec3(0.0,0.0,5.0)), vec3(10.5, 4.5, 1.5), 0.0));\n\t\t  d = ops(d, du_boxr(translate(p,vec3(0.0,9.5,4.5)), vec3(5.5, 0.8, 0.5), 0.6));\n\t\t  d = ops(d, ds_sphere(translate(p,vec3(-9.0,5.0,5.0)), 4.0));\n\t\t  d = ops(d, ds_sphere(translate(p,vec3( 9.0,5.0,5.0)), 4.0));\n\t\t  d = opu(d, du_boxr(translate(p,vec3(0.0,0.0,5.5)), vec3(3.4, 2.5, 2.5), 0.0));\n\t\t  \n\treturn d;\t\n}\n\nfloat du_sword(vec3 p)\n{\n\tfloat d = ds_sphere(translate(p,vec3(7.0,9.0,5.0)), 2.5);\n\t\n\t\t  d = opi(d, du_boxr(translate(p,vec3(7.0,9.0,5.0)), vec3(0.1, 3.0, 3.0), 0.0));\n\n\t\t  d = opu(d, du_boxr(translate(p,vec3(-4.0,9.0,5.0)), vec3(10.5, 0.05, 0.1), 1.0));\n\t\t  d = opu(d, du_boxr(translate(p,vec3(11.0,9.0,5.0)), vec3(3.5, 0.1, 0.1), 1.0));\n\t\t \n\treturn d;\n}\n\t\nvoid generate_ray(Camera c, in vec2 fragCoord, out Ray r)\n{\n\tfloat ratio = iResolution.x / iResolution.y;\n\n\tvec2  uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0)\n\t\t\t * vec2(ratio, 1.0);\n\t\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\n/********************************************************************************/\n// Scene\n/********************************************************************************/\n\n// Returns the distance from the scene geometry\nfloat scene_distance(vec3 p)\n{\n\tfloat d = du_floor(translate(p, vec3(0.0, -1.19,0.0)), vec3(2.0),vec3(0.7), 0.4);\n\td = opu(d, du_base(p));\n\td = opu(d, du_sword(p));\n\t\n\treturn d;\n}\n\n\nvec3 scene_normal(vec3 p, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(p.x + EPSILON, p.y, p.z));\n    n.y = scene_distance(vec3(p.x, p.y + EPSILON, p.z));\n    n.z = scene_distance(vec3(p.x, p.y, p.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 p, vec3 n, Light l, Material m, Camera c)\n{\n\treturn l.d * m.d * dot(n, normalize(l.p - p))\n\t\t + l.s * m.s * pow(clamp(dot(normalize(reflect(l.p - p, n)), normalize(p - c.p)), 0.0, 1.0), m.e);\n}\n\nvec3 scene_color(vec3 p)\n{\n\tvec3 col = vec3(0.6);\n\t\n\tif (p.y > 0.0)\n\t{\n\t\tcol = vec3(0.8,0.6,0.4);\n\t\t\n\t\tif (p.y > 5.0) {\n\t\t\tif (p.x > 6.88 && p.x < 7.2)\n\t\t\t\tcol = vec3(0.5);\n\t\t\telse if(p.x > 7.2)\n\t\t\t\tcol = vec3(0.3,0.4,0.5);\n\t\t\telse if (p.y > 8.0 && p.z > 3.8 && p.z < 5.7)\n\t\t\t\tcol = vec3(0.6,0.0,0.0);\n\t\t}\n\t}\n\n\treturn col;\n}\n\n/********************************************************************************/\n// Ray Marching\n/********************************************************************************/\n\n// Returns if there was an intersection.\nbool raymarch(Ray r, out vec3 p, out vec3 n)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++)\n\t{\n\t\td = scene_distance(pos); // Get the distance.\n\n\t\tif (d < EPSILON)\n\t\t{\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\n\treturn d < EPSILON;\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n\t\n\tfloat t = EPSILON_M;\n\t\n\tfor (int i = 0; i < SMARCH_MAX_STEPS; i++) {\n        float d = scene_distance(ro + rd * t);\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\treturn 0.0;\n\t\t\tbreak;\n\t\t}\n\t\t\n        res = min(res, PENUMBRA_K * d / t);\n\n        t += d;\n    }\n\n    return res;\n}\n\n/********************************************************************************/\n// Main\n/********************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n \n\tc.p =\n#ifdef USE_MOUSE\n\t\tvec3(iMouse.x / iResolution.x * 20.0 - 10.0,\n\t\t\t 1.0 + 30.0 * iMouse.y / iResolution.y, -15.0);\n\t\t//c.p.z = c.p.x + c.p.y;\n#else\n\t\tvec3(-10.0, 25.0, -15.0);\n#endif\n\t\t\n\tc.t = vec3(0.0, 5.0, 0.0);\n\tc.u = normalize(vec3(0.1, 1.0, 0.0));\n\t\n\tRay r;\n\tgenerate_ray(c, fragCoord, r);\n\t\t\t\t \n\tvec3 sp, sn;\n\t\n\tvec3 col = vec3(0.0);\n\n\tif (raymarch(r, sp, sn))\n\t{\n\t\tl.p = vec3(15.0 * cos(iTime), 14.0, -5.0 +  5.0 * sin(iTime));\n\t\tl.d = vec3(1.0);\n\t\tl.s = vec3(1.0);\n\t\t\n\t\tMaterial m;\n\t\tm.d = scene_color(sp);\n\t\tm.s = 1.0 - m.d;\n\t\tm.e = 128.0;\n\t\n\t\tcol = shadow(sp, normalize(l.p - sp)) * scene_shade(sp, sn, l, m, c);\n\t}\n\t\n\t// Fade in\t\n\tcol *= smoothstep(EPSILON, 3.5, iTime);\n\t\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}