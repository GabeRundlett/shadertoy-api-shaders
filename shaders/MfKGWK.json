{
    "Shader": {
        "info": {
            "date": "1713717691",
            "description": "Some palette effect, coming from a popular demo from some years ago (future crew - unreal - 1992).\nI think it's done with a fixed image and only the palette (vga, 256 colors) is changed.",
            "flags": 0,
            "hasliked": 0,
            "id": "MfKGWK",
            "likes": 6,
            "name": "slightly real",
            "published": 3,
            "tags": [
                "palette"
            ],
            "usePreview": 0,
            "username": "sedcore",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "/* 2024-04 - public domain */\n\n/* Some palette effect,\n * coming from a popular demo from some years ago\n * (future crew - unreal - 1992).\n * I think the original is done with a fixed image\n * and only the palette (vga, 256 colors) is changed.\n */\n\nfloat map(vec3 p)\n{\n  /* should find better map function... */\n  return p.y + 2. +min(3.*cos(-length(p.xz)),length(p.xz)>3.14159?-3.:1.);\n}\n\nvec3 paletteA(vec2 p)\n{\n  vec2 q = vec2(length(p), atan(p.x,p.y)/atan(1.));\n  vec2 qb = abs(fract(4.*q+vec2(iTime*4., iTime*2.)) * 2. - 1.);\n  vec3 blue = vec3(.2,.7,1.);\n  vec2 alpha = exp(-qb*qb*20.);\n  return blue * length(alpha);\n}\n\nvec3 paletteB(vec2 p)\n{\n  int fc[16*16] = int[16*16](\n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,\n2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n  );\n  float intens[4] = float[4](\n    .8,\n    .65,\n    .9,\n    .5);\n  vec3 red = vec3(1,0,0);\n  vec2 q = vec2(length(p), atan(p.x,p.y)/atan(1.));\n  vec2 qb = 16.*fract(4.*q+vec2(iTime*4.,iTime*2.));\n  return red * intens[fc[int(qb.x) * 16 + int(qb.y)]];\n}\n\nfloat on(float start, float end, float speed, float v)\n{\n  return min(smoothstep(start, start+speed, v),\n             smoothstep(1.-end, 1.-end+speed, 1.-v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n  \n  /* camera */\n  vec3 eye = vec3(0., 2.5, 5.);\n  vec3 target = vec3(0.,-1.,0.);\n  float focal = 1.2;\n  vec3 ro = eye;\n  vec3 camera_center = ro + focal * normalize(target-ro);\n  vec3 rdx = vec3(1.,0.,0.);\n  vec3 rdy = normalize(cross(rdx, target-ro));\n  rdx/=1.8; rdy/=1.8;\n  vec3 rd = normalize(camera_center + rdx * uv.x + rdy * uv.y - ro);\n\n  /* raymarch - should find a better map */\n  float t = 0.;\n  int i;\n  float d;\n  vec3 p;\n  for (i = 0; i < 100; i++) {\n    p = ro + t * rd;\n    d = map(p);\n    if (d < 0.01) break;\n    //if (d > 100.) break;\n    t += d*.3;\n  }\n\n  /* colormap */\n  vec3 col = on(0.,.55,.07, fract(iTime/10.)) * paletteA(p.xz) +\n             on(.5,.95,.14, fract(iTime/10.)) * paletteB(p.xz);\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}