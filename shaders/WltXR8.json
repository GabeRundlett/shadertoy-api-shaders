{
    "Shader": {
        "info": {
            "date": "1580392371",
            "description": "Code is messy!\nKinda looked better with no post hmm",
            "flags": 32,
            "hasliked": 0,
            "id": "WltXR8",
            "likes": 8,
            "name": "Day 42 - Magma",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 615
        },
        "renderpass": [
            {
                "code": "//Code is messy!\n// Kinda looked better with no post hmm\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragCoord += sin(40.*fragCoord/iResolution.xy + iTime*1.5)*2.;\n    \n    vec4 tA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bA = texture(iChannel0, (fragCoord)/iResolution.xy, 5.);\n    vec4 bB = texture(iChannel0, (fragCoord + vec2(0,iTime*3.4) + sin(iTime + 10.*fragCoord/iResolution.xy))/iResolution.xy, 5.);\n    \n    bA = pow(bA, vec4(1.4));\n    bA.r *= 0.7;\n    \n    fragColor = tA ;\n    fragColor -= bB *(0.5 + sin(iTime*0.5)*0.15)*0.8;\n    fragColor*= 1.8;\n    fragColor.b = min(fragColor.b, 0.1);\n    \n    float f = pow( (1. - fragColor.r), 9.);\n    fragColor.g -= f;\n    //fragColor += 0.2;\n    fragColor *= 1.3;\n    //fragColor.g *= 1. - length(vec2(1) - fragColor.rb);\n    //fragColor = bB;\n    //fragColor = tA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 r22(vec2 x){return vec2(\n\tfract(sin(x.y*213.124)*214.),\n\tfract(sin(x.x*513.524)*614.5)\n);}\nfloat voronoi (vec2 uv){\n    \n    uv += sin(uv*2.)*0.2;\n    vec2 fuv = fract(uv) - 0.5;\n    vec2 uvid = floor(uv);\n    \n    vec2 me = r22(uvid);\n    vec2 u = r22(uvid + vec2(0,1)) + vec2(0,1);\n    vec2 d = r22(uvid - vec2(0,1)) - vec2(0,1);\n    vec2 l = r22(uvid - vec2(1,0)) - vec2(1,0);\n    vec2 r = r22(uvid + vec2(1,0)) + vec2(1,0);\n    \n    vec2 ul = r22(uvid + vec2(1,-1))+ vec2(1,-1);\n    vec2 ur = r22(uvid + vec2(1,1))+ vec2(1,1);\n    vec2 dl = r22(uvid + vec2(-1,-1))+ vec2(-1,-1);\n    vec2 dr = r22(uvid + vec2(-1,1)) + vec2(-1,1);\n    \n    vec3 col = vec3(0);\n\n    \n    float Di = distance(me,fuv);\n    float Du = distance(u,fuv);\n    float Dd = distance(d,fuv);\n    float Dl = distance(l,fuv);\n    float Dr = distance(r,fuv);\n    \n    float Dul = distance(ul,fuv);\n    float Dur = distance(ur,fuv);\n    float Ddl = distance(dl,fuv);\n    float Ddr = distance(dr,fuv);\n    \n    \n    float ddd = min(Di, Du);\n    ddd = min(ddd, Dd);\n    ddd = min(ddd, Dl);\n    ddd = min(ddd, Dr);\n    \n    ddd = min(ddd, Dul);\n    ddd = min(ddd, Dur);\n    ddd = min(ddd, Ddl);\n    ddd = min(ddd, Ddr);\n    \n    float c =  ddd;\n    \n    return  c;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec3 glow = vec3(0);\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt -ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define mx (iTime*0.5 + 10.*iMouse.x/iResolution.y)\n\n\n\n// noise from IQ\nvec2 r22t(vec2 x){\n\treturn texture(iChannel0, (x)).xy; \n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0. ).x;\n}\n\n\nfloat noiseC(in vec2 x){\n\tfloat n = noise(x)*0.5;\n\tn += noise(x*0.5)*0.5;\n\tn += noise(x*2.02)*0.3;\n\tn += noise(x*3.05)*0.2;\n\t//n += noise(x*5.05)*0.02;\n    n = smoothstep(0.,1.,n);\n        \n    return n;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\nfloat sdPyra(vec3 p){\n    float d;\n    d = sdBox(p, vec3(5));\n    //p = abs(p) - 2.4;\n    for (int i = 0; i < 3; i++){\n        p.xz *= rot(tau/3.);\n        //d.x = max(d.x, dot(p, normalize(vec3(2.5,1.,0))));\n        d = max(d, dot(p, normalize(vec3(2.5,1.,0))));\n    }\n    //d.x = max(d.x,-p.y - 0.7);\n    d = max(d,-p.y - 1.);\n\treturn d;\n}\nfloat noi;\nfloat v;\nfloat vB;\n\nfloat r21(vec2 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125)*124115.125235);\n}\nfloat valueNoise(vec2 uv){\n    vec2 id = floor(uv);\n    vec2 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float tl = r21(id);\n    float tr = r21(id + vec2(1,0));\n    float bl = r21(id + vec2(0,-1));\n    float br = r21(id + vec2(1,-1));\n    \n    float c = \n        mix(\n            mix(\n\t\t\t\tbl,                \n                br,\n                fd.x\n    \t\t),\n            mix(\n\t\t\t\ttl,                \n                tr,\n                fd.x\n    \t\t), fd.y\n           );\n    return c;\n}\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e5);\n\n    //d.x = min(d.x, length(p) - 0.5);\n\n    //p = abs(p);\n    \n\tvec2 offs =vec2(0. + iTime*0.1,0.2);\n    float dG = p.y + 0.5;\n    dG += valueNoise(p.xz)*0.4;\n    p.xz += offs;\n    v = voronoi(p.xz*1.5);\n    vB = voronoi(p.xz*2.5 ); \n    noi = noiseC(p.xz*20.);\n    dG += clamp(pow(v*1.12 + noi*0.17, 11.), 0., 0.3)*0.6;\n    dG += (1. - v) * 0.1;\n    dG -= (1. + vB*0.6 + noi*0.06)* 0.089;\n    dG += 0.04;\n    \n    dG -= noi*0.01;\n    //dG ;\n    //dG +=noiseC(p.xz*2.)*0.2;\n    dG -= 0.22; \n    d.x = min(d.x, dG);\n    \n    //d.x = min(d.x, sdPyra(p));\n    //p.x -= 0.6;\n    //d.x = min(d.x, sdPyramid( p*1.3, 1.));\n    d.x *= 0.4;\n    //d.x = min(d.x, max(valueNoise(p*1.)*0.1, 0.1)); \n    //d.x = min(d.x, max(noise(p*1.)*0.1, 0.1));\n\treturn d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\t\n    vec2 d = vec2(10e5);\n    hit = false;\n    t = 0.;\n    p = ro + rd;\n    for(int i = 0; i < 150 ; i++){\n    \td = map(p);\n        \n        glow += exp(-d.x*20.);\n        \n        if(d.x < 0.002){\n            hit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    \n    ro.z += mx;\n    \n    //ro.x += sin(iTime)*3.;\n    //ro.z += cos(iTime)*3.;\n    \n    bool hit;\n    vec3 lookAt = vec3(0.001);\n    lookAt. y -= 0.7;\n    lookAt.z = ro.z + 2.;\n    //lookAt.y -= 0.7;\n    uv.xy *= rot(0.2 + sin(iTime*0.2)*0.2);\n    uv *= 1. + dot(uv,uv)*0.2;\n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p; float t;\n    vec2 d = march( ro, rd,p,t, hit);\n\n    if (hit){\n        vec3 lD = normalize(vec3(0.4,1,1));\n        vec3 h = normalize(lD - rd);\n        vec3 n = getNormal(p);\n        float diff = max(dot(n,lD),0.);\n        float spec = pow(max(dot(n,h),0.), 20.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        noi = pow(noi, 3.);\n        //noi = smoothstep(0.,1.,noi);\n        noi *= 0.2; \n        diff =diff*noi*0.3;\n    \tcol += mix(diff*vec3(1), spec*vec3(1.4,0.7,0.1)*0.5, 0.4 - noi*0.2);\n    }\n    vec3 g = glow*0.1*pal(0.5,0.5,vec3(4.7,2.4,0.7),0.5,4.7  );\n    \n    g.r *= 0. + (2.)*pow(v,2.);\n    //g.r -= noi;//\n    g.g *= 0. + 2.*pow(v*0.97,2.);\n    \n    col += g;\n    col += max(-p.y - 0.5,0.);\n    uv.y *= 1.7;\n    col *= 1. - dot(uv*1.1,uv*1.1)*0.4;\n    col = max(col, vec3(0));\n    col = smoothstep(0.,1.2,col); // wtf, this makes the image\n    \n    col *= 1.4;\n    //col = mix(col, vec3(1.3,0.7,00)*0.5,smoothstep(0.,1.6,t*0.15 - 0.6));\n    col = pow(col, vec3(0.4545));\n    //col.b *= 0.86;\n\tcol.r *= 1.1;\n    //col.g -= col.r;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}