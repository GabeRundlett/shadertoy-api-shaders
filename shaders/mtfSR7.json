{
    "Shader": {
        "info": {
            "date": "1674484589",
            "description": "Atmosphere",
            "flags": 0,
            "hasliked": 0,
            "id": "mtfSR7",
            "likes": 16,
            "name": "AtmosphereXXX",
            "published": 3,
            "tags": [
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "___HackerMann___",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "vec3 sphere_centre = vec3(0);\nfloat sphere_radius = 0.4;\n\nvec2 sphere_line_intersection(in vec3 centre, in float radius, in vec3 ray_origin, in vec3 ray_direction) {\n    float dir_sqr = dot(ray_direction, ray_direction);\n    float diff = dot(ray_direction, centre - ray_origin);\n    float sum = dot(ray_origin, ray_origin) + dot(centre, centre) - radius * radius;\n    float discr_sqrt = sqrt(diff * diff - dir_sqr * sum);\n\n    return vec2(\n        diff + discr_sqrt,\n        diff - discr_sqrt\n    ) / dir_sqr;\n}\n\nvec3 get_sphere_normal(in vec3 centre, in vec3 position) {\n    return normalize(position - centre);\n}\n\nvec3 calculate_density(in vec3 centre, in vec3 position, in float radius, in vec3 density_falloff) {\n    float initial_density = 1.0;\n\n    float dist = length(centre - position);\n    return initial_density * (exp(-dist / density_falloff) - exp(-radius / density_falloff));\n}\n\nvec3 calculate_volume(in vec3 ray_origin, in vec3 ray_direction, in float max_dist, in vec3 light_pos) {\n    int   MAX_STEPS = 5000 / 26;\n    float STEP_SIZE = 0.006;\n    vec3  EPS_GAS_VOLUME = vec3(1) / 10000.0;\n    vec3  PLANET_CENTRE = vec3(0);\n    float ATMOSPHERE_RADIUS = 0.65;\n    vec3  DISTANCE_MULTIPLIER = vec3(260, 220, 280) * 3000000.0;\n    \n    vec3 gas_volume = vec3(0.0);\n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 position = ray_origin + dist * ray_direction;\n        vec3 to_light_dir = normalize(light_pos - position);\n        to_light_dir.z *= -1.0;\n        vec2 t = sphere_line_intersection(sphere_centre, sphere_radius, position, to_light_dir);\n\n        vec3 density = max(calculate_density(\n            PLANET_CENTRE,\n            position,\n            ATMOSPHERE_RADIUS,\n            vec3(1, 1.07, 1.13) * 0.1\n        ), vec3(0));\n        \n        vec3 volume = STEP_SIZE * EPS_GAS_VOLUME * density;\n        \n        if (dist > max_dist - STEP_SIZE)\n            break;\n            \n        dist += STEP_SIZE;\n        \n        if (t.x < 1000.0 && 0.0 < t.x)\n            continue;\n            \n        float light_dist = length(light_pos - position);\n        gas_volume += volume / exp(light_dist * 2.0) * DISTANCE_MULTIPLIER;\n    }\n\n    return gas_volume;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ambient_brightness = 0.2;\n    float specular_power = 20.0;\n    float specular_multiplier = 0.4;\n    float gas_color_density = 18000.0;\n    float diffusion_intensity = 40.0;\n    \n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ray_origin = vec3(0, 0, -1);\n    vec3 ray_direction = normalize(vec3(uv, 0) - ray_origin);\n\n    vec2 t = sphere_line_intersection(sphere_centre, sphere_radius, ray_origin, ray_direction);\n    vec3 nearest_hit_pos = ray_origin + t.x * ray_direction;\n\n    vec3 light_pos = 6.0 * vec3(cos(2.0 * iTime), 1, sin(2.0 * iTime));\n    vec3 dir_to_light = normalize(light_pos - nearest_hit_pos);\n    \n    vec3 gas_volume = calculate_volume(ray_origin, ray_direction, t.x, light_pos);\n\n    vec3 normal = get_sphere_normal(sphere_centre, nearest_hit_pos);\n    float light_dist = length(nearest_hit_pos - light_pos);\n    float brightness = diffusion_intensity * max(ambient_brightness, dot(normal, dir_to_light))\n                     / (light_dist * light_dist);\n\n    vec3 reflected = reflect(-ray_direction, normal);\n    float r_dot_l = max(0.0, dot(dir_to_light, reflected));\n    float specular_brightness = pow(r_dot_l, specular_power) * specular_multiplier;\n\n    vec3 color = normal * 0.5 + 0.5;\n    color *= brightness;\n    color += specular_brightness;\n\n    color = clamp(color, 0.0, 1.0);\n    \n    vec3 gas_color = gas_volume * gas_color_density;\n\n    fragColor = vec4(gas_color + color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}