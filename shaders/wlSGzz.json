{
    "Shader": {
        "info": {
            "date": "1558263282",
            "description": "I'm learning how to make ocean by copying and simplifying\n\nbased on https://www.shadertoy.com/view/tlXGDj",
            "flags": 0,
            "hasliked": 0,
            "id": "wlSGzz",
            "likes": 3,
            "name": "Simplified ocean",
            "published": 3,
            "tags": [
                "seaocean"
            ],
            "usePreview": 0,
            "username": "takahiroando",
            "viewed": 536
        },
        "renderpass": [
            {
                "code": "// based on https://www.shadertoy.com/view/tlXGDj\n\nconst int MAX_MARCH = 15;\nconst int OCTAVE = 5;\nconst mat2 OCTAVE_M = mat2(1.6,1.2,-1.2,1.6);\nconst float EPSILON = 0.001;  // big epsilon is important to suppress noise\nconst vec3 SUN = normalize(vec3(0.0, 1.0, -1.0));\nconst vec3 WATER_LIGHTEST = vec3(0.6,0.7,0.5);\nconst vec3 WATER_DARKEST = vec3(0.1,0.2,0.25);\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_HEIGHT = 0.6;\n\n\nfloat random(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 678.9))) * 987654.321);\n}\n\n// value noise\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = random(i), c = random(i + vec2(0., 1.)),\n        b = random(i + vec2(1., 0.)), d = random(i + 1.);\n    vec2 u = smoothstep(0., 1., f);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat single_octave(vec2 uv) {\n    uv = sin(uv + 2.0 * noise(uv) - 1.0);\n    return pow(1.0 - pow(uv.x * uv.y, 1.5), SEA_CHOPPY);\n}\n\nfloat socean(vec3 pos) {\n    vec2 p = pos.xz;\n    p.x *= 0.5;\n    float h = 0.0;\n    float amp = SEA_HEIGHT;\n    float freq = 0.2;\n\n    float t = 100.0;\n    t = iTime * 0.5;  // @takahiroando: kill wave here by commenting out\n    \n    for (int i = 0; i < OCTAVE; ++i) {\n        h += (single_octave((p - t) * freq) + single_octave((p + t) * freq)) * amp;\n        p *= OCTAVE_M;\n        amp *= 0.2;\n        freq *= 2.0;\n    }\n    return pos.y - h;\n}\n\nfloat sdscene(vec3 pos) {\n    return socean(pos);\n}\n\nvec3 normal(vec3 pos) {\n    vec2 e0 = vec2(EPSILON, 0.);\n    float d = sdscene(pos);\n    return normalize(vec3(sdscene(pos + e0.xyy), sdscene(pos + e0.yxy), sdscene(pos + e0.yyx)) - d);\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 csky(vec3 e) {\n    e.y = max(e.y, 0.0);\n\n    vec3 ret;\n    ret.g = 1.0 - e.y;\n    ret.r = pow(ret.g, 3.0);\n    ret.b = 0.6 + ret.g * 0.4;\n    return ret;\n}\n\nfloat raymarch(vec3 pos, vec3 dir) {\n    float res = .0;\n    for (int i = 0; i < MAX_MARCH; ++i) {\n        float r = sdscene(pos);\n        res += r;\n        if (r <= EPSILON) {\n            break;\n        }\n        pos += dir * r;\n    }\n    return res;\n}\n\nvec3 shade(vec3 pos, vec3 eye, float d) {\n    vec3 n = normal(pos);\n    vec3 l = SUN;\n    // direct light from the sun\n    vec3 reflected = csky(reflect(eye, n)) * 0.5 + 10.0 * pow(max(dot(eye, reflect(l, n)), 0.0), 100.0);\n    // indirect light from the sun through water\n    vec3 refracted = WATER_DARKEST +  WATER_LIGHTEST * pow(0.4 * dot(n, l) + 0.6, 100.0) * 0.1;\n    refracted += WATER_LIGHTEST * 0.2 * (pos.y - 2.0 * SEA_HEIGHT);\n    \n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    float f0 = 0.1;\n    fresnel = f0 + (1.0 - f0) * pow(fresnel,5.0) * 0.65;\n    return mix(refracted, reflected, fresnel);\n}\n\nvec3 cocean(vec3 cp, vec3 cd) {\n    float d = raymarch(cp, cd);\n    return shade(cp + d * cd, cd, d);\n}\n\nvoid camera(out vec3 ro, out vec3 rd, vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = iTime * 0.1;\n    \n    vec3 cd = normalize(vec3(\n        2.0 * noise(vec2(t * 2.0, t * -0.5)) - 1.0,\n        2.0 * noise(vec2(t * 0.5, -t * 2.0)) - 2.0,\n        -2.0\n    ));\n\n    vec3 cr = normalize(cross(cd, vec3(0.25 * (2.0 * noise(vec2(t, -t)) - 1.0), 1.0, 0.0)));\n    vec3 cu = cross(cr, cd);\n    ro = vec3(2.0 * noise(vec2(t * 1.2, -t * 3.4) - 1.0), SEA_HEIGHT * 5.0, -t * 8.0);\n    rd = normalize(cr * uv.x + cu * uv.y + cd);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n    vec3 ro, rd;\n    camera(ro, rd, fragCoord);\n    \n    vec3 color = mix(\n        csky(rd),\n        cocean(ro, rd),\n        pow(smoothstep(0.0,-0.05,rd.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}