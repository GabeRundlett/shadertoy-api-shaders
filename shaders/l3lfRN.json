{
    "Shader": {
        "info": {
            "date": "1728134344",
            "description": "CC0: TIC-80 palette tinkering\n Did this a few weeks ago but forgot to publish\n",
            "flags": 0,
            "hasliked": 0,
            "id": "l3lfRN",
            "likes": 2,
            "name": "TIC-80 palette tinkering",
            "published": 3,
            "tags": [
                "tic80"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 4
        },
        "renderpass": [
            {
                "code": "// CC0: TIC-80 palette tinkering\n//  Did this a few weeks ago but forgot to publish\n\n// #define CELL_SIZE 128.\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PI_2        (0.5*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define LOOPS   4\n#define POWER   8.0\n#define ANIMATE\n\n\n#define RGB(r,g,b) vec3(float(r)/255.,float(g)/255.,float(b)/255.)\n// The iconic TIC-80 palette\nconst vec3 tic80[16] = vec3[](\n  RGB(0x1C, 0x1C, 0x2C)  // 0x0\n, RGB(0x5D, 0x27, 0x5D)  // 0x1\n, RGB(0xB1, 0x3E, 0x53)  // 0x2\n, RGB(0xEF, 0x7D, 0x57)  // 0x3\n, RGB(0xFF, 0xCD, 0x75)  // 0x4\n, RGB(0xA7, 0xF0, 0x70)  // 0x5\n, RGB(0x38, 0xB7, 0x64)  // 0x6\n, RGB(0x25, 0x71, 0x79)  // 0x7\n, RGB(0x29, 0x36, 0x6F)  // 0x8\n, RGB(0x3B, 0x5F, 0xC9)  // 0x9\n, RGB(0x41, 0xA6, 0xF6)  // 0xA\n, RGB(0x73, 0xEF, 0xF7)  // 0xB\n, RGB(0xF4, 0xF4, 0xF4)  // 0xC\n, RGB(0x94, 0xB0, 0xC2)  // 0xD\n, RGB(0x56, 0x6C, 0x86)  // 0xE\n, RGB(0x33, 0x3C, 0x57)  // 0xF\n);\n\n\nconst float TOLERANCE           = 1.0E-2      ;\nconst float MAX_RAY_LENGTH      = 30.         ;\nconst float NORM_OFF            = 0.001       ;\nconst float MAX_RAY_MARCHES     = 70.0        ;\nconst float MAX_SHADOW_MARCHES  = 25.0        ;\n\nfloat g_time;\nmat3 g_rot;\nvec3 g_gd;\n\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat ssphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p,p), 0.25)-r;\n}\n\nfloat ssphere4(vec4 p, float r) {\n  p *= p;\n  return pow(dot(p,p), 0.25)-r;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat acos_approx(float r) {\n  return atan_approx(sqrt(1.-r*r), r);\n}\n\nfloat asin_approx(float r) {\n  return atan_approx(r, sqrt(1.-r*r));\n}\n\nvec3 toSpherical_approx(vec3 p) {\n  float r   = length(p);\n  float t   = acos_approx(p.z/r);\n  float ph  = atan_approx(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat render0(vec3 ro, vec3 rd) {\n  vec3 sp = toSpherical_approx(rd);\n  float col = 0.;\n  if (rd.y > 0. ) {\n    const float skyCol = 12./16.;\n    float col0 = skyCol-0.5*(-0.125*hash(floor(10.*TAU*sp.z))+rd.y);\n    float col1 = mix(skyCol+2E-2, 0., smoothstep(1.,0.8, rd.z));\n    col = max(col0, col1);\n  } else {\n    const float groundCol = 5./16.;\n    col = 0.4*(sqrt(-rd.y)-0.18*hash(floor(-sp.zy*20.)));\n  }\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/noacos/\nmat3 rot(vec3 d, vec3 z) {\n  vec3  v = cross( z, d );\n  float c = dot( z, d );\n  float k = 1.0/(1.0+c);\n\n  return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n               v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n               v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// License: Unknown, author: EvilRyu, found: https://www.shadertoy.com/view/MdXSWn\nfloat mandelBulb(vec3 p) {\n  const float power = POWER;\n  vec3 z  = p;\n  vec3 dz = vec3(0.0);\n  float r, theta, phi;\n  float dr = 1.0;\n  \n  for(int i = 0; i < LOOPS; ++i) {\n    r = length(z);\n    if(r > 2.0) continue;\n    theta = atan_approx(z.y, z.x);\n#ifdef ANIMATE\n    phi = asin_approx(z.z / r) + g_time*0.2;\n#else\n    phi = asin_approx(z.z / r);\n#endif\n    \n    dr = pow(r, power - 1.0) * dr * power + 1.0;\n  \n    r = pow(r, power);\n    theta = theta * power;\n    phi = phi * power;\n    \n    z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n  }\n  return 0.5 * log(r) * r / dr;\n}\n\nvec2 mandelBulbous(vec3 p) {\n  const float mz = 3.; \n  vec3 p0 = p*g_rot;\n  vec3 p1 = p*g_rot;\n  float d1 = mandelBulb(p0/mz)*mz;\n  float d0 = ssphere4(p1, 3.2);\n  \n  return vec2(d0, d1);\n}\n\nfloat df1(vec3 p) {\n  vec2 dd = mandelBulbous(p);\n  float d0 = dd.x;\n  float d1 = dd.y;\n  float d2 = p.y+2.5;\n  \n  d2 = pmax(d2, -(d0-0.75), 0.25);\n  d0 = pmax(d0, -(d1-0.25), 0.25);\n  \n  g_gd = min(g_gd, vec3(d0, d1, d2));\n\n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n\n\n  return d;\n}\n\nfloat rayMarch1(vec3 ro, vec3 rd, float initt) {\n  float t = initt;\n\n  float i;\n  for (i = 0.0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) break;\n    float d = df1(ro + rd*t);\n    if (d < TOLERANCE) break;\n    t += d;\n  }\n\n  return t;\n}\n\nvec3 normal1(vec3 pos) {\n  vec2 eps = vec2(NORM_OFF, 0.0);\n  return normalize(vec3(\n      df1(pos+eps.xyy)-df1(pos-eps.xyy)\n    , df1(pos+eps.yxy)-df1(pos-eps.yxy)\n    , df1(pos+eps.yyx)-df1(pos-eps.yyx))\n    );\n}\n\n\nfloat render1(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(vec3(-1., 1., -1.));\n  g_gd = vec3(1E3);\n  float t1 = rayMarch1(ro, rd,0.);\n  vec3 gd = g_gd;\n  vec3 p1 = ro+rd*t1;\n  vec3 n1 = normal1(p1);\n  float st1 = rayMarch1(p1+n1*TOLERANCE*3., sunDir, TOLERANCE*3.);\n  float col = render0(ro, rd);\n  float dif = dot(n1, sunDir);\n  if (t1 < MAX_RAY_LENGTH) {\n    float col0 = 15./16.;\n    float col1 = 12./16.;\n    float dist = 0.11*hash(floor((90.*t1)));\n    if (gd.z < gd.x && gd.z < gd.y ) {\n      col0 = 6./16.;\n      col1 = 0./16.;\n      vec2 np = floor(p1.xz*0.25+vec2(0., 0.2*TIME));\n      if (mod(np.x+np.y, 2.) < 1.) {\n        col0 = 20./16.;\n        col1 = 14./16.;\n      }\n      dist *= 0.;\n    } else  if (gd.y < gd.x) {\n      col0 = 8./16.;\n      col1 = 5./16.;\n    } else {\n    }\n    if (dif > 0.) {\n      col = mix(col0, col1, dif-dist);\n    } else {\n      col = 0.;\n    }\n    \n    if (st1 < MAX_RAY_LENGTH) {\n      col = 0.;\n    }\n  }\n  \n  return col;\n}\n\nfloat effect(vec2 p) {\n  g_time = TIME+0.*length(p-vec2(0., 1.));\n  float a = g_time*0.25;\n  vec3 r0 = vec3(1.0, sin(vec2(sqrt(0.5), 1.0)*a));\n  vec3 r1 = vec3(cos(vec2(sqrt(0.5), 1.0)*0.913*a), 1.0);\n  mat3 rot = rot(normalize(r0), normalize(r1));\n  g_rot = rot;\n\n  const vec3 ro = vec3(0.0, 1.5, -10.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  const vec3 ww = normalize(la - ro);\n  const vec3 uu = normalize(cross(up, ww ));\n  const vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  float col = render1(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n#if defined(CELL_SIZE)\n  p = floor(p*CELL_SIZE)/CELL_SIZE; \n#endif\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float e = effect(p);\n  vec3 col = tic80[int((16.*fract(e)))];\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}