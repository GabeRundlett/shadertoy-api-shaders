{
    "Shader": {
        "info": {
            "date": "1639406773",
            "description": "Rendering some overlapping hexagons on an isometric grid to produce a height map of extruded blocks.",
            "flags": 0,
            "hasliked": 0,
            "id": "stcXD7",
            "likes": 69,
            "name": "Isometric Grid Height Map",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "heightmap",
                "vector",
                "isometric",
                "block"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1299
        },
        "renderpass": [
            {
                "code": "/*\n\n    Isometric Grid Height Map\n    -------------------------\n    \n    Rendering some overlapping hexagons in an isometric grid fashion \n    to produce a height map of extruded blocks. Isometric grid \n    renderings are certainly not new, but they're fun and simple to \n    code.\n    \n    I had a few versions of this lying around for ages, but wasn't \n    inspired to do anything with them until Bitless posted his really \n    cool \"Cyberspace data warehouse\" example. He put isometric height\n    maps on the faces of isometric cubes, which the isometric design \n    crowd have probably done before, but it was new to me. For anyone \n    who hasn't seen it, the link is below.\n    \n    A lot of people are familiar with the isometric height map concept, \n    but for anyone who isn't, you render cubes (or an extruded version) \n    in back to front order in a diamond pattern, or corresponding \n    patterns to cover the amount of overlap. In this case, I'm rendering \n    seven cells in a hexagon pattern.\n    \n    Just to mix things up a little and break the visual monotony, I\n    rendered columns of differing width and offset them a bit. Other \n    than that, there's not a lot to it.\n    \n    By the way, rendering in this way is fun, novel and fast, but there \n    are way better 3D methods that will achieve the same.  I've attached \n    a link to a much simpler version of this for anyone interested in \n    the process, or code golfing an isometric heightmap, maze, etc. :)\n    \n    \n    \n    Inspired by the following:\n    \n    // Very cool, and unique.\n    Cyberspace data warehouse - bitless\n    https://www.shadertoy.com/view/NlK3Wt\n    \n    // Here's a more sophisticated example. It requires more\n    // work, but is based on a similar concept.\n    Isometric City 2.5D - knarkowicz\n    https://www.shadertoy.com/view/MljXzz\n    \n    // A less interesting, but easier to understand, verion:\n    Isometric Height Map - Shane\n    https://www.shadertoy.com/view/flcSzX\n    \n*/\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Using two hexagons to creat an extruded box of varying height.\n// I hacked in some logic to make it happen, but there might be\n// more efficient ways. Either way, it works, so it'll do.\nfloat dist(vec2 p, float h, float sz){\n\n    //return length(p);\n    \n     // The vertical height component of the hexagon. We're taking\n    // a little off to get rid of artifacts.\n    float szD = sz/.8660254 - .015;\n    \n    // Height factor. More height looks more interesting, but too much\n    // sends the blocks out of the cell range and causes artifacts.\n    const float hFact = .75;\n    \n    // Moving the blocks down a bit to maximize the range. I've hack a \n    // number in, but you could probably calculate something.\n    p.y -= -.1;\n    \n    \n    // I should be rendering three calculated polygons consisting of\n    // the top and two sides, but that requires more effort and GPU\n    // power, so I've merely merged a base hexagon and a hexagon on\n    // top that moves in the Y direction according to the height,\n    // which is good enough for this example.\n    vec2 q = abs(p);\n    float hxB = max(q.y*.8660254 + q.x*.5, q.x);\n    \n    q = abs(p - vec2(0, szD - h)*hFact);\n    float hxH = max(q.y*.8660254 + q.x*.5, q.x);\n\n    // If the block is less that the size of a hexagon, you need the\n    // maximum overlay of the two. If it's above the height of the\n    // base hexagon, fuse the two together... It took me while to \n    // figure that out, but it works.\n    float d = max(hxB, hxH);\n    if(h - szD<0.) d = min(hxB, hxH);\n    return d;\n    \n}\n\n// If you're rendering triangles, hexagons, isometric grids, etc, the number\n// 1.732 (sqrt(3)) will come up all the time.\nconst vec2 s = vec2(1.7320508, 1);\n\n// Hexagon grid.\nvec4 getGrid(vec2 p){\n\n    // Finding the local coordinates and ID of the nearest hexagon center.\n    vec4 ip = floor(vec4(p/s, p/s + .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw - .5);\n   \n}\n\nfloat height(vec2 p){\n\n    //float rnd = hash21(p);\n    //return smoothstep(.5, .95, sin(rnd*6.2831 + iTime)*.5 + .5);\n    float tm = mod(iTime/1.5, 6.2831);\n    float h = dot(sin(p*.73/1.25 - cos(p.yx*.97/1.25 - tm)*2.3), vec2(.25)) + .5;\n    p *= 2.;\n    float h2 = dot(sin(p*.73/1.25 - cos(p.yx*.97/1.25 - tm*2.)*2.3), vec2(.25)) + .5;\n    h = mix(h, h2, .333);\n    return smoothstep(0., 1., h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // Aspect correct coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 16.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = uv*sc + s*iTime/3.;\n    // Including rotation for a side wall perpective.\n    //vec2 p = rot2(-3.14159/2.)*uv*vec2(-1, 1)*sc + s.yx*iTime/4.;\n    \n    \n    // Scene field calculations.\n    \n    // Light direction. Shining down and to the left.\n    vec2 ld = normalize(s);\n    \n  \n   \n    // Rendering in a diamond grouping. Top first, the two below that, and the bottom.\n    //vec2[4] cntr = vec2[4](vec2(0, .5), vec2(-.5, 0), vec2(.5, 0), vec2(0, -.5));\n    \n    \n    // Rendering in a seven cell grouping, and taking rendering order into account:\n    // Top cell first, then the two below, the one below those, two more below\n    // that and the one on the bottom.\n    vec2[7] cntr = vec2[7](vec2(0, .5), vec2(-.5, 0), vec2(.5, 0), vec2(0, -.5),\n                           vec2(-.5, -.5), vec2(.5, -.5), vec2(0, -1));    \n    \n    float obj[7], objSh[7], side[7], side2[7], top[7], hgt[7];\n    vec4[7] p4I;\n\n    \n    // The block width. The maximum is s.y/2. (.8660254) and will produce a packed \n    // grid with no gaps. However, due to overlap, the height needs to be reduced.\n    float sz = .7;\n    vec2 szOffs = sz/s.yx;\n    \n    // Object shadow.\n    float objShad = 1e5;\n    \n    for(int i = min(0, iFrame); i<7; i++){\n   \n        // Obtain the hexagon and ID for this position. I could probably \n        // streamline the process, but this will do.\n        vec4 p4 = getGrid(p + cntr[i]*s);\n        // Random 2D offset.\n        vec2 offs = vec2(hash21(p4.zw + .1), hash21(p4.zw + .2)) - .5;\n        // Random size.\n        sz = .7*(hash21(p4.zw + .3)*.35 + .65);\n        szOffs = sz/s.yx; \n        // Position based height. \n        float h = height(p4.zw*s);\n        vec2 q = p4.xy - cntr[i]*s - offs*vec2(.2, .2); \n        \n        // The extruded column object, which is just two overlayed \n        // hexagons in disguise.\n        obj[i] = dist(q, h, sz) - sz;\n        \n        /*\n        // Failed experiment with different tops.\n        float bx = -1e5;\n        if(hash21(p4.zw + .23)<.5){\n           bx = max(abs(q.x) - sz, \n                    abs(q.y - (sz/.8660254 - .015 - h)*.75 - .15) - sz*.5);\n        }\n        */\n        \n        // Using the column object above and some simple CSG to construt \n        // the top and sides.\n        float sd1 = dist(q - vec2(-1)*szOffs, h, sz) - sz;\n        float sd2 = dist(q - vec2(1, -1)*szOffs, h, sz) - sz;\n        side[i] = max(obj[i], sd1);\n        side2[i] = max(obj[i], sd2);\n        top[i] = max(obj[i], -min(sd1, sd2));\n        \n        // Failed experiment with different tops.\n        //top[i] = max(top[i] - .05, bx);  \n        \n        // The shadow of the column object.\n        objSh[i] = dist(q - ld*.5*sz, h, sz) - sz;\n        \n        // Saving the height, and hexagon cell information.\n        hgt[i] = h;\n        p4I[i] = p4;\n        \n        // The shadow is laid down first on the background, so can be\n        // calculated here.\n        objShad = min(objShad,  objSh[i]);\n \n    }\n     \n  \n\n    \n    // Initiate the scene color to the background.\n    vec3 col = vec3(.3, .25, .2);\n    \n \n    // Rendering the object shadows onto the background. \n    col = mix(col, vec3(.05, .05, .1), (1. - smoothstep(0., sf*2., objShad))*.4);\n     \n   \n    // Loop through all seven object cells and rendering the objects.\n    for(int i = min(0, iFrame); i<7; i++){\n        \n        // Dark glow around the objects for more fake AO.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., obj[i]))*.35);\n        \n        // Unique position-based cell ID.\n        vec2 id = p4I[i].zw;\n        \n        \n        // Coloring -- Mildly inspired by the colors in Shadertoy's in-house\n        // \"Rock Tiles\" texture.\n        float rnd = hash21(id);\n        float fn = dot(sin(id*s/3.5/1.5 - cos(id.yx*s/2.3/1.5)*2.), vec2(.25)) + .5;\n        fn = smoothstep(.1, .9, fn);  \n        vec3 oCol = .6 + .4*cos(6.2831*mix(fn, rnd, .65)/3. + vec3(0, 1, 2)/1.65);  \n        oCol = mix(oCol, oCol.xzy, fn*(hash21(id + .3)*.25 + .25));\n        if(hash21(id + .27)<.33) oCol = oCol*.6;\n        if(hash21(id + .37)<.66) oCol = min(oCol*1.4, 1.);\n        /*\n        // Load in the \"Rock Tiles\" texture for a comparison.\n        vec3 tx = texture(iChannel0, id*s/sc/1.5).xyz; tx *= tx;\n        tx = smoothstep(-.05, .7, tx);\n        vec3 oCol = tx*1.5;\n        */\n       \n        // Using the height for some extra shadowing.\n        float shad = 1. - hgt[i]*.5;\n        \n       \n        // The top of the extruded box.\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i])); // Edge, or stroke.\n        //col = mix(col, oCol*ao*2., 1. - smoothstep(0., sf, top[i] + .04)); \n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i] + .1)); \n        col = mix(col, oCol*shad, 1. - smoothstep(0., sf, top[i] + .04)); // Main.\n        // Render dark holes on random faces to break up the monotony.\n        if(hash21(id + .34)<.5){\n        //if(mod(p4I[i].z + p4I[i].w, 2.)<.5){ // Checkered option.\n            col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i] + .22)); \n            col = mix(col, oCol*shad/3., 1. - smoothstep(0., sf, top[i] + .265)); \n        }         \n\n        \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, side[i])); // Edge, or stroke.\n        //col = mix(col, vec3(.25, .5, .75)*shad, 1. - smoothstep(0., sf, side[i] + .04));\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, side[i] + .1));      \n        col = mix(col, oCol*vec3(.25, .5, .75)*shad, 1. - smoothstep(0., sf, side[i] + .04)); // Main.\n        \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, side2[i])); // Edge, or strke.\n        //col = mix(col, vec3(2, .75, .5)*shad, 1. - smoothstep(0., sf, side2[i] + .04)); // Edge, or stroke.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, side2[i] + .1)); // Edge, or strke.       \n        col = mix(col, oCol*vec3(2, .75, .5)*shad, 1. - smoothstep(0., sf, side2[i] + .04)); // Main.\n    \n   \n    }\n   \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n \n    // Rough gamma correction, and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}