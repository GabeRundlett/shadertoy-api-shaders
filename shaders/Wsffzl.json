{
    "Shader": {
        "info": {
            "date": "1588828862",
            "description": "inspired by iq's experiments with monte carlo PDE solving https://www.shadertoy.com/view/WsXBzl",
            "flags": 32,
            "hasliked": 0,
            "id": "Wsffzl",
            "likes": 28,
            "name": "Random-walk Based Area Lighting",
            "published": 3,
            "tags": [
                "lighting",
                "area",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 1280
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(sqrt(texture(iChannel0, uv).x)) + abs(hash(hash(uv.x,uv.y),iTime))*0.1;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define METAL 0.\n#define SMOOTHNESS 3.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat noise(vec3 p) {\n    p.z -=iTime*0.1;\n    return smoothstep(0.99, 1.0, sin(dot(sin(p*8.), cos(p*6.+2.))*4.));\n}\n\nfloat checker(vec3 p) {\n    return smoothstep(0.0,0.01, sin(p.x)*sin(p.y)*sin(p.z-iTime*2.));\n}\n\nvec3 warp(vec3 p) {\n    p = sqrt(p*p+0.01)-0.4;\n    p.z = asin(sin(p.z*3.)*0.95)/3.;\n    return p;\n}\n\nfloat rings(vec3 p) {\n    p = erot(p,vec3(0,1,0),radians(45.+iTime*9.));\n    p = erot(p,vec3(1,0,0),radians(45.+iTime*5.));\n    return length(vec2(length(p.xy)-0.45,p.z))-0.05;\n}\n\nfloat scene(vec3 p) {\n    p = warp(p);\n    return min(length(p)-0.35, rings(p));\n}\n\nfloat scenecol(vec3 p) {\n    float r = rings(warp(p));\n    if (r > 0.005) return 0.0;\n    return mix(noise(p)*2., checker(p*10.), smoothstep(0.0,.1,sin(iTime+p.z*0.5)));\n}\n\nvec3 normal(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ) );\n}\n\n\nfloat march(vec3 p, float seed, vec3 bias) {\n    vec3 init = p;\n    for (int i = 0; i < 50; i++) {\n        float dist = scene(p);\n        if (dist*dist < 1e-6) break;\n        vec3 rnd = rndvec(seed,i) + rndvec(seed,i+100) + rndvec(seed,i+200);\n        vec3 jump = tan(rnd/3.+bias)*SMOOTHNESS;\n        p+=jump*dist;\n    }\n    return scenecol(p);\n}\n\nvec2 map(vec2 uv) {\n    return (uv*iResolution.y+0.5*iResolution.xy)/iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-4,0,0);\n\n    float yrot = 0.4;\n    float zrot = iTime*0.3;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for(int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n    }\n    \n    float color = 0.;\n    float seed = hash(iTime, hash(uv.x,uv.y));\n    if (hit) {\n        vec3 n = normal(p);\n   \t\tvec3 r = reflect(cam, n);\n    \tvec2 smp = vec2(0);\n        vec3 bias = mix(n,r,METAL)*0.2;\n    \tfor (int i = 0; i < 30 && hit; i++) {\n        \tfloat seed = hash(float(i), seed);\n        \tsmp += vec2(march(p+n*0.01, seed, bias), 1.);\n    \t}\n        color = smp.x/smp.y+scenecol(p)*0.6;\n    }\n    fragColor.x = color;\n    float prev = texture(iChannel0, map(uv)).x;\n    fragColor.x = mix(fragColor.x, prev, .5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 rndvec(float seed, int i) {\n    float h1 = hash(seed, float(i));\n    float h2 = hash(h1, float(i));\n    float h3 = hash(h2, float(i));\n    return vec3(h1,h2,h3);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}