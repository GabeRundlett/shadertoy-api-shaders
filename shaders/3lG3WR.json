{
    "Shader": {
        "info": {
            "date": "1578592688",
            "description": "More or less accurate gear geometry. The shape of the cogs is made using an SDF for an involute.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lG3WR",
            "likes": 15,
            "name": "Gears using involute SDF",
            "published": 3,
            "tags": [
                "gears",
                "involute"
            ],
            "usePreview": 0,
            "username": "Pidhorskyi",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "/* \"Gears using involute SDF\" by Stanislav Pidhorskyi - 2020\n * License Creative Commons Attribution 4.0 International License.\n * Contact: stpidhorskyi@mix.wvu.edu\n */\n\n\nfloat Union(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat SmoothUnion(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Substraction(float a, float b)\n{\n    return max(a,-b);\n}\n\nfloat Intersection(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat SmoothIntersection(float a, float b, float k)\n{\n    return Substraction(Intersection(a, b), SmoothUnion(Substraction(a, b), Substraction(b, a), k));\n}\n\nfloat Circle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat Circle(float rho, float r)\n{\n\treturn rho - r;\n}\n\nfloat Gear(vec2 p, float D, float N, float psi, float alpha, float dir)\n{\n    float R = D / 2.0;\n    /* The Pitch Circle Diameter is the diameter of a circle which by a pure rolling action would transmit \n     * the same motion as the actual gear wheel. It should be noted that in the case of wheels which connect\n     * non-parallel shafts, the pitch circle diameter is different for each cross section of the wheel\n     * normal to the axis of rotation.\n     */\n\n    float rho = length(p);\n    \n    float Pd = N / D; // The Diametral Pitch, p_d is the number of teeth per unit length of diameter\n\n    float P = 3.1416 / Pd; // Circular Pitch\n    /* The Circular Pitch, p is the length of arc round the pitch circle between corresponding points \n     * on adjacent teeth.\n     */\n\n    float a = 1.0 / Pd; // Addendum\n    /* The Addendum is the radial length of a tooth from the pitch circle to the tip of the tooth.\n     */\n\n    float Do = D + 2.0 * a; // Outside Diameter\n    float Ro = Do / 2.0; \n\n    float h = 2.2 / Pd;\n\n    float innerR = Ro - h - 0.4;\n    \n    // Early exit\n    if (innerR - rho > 0.0)\n        return innerR - rho;\n    \n    // Early exit\n    if (Ro - rho < -0.2)\n        return rho - Ro;\n    \n    float Db = D * cos(psi); // Base Diameter \n    float Rb = Db / 2.0; \n\n    float fi = atan(p.y, p.x) * dir + alpha;\n    \n    float alphaStride = P / R;\n    \n    float invAlpha = acos(Rb / R);\n    float invPhi = tan(invAlpha) - invAlpha;\n    \n    float shift = alphaStride / 2.0 - 2.0 * invPhi;\n    \n    float fia = mod(fi + shift / 2.0, alphaStride) - shift / 2.0;\n    float fib = mod(-fi - shift + shift / 2.0, alphaStride) - shift / 2.0;\n    \n    float dista = -1.0e6;\n    float distb = -1.0e6;\n    \n    if (Rb < rho)\n    {\n        float acos_rbRho = acos(Rb/rho);\n        \n        float thetaa = fia + acos_rbRho;\n        float thetab = fib + acos_rbRho;\n\n        float ta = sqrt(rho * rho - Rb * Rb);\n\n        // https://math.stackexchange.com/questions/1266689/distance-from-a-point-to-the-involute-of-a-circle\n        dista = ta - Rb * thetaa;\n        distb = ta - Rb * thetab;\n    }\n    \n    float gearOuter = Circle(rho, Ro);\n    float gearBase = Circle(rho, Rb);\n    float gearLowBase = Circle(rho, Ro - h);\n    float crownBase = Circle(rho, innerR);\n    \n    float cogs = Intersection(dista, distb);\n    \n    float baseWalls = Intersection(fia - (alphaStride - shift), fib - (alphaStride - shift));\n    \n    cogs = Intersection(baseWalls, cogs);\n    cogs = SmoothIntersection(gearOuter, cogs, 0.01);\n    cogs = SmoothUnion(gearLowBase, cogs, Rb - Ro + h);\n    \n    cogs = Substraction(cogs, crownBase);\n    return cogs;\n}\n\nfloat Alpha(float d)\n{\n    d *= iResolution.y / 2.0;\n\treturn clamp(-d + 0.7, 0.0, 1.0);\n}\n\n\nfloat AO(float d, float height)\n{\n    return 1.0 - atan(height, d) / 3.14159;\n}\n\nfloat SDF(vec2 p)\n{\n    float N = pow(2.0, mod(floor(iTime / 15.0), 4.0)) * 4.0 + 9.0; // Number of Teeth\n    float psi = 3.096e-5 * N * N -6.557e-3 * N + 0.551;// Pressure Angle\n\t/* The Pressure Angleor Angle of Obliquity  Psi is the angle \n \t * between the common normal LM and the tangent at the pitch point\n \t */\n    float D = 2.8;\n        \n    float gearA = Gear(p + vec2(1.5, 0.0), D, N, psi, iTime / 4.0, 1.0);\n    float gearB = Gear(p + vec2(1.5 - D, 0.0), D, N, psi, iTime / 4.0, -1.0);\n    float dist = Union(gearA, gearB);\n    return dist;\n}\n\nvec2 normal(vec2 p, float dist)\n{\n\tfloat dx = SDF(p + vec2(0.0, 1.0) / iResolution.yy) - dist;\n\tfloat dy = SDF(p + vec2(1.0, 0.0) / iResolution.yy) - dist;\n    return normalize(vec2(dx, dy));\n}\n\nvec3 Render(vec2 p)\n{\n\t// gradient\n\tvec3 color = vec3(0.55, 0.5, 0.45) * (1.3 - length(p / 2.0 / iResolution.xy * iResolution.yy));\n  \n\tcolor = mix(color, vec3(0.1, 0.1, 0.2), 0.2 * Alpha(0.5 * SDF((p - vec2(1.0, 0.0)) / 2.0)));\n    \n    float dist = SDF(p);\n    \n\tcolor *= AO(dist, 0.2);\n    \n\tcolor = mix(color, vec3(0.1, 0.1, 0.1), Alpha(dist));\n    \n    #ifdef ADD_SPECULAR\n    if (dist < 0.0)\n    {\n    \tvec2 n = normal(p, dist);\n        vec3 nn = normalize(vec3(n, -dist * 200.1));\n        \n        float s = dot(nn, normalize(vec3(1.0, 1.0, 1.0)));\n        \n        s = pow(max(s, 0.0), 20.0);\n        \n    \tcolor += vec3(s) * clamp(-dist * iResolution.y / 4.0, 0.0, 1.0);\n    }\n    #endif\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy  + vec2(0.5)) / iResolution.yy;\n    vec2 p = uv.xy * vec2(2.0) - vec2(1.0);\n\tfragColor = vec4(pow(Render(p), vec3(1.0 / 2.2)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}