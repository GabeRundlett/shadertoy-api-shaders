{
    "Shader": {
        "info": {
            "date": "1521441550",
            "description": "Uses cash() hash to get random integers, hsluv to get really pretty colors from the random numbers, convert-to-linear-space and then 3d lerp to animate. SO PRETTY! if you want to have some fun, tweak the saturation and lightness ranges on line 352 and 353",
            "flags": 0,
            "hasliked": 0,
            "id": "MsGcRm",
            "likes": 13,
            "name": "Colors final",
            "published": 3,
            "tags": [
                "procedural",
                "colors",
                "random",
                "animated",
                "gamma",
                "gammacorrection",
                "integer",
                "rng",
                "hsluv",
                "gammacorrect",
                "bitmath"
            ],
            "usePreview": 0,
            "username": "lahwran",
            "viewed": 805
        },
        "renderpass": [
            {
                "code": "\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n    return (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n    return sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n    vec3 len = y / (sin(theta) - x * cos(theta));\n    if (len.r < 0.0) {len.r=1000.0;}\n    if (len.g < 0.0) {len.g=1000.0;}\n    if (len.b < 0.0) {len.b=1000.0;}\n    return len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub0 = L + 16.0;\n    float sub1 = sub0 * sub0 * sub0 * .000000641;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bounds0x = top1 / bottom;\n    vec3 bounds0y = top2 / bottom;\n\n    vec3 bounds1x =              top1 / (bottom+126452.0);\n    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n    float hrad = radians(H);\n\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bound0x = top1 / bottom;\n    vec3 bound0y = top2 / bottom;\n\n    vec3 bound1x =              top1 / (bottom+126452.0);\n    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    const mat3 m = mat3( \n        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n    \n    return hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n    float X = tuple.x;\n    float Y = tuple.y;\n    float Z = tuple.z;\n\n    float L = hsluv_yToL(Y);\n    \n    float div = 1./dot(tuple,vec3(1,15,3)); \n\n    return vec3(\n        1.,\n        (52. * (X*div) - 2.57179),\n        (117.* (Y*div) - 6.08816)\n    ) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float U = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 2.25 * U * Y / V;\n    float Z = (3./V - 5.)*Y - (X/3.);\n\n    return vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n    float L = tuple.x;\n    float U = tuple.y;\n    float V = tuple.z;\n\n    float C = length(tuple.yz);\n    float H = degrees(atan(V,U));\n    if (H < 0.0) {\n        H = 360.0 + H;\n    }\n    \n    return vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n    return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n    return lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n    return lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n    return lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n    return lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n    return xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n\n\n\n\n\n\n\n\n\n// https://stackoverflow.com/a/37221804/1102705\nint cash(int x, int y, int seed){   \n    int h = seed + x*374761393 + y*668265263; //all constants are prime\n    h = (h^(h >> 13))*1274126177;\n    return h^(h >> 16);\n}\n/*vec4 cash4(int x, int y, int seed) { \n    int intensity = cash(x, y, seed);\n    float i1 = float(intensity&0xff);\n    float i2 = float(intensity>>8 & 0xff);\n    float i3 = float(intensity>>16 & 0xff);\n    float i4 = float(intensity>>24 & 0xff);\n    return vec4(i1,i2,i3,i4)/float(0xff);\n}*/\nvec2 cash2(int x, int y, int seed) {\n    \n    int intensity = cash(x, y, seed);\n    float i1 = float(intensity&0xffff);\n    float i2 = float(intensity>>16 & 0xffff);\n    return vec2(i1,i2)/float(0xffff);\n}\nvec4 cash4(int x, int y, int seed) {\n    vec2 xy = cash2(x, y, seed);\n    vec2 zw = cash2(x+30185, y-18513, seed*4815);\n    return vec4(xy,zw);\n}\nfloat smoothstp(float x) { \n  // Evaluate polynomial\n  return x * x * (3. - 2. * x);\n    //\n}\nvec4 mix_custom(vec4 edge0, vec4 edge1, float x) {\n    return mix(edge0, edge1, smoothstp(x));\n}\nvec2 mix_custom(vec2 edge0, vec2 edge1, float x) {\n    return mix(edge0, edge1, smoothstp(x));\n}\nfloat mix_custom(float edge0, float edge1, float x) {\n    return mix(edge0, edge1, smoothstp(x));\n}\nfloat mix_360(float a, float b, float x) {\n    float forward_dist = b-a;\n    float rev_dist = 360.0+a-b;\n    if (forward_dist > rev_dist) {\n    \treturn mod(mix(360.0+a, b, x), 360.0);\n    }\n    return mix(a, b, x);\n}\nvec4 cash4(int x, int y, float seed) {\n    vec4 a = cash4(x, y, int(floor(seed)));\n    vec4 b = cash4(x, y, int(ceil(seed)));\n    float mix_amt = mix(fract(seed), smoothstp(fract(seed)), 0.5);\n    \n    float hue = mix_360(a.x*360.0, b.x*360.0, mix_amt);\n    vec3 yzw = mix(a.yzw, b.yzw, mix_amt);\n\n    //vec4 hsluv_a = rgbToHsluv(res);\n    //vec4 hsluv_b = rgbToHsluv(res);\n    //vec4 hsluv_res = rgbToHsluv(res);\n    vec3 hsluv_res = vec3(\n        hue,\n        mix(85.0, 100.0, yzw.x), // saturation\n        mix(65.0, 75.0, yzw.y)); // lightness\n        \n    return vec4(hsluv_toLinear(hsluvToRgb(hsluv_res)), yzw.z);\n}\nvec4 cash4(float x, int y, float seed) {\n    vec4 a = cash4(int(floor(x)), y, seed);\n    vec4 b = cash4(int(ceil(x)), y, seed);\n    vec4 res = mix_custom(a, b, fract(x));\n    return res;\n}\nvec4 cash4(float x, float y, float seed) {\n    vec4 a = cash4(x, int(floor(y)), seed);\n    vec4 b = cash4(x, int(ceil(y)), seed);\n    vec4 res = mix_custom(a, b, fract(y));\n    return res;\n}\nvec2 cash2(float x, int y, int seed) {\n    vec2 a = cash2(int(floor(x)), y, seed);\n    vec2 b = cash2(int(ceil(x)), y, seed);\n    vec2 res = mix_custom(a, b, fract(x));\n    return res;\n}\nvec2 cash2(float x, float y, int seed) {\n    vec2 a = cash2(x, int(floor(y)), seed);\n    vec2 b = cash2(x, int(ceil(y)), seed);\n    vec2 res = mix_custom(a, b, fract(y));\n    return res;\n}\n\nvec2 cash2(float x, float y, float seed) {\n    vec2 a = cash2(x, y, int(floor(seed)));\n    vec2 b = cash2(x, y, int(ceil(seed)));\n    vec2 res = mix_custom(a, b, fract(seed));\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/5.0;\n    vec2 pos = fragCoord/500.0;\n    vec2 a = cash2(t/20.0, 34625, 75134) - 0.5;\n    vec4 rand = vec4(cash4(pos.x+(a.x*100.0), pos.y+(a.y*100.0), t));\n    vec4 rgb = vec4(hsluv_fromLinear(rand.xyz), rand.w);\n    fragColor = rgb;\n    \n    /*fragColor = toGamma(hsluvToRgb(rand.x * 360.0,\n                           100.0,\n                           50.0,\n                           1.0));//;\n*/}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}