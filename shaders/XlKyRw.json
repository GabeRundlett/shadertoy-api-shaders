{
    "Shader": {
        "info": {
            "date": "1551858488",
            "description": "Try to render clouds using 3D perlin noise.\n\nreference: \nhttps://mrl.nyu.edu/~perlin/noise/\nhttps://www.shadertoy.com/view/4tlBz8\nhttps://www.shadertoy.com/view/XslGRr\nhttps://www.shadertoy.com/view/MlSSR1\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XlKyRw",
            "likes": 30,
            "name": "Clouds using 3D Perlin noise",
            "published": 3,
            "tags": [
                "raymarch",
                "perlinnoise",
                "clouds"
            ],
            "usePreview": 1,
            "username": "ikuto",
            "viewed": 4388
        },
        "renderpass": [
            {
                "code": "#define MAX_DISTANCE \t\t10.0\n#define NUM_OCTAVES \t\t4\n#define HASHSCALE \t\t\t0.1031\n#define PI\t\t\t\t\t3.1415926\n\nfloat fade(float t) \n{\n    return t*t*t*(t*(6.0*t-15.0)+10.0); \n}\n\nfloat hash13(vec3 pos)\n{\n    vec2 uv = pos.xy + pos.z;\n    return texture(iChannel0, (uv+ 0.5)/256.0).x;\n}\n\nfloat grad3D(float hash, vec3 pos) \n{\n    int h = int(1e4*hash) & 15;\n\tfloat u = h<8 ? pos.x : pos.y,\n \t\t  v = h<4 ? pos.y : h==12||h==14 ? pos.x : pos.z;\n    return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n}\n\nfloat perlinNoise3D(vec3 pos)\n{\n\tvec3 pi = floor(pos); \n    vec3 pf = pos - pi;\n    \n    float u = fade(pf.x);\n    float v = fade(pf.y);\n    float w = fade(pf.z);\n    \n    return mix( mix( mix( grad3D(hash13(pi + vec3(0, 0, 0)), pf - vec3(0, 0, 0)),\n                           grad3D(hash13(pi + vec3(1, 0, 0)), pf - vec3(1, 0, 0)), u ),\n            \t      mix( grad3D(hash13(pi + vec3(0, 1, 0)), pf - vec3(0, 1, 0)), \n                \t \t   grad3D(hash13(pi + vec3(1, 1, 0)), pf - vec3(1, 1, 0)), u ), v ),\n        \t\t mix( mix( grad3D(hash13(pi + vec3(0, 0, 1)), pf - vec3(0, 0, 1)), \n                \t\t   grad3D(hash13(pi + vec3(1, 0, 1)), pf - vec3(1, 0, 1)), u ),\n            \t\t  mix( grad3D(hash13(pi + vec3(0, 1, 1)), pf - vec3(0, 1, 1)), \n                \t\t   grad3D(hash13(pi + vec3(1, 1, 1)), pf - vec3(1, 1, 1)), u ), v ), w );\n}\n\nfloat fbm(vec3 pos, int octaves) \n{\n    float noiseSum = 0.0, frequency = 1.0, amplitude = 1.0;\n    \n    for(int i = 0; i < octaves; ++i) \n    {\n        noiseSum += perlinNoise3D(pos * frequency) * amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n\n    return noiseSum;\n}\n\nmat3 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 getSkyColor(vec3 ray)\n{\n\tvec3 color = vec3(0.0);\n\n\t//sun\n    vec3 sunDir = normalize(vec3(0.0, 0.1, 1.0));\n\tfloat sundot = clamp(dot(ray, sunDir), 0.0, 1.0);\n\tcolor += 0.05 * vec3(0.9, 0.3, 0.9) * pow(sundot, 1.0);\n\tcolor += 0.1 * vec3(1.0, 0.7, 0.7) * pow(sundot, 2.0);\n\tcolor += 0.9 * vec3(1.0) * pow(sundot, 256.0);\n\n\t//sky color\n\tvec3 blueSky = vec3(0.3, 0.55, 0.8);\n\tvec3 redSky = vec3(0.8, 0.8, 0.6);\n\tvec3 skyColor = mix(blueSky, redSky, 1.5 * pow(sundot, 8.0));\n\tcolor += skyColor * (1.0 - 0.8 * ray.y);\n\n\treturn color;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection)\n{\n    vec3 skyColor = getSkyColor(rayDirection);\n    vec3 color = skyColor;\n    \n    for (float dist = MAX_DISTANCE; dist > 0.0; dist -= 0.05)\n    {\n        vec3 position = dist * rayDirection + rayOrigin;\n        position.z += iTime;\n        \n        float noise = 0.7 * fbm(position, NUM_OCTAVES);\n\n        const float heightOffset = 0.2;\n        float cloudSignedDistance = position.y + noise + heightOffset;\n        \n        if (cloudSignedDistance < 0.0) \n        {\n            float cloudDensity = clamp(-cloudSignedDistance, 0.0, 1.0);\n            vec3 cloudColor = vec3(1.0) - cloudDensity * skyColor.zyx;\n        \tcolor = mix(color, cloudColor, cloudDensity * 0.4);\n        }\n\t}\n    \n    //contrast\n\tcolor = clamp(color, 0.0, 1.0);\n\tcolor = color * color * (3.0 - 2.0 * color);\n\n\t//saturation\n\tfloat sat = 0.2;\n\tcolor = color * (1.0 + sat) - sat * dot(color, vec3(0.33));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n   \n    vec2 angle = (iMouse.z > 0.5) ? 4.0*(2.0*iMouse.xy/iResolution.xy-1.0) : vec2(0.0);\n    vec3 rayOrigin = vec3(0.0, 0.5*(sin(iTime)+1.0), 0.0);\n    vec3 rayTarget = vec3(8.0*sin(angle.x), angle.y-1.0, 8.0*cos(angle.x));\n    \n    mat3 viewMat = lookAt(rayOrigin, rayTarget, vec3(0.0, 1.0, 0.0));\n    vec3 rayDirection = normalize(viewMat * vec3(uv, -1.0));\n    \n   \tvec3 color = render(rayOrigin, rayDirection);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}