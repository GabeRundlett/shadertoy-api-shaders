{
    "Shader": {
        "info": {
            "date": "1630680454",
            "description": "sfsg",
            "flags": 48,
            "hasliked": 0,
            "id": "flBGzt",
            "likes": 1,
            "name": "basic pt direct light 33",
            "published": 3,
            "tags": [
                "sdfds"
            ],
            "usePreview": 0,
            "username": "MinimilisticBits",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "/*\nWASD to move\nMouse to pan camera\nC to switch rendering modes\n*/\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz;\n    if(texture(iChannel1, vec2(0.99)).x > 0.5){\n        col/=(c.w+1.);\n    }\n    col = vec3(1.)-exp(-1.2*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEY_A 65.0\n#define KEY_W 87.0\n#define KEY_S 83.0\n#define KEY_D 68.0\n\n#define KEY_C 67.0\n\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc = c * pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n//NOT MY CODE////////////////////\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).xyz;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //vec3 d = texture(iChannel1, vec2(40.,0.)/iResolution.xy).xyz;\n    //vec3 p = vec3(0.);\n    //vec3 d;\n    //d = normalize(vec3(uv.x, 1., uv.y));\n    vec3 d = vec3(0.,-1.,0.);\n    vec3 side = vec3(1.,0.,0.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, -mouse.y*130.);\n    d.xy = rot(d.xy, mouse.x*180.);\n    side.xy = rot(side.xy, mouse.x*180.);\n    //vec3 prevcol = col;\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n    if(fragCoord.x < 0.05*iResolution.x && prev_state.x < 0.5){\n        if(isPressed(KEY_W)){\n            col-=d*0.1;\n        }\n        if(isPressed(KEY_S)){\n            col+=d*0.1;\n        }\n        if(isPressed(KEY_A)){\n            col-=side*0.1;\n        }\n        if(isPressed(KEY_D)){\n            col+=side*0.1;\n        }\n    }\n    \n    if(fragCoord.x > iResolution.x*0.5 && fragCoord.x < iResolution.x*0.6 && prev_state.x < 0.5){\n        col = vec3(-mouse.y*90., mouse.x*180., 0.);\n    }\n    \n    if(fragCoord.x > 0.95*iResolution.x){\n        if(isPressed(KEY_C)){\n            col = (col.x > 0.5)?vec3(0.):vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    float l = length(a);\n    a/=l;\n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n    return vec2(cos(ang),sin(ang))*l;\n}\nfloat escape = 0.;\nfloat escape2 = 0.;\n\nfloat box(vec3 p, vec3 s){\n\n    vec3 a = abs(p)-s;\n\n    return max(max(a.x,a.y),a.z);\n}\n\n//NOT MY CODE///////////////\n//https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\nuint wang_hash(inout uint seed)\n{\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n//https://jbaker.graphics/writings/DEC.html\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape2 = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape2 += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\n\n \t\nfloat de332(vec3 p0){\n//p0 = floor(p0*30.)/30.;\n\tvec4 p = vec4(p0, 1.);\n\tp.xyz=abs(p.xyz);\n\tif(p.x < p.z)p.xz = p.zx;\n\tif(p.z < p.y)p.zy = p.yz;\n\t//if(p.y < p.x)p.yx = p.xy;\n\tfor(int i = 0; i < 8; i++){\n\t\tp.xyz = abs(p.xyz);\n\t\tuint seed = uint(p.x+p.y+p.z);\n\t\tp*=(2.3/clamp(dot(p.xyz,p.xyz),0.,1.));\n\t\tp.xyz-=vec3(1.6,.9,2.2);\n\t}\n\tfloat m = 1.0;\n\tp.xyz-=clamp(p.xyz,-m,m);\n    return length(p.xyz)/p.w;\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fractal_de217(vec3 p){\np=abs(p);\n  float d, a;\n  d=a=1.;\n  escape = 0.;\n  for(int j=0;j++<19;){\n    p.xz=abs(p.xz)*rotate2D(3.14159/4.),\n    d=min(d,max(length(p.zx)-.3,p.y-.4)/a),\n    p.yx*=rotate2D(.9),\n    p.y-=3.,\n    p*=1.2,\n    a*=1.2;\nescape += exp(-0.2*dot(p,p));\n    }\n\n  return d;\n}\n\n///////////////////////////\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5 + 0.5*cos(2.*3.14159*t*a + b);\n}\nvec3 lig = normalize(vec3(0.4,1.,0.5));\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob, inout bool ref){\n    c = vec3(0.3,0.7,0.8);\n    a2 = 0.1;\n    prob = 0.9;\n    l = 0.;\n    ref = false;\n    float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n    float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n    float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n    float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n    float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\nvec3 pos = vec3(-1.1,5.3,1.4)-p;\npos.yz = rot(pos.yz, 90.);\n                float aa = 0.;    //float aaa = DE45((vec3(78.0,0.2,-0.0)-p)/10.)*10.;\n  uint seed = uint(pos.x+pos.y+pos.z);\n  aa = max(max(box(pos, vec3(1.7)), -(box(mod(pos, 1.)-0.5,vec3(.3,.3,.3)))), \n  -(fractal_de217((pos/0.3))*0.3));\n  \n    float b2 = box(vec3(11., -20., 3.)-p, vec3(9.7,20.,25.));\n   // float bb2 = box(vec3(-8., -20., 16.)-p, vec3(20.7,20.,5.));\n\n    //float aa3 = fractal_de89((vec3(0.0,-19.2,2.0)-p)/10.)*10.;\n\n    float final = min(min(min(min(min(min(b2, a),b),c1),c2),c3),\n    max(aa, box(vec3(0.,2.,0.)-p, vec3(9.))));\n   \n    float plane = p.z - (9.+((sin(p.x + cos(p.y))+cos(p.y+sin(p.x)))*0.03+\n\n    (sin(p.x*5.+cos(p.y)) + cos(p.z*5.+sin(p.x*2.)))*0.005  ) );\n   \n    if(final == b2)l = 0.2;\n    if(final == a)l=0.2;\n    if(final == c1)c = vec3(0.2);\n    if(final == c2)c = vec3(0.2);\n    if(final == a)c = vec3(0.2);\n    if(final == b)c = vec3(0.2);\n    if(final == c3)c = vec3(0.2);\n\n\n    vec3 color = vec3(0.2,0.9,0.9);\n    if(final == aa){a2 = 0.1;prob=0.9;c=pal(escape2, vec3(0.9), vec3(0.9,0.2,0.2));\n    l=escape*0.0;\n    ref = true;\n    }\n  \n\n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float t = pow(r2, 2./(1.+a));\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.01;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k, inout bool ref){\n    for(int i = 0; i < 180; i++){\n        dd = dis(p,l,c,a,prob, ref);\n        if(dd<0.001)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    bool ref;\n    \n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob,ref) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob,ref),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob,ref) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob,ref),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob,ref) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob,ref)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    \n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n   \n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\n\nvec3 F(float costheta, float y, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E){\nreturn (1.+A*exp(B/costheta))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\nvec3 skyp2(vec3 d, vec3 lig){//my code to begin with\nvec3 zenith = vec3(0.,0.,1.);\nfloat costheta = max(dot(d,zenith),0.);\nfloat costhetas = max(dot(lig,zenith),0.);\nfloat cosy = max(dot(lig,d),0.);\nfloat y = acos(cosy);\n\nfloat T = 3.;\nfloat X = (4./9. - T/120.)*(3.14159-2.*acos(costhetas));\nfloat Yz = (4.0453*T - 4.9710)*tan(X)-0.2155*T+2.4192;\n\nvec3 AYxy = vec3(0.1787*T-1.4630, -0.0193*T-0.2592,-0.0167*T-0.2608);\nvec3 BYxy = vec3(-0.3554*T+0.4275,-0.0665*T+0.0008,-0.0950*T+0.0092);\nvec3 CYxy = vec3(-0.0227*T+5.3251,-0.0004*T+0.2125,-0.0079*T+0.2102);\nvec3 DYxy = vec3(0.1206*T-2.5771,-0.0641*T-0.8989,-0.0441*T-1.6537);\nvec3 EYxy = vec3(-0.0670*T+0.3703,-0.0033*T+0.0452,-0.0109*T+0.0529);\n\nfloat ts = acos(costhetas);\nfloat ts2 = ts*ts;\nfloat ts3 = ts*ts*ts;\nvec3 xz0 = vec3(0.00166*ts3 -0.00375*ts2 + 0.00209*ts,\n-0.02903*ts3 + 0.06377*ts2 - 0.03202*ts + 0.00394,\n0.11693*ts3 - 0.21196*ts2 + 0.06052*ts + 0.25886\n);\n\nvec3 yz0 = vec3(0.00275*ts3 -0.00610*ts2 + 0.00317*ts,\n-0.04214*ts3 + 0.08970*ts2 - 0.04153*ts + 0.00516,\n0.15346*ts3 - 0.26756*ts2 + 0.06670*ts + 0.26688\n);\n\nfloat xz = xz0.x*T*T + xz0.y*T + xz0.z;\nfloat yz = yz0.x*T*T + yz0.y*T + yz0.z;\n\nvec3 Yxyz = vec3(Yz,xz,yz);\n//test\n//vec3 test1 = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Ftop = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Fbottom = F(1., ts, AYxy, BYxy, CYxy, DYxy, EYxy);\n\nvec3 finalYxy = Yxyz*(Ftop/Fbottom);\n\nvec3 XYZ = vec3(\n(finalYxy.y*finalYxy.x)/finalYxy.z,\nfinalYxy.x,\n((1.-finalYxy.y - finalYxy.z)*finalYxy.x)/finalYxy.z\n);\n\nvec3 rgb = vec3(\n3.2404542*XYZ.x -1.5371385*XYZ.y -0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\n\n//return test1*0.1;\nreturn rgb*0.034 + exp(-y*20.)*vec3(0.9,0.6,0.2);\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 sampleSun(vec3 n, inout uint r, float theta){\n        float diff = 1.-cos(theta);\n        float z = cos(theta) + rndf(r)*diff;\n        float angle = rndf(r)*3.14159*2.;\n        float radius = sqrt(1. - z*z);\n        float x = cos(angle) * radius;\n        float y = sin(angle) * radius;\n        \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 53;\n    float ll = 0.;\n    float k = 0.;\n    bool ref = false;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k,ref)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.03;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\nrough = rough*rough;\n            d = angledircos(n,r);\n        if(i == 0)ll=length(p-prevp);\n            float number = rndf(r);\n           \n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*l*c;\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n           \n           ////////////////////////////\n           float theta = 0.1;\n           vec3 lightdir = sampleSun(lig, r, theta);\n           /////////////////////////////\n\n\n            ldir = normalize(lightdir);\n\n\n            vec3 brdf = c/3.14159 ;\n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n   \n   \n               \n        \n            if(number < probability){\n                brdf = specular;\n                hemipdf = beckmann_pdf2(reflect(wi,n),d,rough);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = specular2;\n                hemipdf2 = beckmann_pdf2(reflect(ldir,n),wi,rough);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            }\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            \n            \n         /*   vec3 L = vec3(0.9,0.7,0.5)*10.;\n            \n           vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            //vec3 lightdir = anglephong(100000., lig, r);\n            //theta - 0, pi/2\n            float height = cos(theta);\n            float ar = 2.*3.14159*(1.0-height);\n            bool ref2 = false;\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2,ref2) && dot(ldir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                float brpdf = max(dot(ldir, n),0.)/3.14159;\n                brpdf = max(brpdf, 0.00000001);\n                if(number < probability){\n                    brpdf = hemipdf2;\n                }\n                float pdf = 1./ar;\n                float weight = powerh(1., pdf, 1., brpdf);\n                col += tt*brdf2*L*weight*dot(ldir,n)/pdf;\n                //break;\n            }\n            \n           //MIS\n           float an = acos(dot(d,lig));\n           if((an) <= theta){\n               curr = p;\n               if(!trac(curr, d,dd,l2,c,a2,prob2,r,k2,ref2)){\n                   float heightbrdf = cos(an);\n                   float arbrdf = 2.*3.14159*(1.-heightbrdf);\n                   float pdf = 1./arbrdf;\n                   float weight = powerh(1.,hemipdf,1.,pdf);\n                   col += tt*brdf*weight*L*max(dot(d,n),0.)/hemipdf;\n                   break;\n               }\n           }\n            */\n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                   \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                   \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/      \n            \n            if(ref){\n            if(i==0){\n                        tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n\n            }\n            float sch = 0.65 + (1.0-0.65)*pow(1.0-max(dot(n, wi),0.),5.);\n                if(rndf(r) < sch){\n                float prob2 = 0.;\n                float dds = dis(p,l,c,a,prob2,ref);\n                if(dds > 0.01){\n                p-=n*0.04;\n                d = refract(wi, n, 0.65);\n                }\n                for(int k = 0; k < 340; k++){\n                    float dds = dis(p,l,c,a,prob2,ref);\n                    if(dds>0.01){\n                    break;\n                    }\n                    \n                    p+=d*.01;\n                }\n                vec3 n2 = norm(p,dd);\n                p+=n2*0.02;\n                \n                d = refract(wi, -n2, 0.65);\n                }else{\n                //d = reflect(wi, n);\n                            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n                }\n                tt *= c;\n            }else{\n            \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            }\n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.1;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\nif(i==0)ll=length(p-prevp);\n          /* if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.1;\n            }*/\n            if(i==0){\n                col += tt*skyp2(d, lig)*0.3;\n            }else{\n                col += tt*skyp2(d, lig)*0.7;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    //col += 1./(1.+exp(-2.*(clamp(ll,0.,20.)*0.1-2.)))*vec3(0.2,0.2,0.2);\n    return col*2.*3.14159;\n}\n\n\nvec3 get_color(vec3 p, vec3 d, vec2 frag){\n    vec3 prevp = p;\n    vec3 p2 = p;\n    vec3 d2 = d;\n    vec3 prevp2 = p2;\n    bool hit_obj = false;\n    vec3 ligc = vec3(0.9,0.8,0.4);\n    vec3 col = vec3(0.);\n    float k = 0.;\n    vec3 glow = vec3(0.);\n    float l = 0.;\n    vec3 c = vec3(0.);\n    float a = 0.;\n    float prob = 0.;\n    bool ref = false;\n    for(int i = 0; i < 80; i++){\n    //dis(p,l,c,a,prob);\n        float dist2 = abs(dis(p2,l,c,a,prob,ref))+0.001;\n        p2 += d2*dist2;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*c;\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }\n    col = glow*12.;\n   return col;\n}\n\n//NOT MY CODE//////////////////////\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NOT MY CODE//////////////////////////////\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n\n    int tiles = 8;\n    int samples = 30;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(prev_state.x > 0.5){\n        if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n        if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n    }\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n   // uv *= 0.5;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n  \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = texture(iChannel1, vec2(0.)).xyz;\n    \n    vec3 rotations = texture(iChannel1, vec2(0.55)).xyz;\n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    float rota = 0.;\n    float rotb = 0.;\n    rota = rotations.x;\n    rotb = rotations.y;\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    vec3 col = vec3(0.);\n    if(prev_state.x > 0.5){\n        \n        float focaldist = 1.3;\n        float radius = 0.03;\n\n        vec3 camdirection = vec3(0.,1.,0.);\n        camdirection.yz = rot(camdirection.yz, rota);\n        camdirection.xy = rot(camdirection.xy, rotb);\n        vec3 sidex = vec3(1.,0.,0.);\n        vec3 sidey = vec3(0.,0.,1.);\n       // sidex.yz = rot2(sidex.yz,rota);\n        //sidex.xz = rot(sidex.xz, -20.);\n       // sidex.yz = rot(sidex.yz,rota);\n        sidex.xy = rot(sidex.xy,rotb);\n    //    sidex.yz = rot(sidex.yz,rota);\n\n        //sidey.xz = rot(sidey.xz,-20.);\n        sidey.yz = rot(sidey.yz,rota);\n        sidey.xy = rot(sidey.xy,rotb);\n    \n        float ang = rndf(r)*2.0*3.14159;\n        float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n        float scale = sqrt(rndf(r))*radius;\n       //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n       //vec2 aa = normalize(vec2(0.,1.));\n        vec2 offset = vec2(cos(ang), sin(ang))*scale;\n        //if(offset.x > offset.y)offset.xy=offset.yx;\n        //offset.x+=-1.;\n    \n       //offset*=radius;\n       //NOT MY CODE////////////////////////\n        vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n        /////////////////////////////////////\n       // vec3 dd = vec3(uv.x,1.,uv.y);\n       // dd.yz = rot(dd.yz, rota);\n       // dd.xy = rot(dd.xy, rotb);\n       //vec3 focuspoint = p+(dd*focaldist);\n        //p.xz += offset;\n\n        p = p + sidex*offset.x;\n        p = p + sidey*offset.y;\n\n        d = normalize(focuspoint - p);\n    \n    \n        col = renderpixel(p,d, r, fragCoord);\n\n        col = tonemap_uchimura2(col);\n        //col = pow(col, vec3(1.6))*1.8;\n        col = pow(col, vec3(1./2.2));\n\n        if(jk != 0){\n            col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        }\n    }else{\n        col = get_color(p,d,fragCoord.xy);\n    }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}