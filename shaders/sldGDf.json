{
    "Shader": {
        "info": {
            "date": "1638424842",
            "description": "simple art scene\nor just playing with colors\n\nCineshader support [url]https://cineshader.com/view/sldGDf[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "sldGDf",
            "likes": 102,
            "name": "in space",
            "published": 3,
            "tags": [
                "space",
                "art",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 6566
        },
        "renderpass": [
            {
                "code": "\n\n// Created by Danil (2021+) https://cohost.org/arugl\n\n// License - CC0 or use as you wish\n\n\n\n// using MIT License code\n// using https://www.shadertoy.com/view/wtXfRH\n// using https://www.shadertoy.com/view/ll2GD3\n\n\n// Note - this shader have very weird bug in AMD on Linux\n// when this shader used as texture in own buffer\n// only option to fix - is remove fwidth from this code, search\n// bug https://www.shadertoy.com/view/MfsBz8\n// https://gitlab.freedesktop.org/mesa/mesa/-/issues/11683\n\n\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// divx is number of lines on background\n//#define divx floor(iResolution.y/15.)\n\nconst float divx = 35.;\n#define polar_line_scale (2./divx)\n\nconst float zoom_nise = 9.;\n\n\n// Common code moved for Cineshader support\n//-------------Common code\n\n// using MIT License code\n// using https://www.shadertoy.com/view/wtXfRH\n// using https://www.shadertoy.com/view/ll2GD3\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return -1.+2.*fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 p )\n{\n    p*=0.25;\n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += s*noise(p);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p;\n    }\n    return 0.5+0.5*f;\n}\n\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x)/3.1415926, length(v));\n}\n\nvec3 fcos( vec3 x )\n{\n    // use this\n    //return cos(x); // fix if needed, and remove lines after\n    \n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14*2.0,0.0,w);\n}\n\n// does not fix amd-bug\n//#define AMD_fix\n// https://gitlab.freedesktop.org/mesa/mesa/-/issues/11683\n#ifdef AMD_fix\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    mat4 m1 = mat4(vec4(vec3(0.0,0.8,1.1),1.0),vec4(vec3(0.3,0.4,0.1),3.1),\n                   vec4(vec3(0.1,0.7,1.1),5.1),vec4(vec3(0.2,0.6,0.7),17.1));\n    mat4 m2 = mat4(vec4(vec3(0.1,0.6,0.7),31.1),vec4(vec3(0.0,0.5,0.8),65.1),\n                   vec4(vec3(0.1,0.4,0.7),115.1),vec4(vec3(1.1,1.4,2.7),265.1));\n    \n    for(int a=0;a<8;a++){\n        vec4 td = a<4?m1[a%4]:m2[a%4];\n        col += max(0.10,0.12-0.01*float(a))*fcos(6.28318*t*td.a+td.rgb);\n    }\n    return col;\n}\n\n#else\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n#endif\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//----------end of Common\n\nvec3 get_noise(vec2 p,float timer){\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 shiftx= res*0.5*1.25+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 shiftx2= res*0.5*2.+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 tp = p + shiftx;\n    float atx = (atan(tp.x+0.0001*(1.-abs(sign(tp.x))),tp.y)/3.141592653)*.5+fract(timer*0.025);\n    vec2 puv = ToPolar(tp);\n    puv.y+=atx;\n    puv.x*=0.5;\n    vec2 tuv = puv*divx;\n    float idx = mod(floor(tuv.y),divx)+200.;\n    puv.y=fract(puv.y);\n    puv.x=abs(fract(puv.x/divx)-0.5)*divx; // mirror seamless noise\n    puv.x+=-.5*timer*(0.075-0.0025*max((min(idx,16.)+2.*sin(idx/5.)),0.));\n    return vec3(SS(0.43,0.73,fbm(((p*0.5+shiftx2)*MD(-timer*0.013951*10./zoom_nise))*zoom_nise*2.+vec2(4.+2.*idx))),SS(0.543,0.73,fbm(((p*0.5+shiftx2)*MD(timer*0.02751*10./zoom_nise))*zoom_nise*1.4+vec2(4.+2.*idx))),fbm(vec2(4.+2.*idx)*puv*zoom_nise/100.));\n}\n\nvec4 get_lines_color(vec2 p, vec3 n, float timer){\n    vec2 res = iResolution.xy/iResolution.y;\n    \n    vec3 col= vec3(0.);\n    float a = 1.;\n    \n    vec2 shiftx= res*0.5*1.25+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 tp = p + shiftx;\n    float atx = (atan(tp.x+0.0001*(1.-abs(sign(tp.x))),tp.y)/3.141592653)*(0.5)+fract(timer*0.025);\n    vec2 puv = ToPolar(tp);\n    puv.y+=atx;\n    puv.x*=0.5;\n    vec2 tuv = puv*divx;\n    float idx = mod(floor(tuv.y),divx)+1.;\n    \n    \n    // thin lines\n    float d = length(tp);\n    d+=atx;\n    float v = sin(3.141592653*2.*divx*0.5*d+0.5*3.141592653);\n    float fv =fwidth(v);\n    fv+=0.0001*(1.-abs(sign(fv)));\n    d = 1.-SS(-1.,1., .3*abs(v)/fv);\n    \n    float d2 = 1.-SS(0., 0.473, abs(fract(tuv.y)-0.5));\n    tuv.x+=3.5*timer*(0.01+divx/200.)-0.435*idx;\n    \n    // lines\n    tuv.x=abs(fract(tuv.x/divx)-0.5)*divx;\n    float ld = SS(0.1,.9,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/3.)))*(1.-SS(0.98,1.,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/3.))));\n    \n    tuv.x+=1.*timer*(0.01+divx/200.)-01.135*idx;\n    ld *= 1.-SS(0.1,.9,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/6.5)))*(1.-SS(0.98,1.,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/6.5))));\n    \n    float ld2 = .1/(max(abs(fract(tuv.y)-0.5)*1.46,0.0001)+ld);\n    ld = .1/((max(abs(fract(tuv.y)-0.5)*1.46,0.0001)+ld)*(2.5-(n.y+1.*max(n.y,n.z))));\n\n    \n    ld=min(ld,13.);\n    ld*=SS(0.0,0.15,0.5-abs(fract(tuv.y)-0.5));\n    \n    // noise\n    d*=n.z*n.z*2.;\n    float d3=(d*n.x*n.y+d*n.y*n.y+(d2*ld2+d2*ld*n.z*n.z));\n    d=(d*n.x*n.y+d*n.y*n.y+(d2*ld+d2*ld*n.z*n.z));\n    \n    a=clamp(d,0.,1.);\n    \n    \n    puv.y=mix(fract(puv.y),fract(puv.y+0.5),SS(0.,0.1,abs(fract(puv.y)-0.5)));\n    col = getColor( .54*length(puv.y) );\n    \n    col = 3.5*a*col*col+2.*(mix(col.bgr,col.grb,0.5+0.5*sin(timer*0.1))-col*0.5)*col;\n    \n    d3=min(d3,4.);\n    d3*=(d3*n.y-(n.y*n.x*n.z));\n    d3*=n.y/max(n.z+n.x,0.001);\n    d3=max(d3,0.);\n    vec3 col2 = .5*d3*vec3(0.3,0.7,0.98);\n    col2=clamp(col2,0.,2.);\n    \n    col=col2*0.5*(0.5-0.5*cos((timer*0.48*2.)))+mix(col,col2,0.45+0.45*cos((timer*0.48*2.)));\n    \n    col=clamp(col,0.,1.);\n    \n    //col=vec3(ld);\n    \n    return vec4(col,a);\n}\n\nvec4 planet(vec3 ro, vec3 rd, float timer, out float cineshader_alpha)\n{   \n    vec3 lgt = vec3(-.523, .41, -.747);\n    float sd= clamp(dot(lgt, rd)*0.5+0.5,0.,1.);\n    float far = 400.;\n    float dtp = 13.-(ro + rd*(far)).y*3.5;\n    float hori = (linearstep(-1900., 0.0, dtp) - linearstep(11., 700., dtp))*1.;\n    hori *= pow(abs(sd),.04);\n    hori=abs(hori);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(0.3, 0.7,  1.0)*3.;\n    col += pow(hori, 25.)* vec3(0.5, 0.5,  1.0)*.5;\n    col += pow(hori, 7.)* pal( timer*0.48*0.1, vec3(0.8,0.5,0.04),vec3(0.3,0.04,0.82),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )*1.;\n    col=clamp(col,0.,1.);\n    \n    float t = mod(timer,15.);\n    float t2 = mod(timer+7.5,15.);\n    float td = .071*dtp/far+5.1;\n    float td2 = .1051*dtp/far+t*.00715+.025;\n    float td3 = .1051*dtp/far+t2*.00715+.025;\n    vec3 c1=getColor(td);\n    vec3 c2=getColor(td2);\n    vec3 c3=getColor(td3);\n    c2=mix(c2,c3.bbr,abs(t-7.5)/7.5);\n\n    c2=clamp(c2,0.0001,1.);\n    \n    col+=sd*hori*clamp((c1/(2.*c2)),0.0,3.)*SS(0.,50.,dtp);\n    col=clamp(col,0.,1.);\n    \n    float a=1.;\n    a=(0.15+.95*(1.-sd))*hori*(1.-SS(.0,25.,dtp));\n    a=clamp(a,0.,1.);\n    \n    hori = mix(linearstep(-1900., 0.0, dtp), 1. - linearstep(11., 700., dtp), sd);\n    cineshader_alpha=1.-pow(hori,3.5);\n\n    return vec4(col,a);\n}\n\nvec3 cam(vec2 uv, float timer)\n{\n    //vec2 res = (ires.xy / ires.y);\n    //vec2 im = (mouse.xy) / ires.y - res/2.0;\n    timer*=0.48;\n    vec2 im = vec2(cos(mod(timer,3.1415926)),-0.02+0.06*cos(timer*0.17));\n    im*=3.14159263;\n    im.y = -im.y;\n    \n    float fov = 90.;\n    float aspect = 1.;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.14159263 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    rd = (roty(-im.x) * rotx(im.y) * rotz(0.32*sin(timer*0.07))) * rd;\n    return rd;\n}\n\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    float timer = .65*iTime+220.;\n    //timer=18.5*iMouse.x/iResolution.x;\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.y-0.5*res;\n    uv*=1.;\n    vec3 noisev = get_noise(uv, timer);\n\n    vec4 lcol = get_lines_color(uv, noisev, timer);\n\n    //fragColor = vec4(lcol.rgba);\n\n    vec3 ro = vec3(1.,40.,1.);\n    vec3 rd = cam(uv, timer);\n    float cineshader_alpha;\n    vec4 planetc = planet(ro,rd,timer,cineshader_alpha);\n\n    vec3 col = lcol.rgb*planetc.a*0.75+0.5*lcol.rgb*min(12.*planetc.a,1.)+planetc.rgb;\n    col=clamp(col,0.,1.);\n    \n    fragColor = vec4(col*0.85+0.15*col*col,1.);\n    \n    // extra color correction\n    fragColor.rgb = fragColor.rgb*0.15+fragColor.rgb*fragColor.rgb*0.65+(fragColor.rgb*0.7+0.3)*ACESFitted(fragColor.rgb);\n    \n    float tfc = fragCoord.x/iResolution.x-0.5;\n    cineshader_alpha*=((1.-(tfc*tfc*4.))*0.15+0.85);\n    fragColor.a = cineshader_alpha;\n    //fragColor=vec4(cineshader_alpha);\n    \n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}