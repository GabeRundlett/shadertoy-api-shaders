{
    "Shader": {
        "info": {
            "date": "1680513596",
            "description": "asdasd",
            "flags": 0,
            "hasliked": 0,
            "id": "DstXDX",
            "likes": 0,
            "name": "ECB Block Test",
            "published": 3,
            "tags": [
                "asdadsd"
            ],
            "usePreview": 0,
            "username": "MacLin",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "// #define DEMO_FILTER_WEIGHT_USING_FUNCTION\n// #define DEMO_FILTER_WEIGHT_USING_CONSTANT\n// #define DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n// #define HIGH_DIMENSION_DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n#define ECBDEMO\n\n#ifdef DEMO_FILTER_WEIGHT_USING_FUNCTION\nconst float u_sigma = 1.0;\n\n///////////////////////////////////////////////////////////////////////////////////\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\nstruct Input\n{\n    float m[9];\n};\n\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.m[0] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.m[1] = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.m[2] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    \n    i.m[3] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    i.m[4] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.m[5] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n\n    i.m[6] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.m[7] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    i.m[8] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Filter1x1x3x3(out float ret, Input i)\n{\n    ret  = i.m[0] * Gaussian(-1.0f, -1.0f, u_sigma);\n    ret += i.m[1] * Gaussian( 0.0f, -1.0f, u_sigma);\n    ret += i.m[2] * Gaussian( 1.0f, -1.0f, u_sigma);\n\n    ret += i.m[3] * Gaussian(-1.0f,  0.0f, u_sigma);\n    ret += i.m[4] * Gaussian( 0.0f,  0.0f, u_sigma);\n    ret += i.m[5] * Gaussian( 1.0f,  0.0f, u_sigma);\n\n    ret += i.m[6] * Gaussian(-1.0f,  1.0f, u_sigma);\n    ret += i.m[7] * Gaussian( 0.0f,  1.0f, u_sigma);\n    ret += i.m[8] * Gaussian( 1.0f,  1.0f, u_sigma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // -------------------------------------------\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n\n    // -------------------------------------------\n    // do filtering\n    float y = 0.0;  \n    Filter1x1x3x3(y, i);\n    \n    // -------------------------------------------\n    // output\n    fragColor = vec4(y, y, y, 0.6);\n}\n#endif\n\n\n#ifdef DEMO_FILTER_WEIGHT_USING_CONSTANT\n///////////////////////////////////////////////////////////////////////////////////\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\nstruct Input\n{\n    float m[9];\n};\n\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.m[0] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.m[1] = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.m[2] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    \n    i.m[3] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    i.m[4] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.m[5] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n\n    i.m[6] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.m[7] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    i.m[8] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\n// -------------------------------------------\n// (1.0 / (2.0 * pi *sigma^2)) * exp( -(x^2+y^2) /(2*sigma^2) )\n// sigma = 1.0\n// 0.0585 0.0965 0.0585\n// 0.0965 0.1591 0.0965\n// 0.0585 0.0965 0.0585\n\n// sigma = 0.6\n// 0.0274 0.1102 0.0274\n// 0.1102 0.4420 0.1102         \n// 0.0274 0.1102 0.0274\n\n// 0.0274 0.1102 0.0274\n// 0.1102 0.4420 0.1102         \n// 0.0274 0.1102 0.0274\nvoid Filter1x1x3x3(out float ret, Input i)\n{\n    ret  = i.m[0] * 0.0274;\n    ret += i.m[1] * 0.1102;\n    ret += i.m[2] * 0.0274;\n\n    ret += i.m[3] * 0.1102;\n    ret += i.m[4] * 0.4420;\n    ret += i.m[5] * 0.1102;\n\n    ret += i.m[6] * 0.0274;\n    ret += i.m[7] * 0.1102;\n    ret += i.m[8] * 0.0274;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // -------------------------------------------\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n\n    // -------------------------------------------\n    // do filtering\n    float y = 0.0;\n    Filter1x1x3x3(y, i);\n    \n    // -------------------------------------------\n    // output\n    fragColor = vec4(y, y, y, 1.0);\n}\n#endif\n\n\n#ifdef DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n///////////////////////////////////////////////////////////////////////////////////\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\nstruct Pixel3x3\n{\n    vec4 m0123;\n    vec4 m4567;\n    float m8;\n};\n\nstruct Input\n{\n    Pixel3x3 pixels;\n};\n\n\n// -------------------------------------------\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.pixels.m0123.r = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.g = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.pixels.m0123.b = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.a = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    \n    i.pixels.m4567.r = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.pixels.m4567.g = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n    i.pixels.m4567.b = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.pixels.m4567.a = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    \n    i.pixels.m8 = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Filter1x1x3x3(out float ret, Input i)\n{\n    ret =  dot(i.pixels.m0123, vec4(0.0274, 0.1102, 0.0274, 0.1102));\n    ret += dot(i.pixels.m4567, vec4(0.4420, 0.1102, 0.0274, 0.1102));\n    ret += i.pixels.m8 * 0.0274;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // -------------------------------------------\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n\n    // -------------------------------------------\n    // do filtering\n    float y = 0.0;\n    Filter1x1x3x3(y, i);\n    \n    // -------------------------------------------\n    // output    \n    fragColor = vec4(y, y, y, 1.0);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////////\n#ifdef HIGH_DIMENSION_DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n// -------------------------------------------\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\n//-------------------------------------------\nstruct Pixel3x3\n{\n    vec4 m0123;\n    vec4 m4567;\n    float m8;\n};\n\nstruct Pixel3x3x8\n{\n    Pixel3x3 m[8];\n};\n\nstruct Input\n{\n    Pixel3x3 pixels;\n};\n\nstruct Middle\n{\n    Pixel3x3x8 pixels;\n};\n\nstruct Output\n{\n    float pixels[8];\n};\n\n//-------------------------------------------\nPixel3x3x8 filters[8];\n\nvoid initPixel3x3SobelDx(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +0.0; f.m0123.b = -1.0; \n    f.m0123.a = +2.0; f.m4567.r = +0.0; f.m4567.g = -2.0;\n    f.m4567.b = +1.0; f.m4567.a = +0.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3SobelDy(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +2.0; f.m0123.b = +1.0;\n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = -1.0; f.m4567.a = -2.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Lap(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +1.0; f.m0123.b = +0.0; \n    f.m0123.a = +1.0; f.m4567.r = -4.0; f.m4567.g = +1.0;\n    f.m4567.b = +0.0; f.m4567.a = +1.0; f.m8      = +0.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Identity(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +1.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3Zero(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3x8(out Pixel3x3x8 f, float scale)\n{\n    //initPixel3x3SobelDx (f.m[0], scale);\n    //initPixel3x3SobelDy (f.m[1], scale);\n    //initPixel3x3Lap     (f.m[2], scale);\n    //initPixel3x3Identity(f.m[3], scale);\n    //initPixel3x3SobelDx (f.m[4], scale);\n    //initPixel3x3SobelDy (f.m[5], scale);\n    //initPixel3x3Lap     (f.m[6], scale);\n    //initPixel3x3Identity(f.m[7], scale);\n    \n    initPixel3x3Lap      (f.m[0], scale);\n    initPixel3x3Zero     (f.m[1], scale);\n    initPixel3x3Zero     (f.m[2], scale);\n    initPixel3x3Zero     (f.m[3], scale);\n    initPixel3x3Zero     (f.m[4], scale);\n    initPixel3x3Zero     (f.m[5], scale);\n    initPixel3x3Zero     (f.m[6], scale);\n    initPixel3x3Zero     (f.m[7], scale);    \n}\n\nvoid initFilters()\n{\n    initPixel3x3x8(filters[0], 1.0);\n    initPixel3x3x8(filters[1], 1.0);\n    initPixel3x3x8(filters[2], 1.0);\n    initPixel3x3x8(filters[3], 1.0);\n    initPixel3x3x8(filters[4], 1.0);\n    initPixel3x3x8(filters[5], 1.0);\n    initPixel3x3x8(filters[6], 1.0);\n    initPixel3x3x8(filters[7], 1.0);\n}\n\nPixel3x3 Pixel3x3Add(Pixel3x3 a, Pixel3x3 b)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = a.m0123 + b.m0123;\n    r.m4567 = a.m4567 + b.m4567;\n    r.m8    = a.m8    + b.m8;\n    \n    return r;\n}\n\nPixel3x3 Pixel3x3Sub(Pixel3x3 a, Pixel3x3 b)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = a.m0123 - b.m0123;\n    r.m4567 = a.m4567 - b.m4567;\n    r.m8    = a.m8    - b.m8;\n    \n    return r;\n}\n\nfloat Pixel3x3Conv(Pixel3x3 a, Pixel3x3 b)\n{\n    float r;\n    \n    r =  dot(a.m0123, b.m0123);\n    r += dot(a.m4567, b.m4567);\n    r += a.m8    * b.m8;\n    \n    return r;\n}\n\nPixel3x3 Pixel3x3Scale(Pixel3x3 p, float w)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = p.m0123 * w;\n    r.m4567 = p.m4567 * w;\n    r.m8    = p.m8    * w;\n    \n    return r;\n}\n\n// -------------------------------------------\nfloat Pixel3x3x8Conv(Pixel3x3x8 a, Pixel3x3x8 b)\n{\n    float r;\n    \n    r =  Pixel3x3Conv(a.m[0], b.m[0]);\n    r += Pixel3x3Conv(a.m[1], b.m[1]);\n    r += Pixel3x3Conv(a.m[2], b.m[2]);\n    r += Pixel3x3Conv(a.m[3], b.m[3]);\n    r += Pixel3x3Conv(a.m[4], b.m[4]);\n    r += Pixel3x3Conv(a.m[5], b.m[5]);\n    r += Pixel3x3Conv(a.m[6], b.m[6]);\n    r += Pixel3x3Conv(a.m[7], b.m[7]);\n    \n    return r;\n}\n\n// -------------------------------------------\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.pixels.m0123.r = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.g = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.pixels.m0123.b = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.a = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    \n    i.pixels.m4567.r = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.pixels.m4567.g = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n    i.pixels.m4567.b = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.pixels.m4567.a = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    \n    i.pixels.m8      = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Step1(out Middle m, Input i)\n{\n    m.pixels.m[0] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[1] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[2] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[3] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[4] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[5] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[6] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[7] = Pixel3x3Scale(i.pixels, 1.0f);\n}\n\nvoid Step2(out Output o, Middle m)\n{\n    o.pixels[0] = Pixel3x3x8Conv(m.pixels, filters[0]);\n    o.pixels[1] = Pixel3x3x8Conv(m.pixels, filters[1]);\n    o.pixels[2] = Pixel3x3x8Conv(m.pixels, filters[2]);\n    o.pixels[3] = Pixel3x3x8Conv(m.pixels, filters[3]);\n    o.pixels[4] = Pixel3x3x8Conv(m.pixels, filters[4]);\n    o.pixels[5] = Pixel3x3x8Conv(m.pixels, filters[5]);\n    o.pixels[6] = Pixel3x3x8Conv(m.pixels, filters[6]);\n    o.pixels[7] = Pixel3x3x8Conv(m.pixels, filters[7]);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    initFilters();\n   \n    ///////////////////////////\n    // prepare input\n    \n    Input i; \n    prepareInput(i, uv);\n    \n    Middle m;\n    Step1(m, i);\n    \n    Output o;\n    Step2(o, m);\n    \n    float y = o.pixels[0];\n    //float y = o.pixels[1];\n    //float y = o.pixels[2];\n    //float y = o.pixels[3];\n    //float y = o.pixels[4];\n    //float y = o.pixels[5];\n    //float y = o.pixels[6];\n    //float y = o.pixels[7];\n    //float y = o.pixels[8];\n    \n    fragColor = vec4(y);\n}\n\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n#ifdef ECBDEMO\n// -------------------------------------------\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\n//-------------------------------------------\nstruct Pixel3x3\n{\n    vec4 m0123;\n    vec4 m4567;\n    float m8;\n};\n\nstruct Pixel3x3x8\n{\n    Pixel3x3 m[8];\n};\n\nstruct Input\n{\n    Pixel3x3 pixels;\n};\n\nstruct Middle\n{\n    Pixel3x3x8 pixels;\n};\n\nstruct Output\n{\n    Pixel3x3 pixels[8];\n};\n\nstruct ECBBlock\n{\n    Pixel3x3x8 m[8];\n    \n    float reluSlope[8];\n};\n\nfloat PReLU(float x, float A)\n{\n    if(x < 0.0)\n        return A * x;\n    else\n        return x;\n}\n\n//-------------------------------------------\nECBBlock block;\n\nvoid initPixel3x3SobelDx(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +0.0; f.m0123.b = -1.0; \n    f.m0123.a = +2.0; f.m4567.r = +0.0; f.m4567.g = -2.0;\n    f.m4567.b = +1.0; f.m4567.a = +0.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3SobelDy(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +2.0; f.m0123.b = +1.0;\n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = -1.0; f.m4567.a = -2.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Lap(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +1.0; f.m0123.b = +0.0; \n    f.m0123.a = +1.0; f.m4567.r = -4.0; f.m4567.g = +1.0;\n    f.m4567.b = +0.0; f.m4567.a = +1.0; f.m8      = +0.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Identity(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +1.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3Zero(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3x8(out Pixel3x3x8 f, float scale)\n{\n    //initPixel3x3SobelDx (f.m[0], scale);\n    //initPixel3x3SobelDy (f.m[1], scale);\n    //initPixel3x3Lap     (f.m[2], scale);\n    //initPixel3x3Identity(f.m[3], scale);\n    //initPixel3x3SobelDx (f.m[4], scale);\n    //initPixel3x3SobelDy (f.m[5], scale);\n    //initPixel3x3Lap     (f.m[6], scale);\n    //initPixel3x3Identity(f.m[7], scale);\n    \n    initPixel3x3Lap       (f.m[0], scale);\n    initPixel3x3Zero      (f.m[1], scale);\n    initPixel3x3Zero      (f.m[2], scale);\n    initPixel3x3Zero      (f.m[3], scale);\n    initPixel3x3Zero      (f.m[4], scale);\n    initPixel3x3Zero      (f.m[5], scale);\n    initPixel3x3Zero      (f.m[6], scale);\n    initPixel3x3Zero      (f.m[7], scale);    \n}\n\nvoid initECBBlock()\n{\n    initPixel3x3x8(block.m[0], 1.0);\n    initPixel3x3x8(block.m[1], 1.0);\n    initPixel3x3x8(block.m[2], 1.0);\n    initPixel3x3x8(block.m[3], 1.0);\n    initPixel3x3x8(block.m[4], 1.0);\n    initPixel3x3x8(block.m[5], 1.0);\n    initPixel3x3x8(block.m[6], 1.0);\n    initPixel3x3x8(block.m[7], 1.0);\n    \n    block.reluSlope[0] = 0.02;\n    block.reluSlope[1] = 0.01;\n    block.reluSlope[2] = 0.02;\n    block.reluSlope[3] = 0.03;\n    block.reluSlope[4] = 0.02;\n    block.reluSlope[5] = 0.01;\n    block.reluSlope[6] = 0.02;\n    block.reluSlope[7] = 0.03;\n}\n\nfloat Pixel3x3Conv(Pixel3x3 a, Pixel3x3 b)\n{\n    float r;\n    \n    r =  dot(a.m0123, b.m0123);\n    r += dot(a.m4567, b.m4567);\n    r += a.m8    * b.m8;\n    \n    return r;\n}\n\nPixel3x3 Pixel3x3Scale(Pixel3x3 p, float w)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = p.m0123 * w;\n    r.m4567 = p.m4567 * w;\n    r.m8    = p.m8    * w;\n    \n    return r;\n}\n\n// -------------------------------------------\nfloat Pixel3x3x8Conv(Pixel3x3x8 a, Pixel3x3x8 b)\n{\n    float r;\n    \n    r =  Pixel3x3Conv(a.m[0], b.m[0]);\n    r += Pixel3x3Conv(a.m[1], b.m[1]);\n    r += Pixel3x3Conv(a.m[2], b.m[2]);\n    r += Pixel3x3Conv(a.m[3], b.m[3]);\n    r += Pixel3x3Conv(a.m[4], b.m[4]);\n    r += Pixel3x3Conv(a.m[5], b.m[5]);\n    r += Pixel3x3Conv(a.m[6], b.m[6]);\n    r += Pixel3x3Conv(a.m[7], b.m[7]);\n    \n    return r;\n}\n\nfloat PReLU_Pixel3x3x8Conv(Pixel3x3x8 a, Pixel3x3x8 b, float A)\n{\n    return PReLU(Pixel3x3x8Conv(a, b), A);\n}\n\n// -------------------------------------------\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.pixels.m0123.r = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.g = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.pixels.m0123.b = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.a = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    \n    i.pixels.m4567.r = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.pixels.m4567.g = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n    i.pixels.m4567.b = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.pixels.m4567.a = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    \n    i.pixels.m8 = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Step1(out Middle m, Input i)\n{\n    m.pixels.m[0] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[1] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[2] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[3] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[4] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[5] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[6] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[7] = Pixel3x3Scale(i.pixels, 1.0f);\n}\n\nvoid Step2(out Output o, Middle m)\n{\n    // o.pixels[0] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[0]), block.reluSlope[0]);\n    // o.pixels[1] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[1]), block.reluSlope[1]);\n    // o.pixels[2] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[2]), block.reluSlope[2]);\n    // o.pixels[3] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[3]), block.reluSlope[3]);\n    // o.pixels[4] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[4]), block.reluSlope[4]);\n    // o.pixels[5] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[5]), block.reluSlope[5]);\n    // o.pixels[6] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[6]), block.reluSlope[6]);\n    // o.pixels[7] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[7]), block.reluSlope[7]);\n    \n    o.pixels[0].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[0], block.reluSlope[0]);\n    o.pixels[1].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[1], block.reluSlope[1]);\n    o.pixels[2].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[2], block.reluSlope[2]);\n    o.pixels[3].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[3], block.reluSlope[3]);\n    o.pixels[4].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[4], block.reluSlope[4]);\n    o.pixels[5].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[5], block.reluSlope[5]);\n    o.pixels[6].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[6], block.reluSlope[6]);\n    o.pixels[7].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[7], block.reluSlope[7]);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    initECBBlock();\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    ///////////////////////////\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n    \n    Middle m;\n    Step1(m, i);\n    \n    Output o;\n    Step2(o, m);\n    \n    float y = o.pixels[0].m0123.r;\n    //float y = o.pixels[1];\n    //float y = o.pixels[2];\n    //float y = o.pixels[3];\n    //float y = o.pixels[4];\n    //float y = o.pixels[5];\n    //float y = o.pixels[6];\n    //float y = o.pixels[7];\n    //float y = o.pixels[8];\n    fragColor = vec4(y);\n}\n\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////////////////////////////////////////\n// Common Function\nfloat RGB2Y(vec3 rgb)\n{\n    return (dot(vec3( 0.2990,  0.5870,  0.114), rgb));\n}\n\nfloat RGB2U(vec3 rgb)\n{\n    return (dot(vec3(-0.1678, -0.3313,  0.5000), rgb));\n}\n\nfloat RGB2V(vec3 rgb)\n{\n    return (dot(vec3( 0.5000, -0.4187, -0.0813), rgb));\n}\n\nfloat Gaussian (float x, float y, float sigma)\n{\n    return (1.0 / (2.0 * 3.141592654 * sigma * sigma)) * exp(-(x * x + y * y) / (2.0 * sigma * sigma));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}