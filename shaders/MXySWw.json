{
    "Shader": {
        "info": {
            "date": "1720013902",
            "description": "A colorful dance floor with particles generated using angular domain repetition",
            "flags": 0,
            "hasliked": 0,
            "id": "MXySWw",
            "likes": 11,
            "name": "En piste !",
            "published": 3,
            "tags": [
                "raymarching",
                "particles",
                "disco",
                "neon"
            ],
            "usePreview": 0,
            "username": "Docteur_Raton",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "#define DISCO_BALL 0\n#define PARTICLE 1\n#define FLOOR 2\n\nstruct MapData\n{\n\tfloat dist;\n\tint property;\n};\n\nconst float ballRadius = .4;\nconst vec2 e = vec2(0., 1.);\nconst float floorY = -1.1;\nconst float pi = acos(-1.);\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, -s, s, c);\n}\n\nvec3 convertCartesianToCircular(vec3 p)\n{\n\tfloat r = length(p);\n\tfloat th = acos(p.y / r);\n\tfloat ph = atan(p.z, p.x);\n\n\treturn vec3(r, th, ph);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 applyPalette(float t)\n{\n\tvec3 a = vec3(0.888, 0.278, 0.668);\n\tvec3 b = vec3(1.074, 0.714, 0.535);\n\tvec3 c = vec3(0.431, 0.431, 0.329);\n\tvec3 d = vec3(2.536, 2.476, 0.166);\n\n    return a + b * cos(2. * pi * (c * t + d ));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(1293.417823 * p.y * sin(fract(1273.1237 * p.x + 8.123198))\n\t\t+ 21831.12831 * p.x * sin(fract(1329.147 * p.y + 9.41322)));\n}\n\nMapData opU(MapData data1, MapData data2)\n{\n\tif (data1.dist < data2.dist)\n\t\treturn data1;\n\t\n\treturn data2;\n}\n\nvec3 generateParticlePosition(float numRepetitions, float thID, float phID)\n{\n\tfloat r = .4 + .2 * (pow(50. * fract(.3 * iTime + 1.1239 * hash(vec2(thID, phID))) + 1., .5) - 1.);\n\tfloat th = .5 / numRepetitions * pi;\n\tfloat ph = .5 / numRepetitions * pi;\n\n\treturn vec3(r, th, ph);\n}\n\nfloat sdDiscoBall(vec3 p)\n{\n\treturn length(p) - ballRadius;\n}\n\nvec4 applyAngularDomainRepetition(float th0, float ph0, float numRepetitions)\n{\n\tfloat thID = floor(numRepetitions * th0 / pi);\n\tfloat phID = floor(numRepetitions * ph0 / pi);\n\tfloat th = fract(numRepetitions * th0 / pi) / numRepetitions * pi;\n\tfloat ph = fract(numRepetitions * ph0 / pi) / numRepetitions * pi;\n\n\treturn vec4(th, thID, ph, phID);\n}\n\nMapData generateParticles(vec3 p)\n{\n\tvec3 circular = convertCartesianToCircular(p);\n\tfloat r = circular.x;\n\tfloat th0 = circular.y;\n\tfloat ph0 = circular.z;\n\tif (abs(th0 - pi / 2.) > 1.2)\n\t\treturn MapData(1., PARTICLE);\n\tfloat numRepetitions = 7.;\n\tvec4 repeated = applyAngularDomainRepetition(th0, ph0, numRepetitions);\n\tfloat th = repeated.x;\n\tfloat thID = repeated.y;\n\tfloat ph = repeated.z;\n\tfloat phID = repeated.w;\n\tvec3 particle = generateParticlePosition(numRepetitions, thID, phID);\n\tfloat sd = distance(vec3(r, th, ph), particle) - .001;\n\n\treturn MapData(sd, PARTICLE);\n}\n\nfloat sdFlashes(vec3 p)\n{\n\tvec3 circular = convertCartesianToCircular(p);\n\tfloat th0 = circular.y;\n\tfloat ph0 = circular.z;\n\tif (abs(th0 - pi / 2.) > 1.1)\n\t\treturn 1.;\n\tfloat numRepetitions = 5.;\n\tvec4 repeated = applyAngularDomainRepetition(th0, ph0, numRepetitions);\n\tfloat th = repeated.x;\n\tfloat thID = repeated.y;\n\tfloat ph = repeated.z;\n\tfloat phID = repeated.w;\n\n\treturn fract(.5 * iTime + .2 * thID + .5 * phID * (mod(thID, 2.) - .5)) > .9 ?\n\t\tdistance(vec2(th, ph), vec2(.5 / numRepetitions * pi)) - .001\n\t\t: 1.;\n}\n\nfloat sdFloor(vec3 p)\n{\n\treturn max(length(p.xz) - .9, p.y - floorY);\n}\n\nMapData generateMap(vec3 p)\n{\n\tfloat ball = sdDiscoBall(p);\n\tMapData res = MapData(ball, DISCO_BALL);\n\tres = opU(res, generateParticles(p));\n\tfloat flashes = sdFlashes(p);\n\tres = opU(res, MapData(flashes, PARTICLE));\n\n\treturn res;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p)\n{\n\tconst vec2 h = .001 * e.xy;\n\tfloat dx = generateMap(p + h.yxx).dist - generateMap(p - h.yxx).dist;\n\tfloat dy = generateMap(p + h.xyx).dist - generateMap(p - h.xyx).dist;\n\tfloat dz = generateMap(p + h.xxy).dist - generateMap(p - h.xxy).dist;\n\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 moveCamera(vec3 p)\n{\n\tp.xz *= rot(.1 * iTime);\n\n\treturn p;\n}\n\nvec4 renderDiscoBall(vec3 p, vec3 rd)\n{\n\tfloat threshold = .6;\n\tfloat thickness = .6;\n\tfloat brightness = smoothstep(threshold + thickness, threshold, fract(60. * acos(p.y / length(p)) / pi));\n\tbrightness *= smoothstep(threshold + thickness, threshold, fract(53. * atan(p.z, p.x) / pi));\n\tbrightness = pow(4. * brightness, -1.5);\n\tvec3 col = brightness * applyPalette(-2. * p.y + .2);\n\tvec3 normal = calcNormal(p);\n\tcol += pow(7. * abs(dot(normal, rd)), -2.) * applyPalette(.9);\n\n\treturn vec4(col, 1.);\n}\n\nvec4 trace(vec2 uv)\n{\n\tvec3 ro = vec3(0., -.45, 1.);\n\tro = moveCamera(ro);\n\tvec3 rd = normalize(vec3(uv, -1.));\n\trd = moveCamera(rd);\n\tvec3 p = ro;\n\tfloat distMinToScene = 100.;\n\tfloat numIterations = 80.;\n\tfloat reflection = 1.;\n\tfor (float i = 0.; i < numIterations; ++i)\n\t{\n\t\tMapData data = generateMap(p);\n\t\tdistMinToScene = min(distMinToScene, data.dist);\n\t\tif (rd.y < 0.)\n\t\t\tdata = opU(data, MapData(sdFloor(p), FLOOR));\n\t\tif (data.dist < 0.001)\n\t\t{\n\t\t\tswitch (data.property)\n\t\t\t{\n\t\t\tcase DISCO_BALL:\n\t\t\t\tp = ballRadius * normalize(p);\n\t\t\t\treturn reflection * clamp(renderDiscoBall(p, rd), 0., 1.);\n\t\t\tcase PARTICLE:\n\t\t\t\treturn reflection * clamp(e.yyyy, 0., 1.);\n\t\t\tcase FLOOR:\n\t\t\t\tp.y = 2. * floorY - p.y;\n\t\t\t\tfloat distMin = .01;\n\t\t\t\tfloat begin = .02;\n\t\t\t\tfloat end = .2;\n\t\t\t\tfloat tilingX = 10.;\n\t\t\t\tfloat tiles = distMin + smoothstep(begin, end, fract(tilingX * p.x));\n\t\t\t\ttiles *= distMin + smoothstep(begin, end, fract(7. * p.z + .5 * mod(floor(tilingX * p.x), 2.)));\n\t\t\t\ttiles += .05 * length(p.xz);\n\t\t\t\tdistMinToScene = min(distMinToScene, tiles);\n\t\t\t\trd = reflect(rd, e.xyx);\n\t\t\t\treflection = .65 + .5 * length(p.xz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (data.dist > 100.)\n\t\t\tbreak;\n\t\tp += .3 * data.dist * rd;\n\t}\n\tvec3 col = .015 / distMinToScene * vec3(0.87, 0.57, 0.48);\n\tcol = .015 / distMinToScene * (applyPalette(abs(sin(rd.x))) + .1);\n\n\treturn reflection * clamp(vec4(col, 1.), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfragColor = trace(uv);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}