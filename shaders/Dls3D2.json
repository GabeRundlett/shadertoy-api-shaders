{
    "Shader": {
        "info": {
            "date": "1672585032",
            "description": "A twisted dodecahedral star ball.",
            "flags": 0,
            "hasliked": 0,
            "id": "Dls3D2",
            "likes": 83,
            "name": "Twisted Dodecahedron Star Ball",
            "published": 3,
            "tags": [
                "sphere",
                "star",
                "ball",
                "icosahedron",
                "dodecahedron",
                "twist",
                "polyhedron",
                "pentagon",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 783
        },
        "renderpass": [
            {
                "code": "/*\n\n    Twisted Dodecahedron Star Ball\n    ------------------------------\n    \n    I'm not sure what you'd technically call this, but I've seen it referred\n    to as a twisted starball, so I'll call it that. From a geometric perspective,\n    it's a rendering of wavy twisted lines eminating from the pentagon face \n    centers of a dodecahedron to each of the five edges.\n    \n    I've mentioned before that I'd like to post more of the ornate polyhedral \n    objects that the geometric art crowd are fond of. Unfortunately, the lengthy \n    construction procedures don't lend themselves well to the pixelshader\n    environment -- due to the fact that we have to construct and render them\n    in a fraction of the time that it takes a Blender artist, for instance.\n    \n    My main objective was to get one of these on the board, rather than write\n    it in the most efficient way. Having said that, it seems to run resonably\n    well in windowed mode. The compile time is pretty mediocre, so I'll try to \n    get that down later.\n    \n    The construction procedure was pretty simple: Select the nearest pentagon \n    face, then render curved twisted lines from the centers to the edge midpoints.\n    Normally, that would involve 3D Bezier curves, but realtime pixelshader \n    constraints wouldn't allow for that, so I had to get inventive and take a\n    warped space approach. Thankfully, it worked. :)\n    \n    I've noticed that rendering things in spherical space isn't exactly a task \n    that a lot of coders like to undertake, and I understand that, but it's not \n    as bad as people would think. The line algorithms involve more cross products \n    and so forth, but other than that, they're roughly the same.\n  \n   \n\n\tOther examples:\n    \n    // There aren't a lot of similar examples on here. However TDHooper \n    // was doing this kind of thing before it was cool. :) Unfortunately,\n    // due to the style of rendering involved, I had to take a completely\n    // different approach.\n    Dodecahedron twist  - tdhooper\n    https://www.shadertoy.com/view/MlcGRf\n    \n    // A very stylish, beautifully rendered example. Fast too.\n    Sphere Gears - iq\n    https://www.shadertoy.com/view/tt2XzG\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Twist, or not. A regular star ball has curved lines without\n// the twist, which is neater, but not quite as interesting.\n#define TWIST\n\n// Curving the spiral arms.\n#define CURVE\n \n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    p.yz *= rot2(iTime/6./4. + 0.);\n    p.xz *= rot2(iTime/3./2.);\n    return p;\n    \n}\n\n\n// IQ's 3D box formular with rounding.\nfloat sBoxS(in vec3 p, in vec3 b, in float rf){\n  \n  vec3 d = abs(p) - b + rf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's 2D box formular with rounding.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n \n// Angle between 3D points.\nfloat angle(vec3 v1, vec3 v2){\n\n    return acos(dot(v1, v2)/(length(v1)*length(v2)));\n}\n\n \n//////////\n\n/*\n// Readjusting the points to the surface of the sphere in question. The function here\n// is the same as the one below, but that's not always the case.\nvec3 size(in vec3 p, in float rad){\n\n    //return p;\n    return normalize(p)*rad;\n}\n*/\n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI (TAU*.5) // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482 // (1. + sqrt(5.))/2.\n\n/*\n// A cartesian coordinate to spherical coordinate conversion.\nvec3 worldToSpherical(vec3 cartCoord){\n    \n    float r = length(cartCoord);\n    float ax = mod(atan(cartCoord.z, cartCoord.x), TAU); // Longitudinal coordinate.\n    float ay = mod(acos(cartCoord.y/r), PI);// Or atan(sphP.y, length(sphP.xz)); // Latitude. \n    return vec3(ax, ay, r);\n}\n*/\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n \n// Global pentagon center position.\nvec3 pentCntr = vec3(0);\n// Global pentagon latitudinal block ID.\nint pID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getDodecPent(inout vec3 q, inout vec3[5] gVertID, const float rad){\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n\n \n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    const float scX = 5.; // Longitudinal scale.\n    vec4 sph = mod(atan(q.z, q.x) + vec4(PI/5., PI/5., 0, 0), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(0, 0, .5, .5))/scX*TAU, TAU);\n\n    // Latitudinal strip positions.\n    vec4 pLat = vec4(0, ang, PI - ang, PI);\n    \n    // Pentagon center.\n    //pentCntr = vec3(0);\n    \n    // Distance to pentagon center.\n    float dist = 1e5;\n \n    // Latitudinal strip ID.\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n        \n        // The spherical coordinates of the central vertex point for each pentagon.\n        vec3 sc = vec3(sph[i], pLat[i], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n        // Nearest pentagon distance.\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           // Update.\n           dist = vDist;\n           id = i;\n           pentCntr = sc;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n\n    // The five vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n   \n    vec3 vLat = vec3(cAng, 2.*mAng - cAng, PI - (2.*mAng - cAng));\n    if(id==0 || id ==3){\n        \n        // Top and bottom pentagons.\n        float xOff = PI/5.;\n        if(id==3){ vLat = PI - vLat; xOff = 0.; }\n\n        gVertID[0] = vec3(xOff, vLat.x, rad);\n        gVertID[1] = vec3(2.*PI/5. + xOff, vLat.x, rad);\n        gVertID[2] = vec3(4.*PI/5. + xOff, vLat.x, rad);\n        gVertID[3] = vec3(6.*PI/5. + xOff, vLat.x, rad);\n        gVertID[4] = vec3(8.*PI/5. + xOff, vLat.x, rad); \n    \n    \n    }\n    else{ \n        \n        // Middle latitudinal strip pentagons.\n        if(id==2){ vLat = PI - vLat; }\n        \n        vec3 ax3 = mod(vec3(ax + TAU - PI/5., ax + PI/5., ax), TAU);\n\n        // Clockwise.\n        gVertID[0] = vec3(ax3.x, vLat.y, rad);\n        gVertID[1] = vec3(ax3.x, vLat.x, rad);\n        gVertID[2] = vec3(ax3.y, vLat.x, rad);\n        gVertID[3] = vec3(ax3.y, vLat.y, rad);\n        gVertID[4] = vec3(ax3.z, vLat.z, rad);\n    }\n    \n\n \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id==0 || id==3) pentCntr.x = 0.;\n    \n    // Debug.\n    //cID = int(floor(ax/TAU*5.));\n    \n    /*\n    // Not needed here.\n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    */\n    \n    // Global pentagon latitudinal block ID.\n    pID = id;\n    \n    \n    return q;\n}\n///////////////////\n \n// A signed spherical line running between points \"a\" and \"b\"\n// (capped at \"b\"). I wrote it and appended a wave to it in a hurry,\n// but it seems to work.\nfloat sphereLineDistCapBWave(vec3 p, vec3 a, vec3 b, float ang){ \n     \n     //float ld = length(a - b);\n     //float lp = length(p);\n     \n     p = normalize(p); // Normalize p. // p /= rad; \n     float ln = dot(p, cross(a, b))/length(a - b);\n     \n     // Perpendicular vector running through point \"b\".\n     vec3 perpB = normalize(b + cross((a - b), b))*.5;\n     // Capping the line off at point \"b\".\n     float endB = dot(p, cross(perpB, b))/length(perpB - b);\n     \n     #ifdef CURVE\n     // Using the perpendicular vector to add a sinusoidal wave to the line.\n     //ln -= sin(6.2831/ld*.25*.975*(ang))*.06;//(endB)*.95//*.975\n     ln -= sin(6.2831*2.*(endB) + 0.125)*.06;//(endB)*.95//*.975\n     //ln -= sin(6.2831*1.905*(endB))*.06;//(endB)*.95//*.975\n     #endif\n \n     // Return the signed distance. \n     return sign(ln)*max(abs(ln), endB);      \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n     // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 3.))) - 16.);\n     // Adding subtle perturbation to the plane.\n    p.z -= dot(sin(p.xy*1. - cos(p.yx*2.)), vec2(.05));\n    float wall = -p.z + 3.;\n    \n    \n////////////////    \n \n    // Dodecahedron vertices and vertex IDs for the current cell.\n    vec3[5] vP, vPID;\n\n    // Obtaining the local cell coordinates and spherical coordinates\n    // for the dodecahedron cell.\n    const float rad = .5;\n    vec3 lq = getDodecPent(q, vPID, rad);\n\n\n    // World vertex coordinates.\n    for(int i = 0; i<5; i++){\n        vP[i] = sphericalToWorld(vPID[i]);//vec3(0, rad, 0);\n    }\n\n\n    // Pentagon center cartesian coordinates.\n    vec3 vPCntr = sphericalToWorld(pentCntr);\n\n    \n    // Central curve and trimming curve.\n    float crv = 1e5, crv2 = 1e5;\n\n    \n    //float pDir = ((pID&1)==0)? 1. : -1.;\n    \n    \n    // The pentagon spiral consists of five curved lines connecting the\n    // center to the pentagon edges.\n    for(int i = min(0, iFrame); i<5; i++){ \n    \n        int ip1 = (i + 1)%5;\n\n        // Mid pentagon edge point.\n        vec3 vMid1 = normalize(mix(vP[i], vP[ip1], .5))*rad; \n        // Angle between the current point and the pentagon center.\n        float angR = angle(lq, vPCntr);\n        //float angR = length(lq - vPCntr)/length(vMid1 - vPCntr);         \n\n        // Sphere line between the mide edge point and the pentagon center.\n        // The formula has been modified to give it a sinusoidal wave.\n        float line = sphereLineDistCapBWave(lq, vMid1, vPCntr, angR);\n\n        // 2D box coordinates (The line and the Z direction).\n        vec2 lv = vec2(line, (length(lq) - .5));\n\n       \n        #ifdef TWIST\n        // Twisting (rotating) the box coordinates a quarter turn from the center to\n        // the mid point. How you do this is up to you. The way I've done it is not\n        // pefect, but it's close enough. I'll put more effort into it later.\n        lv = rot2(smoothstep(.25, 1., angR/cAng*1.15)*3.14159/4.)*lv;\n        //lv = rot2(smoothstep(.05, .95, length(lq - vPCntr)/length(vMid1 - vPCntr))*3.14159/4.)*lv;\n        //lv = rot2(smoothstep(.05, 1., angR*1.)*3.14159/4.)*lv;\n        //lv = rot2(clamp(angR*2.65 - .4, .0, 1.)*3.14159/4.)*lv;\n        #endif\n\n        /*\n        // Failed experiment with repeat boxes... I'll try again later. :)\n        float z = normalize(cross(vec3(lv.x, 0, 0), vec3(0, lv.y, 0))).z;\n        z = mod(angR*cAng/6.2831*8. + .25/8., 1./8.) - .5/8.;\n        float bx = sBoxS(vec3(lv, z), vec3(.04), .01);\n        */\n        \n        // Cross sectional 2D box object.\n        float bx = sBoxS(lv, vec2(.04), .0);\n        //float bx = max(abs(lv.x), abs(lv.y)) - .04;\n        //bx += sin(angR*cAng*256. + 3.14159)*.0003; // Ribbing.\n        //bx = max(ln2, abs(z) - .2/8.);\n        \n        // Putting on some trimming.\n        float sdBox = length(abs(lv) - .045) - .0085;//max(abs(lv.x), abs(lv.y));//\n        //sdBox += clamp(sin(angR*cAng*128. + 3.14159)*3., 0., 1.)*.002;\n        sdBox += sin(angR*cAng*256. + 3.14159)*.0005; // Beading.\n \n        crv = min(crv, bx);\n        crv2 = min(crv2, sdBox);\n \n \n            \n    }\n         \n    // Hastily written background line trimming. \n    float sc = .45;      \n    vec3 qq = p - vec3(0, 0, 3. - .02);\n    qq.xy *= rot2(-3.14159/5.);\n    qq.xy += sin(qq.xy*1. - cos(qq.yx*2.))*.05;\n    qq.y = mod(qq.y, sc) - sc/2.;\n    //\n    float bgLn = length(qq.yz) - .03;\n    bgLn += sin(6.2831*qq.x*16.)*.002; // Beading.\n    \n    // Appending the background line trimming.  \n    crv2 = min(crv2, bgLn);\n \n    // Central pentagon spheres.\n    float sph = length(lq - vPCntr*1.115) - .0325;\n     \n\n\n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, crv, crv2);\n    \n    // Shortest distance.\n    return  min(min(sph, wall), min(crv, crv2));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.75; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .1, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n    //float svMetal = gMetal;\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // Central spheres.\n            texCol = mix(vec3(1, .3, .1), vec3(1, .1, .2), abs(sn.y)*.5 + .25);\n            texCol = max((sn.xzy)*.35 + .65, .1)*texCol*1.2;\n           \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n\n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n            vec3 tx = tex3D(iChannel1, txP, txN);\n            texCol *= tx*2.; \n    \n           \n        }\n        else if(objID==1){ \n        \n            //  Wall.\n\n            // Intial background color.\n            texCol = mix(vec3(1, .5, .25), vec3(.175), .9);       \n            \n            // Coloring alternate strips.\n            float sc = .45;      \n            vec3 qq = sp;// - vec3(0, 0, 3. - .035);\n            qq.xy *= rot2(-3.14159/5.);\n            qq.xy += sin(qq.xy*1. - cos(qq.yx*2.))*.05;\n            float idy = floor(qq.y/sc + .5);\n            qq.y -= (idy + .5)*sc;//mod(qq.y, sc) - sc/2.;\n            if(mod(idy, 2.)<.5) texCol = mix(vec3(1, .5, .25), vec3(.175), .825);\n\n            // Applying texture.\n            vec3 tx = texture(iChannel1, sp.xy/3. + .5).xyz; tx *= tx;\n            texCol *= (tx + .75)*.9;\n            \n   \n            \n        }\n        else { \n        \n            // Star ball and trim color.\n\n            // Main star ball color.\n            texCol = mix(vec3(1, .3, .1), vec3(1, .1, .2), abs(sn.y)*.5 + .25);\n             \n            // Trimming.\n            if(objID==3){\n                 //All trimming.\n                 texCol = max((sn.xzy)*.35 + .65, .1)*texCol*1.2;\n                 // Star ball trimming.\n                 if(sp.z<2.5){\n                    diff *= sqrt(diff);\n                    texCol = mix(mix(texCol, vec3(1, .5, .25)/2., .8), \n                                 vec3(1)*dot(texCol, vec3(.299, .587, .114)), .2); \n                } \n        \n            }\n            \n            \n            if(sp.z>2.5){ \n            \n                // Back wall tubing metal.\n                vec3 tx = tex3D(iChannel1, sp/3. + .5, sn);\n                texCol = mix(vec3(1, .5, .25)/2., vec3(1)*dot(texCol, vec3(.299, .587, .114)), .65)*.5; \n                texCol *= (tx + .75)*.9;\n            }\n            else {\n                \n                // Star ball texturing.\n                \n                // Texture position and normal.\n                vec3 txP = sp - sphPos;\n                vec3 txN = sn;\n\n                // Rotation to match the scene movement.\n                txP = rotObj(txP);\n                txN = rotObj(txN);\n                vec3 tx = tex3D(iChannel1, txP, txN);\n                //tx = smoothstep(.0, .5, tx);\n                texCol *= tx*2.;// + .1;\n            \n            }\n            \n            \n           \n            \n            \n        }\n        \n         \n        // Specular reflection.\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 8.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel0, rf).xyz; rTx *= rTx;\n        float spF = objID == 2? 2. : 3.;\n        if(objID!=1) texCol += (texCol*.9 + .1)*speR*rTx*spF;\n        \n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .15 + vec3(1, .9, .7)*spec*freS*sh*8. + vec3(.2, .4, 1)*fre*sh*0.);\n \n\n\n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog.\n    //col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n\n\n    // No temporal blur, for comparison.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}