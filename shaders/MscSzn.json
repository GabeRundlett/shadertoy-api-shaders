{
    "Shader": {
        "info": {
            "date": "1457307752",
            "description": "An exercise with analytic (no distance field) ray-cube intersections.",
            "flags": 0,
            "hasliked": 0,
            "id": "MscSzn",
            "likes": 10,
            "name": "Analytic Cube Array",
            "published": 3,
            "tags": [
                "raycast",
                "cube",
                "analytic"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 829
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Sept 2014\n// Modified : Feb 2016\n//\n// An exercise with analytic (no distance field) ray-cube intersections.\n// \n// License : Creative Commons Non-commercial (NC) license\n\nconst float MAX_DIST = 2000.0;\nfloat CELL_SIZE = 8.0;\nstruct Cam\n{\n    vec3 R; //right\n    vec3 U; //up\n    vec3 D; //dir\n    vec3 o; //origin\n};\n    \nCam lookAt(vec3 at, float fPitch, float dst, float rot)\n{\n\tCam cam;\n    cam.D = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.U = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.R = cross(cam.D,cam.U);\n    cam.o = at-cam.D*dst;\n    return cam;\n}\n\nCam mouseLookAt(vec3 at, float dst)\n{\n    vec2 speed = vec2(3.1416,4.0);\n    vec2 mvt   = ((iMouse.xy/iResolution.xy)-0.5)*speed;\n    return lookAt(at,mvt.y,dst,mvt.x);\n}\n\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\nvec3 ray(vec2 uv, Cam cam)\n{\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\nfloat _sign(float x)\n{\n    return (x>0.)?1.:-1.;\n}\n\nvec3 rotate(vec3 p, const float yaw, const float pitch)\n{\n    p.xz = vec2( p.x*cos(yaw)+p.z*sin(yaw),\n                 p.z*cos(yaw)-p.x*sin(yaw));\n    p.yz = vec2( p.y*cos(pitch)+p.z*sin(pitch),\n                 p.z*cos(pitch)-p.y*sin(pitch));\n    return p;\n}\n\nstruct hitInfo\n{\n\tfloat dist;\n    vec2 uv;\n};\n\n//ro = ray origin\n//rd = ray direction\nhitInfo rayCubeIntersec(vec3 ro, vec3 rd, vec3 size)\n{\n    float cullingDir = all(lessThan(abs(ro),size))?1.:-1.;\n    vec3 viewSign = cullingDir*sign(rd);\n    vec3 t = (viewSign*size-ro)/rd;\n    vec2 uvx = (ro.zy+t.x*rd.zy)/size.zy; //face uv : [-1,1]\n    vec2 uvy = (ro.xz+t.y*rd.xz)/size.xz;\n    vec2 uvz = (ro.xy+t.z*rd.xy)/size.xy;\n    if(      all(lessThan(abs(uvx),vec2(1))) && t.x > 0.) return hitInfo(t.x,(uvx+1.)/2.);\n    else if( all(lessThan(abs(uvy),vec2(1))) && t.y > 0.) return hitInfo(t.y,(uvy+1.)/2.);\n    else if( all(lessThan(abs(uvz),vec2(1))) && t.z > 0.) return hitInfo(t.z,(uvz+1.)/2.);\n\treturn hitInfo(MAX_DIST,vec2(0));\n}\n\nhitInfo rayMarchArray(vec3 origin, vec3 dir)\n{\n    vec3 size = vec3(0.95,0.95,0.95);\n    float t=1.0;\n    hitInfo info;\n    for(int i=0; i < 100; ++i)\n    {\n        //Cube position\n        vec3 p = origin+t*dir;\n        vec3 cubePos = floor(p/CELL_SIZE)*CELL_SIZE+0.5*CELL_SIZE;\n        \n        //rotation values\n        float yaw = sin(iTime+cubePos.x+cubePos.y+cubePos.z);\n        float pitch = iTime/1.0+sin(iTime+cubePos.x+cubePos.y+cubePos.z);\n    \t\n        //rotated ray origin and direction\n        vec3 rd = rotate(dir,yaw,pitch);\n\t\tvec3 ro = rotate(origin-cubePos,yaw,pitch);\n        \n        //ray-cube intersection function\n        info = rayCubeIntersec(ro,rd,size);\n        \n        //check for hit : stop or continue.\n        if(info.dist<MAX_DIST)\n        \tbreak;\n        \n        //Step into the next cell.\n        t = t+CELL_SIZE; \n    }\n    return info;\n}\n\nvec3 subMain(vec2 uv)\n{\n    Cam cam = mouseLookAt(vec3(2,2.0,-12.0),5.0);\n    vec3 dir     = ray(uv,cam);\n\tvec3 origin  = vec3(1.5*sin(iTime/1.21),1.5*sin(iTime/1.00),6.4*iTime);\n    \n    hitInfo info = rayMarchArray(origin,dir);\n    \n    vec3 color = texture(iChannel0,info.uv,-2.0).xyz;\n    return mix(color,vec3(1.0,1.0,1),info.dist/400.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(subMain(uv),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}