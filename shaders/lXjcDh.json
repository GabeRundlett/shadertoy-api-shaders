{
    "Shader": {
        "info": {
            "date": "1727225364",
            "description": "This is a fork of a shader for raymarching a heightmap (https://shadertoy.com/view/WdKGzt), which facetizes the heightmap using bilinear interpolation over corner sample points.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "lXjcDh",
            "likes": 1,
            "name": "Raymarching a faceted height map",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "heightmap",
                "bilinear",
                "facets"
            ],
            "usePreview": 0,
            "username": "1j01",
            "viewed": 63
        },
        "renderpass": [
            {
                "code": "// Fork of \"Raymarching a height map\" by TheKing. https://shadertoy.com/view/WdKGzt\n// 2024-09-24 23:37:30\n//\n// This forked version facetizes the terrain.\n//\n// I wanted to see if the slopeUB (upper bound) applies equally to functions that are not continuous.\n// I also reduced the slopeUB to 1.5; I'm not sure of the exact upper bound,\n// but 1.5 seems fine for both the original scene and the facetized version.\n//\n// Is it mathematically guaranteed, though, that the slopeUB will work when sampling\n// the function in a piecewise linear fashion?\n// My intuition is that a function that samples a given function in a piecewise linear fashion\n// is Lipschitz-continuous with a Lipschitz constant equal or smaller than the original function,\n// because if you take a part of the original function with the highest slope (there may be multiple places...)\n// and try to draw a line with a higher slope between two points of the function (points defined by its input and output),\n// to get a greater y difference, you need a greater x difference. Right?\n// Like, proportionally greater, maybe? due to the Lipschitz constant of the original function?\n// \n// By the way, for a faceted terrain like this,\n// I bet you could optimize it further using Bresenham's line algorithm or DDA\n// to sample a discrete height map.\n//\n// I'm looking into this because raycasting to a large Plane mesh in THREE.js\n// is very expensive, because it's raycasted as a plain mesh, not a plane mesh,\n// or a height map.\n// Techniques used in a shader for raymarching could be applied elsewhere for raycasting!\n\nconst float angle = 1.;\nconst mat2 m1 = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n\nvec3 transform(vec3 p) {\n    mat2 m2 = mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n    p.yz *= m1;\n    p.xy *= m2;\n    return p;\n}\n\nconst float slopeUB= 1.5;\nconst float g = sin(atan(1.,slopeUB));\n\nfloat originalSde(vec3 p) {\n    float h = (sin(p.x) + sin(p.y));\n    return (p.z-h)*g;\n}\n\nfloat sde(vec3 p) {\n    // This function facetizes the height field.\n\n    // Resolution factor for discretization\n    float res = 1.0;\n\n    // Calculate floor and fractional parts for both x and y\n    vec2 cell = floor(p.xy * res) / res;\n    vec2 fractPart = fract(p.xy * res);\n\n    // Sample the original field at the corners of the grid cell\n    float a = originalSde(vec3(cell.x, cell.y, p.z));\n    float b = originalSde(vec3(cell.x + 1.0/res, cell.y, p.z));\n    float c = originalSde(vec3(cell.x, cell.y + 1.0/res, p.z));\n    float d = originalSde(vec3(cell.x + 1.0/res, cell.y + 1.0/res, p.z));\n\n    // Bilinear interpolation\n    float ab = mix(a, b, fractPart.x);\n    float cd = mix(c, d, fractPart.x);\n    float result = mix(ab, cd, fractPart.y);\n\n    return result;\n}\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.001;\n    while(true) {\n        float d = sde(p);\n        if (d < 0.0001) {break;}\n        p += rd*d;\n        if (length(p-ro) > 200.) {break;}\n    }\n    return p;\n}\n\nconst vec2 helper = vec2(1e-5,0);\n\nfloat light(vec3 l, vec3 p) {\n    float d = sde(p);\n    vec3 norm = normalize(vec3(\n        sde(p + helper.xyy) - d,\n        sde(p + helper.yxy) - d,\n        sde(p + helper.yyx) - d\n        ));\n    vec3 ld = normalize(l-p);\n    float s = max(0.,dot(ld, norm));\n    if (s > 0.) {\n        if (length(rayMarch(p,ld)-p) < length(l-p)) {\n            return 0.;\n        }\n    }\n    return s;\n}\n\nconst vec3 l = vec3(0,10,5);\nconst vec3 ro = vec3(0,0,15);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 c = vec3(15.*uv,3);\n    vec3 ro_ = ro;\n    c = transform(c);\n    ro_ = transform(ro_);\n    \n    vec3 p = rayMarch(ro_, normalize(c - ro_));\n\n    vec3 col = vec3(light(l, p));\n    \n    float d = length(p-ro_);\n    col -= vec3(smoothstep(0.,200.,d));\n    col = min(vec3(1),col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}