{
    "Shader": {
        "info": {
            "date": "1679465998",
            "description": "test- 深色色板 远端红色",
            "flags": 0,
            "hasliked": 0,
            "id": "md3SzN",
            "likes": 1,
            "name": "test- 深色色板 远端红色",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "tianluo97",
            "viewed": 152
        },
        "renderpass": [
            {
                "code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //cubicPulse动态混合过程\n    //earthmap\n    float divisionLine1 = 1.3/19.0 + 0.02;\n    //digital hardware\n    float divisionLine2 = 3.5/19.0;\n    //machine social network\n    float divisionLine3 = 6.6/19.0;\n    //FE\n    float divisionLine4 = 10.0/19.0;\n    //operation center\n    float divisionLine5 = 13.0/19.0 - 0.01;\n    //logo\n    float divisionLine6 = 16.0/19.0;\n    \n    float divisionLine;\n    int count; \n    int night;\n    \n    night = 0;\n    count = 1;\n    \n    //nightColor\n    vec4 nightColor1 = vec4(0.000,0.067,0.259,1.0);\n    vec4 nightColor0 = vec4(0.000,0.165,0.620,1.0);\n    vec4 nightColor = mix(nightColor0, nightColor1, pow(uv.x,1.));\n    nightColor = sqrt(nightColor);\n    \n    if(night==1){\n    fragColor= nightColor;\n    count = 0; \n    }\n    \n    if(night==0){\n    \n    if(count == 0){\n    divisionLine = divisionLine1;\n    }\n    \n    //from earthmap to digital hardware\n    if(count == 1){\n    divisionLine = divisionLine1 + (divisionLine2 - divisionLine1) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from digital hardware to machine social network\n    if(count == 2){\n    divisionLine = divisionLine2 + (divisionLine3 - divisionLine2) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from machine social network to FE\n    if(count == 3){\n    divisionLine = divisionLine3 + (divisionLine4 - divisionLine3) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from FE to operation center\n    if(count == 4){\n    divisionLine = divisionLine4 + (divisionLine5 - divisionLine4) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from operation center to logo\n    if(count == 5){\n    divisionLine = divisionLine5 + (divisionLine6 - divisionLine5) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    float d = cubicPulse(divisionLine,0.14,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //混合遮罩\n    maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    //maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.; \n    float scale = 1.0;\n    \n    vec4 vcolor0 = vec4(0.239,0.467,1.000,1.0);\n    vec4 vcolor1 = vec4(1.000,0.839,0.678,1.0);\n    vec4 vcolor2 = vec4(1.000,0.647,0.459,1.0);\n    \n    float blueColorDist = 0.4;\n    float blueDist = 0.29;\n    float yellowDist = 0.24;\n    float redDist = 0.14;\n    \n    float step0 = (divisionLine - blueColorDist) * scale;\n    float step1 = (divisionLine - blueDist) * scale;\n    float step2 = (divisionLine - yellowDist) * scale;\n    float step3 = (divisionLine - redDist)* scale;\n    \n    //step2 - step3是蓝色的区域\n    //float step3 = 0.6  * scale;\n    \n    float step4 = (divisionLine + redDist)  * scale;\n    float step5 = (divisionLine + yellowDist) * scale;\n    float step6 = (divisionLine + blueDist)  * scale;\n    float step7 = (divisionLine + blueColorDist)  * scale;\n    \n    float offset = uv.x+0.01-time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor;\n    \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    //darkColor = vec4(dist0,dist0,dist0,1.0);\n    darkColor = vcolor0;\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist0 = smoothstep(step0, step1, y);\n    darkColor = vec4(dist0,dist0,dist0,1.0);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = vcolor0;\n    }\n    \n    if (y > step1 && y < step2) {\n    float dist1 = smoothstep(step1, step2, y);\n    darkColor = vec4(dist1,dist1,dist1,1.0);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    darkColor = vcolor0;\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist2 = smoothstep(step2, step3, y);\n    darkColor = vec4(dist2,dist2,dist2,1.0);\n    darkColor = mix(vcolor2, vcolor0, dist2);\n    darkColor = vcolor0;\n    }\n    \n    else if (y > step3 && y < step4) {\n    float dist02 = smoothstep(step3, step4, y);\n    //darkColor = vec4(dist02,dist02,dist02,1.0);\n    darkColor = vcolor0;\n    //darkColor = correct(vcolor3, vcolor4, dist02);\n    }\n    \n    else if (y > step4 && y < step5){\n    float dist3 = smoothstep(step4, step5, y);\n    darkColor = mix(vcolor0, vcolor2, dist3);\n    }\n    \n    else if (y > step5 && y < step6){\n    float dist3 = smoothstep(step5, step6, y);\n    darkColor = mix(vcolor2, vcolor1, dist3);\n    \n    }\n    \n    else if (y > step6 && y < step7){\n    float dist3 = smoothstep(step6, step7, y);\n    darkColor = mix(vcolor1, vcolor0, dist3);\n    }\n    \n    else if (y > step7){\n    float dist3 = smoothstep(step7, 1.0*scale, y);\n    darkColor = vcolor0;\n    }\n    \n    \n    darkColor = sqrt(darkColor);\n    //浅色色板\n    \n    float qscale = 0.25;\n    float qtime = iTime* 0.015;\n    \n    float qstep0 = 0.15 * qscale;\n    float qstep1 = 0.35 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.65 * qscale;\n    \n    vec4 qcolor0 = vec4(0.722,0.804,1.000,1.0);\n    \n    vec4 qcolor1 = vec4(0.722,0.804,1.000,1.0);\n    \n    vec4 qcolor2 = vec4(1.000,0.663,0.522,1.0);\n  \n    vec4 qcolor3 = vec4(1.000,0.820,0.702,1.0);\n\n    vec4 qcolor4 = vec4(1.000,1.000,1.000,1.0);\n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    //lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    //蓝到橙色\n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    //橙色到黄色\n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    //黄色到白色\n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    //lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    //lightColor = vec4(1.0);\n    \n    //通过混合遮罩进行混合\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //ending mask mask\n    float endMask = smoothstep(0.62,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    //night to awake\n\t//fragColor = mix(nightColor, fragColor, smoothstep(0.0,1.0,iTime*0.2));\n\n    }\n    \n    \n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n   \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}