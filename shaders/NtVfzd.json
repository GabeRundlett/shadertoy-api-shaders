{
    "Shader": {
        "info": {
            "date": "1666461401",
            "description": "released at TRSAC, largely partycoded while sleep deprived and experiencing vertigo from the journey\ntowards the party :D\n\nOriginally written in GLSL, adapted for GLSLES/ShaderToy\n\ncompile time and performance is kinda very bad",
            "flags": 0,
            "hasliked": 0,
            "id": "NtVfzd",
            "likes": 9,
            "name": "Rekursive Rubik's [TRSAC22]",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 1,
            "username": "robin_be",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "/*\nThe code started nice[citation needed], but quickly\nwent to shit when deadline stress increased and quick hacks were written. Also\ndoesn't help to be sleep deprived and experiencing vertigo from the journey\ntowards the party :D\n\nOriginally written in GLSL and now adapted to work with GLSL ES in ShaderToy,\noriginal source: https://github.com/yugecin/kube\n*/\n\n#define shadertoy 1\n#define debugmov 0 //noexport\n#if shadertoy == 0\n#define iTime fpar[0].x\nlayout (location=0) uniform vec4 fpar[2];\nlayout (location=2) uniform vec4 debug[2]; //noexport\n#endif\n#define PI 3.14159265359\n#define HALFPI 1.5707963268\n#define _x_ 0 /*'___' : macro name with a double underscore is reserved - unintented behavior is possible*/\n#define RED 1\n#define BLU 2\n#define GRN 3\n#define YLW 4\n#define WHI 5\n#define ORG 6\n#define SHA 7\nvec3 COLORS[8];\nint i;\nfloat gRounding, gSide, gUnit, gOffsetStuff;\nconst float ROUNDING = 2.5;\nconst float SIDE = 12. - ROUNDING;\nconst float UNIT = SIDE * 2. + 2. * ROUNDING;\nconst float SPACING = UNIT;\nconst vec3 off = vec3(0, SPACING, -SPACING);\nconst vec4 rot = vec4(0, HALFPI, -HALFPI, PI);\nvec3 gHitPosition = vec3(0);\nvec3 gCubeOff[26];\nvec3 gCubeRot[26];\nint gCubeCol0[26], gCubeCol1[26], gCubeCol2[26];\nfloat gCubeOpacity[26];\nbool gCubeHidden[26];\nint gHitIndex = 0;\nint gExclusiveCube = -1; // if set, only that cube will be considered.\n                         //useful for consecutive map() calls for lighting after we already know what cube gets hit\n#define F 0 // front\n#define L 2 // left\n#define R 4 // right\n#define U 6 // up\n#define D 8 // down\n#define B 10 // back\nconst int gNumMovements = 12;\nint gMovements[gNumMovements];\nint gCurrentMovement;\nfloat gCurrentMovementProgress = 0.;\nconst float MOVEMENT_TIME_SECONDS = .3;\nconst float HIDE_TIME_SECONDS = .2;\nconst float FADE_TIME_SECONDS = .4;\nint gCubeHiddenOrder[25];\nbool gHackFadeStuff;\nbool gShaft;\nfloat gTimeMod;\n\nmat2 rot2(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\nvec2 oneSidedCube(vec3 p, int cubeIndex)\n{\n\tvec2 mc = vec2(length(max(abs(p) - gSide, 0.)) - gRounding, 0);\n\tfloat tc = length(max(abs(p + vec3(0., 0., gRounding + .02)) - gSide, 0.));\n\n\treturn mc.x < tc ? mc : vec2(tc, float(gCubeCol0[cubeIndex]));\n}\n\nvec2 twoSidedCube(vec3 p, int cubeIndex)\n{\n\tvec2 mc = oneSidedCube(p, cubeIndex);\n\tfloat fc = length(max(abs(p + vec3(0, -gRounding - .02, 0.)) - gSide, 0.));\n\n\treturn mc.x < fc ? mc : vec2(fc, float(gCubeCol1[cubeIndex]));\n}\n\n// also includes the shaft\nvec2 centerCube(vec3 p, int cubeIndex)\n{\n\tvec2\tmc = oneSidedCube(p, cubeIndex),\n\t\tsh = vec2(max(length(p.xy)-gUnit/4., length(max(abs(p-vec3(0.,0.,gUnit*.375)) - gUnit*.75, 0.))), 7);\n\t\n\tmc.x = max(mc.x, -(length(p+vec3(0.,0.,-gUnit))-gUnit*1.2));\n\treturn mc.x < sh.x || !gShaft ? mc : sh;\n}\n\nvec2 middleCube(vec3 p, int cubeIndex)\n{\n\tvec2 res = twoSidedCube(p, cubeIndex);\n\tres.x = max(res.x, -(length(p+vec3(0., 62., -62.))-80.));\n\tres.x = min(res.x, length(max(abs(p - vec3(0., -7., 7.)) - vec3(7., 9., 9.), 0.)));\n\treturn res;\n}\n\nvec2 cornerCube(vec3 p, int cubeIndex)\n{\n\tvec2 mc = twoSidedCube(p, cubeIndex);\n\tfloat sc = length(max(abs(p + vec3(-gRounding - .02, 0., 0.)) - gSide, 0.));\n\n\tif (sc < mc.x) mc = vec2(sc, float(gCubeCol2[cubeIndex]));\n\tvec3 cubepos = p + vec3(9., 9., -9.);\n\tfloat bit = max(length(max(abs(cubepos) - vec3(7.), 0.)), length(p+vec3(gUnit,gUnit,-gUnit))-gUnit*1.18);\n\tmc.x = min(mc.x, bit);\n\treturn mc;\n}\n\nvec2 map(vec3 p)\n{\n\tfloat tt = clamp(gTimeMod / 9., 0., 1.) * PI * 2.;\n\tp.xy *= rot2(tt * .9 + PI * 2. * .1);\n\tif (gTimeMod >= 9.) {\n\t\tp.xy *= rot2(PI * 2. * .1 * clamp(gTimeMod - 9., 0., 1.));\n\t}\n\t//p.zy *= rot2(tt);\n\tfloat boundingbox = length(max(abs(p) - vec3(gUnit * 2.1), 0.));\n\tif (boundingbox > .1) {\n\t\treturn vec2(boundingbox, 0.);\n\t}\n\tvec2 res = vec2(9e9, 0.);\n\tfor (i = 0; i < 26; i++) {\n\t\tif (gCubeHidden[i] || (gExclusiveCube != -1 && gExclusiveCube != i)) {\n\t\t\tcontinue;\n\t\t}\n\t\tvec3 offset = gCubeOff[i];\n\t\tvec2 cub;\n\t\tvec3 pa = p;\n\t\tswitch (gCurrentMovement) {\n\t\tcase F:\n\t\t\tif (offset.y == off.y) {\n\t\t\t\tpa.xz *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase L:\n\t\t\tif (offset.x == off.z) {\n\t\t\t\tpa.yz *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (offset.x == off.y) {\n\t\t\t\tpa.zy *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase B:\n\t\t\tif (offset.y == off.z) {\n\t\t\t\tpa.zx *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (offset.z == off.z) {\n\t\t\t\tpa.xy *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (offset.z == off.y) {\n\t\t\t\tpa.yx *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\tif (offset.x == off.z) {\n\t\t\tpa.yz *= rot2(gTimeMod);\n\t\t}\n\t\tif (offset.x == off.y) {\n\t\t\tpa.yz *= rot2(-gTimeMod);\n\t\t}\n\t\tif (offset.x == off.x) {\n\t\t\tpa.yz *= rot2(-gTimeMod * 0.8);\n\t\t}\n\t\tif (offset.y == off.z) {\n\t\t\t//pa.xz *= rot2(gTimeMod);\n\t\t}\n\t\tif (\n\t\t\t!(offset.x == 0. && offset.y == 0.) &&\n\t\t\t!(offset.x == 0. && offset.z == 0.) &&\n\t\t\t!(offset.y == 0. && offset.z == 0.)\n\t\t) {\n\t\t\toffset *= sin(gTimeMod) + 2.;\n\t\t}\n\t\t*/\n\t\tpa -= offset * gOffsetStuff;\n\t\tpa.xy *= rot2(gCubeRot[i].x);\n\t\tpa.yz *= rot2(gCubeRot[i].y);\n\t\tpa.xz *= rot2(gCubeRot[i].z);\n\t\tif (gCubeCol1[i] == _x_) {\n\t\t\tfloat boundingbox = length(max(abs(pa - vec3(0., 0., gUnit * .36)) - vec3(gUnit * .55, gUnit * .55, gUnit * .9), 0.));\n\t\t\tcub = boundingbox < .1 ? centerCube(pa, i) : vec2(boundingbox, 0.);\n\t\t} else if (gCubeCol2[i] == _x_) {\n\t\t\tfloat boundingbox = length(max(abs(pa) - vec3(gUnit * .7), 0.));\n\t\t\tcub = boundingbox < .1 ? middleCube(pa, i) : vec2(boundingbox, 0.);\n\t\t} else {\n\t\t\tfloat boundingbox = length(max(abs(pa) - vec3(gUnit * .7), 0.));\n\t\t\tcub = boundingbox < .1 ? cornerCube(pa, i) : vec2(boundingbox, 0.);\n\t\t}\n\t\tif (cub.x < res.x) {\n\t\t\tres = cub;\n\t\t\tgHitIndex = i;\n\t\t}\n\t}\n\treturn res;\n}\n\nvec3 norm(vec3 p, float dist_to_p)\n{\n\tvec2 e = vec2(.001, 0);\n\treturn normalize(dist_to_p - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n// x=hit y=dist_to_p z=dist_to_ro w=material(if hit)\nvec4 march(vec3 ro, vec3 rd, int maxSteps)\n{\n\tvec4 r = vec4(0);\n\tfor (i = 0; i < maxSteps && r.z < 350.; i++){\n\t\tgHitPosition = ro + rd * r.z;\n\n\t\t//p.y += 100.;\n\t\t//p.z -= 10.;\n\t\t//p.yz *= rot2(-.9);\n\t\t//p = mod(p, 30.) - 15.;\n\t\t//p.xy *= rot2(gTimeMod/2.);\n\t\t//p.yz *= rot2(gTimeMod/3.);\n\t\t//p.xz*=rot2(sin(p.z*0.2)*0.2+gTimeMod);\n\t\tvec2 m = map(gHitPosition);\n\t\tfloat distance = m.x;\n\t\tif (distance < .03) {\n\t\t\tr.x = 1.;\n\t\t\tr.y = distance;\n\t\t\tr.w = m.y;\n\t\t\tbreak;\n\t\t}\n\t\tr.z += distance;\n\t}\n\treturn r;\n}\n\nvec3 colorHit(vec4 result, vec3 rd)\n{\n\tgExclusiveCube = gHitIndex;\n\tvec3 shade = vec3(0);\n\tint material = int(result.w);\n\tif (0 <= material && material <= 7) {\n\t\tshade = COLORS[material];\n\t}\n\tvec3 normal = norm(gHitPosition, result.y);\n\t// coloring magic from https://www.shadertoy.com/view/sdVczz\n\tfloat diffuse = max(0., dot(normal, -rd));\n\tfloat fresnel = pow(1. + dot(normal, rd), 4.);\n\tfloat specular = pow(max(dot(reflect(rd, normal), -rd), 0.), 30.);\n\n\t// we could not do ambient occlusion and save map() call for more performance\n\t//float ambientOcc = clamp(map(gHitPosition + normal * .05).x / .05, 0., 1.);\n\tfloat ambientOcc = .9; // .9 on purpose, because it's brighter and looks slighty better\n\n\tfloat scat = smoothstep(0., 1., map(gHitPosition - rd * .4).x / .4); // \"sub surface scattering\"\n\tshade = mix(specular + shade * (ambientOcc + .2) * (diffuse + scat * .1), shade, fresnel);\n\t//shade = mix(background, shade, exp(-.002 * result.y * result.y * result.y));\n\tgExclusiveCube = -1;\n\treturn shade;\n}\n\n#if shadertoy == 1\nvoid mainImage(out vec4 c, in vec2 v)\n#else\nout vec4 c;\nin vec2 v;\nvoid main()\n#endif\n{\n\tgMovements[0] = F;\n\tgMovements[1] = F;\n\tgMovements[2] = B;\n\tgMovements[3] = B;\n\tgMovements[4] = L;\n\tgMovements[5] = L;\n\tgMovements[6] = R;\n\tgMovements[7] = R;\n\tgMovements[8] = U;\n\tgMovements[9] = U;\n\tgMovements[10] = D;\n\tgMovements[11] = D;\n\tCOLORS[0] = vec3(.03);\n\tCOLORS[1] = vec3(1, 0, 0);\n\tCOLORS[2] = vec3(0, 0, 1);\n\tCOLORS[3] = vec3(0, 1, 0);\n\tCOLORS[4] = vec3(1, 1, 0);\n\tCOLORS[5] = vec3(1);\n\tCOLORS[6] = vec3(1., .3, .0);\n\tCOLORS[7] = vec3(.9, .9, .8);\n\tgCubeOff[ 0] = off.zyz;\n\tgCubeOff[ 1] = off.xyz;\n\tgCubeOff[ 2] = off.yyz;\n\tgCubeOff[ 3] = off.zxz;\n\tgCubeOff[ 4] = off.xxz;\n\tgCubeOff[ 5] = off.yxz;\n\tgCubeOff[ 6] = off.zzz;\n\tgCubeOff[ 7] = off.xzz;\n\tgCubeOff[ 8] = off.yzz;\n\tgCubeOff[ 9] = off.zyx;\n\tgCubeOff[10] = off.xyx;\n\tgCubeOff[11] = off.yyx;\n\tgCubeOff[12] = off.zxx;\n\tgCubeOff[13] = off.yxx;\n\tgCubeOff[14] = off.zzx;\n\tgCubeOff[15] = off.xzx;\n\tgCubeOff[16] = off.yzx;\n\tgCubeOff[17] = off.zyy;\n\tgCubeOff[18] = off.xyy;\n\tgCubeOff[19] = off.yyy;\n\tgCubeOff[20] = off.zxy;\n\tgCubeOff[21] = off.xxy;\n\tgCubeOff[22] = off.yxy;\n\tgCubeOff[23] = off.zzy;\n\tgCubeOff[24] = off.xzy;\n\tgCubeOff[25] = off.yzy;\n\tgCubeRot[ 0] = rot.yxx;\n\tgCubeRot[ 1] = rot.xxx;\n\tgCubeRot[ 2] = rot.xxx;\n\tgCubeRot[ 3] = rot.yxx;\n\tgCubeRot[ 4] = rot.xxx;\n\tgCubeRot[ 5] = rot.zxx;\n\tgCubeRot[ 6] = rot.wxx;\n\tgCubeRot[ 7] = rot.wxx;\n\tgCubeRot[ 8] = rot.zxx;\n\tgCubeRot[ 9] = rot.xxz;\n\tgCubeRot[10] = rot.xyx;\n\tgCubeRot[11] = rot.zxz;\n\tgCubeRot[12] = rot.yyx;\n\tgCubeRot[13] = rot.zyx;\n\tgCubeRot[14] = rot.yxz;\n\tgCubeRot[15] = rot.xzx;\n\tgCubeRot[16] = rot.wxz;\n\tgCubeRot[17] = rot.yyx;\n\tgCubeRot[18] = rot.xyx;\n\tgCubeRot[19] = rot.xyx;\n\tgCubeRot[20] = rot.yyx;\n\tgCubeRot[21] = rot.xwx;\n\tgCubeRot[22] = rot.zyx;\n\tgCubeRot[23] = rot.wyx;\n\tgCubeRot[24] = rot.xwx;\n\tgCubeRot[25] = rot.xwx;\n\tgCubeHiddenOrder[ 0] = 9;\n\tgCubeHiddenOrder[ 1] = 5;\n\tgCubeHiddenOrder[ 2] = 25;\n\tgCubeHiddenOrder[ 3] = 24;\n\tgCubeHiddenOrder[ 4] = 17;\n\tgCubeHiddenOrder[ 5] = 11;\n\tgCubeHiddenOrder[ 6] = 3;\n\tgCubeHiddenOrder[ 7] = 6;\n\tgCubeHiddenOrder[ 8] = 8;\n\tgCubeHiddenOrder[ 9] = 2;\n\tgCubeHiddenOrder[10] = 14;\n\tgCubeHiddenOrder[11] = 19;\n\tgCubeHiddenOrder[12] = 1;\n\tgCubeHiddenOrder[13] = 20;\n\tgCubeHiddenOrder[14] = 22;\n\tgCubeHiddenOrder[15] = 16;\n\tgCubeHiddenOrder[16] = 23;\n\tgCubeHiddenOrder[17] = 7;\n\tgCubeHiddenOrder[18] = 18;\n\tgCubeHiddenOrder[19] = 4;\n\tgCubeHiddenOrder[20] = 10;\n\tgCubeHiddenOrder[21] = 12;\n\tgCubeHiddenOrder[22] = 13;\n\tgCubeHiddenOrder[23] = 15;\n\tgCubeHiddenOrder[24] = 21;\n\t//0,\n\tgTimeMod = mod(iTime, 10.);\n\tgCubeCol0[ 0] = RED; gCubeCol1[ 0] = YLW; gCubeCol2[ 0] = BLU;\n\tgCubeCol0[ 1] = RED; gCubeCol1[ 1] = BLU; gCubeCol2[ 1] = _x_;\n\tgCubeCol0[ 2] = RED; gCubeCol1[ 2] = BLU; gCubeCol2[ 2] = WHI;\n\tgCubeCol0[ 3] = RED; gCubeCol1[ 3] = YLW; gCubeCol2[ 3] = _x_;\n\tgCubeCol0[ 4] = RED; gCubeCol1[ 4] = _x_; gCubeCol2[ 4] = _x_;\n\tgCubeCol0[ 5] = RED; gCubeCol1[ 5] = WHI; gCubeCol2[ 5] = _x_;\n\tgCubeCol0[ 6] = RED; gCubeCol1[ 6] = GRN; gCubeCol2[ 6] = YLW;\n\tgCubeCol0[ 7] = RED; gCubeCol1[ 7] = GRN; gCubeCol2[ 7] = _x_;\n\tgCubeCol0[ 8] = RED; gCubeCol1[ 8] = WHI; gCubeCol2[ 8] = GRN;\n\tgCubeCol0[ 9] = YLW; gCubeCol1[ 9] = BLU; gCubeCol2[ 9] = _x_;\n\tgCubeCol0[10] = BLU; gCubeCol1[10] = _x_; gCubeCol2[10] = _x_;\n\tgCubeCol0[11] = BLU; gCubeCol1[11] = WHI; gCubeCol2[11] = _x_;\n\tgCubeCol0[12] = YLW; gCubeCol1[12] = _x_; gCubeCol2[12] = _x_;\n\tgCubeCol0[13] = WHI; gCubeCol1[13] = _x_; gCubeCol2[13] = _x_;\n\tgCubeCol0[14] = GRN; gCubeCol1[14] = YLW; gCubeCol2[14] = _x_;\n\tgCubeCol0[15] = GRN; gCubeCol1[15] = _x_; gCubeCol2[15] = _x_;\n\tgCubeCol0[16] = WHI; gCubeCol1[16] = GRN; gCubeCol2[16] = _x_;\n\tgCubeCol0[17] = YLW; gCubeCol1[17] = ORG; gCubeCol2[17] = BLU;\n\tgCubeCol0[18] = BLU; gCubeCol1[18] = ORG; gCubeCol2[18] = _x_;\n\tgCubeCol0[19] = BLU; gCubeCol1[19] = ORG; gCubeCol2[19] = WHI;\n\tgCubeCol0[20] = YLW; gCubeCol1[20] = ORG; gCubeCol2[20] = _x_;\n\tgCubeCol0[21] = ORG; gCubeCol1[21] = _x_; gCubeCol2[21] = _x_;\n\tgCubeCol0[22] = WHI; gCubeCol1[22] = ORG; gCubeCol2[22] = _x_;\n\tgCubeCol0[23] = GRN; gCubeCol1[23] = ORG; gCubeCol2[23] = YLW;\n\tgCubeCol0[24] = ORG; gCubeCol1[24] = GRN; gCubeCol2[24] = _x_;\n\tgCubeCol0[25] = ORG; gCubeCol1[25] = GRN; gCubeCol2[25] = WHI;\n\tgCubeHidden[0] = false;\n\tgCubeOpacity[0] = 1.;\n\tgHackFadeStuff = false;\n\tfor (i = 0; i < 26 - 1; i++) {\n\t\tint index = gCubeHiddenOrder[i];\n\t\tgCubeOpacity[index] = 1.;\n\t\tfloat time = gTimeMod >= 9. ? 0. : gTimeMod;\n\t\tint whatever = i >= 19 ? 21 : i + 1;\n\t\tfloat until = float(gNumMovements) * MOVEMENT_TIME_SECONDS + float(whatever) * HIDE_TIME_SECONDS;\n\t\tif (float(until) < time) {\n\t\t\tgCubeHidden[index] = true;\n\t\t} else {\n\t\t\tgCubeHidden[index] = false;\n\t\t\tif (float(until - FADE_TIME_SECONDS) < time) {\n\t\t\t\tif (i > 21) {\n\t\t\t\t\tgHackFadeStuff = true;\n\t\t\t\t}\n\t\t\t\tgCubeOpacity[index] = (float(until) - time) / FADE_TIME_SECONDS;\n\t\t\t}\n\t\t}\n\t}\n\n\tgCurrentMovement = -1;\n\tgCurrentMovementProgress = 0.;\n\tfor (i = 0; gTimeMod < 9. && i < gNumMovements; i++) {\n\t\tfloat until = float(i + 1) * MOVEMENT_TIME_SECONDS;\n\t\tif (float(until) < gTimeMod) {\n\t\t\tint tmp;\n#define _0 gCubeCol0\n#define _1 gCubeCol1\n#define _2 gCubeCol2\n#define swap(a,b,c,d,e,f,g,h) tmp=a[b];a[b]=c[d];c[d]=e[f];e[f]=g[h];g[h]=tmp;\n\t\t\tswitch (gMovements[i]) {\n\t\t\tcase F:\n\t\t\t\tswap(_0, 2, _1, 0, _1, 17, _2, 19);\n\t\t\t\tswap(_1, 11, _0, 1, _0, 9, _1, 18);\n\t\t\t\tswap(_1, 19, _2, 2, _0, 0, _0, 17);\n\t\t\t\tswap(_1, 2, _2, 0, _2, 17, _0, 19);\n\t\t\t\tswap(_1, 1, _1, 9, _0, 18, _0, 11);\n\t\t\t\tbreak;\n\t\t\tcase L:\n\t\t\t\tswap(_0, 0, _1, 6, _1, 23, _2, 17);\n\t\t\t\tswap(_2, 0, _0, 6, _0, 23, _1, 17);\n\t\t\t\tswap(_1, 9, _0, 3, _0, 14, _1, 20);\n\t\t\t\tswap(_2, 6, _2, 23, _0, 17, _1, 0);\n\t\t\t\tswap(_1, 3, _1, 14, _0, 20, _0, 9);\n\t\t\t\tbreak;\n\t\t\tcase R:\n\t\t\t\tswap(_0, 2, _0, 19, _0, 25, _2, 8);\n\t\t\t\tswap(_1, 25, _0, 8, _1, 2, _1, 19);\n\t\t\t\tswap(_0, 5, _0, 11, _1, 22, _1, 16);\n\t\t\t\tswap(_2, 2, _2, 19, _2, 25, _1, 8);\n\t\t\t\tswap(_1, 5, _1, 11, _0, 22, _0, 16);\n\t\t\t\tbreak;\n\t\t\tcase B:\n\t\t\t\tswap(_0, 8, _2, 25, _1, 23, _2, 6);\n\t\t\t\tswap(_0, 6, _1, 8, _0, 25, _2, 23);\n\t\t\t\tswap(_0, 7, _0, 16, _0, 24, _1, 14);\n\t\t\t\tswap(_2, 8, _1, 25, _0, 23, _1, 6);\n\t\t\t\tswap(_1, 7, _1, 16, _1, 24, _0, 14);\n\t\t\t\tbreak;\n\t\t\tcase U:\n\t\t\t\tswap(_1, 6, _1, 0, _1, 2, _1, 8);\n\t\t\t\tswap(_2, 8, _2, 6, _2, 0, _2, 2);\n\t\t\t\tswap(_1, 7, _1, 3, _1, 1, _1, 5);\n\t\t\t\tswap(_0, 6, _0, 0, _0, 2, _0, 8);\n\t\t\t\tswap(_0, 7, _0, 3, _0, 1, _0, 5);\n\t\t\t\tbreak;\n\t\t\tcase D:\n\t\t\t\tswap(_2, 17, _2, 23, _1, 25, _2, 19);\n\t\t\t\tswap(_2, 25, _0, 19, _0, 17, _0, 23);\n\t\t\t\tswap(_0, 18, _0, 20, _1, 24, _0, 22);\n\t\t\t\tswap(_1, 17, _1, 23, _0, 25, _1, 19);\n\t\t\t\tswap(_1, 18, _1, 20, _0, 24, _1, 22);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tgCurrentMovement = gMovements[i];\n\t\t\tgCurrentMovementProgress = 1. - (float(until) - gTimeMod) / MOVEMENT_TIME_SECONDS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if shadertoy == 1\n\tvec2 uv = (v-.5*iResolution.xy)/iResolution.y;\n#else\n\tvec2 uv=v;uv.y/=1.77;\n#endif\n\n\tvec3 ro = vec3(-80, 80, -70);\n\tvec3 at = vec3(0, 0, 10);\n\n#if debugmov == 1 //noexport\n\tro = debug[0].xyz; //noexport\n\tfloat vertAngle = debug[1].y/20.; //noexport\n\tfloat horzAngle = debug[1].x/20.; //noexport\n\tif (abs(vertAngle) < .001) { //noexport\n\t\tvertAngle = .001; //noexport\n\t} //noexport\n\tfloat xylen = sin(vertAngle); //noexport\n\tvertAngle = cos(vertAngle); //noexport\n\tat.x = ro.x + cos(horzAngle) * xylen; //noexport\n\tat.y = ro.y + sin(horzAngle) * xylen; //noexport\n\tat.z = ro.z + vertAngle; //noexport\n#endif //noexport\n\n\tgRounding = ROUNDING;\n\tgSide = SIDE;\n\tgUnit = UNIT;\n\tgOffsetStuff = 1.;\n\tgShaft = true;\n\tif (gTimeMod >= 9.) {\n\t\tfloat tt = gTimeMod - 9.;\n\t\tgRounding = mix(3.4, ROUNDING, tt);\n\t\tgSide = 12. - gRounding;\n\t\tgUnit = gSide * 2. + 2. * gRounding;\n\t\tgOffsetStuff = mix(.23, 1., tt);\n\t\tro.z += mix(4., 0., tt);\n\t\tat.z += mix(4., 0., tt);\n\t\tgShaft = false;\n\t}\n\n\tvec3\tcf = normalize(at-ro),\n\t\tcl = normalize(cross(cf,vec3(0,0,-1))),\n\t\trd = mat3(cl,normalize(cross(cl,cf)),cf)*normalize(vec3(uv,1)),\n\t\tcol = vec3(.1) - length(uv) * .05;\n\n\tvec4 result = march(ro, rd, 100);\n\n\tif (result.x > 0.) { // hit\n\t\tvec3 shade = colorHit(result, rd);\n\t\tif (gCubeOpacity[gHitIndex] < 1.) {\n\t\t\tfloat opacity = gCubeOpacity[gHitIndex];\n\t\t\tgCubeHidden[gHitIndex] = true;\n\t\t\tresult = march(gHitPosition, rd, 50); // TODO: how many steps?\n\t\t\tvec3 without = result.x > 0. && (!gHackFadeStuff || gHitIndex == 0) ? colorHit(result, rd) : col;\n\t\t\tshade = mix(without, shade, opacity);\n\t\t}\n\t\tcol = shade;\n\t}\n\n\tc = vec4(pow(col, vec3(.4545)), 1.0); // pow for gamma correction because all the cool kids do it\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}