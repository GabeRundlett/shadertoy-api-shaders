{
    "Shader": {
        "info": {
            "date": "1583011341",
            "description": "Two walls with some modded fbm",
            "flags": 32,
            "hasliked": 0,
            "id": "3tKXRG",
            "likes": 58,
            "name": "Day 72",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1459
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,2.7)*0.2;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*5.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*3.; \n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.8);\n    //1fragColor *= 18.;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.2;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define FL_H 0.4\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin(6.28*((c)*(d) + (e))))\n\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\nvec3 glowC = vec3(0);\n\nvec3 reflAtten = vec3(1);\nfloat randomO(vec2 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.625)*225.5235);\n} \n\nfloat random(vec2 u){\n\treturn texture(iChannel0, (u/256.)).x;\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = smoothstep(0.5,1.,fract(p));\n    f = smoothstep(0.7,1.,f);\n    //f = smoothstep(0.2,1.,f);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nvec2 valueNoise(float p){\n\tvec2 a = texture(iChannel0, vec2(floor(p))/256.).xy;\n\tvec2 b = texture(iChannel0, vec2(floor(p) + 1.)/256.).xy;\n    return mix(a,b,smoothstep(0.,1.,fract(p)));\n}\n\nfloat fbm(vec2 p) { \n    p *= 0.6;\n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 5; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .7;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n\nvec3 path (float z){\n    z *= 0.5;\n\treturn vec3(\n    \tsin(z + cos(z*0.7))*0.7,\n    \tcos(z + cos(z*1.2))*0.6,\n        0.\n    )*1.;\n}\n\n#define pmod(p,x) mod(p,x) - x*0.5\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    \n    float n = fbm(p.xz)*1.;\n    float m = pow(abs(sin(p.z*0.03)),10.);\n    n *= 1. + m*2.;\n    n *= 0.5;\n    //n = pow(n*1., 4.)*3.;\n    \n    p.xy *= rot(sin(p.z*0.9 + sin( p.x*2. + p.z*4. + iTime*0.1)*0.9 + p.z*0.1)*0.6);\n    \n    \n    float flTop =(-p.y + FL_H + n*0.7)*0.3;\n    d = dmin(d, vec2(flTop,1.));\n    \n    \n    float flBot =(p.y + FL_H + n*0.7)*0.3;\n    \n    d = dmin(d, vec2(flBot,1.));\n    \n    //d = dmin(d, vec2(length(p) - 0.1, 2.));\n    \n    vec3 z = p;\n    p.xz = pmod(p.xz, 0.6);\n    \n    p.y = abs(p.y);\n    p.y -= FL_H*0.7 + n*0.7;\n    float dBalls = length(p);\n    vec3 q = abs(p) - 0.04;\n    \n    \n    float dPipes = max(q.x,q.y);\n    float dPipesB = max(q.y,q.z);\n    //d = dmin(d, vec2(dPipes, 2.));\n    \n    float atten = pow(abs(sin(z.z*0.2 + iTime*0.2)), 10.);\n    float attenB = pow(abs(sin(z.z*0.02  + sin(z.x + iTime)*0.2 + sin(z.y*3.)*1. + iTime*0.5)), 100.);\n    float attenC = pow(abs(sin(z.z*0.1  + sin(z.x + iTime)*0.2 + sin(z.y*3.)*4. + iTime*0.2)), 200.);\n    \n    vec3 col = pal(0.2,0.6 - attenC,vec3(0.1 + pow(abs(sin(iTime*1.)), 40. )*0.005,2.2,0.3),0.5 + sin(iTime)*0.005,0.5 - attenB*0.6);\n    //vec3 col = pal(0.4,0.6,vec3(0.1 + pow(abs(sin(iTime*1.)), 40.)*0.0,2.2,0.3),0.5 + sin(iTime)*0.01,0.5 );\n    \n    //vec3 col = pal(0.4,0.6,vec3(0.1 + pow(abs(sin(iTime*1.)), 40.)*0.1,2.2,0.3),0.5 + sin(iTime)*0.01,0.5 - attenB*0.6);\n\n    \n    float sc = 60. - atten*55.;\n    glowB += exp(-dPipes*sc)*col*reflAtten;\n    glowB += exp(-dPipesB*sc)*col*reflAtten;\n    //glowC += exp(-dBalls*90.)*colB;\n    //glowB -= 0.002/(0.02 + dPipes*dPipes)*0.4;\n    d.x *= 0.6;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro; t = 0.; hit = false;\n    for (int i = 0; i < 150 ; i++){\n    \td = map(p);\n        //glow += exp(-d.x*20.);\n        if(d.x < 0.002){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;        \n    }\n\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.01,0);\n    return normalize(\n    \tvec3(\n        \tmap(p - t.xyy).x - map(p + t.xyy).x,\n        \tmap(p - t.yxy).x - map(p + t.yxy).x,\n        \tmap(p - t.yyx).x - map(p + t.yyx).x\n        )\n    );\n}\n\n\n#define mx (10.*iMouse.x/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float m = pow(abs(sin(T/2.)), 5.);\n    //uv *= 1. - dot(uv,uv)*(1. - pow(m,2.)*1.)*0.4;\n    \n    \n    \n    //uv.xy *= rot(0.1)\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += mx*2.;\n    ro.xy += valueNoise(iTime*40.)*(0.01)*m; // camshake\n    \n    ro.z += iTime*SPEED - sin(T)*SPEED;\n    \n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 1.);\n    \n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    rd.xy *= rot(sin(iTime)*0.1);\n    \n    \n    \n    //ro += rd*texture(iChannel0, (uv*200. + iTime*9.)).x*2.;\n    \n    bool hit; float t; vec3 p;\n    \n    float bounce;\n    \n    float firstT = 0.;\n    vec2 d;\n    for(int i = 0; i < 2     ; i++){\n        d = march(ro, rd, p, t, hit);\n        vec3 n = getNormal(p);\n        \n        if(i == 0){\n        \tfirstT = t;\n        }\n        reflAtten *= 0.53;\n           \n        rd = reflect(rd, n);\n        ro = p + rd*0.1;\n    }\n    \n\t\n    \n    glowB = max(glowB, 0.);\n    glowB = pow(glowB, vec3(1./0.45));\n    col += glowB*0.0004;\n    \n    col += glowC*0.004;\n    col += glow*0.1;\n    col = mix(col, vec3(0.55,0.25,0.2)*0.01, pow(smoothstep(0.,1., firstT*0.08), 2.) );\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define iTime (iTime + 2.5)\n    #define T iTime\n    \n    #define SPEED 2.",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}