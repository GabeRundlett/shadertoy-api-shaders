{
    "Shader": {
        "info": {
            "date": "1455185029",
            "description": "a grazing-free closed-form solution for describing implicit surfaces with piecewise quadratic functions. This interactive test scene completes in up to 6 iterations. See https://gist.github.com/paniq/002ea2cc587b91ee02a2 for more info.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldGGWw",
            "likes": 32,
            "name": "Polynomial Horizon Tracing",
            "published": 3,
            "tags": [
                "raytracing",
                "quadratic",
                "polynomial",
                "implicits",
                "arithmetic"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1797
        },
        "renderpass": [
            {
                "code": "// instant implicit surfaces via polynomial arithmetic\n// -- @paniq\n\n/*\n\tThis solution uses polynomial arithmetic to build primitives\n\tin the same way SDF primitives are built. Instead of distance\n\tscalars, we compute the coefficients of polynomials of\n\tdegree 2, also known as quadratic functions. A set of\n\tarithmetic operations makes translation of distance functions\n\tstraightforward.\n\n\tUnlike with distance estimators, we build our entry coefficients\n\tnot from a point in space, but from a ray origin, direction and\n\tdistance scalar. The resulting x/y/z functions can then however\n\tbe processed like points.\n\n\tAfter mapping, the resulting polynomial function can then be\n\tsolved for its roots, and if a root is found, the ray hits\n\tthe surface.\n\n\tHowever, due to combining several functions, we increase the\n\tnumber of possible roots, and so must advance on the ray \n\tpiecewise. Therefore each set of coefficients is extended with\n\tan additional horizon scalar which specifies after which\n\tray distance the function is no longer valid.\n\n\tThe ray is then marched piecewise, travelling from horizon\n\tto horizon in order to select the new current function until\n\ta valid root has been found.\n\n\tEvery operation that combines two quadratics to form a \n\tnon-continuous function, such as min/max/abs, computes a\n\tsectional horizon at which one function switches to the other,\n\ttaking into account a possible existing horizon.\n\n\tEach source function must be in quadratic form. That means\n\twhen existing distance estimators are ported, no square roots\n\tmust be performed (in fact, this arithmetic operation does\n    not exist); e.g. the spherical formula length(p)-r must be\n\tconverted to dot(p,p)-r*r. On the upside, this renders \n\tintersections with quadrics, ellipsoids, cones and \n\tcylinders trivial, as well as operating skew operations.\n\t\n\tAll linear functions should be converted to quadratic form\n\tas well. The best way to do this is to bring the result in\n\tsigned quadratic form; e.g. the plane formula dot(p,n)-w\n\tshould be converted to spow2((dot(p,n)) - spow2(w), where\n\tspow2 is defined as x*x*sign(x). This way, comparisons\n\tbetween different functions yield similar voronoi cells\n\tas with distance estimators.\n\t\n\tIt is possible to keep linear functions as-is, but then\n\tone has to consider a=0 in the quadratic solver. i.e.\n\tforcing all functions to remain quadratic unifies the\n\tsolving.\n\n*/\n\n// uncomment to visualize various extra graphs\n// #define DEBUG_VIZ\n// rainbow zig zag line: actual trace, each hue is an iteration\n// red: zero line\n// white: f(x)\n// yellow: f'(x)\n// green: f''(x)\n// magenta: distance to next horizon (discontinuity)\n// cyan: distance to next root\n\n// uncomment to use hardmin optimization (broken)\n// #define USE_HARDMIN\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n// polynomial arithmetic\n// describes piecewise univariate polynomial with degree 2\nstruct poly2 {\n    // the coefficients for f(x) = a0 * x^0 + a1 * x^1 + a2 * x^2\n    vec3 a;\n    // distance to horizon\n    float h;\n};\n\nconst float infinity = 1. / 0.;\n    \nbool hasaxis(poly2 f) {\n    return (f.h != infinity);\n}\n\npoly2 pa_init(float x) {\n    return poly2(vec3(x,1.0,0.0),infinity);\n}\n    \nfloat merge_axes(poly2 f, poly2 g) {\n    if (hasaxis(g)) {\n        if (hasaxis(f)) {\n            float a0 = min(f.h, g.h);\n            float a1 = max(f.h, g.h);\n            return ((a0 > 0.0)?a0:a1);\n        } else {\n            return g.h;\n\t\t}\n    }\n    return f.h;\n}\n\npoly2 pa_add(poly2 f, poly2 g) {\n    return poly2(f.a + g.a,merge_axes(f,g));\n}\npoly2 pa_add(poly2 f, float c) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_add(float c, poly2 f) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(poly2 f, poly2 g) {\n    return poly2(f.a - g.a,merge_axes(f,g));\n}\npoly2 pa_sub(poly2 f, float c) {\n    return poly2(vec3(f.a[0] - c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(float c, poly2 f) {\n    return poly2(vec3(c - f.a[0],-f.a[1],-f.a[2]),f.h);\n}\npoly2 pa_unm(poly2 f) {\n    return poly2(-f.a,f.h);\n}\n\n// {a0 a1 a2} * {b0 b1 b2}\n// = {a0*b0 (a0*b1 + a1*b0) (a0*b2 + a2*b0 + a1*b1) (a1*b2 + a2*b1) (a2*b2)}\n// the two new coefficients are truncated, so only linear\n// functions are going to work here reliably.\npoly2 pa_mul(poly2 f, poly2 g) {    \n    return poly2(vec3(\n    \tf.a[0] * g.a[0],\n\t    f.a[0] * g.a[1] + f.a[1] * g.a[0],\n        f.a[0] * g.a[2] + f.a[1] * g.a[1] + f.a[2] * g.a[0]\n        //f.a[1] * g.a[2] + f.a[2] * g.a[1],\n        //f.a[2] * g.a[2]\n        ), f.h);\n}\npoly2 pa_mul(poly2 f, float c) {\n    return poly2(f.a * c,f.h);\n}\npoly2 pa_mul(float c, poly2 f) {\n    return poly2(f.a * c,f.h);\n}\n\n// the two new coefficients are truncated, so only linear\n// functions are going to work here reliably.\npoly2 pa_pow2(poly2 f) {\n    return poly2(vec3(\n    \tf.a[0] * f.a[0],\n\t    2.0 * f.a[0] * f.a[1],\n        2.0 * f.a[0] * f.a[2] + f.a[1] * f.a[1]\n        //2.0 * f.a[1] * f.a[2],\n        //f.a[2] * f.a[2]\n        ), f.h);\n}\n\n// returns f(x), f'(x), f''(x)\nvec3 pa_f(vec3 a, float x) {\n    return vec3(\n        a[0] + (a[1] +       a[2] * x) * x,\n                a[1] + 2.0 * a[2] * x,\n                             a[2]);\n}\n\nfloat solve_quadratic(vec3 fa, float x) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        float q0 = k - q;\n        float q1 = k + q;\n        \n        // pick the root right of x\n\t\treturn (q0 <= x)?q1:q0;\n    }\n}\n\nfloat solve_quadratic0(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return -c / b;\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = -0.5*b/a;\n        float q = sqrt(k*k - c/a);\n        // pick the closest root right of 0\n\t\treturn k + ((k <= q)?q:-q);\n    }\n}\n\nvec2 solve_quadratic2(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    // the quadratic solve doesn't work for a=0\n    // so we need a branch here.\n    if (a == 0.0) {\n        return vec2(-c / b);\n    } else { \n        // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n        float k = 0.5*b/a;\n        float q = sqrt(k*k - c/a);\n\t\treturn vec2(-k, q);\n    }\n}\n\nfloat solve_quadratic(poly2 f) {\n    return solve_quadratic0(f.a);\n}\n\n// returns the x position of the next root, where f(x) = 0\nfloat nextroot(poly2 f) {\n    return solve_quadratic(f);\n}\n\n// returns the position of the next event (root or start of new segment)\nfloat nextevent(poly2 f) {\n    float s = nextroot(f);\n    float h = (f.h <= 0.0)?infinity:f.h;\n    s = (s <= 0.0)?h:min(s,h);\n    return s;\n}\n\nfloat axis(poly2 f) {\n    return nextevent(f);\n}\n\nfloat pa_sign(poly2 f) {\n    return ((f.a[0] < 0.0)?-1.0:1.0);\n}\n\n// signed pow2; this is for transforming linear distance functions\n// to quadratic ones so they compare correctly against spherical functions\n// the position of the root is not altered\npoly2 pa_spow2(poly2 f) {\n    return pa_mul(pa_pow2(f), pa_sign(f));\n}\n\npoly2 pa_abs(poly2 f) {\n    float s = pa_sign(f);\n    \n    f.h = axis(f);    \n    \n    return poly2(f.a * s, f.h);\n}\n\npoly2 pa_const(float c) {\n    return poly2(vec3(c,0.0,0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b) {\n    float a1 = (a.y - b.y)/(a.x - b.x);\n\tfloat a0 = a.y - a1*a.x;\n    return poly2(vec3(a0, a1, 0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b, float k) {\n    float a2 = 0.5*k;\n    float aa2 = a2*a.x*a.x;\n    float a1 = (a.y - b.y + a2*b.x*b.x - aa2) / (a.x - b.x);\n    float a0 = a.y - a1*a.x - aa2;\n    return poly2(vec3(a0, a1, a2), infinity);\n}\n\npoly2 pa_min(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n}\n\npoly2 pa_max(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx > gx)?f.a:g.a, h);\n    \n}\n\n// the output can only be subject to more comparisons, but must not\n// be transformed further.\npoly2 pa_hardmin(poly2 f, poly2 g) {\n#ifdef USE_HARDMIN\n    float fe = nextevent(f);\n    float ge = nextevent(g);    \n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    bool fi = (fx < 0.0);\n    bool gi = (gx < 0.0);\n    // both outside\n    if (!fi && !gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    // both inside\n    } else if (fi && gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    } else {\n        return poly2((fx < gx)?f.a:g.a, h);\n    }    \n#else\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n#endif\n}\n\n// the output can only be subject to more comparisons, but must not\n// be transformed further.\npoly2 pa_hardmax(poly2 f, poly2 g) {\n    return pa_unm(pa_hardmin(pa_unm(f),pa_unm(g)));\n}\n\n// can only be used once on flat surfaces reliably\n// appears to still work with more complex functions?\npoly2 pa_smin(poly2 a, poly2 b, float r) {\n    poly2 e = pa_min(\n        pa_max(\n            pa_add(\n                pa_unm(\n                    pa_abs(\n                        pa_sub(a, b))), r),\n            pa_const(0.0)),pa_const(r));\n    return pa_sub(pa_min(a, b), pa_mul(pa_pow2(e), 0.25 / r));\n}\n\npoly2 pa_smax(poly2 a, poly2 b, float r) {\n    return pa_unm(pa_smin(pa_unm(a),pa_unm(b),r));\n}\n\n// approximates blend with a quadratic patch, but\n// very buggy. avoid.\npoly2 pa_smin2(poly2 a, poly2 b, float r) {\n    float h = solve_quadratic0(pa_sub(a, b).a);\n    float x0 = h - r;\n    float x1 = h + r;\n    if (0.0 < x0) {\n        a.h = x0;\n        return a;\n    } else if (0.0 >= x1) {\n        return b;\n    } else {\n        vec3 ay0 = pa_f(a.a, x0);\n        vec3 by0 = pa_f(b.a, x0);\n        vec3 ay1 = pa_f(a.a, x1);\n        vec3 by1 = pa_f(b.a, x1);\n        vec3 y0 = (ay0.x < by0.x)?ay0:by0;\n        vec3 y1 = (ay1.x < by1.x)?ay1:by1;\n        poly2 m = pa_ipol(vec2(x0, y0.x), vec2(x1, y1.x), (y1.y - y0.y) / (x1 - x0));\n        m.h = x1;\n    \treturn m;\n    }\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius\n/*\nDAValue sdSuperprim(DAVec3 p, vec4 s, vec2 r) {\n    DAValue dx = da_sub(da_abs(p.x),s.x);\n    DAValue dy = da_sub(da_abs(p.y),s.y);\n    DAValue dz = da_sub(da_abs(p.z),s.z);\n    DAValue q = \n       \tda_sub(\n            da_abs(\n                da_add(\n                    da_add(\n                        da_length(\n                            da_max(da_add(dx, r.x), 0.0),\n                            da_max(da_add(dy, r.x), 0.0)),\n                  \t\tda_min(-r.x,da_max(dx,dy))),\n                    s.w)), \n                s.w);\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n*/\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n/////////////////////////////////////////////////////////\n\nvoid paint();\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//////////////////////////////////////////////////////////\n\n\n#define RO -1.5\n\nvec3 ro;\nvec3 rd;\n\npoly2 sphere(poly2 x, poly2 y, poly2 z, float r) {\n    return pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(y)),pa_pow2(z)), r*r);\n}\n\npoly2 ellipsoid(poly2 x, poly2 y, poly2 z, vec3 r) {\n    poly2 ex = pa_pow2(pa_mul(x, 1.0/r.x));\n    poly2 ey = pa_pow2(pa_mul(y, 1.0/r.y));\n    poly2 ez = pa_pow2(pa_mul(z, 1.0/r.z));\n    return pa_sub(pa_add(pa_add(ex,ey),ez), 1.0);\n}\n\npoly2 cube(poly2 x, poly2 y, poly2 z, float r) {\n#if 1\n\treturn pa_sub(pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z)),r);\n#else\n    poly2 d = pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z));\n    return pa_sub(pa_spow2(d),r * r);\n#endif\n}\n\npoly2 plane(poly2 x, poly2 y, poly2 z, vec4 n) {\n#if 1\n\treturn pa_sub(pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z)),n.w);\n#else\n    poly2 d = pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z));\n    return pa_sub(pa_spow2(d),n.w * n.w * sign(n.w));    \n#endif\n}\n\n/*\n// not really a cone - todo :|\npoly2 cone(poly2 x, poly2 y, poly2 z, vec2 a, float l) {\n    return pa_max(\n        pa_add(pa_mul(pa_add(pa_pow2(x),pa_pow2(y)),a.x),\n               pa_mul(a.y, z)),z);\n}\n*/\n\nvoid rotate(poly2 x, poly2 y, out poly2 rx, out poly2 ry, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    rx = pa_sub(pa_mul(x,c),pa_mul(y,s));    \n    ry = pa_add(pa_mul(x,s),pa_mul(y,c));\n}\n\npoly2 pa_map(poly2 x, poly2 y, poly2 z) {\n\tpoly2 w = plane(x, y, z, vec4(0.0,0.0,1.0,-0.6));\n    poly2 vz = pa_sub(z,sin(iTime*0.3)*0.4);\n\tpoly2 s = sphere(pa_sub(x,1.0),y,vz, 0.5);\n\tpoly2 s2 = sphere(pa_sub(x,0.65),y,vz, 0.3);\n\t//poly2 c = cone(pa_sub(x,-0.5),y,pa_sub(z,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n    poly2 rx, rz;\n    rotate(pa_sub(x,-0.5),pa_sub(z,-0.5),rx,rz,iTime*0.5);\n    poly2 c = ellipsoid(rx,y,rz,vec3(0.2,0.5,0.5));\n    poly2 cb = cube(rx,y,pa_add(rz,-0.5),0.2);\n    \n    poly2 d = w;\n    poly2 g = pa_hardmax(s,pa_unm(s2));\n    d = pa_smin(d, cb, 0.1);    \n    d = pa_hardmin(d,g);\n    d = pa_hardmin(d, c);    \n    \n\treturn d;\n}\n\npoly2 pa_map(vec3 ro, vec3 rd, float t) {\n    poly2 dt = pa_init(t);\n    poly2 x = pa_add(ro.x, pa_mul(rd.x, dt));\n    poly2 y = pa_add(ro.y, pa_mul(rd.y, dt));\n    poly2 z = pa_add(ro.z, pa_mul(rd.z, dt));\n    return pa_map(x,y,z);    \n}\n\n// how to convert pa_map to a classic map function\n// t is the ray scalar\n// returns function value at that point, and distance\n// to next root or horizon\nvec3 map(vec3 ro, vec3 rd, float t) {\n    poly2 f = pa_map(ro, rd, t);\n    return vec3(f.a[0], nextevent(f), f.a[1]);\n}\n\n// for a 3d gradient, three map calls suffice\nvec3 grad(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n    poly2 dx = pa_map(p - d.yxx, d.yxx, 2.0);\n    poly2 dy = pa_map(p - d.xyx, d.xyx, 2.0);\n    poly2 dz = pa_map(p - d.xxy, d.xxy, 2.0);\n    // second coefficient contains first derivative\n    return vec3(dx.a[1],dy.a[1],dz.a[1]) / 1e-3;\n}\n\nvec2 dist(vec3 p) {\n    poly2 d = pa_map(pa_const(p.x),pa_const(p.y),pa_const(p.z));\n    return vec2(d.a[0] / length(grad(p)),d.a[0]);\n}\n\nvec2 grad2d(vec3 p) {\n    return normalize(grad(p).xz);\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat rayf(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[0];\n}\n\nfloat rayff(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[1];\n}\n\nfloat rayfff(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[2];\n}\n\nfloat raynextroot(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);    \n    return nextroot(f);\n}\n\nfloat rayhorizon(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);    \n    return f.h;\n}\n\nfloat itercount(float maxt) {\n\tfloat precis = 0.01;\n\tfloat h = infinity;\n\tfloat t = 0.01;\n    float steps = 0.0;\n\tfor(int i = 0; i < 32; i++) {\n\t\tif(h <= precis)\n            return 0.0;\n        if (t > maxt) break;\n        steps += 1.0;\n\t\tvec3 p = ro+rd*t;\n        vec3 d = map(ro, rd, t);\n        float w = t + d.y;\n        h = abs(d.x);\n\t\tt = w + 0.001;\n\t}    \n    return steps;\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue(float n) {\n    return hue(0.66667 * (1.0 - clamp(n,0.0,1.0)));\n}\n        \nvoid paint() {\n\tvec2 ms = ((iMouse.xy/iResolution.xy)*2.0-1.0) * aspect;\n\t\n    ro = vec3(RO,0.0,0.0);\n\n    // clear screen\n\t\n    vec3 tp = vec3(position.x,0.0,position.y);\n    rd = normalize(tp - ro);\n\t\n    float ic = itercount(length(tp - ro));\n    \n    set_source_rgb(normhue(ic/10.0)*0.5);\n\tclear();\n\n\tset_line_width_px(1.3);\n\t\n    vec2 dd = dist(tp);\n\t_stack.shape.x = dd.x;\n\tset_source_rgb(hsl(0.6, 1.0, 0.7));\n\tstroke_preserve();\n\tset_source_rgba(hsl(0.6, 1.0, 0.7,0.5));\n\tfill();\n\t\n\tset_line_width_px(1.3);\n\tfor (int i = 0; i < 5; ++i) {\n        float qd = float(i)*0.2;\n\t\t_stack.shape.x = dd.y-qd;\n\t\tstroke();\n\t}\n\n\tset_source_rgb(vec3(1.0));\n\tset_line_width_px(1.3);\n\n\trd = normalize(vec3(ms.x, 0.0, ms.y) - ro);\n\t\n\tcircle(ro.xz, 0.02);\n\tfill();\n\n\tfloat maxt = 5.0;\n    \n\tfloat precis = 0.01;\n\tfloat h = infinity;\n\tfloat t = 0.01;\n\tfor(int i = 0; i < 32; i++) {\n\t\tif(h <= precis || t > maxt) continue;\n\t\tset_source_rgb(hsl(float(i)/32.0, 1.0, 0.5));\n\t\tvec3 p = ro+rd*t;\n        vec3 d = map(ro, rd, t);\n        float ts = t + RO;\n        float w = t + d.y;\n        h = abs(d.x);\n        move_to(ts, 0.0);\n        line_to(ts, d.x);\n        line_to(ts + d.y, 0.0);\n        stroke();\n\t\tif (h <= precis) {\n            circle(ts, 0.0, 0.03);\n            fill();\n            continue;\n        }\n\t\tmove_to(p.xz);\n\t\tt = w + 0.001;\n\t\tline_to((ro+rd*t).xz);\n\t\tstroke();\n\t}\n\t\n\t// arrow\n    if (h <= precis) {\n        vec3 p = (ro+rd*t);\n        vec2 n = grad2d(p);\n        vec2 o = vec2(n.y, -n.x);\n        set_source_rgb(vec3(1.0));\t\n        arrow(p.xz, n*0.1);\n\t\tstroke();\n    }\n    \n    // \n\tset_source_rgba(vec4(0.0,0.0,0.0,0.5));\n\tclear();\n    \n    // draw zero crossing\n    move_to(-2.0,0.0);\n    line_to(2.0,0.0);\n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0,0.0,0.0));\n    stroke();\n\n    #ifdef DEBUG_VIZ\n\n    // draw 1D graph of estimated distance to horizon\n    graph1D(rayhorizon);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0,0.0,1.0));\n    stroke();    \n\n    // draw 1D graph of estimated distance to root\n    graph1D(raynextroot);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(0.0,1.0,1.0));\n    stroke();    \n\n    // draw 1D graph of second derivative\n    graph1D(rayfff);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(0.5,1.0,0.0));\n    stroke();    \n\n    // draw 1D graph of first derivative\n    graph1D(rayff);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0,1.0,0.0));\n    stroke();    \n    \n    #endif\n\n    // draw 1D graph of ray distances\n    graph1D(rayf);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0));\n    stroke();    \n    \n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}