{
    "Shader": {
        "info": {
            "date": "1673467993",
            "description": "Used my Rough Seas shader and added a cabin porthole, underwater effects, foam and distortion.\nIncludes GPU Audio - rewind ‚è™ the shader if it's not playing.\nThe light dims when underwater, to give the impression of other portholes.\n",
            "flags": 8,
            "hasliked": 0,
            "id": "DtBGWW",
            "likes": 109,
            "name": "Rough Seas Porthole",
            "published": 3,
            "tags": [
                "3d",
                "waves",
                "raymarch",
                "sound",
                "sea",
                "water",
                "ocean",
                "foam",
                "rough",
                "spray",
                "porthole"
            ],
            "usePreview": 1,
            "username": "Dave_Hoskins",
            "viewed": 1841
        },
        "renderpass": [
            {
                "code": "// Rough Seas Porthole üåä, by Dave Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2023.\n\n// This shader is  https://www.shadertoy.com/view/DtBGWW\n// Forked from     https://www.shadertoy.com/view/dtXGW4\n// Used my Rough Seas shader and added a cabin porthole, underwater effects, foam and distortion.\n\n// Inspiration was from: https://www.istockphoto.com/search/more-like-this/882229368?assettype=film&phrase=rough%20sea\n\n\n#define FAR 1400.\n#define FOG_COLOUR vec3(.33,.31,.3)\n#define SKY_TOP vec3(.1, .13, 0.13)\n#define FOAM_COLOUR vec3(.51,.55,.6)\n#define PI 3.141592653\n#define ZERO min(iFrame, 0)\n\n\nvec3 camPos;\nfloat time;\nvec3 surf;\nvec3 skyColour;\nconst vec3 sunDir = normalize(vec3(4,8,18));\n//#define EXPORT_VERSON\n\n//------------------------------------------------------------------------------\n\n// Hashes from here:\n// https://www.shadertoy.com/view/XdGfRR\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12i(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash22i(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash13i(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash33i(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// Smoothed noise overridden as 2D & 3D...\n//------------------------------------------------------------------------------\nfloat noise(in vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float res = mix(mix(hash12i(p),\n\t\t\t\t\t\thash12i(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(hash12i(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\thash12i(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 p)\n{\n    const vec2 add = vec2(1.0, 0.0);\n\n    vec3 f = fract(p); \n    f *= f * (3.0-2.0*f);\n    p = floor(p);\n\n    float h = mix(\n                    mix(mix(hash13i(p), hash13i (p + add.xyy),f.x),\n                        mix(hash13i(p + add.yxy), hash13i(p + add.xxy),f.x), f.y),\n                    mix(mix(hash13i(p + add.yyx), hash13i(p + add.xyx),f.x),\n                        mix(hash13i(p + add.yxx), hash13i(p + add.xxx),f.x), f.y),\n                 f.z);\n    return h*h*h*2.;\n}\n\n//-----------------------------------------------------------------\nconst float COSR = cos(.43);\nconst float SINR = sin(.52);\nconst mat2 rot2D = mat2(COSR, SINR, -SINR, COSR) * 1.4;\nfloat fbm(in vec2 p)\n{\n    float a = 1.;\n    float y = 0.0;\n    for (int i = ZERO; i< 5; i++)\n    {\n        y += noise(p) * a;\n        a *= .53;\n        p *= rot2D;\n        p.y += 9.1;\n    }\n    return y;\n}\n\n//------------------------------------------------------------------------------\n// A very basic sky...\nvec3 sky(in vec3 p, in vec3 dir)\n{\n    dir.y+=.02;\n    \n    dir.y = max(dir.y,0.001);\n    float d = 20.0/dir.y;\n    p = p + dir * d;\n    vec3 s = vec3(fbm(p.xz*.06))*.2;\n    s*=s;\n    s = mix(s, FOG_COLOUR, max(1.-dir.y*3.,0.0));\n    return mix(s, SKY_TOP ,abs(dir.y)*2.);\n    //return s;\n    \n}\n\n//-----------------------------------------------------------------\n// This creates the sea, it's complexity is governed by the incoming iteration count...\n\nfloat oceanFundamental(in vec2 p, const in float tim, const in float iter)\n{\n    float a =noise(p*.01)*8.+3.0;\n    float h = 0.0;\n    float it = 1./iter;\n    float spr = 0.0;\n\n    p *= .035;// ...Scale it\n\n    for (float i = min(iTime,0.0); i <= 1.0; i += it)\n    {\n        float t = (1.08-i) * tim;\n        float r =noise(p*2.33+t) * i;\n        vec2 y1 = (cos(p-t)+1.0);\n        vec2 y2 = (1.0-abs(sin(p-t)));\n        \n        y1 = mix(y1, y2, r);\n          \n        float s = y1.x + y1.y;\n        \n        h += s*a;\n        \n        a *= .54;\n        p = p * rot2D;\n        \n        p += 37.7;\n    }\n\n    return h;\n}\n\n//-----------------------------------------------------------------\nfloat fbm(in vec3 p)\n{\n    float a = 1.;\n    float y = 0.0;\n    for (int i = ZERO; i< 5; i++)\n    {\n        y += noise(p) * a;\n\n        a *= .53;\n        p.xz *= rot2D;\n        p.y += 9.1;\n    }\n    return y;\n}\n\n// Do a warped multi FBM...\nfloat multiFbm(in vec3 p)\n{\n/*\n    float f = 0.0;\n    f = fbm(p*.87);\n    f = fbm(p + f);\n    f = fbm(p*.5 + f*.4);\n*/\n    // Thanks for shortening the code, iq, it looks mad but it's certaining faster compiling on Windows ANGLE machines.\n    float f = 0.0;\n    const vec3 fre = vec3(0.87,1.0,0.5);\n    const vec3 off = vec3(0.0 ,1.0,0.4);\n    for( int i=0; i<3; i++ )\n    {\n        f = fbm(p*fre[i] + f*off[i]);\n    }\n \n    return f;\n}\n\n// Map the ocean relative to the point...\n//-----------------------------------------------------------------\nfloat map(const in vec3 p, const float iter)\n{\n    float h = oceanFundamental(p.xz, time, iter);\n    return p.y-h;\n}\n \n// March across the sea...\n//-----------------------------------------------------------------\nvec2 rayMarchSea(in vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    float spr = 0.0;\n    for ( int i = ZERO; i < 100 && d < FAR; i++)\n    {\n        vec3 pos = p + dir*d;\n\n        float hh = oceanFundamental(pos.xz, time, 8.);\n        float h = pos.y-hh;\n        \n        if (h < .2)\n        {\n            break;\n        }\n        float wind = (noise(pos*.03)) * fbm(pos*2.+vec3(-time*12., time*.11,0));\n        spr += max(25.-h, 0.0) * smoothstep(40.0, .0,max(h, 0.0))*smoothstep(FAR, 0.0,d)*smoothstep(30., 80.0, hh)\n        * wind;\n        d+= h*.7;\n    }\n    return vec2(d, min(spr*.03, 1.0));\n}\n\n\n\n//==============================================================================\n#define FARCAB 100.0\n//------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n#define rotate(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec2 nutCut(in vec2 p, float s)\n{\n    float k = s / PI / 2.;\n    return rotate(p, floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\nfloat nut(vec3 p, vec3 size, float r)\n{\n    rotate(p.xy,r);\n    p.xy = nutCut(p.xy, 6.0);\n\n    // Now rounded box has 6 sides..\n    float t = roundedBox(p, size,.08);\n    t = min( t, length(p+vec3(0,0,.2))- size.x );\n\n    return t;\n}\n\n//------------------------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions/\nfloat length6( vec2 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y,1.0/6.); }\n// Distance to a squarish torus..\nfloat sdTorusFlat(vec3 p, vec2 t)\n{\n  float x = length(p.xy)-t.x;\n  return length6(vec2(x,p.z))-t.y;\n}\n\n//------------------------------------------------------------------------------\n// Min/max functions with material swap...\nvec2 maxV2(in vec2 v1, in vec2 v2)\n{\n    return (v2.x > v1.x) ? v2:v1;\n}\n    \nvec2 minV2(in vec2 v1, in vec2 v2)\n{\n   return (v2.x < v1.x) ? v2:v1;\n}\n\n//------------------------------------------------------------------------------\nvec2 mapCab(in vec3 p)\n{\n    // Do porthole rim as a flattened tourus...\n    vec2 d = vec2(sdTorusFlat(p-vec3(0,0,.4), vec2(9.1,1.1)), 0);\n    // Back wall...\n    d = minV2(d, vec2(.0-p.z, 2.0));\n    // Do the nuts as a mirrored configuration...\n    p.xy = abs(p.xy);\n    d = minV2(d, vec2(nut(p - vec3(6.2, 6.5, -.8),vec3(.15, .15, .12), .5), 1.0));\n    d = minV2(d, vec2(nut(p - vec3(8.9,.0,-.8),   vec3(.15, .15, .12), 0.0), 1.));\n\n    return d;\n}\n\n//------------------------------------------------------------------------------\n//Sped up for ANGLE with example from iq:  //https://www.shadertoy.com/view/3lsSzf\nvec3 normalCab(const in vec3 pos, float ds)\n{\n    ds *= .5/iResolution.y;\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapCab(pos+ds*e).x;\n    }\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\nfloat shadowCab(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .01;\n    for( int i = ZERO; i < 10; i++ )\n    {\n\t\tfloat h = mapCab(ro + rd*t).x;\n\n        res = min( res, 4.*h/t );\n        t += h;\n        if (res < .1) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n//------------------------------------------------------------------------------\nvec3 lightCab(in vec3 pos, const in vec3 nor,  const in vec3 dir, const in vec4 mat, const in float wat)\n{\n    vec3 lamp = vec3((noise(vec2(time*.5))-.5)*30.,wat*.2,-15);\n\n    vec3 ldir = normalize(lamp-pos);\n    float a = smoothstep(-10.0, 4.0, wat)*.3+.05;\n    float sha = shadowCab(pos, ldir);\n    vec3 col = mat.xyz * max(dot(nor, ldir), 0.0)*4.*a*sha;\n    vec3 ref = reflect(dir, nor);\n    col += vec3(1.,.8, .7) * pow(max(dot(ref, ldir), 0.0), 2.0) * mat.w * sha;\n    return min(col, 1.0);\n} \n\n//------------------------------------------------------------------------------\nvec2 marchCabin(const in vec3 ro, const in vec3 rd)\n{\n    vec2 d = vec2(0);\n    for (int i = ZERO; i < 30 && d.x < FARCAB; i++)\n    {\n        vec3 p = ro+rd*d.x;\n        vec2 m = mapCab(p);\n        d.y = m.y;\n        if ((m.x) < .05 ||  d.x > FARCAB) break;\n        d += m.x*.8;\n        \n\n    }\n    return d;\n}\n\n//==============================================================================\n\n//------------------------------------------------------------------------------\n// Get a view ray of pixel using Euler...not a flat projection...\nmat3 viewMat ( const in float ay, const in float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//------------------------------------------------------------------------------\n\n// Sped up for ANGLE with example from iq:  //https://www.shadertoy.com/view/3lsSzf\n// Uses a higher iteration cound for details...\nvec3 normal(const in vec3 pos, in float ds)\n{\n    ds *= 1./iResolution.y;\n    ds = max(ds*ds, .1);\n                          \n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+ds*e, 14.0);\n    }\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// Super fast water caustic...\n// https://www.shadertoy.com/view/MdKXDm\n#define F length(.5-fract(k.xyw*=mat3(-2,-1,2, 3,-2,1, 1,2,2)*\nfloat waterPattern(vec2 p)\n{\n    vec4 k;\n    k.xy = p*(sin(k).w+2.)*.009;\n    return pow(min(min(F.5)),F.4))),F.3))), 7.)*20.;\n}\n\n//------------------------------------------------------------------------------\n// Juggled for just artistic reasons...\nfloat waveDepth(const in vec3 p, const in vec3 dir)\n{\n    float d = 0.0;\n    for( float i = min(time,3.0); i <= 23.0; i+=5.)\n    {\n        float h = map(p + dir*i, 8.);\n        if (h > 0.) break;\n        d += -h;\n    }\n    return clamp(1.0-d*.02, 0.0, 1.0);\n}\n\n// Standard lighting...\n//------------------------------------------------------------------------------\nvec3 lighting(const in vec3 pos, const in vec3 nor, const in vec3 dir, const in vec3 mat)\n{\n    vec3 col;\n    col = mat * max(dot(sunDir, nor), 0.0);\n    vec3 ref = reflect(dir, nor);\n    float fres = clamp(pow( 1.+dot(nor, dir), 7. ), 0.0, 1.0)*.6;\n\n    col = mix(col, sky(pos, nor), .3);\n    col = mix(col, sky(pos, ref), fres);\n    return col;\n}\n\n\n// Get the sea colour...\n//------------------------------------------------------------------------------\nvec3 diffuse(in vec3 pos, in vec3 nor, in float dep)\n{\n    pos.x -= time*1.3;\n    vec3 mat = vec3(.1,.1,.12);\n    float h = smoothstep(0., 1.0,nor.y);\n    \n    mat += h*.1;\n\n    mat = mix(mat, vec3(.3,.7,.7), dep);\n    pos.x += time * 4.;\n    pos*=3.5;\n     \n\n    // Add different frequencies of voronoi cells...\n    float ny = clamp(nor.y, 0.4, 1.0);\n    float foam = waterPattern(pos.xz +pos.y*.3) * 3.;\n    foam += waterPattern(pos.xz*.37)*5.;\n    foam = clamp(foam, 0.0, 1.0);\n    mat = mat+foam * (dep*dep*1.5+ny*.01);\n    return mat;\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat distanceRayPoint( const in vec3 ro, const in vec3 rd, in vec3 p)\n{\n    p -= ro;\n    float h = dot(p,rd);\n    return length(p-rd*h);\n}\n\n#define tri(x) abs(fract(x)-.5)*2.\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getOffset(const in vec3 id)\n{\n    return tri(id+time*.5);\n}\n\nvec3 getColour(const in vec2 id)\n{\n    float t1 = id.x*.4;\n    float t2 = id.y*.4;\n    return vec3(.75,.6+t1, .6+t2);\n}\n\n//----------------------------------------------------------------------------------------------------------\n#define BUBBLES 65\n#define BUBBLE_SIZE 50.0\n// I believe I was inspired by iapafoto, who does the same here:\n// https://www.shadertoy.com/view/Xl2BRR\nvec3 bubbles(in vec3 ro, const in vec3 rd)\n{ \n    float d;\n    \n    ro *= .00002;\n    ro.x+=time*5.;\n    float fade = 1.0;\n    \n\tvec3 pos = floor(ro),\n         ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + 0.5 +rs*.5) * ri,\n         sum = vec3(0), col = sum;\n\tfor( int i = ZERO; i < BUBBLES; i++ )\n    {\n        vec3 id = hash33i(pos*19.31);\n        float si = (id.x+id.z)*.25+.08;\n        vec3 offset = getOffset(id);\n        d = distanceRayPoint(ro, rd, pos+offset);\n        vec3 mat =  getColour(id.xy);\n        col = mat * pow(smoothstep(si, 0.0,d),8.)*10. *fade;\n        sum += col;\n        fade*= .98;\n\t\tvec3 mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum;\n}\n\n//------------------------------------------------------------------------------\n// Exponential fader...\nfloat fader(const in float edge0, const in float edge1, const in float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\n// Surface foam.\nvoid surfFoam(const in vec3 p, const in float water)\n{\n     float w = -(water-4.0)*pow(multiFbm(p*2.+vec3(0, time*8., time*4.)), 2.0)*.5;\n     surf += FOAM_COLOUR*fbm(camPos*8.3+vec3(0,0,time*6.))* .35 * w;\n     surf *= FOAM_COLOUR*smoothstep(-10.,1.0, water);\n}\n\n//------------------------------------------------------------------------------\n// Get p's position in water at time ti.\nfloat underWaterAtTime(const in vec3 p,  const in float ti)\n{\n    float h = oceanFundamental(p.xz, ti, 8.0)+multiFbm(camPos*5.3+ti*7.);\n     \n    return p.y-h-4.;\n}\n\n\n// Get the camera at time ti\nvec3 cameraLocation(const in float ti)\n{\n     vec3 p = vec3(ti*10.,100,0);\n     float h = (sin(ti*.65)+1.0)*40. + (sin(ti*1.37))*10. + 20.;\n     p.y = h;\n        \n     // Don't spend too long in the water?..\n//     float w = (map(p, 8.0));\n//     if (w < 0.0) p.y  += w*w*.04;\n     return p;\n}\n\n// Do a bump map of sorts...\nvec3 bumpmap(in vec3 p, in vec3 dir, in float a)\n{\n    p *= 5.;\n    float v0 = multiFbm(p);\n    float v1 = multiFbm(p+vec3(.1,0.,0));\n    float v2 = multiFbm(p+vec3(0,0.,.1));\n    vec3 grad = normalize(vec3(v1-v0, 0.0, v2-v0));\n    grad -= dir*dot(dir, grad);          \n\n    \n    return normalize( dir + grad*a );\n}\n \n//------------------------------------------------------------------------------\n// Grab the vec4 diffuse texture with specular in .w...\n// You can also adjust the normal here..\nvec4 getMaterial(const in int id, const in vec3 p, inout vec3 nor)\n{\n    vec4 col = vec4(0);\n    vec2 bn = vec2(0.0);\n    float d = 0.0;\n    switch (id)\n    {\n        case 0: // Porthole rim...\n            col = vec4(.1, .07, .04, .5);\n            col = col*(.6+.4*multiFbm(p*5.+30.));\n            col.w = col.w*col.w*multiFbm(p*3.);\n            bn = vec2(3.0,0.08);\n            break;\n        case 1: // Nuts\n            col = vec4(.05, .05, .06, .3);\n            col.w = col.w*(.4+.6*multiFbm(p*21.));\n            break;\n        case 2: // Backwall.\n        \n            col = texture(iChannel0, p.xy*.15) * vec4(.6,1.2,15.,1.);\n            vec2 uv = fract(-p.xy*.15);\n            col *= smoothstep(0.0, .05, uv.y)*smoothstep(1., .95, uv.y)+.1;\n            col *= vec4(.1,.05,.01,.1);\n            col.w = pow(col.x*10., 5.);\n//            Metal...\n//            col = vec4(.0, .01, multiFbm(p*.5-300.)*0.02, .2 );\n//            float f = multiFbm(p+999.);\n//            col = mix(col, col, smoothstep(.5, .52, f));\n//            bn = vec2(4.,0.1);\n//            col =mix(col, vec4(0.03, 0.01,0,.1), (max(fbm(p*1.53)-0.2,0.))*.2);\n            break;\n    }    \n    nor = bumpmap(p * bn.x, nor, bn.y);\n    return col;\n}\n\n\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 outCol, in vec2 coord )\n{\n    // Take into account non-square viewport to keep aspect ratio of shapes..\n    // Zero in centre and .5 at the max Ys\n    vec2 uv = (coord-iResolution.xy*.5)/iResolution.y;\n\n    time = iTime+232.;\n    uv*= .8+sin(clamp(iTime*.5-0.3, 0.,3.5))*.3;\n    // Reset colours...\n    vec3 colour = vec3(0);\n    surf = vec3(0.0);\n    // Make simple camera shade with uv movements...\n    vec2 shake = vec2(noise(vec2(time*.6))-.5, noise(vec2(time*.7+233.))-.5) * vec2(.1, .1);\n    uv += shake;\n    \n    camPos = cameraLocation(time);\n    float porthole = length(uv)*2.;\n    \n    // Don't do things unnecessarily layered, only render sea in porthole...\n    if (porthole < 1.0)\n    {\n        // Camera...\n        // We need to start the ray from the porthole, because a single camera point will all go underwater at the same time,\n        // and it needs to have the window wash effect.\n        camPos.xy += uv*10.;\n\n        vec3 dir  = vec3(0,0, 1.);\n        dir = viewMat (uv.y +.0, uv.x+.5) * dir;\n        // Simmulate pitching of the boat....\n        rotate(dir.zy, (sin(time*.5)*sin(time*.37)*.6));\n        \n        float water = (underWaterAtTime(camPos, time));\n        \n        if(water < 4.0) //...Minus values under water\n        {\n            \n            // Tint water colour to green sea...\n            colour  = mix(FOAM_COLOUR, vec3(.0, .04,.03),clamp(pow(-(water-4.0), .4)*.3, 0.0, 1.0));\n            // With a deeper blue...\n            colour  = mix(colour, vec3(.0, .0,.02),clamp((-3.0-water)*.015, 0.0, 1.0));\n            // Top white foam band..\n            colour  = mix(colour, FOAM_COLOUR,clamp(2.-(water*water*.4)*multiFbm(camPos*3.3), 0.0, 1.0));\n            \n            // Do 2D surf Foam...\n            surfFoam(camPos, water);\n            \n            // If under water, do bubbles...\n            if (water < .0) surf += bubbles(camPos*25000., dir)*.3*clamp(4.0+water*.1,0.1, 3.0)*.03;\n        }\n        if (water >= 0.)\n        {\n            // Get camera location from 1 second ago, so the disorted drips appear after a water wipe...\n            vec3 p = cameraLocation(time-1.);\n\n            float past = underWaterAtTime(p, time-1.); // ...Did we go underwater a second ago?\n            // Determine an amount of water distortion...\n            float f = smoothstep(25.0, -8.0, past)*.15;\n            // Make the distortion less as we go down the screen...\n            float w = smoothstep(.6, -.3, uv.y);\n            f = f*f*3. * w;\n            float d =0.0;\n            if (f > 0.0)\n            {\n                dir = bumpmap(vec3(uv.x,time*.5,uv.y*.5), dir, f);\n            }\n\n            // March the sea\n            vec2 dis = rayMarchSea(camPos, dir);\n            if (dis.x < FAR)\n            {\n                // The position is the start position plus the normalised direction X distance...\n                vec3  pos = camPos + dir * dis.x; // ...wave hit position\n                vec3  nor = normal(pos, dis.x);   // ... Normal\n                 // The depth of the wave in forward direction, it's simple but effective in helping the water transparent effect...\n                float dep = waveDepth(pos, dir);\n                vec3  mat = diffuse(pos, nor, dep);\n                \n                colour = lighting(pos, nor, dir, mat);\n                colour = mix(FOG_COLOUR, colour, exp(-dis.x*.001));\n            }else\n            {\n                colour = sky(camPos, dir);\n            }\n\n           colour = mix(colour, FOAM_COLOUR, dis.y);\n\n            \n         }\n    }else \n    {   // Everything outside the portal...\n        float water = (underWaterAtTime(camPos, time));\n     \n        vec3 dir  = vec3(0,0, 1.);\n        dir = viewMat (uv.y, uv.x) * dir;\n        camPos = vec3(0,0,-15);\n        vec2 dis = marchCabin(camPos, dir);\n        if (dis.x < FARCAB)\n        {\n            vec3 pos = camPos + dir * dis.x;\n            vec3 nor = normalCab(pos, dis.x);\n            int matID = int(dis.y);\n            vec4 mat = getMaterial(matID, pos, nor);\n            colour = lightCab(pos, nor, dir, mat, water);\n        }\n    }\n    colour += surf;\n\n    if (porthole < 1.0) colour = mix(colour, colour*.1, smoothstep(0.9, 1.,porthole));\n    \n    // Some adjustment..\n    colour = clamp(colour*.2 + smoothstep(0.0, 1.0, colour)*.8,0.0, 1.0);\n\n    colour = sqrt(colour);\n    colour += hash12i(coord+time)/256.0; //...Dither those 8bit limitations away\n    \n    \n#ifdef EXPORT_VERSON\n    outCol = vec4(fader(0.0, 4.0, iTime) * fader(299.0, 294.0, iTime)*colour, 1);\n#else\n    outCol = vec4(fader(0.0, 4.0, iTime) * colour, 1);\n#endif\n    outCol += hash12i(coord+time)/256.0; //...Dither those 8bit limitations away\n}\n\n//-----------------------------------------------------------------\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Rough Seas üåä, by Dave Hoskins.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n/*\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nvec2 ihash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n*/\n\nvec2 noise2D(in float p)\n{\n\tfloat f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 res = mix(hash21(p), hash21(p + 1.0), f);\n    return res-.5;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v, aud;\n    float t = time;\n    \n    \n    // Add vary volumes of different frequencies...\n    // Magic numbers again, sorry folks...\n    v = noise2D(t*.6)*.5+.5;\n    v = v*v*3.0;\n    aud = noise2D(t*320.+sin(t*.1)*100.) * v;\n    \n    v = noise2D(t*.3)*.8+.2;\n    v = v*v*3.0;\n    aud += noise2D(t*600.)*v;\n\n    v = noise2D(-t*.3)*.8;\n    aud += noise2D(t*1300.)*v;\n\n    v = noise2D(-t*.5)*.6;\n    aud += noise2D(t*2200.)*v;\n\n\n    v = (noise2D(-t*.4)+noise2D(-t*.3))*.3;\n    aud += noise2D(t*4400.)*v;\n\n    v = (noise2D(t*.7) +noise2D(t*.22))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*7500.)*v;\n    \n    v = (noise2D(t*.4) +noise2D(t*.3))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*10000.)*v;\n    \n\n\n    aud = clamp(aud*.9, -1.0, 1.0);// Clamp it properly\n    aud = 1.5*aud-.5*aud*aud*aud; // Loudness\n    aud *= fader(.0, 3.0,time) * fader(180.0, 170.0,time); // Fade in and out.\n    \n    return aud;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}