{
    "Shader": {
        "info": {
            "date": "1608518451",
            "description": "cci(radius,radius,distance.x) = circleCircleIntersection\ncci generates both, (bi)Vesica (up half) and MossEgg(low half) \nyou either add radius3 to both others or subtract it from both other radii.\nand if you do one on each half, you get a Pear/Joint/Smile",
            "flags": 32,
            "hasliked": 0,
            "id": "wlcczH",
            "likes": 10,
            "name": "CirclePear (MossEgg+Vesica)",
            "published": 3,
            "tags": [
                "tangent",
                "joint",
                "vesica",
                "hinge",
                "pear",
                "appolonean",
                "appolonean",
                "mossegg",
                "circlesegment"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 480
        },
        "renderpass": [
            {
                "code": "//#define FoldColors\n\n//its an OrVesica, not an AndVesica case (rounded venn diagram)\n//as in https://www.shadertoy.com/results?query=Vesica\n//the middle radius is substracted in the upper half, forming a bay, and added in the lower half, making a penesula. (assuming the shape center is dry land)\n//this makes the OrVesica a complementary shape to the mossEgg\n//while only the AndVesica is identical to a mirrored mossEgg.\n\n//very early version, only calculates 4 correct circle positions\n//does not calculate signed distance field (of below extnesions)\n//this is just the protottype proof of concept\nvec4 circles4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){u=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec4 c=vec4(length(u)-r.x)//red circle\n ;c.y=length(u-vec2(d,0))-r.y//green circle\n ;vec2 ci=vec2(0)//2 circleCircleIntersections -> blue and yellow circle centers\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;vec2 cBlue=vec2(ci.x, pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y, pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;c.z=length(u-cBlue)-(r.z)//blue     circle\n ;c.w=length(u-cYell)-(r.w)//yellow.w circle\n ;c=abs(c)-.005 //4 rings of thichness\n ;c=ss(0.003,c) //4 smoothstep\n ;return c;}\n \n//first rather messy segmentation, still shows circles (dithered)\n//is messy, overly explicit, and unoptimized, to debug or extend\nvec4 segments4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, -> blue and yellow circle centers\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//get distances to 4 points, minus 4 radii.\n ;vec4 c=vec4(0)\n ;c.x=length(v-cRed  )-r.x//red      circle/distance\n ;c.y=length(v-cGreen)-r.y//green    circle/distance\n ;c.z=length(v-cBlue )-r.z//blue     circle/distance\n ;c.w=length(v-cYell )-r.w//yellow.w circle/distance\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.\n ){e= vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     \n  ;e=-vec2(sd2l(v,cGreen,cYell),sd2l(v,cYell,cRed  ))\n ;}\n ;e=sign(e)\n ;//dither 2 views\n ;u=mod(u,2.)\n ;if(u.x==u.y\n ){c=abs(c)-.01 //4 rings of thichness\n  ;c=ss(0.003,c) //4 smoothstep\n ;}else{\n  ;//fold sections to 2 colors that are a piecewise DistanceField\n  ;if(e.x<0.&&e.y<0.//inner blue part\n  ){c.x=0.;c.y=0.;c.z=max(-c.z,c.w);c.w=0.\n  ;}else{//outer red part (can overlap in upper area, so its a miin)\n   ;c.z=0.;c.w=0.;c.x=min(c.x,c.y);c.y=0.\n  ;}\n  ;//c=fract(c*8.)\n  ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              \n  ;//fold 2 segment to monochrome\n  //#define FoldColors\n  #ifdef FoldColors\n  ;c.x+=c.z\n  ;c.z=0.\n  #endif\n ;}\n ;return c;}\n\n//pythCiiBlue||pythCiiYell are 1 division + 1 sqrt()\n//they are the slow subroutines for the sake of making this shape very parametric/dynamic\n//they calculate circleCircleIntersection.xy = positions if yellow and blue circleCenter\n//so that the circles are touching without intersecting.\n//\n//I can not get circleCircleIntersection.xy without sqrt() of pythagorean theorem, right?\nvec2 pythCiiBlue(vec4 r,float d){//return center of blue circle\n ;float i=cci(r.x+r.z,r.y+r.z,d)//circleCircleIntersection.x\n ;return vec2(i,pythagoras(vec2(r.x+r.z,i)));}//circleCircleIntersection.y via pythagoras.\nvec2 pythCiiYell(vec4 r,float d){//return center of yellow circle\n ;float j=cci(r.x-r.w,r.y-r.w,d)//circleCircleIntersection.x\n ;return vec2(j,pythagoras(vec2(r.x-r.w,j)));}//circleCircleIntersection.y via pythagoras.\n\n//vastly improved performance, but more redundant code may compile slower.\n//complexity is either 3 sqrt+1 divisions, OR 4 sqrt+2 divisions.\nvec4 pear(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)//green circle center\n ;vec4 c=vec4(0)//returned value\n ;if(v.y>0.){//upper half (Blue is condition for cYell to be skippable)\n  ;vec2 cBlue=pythCiiBlue(r,d)\n  ;if(sd2l(v,cRed,cBlue)>=0.||sd2l(v,cBlue,cGreen)>=0.//inner blue part\n  ){//outer upper part (can overlap in upper area, so its a min()), but does not need to calculate cYell\n   ;c.x=min(length(v-cRed)-r.x,length(v-cGreen)-r.y)  //3 sqrt toral\n  ;}else{ //inner upper part also needs to calculate cYell\n   ;c.z=max(-length(v-cBlue )+r.z,length(v-pythCiiYell(r,d))-r.w)  //4 sqrt total\n  ;}\n ;}else{//lower half (cYell is condition, for cBlue to be skippable)\n  ;vec2 cYell=pythCiiYell(r,d)\n  ;if(sd2l(v,cYell,cGreen)>=0.||sd2l(v,cRed,cYell)>=0.//inner blue part\n  ){//lower outer parts (can overlap in upper area, so its a miin), but no need to calculate cBlue\n   ;c.x=min(length(v-cRed)-r.x,length(v-cGreen)-r.y)  //3 sqrt toral\n  ;}else{ //lower inner part also needs to calculate blue\n   ;c.z=max(-length(v-pythCiiBlue(r,d))+r.z,length(v-cYell)-r.w)  //4 sqrt toral\n ;}}\n ;return vec4(c.x+c.z,c.y,0,c.w)//final color fold.\n ;}\n\n/*\n//clearly pear() can be optimized and can skip 1 sqrt(), if not 3?\n//pear36() can have 3 sqrt, or will do 6 sqrt()\n//todo: by first computing, if [u] is in the blue or red area, i may get this down to 2 or 4 sqrt()\n//cleaned up working version, returns distance field\n//returns vec4 (for simplicity and optional debugging)\n//only c.xz are relevant (.x=red distance .z= blue segment branch)\nvec4 pear36(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;//vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;vec2 cBlue=vec2(0.)\n ;vec2 cYell=vec2(0.)\n ;if(v.y>0.//upper half = vesica\n ){cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{//lower half == mossEgg\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//returned value\n ;if(e.x<0.&&e.y<0.// uv is within the inner blue part (most complex segment)\n ){//in the end, cBlue + cYell must both be computed for this case\n //, because the blue circle can be below u.y<0\n  ;cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n //complexity is 1 division within cci() + 2 dot() within sd2l()\n // +3 or 6 sqrt (more swrt wwithin the blue area)\n //may be worth it to first compute the blue area, to get this down to 3 or 4 sqrt?)\n //-can be writtnen to be always 4 sqrt (above), by precomputing cBlue+cYell outside of their cases, without precoputing if it is in the blue area.\n/**/\n\nvoid mainImage( out vec4 O, in vec2 u\n){vec2 m=iMouse.xy\n ;//u.x+=iR.y*.5\n ;vec2 n=abs(iMouse.zw)\n ;m=abs(fra(iR,m))\n ;n=abs(fra(iR,n))\n  ;\n ;float t=iTime*2.+15.\n ;\n ;//5 parameters (4 set by iMouse, or overwritten here\n ;float dist=1.//distance.x between red and green circle\n ;//m.x=  //left  end    circle radius (red)\n ;//m.y=  //right end    circle radius (green)\n ;//n.x=.3  //top  inner   circle radius (blue)\n ;//n.y=1.5 //bottom outer circle radius (yellow) (should be > m.x+m.y)\n ;if(iMouse.z>0.)n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n ;//if(iMouse.z>0.)n.y=(dist-m.x-m.y)*mix(1.,5.,cos(iTime*.5)*.5+.5)\n ;\n ;if(iMouse.z<=0.//animate whime louse is up  must b1>=, or initiation if bad\n ){m.x=.7*(sin(t               )*.5+.5) //left radius\n  ;m.y=.7*(sin(t*sqrt(5.)*.5+.5)*.5+.5) //right radius\n  ;m.xy+=.02//minimum circle to emphasize roundness\n  ;n.x=1.*(cos(t*sqrt(2.)*.5+.5)*.5+.5) //upper inner radius\n  ;n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n  ;dist=.5*mix(.3,2.\n           ,1.*(sin(t*sqrt(3.)*.5+.5)*.5+.5))+(m.x+m.y)*.5\n ;} \n ;\n ;//worksafing inputs\n ;float betterSafeThanNull=1./iR.x\n ;//blue circle is at least large enough to touch red AND green\n ;n.x=max(n.x,(dist-m.x-m.y)*.5+betterSafeThanNull)\n ;//yellow circle is at SMALL enough to contain green and blue\n ;n.y=max(n.y,(dist+m.x+m.y)*.5+betterSafeThanNull)\n ;\n ;vec4 c=vec4(0)//return value\n ;float a=1.; ;//chose one of 3 [stages of development];\n ;if(iMouse.z>0.)a=floor(mod(t+1.,7.))         //on mouse down\n ;else a=float(fra(iR,u).x>sin(iTime*.2)*2.)*6.+1.//on mouse up\n ;//3 [stages of development];\n ;     if(a<1.)c=circles4(u,m,n,dist) //draw only circles\n ;else if(a<5.)c=segments4(u,m,n,dist)//mix between above and below\n ;else        {c=pear(u,m,n,dist)\n              ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              ;}\n ;//todo, more userfriendly MossEgg-like wrapper (nrormalize [dist] to 1)\n ;//todo, CSG sign swapping fun (as in my vesica shader)\n ;//todo, put in dragAndDrop Ui Canvas of \n ;//...   https://www.shadertoy.com/view/WdGfRw\n ;//todo, parametrization\n ;\n ;c.xy+=c.w//yellow\n ;O=vec4(c.xyz,1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define iR iResolution\n#define u2(a) (a)*2.-1.\n\n#define ss(a,b) smoothstep (a,-a,b)\n\n#define ViewZoom 2.\n#define fra(r,u) ((u-.5*r.xy)*ViewZoom/r.y)\n#define dd(a) dot(a,a)\n\nvec2 fra2(vec3 r,vec2 u\n){u=u/r.xy \n ;u.x*=r.x/r.y\n ;return u2(u);}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles.centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\nfloat cci(float a,float b,float c){return cci(vec3(a,b,c));}\n//does not check for non-intersecticn cases! \n//intersection.y can be calculated by pythagoras()   \n\n//pythagoran theorem: a.x=hypothenuse (commonly used after cci() )\nfloat pythagoras(vec2 a){a*=a;return sqrt(a.x-a.y);}\n//float su(vec2 a){return a.x-a.y;}\n//float su(vec3 b){return a.x-a.y-a.z;}\n//float su(vec4 b){return a.x-a.y-a.z-a.y;}\n//#define pythagoras(a) sqrt(-su(-(a*a)))\n\n\n//sign() but returns 1 instead of 0.\nivec2 sign2(vec2 a){ return ivec2(a.x<0.,a.y<0.)*2-1;}\n\n //return SIGNED non-normalized distance\n // of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u, vec4 m\n){//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n ;//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n ;vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x)//calculate rotated differential\n ;//no need to divide by dot(a,a), for the same reason as below\n ;//no need to normalize() f, because we only care for the sign, using the SIGN of a LINE as a BOUNDARY of a composite-shape\n ;u-=m.xy;\n ;return dot(u,f)//early out is work safe\n \n //below alternative has some error cases on the mossEgg()\n \n //below may not be worth the overhead\n ;if (u.x==0.||f.x==0.){return u.y*f.y ;}//.x==0\n ;if (u.y==0.||f.y==0.){return u.x*f.x ;}//.y==0\n ;ivec4 s=ivec4(sign2(u),sign2(f))\n ;if  (s.x!=s.z || s.y!=s.w  //if some specific signs are differeent\n ){if (!(s.x!=s.w || s.y!=s.z))  return -1. //we mltiply 2 different signs\n ;return dot(u,f)//cases a hard to predict as doing a dot()\n ;}\n ;return 1. //we sum positives because some signs are equal.\n \n //a dot() would only multiply-to-positive and sum positives\n //-> positive sign\n ;\n \n //;return (u.x*f.x+u.y*f.y) //dot() equivalence\n //seens not worth to turn into if()-tree to only get a sign faster\n \n ;}//signed distance to line, not normalize()d\n \nfloat sd2l(vec2 u, vec2 a,vec2 b){return sd2l(u,vec4(a,b));}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//a backup of the older code\n\n//#define FoldColors\n\n//its an OrVesica, not an AndVesica case (rounded venn diagram)\n//as in https://www.shadertoy.com/results?query=Vesica\n//the middle radius is substracted in the upper half, forming a bay, and added in the lower half, making a penesula. (assuming the shape center is dry land)\n//this makes the OrVesica a complementary shape to the mossEgg\n//while only the AndVesica is identical to a mirrored mossEgg.\n\n//very early version, only calculates 4 correct circle positions\n//does not calculate signed distance field (of below extnesions)\n//this is just the protottype proof of concept\nvec4 circles4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){u=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec4 c=vec4(length(u)-r.x)//red circle\n ;c.y=length(u-vec2(d,0))-r.y//green circle\n ;vec2 ci=vec2(0)//2 circleCircleIntersections -> blue and yellow circle centers\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;vec2 cBlue=vec2(ci.x, pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y, pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;c.z=length(u-cBlue)-(r.z)//blue     circle\n ;c.w=length(u-cYell)-(r.w)//yellow.w circle\n ;c=abs(c)-.005 //4 rings of thichness\n ;c=ss(0.003,c) //4 smoothstep\n ;return c;}\n \n//first rather messy segmentation, still shows circles (dithered)\n//is messy, overly explicit, and unoptimized, to debug or extend\nvec4 segments4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, -> blue and yellow circle centers\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//get distances to 4 points, minus 4 radii.\n ;vec4 c=vec4(0)\n ;c.x=length(v-cRed  )-r.x//red      circle/distance\n ;c.y=length(v-cGreen)-r.y//green    circle/distance\n ;c.z=length(v-cBlue )-r.z//blue     circle/distance\n ;c.w=length(v-cYell )-r.w//yellow.w circle/distance\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.\n ){e= vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     \n  ;e=-vec2(sd2l(v,cGreen,cYell),sd2l(v,cYell,cRed  ))\n ;}\n ;e=sign(e)\n ;//dither 2 views\n ;u=mod(u,2.)\n ;if(u.x==u.y\n ){c=abs(c)-.01 //4 rings of thichness\n  ;c=ss(0.003,c) //4 smoothstep\n ;}else{\n  ;//fold sections to 2 colors that are a piecewise DistanceField\n  ;if(e.x<0.&&e.y<0.//inner blue part\n  ){c.x=0.;c.y=0.;c.z=max(-c.z,c.w);c.w=0.\n  ;}else{//outer red part (can overlap in upper area, so its a miin)\n   ;c.z=0.;c.w=0.;c.x=min(c.x,c.y);c.y=0.\n  ;}\n  ;//c=fract(c*8.)\n  ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              \n  ;//fold 2 segment to monochrome\n  //#define FoldColors\n  #ifdef FoldColors\n  ;c.x+=c.z\n  ;c.z=0.\n  #endif\n ;}\n ;return c;}\n\n//always 4 sqrt version of the below new attempt of reducing sqrt()\nvec4 pear(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.){e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//returned value\n ;if(e.x<0.&&e.y<0.//inner blue part\n ){c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n //complexity is 4 sqrt() + 1 division + 1 dot()\n\n/*\n//clearly pear() can be optimized and can skip 1 sqrt(), if not 3?\n//pear36() can have 3 sqrt, or will do 6 sqrt()\n//todo: by first computing, if [u] is in the blue or red area, i may get this down to 2 or 4 sqrt()\n//cleaned up working version, returns distance field\n//returns vec4 (for simplicity and optional debugging)\n//only c.xz are relevant (.x=red distance .z= blue segment branch)\nvec4 pear36(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;//vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;vec2 cBlue=vec2(0.)\n ;vec2 cYell=vec2(0.)\n ;if(v.y>0.//upper half = vesica\n ){cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{//lower half == mossEgg\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//returned value\n ;if(e.x<0.&&e.y<0.// uv is within the inner blue part (most complex segment)\n ){//in the end, cBlue + cYell must both be computed for this case\n //, because the blue circle can be below u.y<0\n  ;cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n //complexity is 1 division within cci() + 2 dot() within sd2l()\n // +3 or 6 sqrt (more swrt wwithin the blue area)\n //may be worth it to first compute the blue area, to get this down to 3 or 4 sqrt?)\n //-can be writtnen to be always 4 sqrt (above), by precomputing cBlue+cYell outside of their cases, without precoputing if it is in the blue area.\n/**/\n\nvoid mainImage( out vec4 O, in vec2 u\n){vec2 m=iMouse.xy\n ;//u.x+=iR.y*.5\n ;vec2 n=abs(iMouse.zw)\n ;m=abs(fra(iR,m))\n ;n=abs(fra(iR,n))\n  ;\n ;float t=iTime*2.+15.\n ;\n ;//5 parameters (4 set by iMouse, or overwritten here\n ;float dist=1.//distance.x between red and green circle\n ;//m.x=  //left  end    circle radius (red)\n ;//m.y=  //right end    circle radius (green)\n ;//n.x=.3  //top  inner   circle radius (blue)\n ;//n.y=1.5 //bottom outer circle radius (yellow) (should be > m.x+m.y)\n ;if(iMouse.z>0.)n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n ;//if(iMouse.z>0.)n.y=(dist-m.x-m.y)*mix(1.,5.,cos(iTime*.5)*.5+.5)\n ;\n ;if(iMouse.z<=0.//animate whime louse is up  must b1>=, or initiation if bad\n ){m.x=.7*(sin(t               )*.5+.5) //left radius\n  ;m.y=.7*(sin(t*sqrt(5.)*.5+.5)*.5+.5) //right radius\n  ;m.xy+=.02//minimum circle to emphasize roundness\n  ;n.x=1.*(cos(t*sqrt(2.)*.5+.5)*.5+.5) //upper inner radius\n  ;n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n  ;dist=.5*mix(.3,2.\n           ,1.*(sin(t*sqrt(3.)*.5+.5)*.5+.5))+(m.x+m.y)*.5\n ;} \n ;\n ;//worksafing inputs\n ;float betterSafeThanNull=1./iR.x\n ;//blue circle is at least large enough to touch red AND green\n ;n.x=max(n.x,(dist-m.x-m.y)*.5+betterSafeThanNull)\n ;//yellow circle is at SMALL enough to contain green and blue\n ;n.y=max(n.y,(dist+m.x+m.y)*.5+betterSafeThanNull)\n ;\n ;vec4 c=vec4(0)//return value\n ;float a=1.; ;//chose one of 3 [stages of development];\n ;if(iMouse.z>0.)a=floor(mod(t+1.,7.))         //on mouse down\n ;else a=float(fra(iR,u).x>sin(iTime*.2)*2.)*6.+1.//on mouse up\n ;//3 [stages of development];\n ;     if(a<1.)c=circles4(u,m,n,dist) //draw only circles\n ;else if(a<5.)c=segments4(u,m,n,dist)//mix between above and below\n ;else        {c=pear(u,m,n,dist)\n              ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              ;}\n ;//todo, more userfriendly MossEgg-like wrapper (nrormalize [dist] to 1)\n ;//todo, CSG sign swapping fun (as in my vesica shader)\n ;//todo, put in dragAndDrop Ui Canvas of \n ;//...   https://www.shadertoy.com/view/WdGfRw\n ;//todo, parametrization\n ;\n ;c.xy+=c.w//yellow\n ;O=vec4(c.xyz,1);}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}