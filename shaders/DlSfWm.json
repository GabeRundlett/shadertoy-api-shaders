{
    "Shader": {
        "info": {
            "date": "1694689960",
            "description": "A Kraken pit with a black hole in the middle. made with raymarching, and a procedural starmap in the background.",
            "flags": 0,
            "hasliked": 0,
            "id": "DlSfWm",
            "likes": 24,
            "name": "An occult kraken pit",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "reflection",
                "shadow",
                "water",
                "light",
                "star",
                "demo",
                "blackhole",
                "kraken",
                "octopus",
                "tentacle",
                "ligth"
            ],
            "usePreview": 0,
            "username": "Cewein",
            "viewed": 383
        },
        "renderpass": [
            {
                "code": "// Shader made by Maximilien \"Cewein\", september 2023\n//\n// This is a raymarch scene of eigth tentacle in a water pit\n// around a black hole, the black hole deform the direction of the rays\n//\n//\n// Possible improvement :\n// \t\t- Anti-Aliasing (but heave on perf)\n//\t\t- try to add some global illumination\n//\n// main help came from here : \n// https://iquilezles.org/articles/distfunctions/\n// https://mercury.sexy/hg_sdf/\n//\n//\n\n\n///// CONSTANT /////\n\n#define MAX_STEP 256\n#define MAX_DIST 100.0\n\nvec3 blackHolePos = vec3(0.0,3.0,0.0);\n\n///// RAY MARCHING FUNCTION /////\n\nvec2 map(vec3 pos)\n{\n    vec2 dm = vec2(0.0,0.5);\n    \n    float total = 0.0;\n    \n    //black hole\n    float sphere = distance(pos, blackHolePos)-0.35;\n    total = sphere;\n    \n    \n    //floor + hole in the ground\n    float ground = pos.y;\n    float cylinder = sdCylinder(pos, vec3(0.0,0.0,4.5));\n    ground = max(ground,-cylinder);\n    \n    if( total > ground) dm.y = 2.5;\n    total = min(total,ground);\n    \n    ground = abs(pos.y+1.0);\n    if( total > ground) dm.y = 4.5;\n    total = min(total,ground);\n    \n    //tentacle\n    float tentacle = Tentacle((pos - vec3(0.,-3.,0.))*0.4,8.0, iTime, iChannel0);\n    if( total > tentacle) dm.y = 3.5;\n    \n    dm.x = min(total,tentacle);\n    \n    return dm;\n}\n\n//raymarching loop\nhitPayload trace(hitPayload p)\n{\n    float dist = 0.0;\n    for(int i = 0; i < MAX_STEP; i++)\n    {\n        p.pos = p.pos + dist * p.dir;\n        vec2 tmp = map(p.pos);\n        \n        if(tmp.x < 0.00001) return p;\n        \n        p.nbStep = i;\n        \n        dist = tmp.x;\n        p.totalDist += tmp.x;\n        p.mat = tmp.y;\n\n        if(p.totalDist > MAX_DIST) \n        {\n            p.mat = -1.0;\n            break;\n        }\n        \n        //add lensing, very basic but do the trick\n        //we interpolate the original direction and the direction troward\n        //the blackhole at each step based on the distance\n        //of the point to the blackhole\n        float inter = distance(p.pos, blackHolePos);\n        inter = smoothstep(-9.5,2.5,inter);\n        p.dir = mix(normalize(blackHolePos-p.pos),p.dir,inter);\n    }\n    \n    return p;\n}\n\n///// SHADING FUNCTION /////\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(map(pos + e.xyy).x-map(pos-e.xyy).x,\n                          map(pos + e.yxy).x-map(pos-e.yxy).x,\n                          map(pos + e.yyx).x-map(pos-e.yyx).x)\n                    );\n}\n\n\n//since the tentacle came out of the water\n//add a \"watery\" effect \nvec3 Water( vec3 rayDir )\n{\n\n    vec3 WaterKeyColor  = vec3( 0.19, 0.92, 0.98 );\n    vec3 WaterFillColor = vec3( 0.1, 0.06, 0.28 );\n    \n    rayDir.xy *= rot(-80.0); \n    vec3 color = mix( WaterKeyColor, WaterFillColor, clamp( -1.2 * rayDir.y + 0.6 ,0.0,1.0) );\n    return color;\n}\n\n//thanks for the stars, check this shader out, it contain midgar\n//https://www.shadertoy.com/view/XllXWN\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*250.)-0.5;\n        vec3 id = floor(p*250.);\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*smoothstep(-0.1, 0., p.y);\n}\n\n\n//this is the function that translate a material to the correct color\nvec3 getColor(hitPayload p)\n{\n    vec3 color = stars(p.dir);\n    vec3 dm = vec3(p.mat);\n  \n    vec3 newWorldPos;\n    hitPayload pNew;\n    \n    \n    if(p.mat > 4.0 && p.mat < 5.0)\n    {\n        color = vec3(0.60);\n        int nbStep;\n        vec3 rdref = refract(p.dir,p.normal,0.9);\n        p.pos -= p.normal*0.1;\n        pNew = trace(p);\n        p.pos += p.normal*0.1;\n        newWorldPos = pNew.pos;\n        dm.xy = vec2(pNew.mat);\n    }\n    \n    p.mat = dm.y;\n    \n    //prevent tilling in the water pit\n    if(dm.z < 4.0 || dm.z > 5.0)\n    {\n        if(p.mat > 2.0 ) //floor\n        {\n            //floor tilling \n            if(mod(floor(p.pos.xz*0.25), 2.0) == vec2(0.) || mod(floor(p.pos.xz*0.25), 2.0) == vec2(1.))\n                color = vec3(0.6);\n            else\n                color = vec3(0.3);\n\n        }\n    }\n    \n    //tentacle shading\n    //explanation is a bit more ditail here since\n    //the code look a bit messy\n    if(p.mat > 3.0)\n    {\n        \n        // Calculate the background color\n        vec3 background = Water(p.dir) * 0.3;\n\n        // Calculate the specular occlusion based on the distance from the black hole\n        float specOcc = clamp(0.5 * length(p.pos - vec3(blackHolePos)), 0.0, 1.0);\n\n        // Define color constants\n        vec3 c1 = vec3(0.67, 0.1, 0.05);    // Reddish color\n        vec3 c2 = vec3(0.1, 0.06, 0.28);    // Dark blue color\n\n        // Calculate the base color based on the normal\n        vec3 baseColor = mix(c1, p.normal.y > 0.0 ? c1 : c2, smoothstep(vec3(0.0), vec3(0.8), p.normal));\n\n        // Calculate the reflection vector\n        vec3 reflVec = reflect(p.dir, p.normal);\n\n        // Calculate the Fresnel term\n        float fresnel = clamp(pow(1.2 + dot(p.dir, p.normal), 5.0), 0.0, 1.0);\n\n        // Combine components to determine the final color based on the specular occlusion\n        color = mix(\n            0.8 * baseColor + 0.6 * Water(reflVec) * mix(0.04, 1.0, fresnel * specOcc),\n            background,\n            0.9 + dot(p.dir, p.normal) * specOcc\n        );\n    }\n    if(dm.z > 4.0 && dm.z < 5.0) //water pit\n    {\n        color *= 4.5/((distance(newWorldPos,p.pos)-0.1)*20.);\n\n    }\n\n    return color;\n}\n\n\n///// RENDERING FUNCTION /////\n\n//this is the quick way to obtain a invervse view matrix\n//go to common to see alternative way with a long process\nmat4 getInvViewMatrix(vec3 ro, vec3 at)\n{\n    vec3 ww = normalize(at-ro); //front\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0))); // rigth;\n    vec3 vv = normalize(cross(uu,ww)); // up;\n    \n    return mat4(uu,0.,\n                vv,0.,\n                -ww,0.,\n                0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy - 1.0)/iResolution.y;\n    \n    //init camera para\n    float angle = 5.0*iMouse.x/iResolution.x;\n    float height = 5.0*iMouse.y/iResolution.y;\n    \n    //if screen has not been clicked yet\n    if(iMouse.x == 0.0 )\n    {\n        angle = 89.95;\n        height = 0.5;\n\n    }\n    \n    //ray origin and look at point\n    vec3 ro = vec3(10.0 * cos(angle), 4.0*height, 10.0 * sin(angle));\n    vec3 at = vec3(0.0,4.0,0.0);\n    \n    //ray direction\n    vec3 rd = normalize(getInvViewMatrix(ro,at) * vec4(uv,-1.5,1.0)).xyz;\n    \n    //init scope variable\n    vec3 color = vec3(0.0);\n    \n    //Using a struct make the code cleaner and\n    //will also shorten many function \n    hitPayload p = hitPayload(\n        ro, //postion aka origin at first\n        rd, //ray direction\n        vec3(0.0), //normal\n        -1.0, //material\n        0, //number of step\n        0.0 //total distance\n    );\n        \n    \n    //preform ray-marching\n    p = trace(p);\n    \n    //compute normal and get color\n    p.normal = calcNormal(p.pos);\n    color = getColor(p);\n    \n    //perform color grading before shadow (prefere this way)\n    color = pow(color,vec3(0.4545));\n    \n    /***** SHADOW *****/\n    //change the direction throward the bh\n    p.dir =  normalize(blackHolePos - p.pos);\n    \n    //apply shadow on everything exect the sky\n    if(p.mat > 0.0)\n    {\n        color *= clamp(dot(p.normal, p.dir), 0.0, 1.0 );\n        color *= smoothstep(50.0,20.0,length(p.pos.xz));\n    }\n    \n    //trace the shadow troward the blackhole\n    //if anyhing else that the sky or bh is hit then it in shadow\n    p.pos += p.normal*0.001;\n    p = trace(p);\n    if(p.mat > 1.0) color *= 0.3;\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///// STRUCTURE /////\n\nstruct hitPayload\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 normal;\n    float mat;\n    int nbStep;\n    float totalDist;\n};\n\n\n///// CONSTANTE /////\n\nconst float PI = atan(1.0)*4.0;\n\n///// SDF FUNCION /////\n//https://iquilezles.org/articles/distfunctions/\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n///// SDF OPERATION /////\n// https://iquilezles.org/articles/distfunctions/\n\nfloat opUnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat opSubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n///// DOMAIN REPETITION /////\n\n// found on the demogroup website : https://mercury.sexy/hg_sdf/\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n///// TENTACLE /////\n//based on this shader : https://www.shadertoy.com/view/MdsBz2\n//modify to not use smooth and saturate and small tweek to rotate the whole sdf\n\nfloat Tentacle( vec3 p , float nbTentacle, float iTime, sampler2D iChannel0)\n{    \n\n    //polar mod and rotation + displacement in world\n    float c = pModPolar(p.xz,nbTentacle);\n    p.xy *= rot(-60.0 + cos(sin(iTime + c))*3.0);\n    p.y += 0.6;\n    \n    float scale = 1.0 - 2.5 * clamp( abs( p.y ) * 0.25,0.,1. );    \n    \n    p -= vec3( 1.0, -0.5, 0.0 );\n    \n    //controle the length\n    p.xy *= rot(60.0);\n    p.x -= sin( p.y * 5.0 + iTime * 1.6 ) * 0.05;\n    p.z -= cos( p.x * 5.0 + iTime * 1.6 ) * 0.02;\n\n    vec3 t = p;    \n\n    float ret = sdCapsule( p, vec3( 0.0, -1000.0, 0.0 ), vec3( 0.0, 1000.0, 0.0 ), 0.25 * scale );\n    \n    p.z = abs( p.z );\n    p.y = mod( p.y + 0.08, 0.16 ) - 0.08;\n    p.z -= 0.12 * scale;\n    float tent = sdCapsule( p, vec3( 0.0, 0.0, 0.0 ), vec3( -0.4 * scale, 0.0, 0.0 ), 0.1 * scale );\n    \n    float pores = sdSphere( p - vec3( -0.4 * scale, 0.0, 0.0 ), mix( 0.04, 0.1, scale ) );\n    tent = opSubstractRound( tent, pores, 0.01 );\n  \n    ret = opUnionRound( ret, tent, 0.05 * scale );\n    ret += textureLod( iChannel0, vec2( t.xy * 0.5 ), 0. ).x * 0.02;\n\n    return ret;\n}\n\n\n///// PSEUDO-RANDOM FUNCTION /////\n\n//quick and poor function\nfloat frand(vec2 st)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 hash33(vec3 p){\n    p  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n    return fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\n///// MATRIX OPERATION /////\n\n// matrix operations\nmat4 translate(vec3 t)\n{\n \treturn mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t,1.)\n        );\n}\nmat4 translateInv(vec3 t)\n{\n \treturn translate(-t);   \n}\n\nmat4 scale(vec3 s)\n{\n \treturn mat4(\n        vec4(s.x,0.,0.,0.),\n        vec4(0.,s.y,0.,0.),\n        vec4(0.,0.,s.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\nmat4 scaleInv(vec3 s)\n{\n \treturn scale(1./s);   \n}\n\nmat4 rightToLeft()\n{\n    // 1 0 0  0\n    // 0 1 0  0\n    // 0 0 -1 0\n    // 0 0 0  1\n \treturn scale(vec3(1.,1.,-1.));\n}\n\nmat4 rightToLeftInv()\n{\n    // same matrix\n    return rightToLeft();\n}\n\t\n\nmat4 ortho(float l, float r, float b, float t, float n, float f)\n{\n\n    \n       // translation and scale\n    return scale(vec3(2./(r-l),2./(t-b),2./(f-n))) * \n                 translate(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.));\n    \n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f)\n{\n    return translateInv(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.)) *\n        scaleInv(vec3(2./(r-l),2./(t-b),2./(f-n)));\n}\n\nmat4 projection(float n, float f)\n{\n \t// n 0 0 0\t0\n    // 0 n 0 0\t0\n    // 0 0 n+f\t-fn\n    // 0 0 1\t0\n    return mat4(\n        vec4(n,0.,0.,0.),\n        vec4(0.,n,0.,0.),\n        vec4(0.,0.,n+f,1.),\n        vec4(0.,0.,-f*n,0.)\n        );\n}\n\nmat4 projectionInv(float n, float f)\n{\n \t// 1/n \t0 \t0 \t\t0\n    // 0 \t1/n\t0 \t\t0\n    // 0\t0\t0 \t\t1\n    // 0\t0\t-1/fn\t(f+n)/fn\n    \n    return mat4(\n        vec4(1./n,0.,0.,0.),\n        vec4(0.,1./n,0.,0.),\n        vec4(0.,0.,0.,-1./(f*n)),\n        vec4(0.,0.,1.,(f+n)/(f*n))\n        );\n}\n\n\nmat4 perspective(float fov, float aspect, float n, float f)\n{\n \t   float l = 1.0 / tan(fov*n);\n       float b = l/aspect;\n    \n    \treturn ortho(-l,l,-b,b,n,f)*\n            projection(n,f)*rightToLeft();\n}\n\n\nmat4 perspectiveInv(float fov, float aspect,float n, float f)\n{\n     float l = 1.0 / tan(fov*n);\n       float b = l/aspect;\n    \n    return rightToLeftInv()*\n        projectionInv(n,f)*\n        orthoInv(-l,l,-b,b,n,f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}