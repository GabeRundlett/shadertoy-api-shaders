{
    "Shader": {
        "info": {
            "date": "1453837920",
            "description": "I copied the raytracer from McZonk [url]https://www.shadertoy.com/view/ld2Gz3[/url] to learn more about raytracing, added bumpmapping to the ball and floor and added a lot of my own shaders to create an overkill of colors. Still runs 60fps here :)",
            "flags": 0,
            "hasliked": 0,
            "id": "lsBSzD",
            "likes": 18,
            "name": "Overkill",
            "published": 3,
            "tags": [
                "raytracing",
                "bumpmapping",
                "overkill"
            ],
            "usePreview": 0,
            "username": "Andre",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "struct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\nstruct Material {\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n\tfloat shine;\n\tfloat reflectivity;\n};\n\t\nstruct Sphere {\n\tvec3 origin;\n\tfloat radius;\n};\n\nstruct Plane {\n\tvec3 direction;\n\tfloat dis;\n};\n\t\nstruct PointLight {\n\tvec3 origin;\n\tvec3 color;\n};\n\nstruct Output {\n\tvec3 origin;\n\tvec3 normal;\n\tfloat dis;\n\tMaterial material; \n};\n\nconst float PI = 3.1415926536;\n\n#define gt iTime\n#define planeCount 2\nPlane plane[planeCount];\n\n#define sphereCount 7\nSphere sphere[sphereCount];\n\n#define lightCount 1\nPointLight light[lightCount];\n\nvec3 eye;\n\nconst int materialCount = 2;\nMaterial material[2];\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\nfloat floorhash( float n ) \n{\n    float m = mod(n,0.03);\n    n -= m;\n    float h1 = hash(n);\n    float h2 = hash(n+0.03);\n    return mix(h1,h2,0.5-0.5*cos(PI*m/0.03));\n    //return mix(h1,h2,m/0.01);\n}\n\nSphere makeSphere(float offset, float d) {\n\tfloat t = -iTime*.3 + PI * 2.0 * offset;\n\tfloat x = cos(t) * 8.;\n\tfloat z = sin(t) * 8.;\n\treturn Sphere(vec3(x, d+.4*abs(sin(offset*PI*3.-3.*iTime)), z), d);\n}\n\nvoid makeScene() {\n\t{\n\t\tmaterial[0] = Material(\n\t\t\tvec3(0.05,0.05, 0.1),\n\t\t\tvec3(0.2, 0.3, 0.2),\n\t\t\tvec3(0.4, 0.3, 0.3),\n\t\t\t90.,\n\t\t\t0.6\n\t\t);\n\t\t\n\t\tmaterial[1] = Material(\n\t\t\tvec3(0.1, 0.1, 0.03),\n\t\t\tvec3(0.3, 0.3, 0.03),\n\t\t\tvec3(0.3, 0.3, 0.3),\n\t\t\t19.0,\n\t\t\t0.6\n\t\t);\n\t}\n\t\n\t{\n\t\tplane[0].direction = vec3(0.0, 1.0, 0.0);\n\t\tplane[0].dis = 0.0;\n        \n\t\tplane[1].direction = vec3(0.0, 0.0, 1.0);\n\t\tplane[1].dis = 10.0;\n\n        for (int i=1; i<sphereCount; i++)\n\t\t  sphere[i] = makeSphere(float(i)/(float(sphereCount)-1.),0.33*mod(float(i),3.0)+0.66);\n        \n\t}\n\n\t{\n\t\tfloat r = 6.0;\n\t\tfloat y = 2.5+sin(iTime)*1.7;\n\t\t\n\t\tfloat t0 = -iTime ;\n\t\tlight[0].origin = vec3(-cos(t0) * r, y, -sin(t0*.6) * r);\n\t\tlight[0].color = vec3(2.5);// 1.0 +\n\t\t//\t\t\t\t0.5* vec3(\tsin(gt * 3.13),\n\t\t//\t\t\t\t\t\t\tsin(gt * 1.69),\n\t\t//\t\t\t\t\t\t\tsin(gt * 2.67));\n\n            \n            //vec3(30.3, 30.3, 30.3);\n        \n        sphere[0] = Sphere(light[0].origin, .1);\n\t}\n}\n\n#define StepSize .47\n#define LineCount 7\n\n//Function to draw a line, taken from the watch shader\nfloat line(vec3 p, vec3 a, vec3 b)\n{\n    a = normalize (a);\n    b = normalize (b);\n    p = p;\n    b.z=a.z=p.z;\n        \n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\t//float h = dot(pa, ba) / dot(ba, ba);\n\treturn pow(clamp(1.0-length(pa - ba * h),0.0,1.0),180.0)*5.0;\n}\n\nvec3 shaderB( vec3 fragCoord, float offset )\n{\n\tvec3 uv = normalize(fragCoord);\n\n\tfloat gt = iTime * 3. + offset;\n    //gt -= mod(gt,StepSize);\n\n\t// Add lines to the pixel\n\tvec3 color = vec3(0.0);\n\tfor (int i = 0; i < LineCount; i++)\n\t{\n\t\tgt += StepSize;\n\n\t\t//Calculate the next two points\n\t    vec3 point1 = 0.3 * vec3(cos(gt * 0.39), cos(gt * 0.13), cos(gt * 0.15)) \n                    + 0.7 * vec3(sin(gt * 0.27), sin(gt * 0.33), sin(gt * 0.14));\n\t  \tvec3 point2 = 0.3 * vec3(cos(gt * 0.37), sin(gt * 0.29), sin(gt * 0.39)) \n                    + 0.7 * vec3(sin(gt * 0.19), cos(gt * 0.23), cos(gt * 0.11));\n\n\t\t// Fade older lines\n\t\tcolor.rgb -= .13*max(max(color.r,color.g),color.b);\n\n\t\t// Add new line\n\t\tcolor.rgb += line(\tuv,\n\t\t\t\t\t\t\tpoint1, point2)\n\t\t\t\t\t//With color\n\t\t\t\t\t* ( 0.5 +\n\t\t\t\t\t\t0.5 * vec3(sin(float(i) * 7.)\n                                  ,sin(float(i) * 4.)\n                                  ,cos(float(i) * 2.)));\n    }\n\n\treturn color;\n}\n\nfloat segment(vec2 uv)\n{\n    uv = abs(uv);\n\treturn (1.0-smoothstep(0.18,0.21,uv.x))\n         * (1.0-smoothstep(0.46,0.49,uv.y+uv.x))\n         * (1.25 - length(uv*vec2(3.8,1.3)));\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    \n    if (num>=2 && num!=7 || num==-2)\n        seg += segment(uv.yx);\n        \n    if (num==0 || \n            (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):\n            (uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))\n        seg += segment(abs(uv)-0.5); \n\t\n    if (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))\n        seg += segment(vec2(abs(uv.y)-1.0,uv.x));\n    \n\treturn seg;\n}\n\nfloat showNum(vec2 uv,float nr, bool zeroTrim)\n{\n    if (uv.x>-3.0 && uv.x<0.0)\n    {\n        float digit = floor(-uv.x / 1.5);\n\t\tnr /= pow(10.,digit);\n        nr = mod(floor(nr),10.0);\n        if (nr==0.0 && zeroTrim && digit!=0.0)\n            return 0.;\n\t\treturn sevenSegment(uv+vec2( 0.75 + digit*1.5,0.0),int(nr));\n    }\n\treturn 0.;\n}\n\nfloat dots(vec2 uv)\n{\n\tuv.y = abs(uv.y)-0.5;\n\tfloat l = length(uv);\n\treturn (1.0-smoothstep(0.11,0.13,l)) * (1.0-l*2.0);\n}\n\nvec3 shaderA( vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy-0.5;\n    if (uv.y>0.0){\n        uv.y = 0.25-uv.y;\n        uv.x *= -1.0;\n    } else {\n        uv.y += 0.25;\n    }\n        \n    uv *= 8.0;\n    uv.x -= 5.0;\n\n    float p = floor(abs(uv.x/3.5));\n    if (uv.x<-10.0 || uv.x>0.0)\n        return vec3(0.0);\n    uv.x = mod(uv.x,3.5)-3.5;\n    \n\tfloat seg = 0.0;\n    if (uv.x>-3.)\n\t    seg = showNum(uv,mod(iDate.w/pow(60.0,p),60.0),p==2.0);\n    else\n    {\n        uv.x += 3.25;\n\t\tseg = dots(uv);\n    }\n\t\n    return vec3(seg*2.,0.,0.);\t\n}\n\nvec3 shaderD( vec2 g, float speed )\n{\n    float gt = iTime*speed;\n    g *= .55;\n    return smoothstep(.1,.9,sin(g.xyx+cos(gt*7.+g.yxx))\n                           *cos(g.yxy+sin(gt   +g.yyx)));\n}\n\n\nvoid intersectSphere(const Sphere sphere, const Ray ray, Material material, inout Output o) {\n\tvec3 d = ray.origin - sphere.origin;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = dot(ray.direction, d);\n\tfloat c = dot(d, d) - sphere.radius * sphere.radius;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0) {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.dis) {\n\t\t\to.dis = dis;\n            if (sphere.radius <0.2){\n                o.material.ambient += pow(g,3.0)*500000.0;\n                return;\n            }\n            \n\t\t\to.origin = ray.origin + ray.direction * dis;\n\t\t\to.normal = (o.origin - sphere.origin) / sphere.radius;\n\t\t\to.material = material;\n            //Metalic look for the balls by bumpmap\n            float gt = iTime*.3;\n            float sgt = sin(gt);\n            float cgt = cos(gt);\n                \n            vec3 n = floor(o.normal\n                           * mat3( cgt,-sgt, 0.0,\n                                   sgt, cgt, 0.0,\n                                   0.0, 0.0, 1.0)\n                           * mat3( 1.0, 0.0 ,0.0,\n                                   0.0, cgt,-sgt,\n                                   0.0, sgt, cgt)\n                           *45.);\n            float factor = smoothstep(0.1,0.99,hash(n.x*40.+hash(n.z)+hash(n.y)*4.));\n            o.material.reflectivity *= (1.-factor)*.6+0.5;\n            o.material.specular.b *= (1.-factor)*.9+.1;\n//            o.material.diffuse.rg = vec2(.05*factor);\n            o.material.ambient.rg = vec2(.1*factor);\n            o.material.diffuse = factor*smoothstep(0.5,1.0,iTime)\n                                 //*texture(iChannel3,abs(mod((n.zy+n.xx)/500.,2.0)-1.0) ).rgb;\n                                 *shaderD(n.zy+n.xx,0.07);\n            o.normal += (0.14*vec3(hash(n.x+hash(n.y))\n                                 ,hash(n.y+hash(n.z))\n                                 ,hash(n.z+hash(n.x)))-0.07)*factor;\n            o.normal = normalize(o.normal);\n\t\t}\n\t}\n}\n\nvoid intersectPlane(const Plane plane, const Ray ray, Material material, inout Output o) {\n\tfloat dis = -dot(plane.direction, ray.origin) / dot(plane.direction, ray.direction);\n\tvec3 orig = ray.origin + ray.direction * dis;\n    vec2 flr = abs(orig.zx);\n\t//bool hit = false;\n\tif(dis > 0.0 && dis < o.dis && max(flr.x,flr.y)<14.) {\n        \n        if (plane.dis>0.0) {\n            if (orig.y>0. && orig.y < 9.0 && abs(orig.x) < 6.0 && iTime > 16.0) {\n    \t\t\tvec4 jc = texture(iChannel1,orig.xy / vec2(12.0,9.0) + vec2(0.5,1.0-smoothstep(16.0,18.0,iTime)));\n    \t\t\tjc.g *= 0.9;\n\t\t\t    float newG = min(jc.g,max(jc.r,jc.b));\n\t\t\t\tfloat d = (jc.g- newG);\n\t\t\t    jc.g = newG;\n\t\t\t    if (d < 0.1)\n\t\t\t    {\n        \t\t\t//uv.y = 1.0-uv.y;\n//\t\t\t        tex = max(clamp(tex*(1.0-d),0.0,1.0),mix(tex,tex2,smoothstep(0.0,0.33,d)));\n\t\t\t\t\to.normal = faceforward(plane.direction, plane.direction, ray.direction);\n\t\t\t\t\to.dis = dis+jc.g;\n\t\t\t\t\to.origin = orig;\n\t\t\t\t\to.material = material;\n                \t//o.material.specular *= 0.5;//cb2/3.+0.35 ;\n                    o.material.ambient = jc.rgb;\n                    o.material.diffuse = jc.rgb*.3;\n                    o.material.specular = vec3(0.);\n                    o.material.reflectivity = -1.0;//clamp(1.0-length(jc.rgb),0.0,1.0)*.1;\n                    o.material.shine = 0.1;\n     \t\t\t}\n            }\n        } else {\n\t\t    o.dis = dis;\n            o.origin = orig;\n\t\t\to.material = material;\n            orig *= 1.0/2.0;\n        \n        \tvec3 tt = smoothstep(7.5,9.0,iTime)*shaderA(orig.xz*.1+.5);\n            vec3 bn = texture(iChannel2,mod(orig.xz,1.0)).rgb;\n            if (bn.g > max(bn.r,bn.b))\n                bn = vec3(0.);\n            //texture(iChannel1,orig.xz*.1+.5).rgb;\n        \t//if (gs>0.4) {\n\t\t\n\t\t\t// checkerboard\n\t\t\tfloat cb0 = smoothstep(0.0,0.3,0.15+sin(orig.x*PI));\n\t\t\tfloat cb1 = smoothstep(0.0,0.3,0.15+sin(orig.z*PI));\n        \tfloat cb2 = abs(cb0+cb1-1.0);\n        \n\t\t\to.material.ambient.b *= cb2/3.+0.55 ;\n\t\t\to.material.diffuse.b *= cb2+0.55 ;\n\t\t\t//o.material.specular.b *= cb2/3.+0.35 ;\n\t\t\t//o.material.specular *= 0.5;//cb2/3.+0.35 ;\n            o.material.specular = shaderD(orig.zx*10.,0.7)*cb2;\n        \to.material.reflectivity = 0.5-length(tt)*0.3;\n        \n        \t// Add bumpmap to the floor tiles        \n\t\t\to.normal = normalize(vec3(abs(cb0-0.5)*0.06-0.03+floorhash(0.3*orig.x*PI+floor(orig.z))*0.015*cb2+\n            \t                      abs(cb0-0.5)*0.06-0.03+floorhash(0.2*orig.x*PI+floor(orig.z))*0.040*cb2,\n                \t                  1.0,\n                    \t              abs(cb1-0.5)*0.06-0.03+floorhash(0.3*orig.z*PI+floor(orig.x))*0.015*(1.0-cb2)+\n                        \t          abs(cb1-0.5)*0.06-0.03+floorhash(0.2*orig.z*PI+floor(orig.x))*0.040*(1.0-cb2)));\n\t\t\t//o.normal = vec3(0.0,1.0,0.0);\n        \to.material.ambient += tt+o.material.specular*.1;\n            o.material.diffuse += bn*(1.0-cb2)*0.8*smoothstep(20.0,22.0,iTime);\n\t        //o.material.diffuse -= tt;\n    \t    o.normal += tt;\n\t\t\t//o.normal = normalize(mix(vec3(sin(o.origin.x*PI)*0.1,1.0,sin(o.origin.z*PI)*0.1),plane.direction,0.0));//cb2);\n\t\t\to.normal = normalize(faceforward(o.normal,o.normal, ray.direction));\n        }\n\t}\n}\n\n\nvec3 illuminatePointLight(PointLight light, Output o) {\n\tvec3 v = normalize(light.origin - o.origin);\n\t\n\tfloat d = clamp(dot(o.normal, v), 0.0, 100.0);\n\tfloat s = 0.0;\n    \n\tif(d > 0.0) {\n\t\tvec3 eyeV = normalize(eye - o.origin); \n\t\tvec3 h = normalize(v + eyeV);\n\t\ts = pow(clamp(dot(o.normal, h), 0.0, 100.0), o.material.shine);\n\t}\n\t\n\tvec3 diffuse  = o.material.diffuse  * light.color * d;\n\tvec3 specular = o.material.specular * light.color * s;\n\treturn diffuse + specular;\n}\n\nvec3 illumiate(Output o) {\n\tvec3 color = o.material.ambient;\n\t\n\tfor(int i = 0; i < lightCount; ++i) {\n\t\tcolor += illuminatePointLight(light[i], o);\n\t}\n\t\n    return color;\n\t//float dis = length(eye - o.origin);\n\t//return color * (1.0 / (dis*0.13));\n}\n\nOutput raytraceIteration(Ray ray) {\n\tOutput o;\n    \n    //Turn the default into sort of dome around the model\n    o.origin = ray.direction*4.5;\n    \n\to.normal = normalize(-ray.direction);\n\to.dis = 10000.;\n    \n//    vec4 color = texture( iChannel0, normalize(ray.direction ));\n    vec3 color = smoothstep(13.5,17.0,iTime)*\n                 shaderB(ray.direction.xyz,.62345);\n        //texture( iChannel2, abs(mod(ray.direction.xy,1.0)-0.5)+.25 );\n    color += texture( iChannel0, normalize(ray.direction )).g*(1.0+shaderD(o.normal.xy*o.normal.z*23.,0.4));\n    \n\to.material = Material(\n\t\tcolor.rgb,\n\t\tcolor.rgb,\n\t\tvec3(0.0, 0.0, 0.0),\n\t\t250.0,\n\t\t0.0\n\t);\n\n\tfor(int i = 0; i < planeCount; ++i) {\n\t\tintersectPlane(plane[i], ray, material[0], o);\n\t}\n\tfor(int i = 0; i < sphereCount; ++i) {\n\t\tintersectSphere(sphere[i], ray, material[1], o);\n\t}\n    //o.material.diffuse += smoothstep(13.5,17.0,iTime)*.25*shaderB(abs(mod(-ray.direction.xyz,1.0)-0.5)+.25, 752.23 )*.25;\n    //o.material.diffuse += smoothstep(13.5,17.0,iTime)*.25*shaderB((mod(-ray.direction.xyz,1.0)-0.25)+.25, 752.23 )*.25;\n\n\treturn o;\n}\n\nvec3 raytrace(Ray ray) {\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\t\n\tfloat reflectivity = 1.;\n\t\n\tfor(int i = 0; i < 3; ++i) {\n\t\tOutput o = raytraceIteration(ray);\n\t\n        if (o.dis>1000.)\n        {\n           color += o.material.diffuse * reflectivity; \n           break;\n        }\n\t\tcolor += illumiate(o) * reflectivity;\n\t\t\n\t\tfloat l = length(ray.origin - o.origin) + 0.1;\n\t\tcolor -= 0.1 / l;\n\n\t\treflectivity *= o.material.reflectivity;\n        \n        if (reflectivity<0.)\n            break;\n\t\t\n\t\tray = Ray(o.origin + o.normal * 0.0001, reflect(normalize(o.origin - ray.origin), o.normal));\n\t}\n\t\n\treturn pow(clamp(color, 0.0, 1.0),vec3(1.2));\n\t//return pow(clamp(color, 0.0, 1.0),vec3(1.+.72*sin(iTime)));\n}\n\nRay getPrimaryRay(vec3 origin, vec3 lookat, in vec2 fragCoord ) {\n\tvec2 uv =   ((fragCoord.xy\n                   //+0.25*vec2(  //Temporal anti aliasing\n                   //       sin(float(iFrame)*0.5*PI),\n                   //       cos(float(iFrame)*0.5*PI))\n                  ) * 2.0 - iResolution.xy) / iResolution.xx;\n    \n\tvec3 forward = normalize(lookat - origin);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\t\n\tRay ray;\n\t\n\tray.origin = origin;\n\tray.direction = normalize(right * uv.x + up * uv.y + forward);\n\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tmakeScene();\n\t\n\tfloat xo = (iMouse.x * 2.0 / iResolution.x - 1.0) * PI;\n\tfloat yo = (0.5 - (iMouse.y / iResolution.y)) * 4.0 + 4.01;\n\t\n    float g2 = iTime + sin(iTime);\n    g2 *= 0.5;\n\teye = vec3(cos(g2 * 0.2 + xo) * 9.0, yo, sin(g2 * 0.2 + xo) * 14.0)* (1.5-.7*cos(g2*.3));\n    //eye += vec3(cos(g2*.1) * 1.0, sin(g2*.33)*1.0, sin(g2*.1) * 1.0);\n\t\n\tvec3 lookat = vec3(0.0, 2.0, 0.0);\n\t\n\tRay ray = getPrimaryRay(eye, lookat, fragCoord );\n\t\n\tvec3 color = raytrace(ray);\n\t\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}