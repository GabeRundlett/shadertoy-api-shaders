{
    "Shader": {
        "info": {
            "date": "1534600688",
            "description": "A simple random block geometric flythrough with a dark tomb feel. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt3cWl",
            "likes": 41,
            "name": "Random Block Passage",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "random",
                "block",
                "geometric"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2368
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRandom Block Passage\n\t--------------------\n\n    A simple random block geometric flythrough with a dark tomb feel. I see a lot of this \n\tkind of imagery on the net -- Usually, rendered in nice brightly lit pathtraced \n    still-image form with reflections and so forth. This one is just a practice run for \n    something more interesting I have in mind. \n\n\tI'll sometimes break the rule, but I try my best to get a scene running on my fast machine\n\tin fullscreen with reasonable efficiency. This one is borderline, but I'd imagine it'd\n\trun OK in the 800 by 450 window on a lot of systems. I could definitely get things running\n\tfaster, but wanted the code to at least be mildly legible, so have only performed minor\n\toptimization.\n\n\tI also wanted to keep the character count down to a dull roar, so the scene is pretty\n\tbasic. Although, it should still be mildy interesting... for about 15 seconds before you\n\tyawn and shut it down. :D\n\n*/\n\n// Maximum ray distance.\n#define FAR 80.\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n// Non-standard float to vec3 hash function.\nvec3 hash13(float n){ return fract(vec3(2097152, 262144, 32768)*sin(n)); }\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0); // Debug: Straight path.\n    \n    // Windy path.\n    vec2 a = vec2(sin(z*.055), cos(z*.07));\n    return vec2(a.x - a.y*.75, a.y*1.275 + a.x*1.125); \n}\n\n\n\n\n// Individual object IDs. Not used here.\n//vec4 aID;\n//float svObjID;\n\n/*\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float r){\n\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)) + r/2., 0.) + length(max(d + r/2., 0.)) - r;\n}\n\nfloat sBoxS(vec3 p, vec3 b){\n\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n*/\n\nfloat sBox(vec3 p, vec3 b){\n\n  return length(max(abs(p) - b, 0.));\n}\n\n\n// Individual tile scale. Values ranging from \".5\" to \"2.5\" look interesting, but it doesn't \n// really work for values outside that.\nconst float gSc = 1.5;\n\n// The overlapping random block distance field: In order to render repeat objects that either\n// sit up against one another, or slightly overlap, you have to render more than one cell to\n// avoid artifacts. Four cells need to be considered, which means rendering everything four \n// times. This would be better unrolled, tweaked, etc, but I think it reads a little better \n// this way. Anyway, I've explained the process in other examples, like the \"Jigsaw\"\n// example, and so forth.\n//\nfloat blocks(in vec3 p, float rndZ){\n\n    // Warp the XY plane a bit to give the scene an undulated look.\n    \n    // Box scale. If you change this, you might need to make box size changes, etc.\n    const float sc = gSc;\n    \n    // Cell centering.\n    p += sc*.5;\n    \n    // The initial distance. Sometimes, the number has to be smaller.\n    float d = 1e5;\n    \n    //objID = vec2(0);\n    \n    // Unrolling and tweaking would speed this up, but at the expense of readability.\n    // Hopefully, the compiler will do a bit of the work.\n    for (int i=0; i<=1; i++){ \n        for (int j=0; j<=1; j++){ \n\n            // The cell ID.\n            vec2 ip = floor(p.xy/sc - vec2(i, j)/2.)*sc + vec2(i, j)/2.*sc;\n\n            // Local cell position. I remember figuring these out a while back... \n            // I'll take my own word for it. :)\n            vec3 q = vec3((mod(p.xy + vec2(i, j)/2.*sc, sc) - sc/2.), p.z);\n\n            // Random cell number... to do some random stuff. :)\n            float rnd = (hash31(vec3(ip, rndZ))*15. + 1.)/64.;\n            \n            // Shifts the base of the objects to a level point.\n            q -= vec3(0, 0, -rnd);\n           \n            // IQ's unsigned box equation: If you don't need the negative surface values \n            // (no refraction, edging, etc), save some cycles and use this.\n            float obj = sBox(q, vec3(sc/4. - .02, sc/4. - .02, rnd));\n\n            // Alternate overlapping cylinders. Doesn't suit the scene.\n            //float obj = max(length(q.xy) - (sc/4. + .1), abs(q.z) - rnd);\n            \n            // Edged boxes. More expensive and doesn't really add to the scene..\n            //float obj = sBoxS(q, vec3(sc/4. - .02, sc/4. - .02, rnd)); // Outer box.\n            //obj = max(obj, -sBoxS(q + vec3(0, 0, rnd - .02/2.), vec3(sc/4. - .1, sc/4. - .1, .02))); // Inner.\n \n\t\t\t// Individual object ID. Not used here.\n            //objID = (obj<d)? ip : objID;\n\n            // Minimum of the four cell objects. Similar to the way Voronoi cells are handled.\n            d = min(d, obj);\n\n\n        }\n\t}\n  \n    \n    // Return the scene distance, and include a bit of ray shortening to avoid a few minor\n    // inconsistancies.\n    return d;\n    \n}\n\n\n// Ignoring the random blocks, this is a pretty simple scene. There's a large square tube with\n// variable sized repeat boxes dispersed through it, and a small square tube carved through it.\n// The surfaces are then coverd with random boxes. Simple in concept, but a little fiddly to\n// code. Nevertheless, not too taxing.\nfloat map(vec3 p){\n    \n    p.xy -= path(p.z); \n    \n    const float sc = 32.; // Section Z spacing.\n    float ipZ = floor(p.z/sc); // Unique section ID.\n    vec3 rnd3 = floor(vec3(4, 2, 4)*hash13(ipZ)); // Variable sized rooms.\n    \n    // We're using an \"abs\" operation to render two X, Y and Z walls at once, but we keep note\n    // of their polarity to feed to a random generator to give different patterns on each side.\n    vec3 sq = sign(p);\n\n \n    // Repeat Z sections.\n    vec3 q = vec3(p.xy, mod(p.z, sc) - sc/2.);\n    \n    vec3 walls = abs(q - vec3(2, .5, 0)) - vec3(5, 3, 6) - rnd3;\n    float s2 = walls.z;\n    \n    // Scene distance: Initially set to a base room structure.\n    float d = -max(max(walls.x, walls.y), walls.z); \n    \n    // Edging the walls out according to the individual tile scale.\n    walls -= gSc/2.;\n    \n    // Left and right random block walls.\n    float blX = blocks(vec3(q.yz, walls.x), sq.x);\n    // Top and bottom random block walls -- offset half a tile width, because I thought it looked\n    // more interesting that way.\n    float blY = blocks(vec3(q.xz - gSc/4., walls.y), sq.y);\n    // Front and back walls.\n    float blZ = blocks(vec3(q.xy, walls.z), ipZ);\n    \n    // Combine the walls with the existing room structure.              \n    d = min(d, min(min(blX, blY), blZ));\n    \n    // It'd be a much simpler example with no room sections, but less interesting.\n    // The repeat Z and randomness would have to be disabled, etc.\n    //d = min(d, min(blX, blY)); return d*.8;\n    \n    \n    /////\n    q = p;\n    // Left and right block walls in the small square tube.\n    float blXSm = blocks(vec3(q.yz - gSc/4., abs(q.x) - 1.5 - gSc/2.), sq.x);\n    // Top and bottom block walls in the small square tube.\n    float blYSm = blocks(vec3(q.xz, abs(q.y) - 1.5 - gSc/2.), sq.y);\n\n    q = abs(q);\n    \n    // Carve out the small square tube and apply the random block walls to its\n    // internal surface. The messy line below is equivalent to the following:\n    // float smTube = max(q.x - 1.5, q.y - 1.5);\n    // d = max(d, -smTube);\n    // d = min(d, max(min(blXSm, blYSm), -s2));\n    d = max(d, min(max(min(blXSm, blYSm), -s2), -max(q.x - 1.5, q.y - 1.5)));\n\n    \n    \n    // No individual object IDs used, so we're saving the cyles.\n    //aID.xyz = vec3(d, 1e5, 1e5);\n\n    \n    return d*.8;\n    \n \n \n}\n\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize(n + g*bf); // Bumped normal. \"bf\" - bump factor.\n    \n}\n*/\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break; // Alternative: .001*max(t*.25, 1.)\n        t += d;\n        \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n    // Note the wider sample spread for an antialiasing effect. It looks better in some situations, but\n    // far worse in others. Normally, something like \".001\" would be used.\n\tconst vec2 e = vec2(0.005, 0); \n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.005, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Basic soft shadows.\nfloat getShad(in vec3 ro, in vec3 n, in vec3 lp){\n\n    const float eps = .001;\n    \n\tfloat t = 0., sh = 1., dt;\n    \n    ro += n*eps*1.1;\n    \n    vec3 ld = (lp - ro);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    //t += hash31(ro + ld)*.005;\n    \n\tfor(int i = min(0, iFrame); i<24; i++){\n        \n    \tdt = map(ro + ld*t);\n        \n        sh = min(sh, 12.*dt/t);\n         \n \t\tt += clamp(dt, .02, .5);\n        if(dt<0. || t>lDist){ break; } \n\t}\n\n    return max(sh, 0.);\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat getAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    \n    for(int i = min(0, iFrame); i<5; i++){\n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(p + n*hr);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n        if(occ>1e5) break; // Fake break to help the compiler.\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    vec3 ro = vec3(0, 0, iTime*4.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n\t\n \n    // Light positioning. \n \tvec3 lp = ro + vec3(0., .25, 6); // Put it a bit in front of the camera.\n \tvec3 lp2 = ro + vec3(0., .125, 16); // Put it further in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\tlp2.xy += path(lp2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + (uv.x*rgt + uv.y*up)*FOV);\n    \n    // Fish eye lens.\n    //vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.15));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = r2( path(lk.z).x/32. )*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(ro, rd);\n    \n    // Individual scene object sorting. Not used here.\n    //svObjID = aID.x<aID.y && aID.x<aID.z? 0. : aID.y<aID.z? 1. : 2.;\n    //svObjID2 = objID;\n\t\n    // Initialize the scene color.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp);\n        \n        \n        // Texture positioning.\n        const float txSc0 = .25; // Texture scale.\n        vec3 txP = vec3(sp.xy - path(sp.z), sp.z); // Line it up with the camera path. Optional.\n        \n        // Texture based bump mapping.\n        //sn = doBumpMap(iChannel0, txP*txSc0, sn, .01);\n        \n        // Shadows and ambient occlusion. We're only including shadows from the back light.\n        // Shadows from both lights would be better, but it's a little expensive, so the idea is \n        // to trick the user into a sense of realistic lighting, and I believe the back light\n        // contributes more, so... Computer rendering is far from an exact science. :)\n\t    float ao = getAO(sp, sn);\n        float sh = getShad(sp, sn, lp2);\n        sh = min(sh + ao*.3, 1.);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp - sp;\n\t    vec3 ld2 = lp2 - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), .001);\n \t    float distlpsp2 = max(length(ld2), .001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    ld2 /= distlpsp2;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.5/(1. + distlpsp*distlpsp*.25); // + distlpsp*distlpsp*0.025\n\t    float atten2 = 3./(1. + distlpsp2*distlpsp2*.25); // + distlpsp*distlpsp*0.025\n\n    \t\n    \t// Ambient light.\n\t    float amb = ao*.35;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        float diff2 = max( dot(sn, ld2), 0.);        \n        //diff = pow(diff, 2.)*2.;\n        //diff2 = pow(diff2, 2.)*2.;\n\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 32.);\n\n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = clamp(dot(sn, rd) + 1., .0, 1.);\n        \n        // Object texturing and coloring.\n        vec3 oCol = tex3D(iChannel0, txP*txSc0, sn);\n        oCol = smoothstep(0., .5, oCol);\n\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        col = (oCol*(diff*vec3(.4, .6, 1) + amb + vec3(.4, .6, 1)*spec*4.))*atten; // Light one.\n        col += (oCol*(diff2*vec3(1, .4, .2) + amb + vec3(1, .4, .2)*spec2*4.))*atten2; // Light two.\n        //col += oCol*vec3(1, .05, .15)*pow(fre, 4.)*2.*(atten + atten2);\n\n \n\t    // Applying the ambient occlusion and shadows.\n        col *= ao*sh;\n\t\n\t}\n       \n    // Blend the scene with some background light. Interesting, but I wanted more of a dark tomb kind of feel.\n    //col = mix(col, vec3(1.8, 1, .9), smoothstep(.2, .99, t/FAR));\n    \n    // Cooler colors... as in, less warm. :)\n    //col *= vec3(.85, .95, 1.25);\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col = mix(col, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .0625)));\n\n  \n    // Clamp and present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}