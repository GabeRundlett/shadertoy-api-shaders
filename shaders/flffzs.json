{
    "Shader": {
        "info": {
            "date": "1651437572",
            "description": "Daily shading - Playing around more with just motion and ended up here / Mac folks - I have an issues - see comments.. blah! ",
            "flags": 0,
            "hasliked": 0,
            "id": "flffzs",
            "likes": 22,
            "name": "Soothing Movement II",
            "published": 3,
            "tags": [
                "raymarching",
                "domain",
                "repetition",
                "balls",
                "looping"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Soothing Motion II\n    05/01/22 | byt3_m3chanic\n\n    Daily shading - Playing around more with just motion and ended up here. \n    The balls are an illusion with the ID's rolling up 1 in the y while the\n    animation loops in place as you move over the scene.\n    \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define MIN_DIST    .0001\n#define MAX_DIST    75.\n\n#define PI          3.1415926\n#define PI2         6.2831853\n\n//global\nvec3 FC = vec3(0.596,0.812,0.941);\nvec3 hp=vec3(0),hitPoint=vec3(0);\nvec2 gid=vec2(0), sid=vec2(0);\nfloat glow;\nfloat zoom = 10.;\nfloat maptime,time,fractTime,modTime,iss;\nmat2 crt1,crt2;\n\n//constants\nconst float space = 9.5;\nconst float hlf = space/2.;\nconst float dbl = space*2.;\nconst vec3 bsize = vec3(3,5,3);\nconst vec3 wsize = vec3(1,2,1.65);\n    \nconst float c = 1.5;\nconst float c2=c/2.;\n    \n// Helper functions for building smin stairs\n// http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n, u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {return -fOpUnionStairs(-a, b, r, n);}\n\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@Dave_Hoskins \n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//@iq for all the SDF's\nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\tfloat d =length(p.xy)-r;\n\treturn max(d,abs(p.z)-h);\n}\n\nvec2 map(vec3 p, float sg) {\n\tvec2 res = vec2(1e5,0);\n    vec3 q = p-vec3(0,-1.25,maptime);\n    vec3 r = q;\n    \n    float flr = q.y;\n    if(flr<res.x) {\n        res = vec2(flr,1.);\n        hp=q;\n    }\n    \n    float qd = floor((q.z+hlf)/space);\n    q.z=mod(q.z+hlf,space)-hlf;\n\n    float pole = min(cyl(q.zxy-vec3(4,5,0),.045,4.),length(q-vec3(5,4,4))-.1 );\n    if(pole<res.x) {\n        res = vec2(pole,3.);\n        hp=q;\n    }\n    \n    vec3 nq=q;\n    float wave = .5*sin(nq.z*2.35+maptime);\n    float flo = clamp(2.-(nq.z*.5),0.,1.);\n    wave = mix(0.,wave,flo);\n    nq.x+=wave;\n    \n    float flag = box(nq-vec3(5,3.35,3),vec3(.03,.5,1));\n    if(flag<res.x) {\n        res = vec2(flag,6.);\n        hp=nq;\n        gid=vec2(qd,1.);\n    }\n\n    q.x = abs(q.x)-bsize.x;\n\n    float wall = box(q,vec3(.25,bsize.y,bsize.z));\n    float roof = box(q-vec3(-(bsize.x-.25),bsize.y-.5,0.),vec3(3.,.1,bsize.z));\n    \n    vec3 q2 = q, q3 = q;\n    \n    q2.z = abs(q2.z)+.6;\n    float window = box(q2-vec3(0,wsize.y/2.,0),vec3(.4,wsize.x,wsize.z));\n    window=min(cyl(q2.zyx-vec3(0,wsize.y,0.),wsize.z,.4),window);\n    wall = min(box(q2-vec3(.3,bsize.y/2.,bsize.z),vec3(.1,bsize.y/2.,.05)),wall);\n\n    float lits = length(q2-vec3(.575,4.65,2.5))-.05;\n    if (lits<res.x && sg==1.) {\n        res = vec2(lits,4.);\n    \tglow += .0005/(.000025+lits*lits);\n    }\n\n    float qi = floor((q3.z + c2)/c);\n    q3.z = q3.z-c*clamp(round(q3.z/c),-2.,2.);\n    float tip1 = box(q3-vec3(-.1,bsize.y,0),vec3(.08,.45,.5));\n\n    float tip=min(cyl(q2.zyx-vec3(0,bsize.y,-.1),1.,.08),tip1);\n    roof = min(tip,roof);\n    \n    float mainwall = fOpDifferenceStairs(wall,window,.25,3.);\n    float building = fOpUnionStairs(mainwall,roof,.25,3.);\n\n    if(building<res.x) {\n        res = vec2(building,2.);\n        hp=q3;\n        gid=vec2((tip1>res.x)?qd:qd-.5,1.);\n    }\n    \n    vec2 id = vec2(\n        floor((r.x+space)/dbl),\n        floor((r.z+hlf)/space)\n        );\n        \n    float hs,fs;\n    if(modTime<2.){\n      \ths = hash21(id.yy);\n        r.x += (hs<.5) ? fractTime : -fractTime; \n    } else {\n        r.z += -fractTime;\n    }\n    \n    id = vec2(floor((r.x+space)/dbl),floor((r.z+hlf)/space));\n    id.y-=iss;\n    r.xz=vec2(mod(r.x+space,dbl)-space,mod(r.z+hlf,space)-hlf);\n    r-=vec3(0,1,0);\n    \n    if(modTime<2.){\n        r.xy*= (hs<.5) ? crt1 :  crt2 ;\n    } else {\n        r.zy*= crt2 ;\n    }\n    \n    float ball = length(r)-.9;\n    if(ball<res.x) {\n        res = vec2(ball,5.);\n        hp=r;\n        gid=vec2(id);\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p,0.).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n    );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p,1.);\n        if(abs(t.x)<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.5:t.x;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 hue(float t) { \n    vec3 d = vec3(0.929,0.690,0.027);\n    return .45+.4*cos( PI2*t*vec3(0.984,0.914,0.914)+d ); \n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d, vec2 F) {\n        \n    vec3 C=vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p,hit,80);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n    sid=gid;\n    if(hit) {\n  \n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(5.5,8,8.5);\n        vec3 l = normalize(lpos);\n        float diff = clamp(dot(n,l),0.,1.);\n       \n        float shdw = 1.;\n        for( float t=.01;t<18.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = .001; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>18. ) break;\n        }\n        diff = mix(diff,diff*shdw,.35);\n\n        vec3 ret = reflect(normalize(lpos),n);\n        float spec = .75 * pow(max(dot(normalize(p-ro),ret),0.),24.);\n        vec3 h = vec3(.25);\n\n        if(m==1.) {\n            vec2 f = hitPoint.xz;\n            h=FC;\n            \n            if(abs(f.x)<4.5) {\n                h=vec3(.5);\n                vec2 ff=fract(hitPoint.xz*.77)-.5;\n                if(ff.x*ff.y>0.)h=vec3(.2);\n            }\n            \n            if(abs(f.x)>4.5&&abs(f.x)<5.5) h=vec3(.15);\n\n            ref = h*.3;\n        }\n        \n        if(m==2.||m==6.) {\n            h=hue(hash21(sid+m)*.982);\n            ref = h*.3;\n        }\n        \n        if(m==5.) {\n            hitPoint.xy *= rot(1.5707);\n            vec3 f = fract(hitPoint*2.)-.5;\n            f.x=abs(f.x)-.2;\n            h=mod(sid.y,2.)<1. ? vec3(.01):vec3(.9);\n            ref=vec3(.1);\n            if(f.x*1.>0.) {h=hue(hash21(vec2(sid.y,25.))*3.13);  ref = h;}\n           \n        }\n        \n        if(m==6.) {\n            vec2 f = fract(hitPoint.zy*3.5)-.5;\n            h=vec3(.009);\n            if(f.x*f.y>0.)h=hue(hash21(sid+12.)*3.5);\n            ref = h;\n        }\n        \n        C = (m!=2.) ? h * diff + min(shdw,spec):h * diff;\n        C = mix(C,vec3(.90,.49,.82)*vec3(glow*1.15),clamp(.0,1.,glow)); \n        //if(bnc<2) C = mix(C,FC, 1.-exp(-.001*d*d*d));//slows down some\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n        \n    } else {\n        C=FC;\n    }\n\n    return clamp(C,vec3(.0001),vec3(1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 F) { \n    vec3 col = vec3(.00);\n    //precal\n    time = T*.5; \n    float ms = 3.;\n    float mt = 1./ms;\n    modTime = mod(time,ms);\n    //time for ids\n    float os = floor(modTime);\n    //weird bug - IOS needs +1 to make work\n    //float ios = floor(time+1.);\n    float ios = floor(time);\n    iss = floor(ios*mt)-1.;\n\n    fractTime = modTime<2.? (fract(time) * (space))+(space*os) : fract(time) * (space);\n    maptime = time*5.;\n    //ball rotations\n    crt1 = rot(modTime*PI2);\n    crt2 = rot(-modTime*PI2);\n    \n    vec2 uv = (-R.xy + 2. * (F)) / R.x;\n    \n    // mouse //\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*4.-2.)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*2.-1.)*PI;\n    zoom+=x;\n    // ro + rd\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n    \n    FC=hue((uv.y+125.)*.25);\n    \n    mat2 rx =rot(.425);\n    mat2 ry =rot(-.98+y);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0.;\n\n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d,F);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0) fA += d*.2;\n    }\n\n    C = mix(C,FC, 1.-exp(-.002*fA*fA*fA));\n    clamp(C,vec3(0),vec3(1));\n    C = pow( C, vec3(0.4545) );\n\n    fragColor = vec4(C, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}