{
    "Shader": {
        "info": {
            "date": "1599769232",
            "description": "The result of the first day of my shader workshop I am writing for work.\nIt is going to be a workshop aimed at teaching my coworkers the basics of shaders\nThe goal is to illustrate basic shape drawing, calculating random values, and general shader stuff",
            "flags": 0,
            "hasliked": 0,
            "id": "wljBWG",
            "likes": 4,
            "name": "Helios Shader Workshop - Day 1",
            "published": 3,
            "tags": [
                "helios"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "//smoothstep takes in a value and smoothly interpolates it between 0-1 based on the min and max you supply it\n//here we are using it to smoothly step between 0-1 over the distance of a pixel (calculated by size*3./iResolution.y)\n//this can be applied when drawing shapes to get crisp, anti-aliased edges\n#define SS(U) smoothstep(0.,size*3./iResolution.y,U)\n#define TAU 3.1415927*2.0\n#define size (7.5+(cos(iTime/10.0)*2.5))\n\n//random value based on a vector 2\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy, vec2(12190.5283, 57894.23784)))*(834.2831)+.5);\n}\n\n//rotation matrix\nmat2 rot(float a) //0 through Tau\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//drawing a circle:\n//we have a point in space for the center of our circle\n//we measure the distance from our coordinate to the center of the circle\n//if the distance is greater than the radius, we know we are outside of the circle\n//so we subtract the radius of the circle from the distance we calculated, if we are >0\n//we know we are outside of the circle\nfloat circle(vec2 p, float r)\n{\n    return SS(length(p)-r);\n}\n\nfloat renderCell(vec2 p, float randValue)\n{\n    //start with white\n    float color = 1.0;\n    \n    //every cell has a different random number, so we can fill each cell based on our random number\n    //do random maths to select some cells\n    if(mod(ceil(randValue*10.),4.0)==0.){ //MOVING CIRCLE\n        \n        //calculate a random offset for our circle\n        //based off of time and the random value we generated for our ID\n        vec2 offset = vec2(cos(randValue*iTime*sign(fract(randValue*1293.874)-.5)-randValue*10.0),\n                           sin(randValue*iTime*sign(fract(randValue*12.3)-.5)+randValue*30.0))/4.0;\n        \n        //draw a circle with a random offset between 0.01 and 0.3\n        color*=circle(p+offset,mix(0.01,0.3,randValue));\n    }\n    else if(mod(ceil(randValue*3.0),2.0)==0.){//ROTATING LINE\n        //rotate our coordinate space by using the rotation matrix and randomize the rotation based on time and our randValue\n        vec2 ruv = p*rot(3.1415927*2.0+randValue*iTime*sign(randValue-.5));\n        \n        //with the circle, we were measuring the x and the y components in our distance from one point to another\n        //if we just measure in the X or the Y axis, then we can draw a line by subtracting half of the width of the line\n        //and if we are > 0, we are outside of the line\n        color*=(SS(length(ruv.x)-.1));\n    }\n    else if(mod(floor(randValue*52.8),2.0)==0.)//SWIRL\n    {   \n        //calculate the polar coordinate space by using atan, the y value is measured by the distance from the center\n        vec2 puv = vec2(atan(p.x,p.y),length(p));\n        \n        //when we move the x axis, our texture rotates around the center of the coordinate space\n        puv.x+=(randValue+.25)*iTime*sign(randValue*10.0);\n        \n        //if we offset the x coordinate space by the y coordinate space, then we get the swirly look\n        //(remember y goes up as we go away from the center of the coordinate space\n\t\tcolor*=((cos((puv.x-puv.y*cos(randValue*10.0)*20.0)*2.0)));\n    }else{//SQUARE\n        //rotate our space randomly\n        vec2 ruv = p*rot(TAU*randValue+randValue*iTime*sign(randValue-.96));\n        \n        //drawing a square is the same thing as drawing a line in the X and Y directions and then taking the space that overlaps\n        color*= (1.0-((1.0-SS(length(ruv.y)-.1))*(1.0-SS(length(ruv.x)-.1))));\n    }\n    \n    //make sure we don't go above 1.0 (causes anti-aliasing and artifacts in some instances)\n    return min(color,1.0);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2.0*f-iResolution.xy)/iResolution.y;\n    \n    //scale up our coordinates, store the scaling for anti-aliasing our smoothstep\n    p*=size;\n    \n    vec2 id = floor(p);\n    \n    //our coordinates from -.5-.5 in each cell\n    p=fract(p)-.5;\n    \n    //get a random value based on our ID\n    float randValue = rand(id);\n    \n    //set the base color of our cell based on the random value, make sure we dont set it black\n    vec3 col = max(vec3(.1),vec3(randValue));\n    \n    //renderCell will return 0-1 based on our random shape math and the random value we pass it\n    //if we multiply our color by it, we can draw shapes while maintaining the base color that we set in the line above\n    col*=renderCell(p, randValue);\n    \n    // Output to screen and add the border effect to each cell\n    c.rgb = col -(randValue*20.)*(pow(abs(p.x),5.0)+pow(abs(p.y),5.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}