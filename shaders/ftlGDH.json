{
    "Shader": {
        "info": {
            "date": "1622008425",
            "description": "For Jeff staple T-shirts design contest",
            "flags": 32,
            "hasliked": 0,
            "id": "ftlGDH",
            "likes": 18,
            "name": "staple pigeon on the shit",
            "published": 3,
            "tags": [
                "pigepn"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "vec2 glitchEfect(vec2 uv, float shift) {\n    float glitchBlock = 10.0;\n    vec2 uv2 = fract(uv*glitchBlock)-0.5;\n    vec2 id = floor(uv2);\n    \n    vec2 n2 = fract(sin(id*123.456)*789.125);\n    n2+=dot(id.x,id.y*567.89);\n    float n = fract(n2.x+n2.y);\n    \n    if(mod(iTime,1.0)<0.5){\n        float glitchDist = 0.01;\n        float glitchTime = iTime*19.0;\n        uv.x-=(fract(floor(uv.y+n2.y*glitchBlock)*glitchTime)*glitchDist);\n        uv.y-=(fract(floor(uv.x+n2.x*glitchBlock)*glitchTime)*glitchDist);\n        uv.x+=sin(glitchTime*2.0)*shift;\n        uv.x+=sin(floor(uv.y*glitchBlock*1.2)*iTime*20.)*glitchDist;\n        uv.y+=sin(floor(uv.x*glitchBlock*1.2)*iTime*21.)*glitchDist;\n    }\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 r_uv = glitchEfect(uv,0.0);\n    vec2 g_uv = glitchEfect(uv,0.015);\n    vec2 b_uv = glitchEfect(uv,0.025);\n    \n\n    float r = texture(iChannel0,r_uv).r;\n    float g = texture(iChannel0,g_uv).g;\n    float b = texture(iChannel0,b_uv).b;\n    \n    vec3 col = vec3(r,g,b);\n    vec2 size = vec2(1.0,0.03);\n    \n    float t = mod(iTime,1.0);\n    if(t<0.5){\n        for(float i = 1.;i<6.0; i++){\n            vec2 pos = p;\n            pos.y+=sin(floor(iTime*2.1*i))*1.0;\n            size.x = 0.5+abs(cos(floor(iTime*2.1*i))*1.5);\n            size.y = 0.02+sin(floor(iTime*2.1*i))*0.03;\n            float d = smoothstep(0.,0.001,-max(abs(pos.x)-size.x,abs(pos.y)-size.y));\n            col = mix(col,vec3(b,r,g)*1.05,d); \n        }\n    }\n    \n    //fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n    fragColor = vec4(col*1.3,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 80.\n#define SURF_DIST .001\n#define EDGE_WIDTH 0.02\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define PI 3.141592653589793\n\n// noise and fbm function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat edge;\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2, float k){\n    vec4 res1 = val1;\n    vec4 res2 = val2;\n    res1.w = smin(val2.w,val1.w,k);\n    res2.w = smin(val1.w,val2.w,k);\n    return (val1.w < val2.w)?res1:res2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat foot(vec3 p) {\n    vec3 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.1;\n    p*=matRotateY(radians(-30.0));\n    float d = sdEllipsoid(p,vec3(0.05,0.05,0.15));\n    p = prevP;\n    float d2 = sdEllipsoid(p-vec3(0.0,0.0,-0.08),vec3(0.05,0.05,0.15));\n    d = smin(d,d2,0.02);\n    d2 = sdEllipsoid(p-vec3(0.0,0.0,0.12),vec3(0.05,0.05,0.15));\n    d = smin(d,d2,0.02);\n    p*=matRotateX(radians(-20.0));\n    d2 = sdEllipsoid(p-vec3(0.0,0.2,0.05),vec3(0.05,0.2,0.05));\n    d = smin(d,d2,0.03);\n    return d;\n}\n\nfloat leg(vec3 p) {\n    vec3 prevP = p;\n    p*=matRotateX(radians(-20.0));\n    float d = sdRoundCone(p-vec3(0.0,0.2,0.05),0.05,0.15,0.3);\n    return d;\n}\n\nfloat body(vec3 p){\n    vec3 prevP = p;\n    p-=vec3(0,0.8,-0.2);\n    const float k = 1.5; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    float d = sdEllipsoid(q,vec3(0.5,0.4,0.9));\n    return d;\n}\n\nfloat tail(vec3 p){\n    vec3 prevP = p;\n    \n    float d = sdEllipsoid(p-vec3(0,0.8,0.7),vec3(0.3,0.12,0.7));\n    p*=matRotateX(radians(-15.0));\n    float d2 = sdEllipsoid(p-vec3(0,0.85,0.7),vec3(0.3,0.12,0.8));\n    return smin(d,d2,0.1);\n}\n\nfloat head(vec3 p){\n    vec3 prevP = p;\n    p*=matRotateX(radians(10.0));\n    float d = sdRoundCone(p-vec3(0,1.3,-0.28),0.3,0.23,0.5);\n    p = prevP;\n    float d2 = length(p-vec3(0,1.6,-0.65))-0.25;\n    d = smin(d,d2,0.05);\n    return d;\n}\n\nfloat wing(vec3 p){\n    vec3 prevP = p;\n    p*=matRotateX(radians(-10.0))*matRotateY(radians(5.0));\n    \n    float d = sdEllipsoid(p-vec3(0.05,1.0,-0.1),vec3(0.1,0.25,0.65));\n    p*=matRotateX(radians(10.0));\n    float d2 = sdEllipsoid(p-vec3(-0.05,1.05,0.2),vec3(0.1,0.25,0.65));\n    return smin(d,d2,0.05);\n}\n\nfloat mouth(vec3 p){\n    vec3 prevP = p;\n    float d = sdEllipsoid(p-vec3(0,1.6,-0.95),vec3(0.1,0.04,0.1));\n    return d;\n}\n\nfloat mouth2(vec3 p){\n    vec3 prevP = p;\n    float d = sdCappedTorus(p-vec3(0,1.55,-0.91),vec2(0.1,0.04),0.13,0.02);\n    return d;\n}\n\nfloat eye(vec3 p){\n    vec3 prevP = p;\n    p.y*=1.3;\n    float d = length(p-vec3(-0.02,1.74,-0.76))-0.05;\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.25;\n    p*=matRotateY(radians(-20.0));\n    float fd = foot(p);\n    float ld = leg(p);\n    \n    p = prevP;\n    p*=matRotateX(radians(-20.0));\n    float bd = body(p);\n    p = prevP;\n    float hd = head(p);\n    float td = tail(p);\n    \n    p.x = abs(p.x);\n    p.x-=0.39;\n    float wd = wing(p);\n    \n    p = prevP;\n    float md = mouth(p);\n    float md2 = mouth2(p);\n    \n    p.x = abs(p.x);\n    p.x-=0.16;\n    p.y-=0.4;\n    p.z+= 0.01;\n    float ed = eye(p);\n    \n    p = prevP;\n    p*=2.0;\n    p.x = abs(p.x);\n    p.x-=0.37;\n    p.y-=2.16;\n    p.z+= 0.84;\n    float ed2 = eye(p);\n    \n    p = prevP;\n    p.x*=fbm(p*1.5)*4.5;\n    p.z*=fbm(p*2.6)*4.0;\n    p.x*=0.6;\n    p.y*=12.0;\n    p.y+=1.7;\n    float shit = (length(p-vec3(0.0,0.0,0.3))-0.7)*0.3;\n    \n    float n = hash12(p.xz*10.0)*0.12;\n    vec4 resFoot = vec4(vec3(0.9,0.5,0.4)+n,fd);\n    vec4 resLeg = vec4(vec3(0.5,0.5,0.5)+n,ld);\n    vec4 resBody = vec4(vec3(0.8,0.8,0.8)+n,bd);\n    vec4 resHead = vec4(vec3(0.4,0.4,0.45)+n,hd);\n    vec4 resTail = vec4(vec3(0.2,0.2,0.2)+n,td);\n    vec4 resWing = vec4(vec3(0.55,0.6,0.6)+n,wd);\n    vec4 resMouth = vec4(vec3(1.0,0.5,0.6)+n,md);\n    vec4 resMouth2 = vec4(vec3(1.0)+n,md2);\n    vec4 resEye = vec4(vec3(1.0,0.6,0.6)+n,ed);\n    vec4 resEye2 = vec4(vec3(0.1)+n,ed2);\n    vec4 resShit = vec4(vec3(0.9)+n,shit*0.6);\n    \n    vec4 model = combine(resFoot,resLeg,0.03);\n    model = combine(model,resBody,0.1);\n    model = combine(model,resHead,0.07);\n    model = combine(model,resTail,0.1);\n    model = combine(model,resWing,0.1);\n    model = combine(model,resMouth,0.1);\n    model = combine(model,resMouth2,0.02);\n    model = combine(model,resEye,0.07);\n    model = combine(model,resEye2,0.0);\n    model = combine(model,resShit,0.0);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(3,5,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.2;\n    \n\n    \n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3.5, 0.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0));\n    ro.xz *= Rot(radians((sin(t*0.2)*80.0)));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.9,0), 1.0);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        \n    } else {\n        // background\n        //col =.84*max(mix(vec3(1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n        col = vec3(1.0);\n    }\n    \n    col = mix(col,vec3(0.1,0.1,0.1),edge);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}