{
    "Shader": {
        "info": {
            "date": "1723150897",
            "description": "cross eyed 3D ray marching fractal\ninstructions at top of source code.",
            "flags": 48,
            "hasliked": 0,
            "id": "Mf2cWz",
            "likes": 1,
            "name": "Knighty in Crystal",
            "published": 3,
            "tags": [
                "raymarching",
                "3dfractal"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 93
        },
        "renderpass": [
            {
                "code": "/* Key Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<X>   : toggle animation\n<I>   : toggle spherical inversion\n<S>   : toggle cross eyed stereo\n<Q>   : toggle secondSurface\n<W>   : toggle secondSurface refract vs reflect\n<Spc> : reset\n\nNote: toggles off by default\n\nNote: hold down <Shift> then drag mouse to affect camera.xy regardless of focus.\nNote: hold down <Alt><Shift> then drag mouse to affect aim.xy regardless of focus.\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1  \nHold down <Z> for change Amount * 10. \nHold down both <A><Z> for change Amount * 50. \n\nCross-eyed 3D \nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n\nSecond Surface\nRaymarching algorithm calculates a unique \"ray\" from the camera to every pixel of the image.\nRaymarching algorithm \"marches\" along each ray, until the DE() function says to go no farther.\nWhen \"second surface\" is enabled we ask the raymarching to continue past the first stopping point,\nto instead continue marching until a second (or third,fourth) stopping point is reached, \nthereby exposing objects inside the original surface.\nssDistance : how far to jump ahead on the ray before beginning the search for the second surface.\nssAngle    : how much to change the aim of the ray before continuing\nssAmount   : if refraction is enabled ( <W> toggle), how much to refract the ray before continuing\nssMix      : how to blend the color of the 1st surface vs. the second.\n\nbased on: https://www.shadertoy.com/view/lstyR4\ncrystal effect based on: \"crystal slug\",  https://www.shadertoy.com/view/4tjXRm\n*/\n\nstruct Dataset {\n    // DE() params\n    float shape;\n    vec4 vmin,vmax;\n    \n    vec3 camera,aim;    \n    vec3 invpos;\n    float invradius;\n    float invangle;    \n\n    int maxsteps;\n    float bright,contrast;\n    int ssIterations;\n    float ssDistance,ssAngle,ssAmount,ssMix;\n    float epsilon;\n    float fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n    float textureF;\n    \n    float parallax;  // adjust for best stereo effect 0 ... 0.2\n\n    // calculated params \n    vec3 direction;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n    float depth;\n    int iter;\n    \n    int focus,row,displayCount;\n    bool animationEnable,stereoEnable,inversionEnable,secondsurfaceEnable,refractEnable;\n    vec3 viewVector,sideVector,topVector;\n};\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos,inout Dataset data) {\n   float k, scale = 1.;\n   vec3 ot;\n    \n\tfor (int n = 0; n < 100; ++n)\t{\n\t\tif(n >= data.maxsteps) break;\n        pos = 2. * clamp(pos, data.vmin.xyz, data.vmax.xyz) - pos;\n        k = max(data.vmin.w / dot(pos,pos), data.shape);\n        pos *= k;\n        scale *= k;\n    }\n    \n    float rxy = length(pos.xy);\n    return .7 * max(rxy - data.vmax.w, rxy * pos.z / length(pos)) / scale;\n}\n\n// --------------------------------------------------------\n// distance estimation function wrapped by spherical inversion code.\n\nfloat DE_plusSpherical(vec3 pos,inout Dataset data) {\n    if(data.inversionEnable) {\n        pos = pos - data.invpos;\n        float r = length(pos);\n        float r2 = r*r;\n\t\tfloat radius2 = data.invradius * data.invradius;\n        pos = (radius2 / r2) * pos + data.invpos;\n        \n        float an = atan(pos.y,pos.x) + data.invangle;\n        float ra = length(pos.xy);\n        pos.x = cos(an) * ra;\n        pos.y = sin(an) * ra;\n\t\t\t\t\n        float de = DE(pos,data);\n        return r2 * de / (radius2 + r * de);\n    }\n    \n    return DE(pos,data);\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal(inout Dataset data) {\n    float ex = data.epsilon;\n    float ey = -ex;\n    vec3 pos = data.position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE(t1,data);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE(t2,data);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE(t3,data);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE(t4,data);\n\n    data.normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n// viewVectors already calculated in Buffer A\n\nvoid setDirection(vec2 fragCoord,inout Dataset data) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(data.stereoEnable) {\n        vec3 soffset = data.sideVector * data.parallax;\n\t\txsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n\t\t\tsrcP.x -= xsize;      // base 0  X coordinate\n\t\t\tdata.camera -= soffset;// adjust for right side parallax\n\t\t}\n\t\telse {\n\t\t\tdata.camera += soffset;// adjust for left side parallax\n\t\t}\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    data.direction = normalize(data.viewVector + vPos.x * data.sideVector + vPos.y * data.topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 20.0;\n\nvoid rayMarch(inout Dataset data) {\n\tvec3 position = data.camera;\n\tfloat distance;\n\tdata.iter = 0;\n\tdata.depth = MIN_DIST;\n \t\n\tfor(int i = 0;i < 100;++i) {\n\t\tdistance = DE_plusSpherical(position,data);\n        if(abs(distance) < MIN_DIST || data.depth > MAX_DIST) break;\n        data.iter += 1;\n\t\t\n        data.depth += distance;\n        position = data.camera + data.direction * data.depth;\n  }\n}\n\n// --------------------------------------------------------\n\nvoid displayData(inout Dataset data,inout vec4 fragColor, in vec2 fragCoord, int offset) {\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(36,36);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.7, 1) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n\n    if(offset == 1) {\n        t.color.xyz = vec3(0.);\n        t.fragCoord += vec2(-2.,3.);\n    }\n    \n    declString(gap, 1, (cSp));\n\n    String str;\n    float value = 0.;\n\n    switch(data.focus) {\n        case  0 : setString(str,5,(cS,ch,ca,cp,ce)); value = data.shape; break;\n        case  1 : setString(str,4,(cX,cm,ci,cn)); value = data.vmin.x; break;\n        case  2 : setString(str,4,(cX,cm,ca,cx)); value = data.vmax.x; break;\n        case  3 : setString(str,4,(cY,cm,ci,cn)); value = data.vmin.y; break;\n        case  4 : setString(str,4,(cY,cm,ca,cx)); value = data.vmax.y; break;\n        case  5 : setString(str,4,(cZ,cm,ci,cn)); value = data.vmin.z; break;\n        case  6 : setString(str,4,(cZ,cm,ca,cx)); value = data.vmax.z; break;\n        case  7 : setString(str,4,(cW,cm,ci,cn)); value = data.vmin.w; break;\n        case  8 : setString(str,4,(cW,cm,ca,cx)); value = data.vmax.w; break;\n        case  9 : setString(str,7,(cM,ca,cx,cS,ct,ce,cp)); value = float(data.maxsteps); break;\n        case 10 : setString(str,6,(cB,cr,ci,cg,ch,ct)); value = data.bright; break;\n        case 11 : setString(str,8,(cC,co,cn,ct,cr,ca,cs,ct)); value = data.contrast; break;\n        case 12 : setString(str,7,(cF,co,cg,cD,ci,cs,ct)); value = data.fogDistance; break;\n        case 13 : setString(str,9,(cF,co,cg,cA,cm,co,cu,cn,ct)); value = data.fogAmount; break;\n        case 14 : setString(str,8,(cF,co,cg,cC,co,cl,co,cr)); value = data.fogColor; break;\n        case 15 : setString(str,8,(cT,ce,cx,ct,cu,cr,ce,cF)); value = data.textureF; break;\n \n        case 18 : setString(str,7,(cC,ca,cm,ce,cr,ca,cX)); value = data.camera.x; break;\n        case 19 : setString(str,7,(cC,ca,cm,ce,cr,ca,cY)); value = data.camera.y; break;\n        case 20 : setString(str,7,(cC,ca,cm,ce,cr,ca,cZ)); value = data.camera.z; break;\n        case 21 : setString(str,4,(cA,ci,cm,cX)); value = data.aim.x; break;\n        case 22 : setString(str,4,(cA,ci,cm,cY)); value = data.aim.y; break;\n        case 23 : setString(str,4,(cA,ci,cm,cZ)); value = data.aim.z; break;\n        case 24 : setString(str,7,(cI,cn,cv,cP,co,cs,cX)); value = data.invpos.x; break;\n        case 25 : setString(str,7,(cI,cn,cv,cP,co,cs,cY)); value = data.invpos.y; break;\n        case 26 : setString(str,7,(cI,cn,cv,cP,co,cs,cZ)); value = data.invpos.z; break;\n        case 27 : setString(str,6,(cI,cn,cv,cR,ca,cd)); value = data.invradius; break;\n        case 28 : setString(str,8,(cI,cn,cv,cA,cn,cg,cl,ce)); value = data.invangle; break;\n\n        case 29 : setString(str,6,(cS,cS,cd,ci,cs,ct)); value = data.ssDistance; break;\n        case 30 : setString(str,7,(cS,cS,ca,cn,cg,cl,ce)); value = data.ssAngle; break;\n        case 31 : setString(str,8,(cS,cS,ca,cm,co,cu,cn,ct)); value = data.ssAmount; break;\n        case 32 : setString(str,5,(cS,cS,cm,ci,cx)); value = data.ssMix; break;\n    }\n\n    printInt(data.focus+1,t);\n    printString(gap,t);\n    printString(str,t);\n    printString(gap,t);\n    printFloat(value, t);\n    drawText(t, iChannel3, fragColor);\n}   \n\n// animation routines ----------------------------------------\n\nvoid cycleValue(int pDataIndex,inout float value, float vmin,float vmax, float speed) {\n    float ratio = 0.5 + 0.5 * cos(iTime * speed);  // 0 ... 1    \n    value = clamp(vmin + (vmax - vmin) * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);    \n}\n\nvoid cycleValue2(int pDataIndex,inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = clamp(baseValue-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);  \n}\nvoid cycleValue2b(int pDataIndex,inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + sin(iTime * speed);  // 0 ... 2\n    value = clamp(baseValue-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);  \n}\n\nvoid cycleValue3(int pDataIndex,inout float value, float baseValue, float amount, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    float deviation = baseValue * amount * 0.5;    \n    value = clamp(baseValue-deviation + deviation * ratio,pData[pDataIndex].vmin, pData[pDataIndex].vmax); \n}\n\nvoid cycleValue3Vec3(int pDataIndex,inout vec3 value, vec3 baseValue, float amount, float speed) {\n    for(int i=0;i<3;++i)\n        cycleValue3(pDataIndex+i,value[i],baseValue[i],amount,speed);\n}\n\n// ----------------------------------------------------\n\nvoid changeAim(inout Dataset data) {\n    cycleValue2(indexAim,data.aim.x,-1.0,8.0, 0.3);\n    cycleValue2(indexAim+1,data.aim.y,0.0,8.0, 0.4);\n    cycleValue2(indexAim+2,data.aim.z,0.0,8.0, 0.5);\n}\n    \nvoid moveCamera(inout Dataset data) {\n    float angle = iTime * 0.1;\n    float angle2 = iTime * 0.3;\n    float amt = 1.2;\n    \n    data.camera.x += cos(angle) * amt;\n    data.camera.y += cos(angle2) * amt;\n    data.camera.z += sin(angle) * amt;\n}\n\nvoid alterparams(inout Dataset data) {\n    float amt = 0.06;\n\n    cycleValue2(0,data.shape,data.shape,amt,0.3);\n    cycleValue2(1,data.vmin.x,data.vmin.x,amt,0.2);\n    cycleValue2(2,data.vmin.y,data.vmin.y,amt,0.3);\n    cycleValue2(3,data.vmin.z,data.vmin.z,amt,0.4);\n    cycleValue2(4,data.vmin.w,data.vmin.w,amt,0.5);\n    cycleValue2(5,data.vmax.x,data.vmax.x,amt,0.2);\n    cycleValue2(6,data.vmax.y,data.vmax.y,amt,0.3);\n    cycleValue2(7,data.vmax.z,data.vmax.z,amt,0.4);\n    cycleValue2(8,data.vmax.w,data.vmax.w,amt,0.5);\n}\n\nvoid animateSpecifiedVariables(inout Dataset data) {\n    if(!data.animationEnable) return; \n\n    alterparams(data);\n    \n/*\n    //moveCamera(data);\n    //changeAim(data);\n*/\n\n}\n\n// --------------------------------------------------------\n    \nvoid downloadData(ivec2 address,inout float v1,inout float v2,inout float v3) {\n    vec3 d = fetchData(iChannel0, address).xyz;\n    v1 = d.x; v2 = d.y; v3 = d.z;\n}    \n\nvoid readStoredData(inout Dataset data) {\n    float unused = 0.;\n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    data.focus = int(sd.x);\n    data.displayCount = int(sd.y);\n    data.animationEnable = bool(sd.z == 1.0);\n    \n    downloadData(P0_ADDR,data.shape,data.vmin.x,data.vmax.x);\n    downloadData(P1_ADDR,data.vmin.y,data.vmax.y,data.vmin.z);\n    downloadData(P2_ADDR,data.vmax.z,data.vmin.w,data.vmax.w);\n    downloadData(P3_ADDR,unused,data.bright,data.contrast);\n    data.maxsteps = int(unused);\n    downloadData(P4_ADDR,data.fogDistance,data.fogAmount,data.fogColor);\n    downloadData(P5_ADDR,data.textureF,unused,unused);\n    \n    downloadData(P6_ADDR,data.camera.x,data.camera.y,data.camera.z);\n    downloadData(P7_ADDR,data.aim.x,data.aim.y,data.aim.z);\n    downloadData(P8_ADDR,data.invpos.x,data.invpos.y,data.invpos.z);\n    downloadData(P9_ADDR,data.invradius,data.invangle,data.ssDistance);\n    downloadData(P10_ADDR,data.ssAngle,data.ssAmount,data.ssMix);\n    \n    sd = fetchData(iChannel0, UNIFORM_1).xyz;\n    data.inversionEnable = bool(sd.x > 0.);\n    data.stereoEnable = bool(sd.y > 0.);\n\n    sd = fetchData(iChannel0, UNIFORM_2).xyz;\n    data.secondsurfaceEnable = bool(sd.x > 0.);\n    data.refractEnable = bool(sd.y > 0.);\n    \n    data.viewVector = fetchData(iChannel0, VV_1).xyz;\n    data.sideVector = fetchData(iChannel0, VV_2).xyz;\n    data.topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\nvoid initializedNonStoredData(inout Dataset data) {\n    data.epsilon = 0.00001; // deviation when calculating normal\n\tdata.color = vec3(0.); \n    data.ssIterations = 1;\n    data.parallax = 0.02; // use smaller values when viewing closeup objects\n}\n\n// --------------------------------------------------------\n\nvec3 Refract(vec3 incidentVec, vec3 normal, float eta) {\n  float N_dot_I = dot(normal, incidentVec);\n  float k = 1.0 - eta * eta * (1.0 - N_dot_I * N_dot_I);\n  if (k < 0.0)\n    return vec3(0.0);\n  else\n    return eta * incidentVec - (eta * N_dot_I + sqrt(k)) * normal;\n}\n\n// --------------------------------------------------------\n\nconst  mat4  paletteVal = mat4(\n    .5 , .5 , .5 , 0.,\n    .5 , .5 , .5 , 0.,\n    2. , 1. , 0. , 0.,\n    .5 , .2 , .25 , 0.  );\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t) );\n}\n\nvec3 doPalette( in float val , in mat4 pType ) {\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\nvoid applyColoring(inout Dataset data) { \n    vec3 refr = refract( data.direction , data.normal , 1. / 1.1 );\n    vec3 refl = reflect( vec3( 0. , 3. , 0. ) , data.normal );\n    refl = normalize( refl );\n\n    vec2 uv = refr.xy * data.textureF;\n    vec3 refrCol = vec3(texture( iChannel2, uv));  \n    vec3 reflCol = vec3(texture( iChannel2, uv));\n\n    float reflectVal = pow( max( 0. , dot( refl , data.direction ) ), 20. );\n\n    vec3 palCol = doPalette(1., paletteVal);\n    vec3 refCol = doPalette( reflectVal , paletteVal ) * reflectVal;\n\n    data.color =  refCol + (palCol * refrCol);\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(0.); \n\n    Dataset data;\n    readStoredData(data);\n    initializedNonStoredData(data);\n    animateSpecifiedVariables(data);\n\n    setDirection(fragCoord,data);\n\trayMarch(data);\n    \n\tif(data.depth < MAX_DIST) {  \n        data.position = data.camera + data.direction * data.depth;\n        calcNormal(data);\n        applyColoring(data);\n\n        // second surface -------------------------------\n        if(data.secondsurfaceEnable) {\n            vec3 originalCamera = data.camera;\n            \n            for(int i=0;i<5;++i) {\n                if(i >= data.ssIterations) break;\n\n                if(data.refractEnable)\n                    data.direction = Refract(data.direction, data.normal * data.ssAngle,data.ssAmount);\n                else\n                    data.direction = reflect(data.direction, data.normal * data.ssAngle);\n                data.direction = normalize(data.direction);\n\n                data.camera = data.position + data.ssDistance * data.direction;\n                rayMarch(data);\n\n                if(data.depth < MAX_DIST) { \n                    data.position = data.camera + data.direction * data.depth;\n                    calcNormal(data);\n                    vec3 previousColor = data.color;\n                    applyColoring(data);\n                    data.color = mix(previousColor,data.color,data.ssMix); \n                }\n                else\n                    break;\n            }\n            \n            data.camera = originalCamera;\n        }\n    }\n//    else\n  //     data.color.yzx = vec3(texture(iChannel2, data.direction.xy)) * 0.6;\n\n    if(data.fogDistance != 0.0) {\n        float f = data.depth - data.fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * data.fogAmount);\n            data.color = mix(data.color, vec3(f * data.fogColor),f);\n        }\n    }\n        \n    data.color *= data.bright;\n    data.color = vec3(0.5) + (data.color - vec3(0.5)) * data.contrast;\n\n    fragColor = vec4(data.color,1.0);\n    \n    if(data.displayCount > 0) {\n        displayData(data,fragColor,fragCoord,1);\n        displayData(data,fragColor,fragCoord,0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float shapeDefault = 0.8978;\nconst float minxDefault = -0.7821867;\nconst float maxxDefault = 0.5;\nconst float minyDefault = -0.5424057;\nconst float maxyDefault = 1.3;\nconst float minzDefault = -0.4748369;\nconst float maxzDefault = 1.549;\nconst float minwDefault = 0.7999992;\nconst float maxwDefault = 0.90;\n\nconst vec3  cameraDefault = vec3(0.9732,-5.1784,14.974);\nconst vec3  aimDefault = vec3(-0.5974,-1.4059,-12.83);\n\nconst vec3 invposDefault = vec3(0.0712, -0.012, 0.22);\nconst float invradiusDefault = 0.387;\nconst float invangleDefault = 3.973;\n\nconst float ssDistanceDefault = 0.0093;\nconst float ssAngleDefault = 0.7899;\nconst float ssAmountDefault = 1.3;\nconst float ssMixDefault = 1.;\n\n// ========================================================================\n// leave room for future entries without having to adjust hardwired param array positions\n#define UNUSED  999.\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\nconst float pDelta = 0.001;\n\nconst ParamData[] pData = ParamData[]( \n    //  0 p0 ---------------\n    ParamData(shapeDefault, 0.01,2.,  pDelta), \n    ParamData(minxDefault, -5.0, 5.0, pDelta),\n    ParamData(maxxDefault, -5.0, 5.0, pDelta),\n    //  3 p1 ---------------\n    ParamData(minyDefault, -5.0, 5.0, pDelta),\n    ParamData(maxyDefault, -5.0, 5.0, pDelta),\n    ParamData(minzDefault, -5.0, 5.0, pDelta),\n    //  6 p2 ---------------\n    ParamData(maxzDefault, -5.0, 5.0, pDelta),\n    ParamData(minwDefault, -5.0, 5.0, pDelta),\n    ParamData(maxwDefault, -5.0, 5.0, pDelta),\n    //  9 p3 ---------------\n    ParamData(10.,2.0, 15.0, 1.0),  // steps\n    ParamData(1.5,0.1,10.,0.1),    // bright\n    ParamData(1.0,0.1,10.,0.1),    // contrast\n    // 12 p4 ---------------\n    ParamData(0.0,-5.,5.,0.01),    // fogDistance\n    ParamData(0.0,0.0,2.,0.01),    // fogAmount\n    ParamData(0.0,0.0,1.,0.01),    // fogColor\n    \n    // 15 p5 ---------------\n    ParamData(1.,0.1,2.,0.01),     // texture factor\n    UNUSEDP,\n    UNUSEDP,\n    // 18 p6 ---------------    \n    ParamData(cameraDefault.x, -20., 20., 0.01), \n    ParamData(cameraDefault.y, -20., 20., 0.01),\n    ParamData(cameraDefault.z, -20., 20., 0.01),\n    // 21 p7 ---------------\n    ParamData(aimDefault.x, -20., 20., 0.01), \n    ParamData(aimDefault.y, -20., 20., 0.01),\n    ParamData(aimDefault.z, -20., 20., 0.01),\n    // 24 p8 ---------------\n    ParamData(invposDefault.x, -15., 15., 0.01),\n    ParamData(invposDefault.y, -15., 15., 0.01),\n    ParamData(invposDefault.z, -15., 15., 0.01),\n    // 27 p9 ---------------    \n    ParamData(invradiusDefault, 0.01, 10., 0.01),\n    ParamData(invangleDefault, -5., 5., 0.001), \n    ParamData(ssDistanceDefault, 0., 5., 0.01),\n    // 30 p10 ---------------    \n    ParamData(ssAngleDefault, -1., 1., 0.01),\n    ParamData(ssAmountDefault, 0.3, 1.3, 0.01),\n    ParamData(ssMixDefault, 0., 1., 0.01)\n); \n\nconst int indexCamera = 18;\nconst int indexAim = 21;\nconst int indexInversion = 24;\nconst int indexSecondSurf = 29;\n\nconst int PDATA_SIZE = 33;\nconst int PDATA_ADDR_COUNT = (PDATA_SIZE+2)/3;\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR =  ivec2( 2, 0);\nconst ivec2 P1_ADDR =  ivec2( 3, 0);\nconst ivec2 P2_ADDR =  ivec2( 4, 0);\nconst ivec2 P3_ADDR =  ivec2( 5, 0);\nconst ivec2 P4_ADDR =  ivec2( 6, 0);\nconst ivec2 P5_ADDR =  ivec2( 7, 0); \nconst ivec2 P6_ADDR =  ivec2( 8, 0); \nconst ivec2 P7_ADDR =  ivec2( 9, 0); \nconst ivec2 P8_ADDR =  ivec2(10, 0); \nconst ivec2 P9_ADDR =  ivec2(11, 0); \nconst ivec2 P10_ADDR = ivec2(12, 0); \n\nconst ivec2[] storeAddr = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,P10_ADDR);\n\nconst ivec2 UNIFORM_1 = ivec2(13, 0); // booleans\nconst ivec2 UNIFORM_2 = ivec2(14, 0);\nconst ivec2 VV_1 = ivec2(15, 0);   // view vectors\nconst ivec2 VV_2 = ivec2(16, 0);\nconst ivec2 VV_3 = ivec2(17, 0);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ========================================================================\n// visit: https://www.shadertoy.com/view/mdsSD7\n// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n//    vec2 uvSize = f.charSize / f.texSize;\n//    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\n/*\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n*/\n\nvoid printInt(int val, inout TextCursor t)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor)\n{\nif(texture(fontTexture, t.outUV).r > 0.2)\n    fragColor = t.outColor;\n //   if(texture(fontTexture, t.outUV).r < 0.2)\n   //     fragColor = vec4(1.,0.4,0.4,10.);\n    \n/*      \n    fragColor = vec4(0.);\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = t.outColor;\n*/\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < PDATA_SIZE) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 viewVector = normalize(fetchData(iChannel0, P7_ADDR).xyz);  // aim\n        vec3 sideVector = vec3(0.0, 1.0, 0.0);\n        sideVector = cross(sideVector,viewVector);\n        sideVector = normalize(sideVector);\n        vec3 topVector = viewVector;\n        topVector = cross(topVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT  = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT  = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis,inout vec3[PDATA_ADDR_COUNT] memory) {\n    if(focus > PDATA_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 3;  // memory index\n    int focusField = focus % 3;  // x,y,z field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.001;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n                // special handling for maxsteps field\n                bool kLeft = (focus == 9) ? getKeyClick(KEY_LEFT) : getKeyState(KEY_LEFT);\n                bool kRight = (focus == 9) ? getKeyClick(KEY_RIGHT) : getKeyState(KEY_RIGHT);\n                \n                if(kLeft)  changeAmount = -pData[focus].delta; else\n                if(kRight) changeAmount = +pData[focus].delta;\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.); \n    if(fragCoord.x > 30.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    updateViewVectors(fragColor, fragCoord);\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    vec3 m = vec3(0.);\n    vec3[PDATA_ADDR_COUNT] memory = vec3[](m,m,m,m,m,m,m,m,m,m,m);\n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    //-------------\n    // if <Alt><Shift> alter target position.xy regardless of focus    \n    if(getKeyState(KEY_SHIFT) && getKeyState(KEY_ALT)) \n        focus = 21;\n    else\n    \n    // if <Shift> alter camera position.xy regardless of focus\n    if(getKeyState(KEY_SHIFT)) \n        focus = 18;\n    //-------------\n    \n    if(alterFocusedVariable(focus,  0,memory)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1,memory)) resetDisplayCount = true;\n    \n    // output possibly altered values0-----------\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange == 0. && (iFrame % 12 == 0)) { // slow down auto repeat of up/dn arrows\n            if(getKeyState(KEY_UP))   focusChange = -1.;\n            if(getKeyState(KEY_DOWN)) focusChange = +1.;\n        }\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(PDATA_SIZE-1);\n                if(fragColor.x >= float(PDATA_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'  animationEnable\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n      \n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_1)) {\n        fragColor = fetchData(iChannel0, UNIFORM_1); \n        if(iFrame < 10) \n            fragColor.xyz = vec3(0.);\n        else {\n            bool ki = getKeyClick(73); // 'I'\n            bool ks = getKeyClick(83); // 'S'\n            if(ki) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n            if(ks) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n        }\n    }\n\n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_2)) {\n        fragColor = fetchData(iChannel0, UNIFORM_2); \n        if(iFrame < 10) fragColor.xyz = vec3(0.);\n\n        bool kq = getKeyClick(81); // 'Q'\n        bool kw = getKeyClick(87); // 'W'\n        if(kq) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n        if(kw) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}