{
    "Shader": {
        "info": {
            "date": "1515914803",
            "description": "Had the urge to make a little road. Hacked this off of my previous raymarching experiment & iq's tutorial.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBBWw",
            "likes": 8,
            "name": "Road01",
            "published": 3,
            "tags": [
                "raymarching",
                "road"
            ],
            "usePreview": 0,
            "username": "nslottow",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "\nconst float speed = 7.0;\n\n\n\n\nfloat map_z(float z)\n{\n    return z + iTime * speed;\n}\nfloat get_x(vec3 p)\n{\n    return p.x + 1.2 * cos(map_z(p.z) * 0.1);\n}\n\nfloat f(float x, float z)\n{\n    return 0.5 * sin(map_z(z) * 0.2);\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 50.0;\n    const float dt = 1.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(p.x, p.z);\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = 0.02;\n    vec3 n = vec3(\n        f(p.x - eps, p.z) - f(p.x + eps, p.z),\n        2.0 * eps,\n        f(p.x, p.z - eps) - f(p.x, p.z + eps));\n    return normalize(n);  \n}\n\nvec3 getShading(vec3 p, vec3 n)\n{\n    return dot(n, vec3(0.0, 1.0, 0.0)) * vec3(0.2, 0.7, 0.3);\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro + rd * t;\n    vec3 p1 = vec3(p.xy, map_z(p.z));\n    float z = p1.z;\n    \n    vec3 n = getNormal(p1);\n    vec3 s = getShading(p1, n);\n    \n    float waver = abs(get_x(p));\n    float midline = step(0.7, waver);\n    float mix_road = 1.0 - midline;\n    float mix_line = (1.0 - smoothstep(0.0, 0.0025, pow(waver, 2.5))) * step(0.7, mod(z, 1.5));\n    s = mix(s, vec3(0.2, -0.1, 0.2), mix_road * 0.7);\n    s = mix(s, vec3(0.7, 0.7, 0.7), mix_line * 0.7);\n    return s;\n}\n\nvec3 skyColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    return vec3(0.4, 0.6, 0.9 * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    const float hfov = radians(30.0);\n    const float tanhfov = tan(hfov);\n    const float near = 0.1;\n    const float far = 1.0;\n    \n    vec2 uv = fragCoord.xy / (iResolution.xy * 0.5) - vec2(1.0, 1.0);\n    float dx = tanhfov * uv.x / aspect;\n    float dy = tanhfov * uv.y;\n    \n    vec3 viewRayDir = normalize(vec3(dx, dy, 1.0) * (far - near));\n    \n    float z = map_z(0.0);\n    float bob = -0.3 + 0.025 * cos(z * 0.2);\n    float swivel = 0.05 * sin(z * 0.1);\n    mat4 inverseViewMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        swivel, bob, 1.0, 0.0,\n        0.0, 0.0, 0.0, 0.0\n        );\n    \n    float x = get_x(vec3(0.0, 0.0, 0.0));\n    vec3 ro = vec3(-x, 2.0, 0.0);\n    vec3 rd = (inverseViewMatrix * vec4(viewRayDir, 0.0)).xyz;\n    float resT;\n    \n    if (castRay(ro, rd, resT))\n    {\n        fragColor = vec4(terrainColor(ro, rd, resT), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(skyColor(fragCoord), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}