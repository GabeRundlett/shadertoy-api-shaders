{
    "Shader": {
        "info": {
            "date": "1606557470",
            "description": "Inspired by:\nhttps://twitter.com/jagarikin/status/1331409504953540613",
            "flags": 16,
            "hasliked": 0,
            "id": "tdyfRR",
            "likes": 58,
            "name": "(not) moving circle illusion",
            "published": 3,
            "tags": [
                "illusion"
            ],
            "usePreview": 0,
            "username": "bgolus",
            "viewed": 2739
        },
        "renderpass": [
            {
                "code": "// Click and move mouse around to control the ring's \"movement\" direction\n// Hold down space bar to show a grid in the background to show the ring really isn't moving\n\n// You can pause to get a better idea of what's actually happening.\n\n// inspired by this tweet\n// https://twitter.com/jagarikin/status/1331409504953540613\n\n\n\n// show two rings like the original inspiration\n#define TWO_RINGS\n\n// show arrows inside the ring(s)\n#define SHOW_ARROWS\n\n// always show the grid, even if not holding down space bar or so you can enable it on mobile\n//#define FORCE_GRID_ON\n\n\n\n// basic defines\n// slowing down the spin rate can expose how the effect works\n#define SPIN_RATE 2.0\n// a wider line doesn't make the effect stronger, but again can help expose what it's doing while still working\n#define OUTLINE_WIDTH 1.0\n#define RING_RADIUS 80.0\n\n#define pi 3.141592\n#define tau (pi * 2.0)\n\nconst int KEY_SPACE = 32;\n\n// basic 2D rotation\nvec2 rotate(vec2 coord, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec2(c * coord.x - s * coord.y, s * coord.x + c * coord.y);\n}\n\n// borrowed from Trisomie21's comments in this shader\n// https://www.shadertoy.com/view/4s23DG\nfloat lineArrow(vec2 p, vec2 p1, vec2 p2, float a) {\n\tvec2 v = p2 - p1;\n\tvec2 w = p - p1;\n\tfloat d = clamp(dot(w,v) / dot(v,v), 0., 1.);\n\tfloat l = length(w-v*d);\n\ta = max(a*d-3., l-a*d);\n\treturn min(l, a)-.5;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 ring(vec2 uv, float aa, float speed, vec2 dir)\n{\n    float dist = length(uv);\n    \n    float ring_radius = 0.6;\n    \n    float edge = min(1.0 - dist, dist - ring_radius) / aa;\n    float outline_edge = edge - OUTLINE_WIDTH;\n    \n    float dirMag = min(1.0, length(dir));\n    float dirFade = 0.0;\n    float arrow = 0.0;\n    \n    // directional movement\n    if (dir != vec2(0.0))\n    {        \n        float dir_cosine = dot(normalize(dir), normalize(uv));\n        \n        // flip movment direction if negative speed\n        if (speed < 0.0)\n            dir = -dir;\n        \n        // flip speed for ring edges on the \"back\" sides of the ring\n    \tspeed *= sign(dir_cosine);\n        \n        // fade out outline on edges not facing the axis of movement\n        dirFade = 1.0 - clamp(abs(dir_cosine / 0.7), 0.0, 1.0);\n        \n        // direction arrow\n        arrow = 1.0 - lineArrow(uv * RING_RADIUS, normalize(dir) * (RING_RADIUS * 0.25), -normalize(dir) * (RING_RADIUS * 0.25), 20.0);\n    }\n    else\n    {\n        // grow & shring arrows calculated by flipping and swizzling the start and end points\n        vec4 arrowStartEnd = vec4(RING_RADIUS * 0.1, 0.0, RING_RADIUS * 0.35, 0.0);\n        arrowStartEnd = speed > 0.0 ? arrowStartEnd : arrowStartEnd.zwxy;\n        \n        // diagonals\n        float ur = dot(vec2(1.0, 1.0), uv);\n        float ul = dot(vec2(-1.0, 1.0), uv);\n        \n        arrowStartEnd = ul > 0.0 ? -arrowStartEnd : arrowStartEnd;\n        arrowStartEnd = (ul > 0.0 ? ur : -ur) > 0.0 ? -arrowStartEnd.yxwz : arrowStartEnd;\n        \n        arrow = 1.0 - lineArrow(uv * RING_RADIUS, arrowStartEnd.zw, arrowStartEnd.xy, 10.0);\n    }\n    arrow = smoothstep(-1.5, 0.0, arrow);\n    arrow *= abs(speed);\n    \n    // spin UVs for main ring pattern\n    float rotation = iTime * tau * SPIN_RATE;\n    vec2 rotuv_inside = rotate(uv.xy, rotation);\n    \n    // spin UVs with offset for ring outlines\n    speed = dist > ((1.0 + ring_radius) * 0.5) ? speed : -speed;\n    vec2 rotuv_outline = rotate(uv.xy, rotation - pi * speed * 0.25);\n    \n    // colors\n    vec3 yellow = vec3(0.97, 0.77, 0.2);\n    vec3 blue = vec3(0.1, 0.25, 0.81);\n    vec3 arrow_color = vec3(0.0);\n    \n    // masks for ring and outline edges\n    edge = smoothstep(-0.75, 0.75, edge);\n    outline_edge = smoothstep(-0.75, 0.75, outline_edge + (OUTLINE_WIDTH + 1.5) * dirFade);\n    \n    // mask for ring's alternating colors\n    float inside_mask = smoothstep(-aa, aa, rotuv_inside.x);\n    inside_mask = mix(1.0 - inside_mask, inside_mask, smoothstep(-aa, aa, rotuv_inside.y));\n    \n    // mask for outine's alternatting colors\n    float outline_mask = smoothstep(-aa, aa, rotuv_outline.x);\n    outline_mask = mix(1.0 - outline_mask, outline_mask, smoothstep(-aa, aa, rotuv_outline.y));\n    \n    // mix together\n    vec3 col = mix(yellow, blue, inside_mask);\n    col = mix(mix(yellow, blue, outline_mask), col, outline_edge);\n    \n    // draw in arrows if they're enabled\n    #if defined(SHOW_ARROWS)\n    col = dist < (ring_radius - aa * 2.0) ? arrow_color : col;\n    edge += arrow;\n    #endif\n    \n    return vec4(col, edge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    vec2 halfResolution = iResolution.xy * 0.5;\n    \n    uv -= halfResolution;\n    uv /= RING_RADIUS;\n    \n    // background\n    vec3 col = vec3(0.5);\n    \n    // show grid if holding down space, or if forced on.\n    #if !defined(FORCE_GRID_ON)\n    if (texture( iChannel0, vec2((float(KEY_SPACE) + 0.5) / 256.0, 0.5 / 3.0) ).x > 0.0)\n    #endif\n    {\n    \tfloat grid = mod((floor(uv.x * 3.0) + floor(uv.y * 3.0)) + 1000.0, 2.0);\n    \tcol = vec3(grid == 0.0 ? 0.475 : 0.5);\n\t}\n    \n    // wiggle the speed between 1.0 and -1.0\n    float speed = smoothstep(0.25, 0.75, abs(fract(iTime * 0.15) * 2.0 - 1.0)) * 2.0 - 1.0;\n    \n    // rotate direction over time\n    float moveAngle = -iTime * 0.451;\n    vec2 dir = vec2(sin(moveAngle), cos(moveAngle));\n    \n    // if dir == 0, speed controls grow / shrink, so fade speed in and out and set dir to 0\n    speed *= abs(smoothstep(0.3, 0.5, abs(fract(iTime * 0.025) * 2.0 - 1.0)) * 2.0 - 1.0);\n    dir = abs(fract(iTime * 0.025) * 2.0 - 1.0) > 0.4 ? dir : vec2(0.0);\n    \n    // mouse controls\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouseRelativePos = iMouse.xy - halfResolution;\n        #if defined(TWO_RINGS)\n        float mouseDist = sdSegment(mouseRelativePos, vec2(-RING_RADIUS * 1.33, 0.0), vec2(RING_RADIUS * 1.33, 0.0));\n        #else\n        float mouseDist = length(mouseRelativePos);\n        #endif\n        \n        if (mouseDist > RING_RADIUS * 2.0)\n        {\n            dir = normalize(mouseRelativePos);\n            speed = clamp((mouseDist - RING_RADIUS * 2.1) / min(RING_RADIUS, halfResolution.y - RING_RADIUS), 0.0, 1.0);\n        }\n        else\n        {\n            dir = vec2(0.0);\n            #if defined(TWO_RINGS)\n            speed = clamp(mouseRelativePos.x / (RING_RADIUS * 1.33), -1.0, 1.0);\n            #else\n            speed = clamp(mouseDist / RING_RADIUS * 3.0 - 2.0, -1.0, 1.0);\n            #endif\n        }\n    }\n        \n    vec2 ringUV = uv;\n    \n    // support two rings by offseting uvs and flipping the speed direction\n    #if defined(TWO_RINGS)\n    if (uv.x < 0.0)\n    {\n        ringUV.x += 1.33;\n    }\n    else\n    {\n        speed = -speed;\n        ringUV.x -= 1.33;\n    }\n    // add a center point dot\n    col = mix(vec3(0.0), col, smoothstep(1.5, 3.5, length(uv * RING_RADIUS)));\n    #endif    \n    \n    float aa = 1.0 / RING_RADIUS;\n    \n    // draw ring\n    vec4 ringCol = ring(ringUV, aa, speed, dir);\n    col = mix(col, ringCol.rgb, ringCol.a);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}