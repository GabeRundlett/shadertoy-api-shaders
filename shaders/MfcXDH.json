{
    "Shader": {
        "info": {
            "date": "1713864001",
            "description": "Result of Monday Night Bytes shader jam. Wanted to see if I could do raymarching fast enough to allow multiple samples for motion blur, then added a rainbow blur effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "MfcXDH",
            "likes": 13,
            "name": "FTL raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "motionblur",
                "rainbow",
                "wccchallenge"
            ],
            "usePreview": 0,
            "username": "Alie",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "#define r2d(p,a) p=cos(a)*p + sin(a)*vec2(-p.y,p.x);\n\nvec3 hash(vec3 p) {\n  p = fract(p * vec3(443.537, 537.247, 247.428));\n  p += dot(p, p.yxz + 19.19);\n  return fract((p.xxy + p.yxx) * p.zyx);\n} \n\n\nfloat cat(vec2 p) {\n  p.x = abs(p.x);\n  vec2 q=p;\n  q.x = abs(q.x-.2);\n  q.y += q.x - .2;\n  float r = abs(q.y)<.05 && q.x<.15 ? 1. : 0.;\n  p.x -= .6;\n  p.y = abs(p.y) - .08;\n  r += abs(p.y)<0.03 && abs(p.x)<.15 ? 1. : 0.;\n  return r;\n}\n\nfloat boxDist(vec3 p, vec3 o, vec3 s, float r) {\n  p = abs(p - o) - s / 2.;\n  return length(max(p, 0.) + min(0., max(p.x, max(p.y, p.z)))) - r;\n}\n\nvec4 df(vec3 p) {\n  float d = 1000.;\n  //const vec3 cols[3] = {vec3(1,0,1), vec3(1,1,0), vec3(0,1,1) };\n  p.z /= 3.;\n  vec3 col;\n  for (float i=0.; i<3.; i++) {\n    float e = boxDist(p * vec3(1,1,0), vec3(sin(p.z + i * 3.142), cos(p.z + i * 3.142), 0.) * 1.5, vec3(.8), .1);\n    if (e < d) {\n      d = e;\n      col = i==0. ? vec3(.7) : (i==1. ? vec3(.85) : vec3(1));\n    }\n    p.z *= -1.2;\n  }\n  \n  d = min(\n    d,\n    -length(p.xy) + 2.\n  );\n  vec3 q = p;\n  r2d(q.xy, q.z / 3.);\n  if (d > 0.1) {\n    p = .5 - abs(max(fract(p), fract(q)) - .5);\n    //col = step(0.98, fract(p + fract(q))) * 8.;\n    col = 1. - step(.01, p);\n    col = vec3(max(col.x, max(col.y, col.z))) * 4.;\n  }\n  return vec4(col, d);\n}\n\nvec3 norm(vec3 p) {\n  vec2 e = vec2(1e-3, 0.);\n  return normalize(vec3(\n    df(p + e.xyy).w - df(p - e.xyy).w,\n    df(p + e.yxy).w - df(p - e.yxy).w,\n    df(p + e.yyx).w - df(p - e.yyx).w\n  ));\n}\n\nvec3 rm(vec3 p, vec3 dir, float mDist) {\n  vec3 col = vec3(0.);\n  float td = 0.;\n  for (int i=0; i< 20; i++) {\n    vec4 d = df(p);\n    td += d.w;\n    if (d.w < 1e-3 || td > mDist) {\n      col = d.xyz;\n      vec3 n = norm(p);\n      col *= pow(max(0., dot(-n, dir)), 2.);\n      break;\n    }\n    p += d.w * dir;\n  }\n  return col;\n}\n\nconst int samples = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  //vec2 uv = fragCoord/iResolution.xy;\n  vec2 uv = vec2(fragCoord.xy * 2. - iResolution.xy) / iResolution.yy;\n  \n  vec3 col = vec3(0.);\n  \n  for (int j=0;j<samples; j++) {\n    vec3 k = hash(vec3(uv, fract(iTime + float(j) / float(samples)))) - .5;\n    k.z = float(j) / float(samples);\n    float t = iTime + k.z / 15.;\n    vec2 c = vec2(fragCoord.xy) + k.xy * 2.; //texture(texFFTSmoothed, 0.01).x * 20.;\n    vec2 u = vec2(c * 2. - iResolution.xy) / iResolution.yy;\n    vec3 p = vec3(0, 0, t * 10.),\n    dir = normalize(vec3(u, .5));\n    r2d(dir.xy, t / 4.);\n    r2d(dir.xz, sin(t / 20.47) * 2.);\n    r2d(dir.yz, sin(t / 17.24) * 2.);\n  \n    float d = 1. / length(dir.xy), d2 = d * 2.;\n    p += dir * d;\n    \n    int idx = int((k.z) * 3.);\n    col[idx] += rm(p, dir, d / 2.).r * 3.;\n    //col += hash(floor(p * 10.)) * .5 + .25;\n  }\n\n  vec3 catC = vec3(0);\n  for (float i=0.;i<9.;i++) {\n    vec2 o = vec2(\n        sin(i / 10. + iTime * 2.347),\n        sin(i / 10. + iTime * 2.789)\n        );\n    o = pow(abs(o), vec2(7.)) * sign(o);\n    catC[int(i)/3] += cat((uv + o / 4.) * .5) / 3.;\n  }\n\tfragColor = vec4(col / float(samples) + catC, 1.);\n    //fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}