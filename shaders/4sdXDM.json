{
    "Shader": {
        "info": {
            "date": "1459768312",
            "description": "Small test to see how decent the reconstruction of a scene is with a low res sampled distancefield. Default resolution is 35^3 so it displays in the preview. More in the instructions",
            "flags": 32,
            "hasliked": 0,
            "id": "4sdXDM",
            "likes": 4,
            "name": "Discrete distancefield tracer",
            "published": 3,
            "tags": [
                "voxel",
                "sampling",
                "spheretrace"
            ],
            "usePreview": 0,
            "username": "sibaku",
            "viewed": 795
        },
        "renderpass": [
            {
                "code": "//*************** INSTRUCTIONS **********************\n//\n// Move the camera by dragging the mouse with left button held down\n//\n// You can display 3 different visualizations by defining SHOW to be one of the 3 values:\n// SHOW_TRACE: Displays the sphere traced scene\n// SHOW_TEXTURE: Displays the full packed 3D texture\n// SHOW_LAYERS: Displays the individual z-coord layers\n//\n// Some options:\n// USE_SMOOTHER_NORMALS: Computes normals with an epsilon based on cell size. Otherwise\n//\ta small value is used\n// USE_RIM_LIGHT: Enables a basic rim light effect\n//\n//\n// Change the resolution of the sampling with the variable res under constants\n// In both shaders\n// Depending on your viewport resolution, high values may only work in fullscreen\n//\n//***************************************************\n\n\n#define SHOW_TRACE 0\n#define SHOW_TEXTURE 1\n#define SHOW_LAYERS 2\n\n#define USE_SMOOTHER_NORMALS\n\n// #define USE_RIM_LIGHT\n\n#define SHOW SHOW_TRACE\n\n//****************************************************************\n//\n// Constants\n//\n//****************************************************************\n\n// Resolution of the sampling cube.\n// about 50 should work in the usual view\nfloat res = 35.;\n\n\n// Sampling cube bounds in world space\nconst float bounds = 3.5;\nconst vec3 minB = vec3(-bounds);\nconst vec3 maxB = vec3(bounds);\nconst vec3 delta = maxB - minB;\nconst int maxSteps = 150;\nconst float eps = 0.001;\nconst float pi = 3.14159265359;\nconst int shadowSteps = 30;\nvec3 LP = vec3(-30.,20.,40.);\n\n\n\n\n\nfloat DE_Box( vec3 p, float b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\n\n//****************************************************************\n//\n// Computes the uv position of a given 3d coordinate\n// Individual layers may be split from one row to the next. This can create problems\n// with the hardware interpolation inside of the layers at the split lines -> artifacts\n// during rendering. To account for that, the first coloumn will 'jump back' one layer\n// and the last coloumn will 'jump ahead' one layer. Therefore the valid x pixels now\n// start at 1 and end at res.x-2. When sampling, the edges will now automatically interpolated\n// with the wrap-around points.\n//\n//****************************************************************\n\n\n\nvoid getUV(in vec3 P, in vec2 resolution,out vec2 uv1, out vec2 uv2, out float blend)\n{\n \n    vec3 p = (P-minB)/delta;\n    \n    p = clamp(p,0.,1.);\n    float w = resolution.x-2.;\n    float zpx = p.z*(res-1.);\n    float layer = floor(zpx);\n    float layer2 = min(layer+1.,res-1.);\n    blend = fract(zpx);\n    float xpx = (p.x*(res-1.));\n    float ypx = (p.y*(res-1.));\n    \n    float xlin = layer*res + xpx;\n    float x2 = mod(xlin,w);\n    float y2 = ypx + floor(xlin/w)*res;\n    \n    uv1 = vec2(x2,y2);\n    uv1 = min(uv1,resolution.xy-1.);\n    uv1.x += 1.;\n    uv1 = (2.*uv1 +1.)/(2.*resolution.xy );\n    \n    xlin = layer2*res + xpx;\n    x2 = mod(xlin,w);\n    y2 = ypx + floor(xlin/w)*res;\n    \n    uv2 = vec2(x2,y2);\n    uv2.x += 1.;\n    uv2 = min(uv2,resolution.xy-1.);\n    uv2 = (2.*uv2+1.)/(2.*resolution.xy);\n    \n  \n    \n    \n}\n\n// Sample 3D Texture\nvec4 sample_tex(in vec3 P)\n{\n \n    vec2 uv1;\n    vec2 uv2;\n    float blend;\n    getUV(P,iResolution.xy,uv1,uv2,blend);\n    \n   \tvec4 s0 = texture(iChannel0,uv1);\n    vec4 s1 = texture(iChannel0,uv2);\n   return mix(s0,s1,blend);\n   \n    \n    \n}\nfloat DE(in vec3 P)\n{\n    //return max(sample_tex(P).x , DE_Box(P,bounds));\n    return max(sample_tex(P).x , max(DE_Box(P,bounds),0.));\n    //return sample_tex(P).x + max(DE_Box(P,bounds),0.);\n}\n\nfloat smoothShadow(in vec3 P,in vec3 LPos)\n{\n    vec3 l = LPos - P;\n    float llen = length(l);\n    \n    vec3 L = l/llen;\n   \n    llen = min(bounds,llen);\n    \n    float m = 1.;\n     float startDist = abs(DE(P));\n    float k = 8.;\n    \n    float endRadius = DE(LPos);\n    for(int i = 0; i < shadowSteps; i++)\n    {\n        float stepsize = float(i)/float(shadowSteps);\n        \n        float len = stepsize*llen;\n        \n        vec3 pos = P + len*L;\n        \n        if(length(float(greaterThan(pos-bounds,vec3(bounds)))) > 0.) \n        {\n         \treturn  clamp(m,0.,1.);  \n        }\n        if(len >= llen)\n            return clamp(m,0.,1.);\n        \n        \n        len = max(len - 0.2,0.);\n        float d = DE(pos);\n        \n        \n        float radius = endRadius*len/llen;\n        m = min(k*d/radius,m);\n        \n    }\n    if(m< 0.05)\n            return 0.;\n        else if(m > 0.9)\n            return 1.;\n    return clamp(m,0.,1.);\n}\n\nfloat ao(in vec3 P, in vec3 N)\n{\n \t  const int steps = 6;\n    \n    float delta = 0.05;\n    float k = 5.;\n    \n    float startDist = sample_tex(P).x;\n    \n    float occl = 0.;\n   \tfor(int i = 1; i <= steps;i++)\n    {\n        \n     \t vec3 pos = P +  delta*float(i)*N;\n         int index;\n         float d = DE(pos);\n        \n        float realDist = delta*float(i)+ startDist;\n        \n        occl += abs((realDist - d)/pow(2.,float(i)));\n        \n        \n        \n    }\n    \n    return clamp(1.0-k*occl,0.,1.);\n}\n\nvec3 gradient(in vec3 p)\n{\n    \n    #ifdef USE_SMOOTHER_NORMALS\n    \tfloat eps = delta.x/res;\n    #else\n     \tfloat eps = 0.05;\n    #endif\n   \n    \n    \n    return normalize(vec3(\n    \tsample_tex(p + vec3(eps,0.,0.)).x - sample_tex(p - vec3(eps,0.,0.)).x,\n        sample_tex(p + vec3(0.,eps,0.)).x - sample_tex(p - vec3(0.,eps,0.)).x,\n        sample_tex(p + vec3(0.,0.,eps)).x - sample_tex(p - vec3(0.,0.,eps)).x\n    ));    \n}\n\n\nfloat trace(in vec3 p, in vec3 dir,out vec3 N,out vec3 color,out vec3 pos)\n{\n \t//return sample_tex(p);\n    \n        \n    int steps = 0;\n    color = vec3(0.,0.,0.);\n    float dist = 10000.0;\n    float t = 0.;\n    N = vec3(0.,0.,0.);\n    \n    float lastT = 0.;\n    for(int i= 0; i < maxSteps;i++)\n    {\n        pos = p+t*dir;\n       \n     \tfloat d = DE(pos);\n        \n        \n        if(d < eps)\n        {\n            vec4 samp = sample_tex(pos);\n            pos = p + (t-2.*eps)*dir;\n            vec3 L = normalize(LP- pos);\n            N = gradient(pos);\n            float dif = dot(N,L);\n            dif = max(dif,0.);\n            color = samp.yzw;\n         \treturn   dif;\n           \n        }\n        \n        lastT = t;\n        t += d;\n        steps++;\n    }\n    \n    \n \n     return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n\tvec2 camRes = vec2(2.,2.*iResolution.y/iResolution.x);\n    float focal = 1.;\n    \n    vec3 eye = vec3(-5.,0.,0.);\n    //eye += vec3(sin(2.*pi/10.*iTime),0.,cos(2.*pi/10.*iTime))*0.5;\n    // Better camera thanks to stb\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5/iResolution.xy) : iMouse.xy/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    vec3 center = vec3(0.,0.,0.);\n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 right = cross(dir,up);\n    \n    vec3 p = eye + focal*dir - right*camRes.x/2.0 - up*camRes.y/2.0 + uv.x*camRes.x*right + uv.y*camRes.y*up;\n    \n    LP = vec3(sin(iTime/5.)*40.,20.,cos(iTime/5.)*50.);\n    \n   \n    \n    #if SHOW == SHOW_TRACE\n        vec3 rayDir = normalize(p-eye);\n        vec3 N;\n        vec3 color;\n        vec3 pos;\n    \n    \tfloat diffuse = trace(p,rayDir,N,color,pos);\n        float shadow = smoothShadow(pos,LP);\n        float aot = ao(pos,N);\n    \n    \t// compute simple rim light\n    \t#ifdef USE_RIM_LIGHT\n    \t\tfloat rimLight = max(0.0,dot(rayDir,reflect(rayDir,N)))*0.25;\n    \t#else \n    \t\tfloat rimLight = 0.0;\n    \t#endif\n    \t\n    \tfragColor = vec4(color*(diffuse*shadow + 0.3 + rimLight)*aot,1.);\n    #elif SHOW == SHOW_TEXTURE\n    \tfragColor = vec4(texture(iChannel0,uv).x);\n    #else\n    \tfragColor = vec4(sample_tex(vec3(uv, abs(sin(iTime/pi/res*20.)))*delta + minB).x);\n    #endif\n    \n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//*************** INSTRUCTIONS **********************\n//\n// Move the camera by dragging the mouse with left button held down\n//\n// You can display 3 different visualizations by defining SHOW to be one of the 3 values:\n// SHOW_TRACE: Displays the sphere traced scene\n// SHOW_TEXTURE: Displays the full packed 3D texture\n// SHOW_LAYERS: Displays the individual z-coord layers\n//\n// Change the resolution of the sampling with the variable res under constants\n// In both shaders\n// Depending on your viewport resolution, high values may only work in fullscreen\n//\n//***************************************************\n\n\n//****************************************************************\n//\n// Constants\n//\n//****************************************************************\n\n\n// Resolution of the sampling cube.\n// about 50 should work in the usual view\nfloat res = 35.;\n// Sampling cube bounds in world space\nconst float bounds = 3.5;\nconst vec3 minB = vec3(-bounds);\nconst vec3 maxB = vec3(bounds);\nconst vec3 delta = maxB - minB;\n\n\n//****************************************************************\n//\n// Distance functions\n//\n//****************************************************************\n\nmat3 rotY(float theta)\n{\n \n    \n    return mat3(cos(theta),0.,-sin(theta),\n                0.,1.,0.,\n                sin(theta),0.,cos(theta));\n    \n}\n\nfloat DE_Sphere(in vec3 p, in vec3 center, in float r)\n{\n \treturn length(p-center)-r;   \n}\n\nfloat DE_Box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//****************************************************************\n//\n// Computes the 3D position of a given fragment coordinate\n// Individual layers may be split from one row to the next. This can create problems\n// with the hardware interpolation inside of the layers at the split lines -> artifacts\n// during rendering. To account for that, the first coloumn will 'jump back' one layer\n// and the last coloumn will 'jump ahead' one layer. Therefore the valid x pixels now\n// start at 1 and end at res.x-2. When sampling, the edges will now automatically interpolated\n// with the wrap-around points.\n//\n//****************************************************************\n\n\nvec3 get3D(in vec2 fragCoord, in vec2 resolution)\n{\n \tvec2 f = floor(fragCoord);\n    f.x = f.x -1.;\n   \n    float w = resolution.x -2.;\n     if(f.x < 0.)\n     {\n      \tf.x = w-1.;\n        f.y = f.y - res;\n     }else if(f.x >= w)\n     {\n      \tf.x = 0.;\n        f.y = f.y + res;\n     }\n    float xoff = mod(f.x,w);\n    float xlin = xoff + floor(f.y/res)*w;\n    float ylin = mod(f.y,res);\n    float layer = floor(xlin/res);\n    \n    float yuv = ylin/(res-1.);\n    float xuv = mod(xlin,res)/(res-1.);\n    float zuv = layer/(res-1.);\n    \n    \n    return vec3(xuv,yuv,zuv);\n}\n\n\n\n//****************************************************************\n//\n// Main\n// Computes a 3D texture stored in the 2D framebuffer. The sampling cube has\n// resolution 'res' and is ordered in layers of xy. \n// fragColor stores distance in x and color in yzw\n//\n//****************************************************************\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \n    // Do not recompute the texture every time\n    // Ideally do not recompute every time, but that way you have to reset time\n    // whenever you change some constants...\n    if(iTime <0.)\n    {\n     \tfragColor = texture(iChannel0,fragCoord.xy / iResolution.xy);\n        return;\n \t}\n    \n\n\n  \n    vec3 pNorm = get3D(fragCoord,iResolution.xy);\n    vec3 P = minB + delta * pNorm;\n   \n    // Sample the distance function\n    float d1 = DE_Sphere(P,vec3(0.,0.,0.),1.);\n    float d2 = DE_Sphere(P,vec3(-1.,1.,-1.),1.4);\n    float d3 = DE_Box(P-vec3(0.,-2.1,0.),vec3(3.3,1.,3.3)); \n    \n   \n    \n    float o1 = max(d1,-d2);\n    float o2 = d3;\n   \tfloat o3 = DE_Box(rotY(radians(-20.))*(P-vec3(-0.75,0.4,2.)),vec3(0.4,1.,0.5));     \n    \n    float d = min(o1,d3);\n    vec3 color;\n    vec3 indirect = vec3(0.);\n    float scale = 2.;\n    float dmin = o1;\n    color = vec3(1.,0.,0.); \n    \n    if(o2 < dmin)\n    {\n    \n     \tcolor = vec3(0.,0.,1.);  \n        indirect += vec3(1.,0.,0.)*exp(-d1*d1*scale);\n        dmin = o2;\n    }\n    \n    if(o3 < dmin)\n    {\n        color = vec3(0.,1.,1.);  \n        indirect += vec3(1.,0.,0.)*exp(-d1*d1*scale);\n        dmin = o3;\n    }\n    fragColor = vec4(dmin,color );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}