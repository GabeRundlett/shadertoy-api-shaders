{
    "Shader": {
        "info": {
            "date": "1460652084",
            "description": "My shader just wants to party all the time!",
            "flags": 0,
            "hasliked": 0,
            "id": "XstSRX",
            "likes": 62,
            "name": "Disco 2000",
            "published": 3,
            "tags": [
                "raytracing",
                "music",
                "volumetric",
                "lights"
            ],
            "usePreview": 1,
            "username": "finalman",
            "viewed": 19907
        },
        "renderpass": [
            {
                "code": "const float EXPOSURE = 12.0;\nconst float OMNI_LIGHT = 0.1;\nconst float FLOOR_REFLECTION = 0.15;\n\nconst int NUM_LIGHTS = 10;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\nconst float BIG = 1e30;\nconst float EPSILON = 1e-10;\nconst float THETA = (1.0 + 2.2360679775) / 2.0;\nconst float INV_THETA = 1.0 / THETA;\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Intersection\n{\n    float dist;\n    vec3 normal;\n};\n\nstruct Result\n{\n    Intersection start;\n    Intersection end;\n};\n    \nstruct Range\n{\n\tfloat start;\n    float end;\n};\n    \nstruct Light\n{\n    vec3 d;\n    vec3 c;\n    float a;\n};\n    \nLight lights[NUM_LIGHTS];\n    \nmat4 rotateX(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nfloat insideCone(vec3 direction, float angle, vec3 o)\n{\n    float oz = dot(o, direction);\n    vec3 oxy = o - direction * oz;\n    float c = dot(oxy, oxy) / (angle * angle) - (oz * oz);\n    return smoothstep(20.0, -50.0, c);\n}\n\nRange cone(vec3 direction, float angle, Ray ray)\n{\n    float dz = dot(ray.d, direction);\n    float oz = dot(ray.o, direction);\n    vec3 dxy = ray.d - direction * dz;\n    vec3 oxy = ray.o - direction * oz;\n    \n    float a = dot(dxy, dxy) - (dz * dz * angle * angle);\n    float b = dot(dxy, oxy) - (dz * oz * angle * angle);\n    float c = dot(oxy, oxy) - (oz * oz * angle * angle);\n    \n    float p = 2.0 * b / a;\n    float q = c / a;\n    \n    float r = p * p / 4.0 - q;\n    \n    Range result;\n    result.start = BIG;\n    result.end = -BIG;\n    \n    if (r >= 0.0)\n    {\n        float m = -p / 2.0;\n        float sr = sqrt(r);\n            \n        if (c < 0.0)\n        {\n\t\t\t// Inside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                result.start = 0.0;\n                result.end = BIG;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = 0.0;\n                result.end = m + sr;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = 0.0;\n            \tresult.end = m - sr;\n            }\n        }\n        else\n        {\n            // Outside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                return result;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = m + sr;\n                result.end = BIG;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = m - sr;\n            \tresult.end = m + sr;\n            }\n        }\n    }\n    \n    return result;\n}\n\nResult plane(vec3 pos, vec3 normal, Ray ray)\n{\n    ray.o -= pos;\n    \n    float rdn = dot(ray.d, normal);\n    float ron = dot(ray.o, normal);\n    \n    Result result;\n    result.start.normal = normal;\n    result.end.normal = normal;\n    \n    if (ron > 0.0)\n    {\n        // Outside\n        result.start.dist = BIG;\n        result.end.dist = -BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n            else\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n        }\n    }\n    else\n    {\n        // Inside\n        result.start.dist = -BIG;\n        result.end.dist = BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n            else\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n        }\n    }\n    return result;\n}\n\nfloat inverseSquare(vec3 p)\n{\n    return 1.0 / dot(p, p);\n}\n\nfloat inverseSquareAntiderivative(Ray ray, float t)\n{\n    vec3 o = ray.o;\n    vec3 d = ray.d;\n    \n    // Shoutout to Wolfram Alpha\n    float a = t * dot(d, d) + dot(d, o);\n    float b1 = d.x * d.x * dot(o.yz, o.yz);\n    float b2 = 2.0 * d.x * o.x * dot(o.yz, d.yz);\n    float b3 = o.x * o.x * dot(d.yz, d.yz);\n    float b4 = (o.y * d.z - d.y * o.z) * (o.y * d.z - d.y * o.z);\n    float b = sqrt(b1 - b2 + b3 + b4);\n    return atan(a / b) / b;\n}\n\nfloat inverseSquareIntegral(Ray ray, float start, float end)\n{\n    return inverseSquareAntiderivative(ray, end) - inverseSquareAntiderivative(ray, start);\n}\n\nvec3 getLight(vec3 pos)\n{\n    vec3 color = vec3(inverseSquare(pos) * OMNI_LIGHT * 2.0);\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        color += lights[i].c * inverseSquare(pos) * insideCone(lights[i].d, lights[i].a, pos);\n    }\n    return color;\n}\n\nvec3 renderVolumetric(Ray ray, float maxDist)\n{\n    vec3 color = vec3(inverseSquareIntegral(ray, 0.0, maxDist) * OMNI_LIGHT);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Range r = cone(lights[i].d, lights[i].a, ray);\n        r.end = min(r.end, maxDist);\n        \n        if (r.end > r.start)\n        {\n            float boost = mix(1.0, 18.0, insideCone(lights[i].d, lights[i].a, ray.o));\n            \n            color += inverseSquareIntegral(ray, r.start, r.end) * lights[i].c * boost;\n        }\n    }\n    \n    return color;\n}\n\nvec3 floorTexture(vec3 pos)\n{\n    pos.z += pos.x * 0.25;\n    return fract(pos.x * 0.1) > fract(pos.z * 0.1) ? vec3(1.0) : vec3(0.7);\n}\n\nfloat floorGloss(vec3 pos)\n{\n    pos.x += pos.z * 2.0;\n    return texture(iChannel1, pos.xz * 0.2).x * 0.5 + 0.75;\n}\n\nvec3 renderScene(Ray ray)\n{\n    Result r = plane(vec3(0.0, -18.0, 0.0), vec3(0.0, 1.0, 0.0), ray);\n    \n    if (r.start.dist > 0.0 && r.start.dist < r.end.dist)\n    {\n        vec3 pos = ray.o + ray.d * r.start.dist;\n        \n        Ray reflectedRay;\n        reflectedRay.o = pos;\n        reflectedRay.d = ray.d * vec3(1, -1, 1);\n        \n        vec3 volumetric = renderVolumetric(ray, r.start.dist);\n        vec3 reflectedVolumetric = renderVolumetric(reflectedRay, BIG);\n        \n        vec3 color = -normalize(pos).y * getLight(pos) * 30.0 * floorTexture(pos);\n        float gloss = floorGloss(pos);\n        \n        return volumetric + mix(color, reflectedVolumetric, FLOOR_REFLECTION * gloss);\n    }\n    else\n    {\n    \treturn renderVolumetric(ray, BIG);\n    }\n}\n\nvec3 toneMap(vec3 color)\n{\n    return 1.0 - exp(-color * EXPOSURE);\n}\n\nvoid setUpLights()\n{\n    mat4 m = rotateX(TAU * iTime * 0.05) * rotateY(TAU * iTime * 0.09);\n    \n    lights[0].d = normalize(m * vec4(1, 1, 1, 0)).xyz;\n    lights[1].d = normalize(m * m * vec4(1, 1, -1, 0)).xyz;\n    lights[2].d = normalize(m * vec4(1, -1, 1, 0)).xyz;\n    lights[3].d = normalize(m * m * vec4(1, -1, -1, 0)).xyz;\n    lights[4].d = normalize(m * vec4(0, INV_THETA, THETA, 0)).xyz;\n    lights[5].d = normalize(m * m * vec4(0, INV_THETA, -THETA, 0)).xyz;\n    lights[6].d = normalize(m * vec4(INV_THETA, THETA, 0, 0)).xyz;\n    lights[7].d = normalize(m * m * vec4(INV_THETA, -THETA, 0, 0)).xyz;\n    lights[8].d = normalize(m * vec4(THETA, 0, INV_THETA, 0)).xyz;\n    lights[9].d = normalize(m * m * vec4(-THETA, 0, INV_THETA, 0)).xyz;\n    \n    lights[0].c = normalize(vec3(1, 1, 1) * 0.5 + 0.7);\n    lights[1].c = normalize(vec3(1, 1, -1) * 0.5 + 0.7);\n    lights[2].c = normalize(vec3(1, -1, 1) * 0.5 + 0.7);\n    lights[3].c = normalize(vec3(1, -1, -1) * 0.5 + 0.7);\n    lights[4].c = normalize(vec3(0, INV_THETA, THETA) * 0.5 + 0.7);\n    lights[5].c = normalize(vec3(0, INV_THETA, -THETA) * 0.5 + 0.7);\n    lights[6].c = normalize(vec3(INV_THETA, THETA, 0) * 0.5 + 0.7);\n    lights[7].c = normalize(vec3(INV_THETA, -THETA, 0) * 0.5 + 0.7);\n    lights[8].c = normalize(vec3(THETA, 0, INV_THETA) * 0.5 + 0.7);\n    lights[9].c = normalize(vec3(-THETA, 0, INV_THETA) * 0.5 + 0.7);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        lights[i].a = texture(iChannel0, vec2(float(i) * 0.18, 0.0)).x * 0.3 + 0.05;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    setUpLights();\n    \n    Ray ray;\n    ray.o = vec3(sin(iTime * 0.5) * 5.0, -12.5 + sin(iTime * 0.6) * 2.5, -25.0);\n    ray.d = normalize(rotateX(-sin(iTime * 0.23) * 0.1) *\n                      rotateZ(sin(iTime * 0.33) * 0.1) *\n                      vec4((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.7, 0.0)).xyz;\n    \n   \tvec3 color = renderScene(ray);\n    color = toneMap(color);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}