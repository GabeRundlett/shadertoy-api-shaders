{
    "Shader": {
        "info": {
            "date": "1510564589",
            "description": "Visualizing feature point and depth range computation for a small slice of the perspective frustum. The sphere is clipped against the depth bound so that only the section enclosed by the frustum is taken into account.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt2cD3",
            "likes": 6,
            "name": "Quadric Frustum Tracing",
            "published": 3,
            "tags": [
                "quadric",
                "intersection",
                "frustum"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 654
        },
        "renderpass": [
            {
                "code": "// Quadric Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// note that this version is very verbose and purposefully lacks\n// any form of optimization for the sake of education.\n\nstruct surface2x3 {\n    float c[10];\n};\n\nstruct surface2x2 {\n    float c[6];\n};\n\n#define surface2x1 vec3\n\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst float infinity = 1.0/0.0;\n\nsurface2x3 surf3;\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);\n}\n\n// rotation matrix constructor from versor\nmat3 rotation (vec4 q) {\n    float n = dot(q,q);\n    vec4 qs = (n == 0.0)?vec4(0.0):(q * (2.0 / n));\n    vec3 w = qs.w * q.xyz;\n    vec3 x = qs.x * q.xyz;\n    vec3 y = qs.y * q.xyz;\n    float zz = qs.z * q.z;\n    return mat3(\n        1.0 - (y.y + zz), x.y + w.z, x.z - w.y,\n        x.y - w.z, 1.0 - (x.x + zz), y.z + w.x,\n        x.z + w.y, y.z - w.x, 1.0 - (x.x + y.y));\n}\n\n// swizzle the components of a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// performing this twice selects zxy\nvoid surface2x3_swizzle_yzx(in surface2x3 surf, out surface2x3 dest) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float XZ = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tdest.c[0] = YY;\n\tdest.c[1] = ZZ;\n\tdest.c[2] = XX;\n\n    dest.c[3] = YZ;\n\tdest.c[4] = XY;\n\tdest.c[5] = XZ;\n\n    dest.c[6] = Y;\n\tdest.c[7] = Z;\n\tdest.c[8] = X;\n    dest.c[9] = surf.c[9];\n}\n\n// swap the x and y components of a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x2_swizzle_yx(in surface2x2 surf, out surface2x2 dest) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1];\n\tfloat X = surf.c[3]; float Y = surf.c[4];\n    dest.c[0] = YY;\n    dest.c[1] = XX;\n    dest.c[2] = surf.c[2];\n    dest.c[3] = Y;\n    dest.c[4] = X;\n    dest.c[5] = surf.c[5];\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the partial differential for the given position (x y z)\nvec3 surface2x3_diff(in surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    return vec3(\n        2.0*A*p.x + D*p.y + E*p.z + G,\n    \tD*p.x + 2.0*B*p.y + F*p.z + H,\n    \tE*p.x + F*p.y + 2.0*C*p.z + I);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the value for the given position (x y z)\nfloat surface2x3_eval(in surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n    return A*p.x*p.x + B*p.y*p.y + C*p.z*p.z\n        + D*p.x*p.y + E*p.x*p.z + F*p.y*p.z\n        + G*p.x + H*p.y + I*p.z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the value for the given position (x y)\nfloat surface2x2_eval(in surface2x2 surf, vec2 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    return A*p.x*p.x + B*p.y*p.y + C*p.x*p.y + D*p.x + E*p.y + F;\n}\n\n// transform a quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + J\n// by a 4x3 matrix to yield a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\nvoid surface2x3_new(in vec4 quadric, in mat4 mtx, out surface2x3 surf) {\n    float A = quadric.x; float B = quadric.y; float C = quadric.z; float J = quadric.w;\n    vec3 ABC = vec3(A,B,C);\n    vec3 ABC2 = ABC*2.0;\n    surf.c[0] = dot(ABC, mtx[0].xyz*mtx[0].xyz);\n    surf.c[1] = dot(ABC, mtx[1].xyz*mtx[1].xyz);\n    surf.c[2] = dot(ABC, mtx[2].xyz*mtx[2].xyz);\n    surf.c[3] = dot(ABC2, mtx[0].xyz*mtx[1].xyz);\n    surf.c[4] = dot(ABC2, mtx[0].xyz*mtx[2].xyz);\n    surf.c[5] = dot(ABC2, mtx[1].xyz*mtx[2].xyz);\n    surf.c[6] = dot(ABC2, mtx[0].xyz*mtx[3].xyz);\n    surf.c[7] = dot(ABC2, mtx[1].xyz*mtx[3].xyz);\n    surf.c[8] = dot(ABC2, mtx[2].xyz*mtx[3].xyz);\n    surf.c[9] = dot(ABC, mtx[3].xyz*mtx[3].xyz) + J;\n}\n\nvoid transformed_quadric(vec4 coeffs, vec4 rot, vec3 pos, out surface2x3 surf) {\n    mat4 mtx = mat4(transpose(rotation(rot)));\n    mat4 translate = mat4(1.0);\n    translate[3] = vec4(-pos, 1.0);\n    surface2x3_new(coeffs, mtx * translate, surf);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and x\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane_x(in surface2x3 surf, float x,\n\tout surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n    float O = surf.c[9];\n\n    // zx -> x\n    // y -> y\n    slice.c[0] = (XX*x + ZX)*x + ZZ;\n    slice.c[1] = YY;\n    slice.c[2] = XY*x + YZ;\n    slice.c[3] = X*x + Z;\n    slice.c[4] = Y;\n    slice.c[5] = O;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and y\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane_y(in surface2x3 surf, float y,\n\tout surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n    float O = surf.c[9];\n\n    // zy -> x\n    // x -> y\n    slice.c[0] = (YY*y + YZ)*y + ZZ;\n    slice.c[1] = XX;\n    slice.c[2] = XY*y + ZX;\n    slice.c[3] = Y*y + Z;\n    slice.c[4] = X;\n    slice.c[5] = O;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a projective line that goes through the origin and y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_perspective_plane(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n    slice[0] = (B*y + C)*y + A;\n    slice[1] = E*y + D;\n    slice[2] = F;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a xy plane that goes through z\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_ortho_plane_z(in surface2x3 surf, float z,\n\tout surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice.c[0] = A;\n    slice.c[1] = B;\n    slice.c[2] = D;\n    slice.c[3] = E*z + G;\n    slice.c[4] = F*z + H;\n    slice.c[5] = (C*z + I)*z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a vertical line that goes through x\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane_x(in surface2x2 surf, float x,\n\tout surface2x1 slice) {\n    float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n    float X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n\n    slice[0] = YY;\n    slice[1] = XY*x + Y;\n    slice[2] = (XX*x + X)*x + O;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a horizontal line that goes through y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane_y(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n    float X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n\n    slice[0] = XX;\n    slice[1] = XY*y + X;\n    slice[2] = (YY*y + Y)*y + O;\n}\n\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the coordinate of the inflection point\nvec2 surface2x2_center(in surface2x2 surf) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n\tfloat f = 1.0/(4.0*A*B - C*C);\n    return vec2(\n\t\t(C*E - 2.0*B*D)*f,\n        (C*D - 2.0*A*E)*f);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective ray that goes through the origin and (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_perspective_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = (A*p.x + E)*p.x + (D*p.x + B*p.y + F)*p.y + C;\n    slice[1] = G*p.x + H*p.y + I;\n    slice[2] = J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and an orthogonal ray that goes through (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_ortho_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = C;\n    slice[1] = E*p.x + F*p.y + I;\n    slice[2] = (A*p.x + G)*p.x + (D*p.x + B*p.y + H)*p.y + J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_xy(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    ZZ *= 4.0;\n\tslice.c[0] = XX*ZZ - ZX*ZX;\n    slice.c[1] = YY*ZZ - YZ*YZ;\n    slice.c[2] = XY*ZZ - 2.0*ZX*YZ;\n    slice.c[3] = X*ZZ - 2.0*ZX*Z;\n    slice.c[4] = Y*ZZ - 2.0*YZ*Z;\n    slice.c[5] = O*ZZ - Z*Z;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal yz plane\nvoid surface2x3_project_ortho_yz(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    XX *= 4.0;\n\tslice.c[0] = YY*XX - XY*XY;\n    slice.c[1] = ZZ*XX - ZX*ZX;\n    slice.c[2] = YZ*XX - 2.0*XY*ZX;\n    slice.c[3] = Y*XX - 2.0*XY*X;\n    slice.c[4] = Z*XX - 2.0*ZX*X;\n    slice.c[5] = O*XX - X*X;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal zx plane\nvoid surface2x3_project_ortho_zx(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    YY *= 4.0;\n\tslice.c[0] = ZZ*YY - YZ*YZ;\n    slice.c[1] = XX*YY - XY*XY;\n    slice.c[2] = ZX*YY - 2.0*YZ*XY;\n    slice.c[3] = Z*YY - 2.0*YZ*Y;\n    slice.c[4] = X*YY - 2.0*XY*Y;\n    slice.c[5] = O*YY - Y*Y;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the slice of the line that describes the contour of the surface\n// observed from the orthogonal x plane\nvoid surface2x2_project_ortho_x(in surface2x2 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n\tfloat X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n    YY *= 4.0;\n\tslice[0] = XX*YY - XY*XY;\n    slice[1] = X*YY - 2.0*XY*Y;\n    slice[2] = O*YY - Y*Y;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_z(in surface2x3 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    YY *= 4.0;\n\tfloat NXX = ZZ*YY - YZ*YZ;\n    float NYY = (XX*YY - XY*XY)*4.0;\n    float NXY = ZX*YY - 2.0*YZ*XY;\n    float NY = X*YY - 2.0*XY*Y;\n\tslice[0] = NXX*NYY - NXY*NXY;\n    slice[1] = (Z*YY - 2.0*YZ*Y)*NYY - 2.0*NXY*NY;\n    slice[2] = (O*YY - Y*Y)*NYY - NY*NY;\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvec2 surface2x1_bounds(float A, float B, float C) {\n    // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n    float a_neg_rcp = -1.0/A;\n    float k = 0.5*B*a_neg_rcp;\n    float q = sqrt(k*k + C*a_neg_rcp);\n    return k + vec2(-q,q);\n}\n\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvec2 surface2x1_bounds(in surface2x1 surf) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    return surface2x1_bounds(A, B, C);\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the coordinate of the inflection point\nfloat surface2x1_center(in surface2x1 surf) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    return -B / (2.0*A);\n}\n\nstruct bounds2x3 {\n    vec3 v0, v1;\n    vec3 eh0_0, eh0_1, eh1_0, eh1_1;\n    vec3 ev0_0, ev0_1, ev1_0, ev1_1;\n    vec3 c00_0, c01_0, c10_0, c11_0;\n    vec3 c00_1, c01_1, c10_1, c11_1;\n};\n\nbool in_wedge(vec2 p, vec2 u) {\n    return (p.x >= u[0]*p.y) && (p.x <= u[1]*p.y);\n}\nbool in_frustum(vec3 p, vec2 u, vec2 v) {\n    return in_wedge(p.xz, u) && in_wedge(p.yz, v);\n}\n\nvoid merge_plane_range(inout vec2 outer, vec2 p0, vec2 p1, vec2 u) {\n    outer[0] = in_wedge(p0, u)?min(outer[0], p0.y):outer[0];\n    outer[1] = in_wedge(p1, u)?max(outer[1], p1.y):outer[1];\n}\n\nvoid merge_corner_range(inout vec2 outer, inout vec2 inner, float z0, float z1) {\n    outer[0] = min(outer[0], z0);\n    outer[1] = max(outer[1], z1);\n    inner[0] = max(inner[0], (z0 == z0)?z0:infinity);\n    inner[1] = min(inner[1], (z1 == z1)?z1:-infinity);\n}\n\nvec4 compute_bounds(bounds2x3 bounds, vec2 u, vec2 v) {\n    vec2 outer = vec2(infinity, -infinity);\n    vec2 inner = vec2(-infinity, infinity);\n\n    outer[0] = in_frustum(bounds.v0, u, v)?min(outer[0], bounds.v0.z):outer[0];\n    outer[1] = in_frustum(bounds.v1, u, v)?max(outer[1], bounds.v1.z):outer[1];\n    \n    merge_corner_range(outer, inner, bounds.c00_0.z, bounds.c00_1.z);\n    merge_corner_range(outer, inner, bounds.c01_0.z, bounds.c01_1.z);\n    merge_corner_range(outer, inner, bounds.c10_0.z, bounds.c10_1.z);\n    merge_corner_range(outer, inner, bounds.c11_0.z, bounds.c11_1.z);\n    \n    merge_plane_range(outer, bounds.eh0_0.yz, bounds.eh0_1.yz, v);\n    merge_plane_range(outer, bounds.eh1_0.yz, bounds.eh1_1.yz, v);\n    merge_plane_range(outer, bounds.ev0_0.xz, bounds.ev0_1.xz, u);\n    merge_plane_range(outer, bounds.ev1_0.xz, bounds.ev1_1.xz, u);\n\n    return vec4(outer, inner);\n}\n\nvoid compute_bounding_points_compact(surface2x3 surf, vec2 u, vec2 v, out bounds2x3 bounds) {\n\n    float surf_c7_c7 = surf.c[7]*surf.c[7];\n    float surf_2x_c0 = 2.0*surf.c[0];\n    float surf_2x_c1 = 2.0*surf.c[1];\n    float surf_2x_c3 = 2.0*surf.c[3];\n    float surf_2x_c6 = 2.0*surf.c[6];\n    float surf_4x_c1 = 4.0*surf.c[1];\n    \n    {\n\t    float surf_4x_c0_c1_sub_c3_c3 = surf_2x_c0*surf_2x_c1 - surf.c[3]*surf.c[3];\n        \n        // extract contour of quadratic along z plane\n        float NXY = surf.c[4]*surf_4x_c1 - surf.c[5]*surf_2x_c3;\n        float NY = surf.c[6]*surf_4x_c1 - surf.c[7]*surf_2x_c3;\n        float NYY = surf_4x_c0_c1_sub_c3_c3*4.0;\n\n        // compute z bounds of volume\n        vec2 vz = surface2x1_bounds(\n        \t(surf.c[2]*surf_4x_c1 - surf.c[5]*surf.c[5])*NYY - NXY*NXY,\n        \t(surf.c[8]*surf_4x_c1 - 2.0*surf.c[5]*surf.c[7])*NYY - 2.0*NXY*NY,\n        \t(surf.c[9]*surf_4x_c1 - surf_c7_c7)*NYY - NY*NY);\n        // extract quadratic of plane at volume z bounds\n        float slice_z0_c3 = surf.c[4]*vz[0] + surf.c[6];\n        float slice_z0_c4 = surf.c[5]*vz[0] + surf.c[7];\n\n        float slice_z1_c3 = surf.c[4]*vz[1] + surf.c[6];\n        float slice_z1_c4 = surf.c[5]*vz[1] + surf.c[7];\n\n        // compute position of contact points at volume z bounds\n        float f = 1.0/surf_4x_c0_c1_sub_c3_c3;\n        bounds.v0 = vec3(\n            (surf.c[3]*slice_z0_c4 - surf_2x_c1*slice_z0_c3)*f,\n            (surf.c[3]*slice_z0_c3 - surf_2x_c0*slice_z0_c4)*f,\n        \tvz[0]);\n        bounds.v1 = vec3(\n            (surf.c[3]*slice_z1_c4 - surf_2x_c1*slice_z1_c3)*f,\n            (surf.c[3]*slice_z1_c3 - surf_2x_c0*slice_z1_c4)*f,\n        \tvz[1]);\n    }\n    \n    // compute z bounds of corner quadratics\n    // compute position of contact points at corner z bounds\n    {\n    \tfloat surf_2x_c7 = 2.0*surf.c[7];\n        float surf_c1_v0 = surf.c[1]*v[0];\n        float surf_c7_v0 = surf.c[7]*v[0];\n        float surf_c1_v1 = surf.c[1]*v[1];\n        float surf_c7_v1 = surf.c[7]*v[1];   \n        \n        // compute z bounds of plane contours    \n        // compute position of contact points at plane z bounds\n        float surf_2x_c1_neg_rcp = -1.0 / surf_2x_c1;\n\t    float surf_4x_c9_c1_sub_c7_c7 = surf.c[9]*surf_4x_c1 - surf_c7_c7;\n        \n        {\n            float slice_x0_c0 = (surf.c[0]*u[0] + surf.c[4])*u[0] + surf.c[2];\n            float slice_x0_c2 = surf.c[3]*u[0] + surf.c[5];\n            float slice_x0_c3 = surf.c[6]*u[0] + surf.c[8];\n\n            {\n                vec2 cx0y0 = surface2x1_bounds((surf_c1_v0 + slice_x0_c2)*v[0] + slice_x0_c0, surf_c7_v0 + slice_x0_c3, surf.c[9]);\n                bounds.c00_0 = vec3(u[0], v[0], 1.0) * cx0y0[0];\n                bounds.c00_1 = vec3(u[0], v[0], 1.0) * cx0y0[1];\t\n            }\n            {\n                vec2 cx0y1 = surface2x1_bounds((surf_c1_v1 + slice_x0_c2)*v[1] + slice_x0_c0, surf_c7_v1 + slice_x0_c3, surf.c[9]);\n                bounds.c01_1 = vec3(u[0], v[1], 1.0) * cx0y1[1];\n                bounds.c01_0 = vec3(u[0], v[1], 1.0) * cx0y1[0];\n            }\n            {\n                vec2 ph0 = surface2x1_bounds(slice_x0_c0*surf_4x_c1 - slice_x0_c2*slice_x0_c2, slice_x0_c3*surf_4x_c1 - slice_x0_c2*surf_2x_c7, surf_4x_c9_c1_sub_c7_c7);\n                bounds.eh0_0 = vec3(ph0[0] * u[0], (slice_x0_c2*ph0[0] + surf.c[7]) * surf_2x_c1_neg_rcp, ph0[0]);\n                bounds.eh0_1 = vec3(ph0[1] * u[0], (slice_x0_c2*ph0[1] + surf.c[7]) * surf_2x_c1_neg_rcp, ph0[1]);\n            }\n            \n        }\n        {\n            float slice_x1_c0 = (surf.c[0]*u[1] + surf.c[4])*u[1] + surf.c[2];\n            float slice_x1_c2 = surf.c[3]*u[1] + surf.c[5];\n            float slice_x1_c3 = surf.c[6]*u[1] + surf.c[8];\n\n            {\n                vec2 cx1y0 = surface2x1_bounds((surf_c1_v0 + slice_x1_c2)*v[0] + slice_x1_c0, surf_c7_v0 + slice_x1_c3, surf.c[9]);\n                bounds.c10_0 = vec3(u[1], v[0], 1.0) * cx1y0[0];\n                bounds.c10_1 = vec3(u[1], v[0], 1.0) * cx1y0[1];\n            }\n            {\n                vec2 cx1y1 = surface2x1_bounds((surf_c1_v1 + slice_x1_c2)*v[1] + slice_x1_c0, surf_c7_v1 + slice_x1_c3, surf.c[9]);\n                bounds.c11_1 = vec3(u[1], v[1], 1.0) * cx1y1[1];\n                bounds.c11_0 = vec3(u[1], v[1], 1.0) * cx1y1[0];\n            }\n            {\n                vec2 ph1 = surface2x1_bounds(slice_x1_c0*surf_4x_c1 - slice_x1_c2*slice_x1_c2, slice_x1_c3*surf_4x_c1 - slice_x1_c2*surf_2x_c7, surf_4x_c9_c1_sub_c7_c7);        \n                bounds.eh1_0 = vec3(ph1[0] * u[1], (slice_x1_c2*ph1[0] + surf.c[7]) * surf_2x_c1_neg_rcp, ph1[0]);\n                bounds.eh1_1 = vec3(ph1[1] * u[1], (slice_x1_c2*ph1[1] + surf.c[7]) * surf_2x_c1_neg_rcp, ph1[1]);\n            }\n            \n        }\n    }    \n    \n    {\n\t    float surf_4x_c0 = 4.0*surf.c[0];        \n    \tfloat surf_4x_c9_c0_sub_c6_c6 = surf.c[9]*surf_4x_c0 - surf.c[6]*surf.c[6];\n        \n        // compute z bounds of plane contours\n        // compute position of contact points at plane z bounds\n        float surf_2x_c0_neg_rcp = -1.0 / surf_2x_c0;\n        {\n            float slice_y0_c0 = (surf.c[1]*v[0] + surf.c[5])*v[0] + surf.c[2];\n            float slice_y0_c2 = surf.c[3]*v[0] + surf.c[4];\n            float slice_y0_c3 = surf.c[7]*v[0] + surf.c[8];\n            \n            vec2 pv0 = surface2x1_bounds(slice_y0_c0*surf_4x_c0 - slice_y0_c2*slice_y0_c2, slice_y0_c3*surf_4x_c0 - slice_y0_c2*surf_2x_c6, surf_4x_c9_c0_sub_c6_c6);\n            bounds.ev0_0 = vec3((slice_y0_c2*pv0[0] + surf.c[6]) * surf_2x_c0_neg_rcp, pv0[0] * v[0], pv0[0]);\n            bounds.ev0_1 = vec3((slice_y0_c2*pv0[1] + surf.c[6]) * surf_2x_c0_neg_rcp, pv0[1] * v[0], pv0[1]);\n        }\n        \n        {\n            float slice_y1_c0 = (surf.c[1]*v[1] + surf.c[5])*v[1] + surf.c[2];\n            float slice_y1_c2 = surf.c[3]*v[1] + surf.c[4];\n            float slice_y1_c3 = surf.c[7]*v[1] + surf.c[8];\n            \n            vec2 pv1 = surface2x1_bounds(slice_y1_c0*surf_4x_c0 - slice_y1_c2*slice_y1_c2, slice_y1_c3*surf_4x_c0 - slice_y1_c2*surf_2x_c6, surf_4x_c9_c0_sub_c6_c6);\n            bounds.ev1_0 = vec3((slice_y1_c2*pv1[0] + surf.c[6]) * surf_2x_c0_neg_rcp, pv1[0] * v[1], pv1[0]);\n            bounds.ev1_1 = vec3((slice_y1_c2*pv1[1] + surf.c[6]) * surf_2x_c0_neg_rcp, pv1[1] * v[1], pv1[1]);\n        }\n    }\n}\n\nvoid compute_bounding_points_clean(surface2x3 surf, vec2 u, vec2 v, out bounds2x3 bounds) {\n\n\n    surface2x1 contour_z;\n    // extract contour of quadratic along z plane\n    surface2x3_project_ortho_z(surf3, contour_z);\n    // compute z bounds of volume\n    vec2 vz = surface2x1_bounds(contour_z);\n    surface2x2 slice_z0;\n    surface2x2 slice_z1;\n    // extract quadratic of plane at volume z bounds\n    surface2x3_ortho_plane_z(surf3, vz[0], slice_z0);\n    surface2x3_ortho_plane_z(surf3, vz[1], slice_z1);\n    // compute position of contact points at volume z bounds\n    bounds.v0 = vec3(surface2x2_center(slice_z0),vz[0]);\n    bounds.v1 = vec3(surface2x2_center(slice_z1),vz[1]);\n\n    // extract quadratic at planes\n    surface2x2 slice_x0;\n    surface2x2 slice_x1;\n    surface2x2 slice_y0;\n    surface2x2 slice_y1;\n\tsurface2x3_perspective_plane_x(surf3, u[0], slice_x0);\n    surface2x3_perspective_plane_x(surf3, u[1], slice_x1);\n\tsurface2x3_perspective_plane_y(surf3, v[0], slice_y0);\n    surface2x3_perspective_plane_y(surf3, v[1], slice_y1);\n\n    surface2x1 contour_h0;\n    surface2x1 contour_h1;\n    surface2x1 contour_v0;\n    surface2x1 contour_v1;\n    // extract contour of quadratics at planes\n    surface2x2_project_ortho_x(slice_x0, contour_h0);\n    surface2x2_project_ortho_x(slice_x1, contour_h1);\n    surface2x2_project_ortho_x(slice_y0, contour_v0);\n    surface2x2_project_ortho_x(slice_y1, contour_v1);\n    // compute z bounds of plane contours\n    vec2 ph0 = surface2x1_bounds(contour_h0);\n    vec2 ph1 = surface2x1_bounds(contour_h1);\n    vec2 pv0 = surface2x1_bounds(contour_v0);\n    vec2 pv1 = surface2x1_bounds(contour_v1);\n\n\n    surface2x1 slice_h0z0;\n    surface2x1 slice_h0z1;\n    surface2x1 slice_h1z0;\n    surface2x1 slice_h1z1;\n    surface2x1 slice_v0z0;\n    surface2x1 slice_v0z1;\n    surface2x1 slice_v1z0;\n    surface2x1 slice_v1z1;\n\n    // extract quadratic of line at plane z bounds\n    surface2x2_ortho_plane_x(slice_x0, ph0[0], slice_h0z0);\n    surface2x2_ortho_plane_x(slice_x0, ph0[1], slice_h0z1);\n    surface2x2_ortho_plane_x(slice_x1, ph1[0], slice_h1z0);\n    surface2x2_ortho_plane_x(slice_x1, ph1[1], slice_h1z1);\n    surface2x2_ortho_plane_x(slice_y0, pv0[0], slice_v0z0);\n    surface2x2_ortho_plane_x(slice_y0, pv0[1], slice_v0z1);\n    surface2x2_ortho_plane_x(slice_y1, pv1[0], slice_v1z0);\n    surface2x2_ortho_plane_x(slice_y1, pv1[1], slice_v1z1);\n\n    // compute position of contact points at plane z bounds\n    bounds.eh0_0 = vec3(ph0[0] * u[0], surface2x1_center(slice_h0z0), ph0[0]);\n    bounds.eh1_0 = vec3(ph1[0] * u[1], surface2x1_center(slice_h1z0), ph1[0]);\n    bounds.ev0_0 = vec3(surface2x1_center(slice_v0z0), pv0[0] * vec2(v[0],1.0));\n    bounds.ev1_0 = vec3(surface2x1_center(slice_v1z0), pv1[0] * vec2(v[1],1.0));\n    bounds.eh0_1 = vec3(ph0[1] * u[0], surface2x1_center(slice_h0z1), ph0[1]);\n    bounds.eh1_1 = vec3(ph1[1] * u[1], surface2x1_center(slice_h1z1), ph1[1]);\n    bounds.ev0_1 = vec3(surface2x1_center(slice_v0z1), pv0[1] * vec2(v[0],1.0));\n    bounds.ev1_1 = vec3(surface2x1_center(slice_v1z1), pv1[1] * vec2(v[1],1.0));\n\n    // extract quadratic of corners\n    surface2x1 slice_x0y0;\n    surface2x1 slice_x0y1;\n    surface2x1 slice_x1y0;\n    surface2x1 slice_x1y1;\n\tsurface2x2_perspective_plane(slice_x0, v[0], slice_x0y0);\n    surface2x2_perspective_plane(slice_x0, v[1], slice_x0y1);\n\tsurface2x2_perspective_plane(slice_x1, v[0], slice_x1y0);\n    surface2x2_perspective_plane(slice_x1, v[1], slice_x1y1);\n\n    // compute z bounds of corner quadratics\n    vec2 cx0y0 = surface2x1_bounds(slice_x0y0);\n    vec2 cx0y1 = surface2x1_bounds(slice_x0y1);\n    vec2 cx1y0 = surface2x1_bounds(slice_x1y0);\n    vec2 cx1y1 = surface2x1_bounds(slice_x1y1);\n\n    // compute position of contact points at corner z bounds\n    bounds.c00_0 = vec3(u[0], v[0], 1.0) * cx0y0[0];\n    bounds.c01_0 = vec3(u[0], v[1], 1.0) * cx0y1[0];\n    bounds.c10_0 = vec3(u[1], v[0], 1.0) * cx1y0[0];\n    bounds.c11_0 = vec3(u[1], v[1], 1.0) * cx1y1[0];\n    bounds.c00_1 = vec3(u[0], v[0], 1.0) * cx0y0[1];\n    bounds.c01_1 = vec3(u[0], v[1], 1.0) * cx0y1[1];\n    bounds.c10_1 = vec3(u[1], v[0], 1.0) * cx1y0[1];\n    bounds.c11_1 = vec3(u[1], v[1], 1.0) * cx1y1[1];\n\n\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    vec2 frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    vec2 frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n\n    // transform our simplex a bit\n    vec2 plane_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    vec4 plane_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    vec3 plane_normal = rotate(plane_rotation, vec3(0.0, 0.0, 1.0));\n    vec3 ellipsoid_size = vec3(1.0,3.0,1.0) * 0.3;\n    //plane_rotation = vec4(0.0,0.0,0.0,1.0);\n    transformed_quadric(\n        vec4(1.0 / (ellipsoid_size*ellipsoid_size) * vec3(1.0,1.0,1.0),-1.0),\n\t\tplane_rotation, vec3(plane_offset + vec2(0.0,0.0),1.0), surf3);\n\n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nfloat distborder(float x) {\n\treturn 1.0 - clamp(x*400.0, 0.0, 1.0);\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);\n\n    //scale(0.3);\n\n    float rdot = AAINV*2.0;\n\n    vec2 ofs = vec2(0.05, -0.12);\n    if (iMouse.z > 0.5) {\n        ofs = get_query();\n    }\n\n    vec2 u = vec2(-1.0,1.0) * 0.1 + ofs.x;\n    vec2 v = vec2(-1.0,1.0) * 0.1 + ofs.y;\n\n    bounds2x3 bounds;\n    compute_bounding_points_compact(surf3, u, v, bounds);\n\n\tvec4 range = compute_bounds(bounds, u, v);\n\n    surface2x2 contour_zy;\n    surface2x3_project_ortho_yz(surf3, contour_zy);\n    surface2x2_swizzle_yx(contour_zy,contour_zy);\n\n#if 1\n    {\n        vec2 p = get_origin();\n        surface2x1 surf1;\n        surface2x3_perspective_ray(surf3, p, surf1);\n        vec2 d = surface2x1_bounds(surf1);\n        float d0 = d[0];\n\t\tfloat d1 = d[1];\n        vec3 normal0 = normalize(surface2x3_diff(surf3, vec3(p,d0)));\n        vec3 normal1 = normalize(surface2x3_diff(surf3, vec3(p,d1)));\n\n        if ((d0 > 0.0) && (d1 > d0)) {\n            vec3 pos0 = vec3(p,1.0) * d0;\n            vec3 pos1 = vec3(p,1.0) * d1;\n            vec3 color0 = (sin(d0*100.0)*0.5+0.5) * (normal0 * 0.5 + 0.5);\n            vec3 color1 = hsl(d1 * 10.0,0.5,0.9) * (normal1 * 0.5 + 0.5);\n\n#if 0\n            if (!in_wedge(pos0.yz, v)) {\n                color0 *= 0.3;\n            }\n#else\n            if ((pos0.z < range[0])||(pos0.z > range[1]))\n                color0 = color1;\n            if ((pos1.z < range[0])||(pos1.z > range[1]))\n                color1 = vec3(0.0, 0.0, 0.2);\n#endif\n\n            vec3 color = mix(color0, color1, 0.4);\n            if (pos0.z > range[2]) {\n                color *= vec3(0.2,0.2,1.0);\n            }\n#if 0\n            color = mix(color, vec3(1.0, 1.0, 1.0), distborder(length(pos0 - bounds.v0) - 0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.v1) - 0.01));\n\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.eh0_1)-0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.eh1_1)-0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.ev0_1)-0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.ev1_1)-0.01));\n\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.eh0_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.eh1_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.ev0_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.ev1_0)-0.02));\n\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c00_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c01_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c10_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c11_0)-0.02));\n\n            //color = mix(color, vec3(1.0), distborder(abs(pos0.z - bounds.ev1_0.z)-0.005));\n#endif\n\n            color = clamp(color, vec3(0.0), vec3(1.0));\n            set_source_rgb(color);\n            clear();\n        } else {\n            set_source_rgb(vec3(0.0,0.0,0.2));\n            clear();\n        }\n    }\n#else\n    set_source_rgb(vec3(0.0));\n    clear();\n#endif\n\n\n    set_source_rgb(vec3(1.0));\n    set_line_width_px(0.5);\n\n    move_to(u[0],-1.0);\n    line_to(u[0],1.0);\n\tstroke();\n    move_to(u[1],-1.0);\n    line_to(u[1],1.0);\n\tstroke();\n    move_to(-2.0,v[0]);\n    line_to( 2.0,v[0]);\n\tstroke();\n    move_to(-2.0,v[1]);\n    line_to( 2.0,v[1]);\n\tstroke();\n\n    surface2x2 slice_x0;\n    surface2x2 slice_x1;\n\tsurface2x3_perspective_plane_x(surf3, u[0], slice_x0);\n    surface2x3_perspective_plane_x(surf3, u[1], slice_x1);\n\n    set_source_rgb(vec3(1.0));\n    set_line_width_px(1.3);\n    add_field(surface2x2_eval(contour_zy, get_origin())*0.01);\n    stroke();\n    add_field(surface2x2_eval(slice_x0, get_origin())*0.3);\n    stroke();\n    add_field(surface2x2_eval(slice_x1, get_origin())*0.3);\n    stroke();\n\n    move_to(0.0, 0.0);\n\tline_to(2.0,v[1]*2.0);\n    move_to(0.0, 0.0);\n\tline_to(2.0,v[0]*2.0);\n    stroke();\n\n#define DRAW_Z(N) move_to(N, v[0]*N); line_to(N, v[1]*N); stroke();\n    DRAW_Z(range[0]);\n    DRAW_Z(range[1]);\n    set_source_rgba(1.0,1.0,1.0,0.5);\n    DRAW_Z(range[2]);\n    DRAW_Z(range[3]);\n\n    set_source_rgb(hsl(0.06,1.0,0.6));\n    circle(bounds.v0.zy, rdot * 2.0);\n    fill();\n    set_source_rgb(hsl(0.25,1.0,0.6));\n    circle(bounds.eh0_0.zy, rdot * 2.0);\n    circle(bounds.eh1_0.zy, rdot * 2.0);\n    circle(bounds.ev0_0.zy, rdot * 2.0);\n    circle(bounds.ev1_0.zy, rdot * 2.0);\n    fill();\n    set_source_rgb(hsl(0.6,1.0,0.6));\n    circle(bounds.c00_0.zy, rdot * 2.0);\n    circle(bounds.c01_0.zy, rdot * 2.0);\n    circle(bounds.c10_0.zy, rdot * 2.0);\n    circle(bounds.c11_0.zy, rdot * 2.0);\n    fill();\n    set_source_rgb(hsl(0.06,1.0,0.6));\n    circle(bounds.v1.zy, rdot);\n    fill();\n    set_source_rgb(hsl(0.25,1.0,0.6));\n    circle(bounds.eh0_1.zy, rdot);\n    circle(bounds.eh1_1.zy, rdot);\n    circle(bounds.ev0_1.zy, rdot);\n    circle(bounds.ev1_1.zy, rdot);\n    fill();\n    set_source_rgb(hsl(0.6,1.0,0.6));\n    circle(bounds.c00_1.zy, rdot);\n    circle(bounds.c01_1.zy, rdot);\n    circle(bounds.c10_1.zy, rdot);\n    circle(bounds.c11_1.zy, rdot);\n    fill();\n\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = sqrt(_color);\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    c = clamp(c, vec4(0.0), vec4(1.0));\n    c.rgb = c.rgb*c.rgb;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}