{
    "Shader": {
        "info": {
            "date": "1667825718",
            "description": "Antique train with track based on generalized hexagonal Truchet tiles (mouseable, multiple views)",
            "flags": 0,
            "hasliked": 0,
            "id": "dd2GRy",
            "likes": 38,
            "name": "Truchet's Train",
            "published": 3,
            "tags": [
                "grid",
                "truchet",
                "path",
                "train"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 454
        },
        "renderpass": [
            {
                "code": "// \"Truchet's Train\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Three separate raymarching loops: a regular loop for the train, and\n separate hexagonal-grid loops (B) for the Truchet-tiled train tracks\n and (S) for the trees. Tree placement requires both grids to keep\n trees off tracks.\n\n  No. 19 in \"Train\" series\n    \"Train Ride\"                  (4s2Sz3)\n    \"Toy Train\"                   (4tfGzr)\n    \"Gotthard Tunnel\"             (MlSXRR)\n    \"Sneak Preview\"               (XsK3R3)\n    \"Ride the Loop\"               (lsK3Rc)\n    \"Lost Egg\"                    (ls3XDn)\n    \"Thomas X3\"                   (ldtXD8)\n    \"Complex Tunnels\"             (4dtXW4)\n    \"Express Train\"               (MsdSDM)\n    \"Train Builder\"               (4tlcz7)\n    \"Alpine Express\"              (4t2fW1)\n    \"White Pass Route\"            (ltSBzG)\n    \"Time Released\"               (MdVBDK)\n    \"Train Ride 2\"                (XlVczW)\n    \"Roller-Coaster\"              (Wtl3Rl)\n    \"Riding the Textured Tunnel\"  (WdVXzD)\n    \"Live Assembly Instructions\"  (WlcSD2)\n    \"Underground Trains\"          (tsKyzw)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define P_LONG  1  // (= 0/1) for longer path\n\n#if P_LONG\n#define PLEN 17\n#else\n#define PLEN 13\n#endif\n\n#define N_CAR 4\n\nvec4 cPath[PLEN], carPos[N_CAR];\nvec3 qHit, sunDir, tOff;\nvec2 cIdB, cIdS, cMidB, cMidS, wlBase;\nfloat dstFar, tCur, hgSizeB, hgSizeS, tEnd[PLEN + 1], tLen, trVel, cDir, cType, gHt,\n   csOcc, trSzFac;\nint idObj;\nbool trees;\nconst int idGrnd = 1, idFenc = 2, idBrdg = 3, idBrdgP = 4, idRail = 5, idTree = 6, idLeaf = 7, \n  idEng = 8, idCar = 9, idRf = 10, idWhl = 11, idAxle = 12, idCrod = 13, idFun = 14, idCpl = 15,\n  idLamp = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchDist (vec2 p)\n{ // (from \"Generalized Truchet Path\" with longer default path)\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  ac = 0.5 - atan (dp.y, - dp.x) / (2. * pi);\n  cxy = cIdB.x - cIdB.y;\n#if P_LONG  \n  if (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ac *= -1.;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n#else\n  if (ct && cxy < 0.) ac *= -1.;\n#endif\n  return vec3 (d, rc, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n#if P_LONG  \n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. || \n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n#else\n  offTrk = (cxy == -2. && wm.y > 0. || ! cyo && (abs (cxy) == 2. || cxy == -3. && w.y > -0.3 ||\n     cxy == -1. && wm.y > 0. || cxy == 1. && wm.y < 0.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || cxy == 1. && wm.x < 0. ||\n     cxy == 2. && wm.y < 0.));\n#endif\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n#if P_LONG\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n#else\n  cPath[ 8] = vec4 (2., 1., -1./6., tl);\n  cPath[ 9] = vec4 (3., 1., 1./3., - ts);\n  cPath[10] = vec4 (2., 2., 5./6., tl);\n#endif\n  cPath[PLEN - 2] = vec4 (1., 2., -1./3., ts);\n  cPath[PLEN - 1] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = Rot2D (vec2 (0., 1.), pi * cp.z);\n  return (HexToPix (tp) + dc * vd - r * Rot2D (vd, tt * a)) * hgSizeB;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{  // (from \"White Pass Route\")\n  vec3 q;\n  float wRad, d, aw, sx, tw;\n  tw = wlBase.x;\n  wRad = 0.8;\n  q = p;\n  d = max (max (PrBoxDf (vec3 (q.xy, q.z + 1.75), vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (vec3 (q.xy, q.z + 1.95), vec3 (0.95, 1.3, 0.65))),\n     - PrBox2Df (q.yz - vec2 (0.7, -1.75), vec2 (0.5, 0.4)));\n  d = min (d, max (PrCapsDf (q - vec3 (0., -0.2, 0.5), 1., 2.), - (q.z + 1.2)));\n  d = min (min (min (min (d, PrBoxDf (q - vec3 (0., -0.5, -3.15), vec3 (1., 0.7, 0.3))),\n     PrBoxDf (q - vec3 (0., -1.3, -0.25), vec3 (1., 0.1, 3.2))),\n     PrBoxDf (q - vec3 (0., -1.4, 3.), vec3 (1.1, 0.2, 0.07))),\n     PrCylDf (vec3 (abs (q.x) - 0.6, q.y + 1.4, q.z - 3.1), 0.2, 0.1));\n  DMINQ (idEng);\n  d = max (PrCylDf (q - vec3 (0., -2.35, -1.77), 4., 0.7), max (1.4 - q.y, abs (q.x) - 1.35));\n  DMINQ (idRf);\n  d = PrCylDf ((q - vec3 (0., -1.4, -3.5)).xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  d = min (PrCylDf ((q - vec3 (0., 1.1, 2.)).xzy, 0.3, 0.5),\n     PrCylDf ((q - vec3 (0., 1.5, 2.)).xzy, 0.4, 0.15));\n  d = min (d, PrCapsDf ((q - vec3 (0., 0.8, 0.5)).xzy, 0.3, 0.2));\n  DMINQ (idFun);\n  q = p;\n  q.yz -= vec2 (-0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.2);\n  DMINQ (idLamp);\n  q = p; \n  q.xz = abs (q.xz);\n  q -= vec3 (tw - 0.12, -1.4, wlBase.y);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1), PrCylDf (q.zyx - vec3 (0.,0., -0.07),\n     wRad + 0.05, 0.03)), - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (tw - 0.17, -1.4, sign (q.z * wlBase.y));\n  aw = - trVel * tCur / (wRad * trSzFac);\n  q.yz = Rot2D (q.yz, aw);  \n  q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.);\n  q.z -= -0.5 * wRad;\n  d = min (d, PrCylDf (q, 0.05, 0.5 * wRad));\n  DMINQ (idWhl);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);\n  q.xy -= vec2 (tw + 0.08, -1.4);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);\n  q.xz -= vec2 (-0.1, wlBase.y);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  DMINQ (idCrod);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -1.4, wlBase.y);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, tw;\n  wRad = 0.35;\n  tw = wlBase.x;\n  q = p;\n  d = PrBoxDf (q, vec3 (1.3, 1.4, 2.8));\n  DMINQ (idCar);\n  d = max (PrCylDf (vec3 (q.x, q.y + 2.35, q.z), 4., 2.85), max (1.4 - q.y, abs (q.x) - 1.35));\n  DMINQ (idRf);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (-1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (tw - 0.1, -1.85, wlBase.y);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1), PrCylDf (q.zyx - vec3 (0.,0., -0.07),\n     wRad + 0.05, 0.03)), PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  DMINQ (idWhl);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (-1.85, wlBase.y);\n  d = PrCylDf (q.zyx, 0.05, tw);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar / trSzFac;\n  q = (p - carPos[0].xyz) / trSzFac;\n  q.xz = Rot2D (q.xz, carPos[0].w);\n  dMin = EngDf (q, dMin);\n  for (int k = VAR_ZERO + 1; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    dMin = CarDf (q, dMin);\n  }\n  return dMin * trSzFac;\n}\n\nvec4 TrnCol ()\n{\n  vec4 col4, carCol, carCol2;\n  carCol = vec4 (0.1, 0.1, 1., 0.2);\n  carCol2 = vec4 (0.7, 1., 0.7, 0.2);\n  if (idObj == idEng || idObj == idCar) {\n    col4 = mix (carCol2, carCol, smoothstep (0., 0.05, abs (abs (qHit.y + 0.25) - 0.1) - 0.02)) *\n       (0.5 + 0.5 * step (-1.15, qHit.y));\n  }\n  if (idObj == idEng) {\n    if (min (max (abs (abs (qHit.x) - 0.5) - 0.4, abs (qHit.y - 1.1) - 0.2),\n       max (abs (abs (qHit.z - 1.) - 1.5) - 0.1,  - qHit.y - 1.1)) < 0.)\n       col4 = vec4 (0.4, 0.4, 0.1, -1.);\n    if (qHit.z > 3.1 && qHit.y < -1.) col4 = carCol;\n    if (qHit.z < -2.8 && qHit.y > 0.1) col4 = vec4 (vec3 (0.01), 0.);\n  } else if (idObj == idCar) {\n    if (min (max (abs (abs (qHit.z) - 1.25) - 1., abs (qHit.y - 0.6) - 0.5),\n       length (vec2 (qHit.xy - vec2 (0., 0.6))) - 0.4) < 0.) col4 = vec4 (0.4, 0.4, 0.1, -1.);\n  } else if (idObj == idRf) {\n    col4 = carCol2;\n    if (length (qHit.xy - vec2 (0., -2.35)) > 3.97)\n       col4 *= (0.8 + 0.2 * smoothstep (0., 0.05, abs (fract (4. * qHit.x + 0.5) - 0.5)));\n  } else if (idObj == idFun) {\n    col4 = ((qHit.y > 1.35) ? carCol : carCol2) * (0.5 + 0.5 * step (0.25,\n       length (vec2 (qHit.xz - vec2 (0., 2.)))));\n  } else if (idObj == idAxle) {\n    col4 = vec4 (0.3, 0.3, 0.35, 0.);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.6, 0.6, 0.7, 0.1);\n  } else if (idObj == idCpl) {\n    col4 = vec4 (0.3, 0.3, 0.3, 0.);\n  } else if (idObj == idCrod) {\n    col4 = vec4 (0.7, 0.7, 0.1, 0.1);\n  } else if (idObj == idLamp) {\n    col4 = (length (qHit.xy) < 0.16) ? ((mod (tCur, 2.) < 1.) ? vec4 (1., 1., 0.8, -1.) :\n       vec4 (0.8, 0.8, 0.4, 0.)) : carCol2;\n  }\n  return col4;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n#if P_LONG\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n#else\n  else if (abs (cxy) == 2. || cxy == -3.) cType = 2.;\n  if (cType <= 2.) cDir = 2. * mod (cIdB.x, 2.) - 1.;\n#endif\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 2.;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 0.05 * f / aSum;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 ws;\n  float dMin, d, dt, dWid, eWid, rc, ac, dh, r, h;\n  dWid = 0.5;\n  eWid = 0.2;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidB) / hgSizeB;\n    cm3 = TruchDist (q.xz);\n    dt = hgSizeB * cm3.x;\n    rc = cm3.y;\n    ac = 18. * cm3.z;\n    dh = hgSizeB * HexEdgeDist (q.xz);\n    ws = vec2 (0.005, 0.01);\n    if (cType <= 2. && rc != 0. && OnTrk (q.xz)) {\n      d = PrRoundBox2Df (vec2 (dt - wlBase.x * trSzFac + ws.x, q.y - ws.y), ws, 0.003);\n      DMIN (idRail);\n    }\n    h = gHt + GrndHt (p.xz) - 0.05;\n    d = dot (vec2 (dt - dWid, h - q.y), sin (0.13 * pi + vec2 (0.5 * pi, 0.)));\n    d = SmoothMin (q.y, SmoothMax (q.y - h, - d, 0.1), 0.1);\n    d = SmoothMax (d, - max (PrBox2Df (vec2 (dh, q.y - gHt - 0.05),\n       vec2 (eWid, 0.1)), 1.25 - dt), 0.05);\n    DMIN (idGrnd);\n    r = length (vec2 (dt, q.y + 1.)) - 1.8;\n    d = max (abs (abs (r) - 0.1) - 0.025, abs (dh - 0.23) - 0.01);\n    DMIN (idBrdg);\n    d = max (abs (r + 0.1) - 0.01, abs (dh) - 0.23);\n    DMIN (idBrdgP);\n    if (rc != 0.) {\n      d = min (length (vec2 (dt - dWid + 0.2, q.y - 0.2)) - 0.011,\n         max (PrRoundBox2Df (vec2 (dt - dWid + 0.2, (fract (10. * rc * ac + 0.5) - 0.5) / 10.),\n         vec2 (0.01, 0.003), 0.001), q.y - 0.2));\n      DMIN (idFenc);\n    }\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeB;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeB));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    d = BObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    h = BObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > hgSizeB) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid SConf ()\n{\n  vec2 r;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  r = Hashv2v2 (73. * cIdS + 1.1);\n  tOff.xz = 0.2 * sqrt3 * hgSizeS * (0.5 + 0.5 * r.x) * sin (2. * pi * r.y + vec2 (0.5 * pi, 0.));\n  tOff.y = r.x + r.y;\n}\n\nvoid SBConf ()\n{\n  vec2 s, u;\n  u = cMidS + tOff.xz;\n  cIdB = PixToHex (u / hgSizeB);\n  BConf ();\n  s = (u - cMidB) / hgSizeB;\n  csOcc = (hgSizeB * min (TruchDist (s).x, HexEdgeDist (s)) < 1.1) ? 0. : 1.;\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  if (csOcc > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= tOff.xz;\n    h = 0.15 + 0.15 * tOff.y;\n    q.y -= h;\n    d = PrCylDf (q.xzy, 0.05, h);\n    DMIN (idTree);\n    q.y -= h + 0.5;\n    d = PrConCapsDf (q.xzy, sin (0.08 * pi + vec2 (0.5 * pi, 0.)), 0.17, 0.3);\n    DMIN (idLeaf);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeS;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeS));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    SBConf ();\n    d = SObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    SBConf ();\n    if (csOcc > 0.) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.1 * d, h));\n      d += h;\n    } else d += 0.1 * hgSizeS;\n    if (sh < 0.05 || d > 2. * hgSizeS) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec4 GroundCol (vec3 p, inout vec2 vf)\n{\n  vec4 col4, gCol;\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac;\n  gCol = vec4 (0.6, 0.6, 0.5, 0.);\n  col4 = vec4 (0., 0.7, 0., 0.) * (0.6 + 0.4 * Fbm2 (p.xz));\n  vf = vec2 (32., 1.);\n  w = (p.xz - cMidB) / hgSizeB;\n  cm3 = TruchDist (w);\n  dt = hgSizeB * cm3.x;\n  if (dt > 1.22) col4 = mix (gCol, col4, smoothstep (0., 0.01, hgSizeB * HexEdgeDist (w) - 0.2));\n  else if (dt < 0.19) {\n    col4 = mix (col4, gCol, smoothstep (0., 0.03, 0.19 - dt));\n    rc = cm3.y;\n    ac = cm3.z;\n    if (cType <= 2. && rc != 0. && OnTrk (w) && dt < 0.16 && step (0.35,\n         abs (fract (36. * 6. * rc * ac + 0.5) - 0.5)) > 0.) col4 = vec4 (0.5, 0.4, 0.3, 0.);\n  }\n  if (trees) {\n    cIdB = PixToHex (p.xz / hgSizeB);\n    BConf ();\n    cIdS = PixToHex (p.xz / hgSizeS);\n    SConf ();\n    SBConf ();\n    if (csOcc > 0. && length ((p.xz - cMidS) / hgSizeS - tOff.xz) < 0.07) col4 *= 0.8;\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rs;\n  vec2 w, vf;\n  float dstObj, dstObjB, dstObjS, sh, shGrnd;\n  int idObjB, idObjS;\n  vf = vec2 (0.);\n  if (trees) {\n    dstObjS = SObjRay (ro, rd);\n    idObjS = idObj;\n  } else dstObjS = dstFar;\n  dstObjB = BObjRay (ro, rd);\n  idObjB = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObjB, dstObjS) < dstObj) {\n    if (dstObjB < dstObjS) {\n      dstObj = dstObjB;\n      idObj = idObjB;\n    } else {\n      dstObj = dstObjS;\n      idObj = idObjS;\n    }\n  }\n  shGrnd = 1.;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjS) {\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      SConf ();\n      SBConf ();\n      vn = SObjNf (ro);\n    } else if (dstObj == dstObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      BConf ();\n      vn = BObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    if (idObj == idFenc) {\n      col4 = vec4 (0.9, 0.2, 0.3, 0.2);\n    } else if (idObj == idBrdg) {\n      col4 = vec4 (0.8, 0.3, 0.3, 0.2);\n    } else if (idObj == idBrdgP) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n    } else if (idObj == idTree) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n    } else if (idObj == idLeaf) {\n      col4 = mix (vec4 (0.4, 0.7, 0.1, 0.), vec4 (0.9, 0.9, 0., 0.1), step (0.7,\n         Fbm3 (64. * ro.xzy)));\n      vf = vec2 (16., 2.);\n    } else if (idObj == idGrnd) {\n      col4 = GroundCol (ro, vf);\n      for (int k = VAR_ZERO; k < N_CAR; k ++) shGrnd = min (shGrnd, 0.5 +\n         0.5 * smoothstep (-0.02, 0.02, PrBox2Df (Rot2D ((ro.xz - carPos[k].xz), carPos[k].w),\n         vec2 (1.3, ((k == 0) ? 3.15 : 2.8) - 0.1) * trSzFac)));\n    } else if (idObj >= idEng && idObj <= idLamp) {\n      col4 = TrnCol ();\n    }\n    if (col4.a >= 0.) {\n      rs = ro + 0.01 * vn;\n      sh = min (ObjSShadow (rs, sunDir), BObjSShadow (rs, sunDir));\n      sh = min (sh, shGrnd);\n      if (trees) sh = min (sh, SObjSShadow (rs, sunDir));\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col4.rgb * (0.3 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      col = mix (col, SkyCol (rd), smoothstep (0.8, 1., dstObj / dstFar));\n    } else {\n      col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n    }\n  } else {\n    col = SkyCol (rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, cGap, t;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  hgSizeB = 8.;\n  hgSizeS = 1.;\n  gHt = 0.2;\n  trSzFac = 0.1;\n  SetPath ();\n  trees = true;\n  cGap = 2.3 * trSzFac;\n  wlBase = vec2 (1.3, 1.1);\n  trVel = 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = tCur * trVel - (float (k) + ((k > 0) ? 0.05 : 0.)) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * wlBase.y * trSzFac : 0.));\n    carPos[k].xz = pc[0];\n    carPos[k].y = 2.4 * trSzFac;\n    vd.xy = pc[2] - pc[1];\n    carPos[k].w = 0.5 * pi - atan (vd.y, vd.x);\n  }\n  t = tCur * trVel;\n  if (vuId == 0 || vuId == 3) {\n    ro.xz = EvalPPos (t - float ((vuId == 3) ? -3 : N_CAR + 2) * cGap);\n    ro.y = 0.8;\n    vd.xy = normalize (EvalPPos (t - float (N_CAR - ((vuId == 3) ? 5 : 0)) * cGap) - ro.xz);\n    az += atan (vd.y, - vd.x) - 0.5 * pi;\n    el -= 0.06 * pi;\n    el = clamp (el, -0.2 * pi, 0.15 * pi);\n    zmFac = 3.;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 40., (-3. * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n#if P_LONG\n    ro.x += 1.6 * hgSizeB;\n#else\n    ro.x -= 1.6 * hgSizeB;\n#endif\n    az += pi / 3.;\n    el -= 0.3 * pi;\n    el = clamp (el, -0.4 * pi, -0.2 * pi);\n    zmFac = 3.;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x -= 1.5 * hgSizeB;\n    vd = normalize (carPos[1].xyz - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 30.;\n  }\n  vuMat = StdVuMat (el, az);\n  dstFar = 16. * hgSizeB;\n  sunDir = normalize (vec3 (0., 1.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.7, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}