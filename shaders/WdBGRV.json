{
    "Shader": {
        "info": {
            "date": "1549486511",
            "description": "Flat shaded Voronoi sphere with randomly changing face normals. Background glitch art is a byproduct of the method.\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WdBGRV",
            "likes": 31,
            "name": "Spheronoi",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "voronoi",
                "noise",
                "flat",
                "perlin",
                "sphere",
                "glitch",
                "subsurface",
                "orennayar",
                "pbr",
                "cooktorrance",
                "gooch",
                "cividis"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 904
        },
        "renderpass": [
            {
                "code": "/// by Dom Mandy in 2019\n\n\n/*\nlower default precision for performance\n*/\nprecision lowp float;\nprecision lowp int;\nprecision lowp sampler2D;\n\n\nconst float pi = 3.1415926535897932384626433832795;\nconst int lightCount = 4;\n\n\nstruct Light {\n    float intensity;\n    vec3 position;\n    vec3 color;\n};\n\n\n// vector form of a line\nstruct Line {\n    // unit vector in the direction of the line\n    lowp vec3 direction;\n    // position of a point on the line\n    lowp vec3 point;\n};\n\n\n// geometry of a shape\nstruct Shape {\n    // distance to outline of shape\n    float dist;\n    // surface normal of shape\n    vec3 normal;\n};\n\n\n// positioning of scene elements\nstruct Studio {\n    Light[lightCount] lights;\n    Line camera;\n};\n\n\n// rotates a vector by a given angle (in radians) around a given axis (must be a unit vector)\n// see: https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\nvec3 rotationRodrigues(vec3 v, vec3 axis, float angle) {\n    float c = cos(angle);\n    return v * c + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - c);\n}\n\n\n// inverse linear interpolation, an un-smoothed form of smoothstep\nfloat linearStep(float a, float b, float x) {\n    float t = clamp((x - a) / (b - a), 0.0, 1.0);\n    return t;\n}\n\n\n// minimum distance from a line to the origin\n// see: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\nfloat perpendicularDistance(Line line) {\n    return length(line.point - dot(line.point, line.direction) * line.direction);\n}\n\n\n// desaturated lightness of the color\nfloat luma(vec3 color) {\n    // coefficients reflect the luminosity function: https://en.wikipedia.org/wiki/Luminosity_function\n    const vec3 c = vec3(0.2126, 0.7152, 0.0722);\n    float l = dot(c, color);\n    \n    return l;\n}\n\n\n// distribution of reflective microfacets on a surface\n// see: https://en.wikipedia.org/wiki/Specular_highlight#Beckmann_distribution\nfloat beckmannDistribution(float HN) {\n    // roughness\n    const float m = 0.5;\n    const float m2 = m * m;\n    \n    float cos2 = HN * HN;\n    float cos4 = cos2 * cos2;\n    \n    float num = exp((cos2 - 1.0) / (cos2 * m2));\n    float den = pi * m2 * cos4;\n    \n    float k = num / den;\n    \n    return k;\n}\n\n\n// amount of light reflected at boundary of air and object \n// see: https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickApproximation(float VN) {\n    /// refractive indices\n    // air\n    const float n_1 = 1.000293;\n    // diamond\n    const float n_2 = 2.417;\n    \n    float R_0 = (n_1 - n_2) / (n_1 + n_2);\n    R_0 *= R_0;\n    \n    float incidence = 1.0 - VN;\n    incidence *= incidence * incidence * incidence * incidence;\n    float R = R_0 + (1.0 - R_0) * incidence;\n    \n    return R;\n}\n\n\n// specular reflections off a rough surface\n// see: https://en.wikipedia.org/wiki/Specular_highlight#Cook%E2%80%93Torrance_model\nvec3 cookTorrance(vec3 V, vec3 N, Light L) {\n    vec3 H = normalize(V + L.position);\n    float VN = dot(V, N);\n    float NL = dot(N, L.position);\n    float HN = dot(H, N);\n    float VH = dot(V, H);\n    \n    float g = 2.0 * HN / VH;\n    float G = 1.0;\n    G = min(G, g * VN);\n    G = min(G, g * NL);\n    \n    float D = beckmannDistribution(HN);\n    float F = schlickApproximation(VN);\n    \n    float k = 0.25 * D * F * G / (VN * NL);\n    \n    vec3 color = k * L.intensity * L.color;\n        \n    return color;\n}\n\n\n// diffuse reflections on a rough surface\n// see: https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model\nfloat orenNayar(vec3 normal, Light light, vec3 eye) {\n    // roughness\n    const float sigma = 0.3;\n    const float sigma2 = sigma * sigma;\n    const float A = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33);\n    const float B = 0.45 * sigma2 / (sigma2 + 0.09);\n    \n    float eyeNormalProjection = dot(eye, normal);\n    float lightNormalProjection = dot(light.position, normal);\n    float thetaEye = acos(eyeNormalProjection);\n    float thetaLight = acos(lightNormalProjection);\n    float alpha = max(thetaEye, thetaLight);\n    float beta = min(thetaEye, thetaLight);\n    vec3 eyeNormalRejection = eye - eyeNormalProjection * normal;\n    vec3 lightNormalRejection = eye - lightNormalProjection * normal;\n    vec3 axis = cross(vec3(0.0, 1.0, 0.0), normal);\n    float phiEye = acos(dot(eyeNormalRejection, axis));\n    float phiLight = acos(dot(lightNormalRejection, axis));\n    \n    float L = A + B * max(cos(phiEye - phiLight), 0.0) * sin(alpha) * tan(beta);\n    L *= max(lightNormalProjection, 0.0);\n    L *= light.intensity;\n    \n    return L;\n}\n\n\n// scattering of light below the surface of the object\nfloat sss(Light light, float orenNayar) {\n    const float scatterWidth = 0.3;\n    const float scatterWidth2 = 2.0 * scatterWidth;\n    float s = light.intensity * smoothstep(0.0, scatterWidth, orenNayar) * smoothstep(scatterWidth2, scatterWidth, orenNayar);\n        \n    return s;\n}\n\n\n/// Gooch:\n// \"cool to warm\" shading so diffuse colors are all midtones\n// see: https://en.wikipedia.org/wiki/Gooch_shading\n/// Cividis: \n// enables nearly identical visual data interpretation to individuals with and without color vision deficiency  \n// perceptually uniform in hue and brightness\n// see: https://arxiv.org/ftp/arxiv/papers/1712/1712.01662.pdf\nvec3 cividisGooch(float intensity) {\n    // cache useful cividis values for performance\n\tconst int cividisCount = cividis.length() - 1;\n\tconst float cividisScale = float(cividisCount);\n    // approximately cividis scale sampling\n    intensity *= cividisScale;\n    float a = floor(intensity);\n    float b = ceil(intensity);\n    vec3 color = mix(cividis[int(a)], cividis[int(b)], linearStep(a, b, intensity));\n    \n    return color;\n}\n\n\n// light combining physically based equations with stylized elements\nvec3 addLighting(vec3 view, vec3 normal, Light[lightCount] lights) {\n    vec3 color;\n    float diffuse;\n    float subSurface;\n    // ambient light\n    // no-see-um green\n\t// see: http://disneylandguru.tumblr.com/post/24656470253\n\tconst vec3 green = vec3(139.0 / 255.0, 153.0 / 255.0, 153.0 / 255.0);\n    color += 0.125 * green;\n    // for each light\n    for(int n = 0; n < lightCount; n++)\n    {\n        Light light = lights[n];\n        // diffuse\n        float on = orenNayar(normal, light, view);\n        diffuse += on;\n        // specular\n        color += 1.5 * cookTorrance(view, normal, light);\n        // subsurface scattering\n        subSurface += sss(light, on);\n    }\n    // stylized diffuse shading\n    color += 0.5 * cividisGooch(diffuse);\n    // red ochre is one of the oldest used pigments in art\n    // see: https://en.wikipedia.org/wiki/Ochre#Historical_use_in_art_and_culture\n    // adapted from: https://www.pantone.com/color-finder/18-1442-TCX\n    const vec3 redOchre = vec3(145.0 / 255.0, 56.0 / 255.0, 50.0 / 255.0);\n    color += 0.125 * subSurface * redOchre;\n        \n    return color;\n}\n\n\n// draw antialiased point with minimum pixel size \nvec3 draw(vec3 buffer, float dist, float radius, vec3 color) {\n    float up = min(iResolution.x, iResolution.y);\n    dist *= up;\n    const float scale =  1.0 / 360.0;\n    radius *= up * scale;\n  \tfloat aa = 0.5 * fwidth(dist);\n    vec3 mixed = mix(buffer, color, smoothstep(radius + aa, radius - aa, dist));\n   \t\n    return mixed;\n}\n\n\n// manage the light and camera for the scene\nStudio staging(vec2 point) {\n    // lock everything to running time\n    const float speed = 0.375;\n    float time = speed * iTime;\n    // view\n    vec3 viewPoint, viewDirection;\n    viewPoint = vec3(point, -4.0);\n    viewDirection.z = -1.0;\n    // lights\n    Light keyLight;\n    keyLight.position = normalize(vec3(-1.0, 1.0, -1.0));\n    keyLight.intensity = 1.0;\n    keyLight.color = vec3(1.0);\n    Light fillLight = keyLight;\n    fillLight.position.x *= -1.0;\n    fillLight.position.y = 0.0;\n    fillLight.intensity *= 0.5;\n    const float bounceFactor = 1.0 / sqrt(2.0);\n    Light bouncedKeyLight = keyLight;\n    bouncedKeyLight.position = reflect(keyLight.position, viewDirection);\n    bouncedKeyLight.intensity *= bounceFactor;\n    Light bouncedFillLight = fillLight;\n    bouncedFillLight.position = reflect(fillLight.position, viewDirection);\n    bouncedFillLight.intensity *= bounceFactor;\n    \n    Light[lightCount] lights = Light[]\n    (\n        keyLight,\n        fillLight,\n        bouncedKeyLight,\n        bouncedFillLight\n    );\n    // animate rotation\n    const vec3 axis = vec3(0.0, 1.0, 0.0);\n    viewPoint = rotationRodrigues(viewPoint, axis, time);\n    viewDirection = rotationRodrigues(viewDirection, axis, time);\n    for(int n = 0; n < lightCount; n++)\n    {\n        lights[n].position = rotationRodrigues(lights[n].position, axis, time);\n    }\n    // construct view line\n    Line camera;\n    camera.point = viewPoint;\n    camera.direction = viewDirection;\n    \n    Studio studio;\n    studio.lights = lights;\n    studio.camera = camera;\n    \n    return studio;\n}\n\n\n// create voronoi sphere\nShape geometry(Line ray, float scale) {\n    ray.point *= scale;\n    \n    lowp vec3 normal;\n    lowp float minDist = 100000.0;\n    const lowp uint count = 200u;\n    const lowp float inverseCount = 1.0 / float(count);\n    \n    lowp vec2 uv;\n    uv.y = 0.0005 * iTime;\n    for(lowp uint n = 0u; n < count; n++)\n    {\n        // procedural centroid and normal from noise texture\n        uv.x = float(n) * inverseCount;\n        lowp vec3 noiseNormal = normalize(texture(iChannel0, uv).xyz - 0.5);\n        lowp float facing = dot(noiseNormal, ray.direction);\n        // point of intersection between line and plane\n        // see: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n        lowp vec3 planeNormal = noiseNormal * sign(facing);\n        lowp vec3 rayToPlane = planeNormal - ray.point;\n        lowp float t = dot(rayToPlane, planeNormal) / abs(facing);\n        // distance of intersection point to centroid\n        lowp vec3 v = rayToPlane - t * ray.direction;\n        lowp float d = dot(v, v);\n        // find the closest centroid for voronoi shading\n        // see: https://en.wikipedia.org/wiki/Voronoi_diagram\n        if (d < minDist)\n        {\n            minDist = d;\n            normal = planeNormal;\n        }\n    }\n    float dist = perpendicularDistance(ray) - 1.0;\n    \n    Shape shape;\n    shape.dist = dist;\n    shape.normal = normal;\n    \n    return shape;\n}\n\n\n// combine 3D lighting with 2D logic\nvec3 render(vec2 fragCoord, float scale, Studio studio, Shape geometry) {\n    vec3 color;\n    // combine geometry with lighting\n    color = addLighting(studio.camera.direction, geometry.normal, studio.lights);\n    \n    // remove emphasis from the background\n    vec3 background;\n    // desaturate\n    background = mix(color, vec3(luma(color)), 0.3);\n    // add noise\n    background += 0.0625 * (perlin(fragCoord, 1.0, fract(iTime)) - 0.5);\n    // check whether the pixel is on the background\n    bool isBackground = geometry.dist > 0.0;\n    color = background * float(isBackground) + color * float(!isBackground);\n    \n    // add border to edge of object\n    // distance to shape edge\n    float outlineDistance = abs(geometry.dist);\n    // border color\n    const vec3 borderColor = vec3(0.0);\n    // draw shape outline\n    color = draw(color, outlineDistance, scale, borderColor);\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // normalize pixel coordinates and center on origin\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    // golden ratio * 2\n    const float scale = 3.236;\n    // position the lights and camera\n    Studio studio = staging(uv);\n    // plot objects relative to the camera\n    Shape geometry = geometry(studio.camera, scale);\n    // determine pixel colors\n    vec3 color = render(fragCoord, scale, studio, geometry);\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// color deficient vision safe and perceptually uniform color scale\n/// adapted from:\n/// https://github.com/marcosci/cividis\nconst vec3[] cividis = vec3[]\n(\n    vec3(0.0000, 0.1262, 0.3015),\n\tvec3(0.0000, 0.1408, 0.3334),\n\tvec3(0.0000, 0.1546, 0.3676),\n\tvec3(0.0000, 0.1685, 0.4031),\n\tvec3(0.0000, 0.1817, 0.4347),\n\tvec3(0.0000, 0.1930, 0.4361),\n\tvec3(0.0000, 0.2073, 0.4329),\n\tvec3(0.0710, 0.2215, 0.4293),\n\tvec3(0.1204, 0.2357, 0.4262),\n\tvec3(0.1566, 0.2498, 0.4236),\n\tvec3(0.1868, 0.2639, 0.4217),\n\tvec3(0.2133, 0.2780, 0.4205),\n\tvec3(0.2375, 0.2920, 0.4200),\n\tvec3(0.2599, 0.3060, 0.4202),\n\tvec3(0.2811, 0.3200, 0.4210),\n\tvec3(0.3014, 0.3340, 0.4224),\n\tvec3(0.3209, 0.3481, 0.4244),\n\tvec3(0.3398, 0.3622, 0.4270),\n\tvec3(0.3582, 0.3763, 0.4302),\n\tvec3(0.3763, 0.3904, 0.4338),\n\tvec3(0.3940, 0.4047, 0.4381),\n\tvec3(0.4114, 0.4189, 0.4430),\n\tvec3(0.4286, 0.4333, 0.4485),\n\tvec3(0.4456, 0.4477, 0.4547),\n\tvec3(0.4622, 0.4622, 0.4620),\n\tvec3(0.4790, 0.4767, 0.4691),\n\tvec3(0.4971, 0.4915, 0.4723),\n\tvec3(0.5158, 0.5065, 0.4736),\n\tvec3(0.5349, 0.5216, 0.4738),\n\tvec3(0.5541, 0.5368, 0.4733),\n\tvec3(0.5735, 0.5522, 0.4720),\n\tvec3(0.5931, 0.5678, 0.4701),\n\tvec3(0.6129, 0.5835, 0.4673),\n\tvec3(0.6328, 0.5993, 0.4641),\n\tvec3(0.6529, 0.6153, 0.4600),\n\tvec3(0.6732, 0.6315, 0.4553),\n\tvec3(0.6936, 0.6478, 0.4499),\n\tvec3(0.7142, 0.6643, 0.4437),\n\tvec3(0.7350, 0.6810, 0.4368),\n\tvec3(0.7560, 0.6979, 0.4290),\n\tvec3(0.7771, 0.7150, 0.4205),\n\tvec3(0.7985, 0.7322, 0.4111),\n\tvec3(0.8200, 0.7497, 0.4007),\n\tvec3(0.8417, 0.7674, 0.3892),\n\tvec3(0.8636, 0.7853, 0.3766),\n\tvec3(0.8858, 0.8035, 0.3627),\n\tvec3(0.9082, 0.8219, 0.3474),\n\tvec3(0.9308, 0.8405, 0.3306),\n\tvec3(0.9536, 0.8593, 0.3116),\n\tvec3(0.9767, 0.8785, 0.2901),\n\tvec3(1.0000, 0.8979, 0.2655),\n\tvec3(1.0000, 0.9169, 0.2731)\n);\n/// Perlin noise\n/// adapted from: \n/// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n#define M_PI 3.14159265358979323846\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand (vec2 co, float l) {return rand(vec2(rand(co), l));}\nfloat rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}