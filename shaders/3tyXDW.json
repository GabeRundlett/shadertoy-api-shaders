{
    "Shader": {
        "info": {
            "date": "1582673074",
            "description": "Warping lines based on fbm",
            "flags": 0,
            "hasliked": 0,
            "id": "3tyXDW",
            "likes": 11,
            "name": "Warping Fur",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "fbm",
                "warp"
            ],
            "usePreview": 0,
            "username": "oddlama",
            "viewed": 513
        },
        "renderpass": [
            {
                "code": "/*\nMIT License\n\nCopyright (c) 2020 oddlama\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n\n\n// SETTINGS\n\n// Adjusts the animation speed\nconst float time_speed = 0.3;\n// grid pixel dimensions\nconst vec2 grid_size = vec2(30.0);\n// length of line (CAREFUL DONT go > 6, this is O(n^2) !! )\nconst float line_len_factor = 4.0;\n// Thickness of lines\nconst float line_width = 4.6;\n\n// PRE-COMPUTED CONSTANTS, DON'T CHANGE\n\nconst ivec2 grid_neighborhood = ivec2(int(line_len_factor) - 1);\nconst float line_width_antialias = 1.0;\nconst float line_bounding_width = line_width + line_width_antialias;\n\n\n\n////////////////////////////////////////////////// NOISE FUNCTIONS\n\nfloat random (in vec2 x) {\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\nfloat fbm(in vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\n////////////////////////////////////////////////// Helpers\n\nvec2 nearest_grid_pos(vec2 frag_coord) {\n    return round(frag_coord / grid_size) * grid_size;\n}\n\nvec2 screenToUniform(vec2 x) {\n    return x * vec2(1. / iResolution.x);\n}\n\nfloat fbm_warp(vec2 x, out vec2 q, out vec2 r) {\n    q = vec2(fbm(x + vec2(0.0, 0.0)),\n             fbm(x + vec2(5.2, 1.3)));\n\n   \tfloat t = (iTime + 29.) * time_speed;\n    r = vec2(fbm(x + 4.0 * q + vec2(1.7, 9.2) + .15 * t),\n             fbm(x + 4.0 * q + vec2(8.3, 2.8) + .12 * t));\n    return fbm(x + 4.0 * r);\n}\n\n\n////////////////////////////////////////////////// VECTOR FIELDS\n// f = vectorfield at screen pos, f_color = color at screen pos\n\nfloat f(vec2 x, out vec2 y) {\n    x = screenToUniform(x);\n    vec2 q, r;\n    float k = fbm_warp(x, q, r);\n    r = (r + vec2(-.5)) * 2.;\n    y = grid_size * line_len_factor * r;\n    return k;\n}\n\nvec3 f_color(vec2 x) {\n    x = screenToUniform(x);\n    vec2 q, r;\n    float f = fbm_warp(x * 2., q, r);\n    \n    vec3 col = vec3(0.0);\n    col = mix( vec3(0.4,0.2,0.2), vec3(1.5,0.4,0.1), f );\n    col = mix( col, vec3(0.1,0.6,0.9), dot(r,r) );\n    col = mix( col, vec3(0.2,1.19,1.09), 0.5*q.y*q.y );\n    col *= (1. + q.x * q.x * q.x);\n    col = mix( col, vec3(0.0,1.39,1.49), 0.3*smoothstep(1.2,1.3,abs(r.y)+abs(r.x)) );\n    col *= f * 2.0;\n    return col;\n}\n\n\n////////////////////////////////////////////////// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 frag_coord) {    \n    vec3 col = vec3(0.0);\n    \n    // Any pixel can be occluded by multiple lines. Only lines from neighboring\n    // grid anchors will be considered.\n    float active_lines = 0.0;\n    for (int i = -grid_neighborhood.x; i <= grid_neighborhood.x; ++i) {\n        for (int j = -grid_neighborhood.y; j <= grid_neighborhood.y; ++j) {\n    \t\t// Beginning of the line is at the nearest grid anchor\n\t    \tvec2 line_a = nearest_grid_pos(frag_coord + grid_size * vec2(i, j));\n            // End of the line is the beginning but offset by the value of\n            // our vector field at that position\n            vec2 x;\n            float k = f(line_a, x);\n            vec2 line_b = line_a + x;\n            \n            vec2 line_dir = normalize(x);\n            // Project pixel coord to the line\n            float px_proj = dot(line_dir, frag_coord);\n            // la will always be <= lb. (To proof simply replace line_b with line_a + line_dir, solve inequality)\n            // Informal: The projected point x on d is always <= the projected point (x + d) on d.\n            float la_proj = dot(line_dir, line_a);\n            float lb_proj = dot(line_dir, line_b);\n            // We account for the line width by subtracting from la and adding to lb.\n            float la_proj_w = la_proj - line_width;\n            float lb_proj_w = lb_proj + line_width;\n            \n            // Check if projected point is on line\n            if (la_proj_w < px_proj && px_proj < lb_proj_w) {\n                // Calculate distance to line segment on this local axis\n                float dx = distance(px_proj, clamp(px_proj, la_proj, lb_proj));\n                \n                // Now do the projection on the perpendicular axis to get the distance on\n                // the axis perpendicular to the line\n                vec2 perp = line_dir.yx * vec2(1, -1);\n                float px_proj_perp = dot(perp, frag_coord);\n                float la_proj_perp = dot(perp, line_a);\n                \n                // Distance is easier here, as the line is infinitely small, so we don't need clamping.\n                float dy = distance(la_proj_perp, px_proj_perp);\n\n                // Calculate distance from line segment given distances on local axis\n                float dist = length(vec2(dx, dy));\n                if (dist < line_bounding_width) {\n                    // alpha is the relative position of px in the line\n                    float alpha = smoothstep(la_proj, lb_proj, px_proj);\n                    \n                    //vec3 c = mix(col_a, col_b, alpha);\n                    vec3 c = f_color(frag_coord);\n                    \n                    // Line gets lighter at the very end (alpha), but influenced by vector field (k).\n                    // Also add antialiasing to the line edge\n                    float blend = alpha * (.2 + k * 2.) * (1. - smoothstep(line_width, line_bounding_width, dist));\n                    // Blend with previously calculated factor, also make shorter darker everywhere\n                    float len_f = length(x) / (length(grid_size) * line_len_factor);\n                    c *= blend * 1.3 * len_f * (.7 + len_f);\n                    \n                    // Blend color with max\n                    col = max(col, c);\n                }\n            }\n    \t}\n    }\n\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}