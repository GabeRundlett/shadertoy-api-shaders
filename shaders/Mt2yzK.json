{
    "Shader": {
        "info": {
            "date": "1509377576",
            "description": "Playing with my new rendering framework using model from https://www.shadertoy.com/view/MdBXR3\n* WASD + Mouse flycam (shift for speed)\nMotion Blur, Bloom, Depth of Field, Temporal AA, Chromatic aberration, Film grain",
            "flags": 113,
            "hasliked": 0,
            "id": "Mt2yzK",
            "likes": 78,
            "name": "Jack-o'-lantern's Revenge",
            "published": 3,
            "tags": [
                "halloween",
                "pumpkin"
            ],
            "usePreview": 1,
            "username": "P_Malin",
            "viewed": 6286
        },
        "renderpass": [
            {
                "code": "\n//         _            _                _        _             _                  _     \n//        | |          | |              ( )      | |           | |                ( )    \n//        | | __ _  ___| | ________ ___ |/ ______| | __ _ _ __ | |_ ___ _ __ _ __ |/ ___ \n//    _   | |/ _` |/ __| |/ /______/ _ \\  |______| |/ _` | '_ \\| __/ _ \\ '__| '_ \\  / __|\n//   | |__| | (_| | (__|   <      | (_) |        | | (_| | | | | ||  __/ |  | | | | \\__ \\\n//    \\____/ \\__,_|\\___|_|\\_\\      \\___/         |_|\\__,_|_| |_|\\__\\___|_|  |_| |_| |___/\n//   |  __ \\                                                                             \n//   | |__) |_____   _____ _ __   __ _  ___                                              \n//   |  _  // _ \\ \\ / / _ \\ '_ \\ / _` |/ _ \\                                             \n//   | | \\ \\  __/\\ V /  __/ | | | (_| |  __/                                             \n//   |_|  \\_\\___| \\_/ \\___|_| |_|\\__, |\\___|                                             \n//                                __/ |                                                  \n// @P_Malin\n// https://www.shadertoy.com/view/Mt2yzK\n\n\n//    _____                               _____                                _ _   _             \n//   |_   _|                             / ____|                              (_) | (_)            \n//     | |  _ __ ___   __ _  __ _  ___  | |     ___  _ __ ___  _ __   ___  ___ _| |_ _  ___  _ __  \n//     | | | '_ ` _ \\ / _` |/ _` |/ _ \\ | |    / _ \\| '_ ` _ \\| '_ \\ / _ \\/ __| | __| |/ _ \\| '_ \\ \n//    _| |_| | | | | | (_| | (_| |  __/ | |___| (_) | | | | | | |_) | (_) \\__ \\ | |_| | (_) | | | |\n//   |_____|_| |_| |_|\\__,_|\\__, |\\___|  \\_____\\___/|_| |_| |_| .__/ \\___/|___/_|\\__|_|\\___/|_| |_|\n//                           __/ |                            | |                                  \n//                          |___/                             |_|                                  \n\n///////////////////////////////////////////////\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\n\nvec3 ApplyGrain( vec2 vUV, vec3 col, float amount )\n{\n    float h = hash13( vec3(vUV, iTime) );\n    \n    col *= (h * 2.0 - 1.0) * amount + (1.0f -amount);\n    \n    return col;\n}\n\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\nvec4 SampleBloom( vec2 vUV )\n{\n    vec2 gBloomSize = iResolution.xy / 4.0;//min( vec2(320.0, 240.0), iResolution.xy );\n    \n\tvec4 vBloomSample = textureLod( iChannel1, vUV * gBloomSize / iResolution.xy, 0.0 ).rgba;\n    \n    return vBloomSample;\n}\n\n\nvec3 SampleImage( vec2 vUV, int image )\n{\n    if ( image >= 0 )\n    {\n        vUV.x *= 0.5;\n    }\n    \n    if (image > 0 )\n    {\n        vUV.x += 0.5;\n    }\n    \n\tvec4 vImageSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\n    vec4 vBloomSample = SampleBloom( vUV );\n    \n    const float fBloomAmount = 0.025;\n   \n    return mix( vImageSample.rgb, vBloomSample.rgb, fBloomAmount );    \n}\n\nvec2 DistortUV( vec2 vUV, float f )\n{\n    vUV -= 0.5;\n\n    float fScale = 0.0075;\n    \n    float r1 = 1. + f * fScale;\n    \n    vec3 v = vec3(vUV, sqrt( r1 * r1 - dot(vUV, vUV) ) );\n    \n    v = normalize(v);\n    vUV = v.xy;\n    \n    \n    vUV += 0.5;\n    \n    return vUV;\n}\n\nvec3 SampleImage2( vec2 vUV, vec2 vScreen, int image )\n{\n    vec3 a = SampleImage( DistortUV( vUV, 1.0 ), image );\n    vec3 b = SampleImage( DistortUV( vUV, 0.0 ), image );\n    vec3 c = SampleImage( DistortUV( vUV, -1.0 ), image );\n    \n    vec3 vResult = vec3(0);\n    \n    vec3 wa = vec3(1., .5, .1);\n    vec3 wb = vec3(.5, 1., .5);\n    vec3 wc = vec3(.1, .5, 1.);\n    \n    vResult += a * wa;\n    vResult += b * wb;\n    vResult += c * wc;\n    \n    vResult /= wa + wb + wc;\n    \n    return vResult;\n}\n\n\nvoid Process( out vec4 fragColor, vec2 vUV, vec2 vScreen, int image )\n{\n    vec3 vResult = SampleImage2( vUV, vScreen, image );\n    \n    //vResult = texelFetch( iChannel0, ivec2( fragCoord.xy ), 0 ).rgb;\n    \n    float fShade = Vignette( vUV, 1.2 );\n    \n    vResult *= fShade;\n    \n    //if ( vUV.x > sin(iTime)*0.5+0.5 )\n    {\n    \tvResult = ColorGrade( vResult );\n    }\n    \n\tvResult = ApplyGrain( vUV, vResult, 0.15 );      \n    \n    vec3 vFlare = 0.0\n        + SampleBloom((vScreen)).rgb * 0.001\n        + SampleBloom((vScreen - 0.5)*-0.5 + 0.5).rgb * 0.0005\n        + SampleBloom((vScreen - 0.5)*-.9 + 0.5).rgb * 0.00025\n        + SampleBloom((vScreen - 0.5)*0.2 + 0.5).rgb * 0.000125\n        ;\n    \n    vec3 vFlareTex = texture( iChannel2, vScreen ).rgb;\n    vResult += vFlare;\n    \n    //vResult = vFlare * 10.0;\n    \n    \n    vResult = vResult * 1.5;\n    vResult = Tonemap( vResult );\n    fragColor.rgb = vResult;\n    fragColor.a = 1.0;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    \n    Process( fragColor, vUV, vUV, -1 );       \n}\n\nvoid mainVR( out vec4 vFragColor, in vec2 vFragCoord, in vec3 vRayOrigin, in vec3 vRayDir )\n{\n    vec2 vScreen = vFragCoord.xy / iResolution.xy;\n\tvec2 vUV = vScreen;\n    \n    int image = 0;\n    \n    if (vUV.x > 0.5 )\n    {\n        image = 1;\n    }\n    \n    vUV.x = fract( vUV.x * 2.0 );\n    \n    Process( vFragColor, vUV, vScreen, image );    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//     _____                       _____                _           _             \n//    / ____|                     |  __ \\              | |         (_)            \n//   | (___   ___ ___ _ __   ___  | |__) |___ _ __   __| | ___ _ __ _ _ __   __ _ \n//    \\___ \\ / __/ _ \\ '_ \\ / _ \\ |  _  // _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//    ____) | (_|  __/ | | |  __/ | | \\ \\  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_____/ \\___\\___|_| |_|\\___| |_|  \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                                                           __/ |\n//                                                                          |___/ \n\n#define ENABLE_TAA_JITTER\n\n#define FLY_CAM_INVERT_Y 1\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n#define PI 3.141592654\n\n#define iChannelCurr \t\tiChannel0\n#define iChannelKeyboard \tiChannel3\n\n#define DRAW_LAMP \n\n//    _____ _          ____                \n//   |  ___| |_   _   / ___|__ _ _ __ ___  \n//   | |_  | | | | | | |   / _` | '_ ` _ \\ \n//   |  _| | | |_| | | |__| (_| | | | | | |\n//   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n//            |___/                        \n//\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nvoid FlyCam_Update( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{    \n    //float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 0.5;\n    float fRotateSpeed = 3.0;\n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n    \n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;\n    }\n      \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) / iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n}\n\n//    ____                      \n//   / ___|  ___ ___ _ __   ___ \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\\n//    ___) | (_|  __/ | | |  __/\n//   |____/ \\___\\___|_| |_|\\___|\n//                              \n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nSceneResult Scene_Union( SceneResult a, SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        return b;\n    }\n    return a;\n}\n\n    \nSceneResult Scene_Subtract( SceneResult a, SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        b.fDist = -b.fDist;\n        return b;\n    }\n    \n    return a;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nSceneResult Scene_SmoothSubtract( SceneResult a, SceneResult b, float k )\n{    \n    float fA = a.fDist;\n    float fB = -b.fDist;        \n    \n    float fC = -smin( -fA, -fB, k );\n    \n    a.fDist = fC;\n    b.fDist = fC;\n    \n    if ( fA < (fB + k) )\n    {        \n        return b;\n    }\n    \n    return a;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 64;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n//    _     _       _     _   _             \n//   | |   (_) __ _| |__ | |_(_)_ __   __ _ \n//   | |   | |/ _` | '_ \\| __| | '_ \\ / _` |\n//   | |___| | (_| | | | | |_| | | | | (_| |\n//   |_____|_|\\__, |_| |_|\\__|_|_| |_|\\__, |\n//            |___/                   |___/ \n//                                          \n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fGloss;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( const in float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\t// D\n\n\tfloat alphaSqr = AlphaSqrFromGloss( surface.fGloss );\n    float alpha = sqrt( alphaSqr );\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat Light_SpotFactor( vec3 vLightDir, vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle )   \n{\n    float fSpotDot = dot( vLightDir, -vSpotDir );\n    \n    float fTheta = acos(fSpotDot);\n\n    float fAngularAttenuation = clamp( (fTheta - fSpotOuterAngle) / (fSpotInnerAngle - fSpotOuterAngle), 0.0, 1.0 );\n    \n    float fShapeT = fTheta / fSpotOuterAngle;\n    fShapeT = fShapeT * fShapeT * fShapeT;\n    float fShape = (sin( (1.0 - fShapeT) * 10.0));\n    fShape = fShape * fShape * (fShapeT) + (1.0 - fShapeT);\n    \n    //return fShape;\n    return fAngularAttenuation * fShape;\n}\n    \n\nvoid Light_AddSpot( inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const vec3 vLightPos, const vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle, vec3 vLightColour )\n{\n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n    \n    fShadowFactor *= Light_SpotFactor( vLightDir, vSpotDir, fSpotInnerAngle, fSpotOuterAngle );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);    \n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n//    ____                _           _             \n//   |  _ \\ ___ _ __   __| | ___ _ __(_)_ __   __ _ \n//   | |_) / _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//   |  _ <  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_| \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                            |___/ \n//                                                  \n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 2; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fGloss );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//    ____                        ____                      _       _   _             \n//   / ___|  ___ ___ _ __   ___  |  _ \\  ___  ___  ___ _ __(_)_ __ | |_(_) ___  _ __  \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\ | | | |/ _ \\/ __|/ __| '__| | '_ \\| __| |/ _ \\| '_ \\ \n//    ___) | (_|  __/ | | |  __/ | |_| |  __/\\__ \\ (__| |  | | |_) | |_| | (_) | | | |\n//   |____/ \\___\\___|_| |_|\\___| |____/ \\___||___/\\___|_|  |_| .__/ \\__|_|\\___/|_| |_|\n//                                                           |_|                      \n//\n\n// Materials\n\nint MAT_DEFAULT = 0,\n\tMAT_CHROME = 1,\n    MAT_CHROME_GLOW = 2,\n\tMAT_WOOD = 3,\n\tMAT_CHECKER = 4,\n\tMAT_GOLD = 5,\n    MAT_PUMPKIN = 6,\n    MAT_PUMPKIN_STALK = 7,\n    MAT_PUMPKIN_INTERIOR = 8;\n\nfloat Checker(vec2 vUV)\n{\n\treturn step(fract((floor(vUV.x) + floor(vUV.y)) * 0.5), 0.25);\n}\n\n\nstruct TileInfo\n{\n    vec2 vTilePos;    \n    ivec2 vTileIndex;\n    vec2 vTileUV;\n    float fHeight;\n    bool bGrout;\n};\n\nTileInfo Tile( vec2 vUV )\n{\n    TileInfo result;\n    \n    result.vTilePos = vUV;\n    result.vTileIndex = ivec2( floor( result.vTilePos ) );\n    result.vTileUV = fract( result.vTilePos );\n\n    result.fHeight = 0.0;\n    result.bGrout = false;\n\n    float fBevelSize = 0.05;\n    float fGroutSize = 0.02;\n    vec2 vEdge = (abs( fract(result.vTileUV + 0.5) - 0.5) - fGroutSize) / fBevelSize;\n    float fEdge = clamp( min( vEdge.x, vEdge.y ), 0.0, 1.0);\n    \n    float fCurve = 1.0 - fEdge;    \n    fCurve *= 0.8;\n    result.fHeight -= sqrt( 1.0 - fCurve * fCurve );\n    \n//    vec2 vRandomUV = vUV * .5;\n    //if ( result.vTileUV.x >= 0.95 || result.vTileUV.y >= 0.95 )\n    if ( fEdge == 0.0 )\n    {\n        result.bGrout = true;\n        //vRandomUV *= 5.0;\n    }\n    \n//    result.fHeight += textureLod( iChannel2, vRandomUV, 0.5 ).r * 0.2;\n    \n    return result;\n}\n\nfloat GetInnerDist( vec3 vPos )\n{\n    vec3 vDim =  normalize( vec3(1.0, 1.5, 1.0) );\n\treturn (length(vPos * vDim ) - 1.3);\n}\n\nfloat Flicker()\n{\n\treturn hash11(iTime) * 0.2 + 0.8;\n}\n\nvec3 GetGlowCol()\n{\n    return vec3(1.0, 0.8, 0.5) * Flicker();\n}\n\nvec3 GetSpotColor()\n{\n\treturn vec3(1, 0.98, 0.95) * step(hash11(iTime), 0.99);    \n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fGloss = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    \n    vec3 vBumpUV = vec3(0);\n    float fBumpMag = 0.0;\n    \n    vec3 vLightPos = vec3(0,0.075, 0.0);\n    //vec3 vPumpkinDomain = surfaceInfo.vPos - vec3(0,0.1, -0.5);            \n\n    vec3 vLightToPos = surfaceInfo.vPos - vLightPos;\n    //vec3 vDir = normalize(vLightToPos);\n\n    float fInnerDist = GetInnerDist( vLightToPos * 30.0 ) / 30.0;\n\n    float fOpticalDepth = length(vLightToPos) - fInnerDist;\n\n    fOpticalDepth = max(0.0000001, fOpticalDepth);\n    \n    vec3 vGlow = exp2(vec3(0.8, 0.9, 1.0) * fOpticalDepth * -180. );\n    vec3 vGlowCol = GetGlowCol();    \n    \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n        surfaceInfo.vAlbedo = vec3(0.75, 0.75, 0.75); \n\t    surfaceInfo.fGloss = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n    }\n    \n\n    if ( traceResult.iObjectId == MAT_CHECKER )\n    {\n\t    TileInfo tileInfo = Tile( surfaceInfo.vPos.xz * 10.0);\n        \n        //vec2 vTilePos = surfaceInfo.vPos.xz * 10.0;\n        //ivec2 vTileIndex = ivec2( floor( vTilePos ) );\n        //vec2 vTileUV = fract( vTilePos );\n        \n        //surfaceInfo.vAlbedo = Checker( surfaceInfo.vPos.xz * 20.0 ) > 0.5 ? vec3(1.0,0.1,0.1) : vec3(0.9,0.9,0.9);\n        \n        surfaceInfo.vAlbedo = vec3(0.9, 0.9, 0.9);\n\n        if ( ((tileInfo.vTileIndex.x + tileInfo.vTileIndex.y) % 2) == 0)\n        {\n            surfaceInfo.vAlbedo = vec3(0.1);\n        }\n        \n\t\tsurfaceInfo.fGloss = 1.0;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n        \n        vBumpUV = traceResult.vUVW * 5.0;\n        fBumpMag = 0.25;\n        \n        \n        if ( tileInfo.bGrout )\n        {\n            surfaceInfo.vAlbedo = vec3(0.2);\n            surfaceInfo.fGloss = 0.1;\n            surfaceInfo.vR0 = vec3(0.005);\n            \n            vBumpUV = traceResult.vUVW * 20.0;\n\t        fBumpMag = 0.2;\n        }\n\n\n        if ( false )\n        if ( !tileInfo.bGrout )       \n        if( tileInfo.vTileIndex.x > -3 && tileInfo.vTileIndex.x < 3 )\n        {            \n            float dist = 1.0 - dot( tileInfo.vTileUV - 0.5, tileInfo.vTileUV - 0.5);\n            dist = clamp(dist, 0.0, 1.0);\n            dist = dist * dist * dist;\n            \n            float fLight = float( (int(iTime)+tileInfo.vTileIndex.x + tileInfo.vTileIndex.y * 10)  % 3 ) / 3.;            \n            surfaceInfo.vEmissive = dist * vec3(1.,8., 10.) * \n                fLight;\n            surfaceInfo.vAlbedo = vec3(0.05);\n            surfaceInfo.fGloss = 1.0;        \n        }        \n        \n\t\tsurfaceInfo.vEmissive = vGlowCol * 500.0 * vGlow;\n\n          \n        //vec3 vDirt = mix( vec3(.5, .2, .1), vec3(.2, .1, .1), textureLod( iChannel2, surfaceInfo.vPos.xz, 0.0).r);\n        //float fDirt = clamp( (surfaceInfo.vPos.x + 1.0 - surfaceInfo.vPos.y * 1000.0 + vDirt.y) * 10.0, 0.0, 1.0);\n        //surfaceInfo.vAlbedo = mix( surfaceInfo.vAlbedo, vDirt, fDirt);                        \n    }        \n\n    if ( traceResult.iObjectId == MAT_WOOD )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.001 );\n\t    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 2.0, 0.0 ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n\n    \tsurfaceInfo.fGloss = clamp( surfaceInfo.vAlbedo.r * 0.3, 0.0, 1.0);        \n\t}\n    \n\n\n    \n    \n    if ( traceResult.iObjectId == MAT_PUMPKIN )\n    {\n        float fAngle = atan(traceResult.vUVW.x, traceResult.vUVW.z);\n        vec2 vUV = vec2(fAngle, traceResult.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tsurfaceInfo.vAlbedo = texture(iChannel2, vUV).rgb;\n\t\tsurfaceInfo.fGloss = clamp(1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tsurfaceInfo.vAlbedo = mix(vCol1, vCol2, surfaceInfo.vAlbedo.r * 0.5).rgb;\n\t\tsurfaceInfo.vR0 = vec3(0.05);     \n       \n         \n        {\n\n            surfaceInfo.vEmissive = vGlowCol * 5000.0 * vGlow;\n        }  \n        \n        vBumpUV = traceResult.vUVW * 20.0;\n        fBumpMag = 0.3;\n    }    \n    \n \n  \n    \n    \n   if ( traceResult.iObjectId == MAT_PUMPKIN_STALK )\n    {\n        surfaceInfo.vAlbedo = vec3(0.6, 0.6, 0.5); \n\t    surfaceInfo.fGloss = 0.1;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );      \n\n        surfaceInfo.vEmissive = vGlowCol * 5000.0 * vGlow * 0.1;\n    }       \n    \n  \n    // blood splat\n    \n    vec2 vProj = surfaceInfo.vPos.xz + vec2(0.0, surfaceInfo.vPos.y * 0.1);\n        float bs = texture( iChannel2, vProj ).r;\n//\n    \tfloat fBsDist = length( vProj - vec2(0.0, -0.35));\n    \tfBsDist = fBsDist * fBsDist;\n        bs = clamp( bs + fBsDist - 0.2, 0.0, 1.0);\n      \n   \t bs = 1.0 - bs;\n    \n        bs = bs * bs;\n\n    \tbs = min( iTime * 0.1, bs);\n    \n    \t//vec3 vBCol = mix( vec3(1), vec3(0.5, 0.0001, 0.001), bs);\n    \tvec3 vBCol = exp2( -bs * (1.0 - vec3(0.7, 0.001, 0.001)) * 10.0);\n        surfaceInfo.vAlbedo *= vBCol;\n        surfaceInfo.fGloss = mix( surfaceInfo.fGloss, 0.99, bs);\n    \tsurfaceInfo.vR0 = mix( surfaceInfo.vR0, vec3(0.02), bs );   \n    \n    \n    if ( traceResult.iObjectId == MAT_PUMPKIN_INTERIOR )\n    {\n\t\tsurfaceInfo.vAlbedo = vec3(1.0, 0.824, 0.301);\n        \n\t\tsurfaceInfo.fGloss = 0.01;\n\t\tsurfaceInfo.vR0 = vec3(0.02);   \n        surfaceInfo.vEmissive = vGlowCol * 200000.0 * vGlow;\n    }  \n    \n    \tsurfaceInfo.vEmissive *= vBCol;\n         \n\n    if ( fBumpMag > 0.0 )\n    {\n        vec3 vBump;\n        vBump.x = textureLod( iChannel2, vBumpUV.xz, 3.0 ).r - 0.5;\n        vBump.y = textureLod( iChannel2, vBumpUV.xz + 0.3, 3.0 ).r - 0.5;\n        vBump.z = textureLod( iChannel2, vBumpUV.xz + 0.5, 3.0 ).r - 0.5;\n        surfaceInfo.vBumpNormal = normalize( surfaceInfo.vBumpNormal + vBump * fBumpMag );\n    }\n \n    if ( traceResult.iObjectId == MAT_CHROME || traceResult.iObjectId == MAT_CHROME_GLOW)\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fGloss = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8 );\n        \n        /*if ( surfaceInfo.vPos.y < 0.1 && surfaceInfo.vPos.y > 0.09)\n        {\n            surfaceInfo.vEmissive = vec3(0.2, 0.5, 1.0) * 500.0;\n        }*/\n        \n        if ( traceResult.iObjectId == MAT_CHROME_GLOW )\n        {\n            surfaceInfo.vEmissive = GetSpotColor() * 200.0;\n        }\n    }    \n\n    if ( traceResult.iObjectId == MAT_GOLD )\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fGloss = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8, 0.5, 0.1 );\n        \n        /*if ( surfaceInfo.vPos.y < 0.1 && surfaceInfo.vPos.y > 0.09)\n        {\n            surfaceInfo.vEmissive = vec3(0.1, 1.0, 0.1) * 500.0;\n        }\n\t\t*/\n    }       \n    \n    return surfaceInfo;\n}\n\n// Scene Description\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n    //vec3 vToFace = abs(p) - b;\n    //vec3 vConstrained = max( vToFace, 0.0 );\n    //return length( vConstrained ) - r;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat GetCarving2dDistance(const in vec2 vPos )\n{\n    //if(fCarving < 0.0)\n//        return 10.0;\n    \n\tfloat fMouthDist = length(vPos.xy + vec2(0.0, -0.5)) - 1.5;\n\tfloat fMouthDist2 = length(vPos.xy + vec2(0.0, -1.1 - 0.5)) - 2.0;\n\t\n\tif(-fMouthDist2 > fMouthDist )\n\t{\n\t\tfMouthDist = -fMouthDist2;\n\t}\n\n    float fFaceDist = fMouthDist;\n\n    vec2 vNosePos = vPos.xy + vec2(0.0, -0.5);\n    vNosePos.x = abs(vNosePos.x);\n    float fNoseDist = dot(vNosePos.xy, normalize(vec2(1.0, 0.5)));\n    fNoseDist = max(fNoseDist, -(vNosePos.y + 0.5));\n    if(fNoseDist < fFaceDist)\n    {\n        fFaceDist = fNoseDist;\n    }\n\n\n    vec2 vEyePos = vPos.xy;\n    vEyePos.x = abs(vEyePos.x);\n    vEyePos.x -= 1.0;\n    vEyePos.y -= 1.0;\n    float fEyeDist = dot(vEyePos.xy, normalize(vec2(-1.0, 1.5)));\n    fEyeDist = max(fEyeDist, dot(vEyePos.xy, normalize(vec2(1.0, 0.5))));\n    fEyeDist = max(fEyeDist, -0.5+dot(vEyePos.xy, normalize(vec2(0.0, -1.0))));\n    if(fEyeDist < fFaceDist)\n    {\n        fFaceDist = fEyeDist;\n    }\n    \n    return fFaceDist;\n}\n\nfloat GetCarvingDistance( vec3 vPos )\n{\n    float fScale = 1.0 / 30.0;\n    vPos /= fScale;\n\tfloat fDist = GetInnerDist( vPos );\n\n    float fFaceDist = GetCarving2dDistance(vPos.xy);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n    \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.5)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n    \n\treturn fDist * fScale;\n}\n\nSceneResult Scene_GetPumpkinDistance( vec3 vPos )\n{\n    SceneResult result;\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    \n    float fScale = 1.0 / 30.0;\n    float fSphereRadius = 3.0 * fScale;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n    \n    float fAngle1 = atan(vOffset.x, vOffset.z);\n    float fSin = sin(fAngle1 * 10.0);\n    fSin = 1.0 - sqrt(abs(fSin));\n    vOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n    vOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\n    result.fDist = length(vOffset) - fSphereRadius;\n\t    \n\tresult.vUVW = normalize(vPos - vSphereOrigin);\n    \n    //result.fDist -= textureLod( iChannel2, result.vUVW.xz * 1.0, 0.5 ).r * 0.001;\n        \n    result.iObjectId = MAT_PUMPKIN;\n    \n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.15 * fScale + vStalkOffset.y - 0.075;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.2 * fScale + vPos.x * 0.25 * fScale);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < result.fDist )\n\t{\n\t\tresult.fDist = fStalkDist;\n\t\tresult.iObjectId = MAT_PUMPKIN_STALK;\n\t}\n\n\treturn result;\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\t//float n = p.x + p.y*57.0;\n\n\tfloat a = hash12(p);\n\tfloat b = hash12(p+vec2(1,0));\n\tfloat c = hash12(p+vec2(0,1));\n\tfloat d = hash12(p+vec2(1,1));\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nvoid GetSpotState( out vec3 vSpotPos, out vec3 vSpotTarget )\n{\n    vec3 vSpotPivot = vec3(0.0, 0.75, 0.1);\n    vSpotPos = vec3(0.0, 0.25, 0.1);\n    vSpotTarget = vec3(0.0, 0, 0.1);\n    \n    vec3 vSpotOffset = vec3(0);\n    vSpotOffset.x = sin(iTime * 2.0) * 0.1;\n    vSpotOffset.z = cos(iTime * 2.01) * 0.01;\n    \n    vSpotTarget += vSpotOffset;    \n\n    vSpotPos = vSpotPivot + normalize(vSpotTarget- vSpotPivot) * 0.5;\n}\n\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n\n#if 1\n\t//result.fDist = vPos.y;\n    float fBenchBevel = 0.01;    \n    result.fDist = max(max(abs(vPos.y + 0.025) - 0.025, abs(vPos.z) - 1.), abs(vPos.x) - 2.);\n    //result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );\n    \n    TileInfo tileInfo = Tile( vPos.xz * 10.0);\n    result.fDist += tileInfo.fHeight * 0.005;\n    \n    vec2 vRandomUV = vPos.xz;\n    float fRandomMag = 0.0005;\n  \n    if ( tileInfo.bGrout )\n    {\n        vRandomUV = tileInfo.vTilePos * 10.0;\n        fRandomMag = 0.0003;\n    }\n    else\n    {\n        vRandomUV = tileInfo.vTilePos * 0.5;\n        fRandomMag = 0.0005;\n    }\n    \n    if ( vPos.y > 0.01 )\n    {\n        vRandomUV = vPos.xz * 15.0;\n        fRandomMag = 0.0;\n    }\n    \n    float fRandomDist = 0.0;\n    //float fRandomDist = textureLod( iChannel2, vRandomUV, 3.0 ).r;\n    //float fRandomDist = FBM( vRandomUV * 30.0, 0.5);\n    \n    result.fDist += fRandomDist * fRandomMag;\n    \n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_CHECKER;\n    \n\n    //result.fDist = max( vPos.y - 0.1 + textureLod( iChannel2, result.vUVW.xz * 10., 0.5 ).r * 0.12, result.fDist );\n    //result.fDist = min ( result.fDist, 0.3 -vPos.z );\n    \n    float fWallDist = 0.3 -vPos.z;\n    if ( result.fDist > fWallDist )\n    {\n        result.vUVW = vPos.xzy;\n        result.fDist = fWallDist;\n        result.iObjectId = MAT_WOOD;\n    }\n    \n    vec3 vSetPos = vec3(0.0, 0.0, 0.0);\n    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);\n    \n    //vPos.x = fract( vPos.x - 0.5) - 0.5;\n    \n    vec2 vScreenWH = vec2(4.0, 3.0) / 25.0;\n\n    vec3 vPumpkinDomain = vPos - vec3(0,0.075, 0.0);\n    SceneResult resultPumpkin;        \n    resultPumpkin = Scene_GetPumpkinDistance( vPumpkinDomain );\n    //resultPumpkin.fDist -= fRandomDist * 0.0005;\n    \n    SceneResult resultCarving;        \n    resultCarving.vUVW = vPos.xyz;\n\tresultCarving.fDist = GetCarvingDistance( vPumpkinDomain );\n    resultCarving.iObjectId = MAT_PUMPKIN_INTERIOR;\n    \n    resultPumpkin = Scene_Subtract( resultPumpkin, resultCarving );\n    //resultPumpkin = Scene_SmoothSubtract( resultPumpkin, resultCarving, 0.001 );\n    \n    \n    /*\n    if ( resultPumpkin.fDist < vPos.x )\n    {\n        resultPumpkin.fDist = vPos.x;\n\t    resultCarving.iObjectId = MAT_PUMPKIN_INTERIOR;\n    }\n\t*/\n    \n    result = Scene_Union( result, resultPumpkin );                \n    \n#ifdef DRAW_LAMP    \n    SceneResult resultLamp;\n\n    vec3 vSpotPos, vSpotTarget;  \n\n    GetSpotState( vSpotPos, vSpotTarget );\n    vec3 vLampUp = normalize(vSpotPos - vSpotTarget);\n    vec3 vLampPos = vSpotPos + vLampUp * 0.1;\n\n    resultLamp.vUVW = vPos.xzy;\n    resultLamp.fDist = length(vPos - vLampPos ) - 0.1;\n    resultLamp.iObjectId = MAT_CHROME;\n\n    SceneResult resultLampInner;\n\n    resultLampInner.vUVW = vPos.xzy;\n    resultLampInner.fDist = length(vPos - vLampPos + vLampUp * 0.05) - 0.12;\n    resultLampInner.iObjectId = MAT_CHROME_GLOW;\n    resultLamp = Scene_Subtract( resultLamp, resultLampInner );    \n\n    result = Scene_Union( result, resultLamp );    \n#endif    \n    \n#if 0    \n    vec3 vSPos = vPos - vec3(0,0,-.75);\n\t\n\n    SceneResult resultSphere;\n    \n    resultSphere.vUVW = vSPos.xzy;\n\tresultSphere.fDist = length(vSPos - vec3(-0.2,0.075,0.0)) - 0.075;\n    resultSphere.iObjectId = MAT_DEFAULT;\n    result = Scene_Union( result, resultSphere );    \n    \n    resultSphere.vUVW = vSPos.xzy;\n\tresultSphere.fDist = length(vSPos - vec3(0.0,0.075,0.0)) - 0.075;\n    resultSphere.iObjectId = MAT_WOOD;\n    result = Scene_Union( result, resultSphere );    \n    \n    resultSphere.vUVW = vSPos.xzy;\n\tresultSphere.fDist = length(vSPos - vec3(0.2,0.075,0.0)) - 0.075;\n    resultSphere.iObjectId = MAT_CHROME;\n    result = Scene_Union( result, resultSphere );                \n\n    resultSphere.vUVW = vSPos.xzy;\n\tresultSphere.fDist = length(vSPos - vec3(0.4,0.075,0.0)) - 0.075;\n    resultSphere.iObjectId = MAT_GOLD;\n    result = Scene_Union( result, resultSphere );                \n#endif    \n    \n    \n#else\n    float fScale = 10.0;\n    result.vUVW = vPos.xzy;\n    vec2 m = map(vPos * fScale);\n\tresult.fDist =    m.x / fScale;\n    result.iObjectId = (int(m.y) + 0) % 5;\n#endif \n    return result;\n}\n\n\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 3.0;\nvec3 g_vAmbientColor = vec3(0.7, 0.7, 1.0) * 2.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    //Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    vec3 vSpotPos, vSpotTarget;\n    GetSpotState(vSpotPos, vSpotTarget);\n    vec3 vSpotDir = normalize( vSpotTarget - vSpotPos );\n    \n    vec3 vLightCol = GetSpotColor();\n    \n    Light_AddSpot( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vSpotDir, radians(10.0), radians(60.0), vLightCol * 0.02 );\n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vLightCol * 0.001 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n   \n#if 1\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    // Sun\n    //float NdotV = dot( g_vSunDir, vViewDir );\n    //vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n\n    return vResult * 3.5;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.05;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.5, 0.45, 0.4) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    //return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\t\n\t//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    float fReduction = clamp( 60.0 * iTimeDelta - 0.5, 1.0, 4.0 );\n    vec2 vReducedResolution = iResolution.xy / fReduction;\n    vec2 vUV = vFragCoord.xy / vReducedResolution.xy; \n    \n    if ( any( greaterThanEqual( vUV, vec2(1) ) ) )\n    {\n        discard;\n        return;\n    }\n\n    FlyCamState flyCam;\n    \n    FlyCam_LoadState( flyCam, iChannelCurr, ivec2(4,0) );\n        \n\tFlyCam_Update( flyCam, vec3(-0.1, 0.2, -0.4), vec3(.4, .35, 0) );\n    \n    CameraState cam;\n\n#if 0\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y / iResolution.y);\n\n        float fAngle = (iMouse.x / iResolution.x) * radians(360.0);\n    \t//float fElevation = (iMouse.y / iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        if ( iMouse.z <= 0.0 )\n        {\n            fDist = 2.0;\n            fAngle = 3.5f;\n            fElevation = 0.2f;\n        }\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.05,0.0);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 / (1.0 + fDist * 0.5);\n        cam.vUp = vec3(0,1,0);\n    \tvec3 vFocus = vec3(0,0.05,0.0);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif    \n    \n#if 1\n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n    \n    cam.vPos = flyCam.vPos;\n    cam.vTarget = flyCam.vPos + vForwards;\n    cam.vUp = vUp;\n    cam.fFov = 25.0;\n    cam.fPlaneInFocus = 1.0;\n    \n    SceneResult focusTrace = Scene_Trace( flyCam.vPos, vForwards, 0.0, 100.0 );\n    cam.fPlaneInFocus = min( focusTrace.fDist, 3.0);\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n    float fAspectRatio = iResolution.x / iResolution.y;            \n    \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / vReducedResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );    \n    \n    FlyCam_StoreState( ivec2(4,0), flyCam, vFragColor, ivec2(vFragCoord.xy) );\n\tCam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );    \n    \n    StoreVec4( ivec2(7,0), vec4( vReducedResolution,0,0 ), vFragColor, ivec2(vFragCoord.xy) );\n}\n\nvoid mainVR( out vec4 vFragColor, in vec2 vFragCoord, in vec3 vRayOrigin, in vec3 vRayDir )\n{\n    CameraState cam;\n\n    \n    float fDist = 0.01 + 3.0 * (iMouse.y / iResolution.y);\n\n    float fAngle = (iMouse.x / iResolution.x) * radians(360.0);\n    //float fElevation = (iMouse.y / iResolution.y) * radians(90.0);\n    float fElevation = 0.15f * radians(90.0);    \n\n    if ( iMouse.z <= 0.0 )\n    {\n        fDist = 2.0;\n        fAngle = 3.5f;\n        fElevation = 0.2f;\n    }\n\n    cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n    cam.vTarget = vec3(0,0.05,0.0);\n    cam.vPos +=cam.vTarget;\n    cam.fFov = 20.0 / (1.0 + fDist * 0.5);\n    cam.vUp = vec3(0,1,0);\n\t       \n    vFragColor = MainCommon( vRayOrigin, vRayDir );    \n\n    Cam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//    _______                                   _                        _____              \n//   |__   __|                                 | |     /\\        /\\     |  __ \\             \n//      | | ___ _ __ ___  _ __   ___  _ __ __ _| |    /  \\      /  \\    | |__) |_ _ ___ ___ \n//      | |/ _ \\ '_ ` _ \\| '_ \\ / _ \\| '__/ _` | |   / /\\ \\    / /\\ \\   |  ___/ _` / __/ __|\n//      | |  __/ | | | | | |_) | (_) | | | (_| | |  / ____ \\  / ____ \\  | |  | (_| \\__ \\__ \\\n//      |_|\\___|_| |_| |_| .__/ \\___/|_|  \\__,_|_| /_/    \\_\\/_/    \\_\\ |_|   \\__,_|___/___/\n//                       | |                                                                \n//                       |_|                                                                \n\n\n#define ENABLE_TAA\n\n///////////////////////////////\n\n\n#define iChannelCurr iChannel0\n#define iChannelHistory iChannel1\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 TAA_ColorSpace( vec3 color )\n{\n    return Tonemap(color);\n}\n\nfloat minComponent( vec3 a )\n{\n    return min(a.x, min(a.y, a.z) );\n}\n\n// Adapted from https://github.com/gokselgoktas/temporal-anti-aliasing/blob/master/Assets/Resources/Shaders/TemporalAntiAliasing.cginc\n// which is adapted from https://github.com/playdeadgames/temporal\n// Optimization by Stubbesaurus and epsilon adjustment to avoid division by zero\nvec3 clipToAABB(vec3 color, vec3 minimum, vec3 maximum) {\n    // note: only clips towards aabb center (but fast!)\n    vec3 center  = 0.5 * (maximum + minimum);\n    vec3 extents = 0.5 * (maximum - minimum);\n\n    // This is actually `distance`, however the keyword is reserved\n    vec3 offset = color - center;\n\n    vec3 ts = abs(extents / (offset + 0.0001));\n    float t = clamp(minComponent(ts), 0.0, 1.0);\n    return center + offset * t;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannelCurr, ivec2(0) );\n    \n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannelHistory, ivec2(0) );\n\n    vec2 vReducedResolution = LoadVec4( iChannelCurr, ivec2(7,0) ).xy;\n    \t    \n    vec2 vUV = vFragCoord.xy / iResolution.xy;\n\tivec2 vCurrXY = ivec2(floor(vFragCoord.xy));\n    \n    vec2 vfReducedXY = vFragCoord.xy * vReducedResolution / iResolution.xy;\n\tivec2 vReducedXY = ivec2(floor(vfReducedXY));\n    //vfReducedXY -= 0.5;\n\n        \n \t//vec2 vUnJitterUV = vUV - camCurr.vJitter / iResolution.xy;    \n    \n    //vFragColor = textureLod(iChannelCurr, vUnJitterUV, 0.0);\n    //vFragColor = texelFetch( iChannelCurr, vReducedXY, 0);\n    vFragColor = textureLod( iChannelCurr, vfReducedXY / iResolution.xy, 0.0);\n    \n    float fAspectRatio = iResolution.x / iResolution.y;\n    \n    \n#ifdef ENABLE_TAA\n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, fAspectRatio, camCurr, vRayOrigin, vRayDir );    \n    float fDepth;\n    int iObjectId;\n    //vec4 vCurrTexel = texelFetch( iChannelCurr, vReducedXY, 0);\n    vec4 vCurrTexel = texture( iChannelCurr, vfReducedXY / iResolution.xy, 0.0);\n    fDepth = DecodeDepthAndObjectId( vCurrTexel.w, iObjectId );\n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), fAspectRatio );\n        \n    if ( all( greaterThanEqual( vPrevUV, vec2(0) )) && all( lessThan( vPrevUV, vec2(1) )) )\n\t{\n        vec3 vMin = vec3( 10000);\n        vec3 vMax = vec3(-10000);\n        \n        int iNeighborhoodSize = 1;\n        for ( int iy=-iNeighborhoodSize; iy<=iNeighborhoodSize; iy++)\n        {\n            for ( int ix=-iNeighborhoodSize; ix<=iNeighborhoodSize; ix++)\n            {\n                ivec2 iOffset = ivec2(ix, iy);\n\t\t        vec3 vTest = texelFetch( iChannelCurr, vReducedXY + iOffset, 0 ).rgb;\n                                \n                vMin = min( vMin, vTest );\n                vMax = max( vMax, vTest );\n            }\n        }\n        \n        float epsilon = 0.0;\n        vMin -= epsilon;\n        vMax += epsilon;\n        \n        float fBlend = 0.0f;\n        \n        vec4 vHistory = textureLod( iChannelHistory, vPrevUV, 0.0 );\n        vHistory.rgb = clipToAABB( vHistory.rgb, vMin, vMax );\n\n        fBlend = 0.95;\n        \n        //fBlend = 0.0;\n        \n        vFragColor.rgb = mix( vFragColor.rgb, vHistory.rgb, fBlend);\n    }  \n    else\n    {\n        //vFragColor.gb *= 0.0;\n    }\n\n#endif\n    \n    vFragColor.rgb += (hash13( vec3( vFragCoord, iTime ) ) * 2.0 - 1.0) * 0.03;\n    \n\tCam_StoreState( ivec2(0), camCurr, vFragColor, ivec2(vFragCoord.xy) );    \n\tCam_StoreState( ivec2(4,0), camPrev, vFragColor, ivec2(vFragCoord.xy) );    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 12273,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/alexander-nikolaidis-3602545/haunted-house-h-creaking-wood"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//    _____          _   ________   __  _____              \n//   |  __ \\        | | |  ____\\ \\ / / |  __ \\             \n//   | |__) |__  ___| |_| |__   \\ V /  | |__) |_ _ ___ ___ \n//   |  ___/ _ \\/ __| __|  __|   > <   |  ___/ _` / __/ __|\n//   | |  | (_) \\__ \\ |_| |     / . \\  | |  | (_| \\__ \\__ \\\n//   |_|   \\___/|___/\\__|_|    /_/ \\_\\ |_|   \\__,_|___/___/\n//                                                         \n//                                                         \n// Motion blur, Depth of Field\n\n\n#define ENABLE_DOF\n#define ENABLE_MOTION_BLUR\n\n///////////////////////////////\n\n\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t// http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.02;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) /\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\n// Depth of field pass\n\n#define BLUR_TAPS 64\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannel0, ivec2(0) );\n\n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannel0, ivec2(4,0) );\n    \n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n \t//vUV -= camCurr.vJitter / iResolution.xy;    // TAA has removed jitter\n\n    vec4 vSample = texelFetch( iChannel0, ivec2(fragCoord.xy), 0 ).rgba;\n    \n    int iObjectId;\n    float fDepth = DecodeDepthAndObjectId( vSample.w, iObjectId );\n    \n    vec3 vRayOrigin, vRayDir;\n\n    float fAspectRatio = iResolution.x / iResolution.y;\n    \n    Cam_GetCameraRay( vUV, fAspectRatio, camCurr, vRayOrigin, vRayDir );    \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n        \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), fAspectRatio );// - camPrev.vJitter / iResolution.xy;\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = camCurr.fPlaneInFocus;\n        \n\tfloat fCoC = GetCoC( fDepth, camCurr.fPlaneInFocus );\n        \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); // Start angle\n    \n    float fWeight = max( 0.001, fCoC );    \n    vResult.rgb = vSample.rgb * fWeight;\n    fTot += fWeight;\n    \n#if defined(ENABLE_DOF) || defined(ENABLE_MOTION_BLUR)    \n    float fMotionBlurTaps = float(BLUR_TAPS);\n    \n    float fShutterAngle = 0.5;\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<BLUR_TAPS; i++)\n    {\n        float fRandomT = Hash( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        float fOrderedT = fIndex / fMotionBlurTaps;\n        \n        float fDofT = fOrderedT;\n        float fMotionT = fRandomT;\n        \n        vec2 vTapUV = vUV;\n        #ifdef ENABLE_MOTION_BLUR\n        vTapUV = mix( vTapUV, vPrevUV, (fMotionT - 0.5) * fShutterAngle );\n        #endif\n                \n        // http://blog.marmakoide.org/?p=1\n        \n        float fTheta = fDofT * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fDofT * fMotionBlurTaps ) / sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n\t    //vec4 vTapTexel = texelFetch( iChannel0, ivec2(vTapUV.xy * iResolution.xy), 0 ).rgba;\n        \n        int iTapObjectId;\n        float fTapDepth = DecodeDepthAndObjectId( vTapSample.w, iTapObjectId );\n        \n        if ( fTapDepth > 0.0 )\n        {            \n  \t\t  \tfloat fCurrCoC = GetCoC( fTapDepth, fPlaneInFocus );\n            \n            float fCurrWeight = max( 0.001, fCurrCoC );\n            \n    \t\tvResult += vTapSample.rgb * fCurrWeight;\n        \tfTot += fCurrWeight;\n        }\n        f += 1.0;\n        fIndex += 1.0;\n    }\n#endif    \n    vResult /= fTot;\n    \n\tfragColor = vec4(vResult, 1.0);        \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//    _____          _   ________   __  _____              \n//   |  __ \\        | | |  ____\\ \\ / / |  __ \\             \n//   | |__) |__  ___| |_| |__   \\ V /  | |__) |_ _ ___ ___ \n//   |  ___/ _ \\/ __| __|  __|   > <   |  ___/ _` / __/ __|\n//   | |  | (_) \\__ \\ |_| |     / . \\  | |  | (_| \\__ \\__ \\\n//   |_|   \\___/|___/\\__|_|    /_/ \\_\\ |_|   \\__,_|___/___/\n//                                                         \n//                                                         \n// Bloom\n\n///////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 gBloomSize = min( vec2(320.0, 240.0), iResolution.xy );\n    vec2 gBloomSize = iResolution.xy / 4.0;//min( vec2(320.0, 240.0), iResolution.xy );\n    \n\tvec2 vUV = fragCoord.xy / gBloomSize;\n    \n    if ( vUV.x > 1.0 || vUV.y > 1.0 ) \n    {\n        discard;\n        return;\n    }\n\n    // output linear color\n    //fragColor = texture( iChannel0, vUV );\n    //return;\n    \n    #define KERNEL_SIZE 8\n    #define BLOOM_STRENGTH 16.0\n    #define KERNEL_SIZE_F float(KERNEL_SIZE)    \n\n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    {\n        float fY = -KERNEL_SIZE_F;\n        for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ )\n        {\n            float fX = -KERNEL_SIZE_F;\n            for( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ )\n            {            \n\n                vec2 vOffset = vec2( fX, fY );\n                vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) / gBloomSize;\n\n                vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n                if( vTapUV.y < 1.0 / iResolution.y )\n                {\n                   vTapSample = vec4(0.0);\n                }\n\n                vec2 vDelta = vOffset / KERNEL_SIZE_F;\n\n                float f = dot( vDelta, vDelta );\n                float fWeight = exp2( -f * BLOOM_STRENGTH );\n                vResult += vTapSample.xyz * fWeight;\n                fTot += fWeight;\n\n                fX += 1.0;\n            }\n\n            fY += 1.0;\n        }\n    }\n\n    #define HORIZONTAL_BLUR_SIZE 128\n    #define HORIZONTAL_BLOOM_STRENGTH 128.0\n    \n    \n    {\n        float fY = 0.0;\n        float fX = -float(HORIZONTAL_BLUR_SIZE);\n        for( int x=-HORIZONTAL_BLUR_SIZE; x<=HORIZONTAL_BLUR_SIZE; x++ )\n        {            \n\n            vec2 vOffset = vec2( fX, fY );\n            vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) / gBloomSize;\n\n            vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n            if( vTapUV.y < 1.0 / iResolution.y )\n            {\n                vTapSample = vec4(0.0);\n            }\n\n            vec2 vDelta = vOffset / float(HORIZONTAL_BLUR_SIZE);\n\n            float f = dot( vDelta, vDelta );\n            float fWeight = exp2( -f * HORIZONTAL_BLOOM_STRENGTH );\n            vResult += vTapSample.xyz * fWeight;\n            fTot += fWeight;\n\n            fX += 1.0;\n        }\n    }\n    \n    \n    vResult /= fTot; \n    \n    vec4 vPrevSample = textureLod( iChannel1, vUV* gBloomSize / iResolution.xy, 0.0 ).rgba;\n    vResult = max( vResult, vPrevSample.xyz * vec3(0.5, 0.6, 0.7) );\n    //vResult += vPrevSample.xyz * 0.9;\n    \n\tfragColor = vec4(vResult, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//  _   _           _       _____                 _   _                 \n// | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n// | |_| |/ _` / __| '_ \\  | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n// |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n// |_| |_|\\__,_|___/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n//                                                                      \n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n//  ____        _          ____  _                             \n// |  _ \\  __ _| |_ __ _  / ___|| |_ ___  _ __ __ _  __ _  ___ \n// | | | |/ _` | __/ _` | \\___ \\| __/ _ \\| '__/ _` |/ _` |/ _ \\\n// | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __/\n// |____/ \\__,_|\\__\\__,_| |____/ \\__\\___/|_|  \\__,_|\\__, |\\___|\n//                                                  |___/      \n//\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n//\n//  ____       _        _   _             \n// |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n// | |_) / _ \\| __/ _` | __| |/ _ \\| '_ \\ \n// |  _ < (_) | || (_| | |_| | (_) | | | |\n// |_| \\_\\___/ \\__\\__,_|\\__|_|\\___/|_| |_|\n//                                        \n//\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n\n//   ___              _                  _             \n//  / _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n// | | | | | | |/ _` | __/ _ \\ '__| '_ \\| |/ _ \\| '_ \\ \n// | |_| | |_| | (_| | ||  __/ |  | | | | | (_) | | | |\n//  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___/|_| |_|\n//                                                     \n//\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n//\n//  _  __          _                         _ \n// | |/ /___ _   _| |__   ___   __ _ _ __ __| |\n// | ' // _ \\ | | | '_ \\ / _ \\ / _` | '__/ _` |\n// | . \\  __/ |_| | |_) | (_) | (_| | | | (_| |\n// |_|\\_\\___|\\__, |_.__/ \\___/ \\__,_|_|  \\__,_|\n//           |___/                             \n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\n//\n//   ____                               \n//  / ___|__ _ _ __ ___   ___ _ __ __ _ \n// | |   / _` | '_ ` _ \\ / _ \\ '__/ _` |\n// | |__| (_| | | | | | |  __/ | | (_| |\n//  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n//                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\n// fAspectRatio = iResolution.x / iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x /= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nfloat EncodeDepthAndObject( float depth, int objectId )\n{\n    //depth = max( 0.0, depth );\n    //objectId = max( 0, objectId + 1 );\n    //return exp2(-depth) + float(objectId);\n    return depth;\n}\n\nfloat DecodeDepthAndObjectId( float value, out int objectId )\n{\n    objectId = 0;\n    return max(0.0, value);\n    //objectId = int( floor( value ) ) - 1; \n    //return abs( -log2(fract(value)) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}