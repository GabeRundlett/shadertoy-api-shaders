{
    "Shader": {
        "info": {
            "date": "1686964052",
            "description": "Inspired by: https://twitter.com/Yugemaku/status/1669282000077983744?t=owWEnj-YCzsDxlyV2GAqHg&s=35",
            "flags": 0,
            "hasliked": 0,
            "id": "ddsyzS",
            "likes": 25,
            "name": "Fractal braids",
            "published": 3,
            "tags": [
                "fractal",
                "curves",
                "reproduction",
                "braids"
            ],
            "usePreview": 0,
            "username": "AndrewB330",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "const float M_PI = 3.14159265358979323846264338327950288;\nconst float M_PI_T2 = M_PI * 2.0;\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\nconst vec3 LIGHT = normalize(vec3(1.0));\n\nfloat sqr(float x) { return x * x; }\n\nvec3 point_on_curve(float t, float phase, float stretch)\n{\n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    return vec3(cs, t * stretch, sn * cs);\n}\n\nfloat dist_to_point_on_curve(vec3 p, float t, float phase, float stretch)\n{\n    return length(point_on_curve(t, phase, stretch) - p);\n}\n\nfloat dist_to_point_on_curve_dt(vec3 p, float t, float phase, float stretch)\n{\n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    return 2.0 * (sn * (p.x - cs) + (sqr(sn) - sqr(cs)) * (p.z - sn * cs) - stretch * (p.y - stretch * t));\n}\n\nfloat nearest_point_on_curve(vec3 p, float phase, float stretch)\n{\n    float t = p.y / stretch;\n    for (int i = 0; i < 16;i++)\n    {\n        float dt = dist_to_point_on_curve_dt(p, t, phase, stretch);\n        t -= dt * 0.1;\n    }\n    return t;\n}\n\nfloat dist_to_curve(vec3 p, float phase, float stretch)\n{\n    float t = nearest_point_on_curve(p, phase, stretch);\n    return dist_to_point_on_curve(p, t, phase, stretch);\n}\n\nfloat approximate_curve_length(float t, float phase, float stretch)\n{\n    return t * (pow(stretch * 2.2, 1.8) + 9.9)/10.0 - sin((t + phase) * 2.0) * 0.1 * ((0.95 - cos(2.0 * (t + phase))) * 0.83) + sin(phase * 2.0) * 0.095;\n}\n\nvec3 curve_transform(vec3 p, float phase, float stretch, float radius, float target_radius)\n{\n    float t = nearest_point_on_curve(p, phase, stretch);\n    float l = approximate_curve_length(t, phase, stretch);\n    vec3 pp = point_on_curve(t, phase, stretch);\n    \n    float sn = sin(t + phase);\n    float cs = cos(t + phase);\n    \n    vec3 ny = normalize(vec3(-sn, stretch, cs * cs - sn * sn));\n    vec3 nz = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 nx = normalize(cross(ny, nz));\n    nz = normalize(cross(nx, ny));\n    \n    float scale = (1.0 + target_radius) / radius;\n    return vec3(dot(p - pp, nx), l, dot(p - pp, nz)) * scale;\n}\n\nfloat sd_curve(vec3 p, float phase, float stretch, float radius)\n{\n    return (dist_to_curve(p, phase, stretch) - radius) * 0.5;\n}\n\nvec4 op(vec4 a, vec4 b)\n{\n    return a.w < b.w ? a : b;\n}\n\nvec2 uv = vec2(0.0);\n\nvec4 map(vec3 p)\n{\n    p.xyz = p.yxz;\n    float a = iTime * 0.9;\n    vec4 res = vec4(0.0, 0.0, 0.0, 1000.0);\n    \n    float stretch = 1.5;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        vec3 pp = curve_transform(p, M_PI * 4.0 / 3.0 * float(i), stretch, 0.45, 0.55);\n        \n        if (length(vec2(pp.x, pp.z)) > 2.0)\n        {\n            res = op(res, vec4(vec3(0.0), length(vec2(pp.x, pp.z)) - 0.0));\n            continue;\n        }\n        \n        float f = (sqr(sin(iTime + float(i) * 3.14 / 3.0)) + iTime) * 0.8;\n        for (int j = 0; j < 3; j++)\n        {            \n            vec3 ppp = curve_transform(pp, M_PI * 4.0 / 3.0 * float(j) + f, stretch, 0.55, 0.55);\n            \n            if (length(vec2(ppp.x, ppp.z)) > 2.0)\n            {\n                res = op(res, vec4(vec3(0.0), length(vec2(ppp.x, ppp.z)) - 0.0));\n                continue;\n            }\n            \n            for (int k = 0; k < 3; k++)\n            {\n                vec3 pppp = curve_transform(ppp, M_PI * 4.0 / 3.0 * float(k) + f / 0.2, stretch, 0.55, 0.3);\n                vec3 col = vec3(0.5 + float(i) * 0.1, 0.8 + float(j) * 0.07, 0.4 + float(k) * 0.1);\n                float index = float(i * 9 + j * 3 + k);\n                float t1 = (sin(iTime / 32.0) * 0.5 + 0.5) * 27.0;\n                float t2 = (sin(iTime / 32.0 + 16.0) * 0.5 + 0.5) * 27.0;\n                col = mix(vec3(0.4, 1.1, 1.8), col, clamp(sqr(index - t1), 0.0, 1.0));\n                col = mix(vec3(1.9, 0.99, 0.5), col, clamp(sqr(index - t2), 0.0, 1.0));\n                res = op(res, vec4(col, (length(vec2(pppp.x, pppp.z)) - 0.9)));\n            }\n        }\n    }\n    \n    res.w *= 0.03;\n    return res;\n}\n\nvec4 trace(vec3 origin, vec3 dir)\n{\n    float t = 0.0;\n    for (int i = 0; i < 80; i++)\n    {\n        vec4 h = map(origin);\n        origin += dir * h.w;\n        t += h.w;\n        if (h.w < 0.01) return vec4(h.rgb, t);\n        if (origin.z < -50.0) break;\n    }\n\n    return vec4(-1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.02;\n    return normalize(e.xyy*map(pos + e.xyy).w +\n\t\t\t\t\t e.yyx*map(pos + e.yyx).w +\n\t\t\t\t\t e.yxy*map(pos + e.yxy).w +\n\t\t\t\t\t e.xxx*map(pos + e.xxx).w);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n    vec2 ratio = iResolution.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3((uv - 0.5) * ratio, -1.0));\n    vec3 origin = vec3(0.0 + iTime * 0.1, 0.0, 4.0);\n    \n    vec4 res = trace(origin, dir);\n    if (res.w > 0.0)\n    {\n        vec3 n = calcNormal(origin + res.w * dir);\n        float l = clamp(dot(LIGHT, n), 0.0, 1.0) * 0.8 + 0.2;\n        fragColor = vec4(res.rgb * l,1.0);\n        return;\n    }\n\n    fragColor = vec4(vec3(0.0),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}