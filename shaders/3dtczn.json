{
    "Shader": {
        "info": {
            "date": "1600281629",
            "description": "Flight through a spiral\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3dtczn",
            "likes": 12,
            "name": "Flight through a spiral",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "illus0r",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "#define textureCube texture\n\n#define MAX_STEPS 99\n#define MAX_DIST 20.\n#define EPSILON 0.001\n#define PI 3.1415\n\n#define EMPTY 0.\n#define MIRROR 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define WHITE_MIRROR 5.\n#define PUREWHITE 6.\n#define n getNormal(p)\n\n#define tBeam vec2(.2,.5)\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define tChank 4.28125\n\nmat2 Rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sdOctahedron( vec3 p, float s) { p = abs(p); float m = p.x+p.y+p.z-s; vec3 q; if( 3.0*p.x < m ) q = p.xyz; else if( 3.0*p.y < m ) q = p.yzx; else if( 3.0*p.z < m ) q = p.zxy; else return m*0.57735027; float k = clamp(0.5*(q.z-q.y+s),0.0,s); return length(vec3(q.x,q.y-s+k,q.z-k)); }\nfloat Rnd (float x) {return 2.*fract(10000. * sin(10000. * x))-1.;}\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdTorus( vec3 p, vec2 t ){ vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\n\nfloat sdWater(vec3 p) {\n    float t = iTime * 10.1;\n    p.y += .001*sin(p.z*17.+t);\n    p.y += .001*sin(p.z*13.+t);\n    p.y += .001*sin(p.x*11.+t*.5);\n    return p.y;\n}\n\nfloat sdMirrors(vec3 p) {\n    float c = 1.1;\n    p.xy *= Rot(PI/4.);\n    p.xz *= Rot(.1*iTime);\n    vec3 l = vec3(2,0,2), id = round(p/c);\n    p = p-c*clamp(id,-l,l);\n    p.xz *= Rot(p.y*(Rnd(id.x)+1.) + 30.*iTime * (Rnd(id.x + 10. * id.z)+1.5));\n    // p.xz *= atan(p.x, p.z);\n    return sdBox(p, vec3(.1,10.,.001));\n}\n\nfloat sdRocket (vec3 p){\n    // p.y /= 2.;\n    // p.xz *= Rot(iTime);\n    p.xy *= Rot(PI/4.);\n    float sph=length(p) - 1.;\n    for(float i=2.;i<5.;i+=0.5){\n        // float shift = 4.*sin(iTime*i);\n        // float shift = 20.*(fract(.1*iTime*(1.2+.4*Rnd(i))+Rnd(i))*2.-1.)*i;\n        float shift = tan(iTime*(1.2+.4*Rnd(i))+Rnd(i))*10.;\n        float spread = 4.;\n        sph=opSmoothUnion(sph, (length(p*i+vec3(spread*Rnd(i),shift,spread*Rnd(i+1.))) - 1.)/i, .4);\n    }\n    return sph;    \n}\n\nfloat sdBeam(vec3 p){\n    p.xy *= Rot(PI/4.);\n    float size = 3.*Rnd(iTime)*.5+.5;\n    vec3 shift = 2.4*(vec3(Rnd(iTime+9.), 0, Rnd(iTime+99.))*.5);\n    return sdBox(p+shift, vec3(.2*size,100.,.2*size));\n}\n\nfloat timeCurve(float t) {\n    t = t * 4. / tChank;\n    // t = t / 1000.;\n    float whole = floor(t);\n    float decimal = fract(t);\n    t =  (whole + 1. - pow(1. - decimal, 32.));\n    return t;\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    // float t = timeCurve(iTime);\n    // for(float j;++j<6.;){\n    //     p=abs(p)-1.1;\n    //     p=abs(p)-1.1;\n    //     p.xz*=Rot(t / 5.91 + j);\n    //     p.xy*=Rot(t / 3.21 + j);\n    // }\n    // p.y+=1.;\n    // float wave = 0.;//pow(sin(length(p + fract((iTime+.2) * 4. / tChank)))*.5+.5, 64.)*.2;\n    // p.y *= .99;\n    // p.x = cos(p.z);\n    // p.y = sin(p.z);\n\n    // p.z = cos(p.z * 1. + iTime * 10.);\n    // p.zy*=Rot(PI / 2.);\n    // vec2 obj = vec2(sdTorus(p, vec2(3.3, 0.)), WHITE_MIRROR);\n    // p.x -= 1.;\n    p.z += iTime * 10.1;\n    float w = p.z * 1.5 + iTime * 1.;\n    p.x += .6*cos(w);\n    p.y += .6*sin(w);\n    // p.y*=Rot(PI / 2.);\n    p.xy*=Rot(p.z * 1.1 + iTime);\n    p.x += 1.4;\n    vec2 obj = vec2(length(p.xy) * .3, WHITE_MIRROR);\n\n    return obj;\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = EMPTY;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n_ = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n_);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// used recursively for reflections\n// vec3 getColor(vec3 ro, vec3 rd, vec3 color, int depth) {\n// }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d, info, dTotal=0.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro, rd, color, p, rm;\n    float camDist = -10.;// + 5.*sin(timeCurve(iTime));//-17.+12.*smoothstep(2., 2.3, fract(iTime/5.)*5.);\n    ro = vec3(0,0,camDist);\n    // ro.xz *= Rot(timeCurve(iTime));\n    // ro.xy *= Rot(PI/4.);\n    // ro += 1.1*sin(iTime*4.)*vec3(Rnd(iTime),Rnd(iTime+100.),0); // shake\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n    color = vec3(0);\n    float colorAmount = 0.;\n\n    // for(int reflectionDepth = 0; reflectionDepth < 2; reflectionDepth++) {\n    //     rm = rayMarch(ro, rd);\n    //     dTotal += d = rm[0];\n    //     info = rm[1];\n    //     p = ro + rd * d;\n    //     if (d < MAX_DIST) {\n    //         // color = vec3(1);//textureCube(iChannel0, rd).rgb;\n    //         if (info == MIRROR) {\n    //             rd = reflect(rd, n);\n    //             ro = p + 0.01 * rd;\n    //             continue;\n    //             // do nothing, propogate color getting to the reflection\n    //         }\n    //         else if (info == WHITE_MIRROR) {\n    //             vec3 nn = n;\n    //             nn.xy*=Rot(1.);\n    //             // color = vec3(1) * (dot(nn, vec3(1,1,-1))*.3+.7);\n    //             color = nn*.5+.5;\n    //         }\n    //         else if (info == PUREWHITE) {\n    //             color += vec3(1) * (1. - colorAmount);\n    //             colorAmount = 1.;\n    //         }\n    //     }\n    //     else {\n    //         // color += textureCube(iChannel0, vec3(rd.y, rd.xz*Rot(iTime)).yxz).rgb * (1. - colorAmount);\n    //         // colorAmount = 1.;\n    //     }\n    //     break;\n    // }\n    // // color = mix(color, vec3(0,uv.yx+.5)*.2, smoothstep(20., 100., dTotal));\n    // color = mix(color, rd*.2, smoothstep(20., 100., dTotal));\n    // fragColor = vec4(color, 1);\n \n    rm = rayMarch(ro, rd);\n    fragColor = vec4(vec3(.003/rm.z), 1);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}