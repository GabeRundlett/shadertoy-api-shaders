{
    "Shader": {
        "info": {
            "date": "1552137103",
            "description": "The idea is fron ABZU game, but the Non-Photorealistic cloud render is a little bad=.=",
            "flags": 0,
            "hasliked": 0,
            "id": "MtyBDV",
            "likes": 16,
            "name": "Non-Photorealistic Try",
            "published": 3,
            "tags": [
                "waternonphotorealisticcloud"
            ],
            "usePreview": 1,
            "username": "WingStone",
            "viewed": 869
        },
        "renderpass": [
            {
                "code": "#define EPS 0.001\n\n//value noise\n//reference: https://www.shadertoy.com/view/4sfGzS\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat NoiseCloud(vec3 pos)\n{\n    pos *=2.0;\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    vec2 uv = p.xy + vec2(37.0, 17.0)*p.z + f.xy;\n    \n    vec2 rg = texture(iChannel0, (uv+0.5)/256.0).yx;\n    return mix(rg.x, rg.y, f.z)*2.0-1.0;\n}\n\n// water\nfloat Noise( in vec3 pos )\n{\n    vec2 p = pos.xz;\n    \n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat Random(vec2 uv)\n{\n    return texture(iChannel0, uv).y;\n}\n\nfloat HightFunction(vec3 pos)\n{\n    float hight = 0.15*Noise(pos*0.2)*(sin(pos.x)\n                       + 1.1*sin(pos.z + iTime));\n    hight += 0.05*(pow((sin(pos.x - 1.5*pos.z + iTime*3.0)+1.)/2.,1.5));\n    return hight*0.3;\n}\n\nfloat CloudHightFunction_1(vec3 dir)\n{\n    float hight = 0.01*(sin(10.*dir.x + iTime*0.5)) + dir.y + 0.25;\n    return hight;\n}\n\nfloat CloudHightFunction_2(vec3 dir)\n{\n    float hight = NoiseCloud(dir*1.5)*0.2*(sin(10.*dir.x + 1.)) + dir.y+ 0.03 +0.05*Noise(dir*5.);\n    return hight ;\n}\n\nfloat CloudHightFunction_3(vec3 dir)\n{\n    float hight =  NoiseCloud(dir*6.2) + 0.4*(NoiseCloud(dir*12.))+ dir.y*8.;\n    return hight ;\n}\n\nfloat CloudDistanceFuntion(vec3 dir, vec3 dircenter, float noise_if, float noise_of)\n{\n    float c = distance(normalize(dircenter), dir) + NoiseCloud(dir*noise_if)*noise_of;\n    return c;\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    vec3 dx = vec3(EPS, HightFunction(pos+vec3(EPS, 0.0, 0.0))-HightFunction(pos), 0.0);\n    vec3 dz = vec3(0, HightFunction(pos+vec3(0.0, 0.0, EPS))-HightFunction(pos), EPS);\n    return normalize(cross(dz, dx));\n}\n\nfloat RayMatching(vec3 rayOri, vec3 rayDir, float random)\n{\n    if(rayDir.y >= 0.0)\n        return -1.0;\n\n\tfloat nearDist = 0.1f;\n    float farDist = 100.0f;\n    float stp = 0.05f;\n    \n    float d = nearDist;\n    float lastHeight;\n    float lastPosy;\n    rayOri += random*stp*rayDir;  //dither\n    while(d < farDist)\n    {\n        vec3 pos = rayOri + rayDir*d;\n        float hight = HightFunction(pos);    \n        if(hight > pos.y)\n        {\n            //intersection\n            float delt = hight - pos.y;\n            float lastDelt = lastPosy -lastHeight;\n            return d + stp*lastDelt/(lastDelt + delt);\n        }\n        lastHeight = hight;\n        lastPosy = pos.y;\n        stp += 0.01;\n        d += stp;\n    }\n\n    return -1.0;\n}\n\nvec3 GetSkyCol(vec3 dir)\n{\n    vec3 lightDir = normalize(vec3(-0.3, 0.3, 1.));\n    float bk_factor = dot(dir, lightDir);\n    vec3 lightCol = vec3(1.0,0.97,0.94);\n    vec3 cloudCol1 = vec3(0.68, 0.86, 0.93);\n    vec3 cloudCol2 = vec3(0.87, 0.95, 0.96);\n    vec3 cloudCol3 = vec3(0.81, 0.93, 0.96);\n    vec3 col = mix(vec3(0.22, 0.59, 0.81), lightCol,\n                   clamp(0.0, 1.0, pow(bk_factor,64.0)) + smoothstep(0.998,1.0, bk_factor));\n    \n    vec3 cloud_light;\n\tfloat edgenoise = 0.014*Noise(dir*20.);\n    \n    float dis = CloudDistanceFuntion(dir+ vec3(0.005, 0.008, 0.), vec3(-0.6,0., 1.), 10., 0.05);\n    cloud_light = mix(cloudCol1, cloudCol2, smoothstep(0.3, 0.31, dis+edgenoise));\n    col = mix(cloud_light, col,\n              smoothstep(0.315, 0.32,CloudDistanceFuntion(dir, vec3(-0.6,0., 1.), 10., 0.05)));\n    \n    dis = CloudDistanceFuntion(dir+ vec3(0.005, 0.004, 0.), vec3(0.4,-0.1, 1.), 5., 0.05);\n    cloud_light = mix(cloudCol1, cloudCol2, smoothstep(0.3, 0.31, dis+edgenoise));\n    col = mix(cloud_light, col,\n              smoothstep(0.315, 0.32,CloudDistanceFuntion(dir, vec3(0.4,-0.1, 1.), 5., 0.05)));\n    \n    cloud_light = cloudCol1;\n    if(CloudHightFunction_2(dir + vec3(0.02, 0.015, 0.)) + edgenoise> 0.21)\n        cloud_light = cloudCol2;\n    col = mix(cloud_light, col,\n              smoothstep(0.2,0.205, CloudHightFunction_2(dir) +0.015*Noise(dir*14.)));\n    \n    cloud_light = cloudCol1;\n    if(CloudHightFunction_3(dir + vec3(0.02, 0.003, 0.)) + edgenoise> 0.32)\n        cloud_light = cloudCol2;\n    col = mix(cloud_light, col,\n              smoothstep(0.29, 0.3,CloudHightFunction_3(dir)));\n    \n    cloudCol3 = mix(  vec3(0.22, 0.59, 0.81),cloudCol3,smoothstep(-0.125,-0.05, dir.y));\n\tcol = mix(cloudCol3, col,\n              smoothstep(0.2, 0.21,CloudHightFunction_1(dir) +0.015*Noise(dir*15.) ));\n    \n\n    \n    return col;\n}\n\nvec3 CalculateCol(vec3 pos, vec3 nor, vec3 viewDir)\n{\n  \tvec3 specDir = normalize(reflect(viewDir, nor));\n    vec3 skycol = GetSkyCol(specDir);\n    return skycol;\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(0, 10.0, 0.);\n    vec3 target = vec3(0.0, 9.98, 1.0);\n    \n    vec3 front = normalize(target - camera);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), front);\n    vec3 up = cross(front,right);\n    vec3 rayDir = normalize(front*1.732 + uv.x*right + uv.y*up);\n    \n    float random = Random(uv);\n    float dist = RayMatching(camera, rayDir, random);\n    \n    vec3 pos = camera + rayDir*dist;\n    vec3 nor = GetNormal(pos);\n    \n    vec3 col;\n    if(dist < 0.0)\n    {\n        col = GetSkyCol(rayDir);\n    }\n    else\n    {\n    \tcol = CalculateCol(pos, nor, rayDir);\n        col = mix( col, vec3(0.22, 0.59, 0.81),smoothstep(80.,110., dist));\n    }\n    \n    //col = vec3(random,random,random);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}