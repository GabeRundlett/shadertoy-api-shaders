{
    "Shader": {
        "info": {
            "date": "1560990724",
            "description": "some raycasting with voxels search :)",
            "flags": 0,
            "hasliked": 0,
            "id": "WtjGDy",
            "likes": 12,
            "name": "Analytic Repeated Primitives",
            "published": 3,
            "tags": [
                "sphere",
                "voxel",
                "antialiasing",
                "analytic",
                "repeat",
                "primitive"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 821
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// coded with NoodlesPlate https://github.com/aiekick/NoodlesPlate/releases\n\n// I searched a way for repeat analytics primitive like we do in raymarched stuff\n// I though, i could find a voxel, where i can calculate distance with the \n// voxel center of the current point\n// i tried 3 planes intersection at first, very buggy on some hits and camera angle\n// after few simplication, i discovered that code :)\n\n// and in the same time i gain understanding of many voxel demo\n// available on this site :) finally\n\n// i not understanding all the bugs i have with :\n\n// noise with many reflections and other shapes\n// the goursat shape or torus give many noise at 5-6 layer of the eye..\n// maybe normal precision but also due to my mixing reduction (transfer var) or other ?\n\n// i would like to create a truchet demo with a maybe 5-6 refraction\n// (The interest of the raycasting is the cost, so have many reflections can be cool)\n// but i failed to have good shapes when i decentered torus :)\n\n// if you have idea of better lighting, please share :)\n\n// :)\n\n#define AA 1\n\n// try with 5, for seeing the balls appearing :)\n#define layers 100\n\n#define primitiveRadius 0.5\n#define voxelSize vec3(2.0)\n\n// I got 60 fps with 20 reflections  with AA 1:) but not interesting visually\n#define countReflections 3\n#define transfer 5.\n\n#define eliRadius primitiveRadius * vec3(sin(vc)*0.25+0.75)\n#define torRadius primitiveRadius * vec2(1, 0.2)\n\n// with other primitives than sphere or ellipsoid\n// the reflections count cause noise issues (normal precision i thinck)\n// so maybe put countReflections at 0 or tune transfer\n\n// not very happy with the lighting :)\n\nfloat getPrimitive(vec3 ro, vec3 rd, vec3 vc)\n{\n\treturn sphIntersect(ro, rd, vec4(vc, primitiveRadius));\n    //return eliIntersect(ro, rd, vc, eliRadius);\n    //return iGoursat(ro-vc, rd, 0.1, 0.5);\n    //return iTorus(ro - vc, rd, torRadius);\n}\n\nvec3 getNor(vec3 p, vec3 vc)\n{\n\treturn sphNormal(p, vec4(vc, primitiveRadius));\n    //return eliNormal(p, vc, eliRadius);\n    //return nGoursat(p - vc, 0.1, 0.5);\n\t//return nTorus(p - vc, torRadius);\n}\n\nfloat getDist(vec3 ro, vec3 rd, vec3 vs, out vec3 vc)\n{\n\tfloat ds = -1.0;\n\t\n\tvec3 p = ro;\n    for (int i=0;i<layers;i++)\n\t{\n\t\tvc = (floor(p / vs) + 0.5) * vs; // voxel center\n\t\tds = getPrimitive(ro, rd, vc); \t // distance to analytic primitve\n        if (ds > 0.0) break; \t         // hit => exit\n\t\tp += rd * vs;\t\t\t         // move point to next voxel along ray if no hit\n\t}\n    \n    // for render when no hit after all layers\n\tif (ds < 0.0)\n\t\tds = float(layers);\n\t\n\treturn ds;\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 vc)\n{\n    vec3 p = ro;\n\tvec3 n = getNor(p, vc);\n\t\n    vec3 ld = vec3(-0.25, -1, 0.25);\n\t\n    float diff = dot(n, ld) * .5 + .5;\n\tfloat spe = pow(max(dot(-rd, reflect(-ld, n)), 0.0), 8.0);\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\t    \n    vec3 c = (n * 0.5 + 0.5) * diff; // basic coloring :)\n    c += fre * 0.25 + spe * 0.5;\n\n\treturn c;\t\n}\n\nvec3 render(vec2 uv)\n{\n\tvec3 color = vec3(0);\n\tfloat t = iTime;\n\t\n    vec3 ro = path(t);\n    float a = atan(ro.x, ro.z) + 3.14159 * 0.5 + iTime * 0.1;\n    vec3 tgt = ro + vec3(cos(a), sin(a), sin(a));\n\tvec3 rd = camera(uv, ro, tgt);\n\n\tvec3 vc = vec3(0); // voxel center\n\tfloat ds = getDist(ro, rd, voxelSize, vc);\n\tfloat fog = 1.0-exp(-0.0002*ds*ds); // fog with first hit\n\n\tvec3 p = ro + rd * ds;\n\t\n    // first coloring\n    color = shade(p, rd, vc);\n\t\n    // reflections\n\tfloat d = ds; \n\tfor (int i=0;i<countReflections;i++)\n\t{\n\t\tvec3 n = getNor(p, vc);\n\t\trd = reflect(rd, n);\n\t\tds = getDist(p, rd, voxelSize, vc);\n\t\td *= ds;\n\t\tp += rd * ds;\n\t\tcolor = mix(color, shade(p, rd, vc), transfer / d);\n\t}\n\t\n\treturn clamp(mix(color, vec3(0), fog),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0);\n    \n    // AA tech from iq shaders\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 px = fragCoord + vec2(float(m),float(n))/float(AA);\n        vec2 p = (-iResolution.xy+2.0*px)/iResolution.y;\n    \tcol += render( p );    \n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 camera(vec2 uv, vec3 ro, vec3 tgt)\n{\n    vec3 z = normalize(tgt-ro);\n\tvec3 x = normalize(cross(vec3(0,1,0),z));\n\tvec3 y = cross(z, x);\n\treturn normalize(uv.x*x+uv.y*y+z);\n}\n\nvec3 path(float t)\n{\n\treturn vec3(0.,cos(t*0.25) * 10.0, t*2.);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//////// sphere related functions from iq // https://www.shadertoy.com/view/lsSSWV //////////\n/////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat sphShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    return step( min( -b, min( c, b*b - c ) ), 0.0 );\n}\n            \nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float s = 1.0;\n    vec2 r = sphDistances( ro, rd, sph );\n    if( r.y>0.0 )\n        s = max(r.x,0.0)/r.y;\n    return s;\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b -sqrt( h );\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\n// iq shader: https://www.shadertoy.com/view/4sBGDy\n\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\t\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n\n\nvec3 eliNormal( vec3 p, vec3 cen, vec3 rad )\n{\n    return normalize( (p-cen)/rad );\n}\n\nfloat eliIntersect( vec3 ro, vec3 rd, vec3 cen, vec3 rad )\n{\n    vec3 oc = ro - cen;\n    \n    vec3 ocn = oc / rad;\n    vec3 rdn = rd / rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return -1.0;\n\treturn (-b - sqrt( h ))/a;\n}\n\n// (x4 + y4 + z4) - (r2^2)·(x2 + y2 + z2) + r1^4 = 0;\nfloat iGoursat( vec3 ro, vec3 rd, float ka, float kb )\n{\n    float po = 1.0;\n\n    vec3 rd2 = rd*rd; vec3 rd3 = rd2*rd;\n    vec3 ro2 = ro*ro; vec3 ro3 = ro2*ro;\n\n    // raw quartic\n    float k4 = dot(rd2,rd2);\n    float k3 = dot(ro ,rd3);\n    float k2 = dot(ro2,rd2) - kb/6.0;\n    float k1 = dot(ro3,rd ) - kb*dot(rd,ro)/2.0;\n    float k0 = dot(ro2,ro2) + ka - kb*dot(ro,ro);\n\n    // make leading coefficient 1\n    k3 /= k4;\n    k2 /= k4;\n    k1 /= k4;\n    k0 /= k4;\n    \n    // reduced cubic\n    float c2 = k2 - k3*(k3);\n    float c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n    float c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n\n#if 1\n    // prevent |c1| from being too close to zero\n    // reduced cubic\n    if( abs(c1) < 0.1*abs(c2) )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n\n        c2 = k2 - k3*(k3);\n        c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n        c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n    }\n#endif\n\n\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c0*c2 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    // 2 intersections\n    if( h>0.0 )\n    {\n        h = sqrt(h);\n\n        float s = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        \n        float x = s+u+4.0*c2;\n        float y = s-u;\n        float ks = x*x + y*y*3.0;\n        float k = sqrt(ks);\n\n\t\tfloat t = -0.5*po*abs(y)*sqrt(6.0/(k+x)) - 2.0*c1*(k+x)/(ks+x*k) - k3;\n        return (po<0.0)?1.0/t:t;\n    }\n\t\n\t// 4 intersections\n    float sQ = sqrt(Q);\n    float w = sQ*cos(acos(-R/(sQ*Q))/3.0);\n  //float w = sQ*cos(atan(sqrt(-h),-R)/3.0);\n\n    float d2 = -w - c2; if( d2<0.0 ) return -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?1.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?1.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?1.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?1.0/t4:t4;\n\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n}\n\nvec3 nGoursat( in vec3 pos, float ka, float kb )\n{\n    return normalize( 4.0*pos*pos*pos - 2.0*pos*kb*kb );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}