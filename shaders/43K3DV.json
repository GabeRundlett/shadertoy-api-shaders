{
    "Shader": {
        "info": {
            "date": "1719473010",
            "description": "an improved version of my previous Raymarching Renderer",
            "flags": 0,
            "hasliked": 0,
            "id": "43K3DV",
            "likes": 1,
            "name": "Fork RayMarchin simplexqwe 853",
            "published": 3,
            "tags": [
                "raymarching",
                "rmc"
            ],
            "usePreview": 0,
            "username": "simplexqwe",
            "viewed": 99
        },
        "renderpass": [
            {
                "code": "#define FOV 1.\n#define MAX_DIST 60.\n#define MAX_STEPS 60\n#define EPSILON .01\n\nvec2 idmin(vec2 d1,vec2 d2){\n    return (d1.x<d2.x)?d1:d2;\n}\n\nvec2 map(vec3 p){\n  //sphere\n    float rdi = fBox(p-vec3(0.,sin((p.x+iTime)*3.)*.25+10.,cos((p.x+iTime)))*.25,vec3(.75,.0,.0))-.5+\n                texture(iChannel0,vec2(p.xy+p.z),1.).x/10.;\n    float rid = 1.;\n    vec2  r   = vec2(rdi,rid);\n    \n    float qdi = length(p-vec3(sin((p.y+iTime)*2.)*.25,cos((p.z+iTime)*2.),0.)*.25)-1.+\n                texture(iChannel0,vec2(p.xy+p.z),1.).x/10.;\n    float qid = 1.;\n    vec2  q   = vec2(qdi,qid);\n    \n  //plane\n    float  pldi = dot(p,vec3(0.,1.,0.))+texture(iChannel3,p.xz/sqrt(2.),1.).x/8. ;\n    float  plid = 2.;\n    vec2   pl   = vec2(pldi,plid);\n    \n    return idmin(idmin(r,q),pl);\n}\n\nvec2 raymarch(vec3 ro,vec3 rd){\n    vec2 hit,object;\n    \n        for(int i=0;i<MAX_STEPS;i++){\n            vec3 p = ro+rd*object.x;\n            hit    = map(p);\n            \n            object.x+=hit.x;\n            object.y =hit.y;\n            \n            if(abs(hit.x)<EPSILON||object.x>MAX_DIST)break;\n        }\n    return object;\n}\n\n\nvec3 getnormal(vec3 p){\n    vec2 e = vec2(EPSILON,0.);\n    vec3 n = vec3(map(p).x)-vec3(map(p-e.xyy).x,\n                                 map(p-e.yxy).x,\n                                 map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat sh(vec3 p,vec3 lpo){\n    float res = 1.;\n    float dis = .1;\n    float lis = .3;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        float hit = map(p+lpo*dis).x;\n        res       = min(res,hit/(dis*lis));\n        dis      += hit;\n        \n        if(hit<.00001||dis>MAX_DIST)break;\n    }\n    return smoothstep(0.,1.,res);\n}\n\nvec3 getlight(vec3 p,vec3 rd,vec3 col){\n\n    vec3 lpo = vec3(20.,40.,-30.);    \n    vec3 l   = normalize(lpo-p);\n    vec3 n   = getnormal(p);\n    \n    vec3 speccol = vec3(.5);\n    vec3 spec    = speccol*pow(clamp(dot(reflect(-l,n),-rd),0.,1.),10.);\n    vec3 dif     = col*clamp(dot(l,n),0.,1.);\n    vec3 ambient = col*vec3(.05);\n    vec3 fresnel = .15*col*pow(1.+dot(rd,n),3.);\n    \n    float shadow = sh(p+n*.02,normalize(lpo));\n    \n    return (ambient+fresnel+(spec+dif)*shadow)*vec3(.9294,.8352,.6196);\n}\n\nvec3 getmat(vec3 p,float id){\n    vec3 m;\n        switch(int(id)){\n        \n            case 1:\n            //m = vec3(.0,.7,0.);break;\n            m = (texture(iChannel0,vec2(p.xy+p.z),.001).xyz+texture(iChannel1,p.xy/PI,.1).xyz)/2.\n                *vec3(.0,1.4,0.);break;\n            \n            case 2:\n            //m = vec3(.2+.4*mod(floor(p.x)+floor(p.z),2.));break;\n            m = texture(iChannel1,p.xz/PI,.1).xyz/4.\n               +texture(iChannel2,p.xz,.1).xyz/4.\n               +texture(iChannel3,p.xz/sqrt(2.),.1).xyz/2.;break;\n        }\n    return m;\n}\n\nmat3 getcam(vec3 ro,vec3 rg){\n    vec3 camf = normalize(rg-ro);\n    vec3 camr = normalize(cross(vec3(0,1,0),camf));\n    vec3 camu = cross(camf,camr);\n    return mat3(camr,camu,camf);\n}\n\nvoid mousecontrol(inout vec3 ro){\n    vec2 m = iMouse.xy/iResolution.xy;\n    pR(ro.yz,m.y*PI);\n    pR(ro.xz,m.x*TAU);\n}\n\nvec3 render(vec3 col,vec2 uv){\n    vec3 ro = vec3(3.,5.,3.);\n    mousecontrol(ro);\n    vec3 rg = vec3(0,1,0);\n    vec3 rd = getcam(ro,rg)*normalize(vec3(uv,FOV));\n    \n    vec3 co = col;\n    vec3 bg = vec3(.5,.8,.9);\n    \n    vec2 object = raymarch(ro,rd);\n    \n        if(object.x<MAX_DIST){\n            vec3 p = ro+rd*object.x;\n            co += getlight(p,rd,getmat(p,object.y));\n            \n            co  = mix(co,bg,1.-exp(-.0008*object.x*object.x));\n        }else{\n            co += bg-max(rd.y*.5,0.);\n        }\n    return co;\n}\n\nvec2 getuv(vec2 offset,vec2 fragCoord){\n    return (2.*(fragCoord.xy+offset)-iResolution.xy)/iResolution.y;\n\n}\n\nvec3 renderAAx4(vec3 col,vec2 coord){\n    vec4 e = vec4(.125,-.125,.375,-.375);\n    return vec3(render(col,getuv(e.xz,coord))+\n                render(col,getuv(e.yw,coord))+\n                render(col,getuv(e.wx,coord))+\n                render(col,getuv(e.zy,coord)))/4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 col  = vec3(0);\n    vec3 rend = renderAAx4(col,fragCoord);\n    rend      = pow(rend,vec3(.4545));\n        \n    \n    fragColor = vec4(rend,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI radians(180.)\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define sqrt2 sqrt(2.)\n\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = (dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt2/((n-1.)*2.+sqrt2);\n\t\tpR45(p);\n\t\tp.x -= sqrt2/2.*r;\n\t\tp.x += columnradius*sqrt2;\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt2/n/2.0;\n\t\tcolumnradius = r*sqrt2/((n-1.)*2.+sqrt2);\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt2/2.*r;\n\t\tp.x += -columnradius*sqrt2/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}