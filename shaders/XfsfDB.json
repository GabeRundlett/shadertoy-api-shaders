{
    "Shader": {
        "info": {
            "date": "1724450988",
            "description": "trying to create something visually interesting i guess.. not sure if i managed.. but well, some blobs were created, with psychedelic background.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfsfDB",
            "likes": 6,
            "name": "DancingBlobs",
            "published": 3,
            "tags": [
                "2d",
                "blobs"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 102
        },
        "renderpass": [
            {
                "code": "float T;\n#define PI 3.14159265358\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n//https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat rotatingBlob(in vec2 uv, float size, float offset, float phase, float rotationPhase)\n{\n    vec2 uvv3 = uv;\n    uvv3 = uvv3 * rot(phase + T * 1. + rotationPhase );\n    float xoffset1 = cos(rotationPhase + T * rotationPhase * .001 + uv.y * 10.) * .03;\n    uvv3.x += xoffset1;\n    uvv3.x += offset + ((sin(T * 1. + rotationPhase * .5) * 0.5) + 0.5) * .1;\n    return length(uvv3) - size;\n}\n\nfloat blobsDE(in vec2 uv, float k)\n{\n    \n    vec2 uvv = uv;\n    uvv.x += sin(T  * 1.1 + uv.y * 20.) * 0.02;\n    uvv.y += cos(T  * 1.1 + uv.x * 20.) * 0.02;\n    float l = length(uvv) - .1;\n    \n    float offset = 0.15;\n    vec2 uvv2 = uv;\n    uvv2 = uvv2 * rot(T * 1. + cos(T) * .8);\n    \n    float l2 = rotatingBlob(uv, 0.05, 0.04, 3.149, sin(1.0 + T * .6));\n    float l3 = rotatingBlob(uv, 0.05, 0.04, 1.0, cos(1.0 + T) * .24);\n    float l4 = rotatingBlob(uv, 0.035, 0.125, 2.5, sin(2.0 + T) * 1.);\n    float l5 = rotatingBlob(uv, 0.035, -0.235, 2.5, sin(1.4 + T) * .8);\n\n    float lm = min(l, l2);\n    lm = min(lm, l3);\n    l = smin(l, l3, k);\n    l = smin(l, l2, k);\n    l = smin(l, l4, k);\n    l = smin(l, l5, k);\n    \n    return l;\n}\n\nvec3 map(in vec2 uv, in vec2 screen)\n{\n    vec2 uuv = uv;\n    uuv.y += sin(uv.x * 50. + iTime * 2.);\n    uuv.x += cos(uv.y * 50. + iTime * 2.);\n    vec3 bottom = vec3(0.1, 0.08, 0.0 ) * 2.;\n    vec3 top = vec3(0.1, 0.001, 0.1) * 2.;\n\n    // diff between 2 blends\n    float de = blobsDE(uv, 0.001);\n    float de1 = blobsDE(uv, 0.08);\n    \n    float diff = (de - de1) * 10.01;\n    \n    // actual render\n    de = blobsDE(uv, 0.05);\n    vec3 bgCol = mix(bottom, top, screen.y);\n    vec3 col = vec3(smoothstep(0.001, 0.00, de));\n    col *= bgCol * 3.0;\n    \n    // color dodges\n    col /= mix(1.0, 1.0 - (smoothstep(-0.45, 0., de)) * length(col), .45);\n    col /= mix(1.0, 1.0 - (smoothstep(-0.02, 0.02, de)) * length(col), .8);\n    \n    col = clamp(col, 0.0, 1.0);\n    \n    // highlight the distance differences\n    col /= mix(1.0, 1.0 - smoothstep(-0.1, .5, diff), .8);\n    return col;\n}\n\nfloat rays (vec2 uv, float res, float rt)\n{\n    uv *= rot(rt);\n    vec2 duv = uv;\n    duv.x += sin(2. * iTime + length(uv) * 6.0) * length(uv) * .2;\n    duv.y += cos(2.4 * iTime + length(uv) * 5.0) * length(uv) * .2;\n    \n    float an = (PI + atan(duv.y, duv.x));\n    float ares = PI * 2.0 / res;\n    float id = floor(an / ares);\n    float scale = texture(iChannel0, vec2(id, id) * res * .035).r;\n    \n    an = mod(an, ares) / ares;\n    an = abs(sin(an * PI));\n    an *= smoothstep(0.0, .6, scale * (1.0 - length(duv)));\n    an = smoothstep(0.3, 0.9, an);\n    return an;\n}\n\nvec4 color(in vec2 uv, in vec2 screen)\n{\n    vec3 bottom = vec3(.76, .4, .7 ) * 1.;\n    vec3 top = vec3(.9, .7, 0.2) * 1.;\n    vec4 fragColor = vec4(0.0);\n    fragColor.rgb = map(uv, screen) * (.5 + sin(iTime) * .1);\n    vec3 bg = mix(bottom, top, 1.0 - screen.y) * .22;\n    \n    float mask = smoothstep(1., 0.0, length(fragColor.rgb));\n    fragColor.rgb = mix(fragColor.rgb, bg, mask);\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    \n    // bg    \n    float sh = blobsDE(uv, 1.) * 1.;    \n    float an = rays(uv, 2., iTime * .1);\n    an += rays(uv, 4., iTime * .24);\n    float an3 = rays(uv, 14., iTime * .2);\n    an += an3 * .15;\n    an *= .5;\n    an += smoothstep(0.2, 0.0, length(uv)) * 1.4;\n    an = clamp(an, 0.01, 1.);\n    \n    // color dodge    \n    fragColor /= 1.0 - smoothstep(1.4,0., sh) * (.75 + sin(iTime * 2.) * .02) * mask;\n    fragColor /= 1.3 - clamp(an * 1.4 * (.01 - sh), 0.0, 1.0);\n    sh -= an * .35;\n    fragColor.rgb = mix(fragColor.rgb, bg.rgb * 2., sh);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    T = iTime;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screen = uv;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec4 col = vec4(0.0);\n    col = color(uv, screen);\n    vec2 rd = (uv);\n    vec4 glow = vec4(0.0);\n    \n    fragColor.rgb = col.rgb;\n    // tonemap\n    fragColor = smoothstep(0., 1.2, fragColor);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}