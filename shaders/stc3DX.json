{
    "Shader": {
        "info": {
            "date": "1642002135",
            "description": "As a coder I have a fear of algebra.",
            "flags": 0,
            "hasliked": 0,
            "id": "stc3DX",
            "likes": 23,
            "name": "Les maths aiment la musique",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "waves",
                "sketch"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Les maths aiment la musique\n    01/12/22 @byt3_m3chanic\n\n             .---.                                          \n            /. ./|               .---.           .--.--.    \n         .-'-. ' |  ,--.--.    /.  ./|  ,---.   /  /    '   \n        /___/ \\: | /       \\ .-' . ' | /     \\ |  :  /`./   \n     .-'.. '   ' ..--.  .-. /___/ \\: |/    /  ||  :  ;_     \n    /___/ \\:     ' \\__\\/: . .   \\  ' .    ' / | \\  \\    `.  \n    .   \\  ' .\\    ,\" .--.; |\\   \\   '   ;   /|  `----.   \\ \n     \\   \\   ' \\ |/  /  ,.  | \\   \\  '   |  / | /  /`--'  / \n      \\   \\  |--\";  :   .'   \\ \\   \\ |   :    |'--'.     /  \n       \\   \\ |   |  ,     .-./  '---\" \\   \\  /   `--'---'   \n        '---\"     `--`---'             `----'    \n        \n   just doing some waves on a surface with a floor/hue for color\n   still playing around with the hatching / sketch look. \n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    65.\n#define MIN_DIST    .0001\n\n// random var to alter waves\nfloat u_hash = .8123;\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec3 hue(float a) { return .55+.45*cos(PI2*a*(vec3(0.196,0.925,0.208)*vec3(.99,.97,.96))); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432);  }\n// @iq sdf \nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 g_hp,s_hp;\nfloat g_hsh,s_hsh,time;\n\nvec2 map(vec3 p) {\n    p.y+=1.75;\n    vec3 pq = p;\n    vec2 res = vec2(1e5,0.);\n\n    // make waves\n    float ter = .2*sin(length((p.xz)-vec2(.5*sin(T*.12)*.76,u_hash))*3.25+T*.75); \n          ter = exp(ter);\n          ter +=.2*cos(length((p.xz)+vec2(.5*sin(T*.2)*.776,u_hash))*3.00+T*1.50);  \n    p.y= abs(p.y)-2.;\n    p.y+=2.95+ter;\n    \n    // two caps\n    float pk = cap(p+vec3(0,2.5,0),4.15,5.);\n    float pz = cap(p+vec3(0,2.5,0),4.20,5.);\n    \n    if (pk < res.x) {\n        res=vec2(pk,2.5);\n        g_hp=p;\n        g_hsh=ter;\n    }\n    \n    if (pz < res.x) {\n        res=vec2(pz,4.5);\n        g_hp=p;\n        g_hsh=1.;\n    }\n    \n    // the sphere\n    float pl = length(pq-vec3(0,2.75+.5*sin(T*.5),0))-1.5;\n    if (pl < res.x) {\n        res=vec2(pl,5.5);\n        g_hp=p;\n        g_hsh=0.;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps, float sg) {\n    hit = false; float d=0., m = 0., dist = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<1e-4) hit = true;\n        m  = t.y;  \n        d += i<32? t.x*.75:t.x*.95;\n        p = ro + rd * d;\n        if(d>75.) break;\n    } \n    return vec2(d,m);\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.1325/3.75; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, .075, 1.);\n}\n\nvec3 FC = vec3(.015);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d, in vec2 F) {\n        \n    vec3 RC=vec3(0);\n\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p,hit,158,1.);\n    d = ray.x;\n    m = ray.y;\n    s_hp=g_hp;\n    s_hsh=g_hsh;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(-18.,8,-9);\n        vec3 l = normalize(lpos);\n        \n        float diff = clamp(dot(n,l),.2,1.);\n        float ao = calcAO(p,n);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 24.);\n        \n        float shdw = 1.,t=.1;\n        for( int i =1; i<20; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<1e-3 ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<.1 || t>45. ) break;\n        }\n        if(m==2.5) shdw=(shdw>.5 && mod(F.x,3.)!=mod(F.y,3.) ) ? .8:.05;\n        diff=mix(diff,diff*shdw,.75); \n\n        vec3 h = vec3(.25);\n\n        if(m== 2.5||m==5.5) ref=vec3(.55);\n        \n        ao=smoothstep(.2,.51,ao);\n        vec3 sdif = vec3(diff+.5);\n        diff=clamp((diff+.25)*ao,0.,1.);\n        \n        if(m==3.5) {sdif*=1.15;}\n        if(m==2.5) diff *=hue(floor(s_hsh*8.)*2.).r;\n        \n        if(diff<.5&&(mod(F.x,4.)==mod(F.y,4.))) sdif=sdif*.4;\n        if(diff<.175&&(mod(1.-F.y,4.)==mod(F.x,4.))) sdif=sdif*.35;\n        if(diff<.125&&(mod(F.x,1.)==mod(F.y,2.))) sdif=sdif*.3;\n        if(diff<.100&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif=sdif*.1;\n        if(diff<.015&&(mod(F.x,1.)==mod(F.y,1.))) sdif=sdif*.4;\n        \n        if(spec>.45&&(mod(F.x,4.)==mod(F.y,4.))) sdif+=.15;\n        if(spec>.65&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif+=.15;\n\n        RC = clamp(diff*1.25,0.,1.)*sdif;\n\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n    } \n    \n    return RC;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T;\n    \n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    \n    // pixel effect\n    //float pxg = 126.;\n    //uv = floor(uv*(pxg*R.x/R.y))/(pxg*R.x/R.y);pxg*=1.5;\n    \n    // background patterns\n    vec2 ft = fract((uv*2.)*rot(.78))-.5;\n    FC.xyz=mix(FC,vec3(.04),mod(floor(ft.x),3.)==0.?1.:0.);\n \n     // ortho camera\n    float zoom = 7.;\n    vec3 ro = vec3(uv*zoom,-zoom-2.5);\n    vec3 rd = vec3(0,-.05,1.);\n\n    // cam rotations\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*1.-.5)*PI;\n    mat2 rx =rot(.35);\n    mat2 ry =rot(.78+y);\n\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    // the loop and march or march and loop\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 3;\n    for(int i = 0; i < bnc + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,bnc-i,d,F);\n        C = mix(C,RC,fill);\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n\n    // back + fog\n    C = mix(C,FC, 1.-exp(-.00005*fA*fA*fA));\n\n    // hash it up\n    float hs = hash21(uv);\n    if(fract(hs*5.)>.65) C = clamp(C-.02,vec3(0),vec3(1));\n    if(hs>.75) C = clamp(C+.015,vec3(0),vec3(1));\n\n    // gamma out\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n// end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}