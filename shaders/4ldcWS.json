{
    "Shader": {
        "info": {
            "date": "1534603027",
            "description": "GPU based, two tweet moving Turing pattern that forms in about two seconds. If you see a black screen due to the texture not loading, hit the back button.",
            "flags": 32,
            "hasliked": 0,
            "id": "4ldcWS",
            "likes": 33,
            "name": "Two Tweet Turing Texture",
            "published": 3,
            "tags": [
                "diffusion",
                "pattern",
                "minimal",
                "tweet",
                "reaction",
                "turing",
                "belousov",
                "zhabotinsky"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1722
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTwo Tweet Turing Texture\n\t------------------------\n\n    Every now and again, I'll obsess over creating something with minimal code -- \n\tI'm not as obsessed as Fabrice, but like plenty of others on here, I have that \n    tendency. Sometimes, it's just for fun, and others, to see if it can be done.\n\n\tAnyway, here's the smallest Turing pattern routine I could come up with. Taking \n    into account that no one would ever get bored enough to try this and the fact\n    that it's fewer than 250 characters, I'm willing to say it's the smallest routine\n    out there. :) I had to employ a bit of voodoo to make this work. There's some \n    esoteric theory and some of my own refinements behind it, but since it was coded \n    for novelty purposes only, I won't bore you with the details. However, I'll put \n    up a couple of examples later that will be of more practical use.\n\n\tBy the way, the pattern might start to lose some integrity and take on a diagonal \n    appearance after a while, but you get what you pay for. :D By the way, there are \n    ways to get the character count much further down, but I think it's small enough \n    in its current form. Suggestions for improvements are always welcome. :)\n\n\n    Similar examples:\n\n    // Higher quality, more sophisticated, and way more interesting in general, \n    // but also about 50 times larger. :) I deliberately didn't look at Flexi's \n    // workings until after I'd completed this, because I didn't want it to \n    // inflence my thought process. Afterward, I perused the code, and it's really \n    // clever. For anyone interested in this kind of thing -- and Turing textures of\n    // the multiscale variety, it's definitely worth looking at.\n    //\n\tSimple Turing Pattern Mix - Flexi\n\thttps://www.shadertoy.com/view/4sGGRR\n\n\t// A while back, I was obsessed with creating the most conceptually \n\t// minimalistic Voronoi pattern:\n    //\n    One Tweet Cellular Pattern - Shane\n    https://www.shadertoy.com/view/MdKXDD\n\n*/\n\nvoid mainImage( out vec4 c, in vec2 f){\n    \n    c = texelFetch(iChannel0, ivec2(f), 0).xxxx;\n    // Alternatives.\n    //c = texelFetch(iChannel0, ivec2(f), 0); // Multicolored.\n    //c = texture(iChannel0, f/iResolution.xy).xxxx;\n    //c = textureLod(iChannel0, f/iResolution.xy, 0.).xxxx;\n    //c = sqrt(smoothstep(0., .5, texelFetch(iChannel0, ivec2(f), 0).xxxx) - .5);\n    //c = sqrt(smoothstep(0., .5, textureLod(iChannel0, f/iResolution.xy, 1.).xxxx - .5));\n}\n\n/*\n// For anyone interested, here's Fabrice's even smaller 226 character solution:\n//\n// Common Tab:\n#define R    iResolution.xy \n#define t(n) texture(iChannel0, u/R, n) \n// Buffer A Tab\nvoid mainImage(out vec4 c, vec2 u){\n      u += vec2(iFrame&1);\n      c = iFrame>15 ? clamp(t(1.)*2. - t(3.), -1., 1.) : texture(iChannel1, u/R);\n}\n// Image Tab:\nvoid mainImage( out vec4 c, vec2 u) { c = t(0.).xxxx; }\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n   Slightly less code than normally required to produce the average Turing pattern. :)\n\n   If you ignore the physics, you're simply filling the canvas with random values,\n   then blurring them outwards with one filter whilst blurring them back inward with\n   another filter. After a while, an equilibrium should be reached... and that \n   concludes your diffusion tutorial. You're welcome. :D Jokes aside, if you're not\n   familiar with the process, it's interesting reading up on how the physics, math and \n   code relate.  \n   \n*/\n\n//#define t(n) textureLod(iChannel0, u, n) \n#define t(n) texture(iChannel0, u, n) \nvoid mainImage(out vec4 c, in vec2 u){\n\n    // Hardware blurs are too blockish, so the alternating \"iFrame\" shuffle is my bit \n    // of hacky Voodoo to get around that. It also doubles as an animation mechanism. :)\n    u = (u + vec2(iFrame&1))/iResolution.xy;\n    \n    // Fill the canvas with noise, then use a mixture of two hardware blur filters to \n    // emulate the diffusion process. In case it needs to be said, hand coded software \n    // blurs work way better. By the way, you're not limited to the following combination,\n    // or just two filters for that matter.\n    //\n    // This works with other textures too.\n    //c = iFrame>15 ? clamp(t(1.) + (t(1.) - t(3.))/3., -1., 1.) : texture(iChannel1, u);\n    c = iFrame>15 ? clamp(t(1.)*2. - t(3.), 0., 1.) : texture(iChannel1, u);\n    // Alternative that looks like a Belousov-Zhabotinsky reaction. \n    //c = iFrame>15 ? clamp(t(.5)*2. - t(1.).yzxw, -1., 1.) : texture(iChannel1, u);\n    \n    // More robust starting conditions -- Thanks to IQ for the tip.\n    //c = textureSize(iChannel1, 0).x<2 || iFrame<1? \n        //texture(iChannel1, u) : clamp(t(1.) + (t(1.) - t(3.))/3., 0., 1.);\n\n    // Textureless. Needs work, but still safely under two tweets.\n    //c = iFrame > 9? clamp(t(1.) + (t(1.) - t(3.))/3., 0., 1.) : vec4(sin(length(u - .5)*1e7));\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}