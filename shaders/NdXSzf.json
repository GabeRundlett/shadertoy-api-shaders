{
    "Shader": {
        "info": {
            "date": "1619095764",
            "description": "test of cloud rendering, wait a bit for the image to converge",
            "flags": 32,
            "hasliked": 0,
            "id": "NdXSzf",
            "likes": 13,
            "name": "cloud_render2",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 488
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    // do image post-prossesing\n    col = 1.0-exp(-1.3*col); \n    col = pow(col, vec3(1.3));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//the sky\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = vec3(0.3, 0.7, 1.0)*0.7;\n    \n    vec3 sunDir = normalize(vec3(1.0, 0.3, -0.5));\n    //vec3 sunDir = normalize(vec3(0.0, 0.0, 0.5));\n    //vec3 sunDir = normalize(vec3(-0.5, -1.0, 1.8));\n    \n    col += 55.0*vec3(0.9764, 0.8058, 0.441)*pow(0.5 + 0.5*dot(sunDir, rayDir), 80.0);\n    col += vec3(0.8)*pow(0.5 + 0.5*dot(sunDir, rayDir), 2.0);\n    col *= vec3(1.1, 0.5, 0.4); //make the sky red (could be changed by the day)\n    col *= 1.5;\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "//where all the stuff append\n#define PI 3.14159265359\n#define MAXSTEP 100\n#define STEPSIZE 0.04   //smaller for more detail\n#define MAXDEPTH 5\n#define FOGDENSITY 200.8\n#define aperture 0.01   //the bigger the faster the image blur\n#define focalLength 1.0\n\nconst vec3 camPos = vec3(0.5, 1.0, -1.8)*0.8;\nconst vec3 target = vec3(0.0, 0.0, 0.0);\n\n\nstruct Mat{vec3 c, e;}; //color, emission\n\nMat cloud = Mat(vec3(0.99, 0.99, 0.99), vec3(0.0));\n\n//box where the cloud is rendered\nconst vec3 up = vec3(30.0, 0.5, 30.0);\nconst vec3 down = vec3(-30.0, -0.5, -30.0);\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x) + uint(iTime*6000000.0);\n}\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\nfloat noise(vec3 pos){\n    return texture(iChannel2, pos).x;\n}\n\nfloat fbm( vec3 pos )\n{\n    float f = 0.0;\n    float p = 0.3;\n    int o = 8; //octave\n    for(int i = 0; i < o; i++){ \n        f += pow(1.0-p, float(i))*p*noise(pos); pos*=2.01;\n    }\n    f /= 1.0-pow(1.0-p, float(o));\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nvec2 box(vec3 ro, vec3 rd){\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (down.x - ro.x)*dirfrac.x;\n        float t2 = (up.x - ro.x)*dirfrac.x;\n        float t3 = (down.y - ro.y)*dirfrac.y;\n        float t4 = (up.y - ro.y)*dirfrac.y;\n        float t5 = (down.z - ro.z)*dirfrac.z;\n        float t6 = (up.z - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z);\n    return v;\n}\n\nfloat smax(vec3 v){\n    float k = 0.1;\n    return (v.x*exp(k*v.x) + v.y*exp(k*v.y) + v.y*exp(k*v.y))/(exp(k*v.x) + exp(k*v.y) + exp(k*v.y));\n}\n\nfloat density(vec3 p){\n    vec3 normPos = (p-down)/(up-down)*2.0-1.0;\n    normPos = abs(normPos);\n    float mask = smax(normPos);\n    mask = pow(mask, 4.0);\n    \n    float noise = fbm(p*0.05+0.35);\n    \n    float tres = 0.5+mask;\n    if (noise < tres)return STEPSIZE*0.1;\n    return FOGDENSITY*STEPSIZE;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out Mat obj){\n    obj = cloud;\n    vec2 bounds = box(ro, rd);\n    \n    if (bounds.y < 0.0){ obj = Mat(vec3(0.0), texture(iChannel1, rd).xyz);return -1.0;}\n    \n    \n    float t = max(bounds.x, 0.0) + random()*STEPSIZE;\n    float maxDist = bounds.y;\n    \n    for(int i = 0; i < MAXSTEP; i++){\n        if(t > maxDist){ obj = Mat(vec3(0.0), texture(iChannel1, rd).xyz);return -1.0;}\n        vec3 p = ro + t * rd;\n        t += STEPSIZE * max(1.0,distance(p, camPos)*0.5);\n        \n        float prob = density(p);\n        if (random()<prob)return t;\n        \n    }\n    return -1.0;\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd, vec2 uv){\n\tvec3 col = vec3(0.0);\n\tvec3 mask = vec3(1.0);\n    float k = 1.0;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tMat obj;\n        float t = intersect(ro, rd, obj);\n        \n\t\tro = ro + t * rd;\n        if(depth == MAXDEPTH - 2){\n            rd = normalize(vec3(1.0, 0.3, -0.5)); // not realisticly accurate but help the image converge faster\n            k = 0.1;\n        }else{\n            rd = newDir(rd);\n        }\n        \n\t\tcol += mask * obj.e * k;\n\t\tmask *= obj.c;\n        \n        if(t<=0.0)break; // dont intersect anything\n        if (dot(mask, mask)<0.000001)break; // have absorbed to much light that the ray is useless\n\t\t\n\t}\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initRandomGenerator(fragCoord);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec2 off = vec2(random(),random()) / iResolution.y;\n    vec3 rd = normalize(dir0 + right*(uv.x+off.x) + up*(uv.y+off.y));\n    \n    // for focal length\n    float t = dot(dir0*focalLength, dir0)/dot(rd, dir0); //distance to the focal plane\n    vec3 focalPoint = camPos + rd*t;\n    \n    float teta = random()*10.0*PI;\n    vec2 off2 = vec2(cos(teta), sin(teta))*sqrt(random())*aperture;\n    vec3 camPos2 = camPos + right*off2.x + up*off2.y;\n    vec3 rd2 = normalize(focalPoint-camPos2);\n    \n    vec3 col = march(camPos2, rd2, uv);\n    \n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float weight = 1.0/float(iFrame + 1);\n    col = col * weight + last * (1.0-weight);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}