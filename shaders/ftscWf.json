{
    "Shader": {
        "info": {
            "date": "1648821853",
            "description": "A disastrous distance estimate slathered with fudge.",
            "flags": 8,
            "hasliked": 0,
            "id": "ftscWf",
            "likes": 20,
            "name": "Spring FauxBoxBulbs",
            "published": 3,
            "tags": [
                "boxbulbs"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "//Spring FauxBoxBulbs by eiffie\n\n//#define EUCLIDEAN  \n//#define TAXICAB  \n#define CHEBYSHEV  \n  \n#ifdef EUCLIDEAN\n #define Pi 3.14159\n #define Cos cos\n #define Atan atan\n #define Length length\n#endif\n#ifdef TAXICAB\n #define Pi (2.0*sqrt(2.0))\n #define Cos t_cos\n #define Atan t_atan\n #define Length t_length\n#endif\n#ifdef CHEBYSHEV\n #define Pi 4.0\n #define Cos c_cos\n #define Atan c_atan\n #define Length c_length\n#endif\nfloat t_cos(float a){return 2.0*abs(mod(a,2.0*Pi)-Pi)/Pi-1.0;}\nfloat c_cos(float a){return clamp(abs(mod(a,2.0*Pi)-Pi)-Pi/2.0,-1.0,1.0);}\nfloat t_atan(float y, float x){//atan is always complicated by the quadrant (probably a simpler way to write these)  \n float a=x-y,b=x+y,res;\n if(b==0.0)res=(a>0.0?7.0:3.0);\n float d=a/b;\n if(abs(d)<1.0){\n  if(b>0.0)res=1.0-d;\n  else res=5.0-d;\n }else {\n  d=b/a;\n  if(a>0.0)res=7.0+d;\n  else res=3.0+d;\n }\n return res*0.25*Pi;\n}\nfloat c_atan(float y, float x){  \n if(y==0.0)return (x>0.0?0.0:4.0);  \n float a=x/y;  \n if(abs(a)<1.0){  \n  if(y>0.0)return 2.0-a;  \n  else return 6.0-a;  \n }else {  \n  a=y/x;  \n  if(x>0.0)return mod(a,8.0);  \n  else return 4.0+a;  \n }  \n}  \nfloat t_length(vec2 p){return abs(p.x)+abs(p.y);}//==(x^1+y^1)^(1/1) -abs(x & y) is assumed for each  \nfloat t_length(vec3 p){return abs(p.x)+abs(p.y)+abs(p.z);}//==(x^1+y^1)^(1/1) -abs(x & y) is assumed for each  \nfloat c_length(vec2 p){return max(abs(p.x),abs(p.y));}//==(x^inf+y^inf)^(1/inf)  \nfloat c_length(vec3 p){return max(abs(p.x),max(abs(p.y),abs(p.z)));}//==(x^inf+y^inf)^(1/inf)  \n\n\nuniform float u[32];\nfloat Sin(float a){return Cos(a-Pi*.5);}\nvec3 cmap(float a){return fract(vec3(a*13.23,a*1.89,a*3.66));}\nvec3 mcol=vec3(0.0);\nfloat DE(vec3 p){\n  float d=p.z,pr=mod(floor(p.x/3.)*floor(p.y/3.),6.),m=3.+2.*pr,s=m,a,b;\n  p.z+=Cos(pr+iTime+length(p.xy)*.1);p.xy=mod(p.xy,3.0)-1.5;\n  for(int i=0;i<3;i++){\n    a=Atan(p.y,p.x)*s;b=Atan(Length(p.xy),p.z)*s+iTime*1.7+pr;\n    p+=vec3(Cos(b)*vec2(Cos(a),Sin(a)),Sin(b))/s;\n    s*=m;\n  }\n  float r=(Length(p)-(pr==0.?.8:1.))/3.;\n  if(mcol.x>0.){if(d<r)mcol+=cmap(pr);else mcol+=abs(cmap(pr+1.)+.5*Cos((p.y+p.x+p.z)*50.))*.75+.25;}\n  return min(d,r);\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=max(0.1,rd.z)+max(0.1,dot(rd,L));\n  return vec3(d);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,px=1.0/iResolution.x;\n  for(int i=0;i<64;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>100.0 || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.25,0.5));\n  vec3 col=sky(rd,L);\n  if(d<px*t*5.0){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);if(N!=N)N=-rd;if(dot(rd,N)>0.)N=-N;\n    vec3 scol=mcol*0.25;\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    float shad=ShadAO(so,L);\n    col=mix((scol*dif+shad*fr*sky(reflect(rd,N),L))*shad,col,t*t/10000.);\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0,0,1)));\n  return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*iResolution.xy)/iResolution.x;\n  randomize(U);\n  float t=iTime*.05+5.;\n  vec3 ro=vec3(t_cos(t)*100.+30.,t_cos(t*.3-2.)*150.+74.,10.+7.*t_cos(t));\n  vec3 rd=lookat(vec3(30.,70.,-200.+10.*ro.z)-ro)*normalize(vec3(uv.xy,1.0));\n  O=vec4(scene(ro,rd),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define bps 5.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n=0.0; \n  else if(n<2.0)n=2.0; \n  else if(n<3.0)n=5.0; \n  else if(n<4.0)n=-1.0; \n  else if(n<5.0)n=5.0; \n  else if(n<6.0)n=4.0; \n  else if(n<7.0)n=3.0; \n  else n=0.0;\n  return vec2(n,r); \n}\n\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.);\n //if((n2==1.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//dorky\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.5,2.5,0.1,1.505,0.001);//silly fm synth instruments \n //instr sitar=instr(30.0,1.,4.0,0.0,0.2525,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n //instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+84.0,time,t0,epiano)*n0.y*.5;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+75.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+72.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+60.0,time,t2,epiano)*n2.y;\n       //a+=I(n2.x+53.0,time,t2,bass)*n2.y*.5; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/64.0,-1.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}