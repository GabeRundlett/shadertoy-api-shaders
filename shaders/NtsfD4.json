{
    "Shader": {
        "info": {
            "date": "1650908523",
            "description": "For panorama depiction you sometime want 3D view but with mountains still looking quite like they are from the floor.\nleft: classical rotated camera    right: with tilted terrain\nmouse.y controls camera angle.    mouse.x select render mode (red separator)",
            "flags": 0,
            "hasliked": 0,
            "id": "NtsfD4",
            "likes": 35,
            "name": "oblique relief (terrain tilted z",
            "published": 3,
            "tags": [
                "raymarching",
                "panorama",
                "mountain",
                "short",
                "terrainrendering",
                "obliquerelief"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 683
        },
        "renderpass": [
            {
                "code": "// ref: http://www.reliefshading.com/design/plan-oblique-relief/\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))          // rotation 2D\n#define T(U,l)    textureLod( iChannel0, U/S +.2, l ).r // terrain\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t=9., S=4.;                                   // texture scaling\n    vec2  R  = iResolution.xy,\n          U  = ( 2.*u - R )/R.y,                        // normalized screen coords\n          M  = iMouse.z > 0. ? ( 2.*iMouse.xy - R*vec2(1,2) ) / R.y \n                             : vec2(cos(iTime),-.14-.7+.7*sin(0.74*iTime)); // auto-demo\n    vec3  D  = normalize(vec3(U, -3.5)),                // ray direction\n          p0 = vec3(0,0,7), p=p0, q;                    // marching point along ray \n\n    for (int i=0; i<200 && t > .01; i++) {              // --- ray marching loop\n        q = p;\n        if (U.x < M.x) \n              q.yz *=  rot(-M.y);                       // left: classical rotation\n        else  q.y += q.z * -M.y;                        // right: terrain tilting\n     //  q.yz *= rot(.14);                              // rotation\n        t = q.y - .2 *S*T(q.xz,0.) +.3,                 // terrain pseudo-SDF\n        p += .3*t*D;                                    // step forward = dist to obj          \n   }\n   t = length(p-p0)-2.; O = vec4( exp(-t/10.) );        // depth-shading\n   t = T(q.xz,0.);                                      // final look:\n   O *= ( 1. + 100.*(t-T(q.xz,1.)) ) * (.2+t);          // add details + ambient occlusion\n   \n  if ( abs(U.x-M.x)*R.y < 1.5 ) O = vec4(1,0,0,1);      // red separator\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}