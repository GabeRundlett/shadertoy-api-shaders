{
    "Shader": {
        "info": {
            "date": "1599160231",
            "description": "Press SPACE to start or restart.\n\nResources used to make this game:\nhttps://www.shadertoy.com/view/MddGzf",
            "flags": 48,
            "hasliked": 0,
            "id": "tsBcDK",
            "likes": 5,
            "name": "Nibbles.frag",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "snake",
                "nibbles"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "// -1: game over\n//  0: game running\n//  1: game reseted (space pressed)\n//  2: game not started\nconst ivec2 txGameState  = ivec2(2, 0);\nconst ivec2 txApplePos   = ivec2(0, 1);\nconst ivec2 txHeadPos    = ivec2(5, 0);\nconst ivec2 txSize       = ivec2(0, 0);\nconst ivec2 txScore      = ivec2(4, 2);\n\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nint PrintInt( in vec2 uv, in int value ) {\n    const int maxDigits = 3;\n    if(abs(uv.y-0.5) < 0.5)\n    {\n        int iu = int(floor(uv.x));\n        if( iu >= 0 && iu < maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x); // (uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0, 5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n// Finds the distance of P from the line A to B.\nfloat sdSegment(in vec2 p, vec2 a, vec2 b) {\n    \n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n    \n    // Project ap onto ab.\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0); \n    \n    // Finds length of vec from p to the projection of p onto ab.\n\treturn length(ap - ab*h); \n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)  { \n       \n    vec2 uv = (2.*fragCoord-iResolution.xy ) / iResolution.y ;\n    vec3 col = vec3(0.);\n \n    // Board\n    {\n    \tcol = 0.9*vec3(0.4,0.6,0.8)*(1.0-0.4*length(uv)); \n    }\n    \n    // Snake\n    {\n    \tint size = int(texelFetch(iChannel0, txSize, 0).x); \n        int i = 0;\n        while (i < size-1) {\n            vec4 start = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);        \n            vec4 end = texelFetch(iChannel0, txHeadPos + ivec2(i+1, 0), 0);        \n            \n        \tfor (int j = i; j < size; j++) {\n    \t\t\t            \n            \tvec4 nextPos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);                \t\n                if (int(nextPos.z) == 1) {\n                    break;\n                } else {\n                \tend = nextPos;\n                    i = j;\n                }\n            }\n                \n            float d = sdSegment(uv, start.xy, end.xy);    \n            \n            vec3 bcol = vec3(1.0,0.6,0.2);\n    \t\tfloat f = smoothstep(0.02, 0.003, d);\n            col = mix(col, bcol, f); \n            \n            i++;    \t\t\n        }\n    }\n    \n    // Borders\n    {\n        float d = sdSegment(uv, vec2(-1.5, 0.66), vec2(1.5, 0.66));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+0.9);\n        \n        d = sdSegment(uv, vec2(-1.5, -0.75), vec2(1.5, -0.75));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+0.9);\n        \n        d = sdSegment(uv, vec2(-1.5, 0.65), vec2(-1.5, -0.742));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+.9);\n        \n        d = sdSegment(uv, vec2(1.5, 0.65), vec2(1.5, -0.742));\n        col += vec3(0.4, 0.5, 0.5)*exp(-220.0*d+.9);\n    }\n    \n    // Apple\n    if (int(texelFetch(iChannel0, txGameState, 0).x) != 2) {\n        \n    \tvec2 applePos = texelFetch(iChannel0, txApplePos, 0).xy;\n    \tfloat d = sdCircle(uv-applePos, 0.01);      \n        vec3 acol = vec3(1.0, 0.3, 0.2);\n        col = mix(col, acol, smoothstep(0.015, 0.001, d));        \n    }\n    \n    // Score\n    {\n        int score = int(texelFetch(iChannel0, txScore, 0).x); \n        float f = float(PrintInt( (uv-vec2(-1.5, 0.75))*8.0, score));\n        col = mix(col, vec3(1.0,1.0,1.0), f);\n    }\n    \n    // GAME OVER\n    if (int(texelFetch(iChannel0, txGameState, 0).x) == -1) {\n    \tcol = mix(col, vec3(1.0,0.5,0.2), (0.5+0.5*sin(10.0*iTime)));\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int LEFT = 37;\nconst int UP = 38;\nconst int RIGHT = 39;\nconst int DOWN = 40;\nconst int SPACE = 32;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n// -1: game over\n//  0: game running\n//  1: game reseted (space pressed)\n//  2: game not started\nconst ivec2 txGameState  = ivec2(2, 0);\nconst ivec2 txApplePos   = ivec2(0, 1);\nconst ivec2 txSize       = ivec2(0, 0);\nconst ivec2 txDirection  = ivec2(1, 0);\nconst ivec2 txGrow       = ivec2(4, 1);\nconst ivec2 txScore      = ivec2(4, 2);\nconst ivec2 txHeadPos    = ivec2(5, 0);\n\nconst float gameSpeed = 0.32;\n\n// Writes a value into the given buffer if the current pixel is \n// located at the storage address.\nvoid write(inout vec4 buffer, in vec4 val, in ivec2 storageAddr, \n           in vec2 fragCoord) {\n    \n    if (storageAddr == ivec2(fragCoord)) {\n    \tbuffer = val;\n    }\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st, vec2(1.0,113.0)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy ) / iResolution.y;\n    vec4 buff = texture(iChannel0, uv);   \n \n    int dir = RIGHT;\n    int size = int(texelFetch(iChannel0, txSize, 0).x);\n    int score = int(texelFetch(iChannel0, txScore, 0).x); \n    int gameState = int(texelFetch(iChannel0, txGameState, 0).x);\n    vec2 applePos = texelFetch(iChannel0, txApplePos, 0).xy;\n    vec4 headPos = texelFetch(iChannel0, txHeadPos, 0);\n   \n    for (int i = 0; i < size; i++) {\n    \tvec4 oldPos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);        \t \n        write(buff, oldPos, txHeadPos + ivec2(i, 0), fragCoord);\n    }\n    \n    // Start the game once SPACE pressed.\n    if (iFrame == 0) {\n    \tgameState = 2;\n    }\n    \n    if (keyClick(SPACE)) {\n    \tgameState = 1;\n    }\n    \n    // ============= GAME RUNNING =============\n    if (gameState == 0) {\n     \n        // Update the head position.\n        float dis = 0.05*gameSpeed*(iTimeDelta*60.0);\t\n\n        int oldDir = int(texelFetch(iChannel0, txDirection, 0).r); \n\n        if (keyClick(RIGHT) && oldDir != LEFT) {\n            dir = RIGHT;\n        } else if (keyClick(UP) && oldDir != DOWN) {\n            dir = UP;\n        } else if (keyClick(DOWN) && oldDir != UP) {\n            dir = DOWN;\n        } else if (keyClick(LEFT) && oldDir != RIGHT) {\n            dir = LEFT;\n        } else if (keyClick(RIGHT) && oldDir != LEFT) {\n            dir = RIGHT;\n        } else {\n            dir = oldDir;\n        }\n\n            \n        if (dir == UP) {\n            headPos.xy += vec2(0., dis);\n        } else if (dir == DOWN) {\n            headPos.xy += vec2(0., -dis);\n        } else if (dir == LEFT) {\n            headPos.xy += vec2(-dis, 0.0);\n        } else {\n            headPos.xy += vec2(dis, 0.0);\n        }\n\n        // Direction changed mark it.\n        if (dir != oldDir) {\n            headPos.z = 1.0;\n        }\n       \n        // If ate an apple, increase the length. \n        int grow = int(texelFetch(iChannel0, txGrow, 0).x);\n        if (grow != 0) {\n            size++;\n            grow--;\n        }\n        \n        float d = distance(headPos.xy, applePos);\n        if (d < 0.025) {\n            vec2 seed1 = texelFetch(iChannel0, txHeadPos + ivec2(size/2, 0), 0).xy;\n            vec2 seed2 = seed1.yx;\n                \n            float r1 = (random(seed1)-0.5) * 2.2;\n            float r2 = clamp((random(seed2)-0.5) * 2.0, -0.62, 0.62);\n            \n            applePos = vec2(r1, r2);\n            grow+=5;\n            score++;                                   \n        }\n        \n        write(buff, vec4(grow, 0., 0., 0.), txGrow, fragCoord);\n        \n        // Shift each element to make the snake move.\n        for (int i = 1; i < size; i++) {\n            vec4 oldPos = texelFetch(iChannel0, txHeadPos + ivec2(i-1, 0), 0);        \t \n            write(buff, oldPos, txHeadPos + ivec2(i, 0), fragCoord);\n        }\n        \n        // Test if hit a wall.\n        if (headPos.x > 1.48\n            || headPos.x < -1.48 \n            || headPos.y > 0.637\n            || headPos.y < -0.737) {\n            gameState = -1;   \t\n        }    \n\n        // Test if hit the own body.\n        for (int i = 1; i < size; i++) {\n            vec4 pos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);\n            float d = distance(headPos, pos);\n            if (d < 0.007) {\n                gameState = -1;\n            }\n        }\n    }\n    \n    // ============ RESET ========== \n    if (gameState == 1) { \n   \n        size = 10;\n        score = 0;\n        applePos = vec2(0.3, 0.1);\n               \n        dir = RIGHT;   \n        float dis = 0.05*gameSpeed*(iTimeDelta*60.0);\n        float startPosX = 0.5-dis;\n\n        headPos = vec4(startPosX, 0.4, 0., 0.);\n        \n    \tfor (int i = 1; i < size; i++) {\n    \t\tvec4 pos = texelFetch(iChannel0, txHeadPos + ivec2(i, 0), 0);        \t\n            \n            // z: 0 = no change of direction\n            pos = vec4(startPosX, 0.4, 0., 0.);\n        \n            write(buff, pos, txHeadPos + ivec2(i, 0), fragCoord);\n            startPosX -= dis;\n        }        \n        \n        gameState = 0;   \t\n    }\n       \n    write(buff, vec4(size, 0., 0., 0.), txSize, fragCoord);\n    write(buff, vec4(score, 0., 0., 0.), txScore, fragCoord);\n    write(buff, headPos, txHeadPos, fragCoord);\n    write(buff, vec4(applePos, 0., 0.), txApplePos, fragCoord);\n    write(buff, vec4(dir, 0, 0, 0), txDirection, fragCoord);    \n    write(buff, vec4(gameState, 0, 0, 0), txGameState, fragCoord);\n        \n    fragColor = buff;  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}