{
    "Shader": {
        "info": {
            "date": "1648496969",
            "description": "wait for the bass",
            "flags": 8,
            "hasliked": 0,
            "id": "stsyzX",
            "likes": 20,
            "name": "Day 830",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 603
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 829\" by jeyko. https://shadertoy.com/view/slscz2\n// 2022-03-28 08:05:06\n\n// Fork of \"Day 828\" by jeyko. https://shadertoy.com/view/7lfyRj\n// 2022-03-27 08:18:54\n\n// so\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat message(vec2 uv) { // to alter in the icon\n    \n    //uv.y += sin(acos(-1.)*iTime/beat + sin(acos(-1.)*iTime/beat*2.)*float(iTime > msr*2.));\n    \n    uv-=vec2(1.,10.); \n    uv -= vec2(16.,1.5);\n    //uv *= 0.5;\n    //uv.xy *= rot(sin(acos(-1.)*iTime/beat*0.5)*0.1*mod(iTime/beat,2.));\n    \n    uv += cyclicNoise(vec3(uv*0.2,iTime + sin(iTime)));\n        \n    uv += vec2(16.,1.5);\n    if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\t//tGlobal = iTime*2.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n    /*\n    if(iTime > msr*6.)\n        fragColor = 0.5 + 0.5*sin(fragColor + iTime);\n    */\n}   ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat gt;\n\n\nFN(kick,\n    vec4 chord = getChord(t);\n    \n    float repd = bar*2.;\n    float reps = 16.;\n    \n    Time T = rep(t,bar*2.,reps);\n    \n    bool kick = getPatt(T,kickPatt) > 0.5;\n    bool kickNext = getPattOffs(T,kickPatt,reps,1.) == 0.5;\n    \n    if(!kick)\n        return vec2(0); \n    \n    //T.te = t;\n    //float env = exp(-T.te*14.);\n    \n    //float freq = note(chord[0],2.)*(1.  );\n    float freq = 40.;\n    float parm = freq*T.tt*tau;\n    \n    if(kick)\n        parm -= exp(-T.te*30.)*64.;\n    \n    \n    vec2 n = lpnoise(T.tt,10. + freq*4.*tau);\n    \n    vec2 osc = sin(parm + 0.*vec2(sin(0.1 + t*2.),sin(0.6 + t*2.5)) + sin(1200.*T.te)*exp(-T.te*40.)*0.*float(kick)\n    );\n    \n    \n    osc = ringmod(osc,(4200. + sin(T.idl)*2000.)*t*tau,1.,0.4*exp(-T.te*120.));\n    \n    s += osc + n*0.01;\n    \n    if(kick) s *= smoothstep(0.,0.001,T.te);\n    \n    s = smoothify(s,1.,0.2);\n    s = smoothify(s,1.,0.5);\n    s = smoothify(s,1.5,0.1);\n    \n    if(kickNext)\n        s *= 1.-smoothstep(0.9,0.99,T.te/repd*16.);\n    s *= exp(-T.te*5.);\n    \n    //s = smoothify(s*1.,0.2);\n    //s = mix(s,smoothify(s*3.,1.),0.3 * exp(-T.te*45.));\n    \n)\n\nFN(snare,\n    \n    Time T;\n\n    T = rep(t + bar*0.25,bar,1.);\n    //T.te = t;\n    float env = exp(-T.te*40.);\n    float freq = 450. ;\n    \n    float osc = sin(tau*freq*T.te + ((freq - 1.4*exp(-T.te*10.))*t*0.1 )  + 0.4*sin(T.te*800.)*exp(-T.te*4.));\n    \n    float oscb = sin(2.5*tau*freq*T.te + sin(4000.*T.te )*exp(-T.te*4.)*0.4 )*exp(-T.te*14.);\n    \n    float oscc = sin((93000.*exp(-T.te*20.)+ 11000.)*T.te + sin(17000.*T.te )*exp(-T.te*40.)*41.*0. )*exp(-T.te*30.);\n    \n    s += osc*env + oscb*0.5 + oscc*0.2;\n    \n    s = ringmod(s,11400.*T.te,1.4,0.2*exp(-T.te*14.));\n    \n    //s += lpnoise(T.te, 300.*(0.04 + exp(-T.te*39.4)))*0.4*exp(-T.te*1.)*pow(env,0.5);\n    s += lpnoise(T.te, 4.*21300.)*0.4*exp(-T.te*13.)*pow(env,0.2);\n    \n    s += lpnoise(T.te, 21300.)*0.2*exp(-T.te*1.)*pow(env,0.5);\n    \n    //s = mix(s,s*sin(t*(15700. )),0.7*exp(-T.te*115.));\n    s = smoothify(s,1.,0.1);\n    s = powify(s,0.9);\n)\n\nFN(hats,\n    Time T = rep(t,bar,16.);\n    \n    vec2 r = hash21(T.idl);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*12.));\n    float freq = 400. + 0. * exp(-T.te*104.) ;\n    vec2 n = lpnoise(T.te, 1140.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    //vec2 n = cyclicNoise(vec3(T.te*11711.))*vec2(3.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        5.*sin(T.te*50000.)*exp(-T.te*10.) + \n        4.*sin(T.te*20000.*0.75 - n*1.)*exp(-T.te*10.) + \n        n * 14.\n    );\n    \n    s += osc*env*0.4*smoothstep(0.,0.1,r.x);\n    \n    //s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n)\n\nFN(rides ,{\n    Time T = rep(t,bar,8.);\n    \n    vec2 r = hash21(T.idl);\n    r = vec2(1);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 4400. + 1. * exp(-T.te*134.) + 000. * float(chop(t,bar/4.,16.) >= 8.);\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*12000.)*exp(-T.te*10.) + \n        2.*sin(T.te*12000. - n*0.)*exp(-T.te*1.) + \n        n * (1.-exp(-T.te*10.))*60.\n    );\n    \n    s += osc*env*0.6*smoothstep(0.,0.4,r.x);\n    \n    //s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n\n})\n\n\n\nFN(chord,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    for(float i = 0.; i < 4.; i++){\n        \n        float iters = 65.;\n        float range = 17.;\n        for(float k = 1.; k < iters; k++){\n            float freq = note(chord[int(i)],3. + 1.*float(i == 1.));\n            if(freq < 200.)\n                freq *= 2.;\n                \n            float att = 1.;\n            \n            float localIter = ceil(k/iters*range);\n            att *= mix(1.,0.,k/iters);\n            att = pow(att,2.);\n            //att /= pow(2.*k-1.,2.);\n                        \n            vec2 r = lpnoise(k*111.5 + i*112.525, 1.1);\n            \n            if(localIter > 1.){\n                if(r.x < 0.1 )\n                    freq = freq*(2.*localIter - 1.);\n                else if(r.x < 0.8 )\n                    freq = freq*localIter;\n                else\n                    freq = freq*pow(2.,localIter);\n            }\n            \n            //freq = freq*pow(2.,k);\n            //if(k >= 10.)\n            //    freq *=2.;\n           // if(mod(k,4.) == 4.)\n           //     freq *= 2.;\n            \n            vec2 n = lpnoise(t*.0*0. + k*1.5 + i*2.525, 1.1);\n            n = vec2(sin(n.x*20. + t*.5),sin(n.t*20. + t*.5));\n            \n            float polarity = (mod(k + i,2.)*2. - 1.);\n            vec2 osc = sin( \n                (freq+ freq*n*0.0004*1.+ .1*sin(k + t*0.1 *sin(k)))*t*tau )*polarity; \n            \n            //osc = tri(t,freq + n.x*0.1*1.,3.);\n            s += osc/7./iters*att * (1. + 0.5*cos(localIter*150.+ t*4.));\n        }\n        \n    }\n    s *= 2.;\n})\n\n\nFN(chordSupersaw,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    \n    for(float i = 0.; i < 4.; i++){\n        float freq = note(chord[int(i)],3.);\n        //float md = sin(freq*t)*exp(-T.te*14.);\n        //float osc = sin(freq*t + md*4.); \n        //s += osc/4.;\n        \n        float iters = 3.;\n    \n        for(float i = 1.; i < iters; i++){\n            float idx = tau*freq*t + sin(i*10.3 + t*3.)*2.;\n                \n            vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.4;\n            vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n            osc = mix(osc,vec2(sin(idx)),0.);\n            \n\n            //osc = smoothify(osc,vec2);\n            s += osc/iters*1.;\n        }\n    }\n    \n    s *= smoothstep(0.,0.01,T.te);\n    s *= smoothstep(bar/8.,bar/8. - 0.05,T.te);\n\n})\n\n\nFN(dubstep,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],1.);\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    float iters = 5.;\n    \n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.8 + t*3.)*0.3;\n        \n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.45;\n        vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n        osc = mix(osc,vec2(sin(idx)),0.5); \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*2.;\n    }\n    \n    //s = mix(s,clampifyb(s*1.,1.),0.2);\n    //s *= 2.;\n    //s = mix(s,smoothify(s*1.,2.),1. );\n})\n\nconst int mldCnt = 11;\nvec2[] mldArr = vec2[mldCnt](\n    vec2(0,0),\n    vec2(6,3),\n    vec2(4,10),\n    vec2(9,7),\n    vec2(15,8),\n    vec2(0,12),\n    vec2(16,15),\n    vec2(20,14 + 12),\n    vec2(25,22),\n    vec2(30,20),\n    vec2(34,19)\n);\n/*\nstruct Melody{\n    int mldCnt;\n    vec2[] mld;\n}*/\n\n\n\n#define createMelody(name,cnt, len) \\\nvec3[] name = vec3[cnt+1]( \\\n    vec3(cnt,len,0), \n\n#define getMelodyAt(name,at) name[int(at) + 1]\n#define getMelodyNoteCnt(name) name[0].x\n#define getMelodyLen(name) name[0].y\n\n#define playMelody(mld,cb) for(float i=0.;i<getMelodyNoteCnt(mld);i++){ vec3 nt = getMelodyAt(mld,i); if(nt.x < 0.){continue;} cb;} \n\ncreateMelody(bassMelody,9, 32.)\n    vec3(-1,0,1), \n    vec3(3,3,1), \n    vec3(5,-2,1),\n    vec3(8,-5-4,1), \n    vec3(14,-5-4,1), \n    vec3(16,-5-4,1),\n    vec3(19,-5-4,0.5),\n    vec3(-1),\n    vec3(-1)\n);\n\n\nFN(bass,{\n    float period = bar*4.;\n    float reps = getMelodyLen(bassMelody);\n    Time T = rep(t,period,reps);\n    \n    playMelody(bassMelody, {\n        float freq = note(nt.y,2.);\n        float tn = mod(t - nt.x*period/reps,period);\n        \n        vec2 no = lpnoise(t*0. + i,1.);\n        vec2 nob = lpnoise(t + i,111.);\n        //nob += lpnoise(t + i,1111.)*0.2;\n        //nob += lpnoise(t + i,161.)*0.4;\n        //nob += lpnoise(t + i,11111.)*0.5*(1.-exp(-tn*4.));\n        nob *= 0.;\n        float namp = 0.6;\n        \n        loop(14.,k,{\n            float f = 51.*(k*1.5 + 1.);\n            nob += lpnoise(t + i + k,f)*namp;\n            namp /= 1.1;\n        })\n        vec2 osc = sin(tn*tau*freq + no*.0);\n        //vec2 osc = tri(tn,freq,115.);\n        //osc = ringmod(osc,nob,1.,0.5*(1.-exp(-tn*4.)));\n        \n        //osc = ringmod(osc,freq*2.5*t*tau,4.,0.1*exp(-tn));\n        osc = 0.8*ringmod(osc,freq*4.*t*tau,2.,0.1*exp(-tn));\n        osc = ringmod(osc,freq*9.*t*tau,2.,0.1*exp(-tn));\n        \n        float env = exp(-tn*2.*nt.z);\n        \n        vec2 n = lpnoise(T.tt,10. + freq*16.*tau);\n        osc += n*0.02;\n        s += osc*env*0.5;\n    })\n    \n    s = smoothify(s, 4., 0.1);\n    //s = smoothify(s, 1., 0.5);\n\n\n/*\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],2. + 0.*float(mod(T.idl,3.) == 0.));\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    \n    float f = 0.05 + 0.75 * exp(-T.te*(10. + sin(t*tau/beat*0.25)* 25.));// * sin(t*freq*0.5);\n\n    f = 0.1;\n    float wiggle = 0.05;\n    float q = 0.;\n    \n    \n    s += squelchyBass(t, freq, f, q, wiggle, 10.);\n  */  \n    //s *= 2.;\n    //s = mix(s,smoothify(s*1.,1.),0.2 );\n    //s = mix(s,clampify(s*1.,1.),1.);\n\n})\n\n\n\nFN(melody,{\n\n    float period = bar*4.;\n    \n    float reps = 64.;\n    \n    Time T = rep(t,period,64.);\n    \n    for(float i = 0.; i < float(mldCnt); i++){\n        vec2 nt = mldArr[int(i)];\n        if(nt.x < 0.)\n            continue;\n        float freq = note(nt.y,3.) + sin(i*4.+t)*.1;\n        float tn = mod(t - nt.x*period/reps,period);\n        \n        vec2 no = lpnoise(t + i,1.);\n        vec2 nob = vec2(0);\n        \n        float namp = 0.6;\n        \n        loop(14.,k,{\n            float f = 51.*(k*1.5 + 1.);\n            nob += lpnoise(t + i + k,f)*namp;\n            namp /= 1.1;\n        })\n        //nob += lpnoise(t + i,11111.)*0.5*(1.-exp(-tn*4.));\n        \n        \n        vec2 osc = sin(tn*tau*freq + no*1.);\n        //vec2 osc = tri(tn,freq,115.);\n        \n        //osc = ringmod(osc,nob,1.,0.9*(1. - smoothstep(0.,1.,tn*5.)));\n        osc = ringmod(osc,nob,1.,0.2*(1. - smoothstep(0.,1.,tn*1.)));\n        osc = ringmod(osc,nob,1.,0.2*(1. - exp(-tn*4.)));\n        \n        loopOne(5.,k,{\n            // osc = ringmod(osc,freq*1.*t*tau,1.,0.5*exp(-tn));\n            osc = ringmod(osc,freq*k*t*tau,1.,0.5*exp(-tn)*taper(k/5.,0.3,0.2));\n            \n        })\n        \n        float env = exp(-tn*1.)*smoothstep(0.,0.001,tn);\n        \n        s += osc*env*0.1;\n    }\n    \n})\n\n\nFN(arp,{\n    Time T = rep(t,bar,16.);\n    \n    vec4 chord = chords[0 + int(T.idg)%4];\n    float freq = note(chord[int(T.idl)%4],3. + 1.*float(mod(T.idl,5.) == 0.)+ 1.*float(mod(T.idl,3.) == 0.));\n    freq *= 0.5;\n    float iters = 1.;\n    for(float i = 0.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*1.;\n        \n        idx += 1.*sin(freq*2.*t*tau)*exp(-T.te*4.);\n        //idx += sin(freq*2.*t*tau)*exp(-T.te*4.);\n        \n        vec2 osc = vec2(sin(idx));\n        \n        osc += sin(freq*4.*t*tau)*exp(-T.te*4.)*0.5;\n        osc += sin(freq*8./1.33*t*tau)*exp(-T.te*4.)*0.25;\n        osc += sin(freq*32.*0.75*t*tau)*0.2;\n        \n        osc = mix(osc,osc*sin(freq*t*tau*0.5)*2.,0.7);\n        //asdg\n        //vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        //vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.3;\n    }\n})\n\n\nFN(cowbell,{\n    Time T = rep(t,bar*4.,1.);\n    \n    vec4 chord = chords[0 + int(T.idg)%4];\n    float freq = note(0.,1. + 1.*float(mod(T.idl,5.) == 0.)+ 1.*float(mod(T.idl,3.) == 0.));\n    freq *= 0.25;\n    float iters = 1.;\n    loop(iters,i,{\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*1.;\n        \n        idx += 1.*sin(freq*2.*t*tau)*exp(-T.te*4.);\n        //idx += sin(freq*2.*t*tau)*exp(-T.te*4.);\n        \n        vec2 osc = vec2(sin(idx));\n        \n        osc += sin(freq*4.*t*tau)*exp(-T.te*4.)*0.5;\n        osc += sin(freq*8./1.33*t*tau)*exp(-T.te*4.)*0.25;\n        osc += sin(freq*32.*0.75*t*tau)*0.2;\n        \n        osc = mix(osc,osc*sin(freq*t*tau*2.)*1.,0.7);\n        //osc = ringmod(osc,freq*0.5*t*tau,1.,0.4);\n        \n        //asdg\n        //vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        //vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.3;\n    })\n    /*\n    float iters = 3.;\n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*4.;\n        //asdg\n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.7;\n    }\n    */\n})\n\n\n \nFN(perc ,{\n    Time T = rep(t,bar,1.);\n    \n    vec2 r = hash21(T.idl);\n    r = vec2(1);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 1400. + 1. * exp(-T.te*134.) + 000. * float(chop(t,bar/4.,16.) >= 8.);\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*12000.)*exp(-T.te*10.) + \n        2.*sin(T.te*12000. - n*0.)*exp(-T.te*1.) + \n        n * (1.-exp(-T.te*10.))*10.\n    );\n    \n    osc = ringmod(osc,tau*(freq/4. - mod(T.idl*2. + T.idg,8.)*freq/1.)*t,1.,1.*exp(-T.te*1.));\n    \n    s += osc*env*0.6*smoothstep(0.,0.4,r.x);\n    \n    //s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n})\n\nvec2 mainSound( int samp, float t ){    \n    \n    gt = t = t + OFFS;\n    \n    vec2 s = vec2(0);\n\n\n    //s = mod();\n    //return s;\n    //chorus(chord,4.,ch,0.5,0.2);\n    \n    //return s;\n\n\n    //s += sin(t*540.);\n    \n    // --- DRUMS --- //\n    vec2 k = kick(t);\n    delay(kick, 4., bar/8., k, 1., 1., 1., 0.4);\n    reverb(kick,6.,.02,k,0.05, 0.001,0.01);\n    k *= 0.3;\n    \n\n    \n    float sidechain = 1.;\n    {\n        Time T = rep(t,bar*2.,16.);\n        bool kick = getPatt(T,kickPatt) > 0.5;\n        \n        \n        sidechain -= float(kick)\n            * pow(exp(-mod(t,bar*2./16.)*40.),.5)\n            * (1.-exp(-mod(t,bar*2./16.)*140.))\n        ;\n        //sidechain -= float(kick)*pow(exp(-mod(t,bar*2./16.)*40.),.5);\n    }\n    \n    \n    \n    vec2 per = perc(t)*0.3;\n    delay(perc, 6., bar/8., per, 1., 0., 2., 0.9);\n\n    vec2 sn = snare(t)*0.45;\n    if(t > msr*8.)\n        delay(snare, 8., bar/3./2. - abssin(t*tau/beat*0.25)*.05, sn, 1., 1., 0.01, 0.2);\n    \n    reverb(snare,10.,.3,sn,0.1, 0.1,2.);\n    chorus(snare,14.,sn,0.4,0.1 + 0.02*sin(t));\n    \n    //reverb(snare,450.,.9,sn,0.5, 0.04,1.);\n    sn *= pow(sidechain,0.5);\n    \n    s += k*smoothstep(0.,75.,t/msr);\n    s += per*smoothstep(0.,75.,t/msr);\n    s += sn*float(t - msr*4. > 0.);\n    \n    \n    \n    s = clampify(s,0.5);\n    s = smoothify(s,2.5,0.1);\n    \n    vec2 drums = s;\n    \n    s *= 0.;\n    \n    \n    //s = smoothify(s,1.,0.5);\n    //s = smoothify(s,1.5,0.1);\n    //sn *= 1.5;\n    \n    \n    //vec2 h = hats(t)*0.4;\n    //reverb(hats,543.,.89,h,0.3, 0.2,1.);\n    //s += h*pow(sidechain,0.2)*0.6;\n    \n    vec2 cb = cowbell(t);\n    //reverb(cowbell,143.,.9,cb,0.1, 0.,1.);\n    \n    vec2 rd = rides(t)*0.6;\n    //reverb(rides,130.,.2,rd,0.4, 0.1,1.);\n    \n    //s += k;\n    //s += sn;\n\n    //s += h*sidechain;\n    //s += rd*mix(sidechain,1.,0.3)*0.8;\n\n    \n    \n    //s = mix(s,smoothify(s*3.,1.),0.1 );\n    //s = mix(s,smoothify(s*110.,1.),0.01 );\n    \n    //vec2 ml = melody(t)*0.6*mix(1.,sidechain,0.2);\n    //s += ml*0.2*sidechain;\n    \n    // --- MELODY --- //\n    //s *= 0.;\n    \n    //vec2 ch = chord(t)*0.6*sidechain;\n    //reverb(chord,50.,1.3,ch,.1, 0.1,1.);\n    //s = ch;\n    //s += ch*sidechain;\n    \n    vec2 mldy = melody(t);\n    mldy*= 0.8;\n    \n    \n    /*\n    s *= 0.15;\n    vec2 chss = chordSupersaw(t)*0.3;\n    //chorus(chordSupersaw,4.,chss,0.5*smoothstep(0.,1.,t/msr),0.2);\n    //chss *= 0.5;\n    */\n    \n    /*\n    if(!(t < msr*3. || t > msr*7.)){\n        ml *= 0.;\n    } \n    float en = smoothstep(0.,1.,(t - msr*8.)/msr);\n    reverb(melody,40.,.2,ml,0.5 + float(t > msr*4.)*0.2*(1. - en) - float(t > msr*4.)*0.2);\n    ml = ml * smoothstep(0.,50.,t/msr) * (1.-float(t > msr*4.)*pow(1.-en,4.));\n    \n    if(t < msr*12.)\n        s += ml;\n    */\n    \n    \n    //chorus(melody,2.,ml,0.5,0.2);\n    //s += ml*pow(sidechain,0.5)*1.;\n    \n    \n    \n    //s += ch*pow(sidechain,0.1);\n    \n    //reverb(chordSupersaw,10.,1.,chss,0.8);\n    \n    /*\n    if( chop(t,bar,4.) > 1. ){\n        if( (t > msr*6. && t < msr*8.) || (t > msr*3. && t < msr*3.75 ))\n            s += ch*sidechain*1.;\n    } else {\n        s += chss*pow(sidechain,2.)*1.;\n    \n    }\n    */\n    \n    \n    \n    // --- BASS --- //\n    vec2 bs = bass(t)*0.8;\n    \n    if(t > msr*8.){\n        s += cb;\n    \n    }\n    if(t > msr*12.){\n        s += bs*pow(sidechain,2.01);\n    }\n\n    //return bs;\n    \n    // --- MIX --- //\n    s += drums;\n    \n    s += mldy*mix(sidechain,1.,0.4);\n    if(t < msr*4.){\n\n    } else \n    \n    \n    s = mix(s,clampifyb(s,0.6)*1.,0.4);\n    \n\n    \n    float eee = smoothstep(0.,msr,t - msr*3.);\n    \n    \n        \n        \n    s *= 1.;\n    \n    // -- Reinhard\n    //s = s/(1. + abs(s)*4.);\n    \n    // -- Exp\n    // s = (1.-exp(-abs(s)*1.))*sign(s);\n    \n    // -- Aces\n    //s.x = ACESFilm(vec3(abs(s.x))).x*sign(s.x);\n    //s.y = ACESFilm(vec3(abs(s.y))).x*sign(s.y);\n    \n    // -- Clip\n    float clip = 1.;\n    s = clamp(s,-clip,clip)/clip;\n    \n    \n    \n    \n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define bpm (160.)\n#define OFFS msr*0.\n\n\n#define PI acos(-1.)\n#define pi PI\n#define tau 2.*pi\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nfloat[] kickPatt = float[16](1.,0.,0.,1.,0.,1.,0.,0.,1.,0.,0.,1.,0.,0.,0.,1.);\n\n#define getPatt(T,patt) patt[int(T.idl)]\n#define getPattOffs(T,patt,cnt,offs) patt[int(T.idl + offs)%int(cnt)]\n\n#define between(t,mn,mx) (t > mn && t < mx)\n\n#define loop(its,k,cb) for(float k = 0.; k < its; k++){cb;}\n#define loopOne(its,k,cb) for(float k = 1.; k < its; k++){cb;}\n\n#define taper(v, f, wiggle) smoothstep(0. + f + wiggle,0. + f - wiggle,v)\n\n#define abssin(a) (0.5 + sin(a)*0.5)\n\n// -------------------------------------------------------- //\n// ------------------------- FX ------------------------ //\n// -------------------------------------------------------- //\n\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/(amt))*(amt)\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n//#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)/amt\n#define clampifyb(s, amt) clamp(s,-amt,amt)/amt\n#define smoothify(s, sc, amt) sign(s)*mix(abs(s),smoothstep(0.,1.,abs(s)*sc), amt)\n#define ringmod(s,freq,sc,amt) mix(s,s*sin(freq)*sc,amt)\n#define powify(s, amt) sign(s)*pow(abs(s),vec2(amt))\n\n\n#define delay(fn, iters, len, varname, amt, chorsc, diffsc, dec) \\\n{                                       \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 1.; i < iters; i++){   \\\n        vec2 nois =  lpnoise(i+1100.,111551.); \\\n        vec2 noisb =  lpnoise(i+1100. + t*0.1,11.); \\\n        float amp = 1. - pow(i/iters,dec); \\\n        float idx = t - (i)*len; \\\n        float choramt = 0.04 * chorsc;    \\\n        float diffamt = 0.01  * diffsc;     \\\n        float diffiters = 40.;   \\\n        for(float k = 1.; k < diffiters; k++){   \\\n            vec2 noisb =  lpnoise(i+1100. + t*.41 + k,11.); \\\n            vec2 f = vec2(                       \\\n                fn(idx - abs(nois.x)*choramt - noisb.x*diffamt).x, \\\n                fn(idx - abs(nois.y)*choramt - noisb.y*diffamt).y  \\\n            );                                   \\\n            f = ringmod(f,noisb*1.,1.,0.5);     \\\n            res += f*amp/diffiters;                        \\\n        } \\\n    }\\\n    varname = varname + res*amt; \\\n}\n\n\n#define reverb(fn, iters, len, varname, amt, att, dec) \\\n{                                       \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        float nois =  pow(i/iters,1.)*lpnoise(i/iters+1100.,111551.).x; \\\n        float env = smoothstep(0.,att,i/iters)*smoothstep(1.,0.99 - dec,i/iters);\\\n        res += fn(t - (i/iters)*len - abs(nois)*1.*len*env)*env/iters; \\\n    }\\\n    varname = varname + res/mix(1.,0.5,amt)*10.*amt; \\\n}\n\n#define chorus(fn, iters, varname, amt, len) \\\n{ \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        res += fn(t - sin(i/iters*pi*4.*t*0.001*len)*1.)/iters; \\\n    }\\\n    varname = mix(varname,res,amt); \\\n}\n#define phaser(fn, iters, varname, amt, len) \\\n{ \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        res += fn(t - sin(i/iters*pi*4.*t*0.001*len)*1.)/iters; \\\n    }\\\n    varname = mix(varname,res,amt); \\\n}\n    \n// -------------------------------------------------------- //\n// ------------------------- SYNTH ------------------------ //\n// -------------------------------------------------------- //\n\nvec2 tri(float t, float f, float iters){\n    vec2 s = vec2(0);\n    iters += 1.;\n    for(float k = 1.; k < ceil(iters); k++){\n        float freq = tau*f;\n\n        float osc = sin(freq*(2.*k - 1.)*t) * \n            (-8./(pi*pi)) * \n            (mod(k,2.)*2. - 1.)/pow(2.*k-1.,2.);\n        \n        float fr = fract(iters);\n        if(k == ceil(iters) - 1. && fr != 0.){\n            s += osc*fr;\n        }else{\n            s += osc;\n        }\n    }\n\n    return s;\n}\n\nvec2 squelchyBass(float t, float freq, float f, float q, float wiggle, float iters){\n    vec2 s = vec2(0);\n    for(float i = 1.; i < iters; i++){\n        float k = i < 10. ? i : i*2.;\n        //float k = i;\n        float osc = sin(tau*freq*t*k)*(mod(k,2.)*2. - 1.)/k; \n        if(i == 1.)\n            osc *= 5.;\n        //float att = smoothstep(0. + f + wiggle,0. + f - wiggle,i/iters);\n        float att = taper(i/iters,f,wiggle);\n        att *= 1. + smoothstep(wiggle,0.,abs(i/iters - f))*q;\n        s += osc*att;\n    }\n    \n    return s;\n}\n\n\n\n// -------------------------------------------------------- //\n// ------------------------- SEQ  ------------------------- //\n// -------------------------------------------------------- //\n\n\n\n#define tick (60./bpm)\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n#define chop(t,bt,reps) mod(floor(t/(bt/reps)), reps)\n\n\n#define FN(name, code) vec2 name(float t) { \\\n    vec2 s = vec2(0); \\\n    code \\\n    return s; \\\n}\n\n\n\nstruct Time {\n    float tt;\n    float te;\n    float idl;\n    float idg;\n};\n\nTime rep(float t, float period, float reps){\n    Time data;\n    float per = period/reps;\n    data.tt = mod(t,period);\n    data.te = mod(t,per);\n    data.idl = mod(floor(t/per),reps);\n    data.idg = floor(t/period);\n        \n    return data;\n}\n\n\n\n\nfloat note(float note, float octave){ \n    note -= 7.;\n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.);\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmin73 = vec4(0.,7.,10.,3.);\nconst vec4 cmin11 = vec4(0.,10.,14.,17.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmaj9 - 4.,\n    cmin73 - 7.,\n    cmin11 - 5.,\n    cmin7,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n\nvec4 getChord(float t){\n    return chords[ int(t / bar) % 4];\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = floor(t);\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = hash21(tn / fq*2000.);\n    vec2 n1 = hash21((tn + 1.0) / fq*2000.);\n\n    return mix(n0, n1, ft)*2. - 1.;\n}\n\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    #ifdef TURBULENT\n    return 1. - abs(noise)*0.5;\n    #else\n    return (noise*0.25 + 0.5);\n    #endif\n}\n\n\nFN(kick808,\n    vec4 chord = getChord(t);\n    \n    float repd = bar*2.;\n    float reps = 16.;\n    \n    Time T = rep(t,bar*2.,reps);\n    \n    bool kick = getPatt(T,kickPatt) > 0.5;\n    bool kickNext = getPattOffs(T,kickPatt,reps,1.) == 0.5;\n    \n    \n    //T.te = t;\n    //float env = exp(-T.te*14.);\n    \n    float freq = note(chord[0],2.)*(1.  );\n    \n    float parm = freq*T.tt*tau;\n    if(kick)\n        parm -= exp(-T.te*30.)*64.;\n    \n    \n    vec2 n = lpnoise(T.tt,10. + freq*4.*tau);\n    \n    vec2 osc = sin(parm + 0.*vec2(sin(0.1 + t*2.),sin(0.6 + t*2.5)) + sin(1200.*T.te)*exp(-T.te*40.)*0.*float(kick)\n    );\n    \n    s += osc + n*0.01;\n    \n    if(kick) s *= smoothstep(0.,0.01,T.te);\n    \n    s = smoothify(s,114.,0.2);\n    s = smoothify(s,114.,0.2);\n    \n    if(kickNext)\n        s *= 1.-smoothstep(0.9,0.99,T.te/repd*16.);\n    \n    \n    //s = smoothify(s*1.,0.2);\n    //s = mix(s,smoothify(s*3.,1.),0.3 * exp(-T.te*45.));\n    \n)\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}