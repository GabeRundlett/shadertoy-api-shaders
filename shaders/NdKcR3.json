{
    "Shader": {
        "info": {
            "date": "1655292568",
            "description": "Family trip",
            "flags": 0,
            "hasliked": 0,
            "id": "NdKcR3",
            "likes": 16,
            "name": "Walkers",
            "published": 3,
            "tags": [
                "gait",
                "walk",
                "quadruped"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "// \"Walkers\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 11 in \"Walking\" series\n    \"Octopod\"                     (4tjSDc)\n    \"Spider Ascent\"               (4sd3WX)\n    \"Moebius Strip\"               (lddSW2)\n    \"Moebius Strip 2\"             (MscXWX)\n    \"Controllable Hexapod\"        (4ljfDK)\n    \"Visible Hexapod\"             (Mdtyzj)\n    \"Moebius, Menger, Spiders\"    (wsXyzM)\n    \"Helical Ramps with Spiders\"  (3sscWf)\n    \"Controllable Hexapod 2\"      (3tKBzw)\n    \"Arachnogenesis\"              (Ndc3RH)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_WLK 3\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd;\nint idObj;\nconst int idLeg = 1, idAx = 2, idPlat = 3, idTur = 4, idBar = 5;\nbool isSh;\nconst float pi = 3.1415927;\n\nstruct Gird {\n  float wid, thk, crv, hol, lFac;\n};\nGird g;\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n};\n\nstruct Walker {\n  Leg leg[4];\n  vec3 wPos;\n  vec2 csTur;\n  float szFac;\n};\nWalker wlk[N_WLK];\n\nfloat hPlat, lLeg, bLen, bWid;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GirdDf (vec3 p)\n{\n  return max (length (max (vec2 (length (vec2 (p.x, abs (p.z) - min (abs (p.z),\n     (g.lFac - 1.) * g.wid))), abs (p.y)) - vec2 (g.wid, g.thk), 0.)) - g.crv, g.hol -\n     length (vec2 (p.x, 2. * g.wid * fract (p.z / (2. * g.wid) + fract (g.lFac / 2.)) - 0.25)));\n}\n\nvoid SetWlkConf ()\n{\n  float sDir, tc, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh;\n  wlk[0].szFac = 1.2;\n  wlk[1].szFac = 0.82;\n  wlk[2].szFac = 0.51;\n  lLeg = 9.;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.6;\n  limEx = 0.995;\n  fUp = 1.;\n  g.wid = 0.25;\n  g.hol = (2./3.) * g.wid;\n  g.crv = 0.01;\n  hPlat = 4. * limEx * (lLeg - 1.) * g.wid * cos (atan (limT));\n  for (int j = 0; j < N_WLK; j ++) {\n    tc = tCur * spd / (wlk[j].szFac * hPlat * limT * 2. / 3.);\n    for (int k = 0; k < 4; k ++) {\n      t = mod (tc + float (k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.) *\n         sign (0.5 - t) * sDir);\n      fh = hPlat;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      fh *= 0.5 / cos (a1);\n      a2 = - ((k == 1 || k == 3) ? -1. : 1.) * acos (0.5 * fh / ((lLeg - 1.) * g.wid));\n      wlk[j].leg[k].cs1 = sin (-0.5 * pi + a1 + a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs2 = sin (-2. * a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs3 = sin (0.5 * pi - a1 + a2 + vec2 (0.5 * pi, 0.));\n    }\n    wlk[j].csTur = sin (0.6 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.2 * tCur / wlk[j].szFac, 1.)) - 1.) - pi + vec2 (0.5 * pi, 0.));\n    wlk[j].wPos = wPos - vec3 (3.5 * float (2 * j - N_WLK + 1), 0., 0.);\n  }\n  bWid = 1.6;\n  bLen = 3.;\n}\n\nfloat WlkDf (vec3 p, float dMin, Walker wk)\n{\n  vec3 pp, q, qq;\n  float d, lGird, qy;\n  p.y -= hPlat;\n  q = p;\n  q.x = abs (q.x) - bWid;\n  q.y -= g.wid;\n  g.lFac = 13.;\n  g.thk = 0.05;\n  q = q.yxz;\n  d = GirdDf (q);\n  DMINQ (idLeg);\n  q = p;\n  q.y -= g.wid;\n  g.lFac = 7.;\n  g.thk = bWid - 0.05;\n  d = GirdDf (q.yxz);\n  DMINQ (idPlat);\n  g.thk = 0.05;\n  q.z = abs (q.z) - 1.;\n  d = PrCylDf (q.zyx, g.hol, bWid + 2. * g.thk);\n  DMINQ (idAx);\n  q = p;\n  q.y -= g.wid + 0.8;\n  d = PrRoundCylDf (q.zxy, 0.7, 0.1, 0.5);\n  DMINQ (idTur);\n  q = p;\n  q.xz = Rot2Cs (q.xz, wk.csTur);\n  q.yz -= vec2 (g.wid + 0.9, -0.7);\n  d = PrCylDf (q, 0.25, 0.7);\n  DMINQ (idBar);\n  g.thk = 0.05;\n  pp = p;\n  for (int k = 0; k < 4; k ++) {\n    p = pp;\n    p.xz += vec2 (bWid * ((k == 0 || k == 1) ? -1. : 1.), bLen * ((k == 1 || k == 3) ? -1. : 1.));\n    p.y -= g.wid;\n    g.lFac = lLeg;\n    lGird = (lLeg - 1.) * g.wid;\n    q = p.yxz;\n    q.xz = Rot2Cs (q.xz, wk.leg[k].cs1);\n    q.z -= lGird;\n    qy = q.y;\n    q.y = abs (q.y) - 3. * g.thk;\n    d = GirdDf (q);\n    DMINQ (idLeg);\n    q.y = qy;\n    d = PrCylDf (vec3 (q.x, abs (q.z) - lGird, q.y), g.hol, 5. * g.thk);\n    DMINQ (idAx);\n    q.z -= lGird;\n    q.xz = Rot2Cs (q.xz, wk.leg[k].cs2);\n    q.z -= lGird;\n    d = GirdDf (q);\n    DMINQ (idLeg);\n    q.z -= lGird;\n    q.xz = Rot2Cs (q.xz, wk.leg[k].cs3);\n    g.lFac = 4.;\n    lGird = (g.lFac - 1.) * g.wid;\n    q.z -= lGird - 2. * g.wid;\n    qy = q.y;\n    q.y = abs (q.y) - 3. * g.thk;\n    d = GirdDf (q);\n    DMINQ (idLeg);\n    q.y = qy;\n    q.z -= g.wid;\n    d = PrCylDf (vec3 (q.xy, abs (q.z) - 2. * g.wid).xzy, g.hol, 5. * g.thk);\n    DMINQ (idAx);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    q = p - wlk[j].wPos;\n    d = (isSh) ? 0. : wlk[j].szFac * PrRoundBoxDf (q / wlk[j].szFac - vec3 (0., 4.5, 0.),\n       vec3 (2.5, 4.5, 8.) - 0.1, 0.1);\n    if (d < 0.3) d = wlk[j].szFac * WlkDf (q / wlk[j].szFac, dMin / wlk[j].szFac, wlk[j]);\n    dMin = min (d, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.2 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh, nDotL;\n  SetWlkConf ();\n  isSh = false;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n    if (idObj == idLeg) {\n      if (abs (qHit.y) > 0.045) col4 = mix (col4, vec4 (0.2, 0.5, 0.8, 0.2),\n         step (0.4, Fbm2 (16. * qHit.xz)));\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == idPlat) {\n      col4 *= 0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.05, fract (4. * qHit.x));\n    } else if (idObj == idTur) {\n      col4 *= 0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.05, fract (4. * qHit.y));\n    } else if (idObj == idBar) {\n      col4 *= 0.2 + 0.8 * step (0.17, length (qHit.xy));\n    }\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = 0.6 * mix (vec4 (0.8, 0.6, 0.4, 0.), vec4 (0.9, 1., 0.5, 0.),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz)));\n    vn = GrndNf (ro);\n    vn = VaryNf (ro, vn, 1. - smoothstep (0.3, 0.5, dstGrnd / dstFar));\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  }\n  if (rd.y < 0. && dstObj >= dstFar) col = mix (col, vec3 (0.3, 0.4, 0.5),\n     pow (1. + rd.y, 16.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 3.;\n  wPos = vec3 (0., 0.01, spd * tCur);\n  az = 0.7 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n  }\n  el = clamp (el, -0.35 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos + vuMat * vec3 (0., 3.5, -45.);\n  zmFac = 4.5;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}