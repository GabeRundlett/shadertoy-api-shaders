{
    "Shader": {
        "info": {
            "date": "1454522377",
            "description": "not-handwritten digit classifier using a classic feed-forward neural network with back-propagation and stochastic gradient descent learning",
            "flags": 32,
            "hasliked": 0,
            "id": "MdV3Wh",
            "likes": 34,
            "name": "digit classifier",
            "published": 3,
            "tags": [
                "pattern",
                "neural",
                "neuronal",
                "networks",
                "recognition",
                "perceptron",
                "backpropagation"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 2303
        },
        "renderpass": [
            {
                "code": "/* Neural Net Digit classifier on Shadertoy\n\n   (c) 0x7e0, Stefan Berke\n\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Trained to output the correct class for each of 10 digit images\n\n   No hidden layer, simply\n   16x16 input -> 10 output\n   2560 weights, no bias\n\n   Left image shows current training, \n\t with desired (top) and actual (bottom) net output\n   \n   Right image is a test,\n     with the network output (bottom) \n     and indicator of the cell with the highest output \n\n   Restart to learn from scratch\n   \n   *Now FIXED* thanks to eiffie\n*/\n\n\n\n\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(0.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat expectedOutputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat outputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[1].xy;\n    return texture(iChannel1, p).x;\n}\n\nfloat inputState2(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(16.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat outputState2(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[3].xy;\n    return texture(iChannel3, p).x;\n}\n\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[2].xy; \n    return (texture(iChannel2, p).x - .5) * 4.;\n}\n\n\nvec3 classifier(in vec2 uv)\n{\n    uv /= 10.;\n    \n    vec3 col = vec3(0.);\n    if (uv.x >= 0. && uv.y >= 0. && uv.x < 16. && uv.y < 18.)\n    {    \n        float v = 0.2 + 0.8 * inputState(ivec2(uv));\n\t\tcol = vec3(v);\n    \n    \tif (uv.y >= 16. && uv.x <= 10.)\n    \t{\n        \tfloat s = outputState(int(uv));\n        \tcol = vec3(max(0., s), 0., max(0.,-s));\n    \t}\n    \tif (uv.y >= 17. && uv.x <= 10.)\n    \t{\n        \tfloat s = expectedOutputState(int(uv));\n        \tcol = vec3(max(0., s), 0., max(0.,-s));\n    \t}\n    \n    }\n    return col;\n}\n\nvec3 testImage(in vec2 uv)\n{\n    uv /= 10.;\n    \n    vec3 col = vec3(0.);\n    \n    if (uv.x >= 0. && uv.y >= 0. && uv.x < 16. && uv.y < 18.)\n    {    \n    \tfloat v = 0.2 + 0.8 * inputState2(ivec2(uv));\n\t\tcol = vec3(v);\n    \n    \t// find output cell with highest output\n    \tfloat ma = 0.;\n    \tint outc = 0;\n    \tfor (int i=0; i<10; ++i)\n    \t{\n        \tfloat s = outputState2(i);\n        \tif (s > ma)\n        \t{\n            \tma = s;\n            \toutc = i;\n        \t}\n    \t}\n\n    \t// draw output state\n    \tif (uv.y >= 16. && uv.x <= 10.)\n    \t{\n        \tfloat s = outputState2(int(uv));\n        \tcol = vec3(max(0., s), 0., max(0.,-s));\n    \t}\n    \n    \t// draw highest state\n    \tif (uv.y >= 17. && uv.x <= 10.)\n        \tcol = vec3(outc == int(uv.x) ? 1. : 0.);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 col = classifier(fragCoord.xy - 25.);\n\tcol = max(col, testImage(fragCoord.xy - vec2(300., 25.)));\n    \n    // render weight matrix\n    {\n        int inCell = int(fragCoord.x/2. - 10.);\n        int outCell = int(fragCoord.y/2. - 130.);\n        if (inCell >= 0 && inCell < 256 && outCell >= 0 && outCell < 10)\n        {\n            float w = 3.*weight(inCell, outCell);\n    \t\tcol = vec3(max(0., w), 0., max(0.,-w));\n        }\n    }\n    \n    fragColor = vec4(col, 1.);\n    \n\t//fragColor = vec4(texture(iChannel0, uv/10.).xyz, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \n// NETWORK INPUT\n//\n// renders a 16x16 random digit at 0,1\n// and a 10x1 expected network output at 0,0 (the class of the digit)\n// additionally renders a digit at 16,1 for testing the network\n\n\n// enable this to train and test on randomly morphed/displaced images\n//#define MORPH\n\n\n// ------------- digits ----------------\n// code by eiffie https://www.shadertoy.com/view/Mdl3Wj\n\nvoid Char(int i, vec2 p, inout float d){\n  const float w=0.1,h=0.3,w2=0.2,h2=0.4;\n  if(i>127){i-=128;d=min(d,max(abs(p.x),abs(p.y)-h));}\n  if(i>63){i-=64;d=min(d,max(abs(p.x-w2),abs(p.y-w2)-w));}\n  if(i>31){i-=32;d=min(d,max(abs(p.x-w2),abs(p.y+w2)-w));}\n  if(i>15){i-=16;d=min(d,max(abs(p.x+w2),abs(p.y-w2)-w));}\n  if(i>7){i-=8;d=min(d,max(abs(p.x+w2),abs(p.y+w2)-w));}\n  if(i>3){i-=4;d=min(d,max(abs(p.x)-w,abs(p.y-h2)));}\n  if(i>1){i-=2;d=min(d,max(abs(p.x)-w,abs(p.y)));}\n  if(i>0)d=min(d,max(abs(p.x)-w,abs(p.y+h2)));\n}\nint Digi(int i){//converts digits to char codes\n  if(i==0)return 125;if(i==1)return 128;if(i==2)return 79;if(i==3)return 103;\n  if(i==4)return 114;if(i==5)return 55;if(i==6)return 63;if(i==7)return 100;\n  if(i==8)return 127;return 118;\n}\n\nvec3 printDigi(int di, vec2 uv)\n{\n    int c = Digi(di);\n    float d = 1.;\n    Char(c, uv, d);\n\tvec3 color=mix(vec3(0.3,0.8,0.5),vec3(0.0),smoothstep(0.0,0.1,d));\n  \treturn mix(vec3(1.),color,smoothstep(0.0,0.18,d));\n}\n\n// not used, here for completeness\nvec3 PrintVal(float n, vec2 uv)\n{\n  uv *= 10.;\n  float d=1.0;\n  if(n!=n){//error\n    uv.x-=2.8;\n    Char(31,uv,d);uv.x-=0.6;\n    Char(10,uv,d);uv.x-=0.6;\n    Char(10,uv,d);uv.x-=0.6;\n    Char(43,uv,d);uv.x-=0.6;\n    Char(10,uv,d);\n  }else{\n    if(n<0.0){n=-n;Char(2,uv+vec2(0.6,0.0),d);}//negative sign\n    float c=floor(max(log(n)/log(10.0),0.0));\n    d=min(d,length(uv+vec2(-0.6*c-0.3,0.55)));//decimal place\n    if(c>0.0)n/=pow(10.0,c);\n    for(int i=0;i<6;i++){\n      c=floor(n);\n      Char(Digi(int(c)),uv,d);\n      uv.x-=0.6;\n      n=(n-c)*10.0;\n    }\n  }\n  vec3 color=mix(vec3(0.3,0.8,0.5),vec3(0.0),smoothstep(0.0,0.2,d));\n  return mix(vec3(1.),color,smoothstep(0.0,0.08,d));\n}\n// ----------------------------------------\n\n\n// hash by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\n\n\nvec3 digitRect(in vec2 uv, in int digit)\n{\n    uv = ((uv / 16.) * 2. - 1.02) * 0.6;\n\treturn printDigi(digit, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= 32. || fragCoord.y >= 17.)\n        discard;\n    \n    vec2 offs = vec2(0.);\n    \n    // random training digit\n    int digit = int(hash(float(iFrame)*1.11)*9.+.5);\n#ifdef MORPH \n    offs = 2.*vec2(hash(iTime*1.3), hash(iTime*1.5));\n    offs = hash(iTime) * vec2(sin(fragCoord.y+offs.x), sin(fragCoord.x+offs.y));\n#endif\n    vec3 col = digitRect(fragCoord - vec2(0., 1.) + offs, digit);\n    // expected network output\n    if (fragCoord.y < 1.)\n    {\n        col = digit == int(fragCoord.x) ? vec3(.7) : vec3(0.);\n    }\n    \n    // a test digit\n#ifndef MORPH\n    digit = int(mod(iTime, 10.));\n#else\n    digit = int(mod(iTime/2., 10.));\n    offs = (.5 - .5 * cos(iTime*3.14159265)) \n        \t* vec2(sin(fragCoord.y + iTime), sin(fragCoord.x + iTime * .91));\n#endif\n\tcol = max(col, digitRect(fragCoord - vec2(16., 1.) + offs, digit));\n\n\tfragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// FORWARD PROPAGATION\n//\n// takes a 16x16 input (chan0) and a 256x10 weight matrix (chan1)\n// and renders a 10x1 output\n//\n// uses the training image as input\n\n// http://www.musicdsp.org/showone.php?id=238\nfloat Tanh(in float x) { return clamp(x * ( 27. + x * x ) / ( 27. + 9. * x * x ), -1., 1.); }\n\n// activation function\nfloat activation(in float x) { return Tanh(x); }\n\n\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(0.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[2].xy; \n    return (texture(iChannel2, p).x - .5) * 4.;\n}\n\nfloat cellState(in int outCell)\n{\n    float sum = 0.;\n\tfor (int j=0; j<16; ++j)    \n    for (int i=0; i<16; ++i)    \n    {\n        sum += weight(j*16+i, outCell) * inputState(ivec2(i,j));\n    }\n    return activation(sum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > 10. || fragCoord.y > 1.)\n        discard;\n    \n    int outCell = int(fragCoord.x);\n\t\n    float w = cellState(outCell);\n    fragColor = vec4(w, 0., 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// WEIGHT INITIALIZATION\n// AND GRADIENT DESCENT LEARNING\n//\n// renders a 256x10 weight matrix\n//\n// first two animation frames initialize randomly\n// after that, the expected and real network output are compared\n// and the error derivative is used to adjust the weights\n//\n\nconst float INIT_VARIANCE = 0.05;\nconst float LEARNRATE = 0.01;\n\n\n// http://www.musicdsp.org/showone.php?id=238\nfloat Tanh(in float x) { return clamp(x * ( 27. + x * x ) / ( 27. + 9. * x * x ), -1., 1.); }\n\n// activation function\nfloat activation(in float x) { return Tanh(x); }\n// derivative of the activation function\nfloat derivative(in float x) { return 1. - x * x; }\n\n// hashes by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n\n// 16x16 input to the net (the digit image)\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(0.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\n// the class of the input in 10 cells\nfloat expectedOutputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\n// the previous guess of the correct answer\nfloat outputState(in int op)\n{\n    vec2 p = vec2(float(op)+.5, .5) / iChannelResolution[1].xy;\n    return texture(iChannel1, p).x;\n}\n\n// the weight between each input and output cell\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[2].xy; \n    return (texture(iChannel2, p).x - .5) * 4.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= 256. || fragCoord.y >= 10.)\n        discard;\n    \n    // INIT WEIGHTS\n    if (iFrame < 2)\n    {\n        float w = (hash(fragCoord)-.5)*2. * INIT_VARIANCE;\n        \n        fragColor = vec4(vec3(w*.25+.5), 1.0);\n        return;\n    }\n    \n    // BACKPROP\n    \n    int inCell = int(fragCoord.x);\n    int outCell = int(fragCoord.y);\n    ivec2 ip = ivec2(int(mod(float(inCell), 16.)), inCell / 16);\n    \n    // previous output from forward pass\n    float outs = outputState(outCell);\n    // difference to expected output\n    float err = expectedOutputState(outCell) - outs;\n    // error derivative w.r.t. input state \n    float der = derivative(outs) * err * inputState(ip);\n    \n    float w = weight(inCell, outCell);\n    \n    // adjust weight\n    w += LEARNRATE * der; \n    \n    fragColor = vec4(vec3(w * .25 + .5), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// FORWARD PROPAGATION\n//\n// takes a 16x16 input (chan0) and a 256x10 weight matrix (chan1)\n// and renders a 10x1 output\n// \n// this one uses the test image as input\n\n// http://www.musicdsp.org/showone.php?id=238\nfloat Tanh(in float x) { return clamp(x * ( 27. + x * x ) / ( 27. + 9. * x * x ), -1., 1.); }\n\n// activation function\nfloat activation(in float x) { return Tanh(x); }\n\n\nfloat inputState(in ivec2 ip)\n{\n    vec2 p = (vec2(ip) + vec2(16.5, 1.5)) / iChannelResolution[0].xy;\n    return texture(iChannel0, p).x;\n}\n\nfloat weight(in int inCell, in int outCell)\n{\n    ivec2 ip = ivec2(inCell, outCell);\n    vec2 p = (vec2(ip) + .5) / iChannelResolution[2].xy; \n    return (texture(iChannel2, p).x - .5) * 4.;\n}\n\nfloat cellState(in int outCell)\n{\n    float sum = 0.;\n\tfor (int j=0; j<16; ++j)    \n    for (int i=0; i<16; ++i)    \n    {\n        sum += weight(j*16+i, outCell) * inputState(ivec2(i,j));\n    }\n    return activation(sum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > 10. || fragCoord.y > 1.)\n        discard;\n    \n    int outCell = int(fragCoord.x);\n\t\n    float w = cellState(outCell);\n    fragColor = vec4(w, 0., 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}