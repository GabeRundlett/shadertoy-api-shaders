{
    "Shader": {
        "info": {
            "date": "1618749108",
            "description": "CG 2nd HW Ofitserov 320",
            "flags": 32,
            "hasliked": 0,
            "id": "NdfSWN",
            "likes": 0,
            "name": "MSU building in octahedron",
            "published": 3,
            "tags": [
                "octahedron",
                "msu"
            ],
            "usePreview": 0,
            "username": "OFITSEROVLAD",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nconst float DIAMOND_N = 2.5;\n\n\n\nconst vec3 DownPoint = vec3(0, 0, 0);\nconst vec3 UpPoint = vec3(0, 2, 0);\nconst vec3 RightPoint = vec3(-1, 1, 0);\nconst vec3 LeftPoint = vec3(1, 1, 0);\nconst vec3 FrontPoint = vec3(0, 1, -1);\nconst vec3 BackPoint = vec3(0, 1, 1);\n\nconst int NUM_OF_MSU_TRIANGLES = 36;\nconst int NUM_OF_MSU_SPHERES = 3;\n\n\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(1, 2, 5);\n\nconst vec3 LIGHT1_POS = vec3(-3, 2, 1);\nconst float LIGHT1_RADIUS = .2;\nconst vec3 LIGHT1_COLOR = vec3(0.6, .9, 0.3);\n\nconst vec3 LIGHT2_POS = vec3(3, 2, -1);\nconst float LIGHT2_RADIUS = 0.1;\nconst vec3 LIGHT2_COLOR = vec3(0.9, 0.2, 0.9);\nvec3 randDir;\n\n\nstruct Triangle {\n    vec3 vertex0;\n    vec3 vertex1;\n    vec3 vertex2;\n};\n\nstruct Sphere {\n    vec3 orig;\n    float r;\n};\n\n\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 vertex0, vec3 vertex1, vec3 vertex2, out vec3 normal)\n{\n    const float EPSILON = 0.0000001;\n    vec3 edge1, edge2, h, s, q;\n    float a,f,u,v;\n    edge1 = vertex1 - vertex0;\n    edge2 = vertex2 - vertex0;\n    h = cross(dir, edge2);\n    a = dot(edge1, h);\n\n    // This ray is parallel to this triangle.\n    if (a > -EPSILON && a < EPSILON) {\n        return INF;   \n    }\n    f = 1.0/a;\n    s = pos - vertex0;\n    u = dot(f * s, h);\n    if (u < 0.0 || u > 1.0) {\n        return INF;\n    }\n    q = cross(s, edge1);\n    v = dot(f * dir, q);\n    if (v < 0.0 || u + v > 1.0) {\n        return INF;\n    }\n\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    float t = dot(f * edge2, q);\n    if (t > EPSILON) // ray intersection\n    {\n        normal = normalize(cross(edge2, edge1));\n        return t;\n    }\n    else // This means that there is a line intersection but not a ray intersection.\n        return INF;\n         \n\n}\n\n\n\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-.7 - pos.y) / dir.y;\n    if (t <= 0.0) {\n       return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 64.0) {\n        return INF;\n    }\n    \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-0.5 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -0.5) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -0.5) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\n\n\nvec3 rev(int x_, int z_, vec3 v) {\n    vec3 v_ = v;\n    if (x_ == 1) {\n        v_.x = 0. - v.x;\n    }\n\n    if (z_ == 1) {\n        v_.z = 0. - v.z;\n    }\n\n    return v_;\n}\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.5;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFog(vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    return vec4(vec3(5, 2, 5) * totalAbs, 1.0 - opacity);\n}\n\n\n\nbool isOccluded(vec3 pos, vec3 target, Triangle[NUM_OF_MSU_TRIANGLES] MSU_triangles, Sphere[NUM_OF_MSU_SPHERES] MSU_spheres) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    \n    vec3 MSU_TriangleNorm;\n    float MSU_TriangleT;\n    for (int i=0; i < MSU_triangles.length(); i++) {\n\n        for (int x_=0; x_<2; x_++) {\n            for (int z_=0; z_<2; z_++) {\n                vec3 v0 = rev(x_, z_, MSU_triangles[i].vertex0);\n                vec3 v1 = rev(x_, z_, MSU_triangles[i].vertex1);\n                vec3 v2 = rev(x_, z_, MSU_triangles[i].vertex2);\n\n                if ( (x_ == 1 && z_ == 1) || (x_ == 0 && z_ == 0)){\n                    MSU_TriangleT = traceTriangle(pos, dir, v0, v1, v2, MSU_TriangleNorm);\n                } else {\n                    MSU_TriangleT = traceTriangle(pos, dir, v1, v0, v2, MSU_TriangleNorm);\n                }\n            }\n        }\n        if ((MSU_TriangleT + 1.) < dist )\n            return true;\n    }\n\n    \n    vec3 sphNorm;\n    for (int i=0; i < MSU_spheres.length(); i++) {\n        for (float x_=-1.; x_<2.; x_+=2.) {\n            for (float z_=-1.; z_<2.; z_+=2.) {\n                float sphT = traceSphere(pos + vec3(x_ * MSU_spheres[i].orig.x, MSU_spheres[i].orig.y, z_ * MSU_spheres[i].orig.z), dir, MSU_spheres[i].r, sphNorm);\n                if (sphT < dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n    \n    \n    \n}\n\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal, Triangle[NUM_OF_MSU_TRIANGLES] MSU_triangles, Sphere[NUM_OF_MSU_SPHERES] MSU_spheres) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS, MSU_triangles,MSU_spheres ) ? 0.0 : 20.0 / (distSq1 );\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS, MSU_triangles, MSU_spheres) ? 0.0 : 10.0 / (distSq2);\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.2\n    );\n}\n\n\n\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) \n        return reflect(v, normal);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 100; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.3).rgb;\n            normal = planeNorm;\n            if (randVals.z < GLASS_R*5.) {\n                materialType = REFLECTION;\n            }\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        \n\n        Triangle Triangle1;\n        Triangle1.vertex0 = BackPoint;\n        Triangle1.vertex1 = LeftPoint;\n        Triangle1.vertex2 = DownPoint;\n\n        Triangle Triangle2;\n        Triangle2.vertex0 = DownPoint;\n        Triangle2.vertex1 = RightPoint;\n        Triangle2.vertex2 = BackPoint;\n\n        Triangle Triangle3;\n        Triangle3.vertex0 = DownPoint;\n        Triangle3.vertex1 = FrontPoint;\n        Triangle3.vertex2 = RightPoint;\n\n        Triangle Triangle4;\n        Triangle4.vertex0 = DownPoint;\n        Triangle4.vertex1 = LeftPoint;\n        Triangle4.vertex2 = FrontPoint;\n\n        Triangle Triangle5;\n        Triangle5.vertex0 = UpPoint;\n        Triangle5.vertex1 = LeftPoint;\n        Triangle5.vertex2 = BackPoint;\n\n        Triangle Triangle6;\n        Triangle6.vertex0 = UpPoint;\n        Triangle6.vertex1 = BackPoint;\n        Triangle6.vertex2 = RightPoint;\n\n        Triangle Triangle7;\n        Triangle7.vertex0 = UpPoint;\n        Triangle7.vertex1 = RightPoint;\n        Triangle7.vertex2 = FrontPoint;\n\n        Triangle Triangle8;\n        Triangle8.vertex0 = UpPoint;\n        Triangle8.vertex1 = FrontPoint;\n        Triangle8.vertex2 = LeftPoint;\n \n        Triangle triangles[] = Triangle[](Triangle1, Triangle2, Triangle3, Triangle4, Triangle5, Triangle6, Triangle7, Triangle8);\n \n        for (int i=0; i < triangles.length(); i++) {\n            float al = 0.8;\n            vec3 offset= vec3(0,0.6,0);\n            triangles[i].vertex0 -= offset;\n            triangles[i].vertex1 -= offset;\n            triangles[i].vertex2 -= offset;\n\n            triangles[i].vertex0 *= al;\n            triangles[i].vertex1 *= al;\n            triangles[i].vertex2 *= al;\n        }\n\n        vec3 TriangleNorm;\n        float TriangleT;\n        for (int i=0; i < triangles.length(); i++) {\n            TriangleT = traceTriangle(curPos, curDir, triangles[i].vertex0, triangles[i].vertex1, triangles[i].vertex2, TriangleNorm);\n            if (TriangleT < t) \n            {\n                t = TriangleT;\n                normal = TriangleNorm;\n                if (randVals.x < GLASS_R) {\n                    materialType = REFLECTION;\n                } else {\n                    colorMult *= vec3(0.95, 0.95, 1);\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0) {\n                        nEnter = AIR_N;\n                    } else {\n                        nEnter = GLASS_N;\n                    }\n                }\n            }\n        }\n\n\n        // ================================================================================================================================================\n\n        const float y_1 = 3.5;\n        const float y_2 = 4.;\n        const float y_3 = 6.;\n        const float y_4 = 8.5;\n        const float y_5 = 10.;\n        const float y_6 = 13.;\n\n        const float x_2 = 2.;\n        const float x_1 = 1.2;\n        const float x_01 = 0.7;\n        const float x_001 = 0.12;\n\n        const float z_11 = 1.;\n\n\n        const vec3 MSU_2_0_2 = vec3(x_2, 0, 2);\n        const vec3 MSU_2_5_2 = vec3(x_2, y_3, 2);\n        const vec3 MSU_0_0_2 = vec3(0, 0, 2);\n        const vec3 MSU_0_5_2 = vec3(0, y_3, 2);\n\n\n        Triangle MSU_Triangle1;\n        MSU_Triangle1.vertex0 = MSU_2_5_2;\n        MSU_Triangle1.vertex1 = MSU_2_0_2;\n        MSU_Triangle1.vertex2 = MSU_0_0_2;\n\n\n        Triangle MSU_Triangle2;\n        MSU_Triangle2.vertex0 = MSU_2_5_2;\n        MSU_Triangle2.vertex1 = MSU_0_0_2;\n        MSU_Triangle2.vertex2 = MSU_0_5_2;\n\n        const vec3 MSU_2_5_0 = vec3(x_2, y_3, 0);\n        const vec3 MSU_2_0_0 = vec3(x_2, 0, 0);\n\n        Triangle MSU_Triangle3;\n        MSU_Triangle3.vertex0 = MSU_2_5_0;\n        MSU_Triangle3.vertex1 = MSU_2_0_0;\n        MSU_Triangle3.vertex2 = MSU_2_0_2;\n\n        Triangle MSU_Triangle4;\n        MSU_Triangle4.vertex0 = MSU_2_5_0;\n        MSU_Triangle4.vertex1 = MSU_2_0_2;\n        MSU_Triangle4.vertex2 = MSU_2_5_2;\n\n\n        \n        const vec3 MSU_2_0_1 = vec3(x_2, 0, z_11);\n        const vec3 MSU_2_3_1 = vec3(x_2, y_1, z_11);\n        const vec3 MSU_5_3_1 = vec3(5, y_1, z_11);\n        const vec3 MSU_5_0_1 = vec3(5, 0, z_11);\n\n        Triangle MSU_Triangle5;\n        MSU_Triangle5.vertex0 = MSU_5_3_1;\n        MSU_Triangle5.vertex1 = MSU_5_0_1;\n        MSU_Triangle5.vertex2 = MSU_2_0_1;\n\n        Triangle MSU_Triangle6;\n        MSU_Triangle6.vertex0 = MSU_5_3_1;\n        MSU_Triangle6.vertex1 = MSU_2_0_1;\n        MSU_Triangle6.vertex2 = MSU_2_3_1;\n\n        const vec3 MSU_5_4_4 = vec3(5,y_2,4);\n        const vec3 MSU_5_0_4 = vec3(5,0,4);\n        const vec3 MSU_5_0_0 = vec3(5,0,0);\n        const vec3 MSU_5_4_0 = vec3(5,y_2,0);\n\n        Triangle MSU_Triangle7;\n        MSU_Triangle7.vertex0 = MSU_5_4_4;\n        MSU_Triangle7.vertex1 = MSU_5_0_4;\n        MSU_Triangle7.vertex2 = MSU_5_0_0;\n\n        Triangle MSU_Triangle8;\n        MSU_Triangle8.vertex0 = MSU_5_4_4;\n        MSU_Triangle8.vertex1 = MSU_5_0_0;\n        MSU_Triangle8.vertex2 = MSU_5_4_0;\n\n\n        const vec3 MSU_7_4_4 = vec3(7,y_2,4);\n        const vec3 MSU_7_0_4 = vec3(7,0,4);\n\n        Triangle MSU_Triangle9;\n        MSU_Triangle9.vertex0 = MSU_7_4_4;\n        MSU_Triangle9.vertex1 = MSU_7_0_4;\n        MSU_Triangle9.vertex2 = MSU_5_0_4;\n\n        Triangle MSU_Triangle10;\n        MSU_Triangle10.vertex0 = MSU_7_4_4;\n        MSU_Triangle10.vertex1 = MSU_5_0_4;\n        MSU_Triangle10.vertex2 = MSU_5_4_4;\n\n\n        const vec3 MSU_7_4_0 = vec3(7,y_2,0);\n        const vec3 MSU_7_0_0 = vec3(7,0,0);\n\n        Triangle MSU_Triangle11;\n        MSU_Triangle11.vertex0 = MSU_7_4_0;\n        MSU_Triangle11.vertex1 = MSU_7_0_0;\n        MSU_Triangle11.vertex2 = MSU_7_0_4;\n\n        Triangle MSU_Triangle12;\n        MSU_Triangle12.vertex0 = MSU_7_4_0;\n        MSU_Triangle12.vertex1 = MSU_7_0_4;\n        MSU_Triangle12.vertex2 = MSU_7_4_4;\n\n\n\n        const vec3 MSU_0_5_0 = vec3(0,y_3,0);\n\n\n        Triangle MSU_Triangle13;\n        MSU_Triangle13.vertex0 = MSU_2_5_0;\n        MSU_Triangle13.vertex1 = MSU_2_5_2;\n        MSU_Triangle13.vertex2 = MSU_0_5_2;\n\n        Triangle MSU_Triangle14;\n        MSU_Triangle14.vertex0 = MSU_2_5_0;\n        MSU_Triangle14.vertex1 = MSU_0_5_2;\n        MSU_Triangle14.vertex2 = MSU_0_5_0;\n\n\n        const vec3 MSU_5_3_0 = vec3(5,y_1,0);\n        const vec3 MSU_2_3_0 = vec3(x_2,y_1,0);\n\n\n        Triangle MSU_Triangle15;\n        MSU_Triangle15.vertex0 = MSU_5_3_0;\n        MSU_Triangle15.vertex1 = MSU_5_3_1;\n        MSU_Triangle15.vertex2 = MSU_2_3_1;\n\n        Triangle MSU_Triangle16;\n        MSU_Triangle16.vertex0 = MSU_5_3_0;\n        MSU_Triangle16.vertex1 = MSU_2_3_1;\n        MSU_Triangle16.vertex2 = MSU_2_3_0;\n\n\n\n        Triangle MSU_Triangle17;\n        MSU_Triangle17.vertex0 = MSU_7_4_0;\n        MSU_Triangle17.vertex1 = MSU_7_4_4;\n        MSU_Triangle17.vertex2 = MSU_5_4_4;\n\n        Triangle MSU_Triangle18;\n        MSU_Triangle18.vertex0 = MSU_7_4_0;\n        MSU_Triangle18.vertex1 = MSU_5_4_4;\n        MSU_Triangle18.vertex2 = MSU_5_4_0;\n\n\n\n        const vec3 MSU_15_5_15 = vec3(x_1, y_3, x_1);\n        const vec3 MSU_15_7_15 = vec3(x_1, y_4, x_1);\n        const vec3 MSU_0_5_15 = vec3(0, y_3, x_1);\n        const vec3 MSU_0_7_15 = vec3(0, y_4, x_1);\n\n\n        Triangle MSU_Triangle19;\n        MSU_Triangle19.vertex0 = MSU_15_7_15;\n        MSU_Triangle19.vertex1 = MSU_15_5_15;\n        MSU_Triangle19.vertex2 = MSU_0_5_15;\n\n\n        Triangle MSU_Triangle20;\n        MSU_Triangle20.vertex0 = MSU_15_7_15;\n        MSU_Triangle20.vertex1 = MSU_0_5_15;\n        MSU_Triangle20.vertex2 = MSU_0_7_15;\n\n\n        const vec3 MSU_15_7_0 = vec3(x_1, y_4, 0);\n        const vec3 MSU_15_5_0 = vec3(x_1, y_3, 0);\n\n        Triangle MSU_Triangle21;\n        MSU_Triangle21.vertex0 = MSU_15_7_0;\n        MSU_Triangle21.vertex1 = MSU_15_5_0;\n        MSU_Triangle21.vertex2 = MSU_15_5_15;\n\n        Triangle MSU_Triangle22;\n        MSU_Triangle22.vertex0 = MSU_15_7_0;\n        MSU_Triangle22.vertex1 = MSU_15_5_15;\n        MSU_Triangle22.vertex2 = MSU_15_7_15;\n\n\n\n        const vec3 MSU_0_7_0 = vec3(0,y_4,0);\n\n\n        Triangle MSU_Triangle23;\n        MSU_Triangle23.vertex0 = MSU_15_7_0;\n        MSU_Triangle23.vertex1 = MSU_15_7_15;\n        MSU_Triangle23.vertex2 = MSU_0_7_15;\n\n        Triangle MSU_Triangle24;\n        MSU_Triangle24.vertex0 = MSU_15_7_0;\n        MSU_Triangle24.vertex1 = MSU_0_7_15;\n        MSU_Triangle24.vertex2 = MSU_0_7_0;\n\n\n\n\n        const vec3 MSU_1_7_1 = vec3(x_01, y_4, x_01);\n        const vec3 MSU_1_9_1 = vec3(x_01, y_5, x_01);\n        const vec3 MSU_0_7_1 = vec3(0, y_4, x_01);\n        const vec3 MSU_0_9_1 = vec3(0, y_5, x_01);\n\n\n        Triangle MSU_Triangle25;\n        MSU_Triangle25.vertex0 = MSU_1_9_1;\n        MSU_Triangle25.vertex1 = MSU_1_7_1;\n        MSU_Triangle25.vertex2 = MSU_0_7_1;\n\n\n        Triangle MSU_Triangle26;\n        MSU_Triangle26.vertex0 = MSU_1_9_1;\n        MSU_Triangle26.vertex1 = MSU_0_7_1;\n        MSU_Triangle26.vertex2 = MSU_0_9_1;\n\n\n        const vec3 MSU_1_9_0 = vec3(x_01, y_5, 0);\n        const vec3 MSU_1_7_0 = vec3(x_01, y_4, 0);\n\n        Triangle MSU_Triangle27;\n        MSU_Triangle27.vertex0 = MSU_1_9_0;\n        MSU_Triangle27.vertex1 = MSU_1_7_0;\n        MSU_Triangle27.vertex2 = MSU_1_7_1;\n\n        Triangle MSU_Triangle28;\n        MSU_Triangle28.vertex0 = MSU_1_9_0;\n        MSU_Triangle28.vertex1 = MSU_1_7_1;\n        MSU_Triangle28.vertex2 = MSU_1_9_1;\n\n\n\n         const vec3 MSU_0_9_0 = vec3(0,y_5,0);\n\n\n        Triangle MSU_Triangle29;\n        MSU_Triangle29.vertex0 = MSU_1_9_0;\n        MSU_Triangle29.vertex1 = MSU_1_9_1;\n        MSU_Triangle29.vertex2 = MSU_0_9_1;\n\n        Triangle MSU_Triangle30;\n        MSU_Triangle30.vertex0 = MSU_1_9_0;\n        MSU_Triangle30.vertex1 = MSU_0_9_1;\n        MSU_Triangle30.vertex2 = MSU_0_9_0;\n\n\n\n\n\n\n        const vec3 MSU_03_9_03 = vec3(x_001, y_5, x_001);\n        const vec3 MSU_03_12_03 = vec3(x_001, y_6, x_001);\n        const vec3 MSU_0_9_03 = vec3(0, y_5, x_001);\n        const vec3 MSU_0_12_03 = vec3(0, y_6, x_001);\n\n\n        Triangle MSU_Triangle31;\n        MSU_Triangle31.vertex0 = MSU_03_12_03;\n        MSU_Triangle31.vertex1 = MSU_03_9_03;\n        MSU_Triangle31.vertex2 = MSU_0_9_03;\n\n\n        Triangle MSU_Triangle32;\n        MSU_Triangle32.vertex0 = MSU_03_12_03;\n        MSU_Triangle32.vertex1 = MSU_0_9_03;\n        MSU_Triangle32.vertex2 = MSU_0_12_03;\n\n\n        const vec3 MSU_03_12_0 = vec3(x_001, y_6, 0);\n        const vec3 MSU_03_9_0 = vec3(x_001, y_5, 0);\n\n        Triangle MSU_Triangle33;\n        MSU_Triangle33.vertex0 = MSU_03_12_0;\n        MSU_Triangle33.vertex1 = MSU_03_9_0;\n        MSU_Triangle33.vertex2 = MSU_03_9_03;\n\n        Triangle MSU_Triangle34;\n        MSU_Triangle34.vertex0 = MSU_03_12_0;\n        MSU_Triangle34.vertex1 = MSU_03_9_03;\n        MSU_Triangle34.vertex2 = MSU_03_12_03;\n\n\n\n         const vec3 MSU_0_12_0 = vec3(0,y_6,0);\n\n\n        Triangle MSU_Triangle35;\n        MSU_Triangle35.vertex0 = MSU_03_12_0;\n        MSU_Triangle35.vertex1 = MSU_03_12_03;\n        MSU_Triangle35.vertex2 = MSU_0_12_03;\n\n        Triangle MSU_Triangle36;\n        MSU_Triangle36.vertex0 = MSU_03_12_0;\n        MSU_Triangle36.vertex1 = MSU_0_12_03;\n        MSU_Triangle36.vertex2 = MSU_0_12_0;\n\n \n        Triangle MSU_triangles[] = Triangle[](MSU_Triangle1, MSU_Triangle2, MSU_Triangle3, MSU_Triangle4, MSU_Triangle5, MSU_Triangle6,\n                        MSU_Triangle7, MSU_Triangle8, MSU_Triangle9, MSU_Triangle10, MSU_Triangle11, MSU_Triangle12, MSU_Triangle13, MSU_Triangle14, \\\n                        MSU_Triangle15, MSU_Triangle16, MSU_Triangle17, MSU_Triangle18, MSU_Triangle19, MSU_Triangle20, MSU_Triangle21, MSU_Triangle22, \\\n                        MSU_Triangle23, MSU_Triangle24, MSU_Triangle25, MSU_Triangle26, MSU_Triangle27, MSU_Triangle28, MSU_Triangle29, MSU_Triangle30, \\\n                        MSU_Triangle31, MSU_Triangle32, MSU_Triangle33, MSU_Triangle34, MSU_Triangle35, MSU_Triangle36);\n\n\n        float al = 0.05;\n        vec3 offset = vec3(0,1.5,0);\n\n\n        Sphere MSU_Sphere1;\n        MSU_Sphere1.r = 0.9;\n        MSU_Sphere1.orig = vec3(6, -(y_2 +  MSU_Sphere1.r), 3);\n\n\n        Sphere MSU_Sphere2;\n        MSU_Sphere2.r = 0.3;\n        MSU_Sphere2.orig = vec3(0, -(y_6 + MSU_Sphere2.r), 0);\n\n        Sphere MSU_Sphere3;\n        MSU_Sphere3.r = 0.3;\n        MSU_Sphere3.orig = vec3(x_2 - MSU_Sphere3.r , -(y_3 + MSU_Sphere3.r), x_2 - MSU_Sphere3.r);\n\n\n\n        Sphere MSU_spheres[] = Sphere[](MSU_Sphere1, MSU_Sphere2, MSU_Sphere3); \n\n        for (int i=0; i < MSU_spheres.length(); i++) {\n            MSU_spheres[i].orig-= offset;\n            MSU_spheres[i].r *= al;\n            MSU_spheres[i].orig *= al;\n        }\n\n\n\n        float y_line = y_2;\n        y_line += offset.y;\n        y_line *= al;\n\n        float y_line2 = y_3;\n        y_line2 += offset.y;\n        y_line2 *= al;\n\n        float x_line = x_2;\n        x_line *= al;\n\n\n        if (randVals.x < 0.8) {\n            for (int i=0; i < MSU_triangles.length(); i++) {\n                MSU_triangles[i].vertex0 += offset;\n                MSU_triangles[i].vertex1 += offset;\n                MSU_triangles[i].vertex2 += offset;\n                \n                MSU_triangles[i].vertex0 *= al;\n                MSU_triangles[i].vertex1 *= al;\n                MSU_triangles[i].vertex2 *= al;\n            }\n\n            vec3 MSU_TriangleNorm;\n            float MSU_TriangleT;\n            for (int i=0; i < MSU_triangles.length(); i++) {\n                for (int x_=0; x_<2; x_++) {\n                    for (int z_=0; z_<2; z_++) {\n                        vec3 v0 = rev(x_, z_, MSU_triangles[i].vertex0);\n                        vec3 v1 = rev(x_, z_, MSU_triangles[i].vertex1);\n                        vec3 v2 = rev(x_, z_, MSU_triangles[i].vertex2);\n\n                        if ( (x_ == 1 && z_ == 1) || (x_ == 0 && z_ == 0)){\n                            MSU_TriangleT = traceTriangle(curPos, curDir, v0, v1, v2, MSU_TriangleNorm);\n                        } else {\n                            MSU_TriangleT = traceTriangle(curPos, curDir, v1, v0, v2, MSU_TriangleNorm);\n                        }\n                        if (MSU_TriangleT < t) \n                        {\n                            t = MSU_TriangleT;\n                            normal = MSU_TriangleNorm;\n                            materialType = DIFFUSE;\n                        \n                            vec3 worldPos = t * curDir + curPos;\n                            color = vec3(0.9,0.8,0.5);\n                            if (abs(worldPos.x) > x_line + 1e-3 && worldPos.y > (y_line - MSU_spheres[0].r) && worldPos.y < (y_line - 2. * MSU_spheres[0].r / 3.)) {\n                                color = color = vec3(0.6,0.0,0.0);\n                            } else if (abs(worldPos.x) <= x_line + 1e-3 && worldPos.y > (y_line2 - MSU_spheres[0].r) && worldPos.y < (y_line2 - 2. * MSU_spheres[0].r / 3.)) {\n                                color = color = vec3(0.6,0.0,0.0);\n                            }\n                        \n                        }\n                    }\n                }\n                \n            }\n        \n\n        // ================================================================================================================================================\n            vec3 sphNorm;\n            vec3 gold_color = vec3(0.85, 0.65, 0.3);\n            for (int i=0; i < MSU_spheres.length(); i++) {\n                for (float x_=-1.; x_<2.; x_+=2.) {\n                    for (float z_=-1.; z_<2.; z_+=2.) {\n                        float sphT = traceSphere(curPos + vec3(x_ * MSU_spheres[i].orig.x, MSU_spheres[i].orig.y, z_ * MSU_spheres[i].orig.z), curDir, MSU_spheres[i].r, sphNorm);\n                        if (sphT < t) {\n                            t = sphT;\n                            normal = sphNorm;\n                            materialType = DIFFUSE;\n                            color =  gold_color;\n                        }\n                    }\n                }\n            }\n        }\n        // ================================================================================================================================================\n\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * (worldPos.y - 1.)).rgb;\n            \n            normal = cylNorm;\n        }\n       \n        \n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal, MSU_triangles, MSU_spheres) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n\n                vec4 fog = sampleFog(curPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * colorMult;\n                colorMult *= (1.0 - fog.a);\n\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}