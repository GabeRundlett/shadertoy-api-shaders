{
    "Shader": {
        "info": {
            "date": "1576818470",
            "description": "Trying to integrate clouds and atmosphere together, and a crude attempt at a cloud phase function with fogbow/glory. \n3 cameras (sunset, afterburner, window seat) look around with mouse.",
            "flags": 32,
            "hasliked": 0,
            "id": "tl33Rn",
            "likes": 131,
            "name": "Overcast Cloud",
            "published": 3,
            "tags": [
                "sunset",
                "cloud",
                "lensflare",
                "atmosphere",
                "glory",
                "overcast",
                "fogbow",
                "alligator",
                "windowseat",
                "afterburner"
            ],
            "usePreview": 1,
            "username": "blackjero",
            "viewed": 3075
        },
        "renderpass": [
            {
                "code": "IMAGE",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Overcast Cloud - by Jerome Liard, December 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/tl33Rn\n\n// Trying to integrate clouds and atmosphere together, and a crude attempt at a cloud phase function with fogbow/glory.\n// 3 cameras (sunset, afterburner, window seat) look around with mouse.\n// \n// Notes:\n// - Although the atmosphere is done normally spherically, the cloud layer isn't and is just a flat band parameterized from current vertical camera location. \n//   This makes it awkward to use in real situations (not to mention the overall prohibitive cost).\n// - I didn't bother with inside/below/space views, cloud wise.\n// - The cached cloud texture uses layers of alligator noise (documented in Houdini's online documentation). I hack a bit to detect screen resizes.\n// - At high sun elevation we get uniform white/beige color, I probably did something wrong unless it is because it is a heightmap.\n// - No plane shadow in the glory, I didn't model the 3d plane... sorry\n\n// Bits of code from @iq, @Dave_Hoskins, @MyNameIsMJP, @AlanZucconi and others (see comments), and some visual reference from @FabriceNeyret2 for the cloud phase.\n// The code length is hopeless as always.\n\n#define iTanHalfFovy 0.505275\n#define iExposure 4.118157\n\n#define iSlider0 0.692857\n#define iSlider1 0.085714\n#define iSlider2 0.450000\n#define iSlider3 0.000000\n#define iSlider4 0.000000\n#define iSlider5 0.100000\n\n#define PI 3.141592654\n#define const\n#ifndef FLT_MAX\n#define FLT_MAX 1000000.0\n#endif\n\nconst vec3 RED = vec3( 1, 0, 0 );\nconst vec3 GREEN = vec3( 0, 1, 0 );\nconst vec3 BLUE = vec3( 0, 0, 1 );\nconst vec3 WHITE = vec3( 1, 1, 1 );\nconst vec3 BLACK = vec3( 0, 0, 0 );\nconst vec3 YELLOW = vec3( 1, 1, 0 );\nconst vec3 CYAN = vec3( 0, 1, 1 );\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\n\nIMPL_SATURATE( float ) \nIMPL_SATURATE( vec2 ) \nIMPL_SATURATE( vec3 ) \nIMPL_SATURATE( vec4 )\n\nfloat exp_decay( float x ) { return 1. - exp( -x ); } // note: exp_decay(pow(x,a)*b) for smooth in\n\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\n\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nvec3 smoothbump( vec3 a, vec3 r, vec3 x ) { return vec3( 1.0 ) - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\n\n// like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n// band, centered at 0... like smoothstep_c but different meaning\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n// range s,e\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\n\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\n// return range -pi,pi\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\n\n//https://iquilezles.org/articles/smin\nfloat smin_pol( float a, float b, float k ) { float h = clamp( 0.5f + 0.5f * ( b - a ) / k, 0.0f, 1.0f ); return mix( b, a, h ) - k * h * ( 1.0 - h ); }\nfloat smax_pol( float a, float b, float k ) { return -smin_pol( -a, -b, k ); }\n\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nfloat nearest( float x ) { return floor( 0.5 + x ); }\nfloat sum( vec2 v ) { return v.x + v.y; }\nfloat sum( vec3 v ) { return v.x + v.y + v.z; }\nfloat sum( vec4 v ) { return v.x + v.y + v.z + v.w; }\nfloat product( vec2 v ) { return v.x * v.y; }\nfloat product( vec3 v ) { return v.x * v.y * v.z; }\nfloat product( vec4 v ) { return v.x * v.y * v.z * v.w; }\n\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\nfloat safe_asin( float x ) { return asin( clamp( x, -1., 1. ) ); }\n\n// use with constants...\n#define POW0(x) 1.0\n#define POW1(x) (x)\n#define POW2(x) (POW1(x)*(x))\n#define POW3(x) (POW2(x)*(x))\n#define POW4(x) (POW3(x)*(x))\n#define POW5(x) (POW4(x)*(x))\n#define POW6(x) (POW5(x)*(x))\n\n// project this on line (O,d), d is assumed to be unit length\n#define PROJECT_ON_LINE1(type) type project_on_line1( type P, type O, type d ) { return O + d * dot( P - O, d ); }\n\nPROJECT_ON_LINE1( vec2 ) \nPROJECT_ON_LINE1( vec3 )\n\nmat4 mat4_translation( vec3 value ) { return mat4( vec4( 1.0, 0.0, 0.0, 0.0 ),  vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( value, 1.0 ) ); }\n\nmat4 mat4_inverse1( mat4 m )\n{\n\t// inv(T(t)xR)=inv(R)xinv(T(t))=trans(R)xT(-t)\n\treturn mat4(\n\t\tvec4( m[0].x, m[1].x, m[2].x, 0.0 ),\n\t\tvec4( m[0].y, m[1].y, m[2].y, 0.0 ),\n\t\tvec4( m[0].z, m[1].z, m[2].z, 0.0 ),\n\t\tvec4( 0, 0, 0, 1 ) ) * mat4_translation( -m[3].xyz );\n}\n\nvec3 transform_point( mat4 m, vec3 p ) { return ( m * vec4( p, 1.0 ) ).xyz; }\nvec3 transform_vector( mat4 m, vec3 v ) { return ( m * vec4( v, 0.0 ) ).xyz; }\n\n#define REPEAT_FUNCTIONS( type ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); } \\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); } \\\ntype repeat_e( type x, type start, type end ) { return start + repeat( x - start, end - start ); } /* _e means end as in start,end, return identity in range start,start+len, and repeat elsewhere */ \\\ntype tri0( type x ) { return abs( fract( x * 0.5 ) - type(0.5) ) * 2.0; } /* mirror repeat of y=1-x on 0,1 */ \\\ntype tri( type x ) { return tri0( type(1.0) - x ); } /* mirror repeat of y=x on 0,1 */\n\nREPEAT_FUNCTIONS( float )\nREPEAT_FUNCTIONS( vec2 )\n\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\n// w is a magical aa scale factor, smaller w gives thicker lines\nfloat rulers( float p, float spacing, float w )\n{\n\tfloat u = tri( p * ( 2.0 / spacing ) );\n\tu /= fwidth( p ); // == abs(dFdx(p)) + abs(dFdy(p))\n\tu = smoothstep( 0., 1., spacing * u * w );\n\treturn 1.0 - u; // alpha\n}\n\n// iq's function munged for vec4 https://www.shadertoy.com/view/XlXcW\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = ( ( x >> 13U ) ^ x.yzwx ) * k;\n\tx = ( ( x >> 13U ) ^ x.zwxy ) * k;\n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ) );\n}\n\nvec2 hash22i( vec2 index ) { return hash42_( ivec2( index ) ).xy; }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nfloat hash11( float p ) { vec3 p3  = fract( vec3( p ) * HASHSCALE1 ); p3 += dot( p3, p3.yzx  + 19.19 ); return fract( ( p3.x + p3.y ) * p3.z ); }\nfloat hash12( vec2 p ) { vec3 p3  = fract( vec3( p.xy, p.x ) * HASHSCALE1 ); p3 += dot( p3, p3.yzx  + 19.19 ); return fract( ( p3.x + p3.y ) * p3.z ); }\n\nconst vec2 V45 = vec2( 0.707106781, 0.707106781 );\n\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\n// theta_vec is the unit vector for angle theta\n// phi_vec is the unit vector for angle phi\nvec3 zup_spherical_coords_to_vector( vec2 theta_vec, vec2 phi_vec ) { return vec3( theta_vec.y * phi_vec, theta_vec.x ); }\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\nvec3 zup_spherical_coords_to_vector( vec2 theta_phi ) { return zup_spherical_coords_to_vector( theta_phi.x, theta_phi.y ); }\n\n// note: n.xy==0 is undefined for phi, pleae handle in caller code\nvec2 vector_to_zup_spherical_coords( vec3 n )\n{\n\tfloat theta = safe_acos( n.z ); // note: vectors normalized with normalize() are not immune to -1,1 overflow which cause nan in acos\n\tfloat phi = calc_angle( n.xy  );\n\treturn vec2( theta, phi );\n}\n\nmat4 zup_spherical_coords_to_matrix( vec2 theta, vec2 phi )\n{\n\tvec3 z = zup_spherical_coords_to_vector( theta, phi );\n\tvec3 x = zup_spherical_coords_to_vector( perp( theta ), phi ); // note: perp(theta) = unit_vector2(theta+PI*0.5)\n\tvec3 y = cross( z, x );\n\treturn ( mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) ) );\n}\n\n// same as zup_spherical_coords_to_matrix with extra roll around x\nmat4 zup_spherical_coords_to_matrix_rollx( vec2 theta, vec2 phi, vec2 rollx )\n{\n\tvec3 z = zup_spherical_coords_to_vector( theta, phi );\n\tvec3 x = zup_spherical_coords_to_vector( perp( theta ), phi ); // note: perp(theta) = unit_vector2(theta+PI*0.5)\n\tvec3 y = cross( z, x );\n\tvec3 ry = y * rollx.x + z * rollx.y;\n\tvec3 rz = -y * rollx.y + z * rollx.x;\n\ty = ry;\n\tz = rz;\n\treturn ( mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) ) );\n}\n\nmat4 zup_spherical_coords_to_matrix( float theta, float phi ) { return zup_spherical_coords_to_matrix( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nvec3 yup_spherical_coords_to_vector( vec2 theta, vec2 phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return yup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 yup_spherical_coords_to_matrix( vec2 theta, vec2 phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( perp( theta ), phi ); // note: perp(theta) = unit_vector2(theta+PI*0.5)\n\tvec3 x = cross( y, z );\n\treturn ( mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ) );\n}\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phi ) {  return yup_spherical_coords_to_matrix( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 x_rotation( const float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( 1,0,0,0 ), vec4( 0.f, v.x, v.y, 0.f ), vec4( 0.f,-v.y, v.x, 0.f ), vec4( 0,0,0,1 ) ); }\nmat4 y_rotation( const float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, 0.f, -v.y, 0.f ), vec4( 0,1,0,0 ), vec4( v.y, 0.f, v.x, 0.f ), vec4( 0,0,0,1 ) ); }\nmat4 z_rotation( const float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\n// source: adapted from Houdini online doc\nfloat calc_alligator_noise( vec2 p, float period )\n{\n\tvec2 p_index = floor( p );\n\tfloat d1 = 0.0;\n\tfloat d2 = 0.0;\n\tfor ( int x = -1; x <= 1; ++x )\n\t{\n\t\tfor ( int y = -1; y <= 1; ++y )\n\t\t{\n\t\t\tvec2 index = p_index + vec2( x, y );\n\t\t\tvec2 index_hash = index;\n\t\t\tif ( period != 0.0 ) index_hash = mod( index_hash, vec2( period ) );\n\t\t\tvec2 c = index + hash22i( index_hash ); // compiler bug.. hash bit returns 0 (but not always, depends where its called from)\n\t\t\tvec2 cp = p - c;\n\t\t\tfloat d = lensqr( cp );\n\t\t\tif ( d < 1.0 )\n\t\t\t{\n\t\t\t\tif ( period != 0.0 ) index_hash = mod( index_hash, vec2( period ) );\n\t\t\t\td = hash12( index_hash ) * smoothstep_unchecked( 1.0 - sqrt( d ) );\n\t\t\t\tif ( d1 < d )\n\t\t\t\t{\n\t\t\t\t\td2 = d1;\n\t\t\t\t\td1 = d;\n\t\t\t\t}\n\t\t\t\telse if ( d2 < d )\n\t\t\t\t{\n\t\t\t\t\td2 = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d1 - d2;\n}\n\nfloat noise1s( float x )\n{\n\tx -= 0.5;\n\tfloat x0 = floor( x );\n\tfloat y0 = hash11( x0 );\n\tfloat y1 = hash11( x0 + 1.0 );\n\treturn mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n}\n\n// noise layering with build time expanded normalizing factors etc (use constants obviously)\n\n#define LAYERED6(func,p,args,frequency,persistence,period) \\\n((func(p*POW0(frequency),args,period*POW0(frequency))*POW1(persistence)+ \\\n  func(p*POW1(frequency),args,period*POW1(frequency))*POW2(persistence)+ \\\n  func(p*POW2(frequency),args,period*POW2(frequency))*POW3(persistence)+ \\\n  func(p*POW3(frequency),args,period*POW3(frequency))*POW4(persistence)+ \\\n  func(p*POW4(frequency),args,period*POW4(frequency))*POW5(persistence)+ \\\n  func(p*POW5(frequency),args,period*POW5(frequency))*POW6(persistence))* \\\n   (1.0/( (POW1(persistence)+ \\\n\t POW2(persistence)+ \\\n\t POW3(persistence)+ \\\n\t POW4(persistence)+ \\\n\t POW5(persistence)+ \\\n\t POW6(persistence)))))\n\n// higher values for a gives smoother landscapes\nfloat calc_alligator_noise_( vec2 p, float args, float period ) { return calc_alligator_noise( p, period ); }\n\nfloat alligator6_12( vec2 p, float period ) { return LAYERED6( calc_alligator_noise_, p, -1.0, 2.0, 0.5, period ); }\nfloat alligator6_12( vec2 p, float frequency, float persistence, float period ) { return LAYERED6( calc_alligator_noise_, p, -1.0, frequency, persistence, period ); }\n\nstruct Ray{ vec3 o; vec3 d; };\n\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\n// note: looking down z\nvec3 get_view_dir( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp ) { return normalize( vec3( normalized_pos.x * aspect, normalized_pos.y, -tan_half_fovy_rcp ) ); }\n// note that we pass the reciprocal of tan_half_fovy\n// normalized_pos is (-1,1-)->(1,1)\nRay get_view_ray2( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp, mat4 camera ) { return mkray( camera[3].xyz, transform_vector( camera, get_view_dir( normalized_pos, aspect, tan_half_fovy_rcp ) ) ); }\nRay transform_ray( mat4 m, Ray ray ) { return mkray( transform_point( m, ray.o ), transform_vector( m, ray.d ) ); }\n\nvec2 sphere_trace( Ray ray, float radius, vec3 center )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( center - O, d ); // O + d * tp = center projected on line (O,d)\n\tfloat h_sqr = lensqr( ( O + d * tp ) - center );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\nfloat get_horizon_elevation( vec3 c, float r, vec3 p ) { return safe_asin( r / length( p - c ) ); }\nfloat get_ray_elevation( vec3 c, vec3 o, vec3 d ) { return safe_acos( dot( d, normalize( c - o ) ) ); }\nfloat get_ray_elevation( vec3 c, Ray view_ray ) { return get_ray_elevation( c, view_ray.o, view_ray.d ); }\n\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\n\n// http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\nfloat CornetteSingleScatteringPhaseFunction( float cos_theta, float g )\n{\n\tfloat g2 = g * g;\n\treturn 3.0 * ( 1.0 - g2 ) * ( 1.0 + pow2( cos_theta ) ) / ( 2.0 * ( 2.0 + g2 ) * pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ) );\n}\n\n// notes: RayleighScattering(cos_theta)  == CornetteSingleScatteringPhaseFunction( cos_theta, 0.0 )\n// should integrate to one on the sphere (check with integral_of_spherical_func)\nfloat RayleighScattering( float cos_theta ) { return 0.75 * ( 1.0 + cos_theta * cos_theta ); }\n\n// https://www.astro.umd.edu/~jph/HG_note.pdf HG, g in [-1,1]\n// note: multiply by 4*PI to integrate to 1 on the sphere, I think... (check with integral_of_spherical_func)\nfloat HenyeyGreensteinPhaseFunction( float cos_theta, float g )\n{\n\tfloat g2 = g * g;\n\treturn ( 1.0 / ( 4.0 * PI ) ) * ( 1.0 - g2 ) / pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 );\n}\n\n// this one gives us fogbow and glories\n// for the cloud phase function I used \"Interactive multiple anisotropic scattering in clouds\" Figure 2 for rough reference https://hal.inria.fr/inria-00333007/document\nvec3 CloudPhaseFunction( float cos_theta )\n{\n\tfloat x = safe_acos( cos_theta );\n\tfloat x2 = max( 0., x - 2.45 ) / ( PI - 2.15 );\n\tfloat x3 = max( 0., x - 2.95 ) / ( PI - 2.95 );\n\tfloat y = ( exp( -max( x * 1.5 + 0.0, 0.0 ) * 30.0 ) // front peak\n\t\t\t\t+ smoothstep( 1.7, 0., x ) * 0.45 * 0.8 // front ramp\n\t\t\t\t+ smoothbump( 0.4, 0.5, cos_theta ) * 0.02 // front bump middle\n\t\t\t\t- smoothstep( 1., 0.2, x ) * 0.06 // front ramp damp wave\n\t\t\t\t+ smoothbump( 2.18, 0.20, x ) * 0.06 // first trail wave\n\t\t\t\t+ smoothstep( 2.28, 2.45, x ) * 0.18 // trailing piece\n\t\t\t\t- powerful_scurve( x2 * 4.0, 3.5, 8. ) * 0.04 // trail\n\t\t\t\t+ x2 * -0.085\n\t\t\t\t+ x3 * x3 * 0.1 ); // trail peak\n\n\tvec3 ret = vec3( y );\n\t// spectralize a bit\n\tret = mix( ret, ret + 0.008 * 2., smoothstep( 0.94, 1., cos_theta ) * sin( x * 10. * vec3( 8, 4, 2 ) ) );\n\tret = mix( ret, ret - 0.008 * 2., smoothbump( -0.7, 0.14, cos_theta ) * sin( x * 20. * vec3( 8, 4, 2 ) ) ); // fogbow\n\tret = mix( ret, ret - 0.008 * 5., smoothstep( -0.994, -1., cos_theta ) * sin( x * 30. * vec3( 3, 4, 2 ) ) ); // glory\n\n\t// scale and offset should be tweaked so integral on sphere is 1\n\tret += 0.13 * 1.4;\n\treturn ret * 3.9;\n}\n\n// http://graphicrants.blogspot.jp/\n// \n// Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr / ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_neumann( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v / max( n_dot_l, n_dot_v ); }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\nfloat F_cooktorrance( float v_dot_h, float F0 )\n{\n\tfloat F0_sqrt = sqrt( F0 );\n\tfloat mu = ( 1. + F0_sqrt ) / ( 1. - F0_sqrt );\n\tfloat c = v_dot_h;\n\tfloat g = sqrt( mu * mu + c * c - 1. );\n\treturn 0.5 * pow2( ( g - c ) / ( g + c ) ) * ( 1. + pow2( ( ( g + c ) * c - 1. ) / ( ( g - c ) * c + 1. ) ) );\n}\n\n// this is just an example\n// v = wi\n// l = Li\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, float kdiffuse, float kspecular, float roughness )\n{\n\tfloat F0 = 0.08;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat n_dot_l_raw = dot( n, l );\n\tfloat n_dot_v_raw = dot( n, v );\n\tfloat n_dot_h_raw = dot( n, h );\n\tfloat eps = 1e-4; // else divides by zero\n\tfloat n_dot_l = max( eps, n_dot_l_raw );\n\tfloat n_dot_v = max( eps, n_dot_v_raw );\n\tfloat n_dot_h = max( eps, n_dot_h_raw );\n\tfloat D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0\n\tfloat G = G_neumann( n_dot_l, n_dot_v );\n\tfloat F = F_schlick( n_dot_v, F0 );\n\treturn ( ( kdiffuse * albedo * ( 1.0 / PI ) + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, vec3 kdiffuse_kspecular_roughness )\n{\n\treturn add_light_contrib( albedo, l, n, v, Li, dwi, kdiffuse_kspecular_roughness.x, kdiffuse_kspecular_roughness.y, kdiffuse_kspecular_roughness.z );\n}\n\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); } // //http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x, float exposure ) { return exposure * tonemap_reinhard( x ); }\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); } // mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\n\n// spherical gaussians code copied from @MyNameIsMJP, tried to use a bit for the soft look but didn't push much\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n\nstruct SG { vec3 Amplitude; vec3 Axis; float Sharpness; };\n\nSG MakeSG( vec3 a, vec3 v, float s )\n{\n\tSG sg;\n\tsg.Amplitude = a;\n\tsg.Axis = v;\n\tsg.Sharpness = s;\n\treturn sg;\n}\n\n// approximate integral on omega of sg(v)dv\nvec3 ApproximateSGIntegral( in SG sg ) { return 2. * PI * ( sg.Amplitude / sg.Sharpness ); }\n\nvec3 SGIrradianceFitted( in SG lightingLobe, in vec3 normal )\n{\n\tconst float muDotN = dot( lightingLobe.Axis, normal );\n\tconst float lambda = lightingLobe.Sharpness;\n\n\tconst float c0 = 0.36f;\n\tconst float c1 = 1.0f / ( 4.0f * c0 );\n\n\tfloat eml  = exp( -lambda );\n\tfloat em2l = eml * eml;\n\tfloat rl   = 1.0 / lambda;\n\n\tfloat scale = 1.0f + 2.0f * em2l - rl;\n\tfloat bias  = ( eml - em2l ) * rl - em2l;\n\n\tfloat x  = sqrt( 1.0f - scale );\n\tfloat x0 = c0 * muDotN;\n\tfloat x1 = c1 * x;\n\n\tfloat n = x0 + x1;\n\n\tfloat y = saturate( muDotN );\n\tif ( abs( x0 ) <= x1 ) y = n * n / x;\n\n\tfloat result = scale * y + bias;\n\n\treturn result * ApproximateSGIntegral( lightingLobe );\n}\n\n// is this correct then?\nvec3 SGDiffuseFitted( in SG lightingLobe, in vec3 normal, vec3 albedo )\n{\n\tvec3 brdf = albedo / PI;\n\treturn SGIrradianceFitted( lightingLobe, normal ) * brdf;\n}\n\n// AlanZucconi's spectral palette functions from https://www.shadertoy.com/view/ls2Bz1\n\nvec3 bump3y( vec3 x, vec3 yoffset ) { vec3 y = 1. - x * x; return saturate( y - yoffset ); }\n\nvec3 spectral_zucconi6_01( float x )\n{\n\tconst vec3 c1 = vec3( 3.54585104, 2.93225262, 2.41593945 );\n\tconst vec3 x1 = vec3( 0.69549072, 0.49228336, 0.27699880 );\n\tconst vec3 y1 = vec3( 0.02312639, 0.15225084, 0.52607955 );\n\tconst vec3 c2 = vec3( 3.90307140, 3.21182957, 3.96587128 );\n\tconst vec3 x2 = vec3( 0.11748627, 0.86755042, 0.66077860 );\n\tconst vec3 y2 = vec3( 0.84897130, 0.88445281, 0.73949448 );\n\t\n\treturn bump3y( c1 * ( x - x1 ), y1 ) + bump3y( c2 * ( x - x2 ), y2 );\n}\n\nvec3 spectral_zucconi6( float w )\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate( ( w - 400.0 ) / 300.0 );\n\treturn spectral_zucconi6_01( x );\n}\n\nstruct coordsys_t { vec3 o,x,y,z; };\n\nfloat calc_Fr_r( float cos_theta ) { return RayleighScattering( cos_theta  ); }\nfloat calc_Fr_m( float cos_theta, float g ) { return CornetteSingleScatteringPhaseFunction( cos_theta, g ); }\n\n#define earth_radius 6.36e+6 // careful algorithm is very sensitive to this\n#define earth_center vec3(0.0,0.0,0.0)\nconst float earth_angular_velocity = ( 2.0 * PI / ( 24.0 * 60.0 * 60.0 ) );\nconst float sun_radius = 6.955e+8; // for render only\n#define sun_dist 1.49e+11 // for render only\nconst float sun_cos = 0.999989; // for render only\nconst float H0_r = 8e+3;\nconst float H0_m = 1.2e+3;\nconst float atm_max = 6420e+3 - earth_radius; // as small as possible, large enough to accomodate H0_ values\n// beta is 1/m units, but we work in km\nconst vec3 beta_r = 1.0 * vec3( 5.19e-6, 1.21e-5, 2.96e-5 ); // calculated offline\n//vec3 beta_r = 1.0 * vec3( 5.8e-6, 13.5e-6, 33.1e-6 ); // from \"Precomputed Atmospheric Scattering\"\n//vec3 beta_r = 1.0 * vec3( 5.5e-6, 13.0e-6, 22.4e-6 ); // wwwtyro\nconst vec3 beta_m = 0.01 * vec3( 210e-5 ); // from \"Precomputed Atmospheric Scattering\", but need an extra factor 100 to get something that looks like something...\nconst vec3 beta_c = vec3( 6e-4f, 5e-4f, 2e-4f ) * 0.6 * 1.5;\n#define Is (vec3( 1.0, 1.0, 1.0 ) * 1.6)\nconst vec3 sun_Ls = Is * 2.0; // for solid objects lighting\n\nconst vec3 earth_diffuse_reflection = vec3( 0.1 ); // controls blue depth\nconst float Isky_max_angle_deg = 110.0;\n\n// include window scale when debugging plane orientation (helps to see more of the outside)\n#define WINDOW_RADIUS_SCALE 1.0\n#define CLOUD_AND_SKY_AS_DOWNSIZED_BUFFER\n#define NICER_HORIZON 2\n#define USE_REAL_SUN_COLOR\n#define CLAMP_IV // be careful: clamping fixes clouds bright dots artifacts but ruins atm where used\n#define CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE 0.5 /*0.25 or 0.5*/\n#define num_view_ray_segments 40 // we have to bump this number quite a bit to get decent integration\n\t\t\t\t\t\t\t\t // also 40 causes cream artifact on the horizon\nint enable_solid_clouds = 1;\nint enable_sky_and_clouds = 1;\n#define min_max_cloud_steps 25.0\n#define max_cloud_steps_increment 5.0\nfloat max_max_cloud_steps = min_max_cloud_steps + max_cloud_steps_increment * 2.0;\nfloat sun_ray_optical_depth_max_n = 10.f; // affects shadow a lot\nint enable_cloud_phase = 1;\nint enable_solid_clouds_half_screen = 0;\n// pretend altocumulus-ish altitude https://en.wikipedia.org/wiki/Altocumulus_cloud altough we do full opaque...\n#define cloud_end 6.0e+3\n#define cloud_layer_thickness 5.e+3\n#define cloud_start (cloud_end - cloud_layer_thickness)\n#define cloud_mid (( cloud_end + cloud_start ) * 0.5)\nconst float cloud_tex_world_size = 21000.0;\nfloat cloud_sharpness = 1.0;\nfloat cloud_density = 1.1;\nfloat sun_cloud_tmax_hack = 1.0;\nfloat cloud_scattering_max_step = 450.0; // affects the look of the cloud quite a bit, try 50.0\n\t\t\t\t\t\t\t\t\t\t // when flying below clouds this must be small\nstruct scene_params_t\n{\n\tmat4 camera;\n\tmat4 plane_to_world;\n\tmat4 plane_render_camera;\n\tvec3 sun_direction;\n\tcoordsys_t b;\n\tfloat tan_half_fovy;\n\tfloat fade;\n\tint enable_cabin_view;\n\tint enable_sun_glare;\n\tint enable_sun_flares;\n\tvec4 cloud_animation_params; // xy: cloud_scroll_offset  z: animation speed w: iTime\n};\n\n// [0,1] -> [0,1]\n// s is the slope at midpoint (0.5.0.5)\n// for s pick something >4 to get a bit of oversteer\nfloat oversteer_step_cubic( float x, float s )\n{\n\ts = -s;\n\tx = saturate( x );\n\tif ( x > 0.5 ) {\n\t\tx = 1.0 - x;\n\t\treturn 1.0 + ( ( ( -6.0 - s * 2.0 ) + ( 8.0 + s * 4.0 ) * x ) * x ) * x;\n\t}\n\treturn -( ( ( -6.0 - s * 2.0 ) + ( 8.0 + s * 4.0 ) * x ) * x ) * x;\n}\n\nfloat quantize( float x, float q ) { return nearest( x * q ) / q; }\n\n// for camera movements\n// set s to 2,3 for smooth noise with a bit of control on the smoothness\n// set s to 4,5,6 for some oversteer (6 starts to get quite strong)\nfloat noise1s_quantized_oversteer( float x, float s, float q )\n{\n\tx -= 0.5;\n\tfloat x0 = floor( x );\n\tfloat y0 = quantize( hash11( x0 ), q );\n\tfloat y1 = quantize( hash11( x0 + 1.0 ), q );\n\tif ( s == 1.0 ) return mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n\treturn mix( y0, y1, oversteer_step_cubic( x - x0, s ) );\n}\n\nvec3 getFlyingCameraPath( float time )\n{\n\tvec3 p;\n\tp.y = 3000.0 * noise1s_quantized_oversteer( 0.1 * time, 6.0, 4.0 );\n\tp.z = time * 3000.0;\n\tp.x = ( noise1s_quantized_oversteer( 0.06 * time, 5.0, 4.0 ) - 0.5 ) * 2.0 * 10000.0;\n\treturn p;\n}\n\n// note: scene_params.camera's position must stay in place!! cloud uv scroll makes it look like we are moving (sorry this is sad)\nvoid applyFlyingCamera( inout scene_params_t scene_params, float time )\n{\n\tvec3 p0 = getFlyingCameraPath( time - 1.0 );\n\tvec3 p1 = getFlyingCameraPath( time );\n\n\tfloat roll = ( p1.x - p0.x ) * 0.0001;\n\t\n\tscene_params.camera[3].xyz = scene_params.b.z * ( earth_radius + cloud_end + 1500.0 );\n\n\tvec3 x = scene_params.camera[0].xyz;\n\tvec3 y = scene_params.camera[1].xyz;\n\tvec3 z = scene_params.camera[2].xyz;\n\tvec3 o = scene_params.camera[3].xyz;\n\t\n\tscene_params.camera[3].xyz = (scene_params.camera * vec4(p1.x,p1.y,0.0,1.0) ).xyz;\n\n\tvec2 rollv = unit_vector2( roll );\n\tscene_params.camera[0].xyz = rollv.x * x + rollv.y * y;\n\tscene_params.camera[1].xyz = -rollv.y * x + rollv.x * y;\n\n\tfloat travelled = p1.z * 2.0;\n\n\tscene_params.cloud_animation_params.xy = vec2( -travelled, 0.0 );\n\tscene_params.cloud_animation_params.z = 1.0;\n}\n\nscene_params_t getSceneParams( float aTime, vec3 aResolution, vec4 aMouse )\n{\n\tscene_params_t scene_params;\n\n\tscene_params.enable_cabin_view = 0;\n\tscene_params.enable_sun_glare = 1;\n\tscene_params.enable_sun_flares = 1;\n\tscene_params.fade = 1.0;\n\n\tscene_params.cloud_animation_params.xy = unit_vector2( PI ) * aTime * 1000.0;\n\tscene_params.cloud_animation_params.z = 1.0; // cloud animation\n\tscene_params.cloud_animation_params.w = aTime;\n\n\tfloat theta_from_sun_direction = radians( 110.0 * iSlider0 ); // note: theta_from_sun_direction can't be zero, our trace doesn't support it (because b)\n\tfloat flying_altitude = cloud_end + 1800.0 + ( 30000. - 1800. ) * iSlider1;\n\tfloat plane_yaw = 2.0 * PI * iSlider2 * 1.0;\n\tfloat plane_roll = 2.0 * PI * iSlider3 * 1.0;\n\tfloat plane_pitch = 2.0 * PI * iSlider4 * 1.0;\n\n\tscene_params.tan_half_fovy = iTanHalfFovy;\n\n\tvec2 mm = vec2( 0.0, 0.0 );\n\tvec2 mm0 = mm;\n\tvec2 mm1 = mm;\n\n\t{\n\t\t// mouse control\n\t\tbool sticky_mouse = false;\n\t\tif ( aMouse.z > 0.0 || sticky_mouse ) mm0 = ( aMouse.xy - aResolution.xy * 0.5 ) / ( min( aResolution.x, aResolution.y ) * 0.5 );\n\t\tmm1 = mm0;\n\t\tmm1 = sign( mm1 ) * pow( abs( mm1 ), vec2( 0.9 ) );\n\t\tmm = mm1 * 3.0 * scene_params.tan_half_fovy;\n\t}\n\n\tint camera_index = -1;\n\n\tfloat t0 = 15.0;\n\tfloat t1 = 28.0;\n\tfloat t2 = 26.0;\n\t\n\tfloat time = aTime;\n\n#if 1\n\n\ttime = mod( time, t0 + t1 + t2  );\n\tfloat t = 0.0;\n\n\tfloat fade_time = 0.5;\n\tscene_params.fade = saturate( 1.0 -( smoothbump( 0.0, fade_time, time )+\n\t\t\t\t\t\t\t\t\t\t smoothbump( t0, fade_time, time )+\n\t\t\t\t\t\t\t\t\t\t smoothbump( t0 + t1, fade_time, time )+\n\t\t\t\t\t\t\t\t\t\t smoothbump( t0 + t1 + t2, fade_time, time ) ) );\n\t \n\t     if ( time < t0      ) { camera_index = 0;                  t = time / t0; }\n\telse if ( time < t0 + t1 ) { camera_index = 1; time -= t0;      t = time / t1; }\n\telse                       { camera_index = 2; time -= t0 + t1; t = time / t2; }\n\n#else\n\n\tfloat loop_time = t2;\n\tcamera_index = 2;\n\ttime = mod( time, loop_time );\n\tfloat t = time / loop_time;\n\t\n#endif\n\n\tif ( camera_index == 0 ) // sunset\n\t{\n\t\ttheta_from_sun_direction = radians( 90.0 );\n\t\tflying_altitude = cloud_end + 1800.0 * mix( 1.5, 3.5, t );\n\t\tmm.x += exp_decay( pow(time,2.0) * 0.015 ) * 1.0;\n\t\tmm.y -= t * 0.6;\n\t\t\n\t\tscene_params.cloud_animation_params.xy = unit_vector2( plane_yaw ) * aTime * 5000.0;\n\t}\n\telse if ( camera_index == 1 ) // flight\n\t{\n\t\ttheta_from_sun_direction = radians( 80.0 );\n\t\tfloat lookup = 1.0 - 0.82 * exp_decay( time * 0.1 );\n\t\tmm.y -= lookup;\n\t}\n\telse if ( camera_index == 2 ) // cabin\n\t{\n\t\ttheta_from_sun_direction = radians( mix( 91.0, 70.0, t ) );\n\t\tflying_altitude = cloud_end + 6000.0;\n\t\tscene_params.enable_cabin_view = 1;\n\t\tscene_params.tan_half_fovy = 0.51;\n\t\tplane_yaw = radians( 39.0 );\n\t\tscene_params.cloud_animation_params.xy = -unit_vector2( plane_yaw ) * aTime * 1000.0;\n\n\t\tif ( aMouse.z <= 0.0 )\n\t\t{\n\t\t\tmm0.x -= smoothband( time, 6.0, 11.0, 2.0 ) * 0.18;\n\t\t\tmm0.y -= smoothband( time, 6.2, 12.0, 2.0 ) * 0.10;\n\t\t}\n\n\t\t// todo: make the clamp below smoother...\n\t\tmm1 = clamp( mm0, vec2( -0.2, -0.32 ), vec2( +0.6, +0.3 ) );\n\t\tmm1 = sign( mm1 ) * pow( abs( mm1 ), vec2( 0.9 ) );\n\t\tmm = mm1 * 3.0 * scene_params.tan_half_fovy;\n\t}\n\n\tmat4 tmp = zup_spherical_coords_to_matrix( theta_from_sun_direction, 0.0 );\n\n\tscene_params.sun_direction = vec3( 0., 0., 1. ); // no point in changing this\n\tvec3 cloud_plane_n = tmp[2].xyz;\n\n\tscene_params.b.x = tmp[0].xyz;\n\tscene_params.b.y = tmp[1].xyz;\n\tscene_params.b.z = tmp[2].xyz;\n\tscene_params.b.o = earth_radius * cloud_plane_n; // ground point\n\n\tscene_params.camera[0].xyz = tmp[1].xyz;\n\tscene_params.camera[1].xyz = tmp[2].xyz;\n\tscene_params.camera[2].xyz = tmp[0].xyz;\n\tscene_params.camera[3].xyz = cloud_plane_n * ( earth_radius + flying_altitude );\n\n\tif ( camera_index == 1 ) applyFlyingCamera( scene_params, time );\n\n\tmat4 mouse_rotation = yup_spherical_coords_to_matrix( mm.y, -mm.x );\n\tscene_params.camera = scene_params.camera * mouse_rotation;\n\n\tif ( scene_params.enable_cabin_view == 1 )\n\t{\n\t\tscene_params.plane_to_world = tmp; // plane is local so origin is 0,0,0\n\n\t\tfloat noise_rotation_amplitude = 1.15;\n\t\tscene_params.plane_to_world = scene_params.plane_to_world\n\t\t\t* zup_spherical_coords_to_matrix_rollx(\n\t\t\tunit_vector2( plane_pitch + noise_rotation_amplitude * sin( (time)*2. * PI / 9.0 ) * 0.01 ),\n\t\t\tunit_vector2( plane_yaw + noise_rotation_amplitude * sin( ( time - 3.0 ) * 2. * PI / 10.0 ) * 0.01 ),\n\t\t\tunit_vector2( plane_roll + noise_rotation_amplitude * sin( ( time + 4.0 ) * 2. * PI / 11.0 ) * 0.01 ) );\n\n\t\t// plane needs to be traced with saner float ranges so origin same as plane local offset from here\n\t\tscene_params.plane_render_camera[0] = scene_params.plane_to_world[0];\n\t\tscene_params.plane_render_camera[1] = scene_params.plane_to_world[2];\n\t\tscene_params.plane_render_camera[2] = -scene_params.plane_to_world[1];\n\t\tscene_params.plane_render_camera[3] = scene_params.plane_to_world[3]\n\t\t\t+ scene_params.plane_to_world[0] * 0.30 // move along plane\n\t\t\t+ scene_params.plane_to_world[1] * 5.30 // get closer to the window\n\t\t\t+ scene_params.plane_to_world[2] * 0.75 // up and down\n\t\t;\n\n\t\tscene_params.plane_render_camera\n\t\t\t= scene_params.plane_render_camera\n\t\t\t* x_rotation( radians( -4.5 ) )\n\t\t\t* y_rotation( radians( 15.0 ) );\n\n\t\t{\n\t\t\t// vector that looks at windows center\n\t\t\tvec3 z = -scene_params.plane_render_camera[3].xyz;\n\n\t\t\t// move along plane\n\t\t\tscene_params.plane_render_camera[3].xyz += scene_params.plane_to_world[0].xyz\n\t\t\t\t* ( ( smoothstep( 0.0, 0.12, abs( mm1.x ) ) )\n\t\t\t\t\t* max( mm1.x, 0. ) * -1.2 );\n\n\t\t\t// up and down\n\t\t\tscene_params.plane_render_camera[3].xyz += scene_params.plane_to_world[2].xyz\n\t\t\t\t* ( smoothstep( 0.1, 0.4, abs( mm1.y ) ) )\n\t\t\t\t* max( -mm1.y, 0. ) * 0.65;\n\n\t\t\t// get closer to the window\n\t\t\tscene_params.plane_render_camera[3].xyz -= z\n\t\t\t\t* maxcomp( smoothstep( 0.1, 0.4, abs( mm1 ) ) * abs( mm1 ) ) * 0.1;\n\n\t\t\t// translate closer to the window when looking left and down\n\t\t\tscene_params.plane_render_camera[3].xyz += scene_params.plane_to_world[1].xyz\n\t\t\t\t* smoothstep( 0.0, 0.025, abs( mm1.x ) * max( -mm1.x, 0. ) ) * 0.3;\n\t\t}\n\n\t\tscene_params.plane_render_camera = scene_params.plane_render_camera * mouse_rotation;\n\t\t\n\t\tscene_params.camera[0] = scene_params.plane_render_camera[0];\n\t\tscene_params.camera[1] = scene_params.plane_render_camera[1];\n\t\tscene_params.camera[2] = scene_params.plane_render_camera[2];\n\t}\n\n\treturn scene_params;\n}\n\n// write Image's iChannel0\nvec4 calcCloudHeightMap_bufA( vec2 fragCoord, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tint calculate_bufA_every_frame = 0;\n\n\tbool resized = ( aResolution != texelFetch( aChannel1, ivec2( aResolution.xy ) - ivec2( 1, 1 ), 0 ).xyz ); // check the resolution we think we have (should have been written in the top right pixel of bufB)\n\n\tif ( !resized && ( calculate_bufA_every_frame == 0 ) && aFrame > 2 ) return texture( aChannel0, fragCoord.xy / aResolution.xy ); // reuse\n\n\tvec2 uv = fragCoord.xy / aResolution.xy;\n\tvec4 tex = vec4( 0.0 );\n\t // s must be integer\n\t{ float s =  8.; tex.x = alligator6_12( uv.xy * s, s ); }\n\t{ float s =  4.; tex.y = alligator6_12( uv.xy * s, s ); }\n\t{ float s = 10.; tex.z = alligator6_12( uv.xy * s, s ); }\n\treturn tex;\n}\n\nfloat getCloudDist( vec3 p, coordsys_t b, vec4 cloud_animation_params, sampler2D aChannel0 )\n{\n\tfloat aTime = cloud_animation_params.w;\n\t\n\tfloat lod = 0.0;\n\n\tfloat r = length( p );\n\tfloat ph = r - earth_radius;\n\tvec3 n = p; // / r; // we don't need normalize, because we project\n\tn = vec3( dot( n, b.x ),\n\t\t\t  dot( n, b.y ),\n\t\t\t  dot( n, b.z ) );\n\tp.xy = ( 8. * 1000000.0 ) * ( n.xy / n.z ); // cube projection centered on b\n\tp.xy += cloud_animation_params.xy;\n\tvec2 uv = p.xy * ( 1.0 / cloud_tex_world_size );\n\n\tvec4 n1 = textureLod( aChannel0, uv + aTime * ( 0.004 * cloud_animation_params.z ), lod );\n\tvec4 n2 = textureLod( aChannel0, uv * ( 1.0 / 8. ) + ( aTime * 0.0017 * cloud_animation_params.z ), lod );\n\tfloat h = saturate( ( 1.0 * n1.x * 0.3 +\n\t\t\t\t\t\t  1.0 * n1.y * 0.5 +\n\t\t\t\t\t\t  1.0 * n2.z * 1.3 - 0.05 ) ); // saturating here should make no difference, if it does it means h range is wrong\n\n\tfloat h1 = mix( mix( cloud_start, cloud_end, 0.3 ), cloud_end, h );\n\tfloat h2 = mix( mix( cloud_start, cloud_end, 0.2 ), cloud_start, h );\n\tfloat d1 = ph - h1;\n\tfloat d2 = h2 - ph;\n\tfloat dist = opI( d1, d2 );\n\treturn dist;\n}\n\nvec2 getCloudDensityAndDistance( vec3 p, coordsys_t b, vec4 cloud_animation_params, sampler2D aChannel0 )\n{\n\tfloat dist = getCloudDist( p, b, cloud_animation_params, aChannel0 );\n\tfloat density = ( dist > 0.0 ? 0.0 : exp_decay( max( -dist, 0.0 ) * cloud_sharpness ) * cloud_density ); // also: beta_c\n//\tfloat density = step( dist, 0.0 ); // little visual different and a little bit faster\n\treturn vec2( density, dist );\n}\n\n// like sphere_trace with some bits factored out\nvec2 sphere_trace_2( float tp, float h_sqr, float radius )\n{\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n// return the trace interval of the cloud band\n// return 0,0 if there is nothing to trace\nvec2 getCloudTraceRange( Ray view_ray )\n{\n\tvec3 O = view_ray.o;\n\tvec3 d = view_ray.d;\n\tfloat tp = dot( earth_center - O, d ); // O + d * tp = center projected on line (O,d)\n\tfloat h_sqr = lensqr( ( O + d * tp ) - earth_center );\n\tvec2 tcs = sphere_trace_2( tp, h_sqr, earth_radius + cloud_start );\n\tvec2 tce = sphere_trace_2( tp, h_sqr, earth_radius + cloud_end );\n\n\tfloat r2 = lensqr( view_ray.o - earth_center );\n\n\tif ( r2 > pow2( earth_radius + cloud_end ) )\n\t{\n\t\tif ( tce.x == FLT_MAX || tce.x < 0.0 ) return vec2( 0.0, 0.0 );\n\t\tif ( tcs.x == FLT_MAX ) return vec2( tce.x, tce.y );\n\t\treturn vec2( tce.x, tcs.x );\n\t}\n\n\tif ( r2 > pow2( earth_radius + cloud_start ) )\n\t{\n\t\tif ( tcs.x != FLT_MAX && tcs.x > 0.0 ) return vec2( 0, tcs.x );\n\t\treturn vec2( 0.0, tce.y );\n\t}\n\n\tif ( tcs.y != FLT_MAX && tcs.y > 0.0 )\n\t{\n\t\tvec2 tea = sphere_trace_2( tp, h_sqr, earth_radius );\n\t\tif ( tea.x == FLT_MAX || tea.x > 0.0 ) return vec2( 0, 0 );\n\t\treturn vec2( tcs.y, tce.y );\n\t}\n\n\treturn vec2( 0, 0 );\n}\n\n#define body_radius vec2( 5.96, 6.09 )\nconst vec2 windows_radius = vec2( 25.0, 37.0 ) / 229.0 * body_radius.x * 0.5;\nconst float windows_spacing = 50.0 / 229.0 * body_radius.x * 0.5;\nconst float windows_pos_from_center = 50.0 / 229.0 * body_radius.x * 0.5;\n\nfloat sdAirlinerWindow( vec2 p, float window_radius_scale )\n{\n\tp = abs( p );\n\n\tvec2 r = vec2( 525.0, 625.0 ) / 525.0;\n\tp *= r.x / ( windows_radius.x * window_radius_scale );\n\n\treturn smin_pol( smin_pol( -p.y + r.y, -p.x + r.x, 0.95 )\n\t\t\t\t\t , -dot( V45, p - project_on_line1( p, r + V45 * 1.05, perp( V45 ) ) ), 2.1 );\n}\n\nfloat sd_cylinderx( vec3 p, vec3 c, float r ) { return length( p.yz - c.yz ) - r; }\n\nfloat sdPlaneWindowVolume( vec3 p, float window_radius_scale )\n{\n\tvec3 cc = vec3( 0 );\n\tfloat wall_in = body_radius.x - 0.05;\n\tfloat wall_out = body_radius.x + 0.02;\n\tvec2 p2 = p.xz;\n\tp2.x = repeat_e( p.x, -windows_spacing, windows_spacing );\n\tp2.y -= windows_pos_from_center;\n\t// wx is window border mapped to 0,1\n\tfloat wx = saturate( ( ( p.y - cc.y ) - wall_in ) / ( wall_out - wall_in ) );\n\tp2 *= ( 1.0 + wx * 0.1 );\n\tfloat dw = sdAirlinerWindow( p2, window_radius_scale );\n\treturn dw;\n}\n\nfloat sdPlaneCabin( vec3 p, float window_radius_scale )\n{\n\tvec3 cc = vec3( 0 );\n\n\tfloat wall_in = body_radius.x - 0.05;\n\tfloat wall_out = body_radius.x + 0.02;\n\n\tfloat l = 72.25; //a350len\n\tfloat d = opI( opI( ( p - cc ).x - l * 0.5, //front clip\n\t\t\t\t  opI( -sd_cylinderx( p, cc, wall_in ),\n\t\t\t\t\t   sd_cylinderx( p, cc, wall_out ) ) ), // plane body wall\n\t\t\t -( p - cc ).x - l * 0.5 ); // back clip\n\n\t// https://www.airbus.com/content/dam/corporate-topics/publications/backgrounders/techdata/aircraft_characteristics/Airbus-Commercial-Aircraft-AC-A350-900-1000.pdf\n\t// Page 9 for window size and position\n\tvec2 p2 = p.xz;\n\tp2.x = repeat_e( p.x, -windows_spacing, windows_spacing );\n\tp2.y -= windows_pos_from_center;\n\t// wx is window border mapped to 0,1\n\tfloat wx = saturate( ( ( p.y - cc.y ) - wall_in ) / ( wall_out - wall_in ) );\n\tp2 *= ( 1.0 + wx * 0.1 );\n\tfloat dw = sdAirlinerWindow( p2, window_radius_scale );\n\td = opI( d, dw );\n\tfloat d1 = opI( -sd_cylinderx( p, cc, wall_in + 0.02 ),\n\t\t\t\t\tsd_cylinderx( p, cc, wall_in + 0.03 ) );\n\td = opS( d, d1 );\n\treturn d;\n}\n\nvec3 gPlaneCabin( vec3 p, float window_radius_scale )\n{\n\tfloat d = 0.05; // for near stuff\n\tfloat c = sdPlaneCabin( p, window_radius_scale );\n\treturn normalize( vec3( sdPlaneCabin( p + vec3( d, 0.0, 0.0 ), window_radius_scale ) - c,\n\t\t\t\t\t\t\tsdPlaneCabin( p + vec3( 0.0, d, 0.0 ), window_radius_scale ) - c,\n\t\t\t\t\t\t\tsdPlaneCabin( p + vec3( 0.0, 0.0, d ), window_radius_scale ) - c ) );\n}\n\n// for debug coloring of cloud surface\nvec3 gForClouds( vec3 p, coordsys_t b, vec4 cloud_animation_params, sampler2D aChannel0 )\n{\n\tfloat d = 70.0; // d too small will reveal bilinear lookup discontinuities, if used\n\tfloat c = getCloudDist( p, b, cloud_animation_params, aChannel0 );\n\treturn normalize( vec3( getCloudDist( p + vec3( d, 0.0, 0.0 ), b, cloud_animation_params, aChannel0 ) - c,\n\t\t\t\t\t\t\tgetCloudDist( p + vec3( 0.0, d, 0.0 ), b, cloud_animation_params, aChannel0 ) - c,\n\t\t\t\t\t\t\tgetCloudDist( p + vec3( 0.0, 0.0, d ), b, cloud_animation_params, aChannel0 ) - c ) );\n}\n\nvec3 calc_Fr_c( float cos_theta )\n{\n\tif ( enable_cloud_phase == 1 ) return 1.04 * CloudPhaseFunction( cos_theta );\n\n\t// *4.0*PI is so that function integrates to 1 on the sphere\n\t// note: linear combination still integrate to 1\n\treturn vec3( mix( HenyeyGreensteinPhaseFunction( cos_theta, 0.42 ), // normal phase (increase g to strengthen illumination in sun direction)\n\t\t\t\t\t  HenyeyGreensteinPhaseFunction( cos_theta, -0.3 ), // hack boost clouds on the other side of the sun too..\n\t\t\t\t\t  0.3 ) * 4.0 * PI );\n\t// also see Physically based Sky, Atmosphere and Cloud Rendering in Frostbite:\n\t// http://blog.selfshadow.com/publications/s2016-shading-course/hillaire/s2016_pbs_frostbite_sky_clouds.pptx\n}\n\n// return r,m in .xy and set cloud density to 0 in .z\nvec3 calc_rho_atm_only( vec3 p )\n{\n\tfloat h = length( p - earth_center ) - earth_radius;\n\treturn vec3( exp( -vec2( h ) / vec2( H0_r, H0_m ) ), 0.0 );\n}\n\nstruct vec9 { vec3 r, m, c; }; // rayleigh, mie, cloud\n\nvec9 mkvec9( vec3 s )\n{\n\tvec9 val;\n\tval.r = vec3( s.x );\n\tval.m = vec3( s.y );\n\tval.c = vec3( s.z );\n\treturn val;\n}\n\nvec9 mkvec9( float s ) { return mkvec9( vec3( s, s, s ) ); }\n\nvoid add_vec9( inout vec9 od, vec9 value, float ds )\n{\n\tod.r += value.r * beta_r * ds;\n\tod.m += value.m * beta_m * ds;\n\tod.c += value.c * beta_c * ds;\n}\n\nvoid add_vec9_c( inout vec3 od_c, vec3 value_c, float ds ) { od_c += value_c * beta_c * ds; }\n\nstruct integration_t\n{\n\tvec9 prev;\n\tvec9 sum;\n\tbool first; // could use a 0,1 float and mulitply\n};\n\nintegration_t integration_init()\n{\n\tintegration_t ret;\n\tret.sum = mkvec9( 0.0 );\n\tret.first = true;\n\treturn ret;\n}\n\nvoid add_vec9( inout integration_t od, vec9 value, float ds )\n{\n\tif ( !od.first )\n\t{\n\t\tvec9 tmp;\n\t\ttmp.r = ( od.prev.r + value.r ) * 0.5;\n\t\ttmp.m = ( od.prev.m + value.m ) * 0.5;\n\t\ttmp.c = ( od.prev.c + value.c ) * 0.5;\n\t\tadd_vec9( od.sum, tmp, ds );\n\t}\n\tod.prev = value;\n\tod.first = false;\n}\n\nvoid add_vec9_c( inout integration_t od, vec3 value_c, float ds )\n{\n\tif ( !od.first )\n\t{\n\t\tvec9 tmp;\n//\t\ttmp.r = ( od.prev.r + value.r ) * 0.5; // 0.0\n//\t\ttmp.m = ( od.prev.m + value.m ) * 0.5; // 0.0\n\t\ttmp.c = ( od.prev.c + value_c ) * 0.5;\n\t\tadd_vec9_c( od.sum.c, tmp.c, ds );\n\t}\n\tod.prev.c = value_c;\n\tod.first = false;\n}\n\n// note: transmittance = exp(-opticalDepth)\nintegration_t opticalDepth2( Ray ray, float t, float t2, coordsys_t b )\n{\n\tintegration_t ret = integration_init();\n#define num_segments 15\n\tfloat dt = ( t2 - t ) / float( num_segments );\n\tfor ( int i = 0; i < num_segments + 1; ++i )\n\t{\n\t\tvec3 p = ray.o + ray.d * t;\n\t\tvec3 rho = calc_rho_atm_only( p ); // no cloud\n\t\tadd_vec9( ret, mkvec9( rho ), dt );\n\t\tt += dt;\n\t}\n\treturn ret;\n}\n\nstruct TraceOutput\n{\n\tfloat t;\n\tfloat num_iterations; // num iterations\n\tfloat dist; // distance to surface (error)\n\tfloat shadow;\n};\n\nTraceOutput traceClouds( Ray ray, coordsys_t b, vec2 tmax, vec4 cloud_animation_params, sampler2D aChannel0 )\n{\n\tfloat dbreak = 0.0004; // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\tfloat tfrac = 1.0;\n\tint max_iterations = 100;\n\n\tTraceOutput to;\n\tto.t = tmax.x;\n//\tto.t = 0.0;\n\tto.num_iterations = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfor ( int i = 0; i < max_iterations; ++i )\n\t{\n\t\tfloat d = getCloudDist( ray.o + to.t * ray.d, b, cloud_animation_params, aChannel0 );\n\t\tto.dist = d;\n\t\tif ( ( abs( to.dist ) <= dbreak * to.t ) || to.t > tmax.y ) break;\n\t\t\n\t\tto.t += to.dist * tfrac; // d can be negative... hmm\n\t\tto.num_iterations += 1.0;\n\t}\n\n\treturn to;\n}\n\n// just cloud contribution\nintegration_t opticalDepth3( Ray ray, float tmax, coordsys_t b, vec2 uv, float nn, vec4 cloud_animation_params, sampler2D aChannel0 )\n{\n\tintegration_t ret = integration_init();\n\tfloat dx = 2000.0;\n\tfloat n = min( ceil( tmax / dx ), nn );\n\tdx = tmax / n;\n\tfloat tprev = 0.0;\n\tfloat t = 0.0;\n\tfor ( float i = 0.; i < n; i += 1.0 )\n\t{\n\t\tvec3 p = ray.o + ray.d * t;\n\t\tvec2 dd = getCloudDensityAndDistance( p, b, cloud_animation_params, aChannel0 );\n\t\tfloat density = dd.x;\n\t\tfloat dist = dd.y;\n\t\tfloat dt = t - tprev;\n\t\tadd_vec9_c( ret, vec3( density ), dt ); // note: dt not used the first time\n\t\ttprev = t;\n\t\tdist = abs( dist );\n\t\tdist = max( dist, cloud_scattering_max_step );\n\t\tt += dist;\n\t}\n\treturn ret;\n}\n\nbool in_earth_shadow( vec3 p, vec3 sun_direction ) { return ( dot( p, sun_direction ) < 0.0 ) && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius ); }\n\nvec4 s_params_r = vec4( 11.8549757, 22.499994277, 0.01295454, 0.199916169 );\nvec4 s_params_g = vec4( 7.501523494, 12.642851829, 0.023999901, 0.242999389 );\nvec4 s_params_b = vec4( 0.381065428, 9.642851829, 0.073178708, 0.570980966 );\n\nfloat calc_Isky_div_Is_approx_per_wavelength( float x, vec4 params )\n{\n\tx = -( x - radians( Isky_max_angle_deg ) ) / radians( Isky_max_angle_deg );\n\tx = saturate( x );\n\tx -= params.w;\n\t// Gompertz Function, via Payul Bouyrke miscellaneous functions\n\treturn exp( params.x * exp_decay( x * params.y ) / params.y ) * params.z;\n}\n\nvec3 calc_Isky_div_Is_approx( float x )\n{\n\treturn vec3( calc_Isky_div_Is_approx_per_wavelength( x, s_params_r ),\n\t\t\t\t calc_Isky_div_Is_approx_per_wavelength( x, s_params_g ),\n\t\t\t\t calc_Isky_div_Is_approx_per_wavelength( x, s_params_b ) );\n}\n\n// implementation of http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n// using buffer and  all symmetries we could cache luts and make this shader considerably faster,\n// but I wanted a no buffers shader, so brute force.\n\nstruct AtmOut\n{\n\tvec3 earth_p; // when hitting earth surface\n\tvec3 earth_n; // when hitting earth surface\n\tbool earth_surface; // is earth surface\n};\n\nvec3 atmEval_WithClouds( Ray view_ray, inout AtmOut atm_out\n\t\t\t\t\t\t , vec3 sun_direction, coordsys_t b\n\t\t\t\t\t\t , vec2 uv, float first_cloud_t, vec2 cloud_trange\n\t\t\t\t\t\t , vec4 cloud_animation_params\n\t\t\t\t\t\t , sampler2D aChannel0 )\n{\n\t// elevation from (view point,earth center) vector\n\tfloat elev_view_vector = get_ray_elevation( earth_center, view_ray );\n\tfloat elev_earth_horizon = get_horizon_elevation( earth_center, earth_radius, view_ray.o );\n\tfloat elev_cloud_end_vector = get_horizon_elevation( earth_center, earth_radius + cloud_end, view_ray.o );\n\tbool hits_earth = elev_view_vector < elev_earth_horizon;\n\n\tvec2 te = sphere_trace( view_ray, earth_radius, earth_center ); // earth sphere\n\tvec2 ta = sphere_trace( view_ray, earth_radius + atm_max, earth_center ); // upper atmosphere sphere\n\n\tatm_out.earth_surface = ( te.x > 0.0 && te.x != FLT_MAX );\n\n\tvec3 spacecolor = BLACK;\n\n\tif ( ta.x == FLT_MAX ) return spacecolor; // view_ray line doesn't intersect a (and therefore, e since e is inside a)\n\tif ( ta.y <= 0.0 ) return spacecolor; // return mix(SPACECOLOR,WHITE,0.7);\t// view_ray line intersects a(atm) but behind us\n\tif ( te.x <= 0.0 && te.y >= 0.0 ) return GREEN; // inside (e)earth\n\n\t// sky range\n\tvec2 atm_trace_range; // range segment we integrate things on along view_ray\n\n\tif ( te.x == FLT_MAX ) atm_trace_range = vec2( max( 0.0, ta.x ), ta.y ); // view_ray line intersects a, doesn't intersect e\n\t// view_ray line intersects a and e\n\telse if ( ta.x > 0.0 ) atm_trace_range = vec2( ta.x, te.x ); // ray hitting a from outside atm\n\telse if ( te.x > 0.0 ) atm_trace_range = vec2( 0.0, te.x ); // ray hitting e from inside atm\n\telse atm_trace_range = vec2( 0.0, ta.y ); // ray hitting a from inside atm\n\n\tif ( atm_trace_range.y - atm_trace_range.x < 0.0 ) return YELLOW; // should never happen\n\n\t// we also set this once more after the loop, here it is set in case we early return for debug but still want the normal\n\tif ( atm_out.earth_surface ) atm_out.earth_n = normalize( view_ray.o + view_ray.d * te.y - earth_center );\n\n\tRay sun_ray;\n\tsun_ray.d = sun_direction;\n\n\tvec3 p;\n\tintegration_t tppc = integration_init(); // the last of those is a earth hit -> sun ray when earth_surface is true\n\tintegration_t tppa = integration_init(); // the last of those is a earth hit -> eye ray when earth_surface is true\n\tintegration_t Iv_sum = integration_init();\n\t\n\tfloat tp = atm_trace_range.x;\n\tfloat atm_trace_step0 = ( atm_trace_range.y - atm_trace_range.x ) / float( num_view_ray_segments );\n\tfloat atm_trace_step = atm_trace_step0;\n\n\tfloat cloud_step = 0.0; // total budget for stepping inside clouds\n\tfloat cloud_t = first_cloud_t;\n\n\tbool global_cloud_trace_active = ( first_cloud_t > 0.0 && first_cloud_t != FLT_MAX && cloud_trange.y != 0.0 );\n//\tif ( global_cloud_trace_active ) return WHITE;\n\tbool global_cloud_trace_active0 = global_cloud_trace_active;\n\n\tfloat longpath2 = smoothstep( elev_earth_horizon - radians( 5.0 ), elev_earth_horizon, elev_view_vector );\n\n\tfor ( int i = 0; i < num_view_ray_segments + 1; ++i )\n\t{\n\t\tp = view_ray.o + view_ray.d * tp;\n\t\tp = earth_center + normalize( p ) * max( earth_radius * 1.00001, length( p ) ); // make sure we don't start inside the earth when p is a hit point\n\t\tvec3 rho = calc_rho_atm_only( p );\n\n\t\tif ( !in_earth_shadow( p, sun_direction ) )\n\t\t{\n\t\t\tsun_ray.o = p;\n\t\t\tvec2 ta_sun = sphere_trace( sun_ray, earth_radius + atm_max, earth_center );\n\t\t\ttppc = opticalDepth2( sun_ray, 0.0/*p*/, ta_sun.y/*pc*/, b ); // note: ta_sun.y > 0.0\n\t\t\tvec9 tmp;\n\t\t\tvec3 tr = exp( -tppc.sum.r - tppa.sum.r\n\t\t\t\t\t\t   - tppc.sum.m - tppa.sum.m\n\t\t\t\t\t\t   - tppc.sum.c - tppa.sum.c );\n\t\t\ttmp.r = rho.x * tr;\n\t\t\ttmp.m = rho.y * tr;\n\t\t\ttmp.c = rho.z * tr;\n\t\t\tadd_vec9( Iv_sum, tmp, atm_trace_step );\n\t\t}\n\n\t\tadd_vec9( tppa, mkvec9( rho ), atm_trace_step );\n#if 1\n\t\tif ( global_cloud_trace_active && tp > cloud_t )\n\t\t{\n\t\t\tbool local_cloud_trace_active = global_cloud_trace_active;\n\n\t\t\tfloat cloud_limit_this_step = min( tp + atm_trace_step, cloud_trange.y );\n\n\t\t\tfloat max_cloud_steps = min_max_cloud_steps; // affects horizon mostly (the noisy glitter artifact)\n\n#if NICER_HORIZON == 1\n// most of our problems are in that range, we need more res\n\t\t\tif ( !hits_earth ) max_cloud_steps = max_max_cloud_steps * 2.;\n#elif NICER_HORIZON == 2\n// second attempt with smoother transition\n\t\t\tmax_cloud_steps = mix( max_cloud_steps, max_max_cloud_steps * 2., longpath2 );\n#endif\n\t\t\t// cloud trace catch up\n\t\t\tfor (; cloud_step < max_cloud_steps\n\t\t\t\t  && local_cloud_trace_active\n\t\t\t\t  ; cloud_step += 1.0 )\n\t\t\t{\n\t\t\t\tvec3 p2 = view_ray.o + cloud_t * view_ray.d;\n\n\t\t\t\t//if ( length( p2 ) - earth_radius < cloud_start ) return RED; // should ne noise or nothing\n\n\t\t\t\tvec2 d = getCloudDensityAndDistance( p2, b, cloud_animation_params, aChannel0 );\n\t\t\t\tfloat density = d.x;\n\t\t\t\tfloat dist = d.y;\n\n\t\t\t\t// just trace the whole space always, give more steps to closest bits\n\t\t\t\tfloat cloud_step_left = max_cloud_steps - cloud_step;\n\t\t\t\tfloat cloud_t_left = cloud_trange.y - cloud_t;\n\t\t\t\tfloat cloud_dt = mix( abs( dist ), cloud_t_left / cloud_step_left\n\t\t\t\t\t\t\t\t\t  , cloud_step / max_cloud_steps );\n\n\t\t\t\tif ( cloud_t + cloud_dt >= cloud_limit_this_step )\n\t\t\t\t{\n\t\t\t\t\tlocal_cloud_trace_active = false;\n\t\t\t\t\tcloud_dt = cloud_limit_this_step - cloud_t;\n\t\t\t\t}\n\n\t\t\t\tif ( !in_earth_shadow( p2, sun_direction ) )\n\t\t\t\t{\n\t\t\t\t\tsun_ray.o = p2;\n\t\t\t\t\tfloat sun_cloud_tmax = getCloudTraceRange( sun_ray ).y * sun_cloud_tmax_hack;\n\t\t\t\t\tintegration_t tppc2 = opticalDepth3( sun_ray, sun_cloud_tmax/*pc*/, b, uv\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ,\n#if NICER_HORIZON == 1\n// since we have double the res we half steps on sun direction scattering\n// we get most of the perf back + it gives a bit of fade out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t !hits_earth ? sun_ray_optical_depth_max_n * 0.5 : sun_ray_optical_depth_max_n\n#elif NICER_HORIZON == 2\n// second attempt with smoother transition\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t mix( sun_ray_optical_depth_max_n, sun_ray_optical_depth_max_n * 0.5, longpath2 )\n#else\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sun_ray_optical_depth_max_n\n#endif\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t , cloud_animation_params, aChannel0 ); // note: ta_sun.y > 0.0\n\t\t\t\t//\ttppc2.sum = mkvec9( 0.5 );\n\t\t\t\t\tvec3 tr = exp(\n\t\t\t\t\t\t-tppc2.sum.r - tppa.sum.r\n\t\t\t\t\t\t- tppc2.sum.m - tppa.sum.m // doesn't contribute\n\t\t\t\t\t\t- tppc2.sum.c - tppa.sum.c );\n\n\t\t\t\t\tadd_vec9_c( Iv_sum, vec3( density * tr ), cloud_dt );\n\t\t\t\t}\n\n\t\t\t\tadd_vec9_c( tppa, vec3( density ), cloud_dt ); // add cloud contribution\n\n\t\t\t\tcloud_t += cloud_dt;\n\t\t\t}\n\t\t}\n#endif\n\t\ttp += atm_trace_step;\n\t}\n\n\tfloat cos_theta = dot( sun_direction, view_ray.d );\n\tvec3 Iv = Is *\n\t\t( ( Iv_sum.sum.r / ( 4.0 * PI ) ) * calc_Fr_r( cos_theta ) +\n\t\t  ( Iv_sum.sum.m / ( 4.0 * PI ) ) * calc_Fr_m( cos_theta, 0.8 ) +\n\t\t  ( Iv_sum.sum.c / ( 4.0 * PI ) ) * calc_Fr_c( cos_theta ) );\n\n\tif ( atm_out.earth_surface )\n\t{\n\t\tvec3 n = normalize( p - earth_center );\n\t\tfloat cos_alpha = dot( sun_direction, n );\n\t\tvec3 Isky_div_Is = calc_Isky_div_Is_approx( safe_acos( cos_alpha ) );\n\n\t\tatm_out.earth_p = p; // note: P is the earth hit\n\t\tatm_out.earth_n = n;\n\n\t\t// note:\n\t\t// tr_ppc is the tr of earth hit -> sun ray\n\t\t// Tr_ppa is the tr of earth hit -> eye ray\n\t\tvec3 Ie = earth_diffuse_reflection\n\t\t\t* ( cos_alpha * Is * exp( -tppc.sum.r - tppc.sum.m ) + Is * Isky_div_Is );\n\t\tIv += Ie * exp( -tppa.sum.r - tppa.sum.m );\n\t}\n\telse\n\t{\n//\t\tfloat sun_visible = cos_theta > sun_cos ? 1.0 : 0.0;\n\t\tfloat sun_visible = cos_theta > ( sun_cos - 0.00001 ) ? 1.0 : 0.0; // make it bigger so we can do a lookup\n\t\tIv += Is * exp( -tppa.sum.r - tppa.sum.m ) * sun_visible;\n\t}\n\n#ifdef CLAMP_IV\n\tif ( global_cloud_trace_active0\n\t\t && ( length( view_ray.o ) - earth_radius ) > cloud_start // protect below cloud views from this hack\n\t\t)\n\t{\n\t\tIv = mix( Iv, min( Iv, vec3( 0.23 ) ), longpath2 );\n\t}\n#endif\n\n\treturn Iv;\n}\n\n#define MAX_ITERATIONS 120\nfloat TMAX = 350.0;\n\nTraceOutput tracePlaneCabin( Ray ray, float soft_shadow_sharpness, float window_radius_scale )\n{\n\tfloat DBREAK = 0.0025; // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\tfloat TFRAC = 0.25;\n\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.num_iterations = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfor ( int i = 0; i < MAX_ITERATIONS; ++i )\n\t{\n\t\tfloat d = sdPlaneCabin( ray.o + to.t * ray.d, window_radius_scale );\n\t\tto.dist = d;\n\t\tif ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > TMAX ) break;\n\t\tto.shadow = min( to.shadow, soft_shadow_sharpness * to.dist / to.t ); // https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\tto.t += to.dist * TFRAC; // d can be negative... hmm\n\t\tto.num_iterations += 1.0;\n\t}\n\n\tto.shadow = max( 0.0, to.shadow ); // hide shitty artifacts\n\treturn to;\n}\n\nvec3 renderPlaneCabin( scene_params_t scene_params, vec2 uv, float aspect, float window_radius_scale\n\t\t\t\t\t   , bool skip_shading, inout bool outside_visible )\n{\n\tmat4 world_to_plane = mat4_inverse1( scene_params.plane_to_world );\n\n\tRay plane_view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / scene_params.tan_half_fovy, scene_params.plane_render_camera );\n\n\tRay plane_view_ray_plane_local = transform_ray( world_to_plane, plane_view_ray );\n\tTraceOutput to = tracePlaneCabin( plane_view_ray_plane_local, 1.0, window_radius_scale );\n\n\tbool sky = to.t > TMAX;\n\toutside_visible = sky;\n\n\tif ( skip_shading ) return CYAN; // just occlude with flat color\n\n\tvec3 p_plane_local = plane_view_ray_plane_local.o + to.t * plane_view_ray_plane_local.d;\n\tvec3 n_plane_local = gPlaneCabin( p_plane_local, window_radius_scale );\n\n\tfloat ao = 1.0;\n\t{\n\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\tfloat delta = 0.01;\n\t\tfloat a = 0.0;\n\t\tfloat bb = 1.0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\t\t\tfloat fi = float( i );\n\t\t\tfloat d = sdPlaneCabin( p_plane_local + delta * fi * n_plane_local, window_radius_scale );\n\t\t\ta += ( delta * fi - d ) * bb;\n\t\t\tbb *= 0.5;\n\t\t}\n\t\tao = max( 1.0 - 1.2 * a, 0.0 );\n\t}\n\n\tvec3 l = scene_params.sun_direction;\n\n\tfloat soft_shadow = 1.0;\n\tfloat soft_shadow_sharpness = 5.0;\n\tfloat direct_shadow = 1.0;\n\tif ( !sky )\n\t{\n\t\tRay sun_ray;\n\t\tsun_ray.o = p_plane_local + n_plane_local * 0.05;\n\t\tsun_ray.d = transform_vector( world_to_plane, l );\n\t\tTraceOutput tos = tracePlaneCabin( sun_ray, soft_shadow_sharpness, window_radius_scale );\n\t\tsoft_shadow = tos.shadow;\n\t\tdirect_shadow = tos.t > TMAX ? 1.0 : 0.0;\n\t}\n\tfloat shadow = mix( soft_shadow, direct_shadow, 0.05 );\n\n\tvec3 v = plane_view_ray.d; // same orientation has world space\n\tvec3 n = transform_vector( scene_params.plane_to_world, n_plane_local );\n\n\tvec3 sky_color = vec3( 0.3, 0.4, 0.5 ) * 0.3; // todo: pick this color from BufB\n\n\tvec3 albedo = vec3( 1.0, 0.917, 0.866 );\n\talbedo *= albedo;\n\n\tif ( sky ) return sky_color;\n\n\tvec3 col = vec3( 0 );\n#if 1\n\tfloat f = smoothstep( -0.707, 0., dot( n, scene_params.plane_to_world[1].xyz ) );\n\t// sky lobe\n\tcol += f * SGDiffuseFitted( MakeSG( sky_color * 1.17 * 0.1, vec3( 0, 0, 1 ), 2.133 ), n, albedo );\n\t// cloud lobe\n\tcol += f * SGDiffuseFitted( MakeSG( vec3( 0.05, 0.05, 0.05  ) * 1.17, vec3( 0, 0, -1 ), 2.133 ), n, albedo );\n\t// cabin light lobe\n\tcol += ( 1.0 - f ) * SGDiffuseFitted( MakeSG( vec3( 0.05, 0.05, 0.05  ) * 0.2 * 1.17, -scene_params.plane_to_world[1].xyz, 2.133 ), n, albedo );\n\t// direct sun light\n\tvec3 kdiffuse_kspecular_roughness = vec3( 0.4, 0.2, 0.8 );\n\tcol += shadow * add_light_contrib( albedo, l, n, -v, sun_Ls * 0.1, 1.0, kdiffuse_kspecular_roughness );\n#endif\n\tvec3 l_plane_local = transform_vector( world_to_plane, l );\n\tfloat window_glow_d = sdPlaneWindowVolume( p_plane_local + l_plane_local * 0.2 * iSlider5, window_radius_scale );\n\tfloat window_glow = exp( -10.0 * max( 0., -window_glow_d ) );\n\tcol += vec3( window_glow ) * 0.21 * sky_color;\n\n\treturn col;\n}\n\n// sun center uv so we can lookup in bufB\nvec2 getSunCenterUV( mat4 camera, vec3 sun_direction, float tan_half_fovy, float aspect )\n{\n\tvec3 v = sun_direction;\n\tv = vec3( dot( camera[0].xyz, v ),\n\t\t\t  dot( camera[1].xyz, v ),\n\t\t\t  dot( camera[2].xyz, v ) );\n\tv = normalize( v );\n\tfloat d = 1.0 / tan_half_fovy;\n\tvec3 P = vec3( 0, 0, -d );\n\tvec3 n = vec3( 0, 0, 1 );\n\tvec3 O = vec3( 0, 0, 0 );\n\tfloat alpha = dot( P - O, n ) / dot( v, n );\n\tvec3 I = O + alpha * v;\n\tI.x /= aspect;\n\treturn ( I.xy + vec2( 1.0, 1.0 ) ) * 0.5;\n}\n\nvec3 calcCloudsAndSky_bufB( vec2 fragCoord, float aTime, vec3 aResolution, vec4 aMouse, sampler2D aChannel0 )\n{\n#ifndef CLOUD_AND_SKY_AS_DOWNSIZED_BUFFER\n\treturn RED;\n#else\n\n\tif ( fragCoord.xy == ( aResolution.xy - vec2( 0.5, 0.5 )) ) return aResolution; // write the resolution we think we have in a volunteer pixel (top right pixel of bufB)\n\n\tfloat aspect = aResolution.x / aResolution.y;\n\tvec2 uv = fragCoord.xy / aResolution.xy;\n\n\tif ( uv.x > CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE ||\n\t\t uv.y > CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE ) return RED;\n\n\tuv *= ( 1.0 / CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE );\n\n\tscene_params_t scene_params = getSceneParams( aTime, aResolution, aMouse );\n\tRay view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / scene_params.tan_half_fovy, scene_params.camera );\n\tvec2 cloud_trange = getCloudTraceRange( view_ray );\n\n\tvec3 col = vec3(0.0);\n\tAtmOut atm_out;\n\n\tbool outside_visible = true;\n\n\tif ( scene_params.enable_cabin_view == 1 )\n\t{\n\t\tfloat window_radius_scale = 1.2 * WINDOW_RADIUS_SCALE;\n\n\t\tbool skip_shading = true;\n\t\t// render window to get occlusion\n\t\tcol = renderPlaneCabin( scene_params, uv, aspect, window_radius_scale, skip_shading, outside_visible );\n\t}\n\n\tfloat first_cloud_t = FLT_MAX;\n\n\tif ( enable_solid_clouds == 1 )\n\t{\n\t\t// trace to find the first hit distance\n\t\tTraceOutput to = traceClouds( view_ray, scene_params.b, cloud_trange, scene_params.cloud_animation_params, aChannel0 );\n\t\tif ( to.t < cloud_trange.y ) first_cloud_t = to.t;\n\t\tif ( uv.x > 0.5 && enable_solid_clouds_half_screen == 1 ) return to.t > cloud_trange.y ? BLUE * 0.5 : ( gForClouds( view_ray.o + to.t * view_ray.d, scene_params.b, scene_params.cloud_animation_params, aChannel0 ) + 1.0 ) * 0.5;\n\t}\n\n\tif ( enable_sky_and_clouds == 1 )\n\t{\n\t\tif ( outside_visible ) // shameless culling of cloud work when outside_visible is false\n\t\t{\n\t\t\tcol = atmEval_WithClouds( view_ray, atm_out, scene_params.sun_direction, scene_params.b, uv\n\t\t\t\t\t\t\t\t\t  , first_cloud_t, cloud_trange, scene_params.cloud_animation_params, aChannel0 );\n\t\t}\n\t}\n\n\treturn col;\n\n#endif\n}\n\nfloat flare_noise1s( float x, float cut )\n{\n\tx -= 0.5;\n\tfloat x0 = floor( x );\n\tfloat y0 = hash11( x0 );\n\tfloat y1 = hash11( x0 + 1.0 );\n\tfloat y = mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n\treturn y;\n}\n\nfloat calcFallOff( float sd, float r, float p1, float p2 )\n{\n\tfloat sd_last = sun_cos - r; //length of rays\n\tfloat g = 1.0 - saturate( max( sun_cos - sd, 0.0 ) / ( sun_cos - sd_last ) );\n\treturn powerful_scurve( g, p1, p2 );\n}\n\nvoid add_sun_glow_and_flares( inout vec3 col, Ray view_ray, Ray center_view_ray\n\t\t\t\t\t\t\t  , scene_params_t scene_params, bool outside_visible, vec3 real_sun_color, float aTime )\n{\n\tfloat sd = dot( view_ray.d, scene_params.sun_direction ); // assumes sun very far... view_ray.d needs renormalize for some obscure reason\n\tfloat sd_center = dot( center_view_ray.d, scene_params.sun_direction ); // assumes sun very far... view_ray.d needs renormalize for some obscure reason\n\n\tvec3 n = normalize( view_ray.o );\n\tvec3 x = normalize( cross( scene_params.sun_direction, n ) );\n\tvec3 y = cross( x, scene_params.sun_direction );\n\tfloat theta = safe_acos( sd );\n\tvec2 v = vec2( dot( view_ray.d, x ), dot( view_ray.d, y ) );\n\tfloat phi = calc_angle( v );\n\n\tfloat flare_attn_gradiant_angle = radians( 90.0 );\n\n\tvec3 xsum2 = vec3( 0.0 );\n\n\tfloat flare = pow2( smoothstep( 0.995, 1.0, sd_center ) );\n\n\tif ( outside_visible && ( scene_params.enable_sun_flares == 1 ) )\n\t{\n\t\tfloat cut = 0.3;\n\t\tfloat phi2 = phi + safe_acos( sd_center ) * 0.4;\n\t\tvec3 spectre = spectral_zucconi6( mix( 400., 700., sin( theta * 10.0 + aTime * 0.1 ) ) );\n\t\tvec3 offset = ( 1. + 0.4 * spectre );\n\t\tfloat nn = flare_noise1s( phi2 * 14., cut );\n\t\tnn = 0.0 + smax_pol( nn - cut, 0.0, 0.2 ) / ( 1. - cut );\n\t\txsum2 += 0.85 * 0.02 * offset * nn;\n\t\txsum2 = vec3( smoothstep( 0.0, 0.4, xsum2 ) * 4.0 ) * offset; // higher contrast?\n\t\txsum2 *= vec3( smoothstep( 1.0, 20., degrees( theta ) ) ); // fade out center\n\n\t\tvec3 xsum0 = vec3( xsum2 );\n\n\t\tfloat flare_attn_grad = dot( v, unit_vector2( flare_attn_gradiant_angle ) );\n\t\tfloat flare_attn2 = 1.0 - smoothstep( -0.7, -0.24, flare_attn_grad );\n\n\t\txsum2 *= flare_attn2; // fade upper half of the lens flare\n\n\t\t// first wave of radial bumps\n\t\txsum2 += vec3( smoothbump( ( radians( 25. + noise1s( phi ) * 6. ) ),\n\t\t\t\t\t\t\t\t   (  radians( 3. + noise1s( phi ) * 3. ) )\n\t\t\t\t\t\t\t\t   , ( theta ) ) * xsum0 * mix( 5., 20.0, flare ) ) * flare_attn2;\n\n\t\t// second wave of radial bumps\n\t\txsum2 += vec3( smoothband( theta, radians( 50.0 ), radians( 54.0 ), radians( 2.5 ) ) * xsum0 * 4.0 ) * flare_attn2;\n\n\t\tvec3 spectral_ring = spectral_zucconi6( mix( 400., 700., smoothstep( radians( 27.0 ),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t radians( 35.0 ), theta ) ) )\n\t\t* stripes( phi, radians( 1.2 ), radians( 0.2 ), radians( 0.2 ) );\n\t\txsum2 += spectral_ring * 0.02 * flare;\n\t}\n\n\txsum2 *= 0.8;\n\txsum2 *= 1. - smoothstep( radians( 60. ), radians( 71. ), theta ); // fade lens flare below and behind\n\n\tvec3 xsum1 = vec3( 0.0 );\n\n\tif ( outside_visible && ( scene_params.enable_sun_glare == 1 ) )\n\t{\n\t\t// sun glow\n\t\txsum1 += calcFallOff( sd, 0.005, 3.0, 0.32 );\n\n\t\t{\n\t\t\t// sun glow peaks (todo: cull)\n\t\t\tvec2 sc_v = unit_vector2( phi ) * theta;\n\t\t\tfloat gs = calcFallOff( sd, 0.004, 3.0, 0.9 );\n\t\t\tfloat n = 5.0;\n\t\t\tvec2 sv0 = unit_vector2( 2.0 * PI / n );\n\t\t\tvec2 sv = sv0;\n\t\t\tfor ( float i = 0.0; i < n; i += 1.0 )\n\t\t\t{\n\t\t\t\tfloat vv0 = dot( sc_v, sv );\n\t\t\t\tfloat vv1 = dot( sc_v, perp( sv ) );\n\t\t\t\tfloat vv = abs( vv0 );\n\t\t\t\tvv /= PI;\n\t\t\t\tvv *= 0.4;\n\t\t\t\txsum1 += exp( -vv * 1500.0 ) * gs * 0.04 * ( vv1 > 0.0 ? 1.0 : 0.0 );\n\t\t\t\tsv = rotate_with_unit_vector( sv, sv0 );\n\t\t\t\t//break;\n\t\t\t}\n\t\t}\n\t}\n\n\tvec3 xsum = vec3( 0.0 );\n\txsum += xsum2;\n\txsum += xsum1\n#ifdef USE_REAL_SUN_COLOR\n\t\t* real_sun_color // use sun color\n#endif\n\t;\n\n\tcol += xsum;\n}\n\nvec3 calcFinalImage( vec2 fragCoord, float aTime, vec3 aResolution, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tfloat aspect = aResolution.x / aResolution.y;\n\tvec2 uv = fragCoord.xy / aResolution.xy;\n\n\tscene_params_t scene_params = getSceneParams( aTime, aResolution, aMouse );\n\tvec2 sun_center_uv = getSunCenterUV( scene_params.camera, scene_params.sun_direction, scene_params.tan_half_fovy, aspect );\n\tRay view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / scene_params.tan_half_fovy, scene_params.camera );\n\tRay center_view_ray = get_view_ray2( vec2( 0.0 ), aspect, 1.0 / scene_params.tan_half_fovy, scene_params.camera );\n\tvec2 cloud_trange = getCloudTraceRange( view_ray );\n\n\tvec3 col = vec3(0.0);\n\tAtmOut atm_out;\n\n\tbool outside_visible = true;\n\n\tif ( scene_params.enable_cabin_view == 1 )\n\t{\n\t\tfloat window_radius_scale = 1.0 * WINDOW_RADIUS_SCALE;\n\n\t\tbool skip_shading = false;\n\n\t\tcol = renderPlaneCabin( scene_params, uv, aspect, window_radius_scale, skip_shading, outside_visible );\n\t}\n\n\tfloat first_cloud_t = FLT_MAX;\n\n#ifndef CLOUD_AND_SKY_AS_DOWNSIZED_BUFFER\n\n\tif ( enable_solid_clouds == 1 )\n\t{\n\t\t// trace to find the first hit distance\n\t\tTraceOutput to = traceClouds( view_ray, scene_params.b, cloud_trange, scene_params.cloud_animation_params, aChannel0 );\n\t\tif ( to.t < cloud_trange.y ) first_cloud_t = to.t;\n\t\tif ( uv.x > 0.5 && enable_solid_clouds_half_screen == 1 ) return to.t > cloud_trange.y ? BLUE * 0.5 : ( gForClouds( view_ray.o + to.t * view_ray.d, scene_params.b, scene_params.cloud_animation_params, aChannel0 ) + 1.0 ) * 0.5;\n\t}\n\n#endif\n\n\tvec3 real_sun_color = vec3( 1. );\n\n\tif ( enable_sky_and_clouds == 1 )\n\t{\n#ifndef CLOUD_AND_SKY_AS_DOWNSIZED_BUFFER\n\n\t\tif ( outside_visible )\n\t\t{\n\t\t\tcol = atmEval_WithClouds( view_ray, atm_out, scene_params.sun_direction, scene_params.b, uv\n\t\t\t\t\t\t\t\t\t  , first_cloud_t, cloud_trange, scene_params.cloud_animation_params, aChannel0 );\n\t\t}\n#else\n\t\tif ( sun_center_uv == saturate( sun_center_uv ) )\n\t\t{\n\t\t\t// if the sun is visible-ish read the value from its center in bufB\n\t\t\tfloat a = ( 1.0 / aspect );\n\t\t\tfloat b = 2.0 / aResolution.x;\n\t\t\tfloat fade = ( ( 1.0 - smoothstep( 0.5 - b, 0.5, abs( uv.x - 0.5 ) ) ) *\n\t\t\t\t\t\t   ( 1.0 - smoothstep( a * 0.5 - b, a * 0.5, abs( uv.y * a - a * 0.5 ) ) ) );\n\t\t\treal_sun_color = mix( real_sun_color, texture( aChannel1, sun_center_uv * CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE ).xyz, fade ); // calcCloudsAndSky_bufB\n\t\t}\n\n\t\tif ( outside_visible )\n\t\t{\n\t\t#if 0\n\t\t\tcol = texture( aChannel1, uv* CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE ).xyz; // calcCloudsAndSky_bufB\n\t\t#else\n\t\t\t// perform a manly edge clamp as we only use downsize area and we have garbage RED on borders\n\t\t\tvec2 x = ( fragCoord.xy * CLOUD_AND_SKY_AS_BUFFER_DOWWNSCALE - vec2( 0.5 ) );\n\t\t\tvec2 f = fract( x );\n\t\t\tivec2 p00 = ivec2( floor( x ) );\n\t\t\tivec2 edge = ivec2( aResolution.xy / 2.0 ) - ivec2( 1, 1 );\n\t\t\tvec3 c00 = texelFetch( aChannel1, clamp( p00 + ivec2( 0, 0 ), ivec2( 0, 0 ), edge ), 0 ).xyz;\n\t\t\tvec3 c10 = texelFetch( aChannel1, clamp( p00 + ivec2( 1, 0 ), ivec2( 0, 0 ), edge ), 0 ).xyz;\n\t\t\tvec3 c01 = texelFetch( aChannel1, clamp( p00 + ivec2( 0, 1 ), ivec2( 0, 0 ), edge ), 0 ).xyz;\n\t\t\tvec3 c11 = texelFetch( aChannel1, clamp( p00 + ivec2( 1, 1 ), ivec2( 0, 0 ), edge ), 0 ).xyz;\n\t\t\tcol = mix( mix( c00, c10, f.x ), mix( c01, c11, f.x ), f.y );\n\t\t#endif\n\t\t\tif ( uv.x > 0.5 && ( enable_solid_clouds_half_screen == 1 ) ) return col;\n\t\t}\n#endif\n\t}\n\n//\tcol = mix( col, GREEN, smoothbump( get_horizon_elevation( earth_center, earth_radius, view_ray.o ), 1e-2, get_ray_elevation( earth_center, view_ray ) ) ); // show the horizon\n\n\tif ( ( scene_params.enable_sun_flares == 1 ) || ( scene_params.enable_sun_glare == 1 ) )\n\t{\n\t\tadd_sun_glow_and_flares( col, view_ray, center_view_ray, scene_params, outside_visible, real_sun_color, aTime );\n\t}\n\n\tcol = tonemap_reinhard( col, iExposure );\n//\tcol = max( vec3( 0 ), contrast( col, vec3( 1.05 ) ) );\n\tcol *= 0. + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); // vignette\n//\tcol = gamma_correction( col );\n\tcol = gamma_correction_itu( col );\n\tcol *= scene_params.fade;\n\t\n\treturn col;\n}\n\n#define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = calcCloudHeightMap_bufA( fragCoord, iResolution, iFrame, iMouse, iChannel0, iChannel1 ); }\n#define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4( calcCloudsAndSky_bufB( fragCoord, iTime, iResolution, iMouse, iChannel0 ), 1.0 ); }\n#define IMAGE void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4( calcFinalImage( fragCoord, iTime, iResolution, iMouse, iChannel0, iChannel1 ), 1.0 ); }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "BUFFERA",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "BUFFERB",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}