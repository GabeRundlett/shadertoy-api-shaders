{
    "Shader": {
        "info": {
            "date": "1669024339",
            "description": "个人练习",
            "flags": 0,
            "hasliked": 0,
            "id": "cslSDM",
            "likes": 2,
            "name": "Sphere&Camera",
            "published": 3,
            "tags": [
                "3d",
                "camera"
            ],
            "usePreview": 0,
            "username": "CodeJUN",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "#define TMIN 0.1\n#define TMAX 20.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//球体\n{\n    return length(p) - 1.5 ;\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)//射线方向和源头\n{\n    float t=TMIN;\n    for(int i=0;i<RAYMARCH_TIME &&t<TMAX;i++)\n    {\n        vec3 p=ro+t*rd;\n        float d=sdfSphere(p);\n        if(d<PRECISION)\n        {\n            //return t;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//光照\n{\n    const float h=0.0001;;\n    const vec2 k= vec2 (1,-1);\n   return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//摄像机围绕球体旋转\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\nvec3 render(vec2 uv )\n{\n    vec3 color =vec3(.05);\n    vec3 ro =vec3 (2.*cos(iTime),1.,2.*sin(iTime));//球体旋转\n    if(iMouse.z>0.001)//鼠标控制\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),1.+0.2*cos(iTime),2.*sin(theta));\n    }\n    vec3 ta=vec3(0.);\n    mat3 cam=setCamera(ta,ro,0.);\n    vec3 rd =normalize(cam*vec3 (uv,1.));\n    float t=rayMarch(ro,rd);\n    if(t<TMAX)\n    {\n        vec3 p=ro+t*rd;\n        vec3 n= calcNormal(p);\n        vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//光线移动\n        //vec3 light =vec3 (2.,2.,2.);\n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//环境灯光亮度\n\n        color=amd*vec3(0.05)+dif*vec3(.6);\n\n    }\n    return sqrt(color);//幂\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            color += render(uv);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}