{
    "Shader": {
        "info": {
            "date": "1720482593",
            "description": "Most of this is reused from the forked shader, with u transformed to work with 2 points anywhere in space. Should be good for muscles! Thanks to iq for the display code.",
            "flags": 0,
            "hasliked": 0,
            "id": "X3KSWG",
            "likes": 11,
            "name": "Uneven Egg Segment - Distance",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "sdf",
                "line",
                "circle",
                "distance",
                "segment",
                "capsule",
                "egg",
                "moss",
                "vesica"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "float sdUnevenEggSegment(vec2 u, vec2 p, vec2 q, float rp, float rq, float tc) \n{    \n    u -= p; q -= p;\n    float h = length(q);\n    u *= mat2(q.y, -q.x, q.x, q.y) / h;\n    q = vec2(0, h);    \n    u.x = abs(u.x); \n    float rprq = rp - rq;\n    if (h <= abs(rprq)) return min(length(u)-rp, length(u-q)-rq);     \n    float a = mix(asin(rprq / h) + .001, 1.570796, tc);\n    vec2 dira = vec2(cos(a), sin(a));\n    vec2 e = q + rq * dira;   \n    vec2 f = e - rp * dira;  \n    vec2 eq = e - q;\n    float t = dot(e-f/2., f) / dot(eq, f);\n    vec2 w = e - eq * t;\n    float k = dot(u, vec2(w.y, -w.x));\n    if (k < 0.)          return length(u)   - rp;  \n    if (k > h*(u.x-w.x)) return length(u-q) - rq;  \n                         return length(u-w) - rq * abs(t);\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    vec2 m = (2.*iMouse.xy-R)/R.y;\n         u = (u+u-R)/R.y;\n         \n    float t = iTime;    \n         \n    // --- Parameters ---\n    vec2 p = vec2(.3*cos(t), .5*sin(.32*t));       // point p\n    vec2 q = vec2(.5*sin(.42*t), .5*cos(.52*t));   // point q\n    float rp = .2 + .2 * sin(.8*t);                // p radius > 0\n    float rq = .2 + .16 * cos(.9*t);               // q radius > 0\n    \n    // 0 <= tc <= 1\n    // tc = 0 -> tangent, \n    // tc = 1 -> containing circle\n    float tc = .5 + .5 * (.6+.4*sin(.3*t))*cos(t); \n    // ------------------\n\n    float d = sdUnevenEggSegment(u, p, q, rp, rq, tc);   \n      \n\t// Coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdUnevenEggSegment(m, p, q, rp, rq, tc);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(u-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(u-m)-0.015));    \n    }\n\n\to.rgb = col;\n    \n    // Debug\n    d = min(length(u-p), length(u-q));   \n    o += smoothstep(-2./R.y, 2./R.y, .02 - d);\n    \n    d =  min(abs(length(u-p)-rp), abs(length(u-q)-rq));\n    o.r += .5 * smoothstep(-2./R.y, 2./R.y, .006 - d);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}