{
    "Shader": {
        "info": {
            "date": "1698855568",
            "description": "Implementation of Shell Texturing using a SDF, with technique described by Acerola: https://www.youtube.com/watch?v=9dr-tRQzij4\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DsyBWd",
            "likes": 5,
            "name": "Shell Texturing (grass)",
            "published": 3,
            "tags": [
                "grass",
                "fur",
                "shell",
                "acerolafurrychallenge"
            ],
            "usePreview": 0,
            "username": "Falken",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "// a simple implementation of Shell Texturing, as described by Acerola: https://www.youtube.com/watch?v=9dr-tRQzij4\n// coded by Michael Tedder (@_falken / brs^bas)\n//\n// uses SDFs for each layer in place of drawing multiple quads.\n// for a slightly better demo, see: https://www.shadertoy.com/view/dlVyWm\n// (not terribly optimized due to lack of time, sorry!)\n//\n// hat tips to:\n// 1. sdf/lighting: https://www.shadertoy.com/view/stcGRX\n// 2. noise: https://www.shadertoy.com/view/4dS3Wd\n\n// feel free to tweak any of these values below:\nconst int kSubsampleFactor = 1;         // sampling quality, any positive integer > 0\nconst int kNumberOfLayers = 32;         // number of shell layers, any positive integer > 0\nconst float kShellDensity = 500.0;      // detail of points in each layer, any positive value > 0\nconst float kShellLayerSpacing = 0.1;   // spacing between each layer, any positive value > 0\n\n// precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat sdBox(vec3 position, vec3 halfSize)\n{\n\tposition = abs(position) - halfSize;\n\treturn length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0);\n}\n\nfloat sdf(in vec3 position)\n{ \n\tfloat halfWidth = 0.5; \n\tfloat halfHeight = 0.001;\n\tfloat halfDepth = 0.5;\n\treturn sdBox(position, vec3(halfWidth, halfHeight, halfDepth));\n}\n\nvec3 normal(vec3 position)\n{\n\tfloat epsilon = 0.001;\n\tvec3 gradient = vec3(\n\t\tsdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n\t\tsdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n\t\tsdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n\t);\n\treturn normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection, vec3 translation)\n{\n\tint stepCount = 128 * 2;\n\tfloat maximumDistance = 5.0;\n\tfloat t = 0.0;\n\tfor (int i = 0; i < stepCount; i++) {\n\t\tif (t > maximumDistance) {\n\t\t\tbreak;\n\t\t}\n\t\tvec3 position = rayOrigin + rayDirection * t;\n\t\tfloat d = sdf(position + translation);\n\t\tif (d < 0.0001) {\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\treturn 0.0;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to)\n{\n\tvec3 forward = normalize(to - from);\n\tvec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n\tvec3 up = cross(right, forward);\n\treturn mat3(right, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat angle = 0.5 * (iTime - 8.0);\n\tvec3 cameraOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n\tvec3 cameraTarget = vec3(0.0);\n\tmat3 cameraTransform = lookAtMatrix(cameraOrigin, cameraTarget);\n\tvec3 result = vec3(0.0);\n    \n    const float layerYInc = 1.0 / float(kNumberOfLayers);\n    \n\tivec2 sampleCount = ivec2(kSubsampleFactor, kSubsampleFactor);\n\tfor (int y = 0; y < sampleCount.y; y++)\n    {\n\t\tfor (int x = 0; x < sampleCount.x; x++)\n        {\n\t\t\tvec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n\t\t\tuv = uv / iResolution.xy;\n\t\t\tuv = (uv * 2.0) - 1.0;\n\t\t\tuv.x *= iResolution.x / iResolution.y;\n\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n\t\t\trayDirection = cameraTransform * rayDirection;\n            \n\t\t\tvec3 color = vec3(0.0);\n            float layerY = 0.0;\n            for (int layerIndex = 0; layerIndex < kNumberOfLayers; ++layerIndex)\n            {\n                vec3 translation = vec3(0.0, -layerY * kShellLayerSpacing, 0.0);\n                float t = raycast(cameraOrigin, rayDirection, translation);\n                if (t > 0.0)\n                {\n                    // same style that iq uses in his shaders\n                    vec3 position = cameraOrigin + rayDirection * t;\n                    vec3 lightDirection = vec3(0.57735);\n                    vec3 n = normal(position);\n                    float diffuseAngle = max(dot(n, lightDirection), 0.0);\n\n                    // position (xz along plane) is in range [-0.5 .. +0.5] so renormalize for noise\n                    float v = noise(position.xz * kShellDensity);\n                    if (v > max(0.1, layerY)) {\n                        color = vec3(0.0, max(0.1, layerY), 0.0);\n                        color *= diffuseAngle;\n                    }\n                }\n                layerY += layerYInc;\n            }\n\t\t\t// gamma        \n\t\t\tcolor = sqrt(color);\n\t\t\tresult += color;\n\t\t}\n\t}\n\tresult /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}