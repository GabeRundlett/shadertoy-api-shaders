{
    "Shader": {
        "info": {
            "date": "1599418536",
            "description": "credit to dean_the_coder not 100% but like 90%\n10% of the credit goes to me for the edits.",
            "flags": 0,
            "hasliked": 0,
            "id": "tt2fzV",
            "likes": 1,
            "name": "ying & yang golden donutcat*fork",
            "published": 3,
            "tags": [
                "fork",
                "ying",
                "yang",
                "golden"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n    return (noise(p) + noise((p + 0.2) * 1.98) * 0.5 + noise((p + 0.66) * 4.12) * 0.25) / 1.75;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, -c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 sdDonut(vec3 p) {\n\treturn vec2(sdTorus(p, vec2(4.0, 1.4)), 1.5);\n}\n\nfloat fbmc;\nvec2 sdCream(vec3 p) {\n    float d = abs(p.y + fbmc + 0.7) - 2.3;\n\treturn vec2(max(sdDonut(p).x, -d) - 0.13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n    float dd = sdCream(p - vec3(0.0, 0.05, 0.0)).x;\n    \n    vec3 id = floor(p / 0.3);\n    \n    mat2 r = rot(noise(id) * 3.141);\n    p.xz *= r;\n    p.xy *= r;\n    p.xz *= r;\n    \n    p = mod(p, 0.3) - 0.15;\n    \n    p.xz *= r;\n    p.xy *= r;\n    p.xz *= r;\n    float d = max(sdCapsule(p, 0.3, 0.02), dd);\n    \n    return vec2(d, mod(id.x, 6.0) + mod(id.y, 6.0) + mod(id.z, 6.0) + 10.5);\n}\n\nvec2 map(vec3 p) {\n    fbmc = fbm(p * 0.6) * 2.0;\n    vec2 d = sdDonut(p) - fbm(p * 8.0) * 0.02;\n    d = min2(d, sdCream(p));\n    d = min2(d, sdSprinkles(p));\n    d = min2(d, vec2(p.y + 1.7, 3.5));\n    \n    vec3 mp = p;\n    mp.x = abs(mp.x);\n    \n    // Paws.\n    vec2 cat = vec2(length(mp - vec3(1.3, 1.4, -3.96)) - 0.2, 7.5);\n    cat = min2(cat, vec2(length(mp - vec3(1.5, 1.4, -4.00)) - 0.2, 7.5));\n    cat = min2(cat, vec2(length(mp - vec3(1.7, 1.45, -3.86)) - 0.2, 7.5));\n    cat = min2(cat, vec2(length(mp - vec3(1.5, 1.3, -3.5)) - 0.6, 6.5));\n\n    // Body\n    mp.y += (sin(iTime)+0.33*sin(iTime * 1.0)) * 0.5;\n    cat = min2(cat, vec2(sdCapsule(mp.xzy, 1.6, 3.0), 6.5));\n    \n    // Eyes.\n    cat = min2(cat, vec2(length(mp - vec3(0.8, 2.4, -2.3)) - 0.7, 5.5));\n    \n    // Ears.\n    vec3 ep = mp;\n    ep.xz *= rot(-6.5 + sin(iTime * 2.0) * 0.1);\n    float ear = length(ep - vec3(2.0, 4.0, 0.0)) - 0.8;\n    ear = max(ear, -ep.z);\n    cat.x = smin(cat.x, ear, 0.3);\n    \n    // Nose.\n    vec3 np = mp - vec3(0.0, 1.9, -2.9);\n    float nose = sdCapsule(np, vec3(0.0), vec3(0.16, 0.16, 0.0), 0.15);\n    nose = smin(nose, sdCapsule(np * vec3(-1.0, 1.0, 1.0), vec3(0.0), vec3(0.16, 0.16, 0.0), 0.15), 0.05);\n    cat = min2(cat, vec2(nose, 2.5));\n    \n    // Mouth.\n    np.x = abs(np.x);\n    np -= vec3(0.2, -0.1, -0.1);\n    float mouth = sdCappedTorus(np, vec2(-1.0, 0.0), 0.2, 0.05);\n    cat = min2(cat, vec2(mouth, -16.5));\n    \n    return min2(d, cat);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.00005, -0.00005);\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.7;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col;\n\n    // Raymarch.\n    vec3 ro = vec3(sin(iTime * 0.3) * 2.0, 4.0 + cos(iTime * 0.6) * 0.5, -12.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, 1.0, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 928.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(990.0, 7.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(-1.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Donut.\n            mat = vec3(5.5, 0.3, 0.2);\n        } else if (hit == 55) {\n            // Cream.\n            mat = vec3(1.0, 0.43, 0.85);\n        } else if (hit == 3) {\n            // Plane.\n            mat = vec3(1.53, 0.81, 0.94);\n        } else if (hit == 4) {\n            // Eyes - White\n            mat = vec3(1.8);\n        } else if (hit == 5 || hit == 98) {\n            // Eyes - Black\n            mat = vec3(9.0001);\n        } else if (hit == 6) {\n            // Cat\n            mat = vec3(15.0,55.0, 0.5);\n        } else if (hit == 7) {\n            // Paws.\n            mat = vec3(4.4, 9.4, 0.2);\n        } else if (hit >= 1) {\n            // Sprinkles!\n            vec3 c = vec3(float(hit)) + vec3(9.0, 2.0, 3.0);\n            mat = sin(floor(c * 6.0) / 999.0);\n        }\n\n        col = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col *= mat;\n        \n        if (hit == 5)\n            col += (pow(max(0.0, dot(rd, reflect(normalize(vec3(0.0, 6.0, -10.0) - p), n))), 15.0) +\n                   pow(max(0.0, dot(rd, reflect(normalize(vec3(2.0, -5.0, -10.0) - p), n))), 45.0)) * 2.0;\n        \n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = vec3(.15, 0.2, 0.25);\n    }\n\n    // Output to screen\n    col = pow(col, vec3(1)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}