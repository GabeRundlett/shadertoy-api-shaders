{
    "Shader": {
        "info": {
            "date": "1522748919",
            "description": "voxel experiment with fake ao.\nusing dist from actual distance field as a fake ao parameter.\nlooks quite good in edges but soetimes leads to bigger false dark spots on flat surfaces...",
            "flags": 0,
            "hasliked": 0,
            "id": "MsVczV",
            "likes": 56,
            "name": "voxels with fake ao",
            "published": 3,
            "tags": [
                "voxel",
                "ao",
                "ambientocclusion"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 3076
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// voxels with fake ao\n// using dist from actual distance field as a fake ao parameter.\n\n#define SHADOW\n//#define ONLY_VOXEL\n#define GRID_LINES\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#ifdef SHADEROO\nfloat distCar(vec3 pos)\n{\n    //return length(pos)-.5;\n    float sc = 1.;\n    vec4 q = vec4(0,0,0,1);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),iTime*.5));\n    //q=multQuat(q,axAng2Quat(vec3(1,0,0),iTime*.17));\n    vec3 pos2;\n    pos=transformVecByQuat(pos,q);\n\n    vec3 tpos=clamp(pos*sc,-.95,.95);\n    float d=texture(iChannel1,pos*sc*.5+.5).x/sc;\n    //d+=maxcomp(abs(tpos-pos));\n    d+=length(tpos-pos*sc)*.5/sc;\n    \n    return d;\n}\n#endif\n\n//vec3 light=normalize(vec3(cos(iTime),sin(iTime),sin(iTime*.17)));\nvec3 light=normalize(vec3(1,.6,.3));\n\nfloat torusDist(vec3 pos, float R, float r)\n{\n    return length(vec2(length(pos.xy)-R,pos.z))-r;\n}\n\n#define randSampler iChannel0\n\n// this is a somewhat modified version of iq's noise in shadertoy \"volcanic\"\nvec4 noise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = textureLod( randSampler, uv/256.0, 0.0);\n    vec4 v2 = textureLod( randSampler, (uv+vec2(17,7))/256.0, 0.0);\n    return mix( v1, v2, f.z );\n}\n\nfloat distTor(vec3 pos)\n{\n    vec4 q = vec4(0,0,0,1);\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),PI2*.125));\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),iTime*.5+2.));\n    pos=transformVecByQuat(pos,q);\n    \n    pos+=.100*(noise3Dv4(pos*.015).xyz-.5);\n    pos+=.050*(noise3Dv4(pos*.030).xyz-.5);\n    pos+=.025*(noise3Dv4(pos*.060).xyz-.5);\n    float d=torusDist(pos+vec3(.33,0,0),.66,.25);\n    d=min(d,torusDist((pos-vec3(.33,0,0)).xzy,.66,.25));\n    return d;\n}\n\n#ifdef SHADEROO\nfloat dist(vec3 pos)\n{\n    return fract(iTime*.1)<.5?distCar(pos):distTor(pos);\n}\n#else\n#define iMouseData vec4(0)\nfloat dist(vec3 pos)\n{\n    return distTor(pos);\n}\n#endif\n\nvec3 grad(vec3 pos, float eps)\n{\n    vec3 d=vec3(eps,0,0);\n    return vec3(\n        dist(pos+d.xyz)-dist(pos-d.xyz),\n        dist(pos+d.zxy)-dist(pos-d.zxy),\n        dist(pos+d.yzx)-dist(pos-d.yzx)\n        )/eps/2.;\n}\n\nbool checkSolid(vec3 pos)\n{\n    return dist(pos)-.002<.0;\n}\n\nbool gridStep(inout vec3 pos, inout vec3 n, vec3 grid, vec3 dir)\n{\n    float l,lmin=10000.;\n    vec3 s = sign(dir);\n    // find next nearest cube border (.00001 -> step a tiny bit into next cube)\n    vec3 next=floor(pos/grid+s*(.5+.00001)+.5)*grid; // assuming floor(x+1.)==ceil(x)\n    l=(next.x-pos.x)/dir.x; if (l>0. && l<lmin) { lmin=l; n=-vec3(1,0,0)*s; }\n    l=(next.y-pos.y)/dir.y; if (l>0. && l<lmin) { lmin=l; n=-vec3(0,1,0)*s; }\n    l=(next.z-pos.z)/dir.z; if (l>0. && l<lmin) { lmin=l; n=-vec3(0,0,1)*s; }\n    \n    pos+=dir*lmin;\n    return checkSolid((floor((pos-.5*n*grid)/grid)+.5)*grid);\n}\n\nvoid march(inout vec3 pos, vec3 dir, inout float dmin)\n{\n    float eps=.001;\n    float dtot=0.;\n    dmin=10000.;\n    float dp=dist(pos);\n    for(int i=0;i<100;i++)\n    {\n        float d=dist(pos);\n        if(d<dp) dmin=min(d,dmin);\n        dp=d;\n        d*=.8;\n        pos+=d*dir;\n        dtot+=d;\n        if(d<eps) break;\n        if(dtot>4.) { pos-=(dtot-4.)*dir; break; }\n    }\n}\n\nvoid march(inout vec3 pos, vec3 dir)\n{\n    float dmin;\n    march(pos,dir,dmin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ph=iMouse.x/iResolution.x*7.;\n    float th=-(iMouse.y/iResolution.y-.5)*3.;\n    if(iMouse.x<1.) th=-0.1;\n    if(iMouse.y<1.) ph=2.3;\n    vec3 fwd = vec3(vec2(cos(ph),sin(ph))*cos(th),sin(th));\n    vec3 right=normalize(vec3(fwd.yx*vec2(1,-1),0));\n    vec3 up=cross(right,fwd);\n    vec3 pos=-fwd*2.5*(1.-iMouseData.z*.001);\n    vec2 sc=(fragCoord/iResolution.xy-.5)*2.*vec2(1,iResolution.y/iResolution.x);\n    vec3 dir=normalize(fwd*1.6+right*sc.x+up*sc.y);\n    vec3 n;\n    vec3 grid=vec3(.05);\n    //#define MARCH\n    float ao=1.;\n    float br=1.;\n    #ifndef ONLY_VOXEL\n    if(fragCoord.x>iResolution.x*.5+(fragCoord.y-iResolution.y*.5)*.4)\n    {\n        march(pos,dir);\n        n=grad(pos,.01)*exp(-dist(pos)*20.);\n        ao*=1.-8.*max(.05-dist(pos+n*.1),0.);\n        #ifdef SHADOW\n        vec3 pos2=pos+light*.01;\n        float dmin;\n        march(pos2,light,dmin);\n        // getting dmin for soft shadow (see https://iquilezles.org/articles/rmshadows)\n        if(dist(pos2)<.01) ao *=.6 ;\n        else\n        \tao*=1.-.4*(1.-clamp(dmin/.05,0.,1.));\n        #endif\n    }\n    else\n    #endif\n    {\n        vec3 pos0=pos;\n        float bg=1.;\n        for(int i=0;i<100;i++)\n        {\n            if(gridStep(pos,n,grid,dir)) { bg=0.; break; }\n            //if(length(pos-pos0)>3.5) break;\n        }\n        \n        vec3 pf=pos/grid-floor(pos/grid);\n        vec3 pc=pos/grid-ceil(pos/grid);\n        vec3 s=sin(pos/grid*PI2*.5);\n        // marking the voxel borders\n        #ifdef GRID_LINES\n        br*=1.-.15*(dot(exp(-s*s/.05),vec3(1))-1.);\n        br*=1.-.075*(dot(exp(-s*s/.5),vec3(1))-1.);\n        #endif\n        // ao due to dist to actual distfield from voxel pos\n        ao*=clamp(.8+.25*(dist(pos)+.03)/grid.x,0.,1.);\n        // normal ao like in raymarching\n        ao*=1.-3.*max(.1-dist(pos+n*.2),0.);\n        if(bg==1.) { br=1.; ao=1.; n=vec3(0,0,1); pos=pos0+4.*dir; }\n        \n        #ifdef SHADOW\n        vec3 pos2=pos+n*.0001,n2;\n        for(int i=0;i<100;i++)\n        {\n            if(gridStep(pos2,n2,grid,light)) { ao*=.6; break; }\n        }\n        #endif\n    }\n    float fog=clamp(1.5-.5*length(pos),0.,1.);\n    //fog=1.;\n    sc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.-.3*dot(sc,sc);\n    vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n    vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n    fragColor=vec4(max(clamp(dot(n,light),-.5,1.)*.3-n*.03+.7,.0)*1.2*vec3(1.,.9,.8)*ao*fog*vign*br,1.);\n    //fragColor=vec4(vec3(ao),1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// some quaternion functions, frustum\n\n#define PI2 (3.141592653*2.)\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1) * sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 slerpQuat(vec4 q1, vec4 q2, float t)\n{\n    vec4 q3;\n    float dot = dot(q1, q2);\n\n    /*\tdot = cos(theta)\n     if (dot < 0), q1 and q2 are more than 90 degrees apart,\n     so we can invert one to reduce spinning\t*/\n    if (dot < 0.0)\n    {\n        dot = -dot;\n        q3 = -q2;\n    } else q3 = q2;\n\n    if (dot < 0.95)\n    {\n        float angle = acos(dot);\n        return (q1*sin(angle*(1.0-t)) + q3*sin(angle*t))/sin(angle);\n    } else // if the angle is small, use linear interpolation\n        return mix(q1,q3,t);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}