{
    "Shader": {
        "info": {
            "date": "1688542059",
            "description": "i've got into shadertoy again, sorry for my bad code\nyou can change INTERP_TECHNIQUE in Common and GRAD_METHOD in Image to get different kinds of results",
            "flags": 0,
            "hasliked": 0,
            "id": "DsXBz4",
            "likes": 20,
            "name": "stream of squares and circles",
            "published": 3,
            "tags": [
                "sdf",
                "shape",
                "repeat"
            ],
            "usePreview": 0,
            "username": "AShaderBeginner",
            "viewed": 279
        },
        "renderpass": [
            {
                "code": "#define rep1 0.7\n#define rep2 0.5\n#define rep rep1 + rep2\n#define r1 rep1 / 3.\n#define r2 rep2 / 3.\n\n#define PI 3.14159265359\n#define GRAD_METHOD 0\n\n// === customizable functions ===\n\n// HACK: as long as this shortly returns max/min\n// after a small positive value, nothing will visually break :)\nfloat fromsd(float x){\n#if GRAD_METHOD == 0\n    // normal\n    return smoothstep(0.02, 0.0, x);\n#elif GRAD_METHOD == 1\n    // hole\n    return smoothstep(-0.02, 0.0, x) * smoothstep(0.02, 0.0, x);\n#elif GRAD_METHOD == 2\n    // pyramid\n    return (1. - smoothstep(-0.01, 0.01, sin(20.*2.*PI*(x)))) * smoothstep(0.02, 0.0, x);\n#elif GRAD_METHOD == 3\n    // don't know how to describe this\n    return smoothstep(0.02, 0., x) + sin(20.*PI*clamp(x,-.1,.1))*abs(1./(10.*PI*x));\n#else\n    // neon, i guess\n    return clamp(0.03/max(0., x + 0.03)-0.34, 0., 1.);\n#endif\n}\n\nvec4 getcol(vec2 pos){\n    vec2 posdiff = vec2(0.25 * sin(iTime / 5.), 0.0);\n    return vec4(vec3(1.0, 0.0, 0.0) * (1. - length(pos + posdiff))\n                + vec3(0.0, 1.0, 0.0) * (1. - length(pos))\n                + vec3(0.0, 0.0, 1.0) * (1. - length(pos - posdiff)), 1.0);\n}\n\n// === main driver, for rotation and such ===\n#define halfsqrt2 0.70710678118\n#define scale 2.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= scale;\n    \n    // 45deg\n    mat2 invrot = mat2(halfsqrt2, -halfsqrt2, halfsqrt2, halfsqrt2);\n    mat2 rot    = mat2(halfsqrt2, halfsqrt2, -halfsqrt2, halfsqrt2);\n    uv = invrot * uv;\n    \n    vec2 uv_part = uv;\n    uv_part.y = mod(uv_part.y, rep);\n    vec2 uv_pos = uv - uv_part;\n    \n    float dx1 = iTime / 4.0;\n    float dx2 = iTime / 2.0;\n    vec2 cent1 = vec2(repCenter(rep1, uv_part.x - dx1) + dx1, rep1 / 2.0) + uv_pos;\n    vec2 cent2 = vec2(repCenter(rep2, uv_part.x - dx2) + dx2, rep1 + rep2 / 2.0) + uv_pos;\n    float intr1 = smoothstep(-0.3, 0.3, sin(-cent1.x * .4 + iTime));\n    float intr2 = smoothstep(0.3, -0.3, sin(-cent2.x * .2 + iTime));\n    float sd1 = sdInterpRep(rep1, r1, uv_part - vec2(dx1, rep1 / 2.0), intr1);\n    float sd2 = sdInterpRep(rep2, r2, uv_part - vec2(dx2, rep1 + rep2 / 2.0), intr2);\n    cent1 /= scale;\n    cent2 /= scale;\n    \n    cent1 = rot * cent1;\n    cent2 = rot * cent2;\n    \n    fragColor = getcol(cent1) * fromsd(sd1) + getcol(cent2) * fromsd(sd2);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define INTERP_TECHNIQUE 1\n\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdSquare(float r, vec2 pos){\n    vec2 d = abs(pos) - r;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nfloat sdCirc(float r, vec2 pos){\n    return length(pos) - r;\n}\n\nfloat sdInterp(float r, vec2 pos, float interp){\n    float interp_c = clamp(interp, 0.0, 1.0);\n#if INTERP_TECHNIQUE == 0\n    // directly interpolating the SDFs\n    return sdSquare(r, pos) * interp_c + sdCirc(r, pos) * (1. - interp_c);\n#else\n    // interpolate the square radius instead\n    return sdSquare(r * (1. - interp_c), pos) - r * interp_c;\n#endif\n}\n\n// Infinite.\n// The reason why I modulo'd everything is because the sd functions kind of\n// clash into each other.\n// Reasonable if rep > 2 * r.\nfloat sdInterpRep(float rep, float r, vec2 pos, float interp) {\n    vec2 pos_2 = vec2(mod(pos.x + rep / 2.0, rep) - rep / 2.0, pos.y);\n    return sdInterp(r, pos_2, interp);\n}\n\nfloat repCenter(float r, float x) {\n    return round(x / r) * r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}