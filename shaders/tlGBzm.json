{
    "Shader": {
        "info": {
            "date": "1649664861",
            "description": "How to build a gas giant, step by step.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlGBzm",
            "likes": 5,
            "name": "Gas Giant Animation Almas",
            "published": 3,
            "tags": [
                "animation",
                "gas"
            ],
            "usePreview": 0,
            "username": "almeynman",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "// Caosdoar 2017 (caosdoar@gmail.com)\n\n#define PI          (3.1415926535897932384626433832795)\n#define HALF_PI     (1.5707963267948966192313216916398)\n#define TWO_PI      (6.283185307179586476925286766559)\n\n\n// Spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p)\n{\n    vec2 s = sin(p);\n    vec2 c = cos(p);\n    return vec3(c.x*s.y, c.y, s.x*s.y);\n}\n\nvec2 cart2sphe(vec3 p)\n{\n    p *= inversesqrt(dot(p, p));\n    return vec2(atan(p.z, p.x), acos(p.y));\n}\n\n// Ray-sphere intersection\nfloat sphere(vec3 o, vec3 l, vec3 c, float r2)\n{\n    const float eps = 0.0001;\n    \n    float a_ = dot(l,l);\n\tvec3 p = o - c;\n    float b_ = 2.0 * dot(l,p);\n    float c_ = dot(p,p) - r2;\n    \n    float a = b_*b_-4.0*a_*c_;\n    if (a < 0.0) return -1.0;\n    a = sqrt(a);\n    float t2 = -b_ + a;\n    if (t2 < eps) return -1.0;\n    float t1 = -b_ - a;\n    float result = (t1 > eps && t1 < t2) ? t1 : t2;\n    return result * 0.5 / a_;\n}\n\nint rotl17(int v) { return (v << 17) | (v >> 15); }\n\nint hash(int x, int y, int z, int seed)\n{\n    int h = seed * 374761393;\n    h = (x ^ h) * 374761393;\n    h = (y ^ h) * 374761393;\n    h = (z ^ h) * 374761393;\n    h = (h ^ rotl17(h)) * 2246822519;\n    return h;\n}\n\nfloat noise(vec3 p, int seed)\n{\n    return float(hash(int(p.x), int(p.y), int(p.z), seed)) / 4294967296.0;\n}\n\nfloat vnoise(vec3 p, int seed)\n{\n    vec3 p0 = floor(p);\n    vec3 s = p - p0;\n    //s = s * s * (3.0 - 2.0 * s);\n    s = s * s * s * (s * (s * 6.0 - 15.0) + 10.0);\n    \n    return mix(\n        mix(\n        \tmix(noise(p0, seed), noise(p0 + vec3(1.0, 0.0, 0.0), seed), s.x),\n        \tmix(noise(p0 + vec3(0.0, 1.0, 0.0), seed), noise(p0 + vec3(1.0, 1.0, 0.0), seed), s.x),\n        \ts.y),\n        mix(\n        \tmix(noise(p0 + vec3(0.0, 0.0, 1.0), seed), noise(p0 + vec3(1.0, 0.0, 1.0), seed), s.x),\n        \tmix(noise(p0 + vec3(0.0, 1.0, 1.0), seed), noise(p0 + vec3(1.0), seed), s.x),\n        \ts.y),\n        s.z);\n}\n\nvec3 grad(vec3 p, int seed)\n{\n    return vec3(noise(p, seed), noise(p, seed + 1), noise(p, seed + 2));\n}\n\n// by: Iñigo Quilez (with small modifications for custom hash)\n// https://www.shadertoy.com/view/4dffRH\nfloat gnoise(in vec3 x, int seed)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 iu = 1.0 - u;\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = grad( p+vec3(0.0,0.0,0.0), seed );\n    vec3 gb = grad( p+vec3(1.0,0.0,0.0), seed );\n    vec3 gc = grad( p+vec3(0.0,1.0,0.0), seed );\n    vec3 gd = grad( p+vec3(1.0,1.0,0.0), seed );\n    vec3 ge = grad( p+vec3(0.0,0.0,1.0), seed );\n\tvec3 gf = grad( p+vec3(1.0,0.0,1.0), seed );\n    vec3 gg = grad( p+vec3(0.0,1.0,1.0), seed );\n    vec3 gh = grad( p+vec3(1.0,1.0,1.0), seed );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return \n        va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + \n        u.x*u.y*(va-vb-vc+vd) + \n        u.y*u.z*(va-vc-ve+vg) + \n        u.z*u.x*(va-vb-ve+vf) + \n        (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n// by: Iñigo Quilez (with small modifications for custom hash)\n// https://www.shadertoy.com/view/4dffRH\nvec4 gnoised(in vec3 x, int seed)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 iu = 1.0 - u;\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = grad( p+vec3(0.0,0.0,0.0), seed );\n    vec3 gb = grad( p+vec3(1.0,0.0,0.0), seed );\n    vec3 gc = grad( p+vec3(0.0,1.0,0.0), seed );\n    vec3 gd = grad( p+vec3(1.0,1.0,0.0), seed );\n    vec3 ge = grad( p+vec3(0.0,0.0,1.0), seed );\n\tvec3 gf = grad( p+vec3(1.0,0.0,1.0), seed );\n    vec3 gg = grad( p+vec3(0.0,1.0,1.0), seed );\n    vec3 gh = grad( p+vec3(1.0,1.0,1.0), seed );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n// Curl-noise \n// Reference\n// https://www.cct.lsu.edu/~fharhad/ganbatte/siggraph2007/CD2/content/papers/046-bridson.pdf\nvec3 curlnoise(in vec3 p, int seed)\n{\n    vec4 x = gnoised(p, seed);\n    vec4 y = gnoised(p, seed+3);\n    vec4 z = gnoised(p, seed+6);\n    return vec3(z.z - x.w, x.w - z.y, y.y - x.z);\n}\n\nvec3 noise_offset(vec3 p, float f, float s)\n{\n    p += curlnoise(p * f, 1) * s;\n    p += curlnoise(p * f, 1) * s;\n    p += curlnoise(p * f, 1) * s;\n    return p;\n}\n\n\nfloat y_equator(float y)\n{\n    return pow(abs(y), 1.0) * sign(y);\n}\n\nfloat y_noise(float y)\n{\n    y += texture(iChannel0, vec2(y * 0.05, 0.0)).x * 0.08;\n    y += texture(iChannel0, vec2(y * 0.1, 0.0)).x * 0.04;\n    y += texture(iChannel0, vec2(y * 0.2, 0.0)).x * 0.02;\n    return y;\n}\n\nvec4 swirl(vec3 p, vec3 sc, float sr)\n{\n    float t = max(0.0, 1.0 - distance(p, sc) / sr);\n    float t2 = smoothstep(0.0, 1.0, t);\n    float theta = t2 * 10.0;\n    vec4 q1 = vec4(0.0, p.x, p.y, p.z);\n    float theta_half = theta * 0.5;\n    float s = sin(theta_half);\n    float c = cos(theta_half);\n    vec4 q2 = vec4(c, s * sc.x, s * sc.y, s * sc.z);\n    vec4 q2i = vec4(q2.x, -q2.y, -q2.z, -q2.w);\n    vec4 qa = vec4(\n        q1.x*q2.x-q1.y*q2.y-q1.z*q2.z-q1.w*q2.w,\n        q1.x*q2.y+q1.y*q2.x-q1.z*q2.w+q1.w*q2.z,\n        q1.x*q2.z+q1.y*q2.w+q1.z*q2.x-q1.w*q2.y,\n        q1.x*q2.w-q1.y*q2.z+q1.z*q2.y+q1.w*q2.x);\n    vec4 q3 = vec4(\n        q2i.x*qa.x-q2i.y*qa.y-q2i.z*qa.z-q2i.w*qa.w,\n        q2i.x*qa.y+q2i.y*qa.x-q2i.z*qa.w+q2i.w*qa.z,\n        q2i.x*qa.z+q2i.y*qa.w+q2i.z*qa.x-q2i.w*qa.y,\n        q2i.x*qa.w-q2i.y*qa.z+q2i.z*qa.y+q2i.w*qa.x);\n    return vec4(q3.yzw, t2);\n    //return vec3(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n#if 1\n    vec3 cc = vec3(0.0,0.0,3.6);\n    float cam_speed = 0.1;\n    vec3 co = 3.6 * sphe2cart(vec2(cam_speed*iTime, 3.14159*0.5+0.5*sin(cam_speed*iTime))) + cc;\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,1.0,0.0)));\n    vec3 cu = normalize(cross(cr, cf));\n#else\n    vec3 cc = vec3(0.0,0.0,3.6);\n    vec3 co = vec3(0.0,2.6,3.6);\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,0.0,1.0)));\n    vec3 cu = normalize(cross(cr, cf));\n#endif\n    uv *= 3.14159 * 0.25;\n    \n    vec3 rd = normalize(cr*uv.x + cu*uv.y + cf);\n    \n    vec3 so = vec3(0.0,0.0,3.6);\n    float r = 1.0;\n    float r2 = r*r;\n    float t = sphere(co, rd, so, r2);\n    if (t > 0.0)\n    {\n        vec3 p = co + t * rd;\n        vec3 pc = p - so;\n        \n        // Bands\n        vec2 scoord_clean = cart2sphe(pc);\n        float y_clean = scoord_clean.y / PI * 2.0 - 1.0;\n        y_clean = y_equator(y_clean);\n        y_clean = y_noise(y_clean);\n        float w0_clean = sin((y_clean * HALF_PI + HALF_PI / 4.0) * 12.0f);\n        \n        // Swirls\n        float row_count = 2.0;\n        float row = round(scoord_clean.y * row_count);\n        vec3 row_rand = texture(iChannel0, vec2(row / row_count, 0.35)).rgb;\n        float swirl_size = 0.3 + 0.7 * row_rand.y;\n        float swirl_start = fract(row_rand.x * 10.0f);\n        float swirl_offset = fract(iTime * (row_rand.z * 0.9 + 0.1) * 0.03);\n        vec2 swirlc_sph = vec2((swirl_start + swirl_offset) * TWO_PI, (row + 0.5 * (1.0 - swirl_size) * (row_rand.z * 2.0 - 1.0)) / row_count);\n        vec3 swirlc = sphe2cart(swirlc_sph);\n        vec4 swirl_data = swirl(pc, swirlc, 0.9 * swirl_size * 0.5 / row_count);\n        //float h = texture(iChannel0, cart2sphe(pc + swirl_data.xyz) / PI).r;\n        float swirl_out = 1.0 - swirl_data.w;\n        pc = swirl_data.xyz;\n        \n        vec3 pc1 = noise_offset(pc, 50.0, 0.002);\n        vec3 pc2 = noise_offset(pc, 5.0, 0.02);\n        pc1 += (pc2 - pc) * 0.2;\n        pc2 += (pc1 - pc) * 0.5;\n        \n        pc2 = mix(pc2, swirl_data.xyz, swirl_data.w);\n        \n        vec2 scoord = cart2sphe(pc1);\n        float y = scoord.y / PI * 2.0 - 1.0;\n        y = y_equator(y);\n        y = y_noise(y);\n        \n        float band = (y * HALF_PI + HALF_PI / 4.0) * 12.0f;\n        float w0 = sin(band);\n        float w1 = smoothstep(-1.0, 1.0, w0) * 2.0 - 1.0;\n        float w2 = smoothstep(-1.0, 1.0, w1) * 2.0 - 1.0;\n        \n        // band force\n        float a = sin((scoord.x + w0 * 0.25) * 10.0);\n        vec3 pn = pc2 * 7.0;\n        pn += swirl_out * gnoise(pc * 20.0, 1) * 0.2;\n        vec3 ptan = cross(vec3(0.0,1.0,0.0), normalize(pc));\n        pn += swirl_out * ptan * w0_clean * 2.0;\n        \n        //pn *= 4.0;\n        float b = gnoise(pn, 1) + 0.6 * gnoise(pn * 2.0, 2) + 0.5 * gnoise(pn * 4.0, 3) + 0.4 * gnoise(pn * 8.0, 4);\n        //float c = mix(w2, 0.75 * w0_clean + 0.4 * b, abs(w0_clean));\n        float c = w2 - w0_clean * (b * 0.5 + 0.5);\n        \n        float swirl_height_dir = sign(row_rand.z - 0.5);\n        c += 0.5 * swirl_data.w * swirl_height_dir;\n        //c = clamp(c, -1.0, 1.0) - 0.2 * swirl_data.w * swirl_height_dir * b;\n        float swirl_inner = max(0.0, swirl_data.w);\n        //swirl_inner = pow(swirl_inner, 0.5);\n        c = mix(c, swirl_height_dir * b, swirl_inner);\n        //float a = gnoise(pc * 10.0, 1);\n        \n        \n        \n        fragColor = vec4(vec3(c * 0.5 + 0.5), 1.0);\n        //fragColor = vec4(vec3(swirl_data.w), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(vec3(0.1), 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}