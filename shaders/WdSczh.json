{
    "Shader": {
        "info": {
            "date": "1586234188",
            "description": "Tried to create something aesthetically pleasing while teaching myself the math for raytracing AABB's and transparent objects.\n\nI annotated every line mostly just because I felt like it, but hopefully it can help someone else who's learning this stuff.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdSczh",
            "likes": 33,
            "name": "Glass Cube",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "reflections",
                "translucency",
                "annotated"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 954
        },
        "renderpass": [
            {
                "code": "#define ABSORBTION vec3(0.1, 5.0, 2.0)\n#define IOR 1.5\n#define TIMESCALE 0.35\n#define INTERNAL_REFLECTIONS 5\n\n\nvec3 rotate ( vec3 p, vec3 r ) {\n\tp = vec3( p.x,                       p.y*cos(r.x)-p.z*sin(r.x), p.y*sin(r.x)+p.z*cos(r.x) );\t// x-axis rotation\n    p = vec3( p.x*cos(r.y)+p.z*sin(r.y), p.y,                      -p.x*sin(r.y)+p.z*cos(r.y) );\t// y-axis rotation\n    p = vec3( p.x*cos(r.z)-p.y*sin(r.z), p.x*sin(r.z)+p.y*cos(r.z), p.z \t\t\t\t\t  );\t// z-axis rotation\n    return p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return rotated vector\n}\n\n\nfloat IntersectCube ( vec3 ro, vec3 rd ) {\n    vec3 tmin = (vec3( 0.5)-ro)/rd;\t\t\t\t\t\t// distances to positive bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 tmax = (vec3(-0.5)-ro)/rd;\t\t\t\t\t\t// distances to negative bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 rmin = min(tmin, tmax);\t\t\t\t\t\t// distances to front-facing planes\n    vec3 rmax = max(tmin, tmax);\t\t\t\t\t\t// distances to back-facing planes\n    float dback  = min( min(rmax.x, rmax.y), rmax.z );\t// distance to nearest back-facing side\n    float dfront = max( max(rmin.x, rmin.y), rmin.z );\t// distance to furthest front-facing side (possible collision distance)\n    return dback>=dfront ? dfront : -1.0;\t\t\t\t// distance to front of cube (-1.0 if miss)\n}\n\n\nfloat InteriorCubeReflection ( vec3 ro, vec3 rd ) {\n    vec3 tmin = (vec3( 0.5)-ro)/rd;\t\t\t\t\t\t// distances to positive bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 tmax = (vec3(-0.5)-ro)/rd;\t\t\t\t\t\t// distances to negative bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 rmax = max(tmin, tmax);\t\t\t\t\t\t// distances to back-facing planes\n    return min( min(rmax.x, rmax.y), rmax.z );\t\t\t// distance to nearest back-facing side\n}\n\n\nfloat GetReflectance ( vec3 i, vec3 t, vec3 nor, float iora, float iorb ) {\n\tfloat cosi = dot(i,nor);\t\t\t\t\t\t\t\t\t\t\t\t\t// cosine of angle between incoming ray and normal\n    float cost = dot(t,nor);\t\t\t\t\t\t\t\t\t\t\t\t\t// cosine of angle between refracted ray and normal\n    float spr = pow( (cosi/iorb - cost/iora) / (cosi/iorb + cost/iora), 2.0 );\t// calculate r-polarized Fresnel reflectance\n    float spp = pow( (cost/iorb - cosi/iora) / (cost/iorb + cosi/iora), 2.0 );\t// calculate p-polarized Fresnel reflectance\n    return ( spr + spp ) / 2.0;\t\t\t\t\t\t\t\t\t\t\t\t\t// average polarized reflectances for unpolarized light\n}\n\n\nvec3 GetSky ( vec3 rd ) {\n    rd = rotate(rd, vec3(3.1415/4.0));\t\t\t\t\t\t\t\t\t\t\t// rotate sky (for more interesting reflections in cube)\n    vec3 room = vec3( max( max( abs(rd).x, abs(rd).y ), abs(rd).z ) );\t\t\t// draw quick 'box' (white on axes, darker 'corners')\n    room = pow( room, vec3(1.5) );\t\t\t\t\t\t\t\t\t\t\t\t// darken shadows in corners\n    if( abs(rd).x>max(abs(rd).y,abs(rd).z) ) room -= vec3(0.5,0.0,1.0);\t\t\t// paint x-axis walls green\n    if( abs(rd).y>max(abs(rd).x,abs(rd).z) ) room -= vec3(0.8,0.3,0.0); \t\t// paint y-axis walls blue\n    return room;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return sky colour\n}\n\n\nvec3 GetRenderSample ( vec3 ro, vec3 rd ) {\n\tfloat rl = IntersectCube( ro, rd );\t\t\t\t\t\t\t\t\t// find intersection distance between camera ray and cube\n    \n    if ( rl > 0.0 ) {\t\t\t\t\t\t\t\t\t\t\t\t\t// did the camera ray hit the cube?\n        \n        vec3 xyz = ro + rd*rl;\t\t\t\t\t\t\t\t\t\t\t// ray hit the cube - get intersection coordinates\n        vec3 nor = round( xyz*1.00001 );\t\t\t\t\t\t\t\t// calculate surface normal for axis-aligned unit cube\n        vec3 power = vec3(1.0);\t\t\t\t\t\t\t\t\t\t\t// attenuated contribution of light path\n        vec3 refractd = refract( rd, nor, 1.0/IOR );\t\t\t\t\t// get ray vector refracted into cube\n        vec3 reflectd = reflect( rd, nor );\t\t\t\t\t\t\t\t// get ray vector reflected off of cube\n        float refl = GetReflectance ( rd, refractd, nor, 1.0, IOR );\t// get fraction of light that is reflected\n        vec3 c = GetSky(reflectd) * refl;\t\t\t\t\t\t\t\t// calculate colour of ray reflected off surface of cube\n        power *= 1.0-refl;\t\t\t\t\t\t\t\t\t\t\t\t// attenuate influence of refracted ray\n        rd = refractd;\t\t\t\t\t\t\t\t\t\t\t\t\t// reorient camera ray along refracted ray path\n\n        for ( int i=0; i<INTERNAL_REFLECTIONS; i++ ) {\t\t\t\t\t// for each light ray traced inside of the cube...\n        \trl = InteriorCubeReflection( xyz, rd );\t\t\t\t\t\t// get length of reflected ray inside cube\n        \txyz += rd*rl;\t\t\t\t\t\t\t\t\t\t\t\t// move to new intersection coordinates\n            nor = round( xyz*1.00001 );\t\t\t\t\t\t\t\t\t// calculate surface normal for axis-aligned unit cube\n        \trefractd = refract( rd, -nor, 1.0/IOR );\t\t\t\t\t// get refracted ray direction\n        \treflectd = reflect( rd, -nor );\t\t\t\t\t\t\t\t// get reflected ray direction\n        \trefl = GetReflectance ( rd, refractd, -nor, IOR, 1.0 );\t\t// get fraction of light that is reflected\n        \tpower *= exp( -ABSORBTION * rl );\t\t\t\t\t\t\t// calculate absorbtion with Beer's Law\n            c += GetSky(refractd) * (1.0-refl) * power;\t\t\t\t\t// add light that is refracted out of cube\n            power *= refl;\t\t\t\t\t\t\t\t\t\t\t\t// attenuate influence of next reflected ray\n            rd = reflectd;\t\t\t\t\t\t\t\t\t\t\t\t// move to reflected path for next calculation\n        }\n        return c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return cube colour along camera ray\n    } else {\n    \treturn GetSky(rd);\t\t\t\t\t\t\t\t\t\t\t\t// ray missed the cube - return background colour\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\t\t\t\t\t// get camera-space position of pixel (-1 => 1)\n    uv.y *= iResolution.y/iResolution.x;\t\t\t\t\t\t\t\t// stretch y-axis to equalize length of x and y units\n    \n    vec3 campos = vec3(0.0, 0.0, -2.5);\t\t\t\t\t\t\t\t\t// set camera back -2.5 units from center of cube\n    vec3 camray = normalize( vec3(uv,1.0) );\t\t\t\t\t\t\t// get camera ray vector for camera pointed at origin (FOV = PI/2)\n    campos = rotate(campos, vec3(iTime*TIMESCALE));\t\t\t\t\t\t// rotate camera around cube\n    camray = rotate(camray, vec3(iTime*TIMESCALE));\t\t\t\t\t\t// rotate camera rays to face cube\n    \n    vec3 col = GetRenderSample( campos, camray );\t\t\t\t\t\t// get pixel colour along camera ray path\n    \n    //col = smoothstep(0.0, 1.0, col);\t\t\t\t\t\t\t\t\t// quick tonemapping - saturate colours\n    col = pow( col, vec3(0.4545) );\t\t\t\t\t\t\t\t\t\t// gamma correction\n    fragColor = vec4( col, 1.0 );\t\t\t\t\t\t\t\t\t\t// return final pixel colour\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}