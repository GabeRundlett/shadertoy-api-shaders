{
    "Shader": {
        "info": {
            "date": "1611793810",
            "description": "I came across this somewhat by accident while playing with tdhooper's SDF mesher: http://tdhooper.github.io/glsl-marching-cubes/",
            "flags": 0,
            "hasliked": 0,
            "id": "WtVyWV",
            "likes": 2,
            "name": "Octahedron SDF (not exact)",
            "published": 3,
            "tags": [
                "distancefield",
                "sdf",
                "octahedron",
                "bound"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 194
        },
        "renderpass": [
            {
                "code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    const float c = 1.73205080757; // sqrt(3)\n    return (dot(abs(p), vec3(1.0)) - s) / c;\n}\n\nSurface mapScene(in vec3 p) {\n    vec3 planeColor = vec3(mod(dot(floor(p.xz), vec2(1.0)), 2.0));\n    Surface plane = Surface(p.y + 1.0, 1.6 * planeColor, planeColor, vec3(0.0), 0.0);\n    Surface shape = Surface(sdOctahedron(p, 0.5 + 0.5 * sin(iTime)), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 8.0);\n\n    if (plane.dist < shape.dist) {\n        return plane;\n    }\n\n    return shape;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    vec3 ro = vec3(-5.0 * c, 1.0, -5.0 * s);\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = -f;\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}