{
    "Shader": {
        "info": {
            "date": "1644426429",
            "description": "i was inspired by a gif i saw in Twitter, when i tried to recreate it using raymarching i ended up with this.\nchange H value to see more variants",
            "flags": 0,
            "hasliked": 0,
            "id": "fssyWj",
            "likes": 14,
            "name": "rolling orchestra",
            "published": 3,
            "tags": [
                "loop",
                "repeat",
                "rolling"
            ],
            "usePreview": 0,
            "username": "xnio94",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "#define pi 3.14\n\n#ifdef HW_PERFORMANCE\n    #if HW_PERFORMANCE==0\n    #define AA 1.\n    #else\n    #define AA 2.   // make this 2 or 3.. for better antialiasing\n    #endif\n#else\n#define AA 1.\n#endif\n\nconst float MAXD = 100.;\nconst float MAXSHD = 3.;\nconst float MAXRD = 15.;\nfloat t;\n// 2d rotation\nvec2 rot(vec2 p, float r) {\n\tfloat c = cos(r), s = sin(r);\n\treturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\nfloat H = .4; //size of the cross sphere raduis is cqlculated based on this\n// rolling a vector u in a closed path (square of length h, in plan y=0)\n// f is the animation parametre (iTime)\nvec3 roll4(vec3 u, float h, float f)\n{\n    float s=.5;\n    float c = .03; //this add a clamping effect i think it look cooler\n    f = floor(f)+smoothstep(s,1.+c,fract(f));\n    f*=pi;\n    float b = f/pi/2.;\n    float a = b + .5;\n    a =(max(0., 2.*fract(a) - 1. ) + floor(a));  \n    b = abs(  max(0., 2.*fract(b)-1.) + floor(b)- floor(b/2.+.25)*2.);\n    u.x += (2.-h)*  (4.*abs(fract(a/2.)-.5)-1.);\n    u.z += (2.-h)*  (4.*abs(fract(b/2.)-.5)-1.);\n    u.zy = rot(u.zy,b*pi);\n    u.xy = rot(u.xy,a*pi);\n    return u;   \n}\n// rolling wheel (1/4 of a sphere)\nfloat wheel(vec3 p,float r)\n{\n    float d = length(p) - r;\n    return max(-p.z,max(-p.x,d));\n}\n// 1d-elongated cylindre\nfloat cyl(in vec3 p, in float r,in float h)\n{\n    p.x -=clamp(p.x,-h,h);    \n    vec2 d = abs(vec2(length(p.yx),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// 2d-elongated sphere \nfloat sph(in vec3 p, in float r,in float h)\n{\n    p.xz -=clamp(p.xz,-h,h);    \n    return length(p)-r;\n    vec2 d = abs(vec2(length(p.yx),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cros(in vec3 p, in float r,in float h)\n{\n    float d = min(cyl(p,r,h),cyl(p.zyx,r,h));\n    /*\n    for(int i=0;i<6;i++)\n    {\n        p.y -= r/2. + r/2.;// r*2.-.5+r/4.;\n        r/=1.4;\n        h-=r/sqrt(2.);\n        d = min(d, sph(p,r,h));\n    }\n    */\n    return d;\n}\n// surface texture\nfloat text(vec3 u)\n{\n    return  0.; //remove this to apply surface textures\n    u *= 6.28*10.;\n    //u = abs(fract(u/10.)-.5)*4.-1.;\n    u = sin(u/2.);\n    return 0.015*( u.x*u.y*u.z )  ;\n}\nvec4 opu(vec4 a,vec4 b){ return (a.x<b.x) ? a : b;}\nvec4 map(vec3 p)\n{\n    vec3 blue = normalize(vec3(.3,.4,.8));\n    vec3 q=p;\n    p.xz=mod(p.xz,4.)-2.;\n    vec2 s = (q.xz-p.xz)/4.-.5;\n\tvec3 u = p;        \n    \n    float h = H;\n    float r = (4.-h*2.)/3.14;\n    u.y-=r;\n    \n    q = u;\n    q.xz = abs(u.xz) - vec2(2.);\n    float frame = cros(q,r,h);\n    if(fract(s.x/2.+s.y/2.)>.25) frame += text(u);\n    vec4 plan = vec4(p.y,blue-.1);\n    vec4 wall = vec4(frame,blue);\n\n    float c = t*.2 +s.y+2.*s.x; //; -  0.*s.y/2.;\n    float c2 = c +1.+mod(s.x*s.y,2.); //; -  0.*s.y/2.;\n    p = roll4(u,h,c);\n    float w1 = wheel(p , r);\n    w1 += text(p);\n    p = roll4(u,h,c2);\n    float w2 = wheel(p , r);\n    //w2 += text(p);\n    vec4 wheel1 = vec4(w1, blue); \n    vec4 wheel2 = vec4(w2, blue*0.65);\n    wheel1 = opu(wheel1,wheel2);\n\n    vec4 o = opu(plan,opu(wheel1,wall));\n    o.x -= .04;//+0.01*(sin(p.x*40.)*sin(p.y*40.));\n    o.yzw = vec3(1.,.8,.9); //color \n    \n    return o;//vec4(d,1.,0.,0.);\n}\n//simple raymarch\nvec4 rayMarch(vec3 rO, vec3 rD)\n{   \n    float d = 0.;\n    vec4 D;\n    for (int i = 0; i<130 &&  d < MAXD; i++)\n    {\n        D = map(rO + rD * d);\n        //d += D.x;\n        if (D.x > .5)  d += D.x*.5;   else d += D.x;\n        if (D.x < 3e-4)  break;\n    }\n    return vec4(d, D.yzw);\n}\n\n//to learn about normal using sdf\n//https://iquilezles.org/articles/normalsSDF\n\n#define ZERO (min(iFrame,0))\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return -normalize(n);\n}\nvec3 simpleSky(vec3 p){   \n    return vec3(.5,.6,1.-p.y);\n}\n// you can learn more about soft shadows in this article https://iquilezles.org/articles/rmshadows\nfloat shadows(vec3 or, vec3 lD)\n{\n    const float k = 1.5;\n    float res = 1.;\n    float t = 0.;\n    for (int i = 0; i < 40; i++)\n    {\n        float d = map(or + lD*t).x;\n        res = min(res, .5 + d * k / t);\n        if (res < .01|| t > MAXSHD) break;\n        t += d;\n    }\n    res = max(res, 0.);\n    return smoothstep(.3, 1., res);\n}\nvec4 render(in vec2 fragCoord )\n{\n    float fov = iResolution.x;\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    uv = uv - .5;\n    uv /= fov;\n    float ww=t*.025;\n    vec3 or = vec3(cos(ww),.6+sin(ww*1.5345)*.2,sin(ww))*10.*(sin(ww*1.37)+3.);\n    //or.y = 20.;\n    //or.y-=17.5;\n    vec3 w = normalize(vec3(0.,0.,0.)-or);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rD = normalize(w*1.5+uv.x*u+uv.y*v);\n\t   \n    vec4 d = rayMarch(or, rD);\n    vec3 col = vec3(0,0,0);\n    \n    if (d.x < MAXD)\n    {\n        vec3 p = or + d.x * rD;\n    \tvec3 nrm = normal(p);\n        vec3 sun = -normalize(vec3(.4, 2., .8));\n        \n        col = vec3(dot(sun,nrm)) *d.yzw;\n        //col *= d.yzw; //colloring\n        col *= vec3(shadows(p - sun * 0.01, -sun));\n\n    }\n    else \n    {\n        col = simpleSky(rD);\n    }\n    \n    return vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    t = iTime*2.25; // globale time\n    for(float a=0.;a<AA;a++)\n        fragColor += render(fragCoord + a/AA);\n    fragColor /=AA;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}