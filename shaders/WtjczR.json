{
    "Shader": {
        "info": {
            "date": "1655027495",
            "description": "When looking at [url]https://www.shadertoy.com/view/tsBXRW[/url] again I had difficulty understanding what was going on, so here is a version that tries to simplify & explain.\n\nMouse changed degree of spiralling, 'a','l','x',and 'z' also do things.",
            "flags": 16,
            "hasliked": 0,
            "id": "WtjczR",
            "likes": 28,
            "name": "Complex Atanh Made Simple",
            "published": 3,
            "tags": [
                "complex",
                "atanh"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 513
        },
        "renderpass": [
            {
                "code": "/*\nCopyright (c) 2022 Matthew Arcus\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this \nsoftware and associated documentation files (the \"Software\"), to deal in the Software \nwithout restriction, including without limitation the rights to use, copy, modify, \nmerge, publish, distribute, sublicense, and/or sell copies of the Software, and to \npermit persons to whom the Software is furnished to do so, subject to the following \nconditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A \nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\nOR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ \n\n// Complex Atanh Made Simple, Matthew Arcus, mla, 2022\n// Draw a grid, rotate and transform with atanh.\n//\n// Complex log, and functions derived from it, like atanh,\n// produce results that have discontinuities in the imaginary\n// part, jumping between -PI and PI for clog, and -PI/2\n// and PI/2 for atanh. To hide these discontinuities, we\n// need to ensure that the colouring function produces the\n// same value for both these values, which we can do this\n// by making it periodic.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  int A = 2, B = 7; // Rotation angle is atan(B,A)\n  float alpha = 1.0;\n  if (!key(CHAR_A)) alpha += 0.618*sin(iTime);\n  vec2 ar = vec2(alpha,1.0/alpha);\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m = floor(20.0*m);\n    // Ensure A is positive\n    if (m.x < 0.0) m = -m;\n    A = max(1,int(m.x)), B = int(m.y);\n  }\n  vec2 rot = 0.5*ar.yx*vec2(float(A),-B);\n  float scale = 2.0;\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  if (!key(CHAR_X)) {\n    //z = 2.0*catanh(z);\n    z = clog(z) + 2.0*catanh(z+vec2(0,1)) + 2.0*catanh(-z+vec2(0,1));\n    z /= PI;\n  }\n  vec2 z0 = z;\n  z.y += 0.2*iTime;\n  //z.y = mod(z.y,2.0); // Check periodicity - this should have no effect\n  float px = fwidth(z.x);\n  z = cmul(rot,z); // Transform z to skewed square grid\n  px *= length(rot); // Adjust pixel width\n  z /= ar;\n  ivec2 index = ivec2(floor(z)); // Index of grid square\n\n  // Want color(rot*(x-i)) = color(rot*(x+i)) so:\n  // color(rot*x-rot*i) = color(rot*x+rot*i) so:\n  // color(z) = color(z+(B+iA)) ie.\n  // coloring function should be periodic, period B+iA.\n  // Note that we only need to repeat in one direction.\n  int k = idiv(index.y,A); // Integer divide, but fixed for -ve values\n  index -= k*ivec2(B,A);\n\n  float h = float(ihash(uint(index.x)^ihash(uint(index.y))))/pow(2.0,32.0);\n  vec3 col = getcol(h);\n  z = fract(z);\n  z *= ar;\n  z = min(z,ar-z);\n  float d = min(z.x,z.y);\n  if (!key(CHAR_L)) {\n    // Draw a pattern in each cell - just a line for now.\n    z -= 0.5*ar;\n    d = min(d,abs(z[int(h<0.5)])); // Iverson brackets are cool.\n  }\n  col *= smoothstep(-px,px,d-0.02);\n  float px0 = fwidth(length(z0));\n  if (key(CHAR_Z)) {\n    // Show borders of repeating area.\n    col = mix(vec3(1,0,0),col,smoothstep(-px0,px0,abs(abs(z0.y)-1.0)-0.01));\n  }\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_L = 76;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.14159;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\nint idiv(int a,int b) {\n  if (b < 0) { b = -b; a = -a; }\n  if (a < 0) return -((-a+b-1)/b); // Careful with bracket here!\n  else return a/b;\n}\n\nint imod(int a, int b) {\n  int d = idiv(a,b);\n  return a-d*b;\n}\n\n// iq's palette function\nvec3 pal( float t, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getcol(float t) {\n  vec3 rgb = pal(t,vec3(0.8), vec3(0.2), vec3(1), vec3(0,0.1,0.2));\n  return rgb;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}