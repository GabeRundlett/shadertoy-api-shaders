{
    "Shader": {
        "info": {
            "date": "1484513120",
            "description": "A simple sdf shadowmap example.  Still need to fix aliasing/artifact issues.",
            "flags": 32,
            "hasliked": 0,
            "id": "MlyXR1",
            "likes": 7,
            "name": "Simple Shadowmap",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "shadow",
                "spotlight",
                "multipass",
                "shadowmap"
            ],
            "usePreview": 0,
            "username": "AxleMike",
            "viewed": 1190
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         128\n#define \tAA \t\t\t\t\t\t2\n#define \tPOISSON_SAMPLING\t\t1\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 500.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\nconst float \tTORUS \t\t\t= 2.0;\nconst float \tGROUND \t\t\t= 1.0;\n\n//////////////////////////////////////////////////\n// Globals\nmat4 gLightViewMatrix;\nvec3 gLightPosition;\nvec3 gLightDirection;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfPlane(in vec3 p, in vec4 normal)\n{\n  \t// n must be normalized\n\treturn dot(p, normal.xyz) + normal.w;\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);\n    \n    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));\n    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale); \n    IntersectionData torusIntersectionData = IntersectionData(sdfTorus(p + curvePoint, vec2(2.0, 0.5)), TORUS);\n\n    return GetClosestIntersection(planeIntersectionData, torusIntersectionData);\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n\n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }   \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nmat4 CreateViewMatrix(in vec3 cameraPosition, in vec3 cameraForward, in vec3 cameraUp)\n{\n    vec3 rightAxis = normalize(cross(cameraForward, cameraUp));\n\n    mat4 viewMatrix = mat4(rightAxis.xyz, 0.0,\n\t\t\t\t\t\t   cameraUp.xyz, 0.0,\n                           cameraForward.xyz, 0.0,\n                           cameraPosition.xyz, 1.0);\n    \n    return viewMatrix;\n}\n\nvec2 CalculateShadowMapUV(in mat4 shadowMapMatrix, in vec3 position, in float aspectRatio)\n{\n    vec3 lightPosition = vec3(shadowMapMatrix[3][0], shadowMapMatrix[3][1], shadowMapMatrix[3][2]); \n    \n    vec3 lightWorldDirection = normalize(position.xyz - lightPosition);\n    vec3 shadowMapCameraRayDirection = (vec4(lightWorldDirection.xyz, 1.0) * shadowMapMatrix).xyz;\n    shadowMapCameraRayDirection /= shadowMapCameraRayDirection.z;\n    \n    vec2 textureCoords = shadowMapCameraRayDirection.xy / vec2(aspectRatio, 1.0);\n    textureCoords = textureCoords * 0.5 + 0.5;\n    \n    return textureCoords;\n}\n\nfloat SampleShadowMap(in vec2 shadowCoords)\n{\n    return texture(iChannel0, shadowCoords).r;\n}\n\nvec2 SamplePoissonDisk(in int i)\n{\n    if(i == 0) \t\t{ return vec2(-0.942016240, -0.39906216); }\n    else if(i == 1) { return vec2( 0.945586090, -0.76890725); }\n    else if(i == 2) { return vec2(-0.094184101, -0.92938870); }\n    else \t\t\t{ return vec2( 0.344959380,  0.29387760); }\n}\n\nfloat SampleShadowMap(in vec3 point, in float shadowMapBias)\n{\n\tconst float shadowMapMaxDistance = 23.0;\n    \n    float shadow = 1.0;\n    \n    vec3 pointToLight = point - gLightPosition;\n    float distanceToLight = length(pointToLight);\n    \n    vec2 shadowCoords = CalculateShadowMapUV(gLightViewMatrix, point, (iResolution.x / iResolution.y));\n    \n    if((shadowCoords.x > EPSILON && shadowCoords.y > EPSILON) && (shadowCoords.x < (1.0 - EPSILON) && shadowCoords.y < (1.0 - EPSILON)))\n    {\n#if POISSON_SAMPLING        \n        for(int i = 0; i < 4; ++i)\n        {\n            const float poissonDiskSpread = 0.00125;\n            float shadowMap = SampleShadowMap(shadowCoords + (SamplePoissonDisk(i) * poissonDiskSpread));\n            \n            float shadowMapDistance = (shadowMap * shadowMapMaxDistance);\n\n            if(shadowMapDistance < (distanceToLight - shadowMapBias))\n            {\n                shadow -= 0.25;\n            }   \n        }\n#else\n        float shadowMap = SampleShadowMap(shadowCoords);\n        float shadowMapDistance = (shadowMap * shadowMapMaxDistance);\n\n        if(shadowMapDistance < (distanceToLight - shadowMapBias))\n        {\n            shadow = 0.0;\n        }     \n#endif\n    }\n    return shadow;\n}\n\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)\n{       \n    vec3 lightToPoint = gLightPosition - point;\n    float spot = step(0.7, dot(normalize(lightToPoint), gLightDirection)) * Saturate(1.0 - length(lightToPoint) / 30.0);\n    float lighting = Saturate(dot(normal, -gLightDirection)) * spot;\n    \n    // Slope bias\n    float shadowMapBias = clamp(0.1 * tan(acos(Saturate(dot(normal, gLightDirection)))), 0.0, 0.1);\n    float shadow = SampleShadowMap(point, shadowMapBias);\n    \n    return (albedo * lighting * shadow) + (albedo * ambient);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n       \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        const float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == TORUS)\n        {\n\t\t\tdiffuse = vec3(1.0, 0.4, 0.0);\n        }\n        else if(intersection.mMaterialIndex == GROUND)\n        {\n            float tile = mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;\n            diffuse = vec3(0.5) + tile;\n        }\n        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, ambient);         \n    }\n    \n    vec3 fogColor = vec3(0.85, 0.85, 1.0);\n    float fogAmount = 1.0 - exp(-intersection.mT * 0.015);\n    finalColor = mix(finalColor, fogColor, fogAmount);\n                          \n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 finalColor = vec4(0.0);\n    \n    // Setup light\n    gLightPosition = vec3(0.0, 8.0, 0.0);\n    gLightDirection = normalize(vec3(0.0, 1.0, 0.0));\n    gLightViewMatrix = CreateViewMatrix(gLightPosition, gLightDirection, vec3(0.0, 0.0, -1.0));\n    \n    vec2 initialScreenCoord = (fragCoord.xy / iResolution.xy);\n#if (AA > 1)\n    for(int x = 0; x < AA; ++x)\n    {\n    \tfor(int y = 0; y < AA; ++y)\n        {\n    \t\tvec2 offset = vec2(float(x), float(y)) / float(AA) - 0.5; \t\n    \t\tvec2 screenCoord = ((fragCoord.xy + offset) / iResolution.xy);\n#else\n    \t\t// Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    \t\tvec2 screenCoord = (fragCoord.xy / iResolution.xy);   \n#endif\n            vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n            float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.3) : 0.0;\n            mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n            float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05; // Multiply by 0.1 to slow down the rotation ;   \n            mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n            // Determine our camera info\n            const float distanceFromOrigin = 8.0;\n            vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n            cameraPosition += vec3(0.0, 2.0, 0.0);\n            vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n            finalColor += DisplayScene(cameraPosition, cameraDirection);\n#if (AA > 1)\n    \t}\n    }\n\tfinalColor /= float(AA * AA);        \n#endif         \n\n    if(initialScreenCoord.x < 0.2 && initialScreenCoord.y > 0.8)\n    {\n        finalColor = texture(iChannel0, vec2(initialScreenCoord.x, (1.0 - initialScreenCoord.y)) * 5.0);\n    }\n\tfragColor = finalColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Alexander Lemke, 2017\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         128\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_SHADOW_MAP_DISTANCE\t\t= 23.0;\nconst float     EPSILON        \t\t\t \t= 0.001;\nconst float     PI              \t\t\t= 3.14159265359;\n\n//////////////////////////////////////////////////\n// Globals\nvec3 gCameraPosition;\nvec3 gCameraDirection;\n\n//////////////////////////////////////////////////////\n// Intersection Helpers   \nfloat GetClosestIntersection(in float a, in float b)\n{\n    if(a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdfTorus(in vec3 p, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdfPlane(in vec3 p, in vec4 normal)\n{\n  \t// n must be normalized\n  \treturn dot(p, normal.xyz) + normal.w;\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nfloat CheckSceneForIntersection(in vec3 p)\n{\n    float planeT = sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0));\n    \n    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));\n    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale);\n    float torusT = sdfTorus(p + curvePoint, vec2(2.0, 0.5));\n\n    return GetClosestIntersection(planeT, torusT);\n}\n\nfloat Intersect(in Ray initialRay)\n{    \n    float sceneIntersection = MAX_SHADOW_MAP_DISTANCE;\n    \n    float t = 0.0;   \n \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection < EPSILON || t > MAX_SHADOW_MAP_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection; // Step forward\n    }\n    sceneIntersection = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nfloat DisplayShadowMap(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection); \n    return Intersect(cameraRay);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n    // Determine our camera info\n    gCameraPosition = vec3(0.0, 8.0, 0.0);\n    gCameraDirection = normalize(vec3(aspectRatioAdjustedUVs.x, -1.0, aspectRatioAdjustedUVs.y));\n\n    float t = DisplayShadowMap(gCameraPosition, gCameraDirection, 0.4);\n    float shadowMapValue = min(t / MAX_SHADOW_MAP_DISTANCE, 1.0);\n    \n\tfragColor = vec4(vec3(shadowMapValue), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}