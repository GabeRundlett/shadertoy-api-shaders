{
    "Shader": {
        "info": {
            "date": "1607656394",
            "description": "Given two points on a sphere and two tangent vectors, construct a smooth spline (orange) out of a pair of equal-radius arcs connecting the points.\n\nHold the mouse down to show just the blue lines + orange spline. Hit S to toggle stereographic projection.",
            "flags": 16,
            "hasliked": 0,
            "id": "3dVfzc",
            "likes": 25,
            "name": "spherical arc spline",
            "published": 3,
            "tags": [
                "test",
                "spline",
                "spherical",
                "debug",
                "arc"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//\n// spherical arc spline by mattz\n//\n// License CC BY 4.0 https://creativecommons.org/licenses/by/4.0/\n//\n// Given two points on a sphere and two tangent vectors, construct\n// a smooth spline (orange) out of a pair of equal-radius arcs\n// connecting the points.\n//\n// The orange spline touches the black points, and is tangent\n// to the green arrows.\n//\n// The maroon dots are the arc centers -- each one is an equal\n// distance to the black points.\n//\n//////////////////////////////////////////////////////////////////////\n\n// light pos\nvec3 L = vec3(-0.15, 0.3, 1);\n\nconst float PI = 3.141592653589793;\nconst float EPS = 1e-3;\n\n// animation parameters\nconst float PERIOD = 30.0; // seconds per repeat\nconst float PFREQ = 5.0;\nconst float QFREQ = 1.0;\n\n// antialiasing distance\nfloat aa = 0.01;\n\n// should we draw decorations\nbool draw_extras = true;\n\n//////////////////////////////////////////////////////////////////////\n// rotate about x-axis \n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about y-axis \n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// ray-sphere intersection\n\nconst vec4 miss = vec4(-1);\n\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////\n// arclengh distance between unit vectors on sphere\n\nfloat sdist(vec3 a, vec3 b) {\n    return acos(clamp(dot(a, b), -1.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arrow at p0 with tangent l0 \n\nfloat darrow(vec3 p, vec3 p0, vec3 l0) {\n\n    float k = 0.125;\n    \n    vec3 q = cos(k)*p0 + sin(k)*l0;\n\n    vec3 a0 = normalize(cross(p0, l0));\n    vec3 l1 = normalize(cross(q, a0));\n\n    float d = abs(dot(p, a0));\n    d = max(d, -dot(p, l0));\n    d = max(d, -dot(p, l1));\n    \n    float dh = 1e5;\n    \n    for (float s=-1.0; s<=1.0; s+=2.0) {\n    \n        vec3 r = normalize(q + 0.035*s*a0 + 0.4*p0);\n    \n        vec3 l2 = normalize(cross(q, r));\n        vec3 l4 = normalize(cross(q, l2));\n        vec3 l5 = normalize(cross(r, l2));\n    \n        float d2 = abs(dot(p, l2));\n        d2 = max(d2, dot(p, l4));\n        d2 = max(d2, -dot(p, l5));\n        \n        dh = min(dh, d2);\n        d = max(d, -s*dot(p, l2));\n    \n    }\n    \n    d = min(d, dh);\n\n    return d;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// data structure to store spline\n\nstruct arc_spline {\n        \n    vec3 p0, l0, p1, l1, c0, c1, m, w;\n    float r;\n\n};\n\n//////////////////////////////////////////////////////////////////////\n// compute a spline on the sphere made of two arcs that are tangent \n// to each other have desired tangents at given points\n//\n// inputs:\n//\n//   p0: first point on sphere (unit vector)\n//   l0: tangent vector at p0 (unit vector with dot(p0, l0) = 0)\n//   p1: second point on sphere (unit vector) \n//   l1: tangent vector at p1 (unit vector with dot(p1, l1) = 0)\n//\n// output: an arc_spline\n\nvoid compute_spline(in vec3 p0, in vec3 l0,\n                    in vec3 p1, in vec3 l1,\n                    out arc_spline S) {\n                  \n    // fill in data members of spline that copy inputs\n    S.p0 = p0;\n    S.l0 = l0;\n    \n    S.p1 = p1;\n    S.l1 = l1;\n    \n    // compute the line connecting p0 & p1\n    vec3 tmp = normalize(cross(p0, p1));\n    \n    // special case: p0 and p1 are connected by a segment of a great circle\n    // the line from p0 to p1 hits them at the correct tangents \n    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < EPS) {\n        // in this case we set S.r = 0 and set S.w to be the line\n        S.w = tmp;\n        S.r = 0.0;\n        return;\n    }\n    \n    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively\n    vec3 a0 = cross(l0, p0);\n    vec3 a1 = cross(l1, p1);\n    \n    // we will construct arc centers \n    //\n    //   c0 = cos(r) * p0 + sin(r) * a0\n    //   c1 = cos(r) * p1 + sin(r) * a1\n    //\n    // which are a distance r away from p0 & p1 respectively\n    // by construction, dot(c0, l0) = dot(c1, l1) = 0\n    //\n    // now we want to solve for r such that dot(c0, c1) = cos(2*r)\n    //\n    // start by observing that \n    //\n    //   (cos(r)²       * a +\n    //    cos(r)*sin(r) * b\n    //    sin(r)²       * c) = cos(2r)\n    //\n    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and \n    // c = dot(a0, a1).\n    //\n    // applying the half angle identities and setting θ = 2r, we find\n    //\n    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)\n    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)\n    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)\n    //\n    // we can rewrite that as\n    //\n    //   d*cos(θ) + b*sin(θ) = e\n    //\n    // where d = a - c - 2 and e = -(a + c).\n    //\n    // finally, we can rewrite that as\n    //\n    //   α*cos(θ - φ) = e\n    //\n    // where α = sqrt(d² + b²) and φ = atan(b, d).\n    // the solution is given by\n    //\n    //   θ = φ ± acos(e / α)\n    //\n    // and r = 0.5 * θ.\n    \n    float a = dot(p0, p1);\n    float b = dot(p0, a1) + dot(p1, a0);\n    float c = dot(a0, a1);\n    \n    float d = (a - c - 2.);\n    float e = -(a + c);\n    \n    float alpha = length(vec2(d, b));\n    float phi = atan(b, d); // in [-pi, pi]\n    float tau = acos(e/alpha); // in [0, pi]\n\n    // we want the r with the least magnitude so choose tau with the \n    // opposite sign as phi\n    float r = 0.5 * (phi > 0. ? phi - tau : phi + tau);\n\n    // now get c0 & c1\n    float cr = cos(r);\n    float sr = sin(r);\n\n    S.c0 = normalize(cr*p0 + sr*a0);\n    S.c1 = normalize(cr*p1 + sr*a1);\n    \n    // m is the midpoint of c0 & c1, the point\n    // of mutual tangency of the two arcs\n    S.m = normalize(S.c0 + S.c1);\n    \n    // get the line connecting c0 & c1\n    S.w = normalize(cross(S.c0, S.c1));\n    \n    // no longer need the sign of r, want it positive to compute distances later\n    S.r = abs(r);\n    \n    // choose w to point towards p0\n    if (dot(S.w, p0) < 0.) { S.w = -S.w; }\n                  \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arc on sphere\n//\n// inputs: \n//\n//   p: query point (unit vector)\n//   c: arc center point (unit vector)\n//   r: arc radius in radians\n//   l: lower tangent (unit vector)\n//   w: upper tangent (unit vector)\n\nfloat darc(vec3 p, vec3 c, float r, vec3 l, vec3 w) {\n\n    float d = abs(sdist(p, c) - r);\n    \n    d = max(d, -dot(p, l));\n    d = max(d, -dot(p, w));\n    \n    return d;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance from point p to spline S\n\nfloat dspline(vec3 p, arc_spline S) {\n\n    if (S.r == 0.0) {\n    \n        // spline is the great circle segment connecting p0 & p1\n        return max(abs(dot(p, S.w)), -min(dot(p, S.l0), dot(p, S.l1)));\n    \n    } else {\n    \n        // spline is one or two arcs \n        \n        // ignore either arc segment if the midpoint lies at the corresponding endpoint \n        float d = 1e5;\n\n        if (dot(S.m, S.p0) < 1.0 - EPS) { d = min(d, darc(p, S.c0, S.r, S.l0,  S.w)); }\n        if (dot(S.m, S.p1) < 1.0 - EPS) { d = min(d, darc(p, S.c1, S.r, S.l1, -S.w)); }\n        \n        return d;\n                    \n    }\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// draw diagram on sphere\n\nvec3 draw(vec3 p) {\n\n    //////////////////////////////////////////////////\n    // figure out some sample points and tangents\n    \n    vec3 p0 = vec3(0, 0, 1);\n    vec3 l0 = vec3(0, 1, 0);\n    \n    float u = 2.*PI*fract(iTime/PERIOD);\n\n    vec3 p1 = normalize(vec3(0.25, 0.4, 1.0) + vec3(0.3*sin(PFREQ*u), 0.3*cos(PFREQ*u), 0));    \n    vec3 q = normalize(vec3(1, 0, 0.5) + vec3(0.2*sin(QFREQ*u + 0.3), 0.2*cos(QFREQ*u + 0.1), 0));\n    vec3 l1 = normalize(cross(q, p1));\n    \n    //////////////////////////////////////////////////\n    // compute and draw the spline\n    \n    arc_spline S;    \n    compute_spline(p0, l0, p1, l1, S);\n    \n    float bblue = 1e5;\n    float blue = min(abs(dot(p, l0)), abs(dot(p, l1)));\n    float black = min(sdist(p0, p), sdist(p1, p));\n    float green = min(darrow(p, p0, l0), darrow(p, p1, l1));  \n    float maroon = 1e5;\n    float orange = dspline(p, S);\n         \n    if (draw_extras && S.r != 0.0) {\n  \n        blue = min(blue, max(abs(dot(p, S.w)), -min(dot(p, l0), dot(p, l1))));\n        \n        maroon = min(maroon, sdist(p, S.c0));\n        maroon = min(maroon, sdist(p, S.c1));\n        black = min(black, sdist(p, S.m));\n                \n    }\n    \n    vec3 color = vec3(1);\n    \n    if (!draw_extras) {\n        green = 1e5;\n    }\n    \n    color = min(color, mix(vec3(1), vec3(0, 0.5, 1), 0.4*smoothstep(aa, 0.0, blue - 0.002)));\n    color = min(color, mix(vec3(1), vec3(0.1, 0.6, 0), smoothstep(aa, 0.0, green - 0.002)));\n    color = min(color, mix(vec3(1), vec3(1.0, 0.4, 0), smoothstep(aa, 0.0, orange - 0.008)));\n    color = min(color, mix(vec3(1), vec3(0.7, 0, 0.4), smoothstep(aa, 0.0, maroon - 0.015)));\n    color *= smoothstep(0., aa, black - 0.015);\n    \n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// raytrace to sphere and compute color & lighting\n\nvec4 shade(vec3 ro, vec3 rd) {\n    \n    // raytrace\n    vec4 res = sphere(ro, rd, vec3(0), 1.0);\n    \n    // if miss sphere, gray background\n    if (res.w < 0.) { return vec4(vec3(0.85), 1); }\n    \n    // get intersection point on sphere\n    vec3 p = res.xyz;\n\n    // render on sphere\n    vec3 color = draw(p);\n    \n    // goofy non realistic lighting\n    color *= 0.3*dot(p, L) + 0.7;\n\n    return vec4(color, 1);\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// stereographic projection\n\nvec3 sphere_from_plane(vec2 q) {\n\n    float qq = dot(q, q);\n        \n    return vec3(2.*q, -1.+qq) / (1. + qq);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// pretty vanilla main handles scene transform & mouse interaction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // distance from camera to sphere centers\n    const float cdist = 6.0;\n    \n    // center-relative fragment coordinates\n    vec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n        \n    // focal length in pixels\n    float f = 0.45/iResolution.y;\n\n    vec2 theta = vec2(-0.2, 0.15);\n    \n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        theta.x = (iMouse.y - .5*iResolution.y) * 3.5/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * -5.0/iResolution.x; \n    }\n    \n    draw_extras = (max(iMouse.z, iMouse.w) <= 0.0);\n\n    mat3 Rview = rotY(theta.y)*rotX(theta.x); \n\n    if (texture(iChannel0, vec2(83.5/256., 0.75)).x > 0.) {\n\n        vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * 1.5/ iResolution.y;\n\n        vec3 p = sphere_from_plane(uv);\n        \n        p.z = -p.z;\n\n        aa = sqrt(length(cross(dFdx(p), dFdy(p))));\n\n        p = Rview*p;\n\n        vec3 color = draw(p);\n\n        fragColor = vec4(color, 1);\n        \n    } else {\n\n         aa = 4.0 / iResolution.y;\n\n        // ray origin and direction\n        vec3 rd = normalize(vec3(f*uv, -1));\n        vec3 ro = vec3(0, 0, cdist);\n        \n        L = Rview*L;\n        fragColor = shade(Rview*ro, Rview*rd);\n\n    }        \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.7));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}