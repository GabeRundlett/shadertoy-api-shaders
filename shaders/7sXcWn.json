{
    "Shader": {
        "info": {
            "date": "1642263064",
            "description": "Gamut compression comparison",
            "flags": 0,
            "hasliked": 0,
            "id": "7sXcWn",
            "likes": 6,
            "name": "Gamut compression comparison",
            "published": 3,
            "tags": [
                "gamut"
            ],
            "usePreview": 0,
            "username": "bjornornorn",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "float modulo(float x)\n{\n    return x - floor(x);\n}\n\nfloat findCenter(vec3 x)\n{\n    float a = 1.9779984951f*x.x - 2.4285922050f*x.y + 0.4505937099f*x.z;\n    float b = 0.0259040371f*x.x + 0.7827717662f*x.y - 0.8086757660f*x.z;\n    float C = sqrt(a*a+b*b);\n    \n    // Matrix derived for max(l,m,s) to be as close to macadam limit as possible\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26923008, -1.43594808,  0.166718,\n        -0.98545265,  2.12616699, -0.14071434,\n        -0.02985871, -0.25753239,  1.2873911);\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n  \n    return c_smooth;\n}\n\nvec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat calculateC(vec3 lms)\n{\n    // Most of this could be precomputed\n    // Creating a transform that maps R,G,B in the target gamut to have same distance from grey axis\n\n    vec3 lmsR = toLms(vec3(1.0,0.0,0.0));\n    vec3 lmsG = toLms(vec3(0.0,1.0,0.0));\n    vec3 lmsB = toLms(vec3(0.0,0.0,1.0));\n    \n    vec3 uDir = (lmsR - lmsG)/sqrt(2.0);\n    vec3 vDir = (lmsR + lmsG - 2.0*lmsB)/sqrt(6.0);\n    \n    mat3 to_uv = inverse(mat3(\n    1.0, uDir.x, vDir.x,\n    1.0, uDir.y, vDir.y,\n    1.0, uDir.z, vDir.z\n    ));\n    \n    vec3 _uv = lms * to_uv;\n    \n    return sqrt(_uv.y*_uv.y + _uv.z*_uv.z);\n}\n\nvec3 calculateLCh(vec3 c)\n{\n    vec3 lms = toLms(c);\n    \n    float maxLms = findCenter(lms);\n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n\n    return vec3(maxLms, C, atan(-b, -a));\n}\n\n\nvec2 expandShape(vec3 rgb, vec2 ST)\n{\n    vec3 LCh = calculateLCh(rgb);\n    vec2 STnew = vec2(LCh.x/LCh.y, (1.0-LCh.x)/LCh.y);\n    STnew = (STnew + 3.0*STnew*STnew*LCh.y);\n    \n\n    return vec2(min(ST.x, STnew.x), min(ST.y, STnew.y));\n}\n\nfloat expandScale(vec3 rgb, vec2 ST, float scale)\n{\n    vec3 LCh = calculateLCh(rgb);\n    float Cnew = (1.0/((ST.x/LCh.x) + (ST.y/(1.0-LCh.x))));\n\n    return max(LCh.y/Cnew, scale);\n}\n\nfloat softness_scale = 0.2;\n\nvec2 approximateShape()\n{\n    float m = -softness_scale*0.2;\n    float s = 1.0 + (softness_scale*0.2+softness_scale*0.8);\n    \n    vec2 ST = vec2(1000.0,1000.0);\n    ST = expandShape(m+s*vec3(1.0,0.0,0.0), ST);\n    ST = expandShape(m+s*vec3(1.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,0.0), ST);\n    ST = expandShape(m+s*vec3(0.0,1.0,1.0), ST);\n    ST = expandShape(m+s*vec3(0.0,0.0,1.0), ST);\n    ST = expandShape(m+s*vec3(1.0,0.0,1.0), ST);\n    \n    float scale = 0.0;\n    scale = expandScale(m+s*vec3(1.0,0.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,0.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,1.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(0.0,0.0,1.0), ST, scale);\n    scale = expandScale(m+s*vec3(1.0,0.0,1.0), ST, scale);\n    \n    return ST/scale;\n}\n\n\nvec3 compute(float L, float hue, float sat)\n{\n    vec3 c;\n    c.x = L;\n    c.y = cos(hue);\n    c.z = sin(hue);\n    \n    float l_ = + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = - 0.0894841775f * c.y - 1.2914855480f * c.z;\n    \n    vec3 lms = vec3(l_,m_,s_);\n    \n    vec2 MC = findCenterAndPurity(lms);\n    \n    lms -= MC.x;\n    \n    lms *= sat;  \n    \n    lms += c.x;\n\n    lms = lms*lms*lms;\n    \n    float l = lms.x;\n    float m = lms.y;\n    float s = lms.z;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    \n    return rgbResult;\n}\n\nvec3 scurve3(vec3 x)\n{\n    return (3.0*x - x*x*x)/2.0;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = clamp(a, 0.0,softness_scale);\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColor(vec3 color)\n{\n    // soft clip of rgb values to avoid artifacts of hard clipping\n    // causes hues distortions, but is a smooth mapping\n    \n    float grey = 0.2;\n    \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n \n    float softness_0 = maxRGB/(1.0+softness_scale)*softness_scale; \n    float softness_1 = (1.0-minRGB)/(1.0+softness_scale)*softness_scale;\n\n    vec3 softness = vec3(0.5)*(softness_0+softness_1 + xsgn*(softness_1 - softness_0));\n\n    return grey + xscale*xsgn*softSaturate(abs(x), softness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = (fragCoord.x / iResolution.x)* 3.141592 * 2.;\n    float L = 2.0*fragCoord.y / iResolution.y;\n    L = L - floor(L);\n    float C = -0.5*log(0.5+0.5*sin(iTime));\n    \n    vec2 ST = approximateShape();\n   \n    float C_smooth = (1.0/((ST.x/L) + (ST.y/(1.0-L))));\n    float C_max;\n    \n    for (int i=0; i<200; i++)\n    {\n        vec3 rgbTest = compute(L, h, 0.5*float(i)/200.0);\n        float diff = length(rgbTest - clamp(rgbTest, 0., 1.));\n    \n        if(diff == 0.)\n        {\n            C_max = 0.5*float(i)/200.0;\n        }\n    }\n    \n    vec3 rgb;\n    \n    if (fragCoord.y / iResolution.y > 0.5)\n    {\n        rgb = compute(L, h, C/sqrt(C*C/C_smooth/C_smooth+1.0));\n        rgb = softClipColor(rgb);\n    }\n    else\n    {\n        rgb = compute(L, h, C/sqrt(C*C/C_max/C_max+1.0));\n    }\n    \n    fragColor.rgb = Srgb3(rgb);\n    fragColor.a = 1.;\n    \n        \n    //fragColor = vec4(Srgb3(avgColor),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}