{
    "Shader": {
        "info": {
            "date": "1581793340",
            "description": "learning about iterated function systems. also gave antialiasing a shot, with dubious success.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ldXD2",
            "likes": 5,
            "name": "thorn garden",
            "published": 3,
            "tags": [
                "fractal",
                "ifs"
            ],
            "usePreview": 0,
            "username": "mahalis",
            "viewed": 432
        },
        "renderpass": [
            {
                "code": "// license: CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\n// set to 1 if the holes bother you\n#define TRYPOPHOBIA 0\n\n// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTet(vec3 p, float r) {\n    const vec3 c = normalize(vec3(1.,-1.,1.));\n    return max(max(max(dot(p, c.xxx) - r, dot(p, c.yyx) - r), dot(p, c.xyy) - r), dot(p, c.yxy) - r);\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// assumes normalized axis\nmat3 makeRotation(vec3 axis,float angle) {\n    \n    float c = cos(angle), s = sin(angle);\n    float mc = 1. - c;\n    float sz = s * axis.z;\n    float sy = s * axis.y;\n    float sx = s * axis.x;\n    float mx = mc * axis.x;\n    float my = mc * axis.y;\n    float mz = mc * axis.z;\n    \n    return mat3(c + mx * axis.x,\n                mx * axis.y - sz,\n                mx * axis.z + sy,\n                mx * axis.y + sz,\n                c + my * axis.y,\n                my * axis.z - sx,\n                mx * axis.z - sy,\n                my * axis.z + sx,\n                c + mz * axis.z);\n}\n\n// -----------------\n\nmat3 innerRotation;\n\nfloat d(vec3 position) {\n    position = rX(position, iTime * 0.13);\n    float fScale = 0.79 + sin(iTime * 0.9) * 0.013;\n    float accumulatedScale = 1.;\n    \n    for(int i = 0; i < 8; i++) {\n        position = abs(position);\n        position *= fScale;\n        accumulatedScale *= fScale;\n        position -= (0.0137 + 0.001 * sin(iTime * 0.6 + 1.));\n        position = innerRotation * position;\n    }\n    float cutoutAmount = pow(sin(iTime * 0.231), 4.);\n    #if TRYPOPHOBIA\n    float innerCutout = sdTet(-position,0.003 + cutoutAmount * 0.009);\n    #else\n    float innerCutout = sdSphere(position, 0.014 + cutoutAmount * 0.002);// sdSphere(position, 0.009 + cutoutAmount * 0.007);\n    #endif\n    float outerCrop = sdSphere(position, 0.021 + sin(iTime * 0.831 + 2.) * 0.003);\n    return opInt(opSub(sdTet(position, 0.01), innerCutout), outerCrop) / accumulatedScale;\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 70; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\n// ambient occlusion using iq’s technique from https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat occlusion(vec3 position, vec3 normal) {\n    const float aoStep = 0.04;\n    float aoAcc = 0.;\n    const float distanceScale = 0.005; // decrease for less attenuation of shadows\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float sampleDistance = aoStep * fi;\n        aoAcc += (sampleDistance - max(0.,d(position + normal * sampleDistance))) / exp2(fi * distanceScale);\n    }\n    return aoAcc;\n}\n\nvec3 palette(float v) {\n    v *= 4.;\n    return vec3(0.5) + 0.5 * cos(6.28318 * (v + vec3(0.0,0.333,0.667)));\n}\n\n// soft shadows also using iq’s technique — https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 origin, vec3 direction, float sharpness) {\n    const float maxDistance = 2.;\n    float amount = 1.;\n    float totalDistance = 0.;\n    for(int i = 0; i < 70; i++) {\n        float localDistance = d(origin);\n        amount = min(amount, 0.5 + 0.5 * localDistance / (sharpness * totalDistance));\n        if (localDistance < 0.) break;\n        origin += direction * max(0.002, localDistance);\n    }\n    \n    amount = max(amount, 0.);\n    return amount * amount * (3. - 2. * amount);\n    \n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.4, 1.0, 0.6)  - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    float nDotV = max(0., dot(normal, toEye));\n    const float diffuse = 1.;\n    float ambience = 0.1 + max(0., dot(normal, vec3(0.,-1.,0.))) * 0.4;\n    const float specular = 0.3;\n    float ao = (1.0 - occlusion(position, normal));\n    float fres = pow(1. - nDotV, 8.);\n    float shadowAmount = shadow(position + normal * 0.01, toLight, .5);\n    \n    vec3 color = vec3((ndotL * diffuse + pow(ndotH, 4.) * specular) * shadowAmount + ao * (ambience + fres)) * palette(nDotV * -0.5 + 0.6 + iTime * 0.03);\n    return color;\n}\n\n\n#define ANTIALIASING_SAMPLES 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, -0.04, 0.0);\n    vec3 cameraPosition = vec3(0.0, 0.2, 1.5) * 1.7;\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    innerRotation = makeRotation(normalize(vec3(1.,2.,-3.)), iTime * 0.122 + sin(iTime * 0.23) * 0.1);\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < ANTIALIASING_SAMPLES; i++) {\n        vec3 aaOffset = 0.002 * (cameraRight * float(i == 1 || i == 3) + cameraUp * float(i == 0 || i == 2));\n    \tvec4 marchResult = march(cameraPosition + aaOffset, rayDirection, 0.0001);\n    \tif (marchResult.w > 0.0) {\n    \t    color += vec3(0.0); // “sky” color\n    \t} else {\n    \t    vec3 position = marchResult.xyz;\n    \t    color += lightSurface(position, gradient(position, marchResult.w), -rayDirection);\n    \t}\n    }\n    color /= float(ANTIALIASING_SAMPLES);\n    color = pow(color, vec3(1.2)) * 1.5;\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}