{
    "Shader": {
        "info": {
            "date": "1514563890",
            "description": "a sets of cholor wheels which I use for my paintings color mixing algorithmen ",
            "flags": 0,
            "hasliked": 0,
            "id": "ltlyDf",
            "likes": 0,
            "name": "Distorted/Correction Colorwheel ",
            "published": 3,
            "tags": [
                "perceptualcolorwheel"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 879
        },
        "renderpass": [
            {
                "code": "\n// Value ranges for different hues and different colors.\n\n/*\n[0, 15] Red\n[15, 35] Orange\n[35, 60] Yellow\n[60, 135] Green\n[135, 200] Cyan\n[200, 260] Blue\n[260, 330] Magenta\n[330, 360] Red Magenta\n*/\n\n\n// r,g,b values are from 0 to 1\n// h = [0,360], s = [0,1], v = [0,1]\n//\t\tif s == 0, then h = -1 (undefined)\n\tvec3 RGBtoHSV( in float r, in float g, in float b )\n{\n    vec3 toReturn = vec3(0.0,0.0,0.0);\n    \n\tfloat MIN = 0.0;\n    float MAX = 0.0;\n    float delta =0.0;\n\tMIN = min( min(r, g), b );\n\tMAX = max( max( r, g), b );\n\ttoReturn.z = MAX;\t\t\t\t// v\n\tdelta = MAX - MIN;\n\tif( MAX != 0.0 )\n\t\ttoReturn.y = delta / MAX;\t\t// s\n\telse {\n\t\t// r = g = b = 0\t\t// s = 0, v is undefined\n\t\ttoReturn.y = 0.0;\n\t\ttoReturn.x = -1.0;\n\t\treturn toReturn;\n\t}\n\tif( r == MAX )\n\t\ttoReturn.x= ( g - b ) / delta;\t\t// between yellow & magenta\n\telse if( g == MAX )\n\t\ttoReturn.x = 2.0 + ( b - r ) / delta;\t// between cyan & yellow\n\telse\n\t\ttoReturn.x = 4.0 + ( r - g ) / delta;\t// between magenta & cyan\n\ttoReturn.x *= 60.0;\t\t\t\t// degrees\n\tif( toReturn.x < 0.0 )\n\t\ttoReturn.x += 360.0;\n    \n    return toReturn;\n}\n\n\n\tvec3 HSVtoRGB(in float h, in float s, in float v )\n{\n    vec3 toReturn = vec3(0.0, 0.0, 0.0);\n\tfloat i;\n    int ii;\n\tfloat f, p, q, t;\n\tif( s == 0.0 ) {\n\t\t// achromatic (grey)\n\t\t//toReturn.x = toReturn.y = toReturn.z = v;\n\t\treturn vec3(v);\n\t}\n\th /= 60.0;\t\t\t// sector 0 to 5\n\ti = floor( h );\n\tf = h - i;\t\t\t// factorial part of h\n\tp = v * ( 1.0 - s );\n\tq = v * ( 1.0 - s * f );\n\tt = v * ( 1.0 - s * ( 1.0 - f ) );\n    ii = int(i);\n\tswitch( ii ) {\n\t\tcase 0:\n\t\t\ttoReturn.x = v;\n\t\t\ttoReturn.y = t;\n\t\t\ttoReturn.z = p;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttoReturn.x = q;\n\t\t\ttoReturn.y = v;\n\t\t\ttoReturn.z = p;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttoReturn.x = p;\n\t\t\ttoReturn.y = v;\n\t\t\ttoReturn.z = t;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttoReturn.x = p;\n\t\t\ttoReturn.y = q;\n\t\t\ttoReturn.z = v;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttoReturn.x = t;\n\t\t\ttoReturn.y = p;\n\t\t\ttoReturn.z = v;\n\t\t\tbreak;\n\t\tdefault:\t\t// case 5:\n\t\t\ttoReturn.x = v;\n\t\t\ttoReturn.y = p;\n\t\t\ttoReturn.z = q;\n\t\t\tbreak;\n\t}\n    return toReturn;\n}\n\nvec4 ReturnABCD(in float hueToConsider){\n    \n    vec4 ABCD = vec4(0.0,0.0,0.0,0.0);\n    \n    // Color Wheel where each color occupies the same segment of the circle\n    \n    \n    vec2 Red = vec2(0.0, 50.0); \n    vec2 Orange = vec2(Red.y, Red.y + 50.0);\n    vec2 Yellow = vec2(Orange.y, Orange.y + 25.0);\n    vec2 Green = vec2(Yellow.y, Yellow.y + 65.0);\n    vec2 Cyan = vec2(Green.y, Green.y + 40.0);\n    vec2 Blue = vec2(Cyan.y, Cyan.y + 40.0);\n    vec2 Magenta = vec2(Blue.y, Blue.y + 60.0);\n    vec2 RedMagenta = vec2(Magenta.y, Magenta.y + 30.0);\n\n\tvec2 RedNew = vec2(0.0, 45.0); \n    vec2 OrangeNew = vec2(RedNew.y, RedNew.y + 45.0);\n    vec2 YellowNew = vec2(OrangeNew.y, OrangeNew.y + 45.0);\n    vec2 GreenNew = vec2(YellowNew.y, YellowNew.y + 45.0);\n    vec2 CyanNew = vec2(GreenNew.y, GreenNew.y + 45.0);\n    vec2 BlueNew = vec2(CyanNew.y, CyanNew.y + 45.0);\n    vec2 MagentaNew = vec2(BlueNew.y, BlueNew.y + 45.0);\n    vec2 RedMagentaNew = vec2(MagentaNew.y, MagentaNew.y + 45.0);\n\t\n    \n    // Artist color Wheel\n    /*\n    vec2 Red = vec2(0.0, 40.0); \n    vec2 Orange = vec2(Red.y, Red.y + 70.0);\n    vec2 Yellow = vec2(Orange.y, Orange.y + 25.0);\n    vec2 Green = vec2(Yellow.y, Yellow.y + 55.0);\n    vec2 Cyan = vec2(Green.y, Green.y + 40.0);\n    vec2 Blue = vec2(Cyan.y, Cyan.y + 40.0);\n    vec2 Magenta = vec2(Blue.y, Blue.y + 50.0);\n    vec2 RedMagenta = vec2(Magenta.y, Magenta.y + 40.0);\n    \n    vec2 RedNew = vec2(0.0, 50.0); \n    vec2 OrangeNew = vec2(RedNew.y, RedNew.y + 60.0);\n    vec2 YellowNew = vec2(OrangeNew.y, OrangeNew.y + 35.0);\n    vec2 GreenNew = vec2(YellowNew.y, YellowNew.y + 65.0);\n    vec2 CyanNew = vec2(GreenNew.y, GreenNew.y + 30.0);\n    vec2 BlueNew = vec2(CyanNew.y, CyanNew.y + 40.0);\n    vec2 MagentaNew = vec2(BlueNew.y, BlueNew.y + 40.0);\n    vec2 RedMagentaNew = vec2(MagentaNew.y, MagentaNew.y + 40.0);\n    */\n    \n    if(hueToConsider<Red.y) ABCD= vec4(Red.x, Red.y, RedNew.x, RedNew.y);\n    else if(hueToConsider<Orange.y) ABCD= vec4(Orange.x, Orange.y, OrangeNew.x, OrangeNew.y);\n    else if(hueToConsider<Yellow.y) ABCD= vec4(Yellow.x, Yellow.y, YellowNew.x, YellowNew.y); \n    else if(hueToConsider<Green.y) ABCD= vec4(Green.x, Green.y, GreenNew.x, GreenNew.y); \n    else if(hueToConsider<Cyan.y) ABCD= vec4(Cyan.x, Cyan.y, CyanNew.x, CyanNew.y); \n    else if(hueToConsider<Blue.y) ABCD= vec4(Blue.x, Blue.y, BlueNew.x, BlueNew.y); \n    else if(hueToConsider<Magenta.y) ABCD= vec4(Magenta.x, Magenta.y, MagentaNew.x, MagentaNew.y); \n    else if(hueToConsider<360.0) ABCD= vec4(RedMagenta.x, RedMagenta.y, RedMagentaNew.x, 360.0); \n    \n\treturn ABCD;\n}\n\nfloat DistortingFormula(in float hueIN){\n    vec4 abcd = ReturnABCD(hueIN); \n    return abcd.z + ((hueIN - abcd.x) * ((abcd.w - abcd.z)/(abcd.y - abcd.x) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float CircleRadius = 0.5;\n    float M_PI = 3.1415926535897932384626433832795;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tuv.x -= CircleRadius/1.25;\n   vec2 screenCenter = vec2(0.5, 0.5);\n   vec2 vectorToCenter = screenCenter - uv ;\n   \n    \n    \n    \n   float hue = atan(vectorToCenter.y/vectorToCenter.x);\n    if((vectorToCenter.x < 0.0) && (vectorToCenter.y>0.0)) hue +=1.0* M_PI;\n    if((vectorToCenter.x < 0.0) && (vectorToCenter.y<0.0)) hue +=1.0* M_PI;\n    if((vectorToCenter.x > 0.0) && (vectorToCenter.y<0.0)) hue +=2.0* M_PI;\n    \n   if(hue < 0.0) hue +=2.0* M_PI;\n   hue *= 180.0/M_PI;\n   hue = DistortingFormula(hue);\n   float saturation = length(vectorToCenter *2.0);\n   float value = 0.8;\n    \n   vec3 color = HSVtoRGB(hue, saturation, value);\n   \n   \n    if(length(vectorToCenter)> CircleRadius){\n        color = vec3(0.5,0.5,0.5);\n    }\n    \n   fragColor = vec4(color, 1.0); \n    \n    \n\t\n\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}