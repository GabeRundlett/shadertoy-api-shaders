{
    "Shader": {
        "info": {
            "date": "1502783185",
            "description": "The classic chessboard puzzle. First attempt at doing some proper CSG modelling in a shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltySzc",
            "likes": 10,
            "name": "8 queens",
            "published": 3,
            "tags": [
                "raymarching",
                "csg"
            ],
            "usePreview": 0,
            "username": "russ",
            "viewed": 942
        },
        "renderpass": [
            {
                "code": "const float eps = .01, far = 33. ;\t//raymarching parameters\nconst int iter  =120, AA = 1;\n\nconst float s1 = 0.447213595, \t//sin of pieces grid\n    \t\tc1 = 0.894427191, \t//cos of pieces grid\n    \t\tc2 = 0.796083798,\t//cos of clip box\n    \t\ts2 = 0.605186405,\t//sin of clip box\n    \t\tr5 = 2.236067977; \t//root 5\n\nconst vec3 lightPos = vec3(9,8,6);\nconst vec3 lightCol = vec3(1.,.9,.8);\n\n//smoothstep spline\nfloat spline(float t){\n    return t * t * (3. - 2.*t);\n}\n\nfloat box(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return min(max(p.x,max(p.y,p.z)),0.0) + length(max(p,0.0));\n}\n\n//octagon fold then sphere test\n//s = ring radius, sphere radius\nfloat spheres(vec3 p, vec2 s){\n    p.xz = abs(p.xz);\n    vec2 fold = vec2(-.70710678,.70710678);\n    p.xz -= 2. * max(dot(p.xz, fold), 0.) * fold;\n    return distance(p, vec3(0.9238795* s.x,0.,0.3826834*s.x)) - s.y;\n}\n\n//cylinder with smoothstepped radius\nfloat base(vec3 p){\n  float t = spline(-p.y*.75+.33);\n  vec2 s = vec2(.4*t*t +.2,.99); \n  vec2 d = abs(vec2(length(p.xz),p.y)) - s;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));    \n}\n\n//square cross-section torus, s = major, minor radius \nfloat sharpTorus(vec3 p, vec2 s){\n\tfloat d = length(p.xz) - s.x;\n    vec2 v = vec2(d, p.y);\n    return dot(abs(v),vec2(.70710678)) -s.y;\n}\n\n//from iq's primitives\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//put it all together to make a queen\nfloat queen(vec3 p){\n\tfloat d = base(p);\n    p.y += .5;\n    d = max(d, - sharpTorus(p,vec2(.49,.05)));\n    p.y += .25;\n    d = max(d, - sharpTorus(p,vec2(.6,.05)));\n    p.y -= 1.78;\n    d = max(d, - spheres(p, vec2(.33,.12)));\n    p.y -= .08;\n    d = min(d, sdEllipsoid(p,vec3(.15,.25,.15)));\n    return d;  \n}\n\n//mirrored repeating grid of queens clipped by bounding box\nfloat queens(vec3 p){\n    float flip = dot(p.xz, vec2(1.)) >= 0. ? 1. : -1.;\n    p.xz *= flip;\n    vec3 q = p;\n\tp.xz -= 1.;\n\tp.xz = mat2(c1,-s1,s1,c1)*p.xz;\n    p.xz = mod(p.xz + r5, 2.*r5) - r5;  \n    q.xz -= vec2 (4.2,3.6);\n    q.xz = mat2(c2,s2,-s2,c2) * q.xz;\n\n    return max(queen(p),box(q,vec3(6,1.5,3)));\n}\n\nfloat board(vec3 p){\n    return box(p,vec3(7.99,1,7.99));\n}\n\nfloat ground(vec3 p){\n    p.y += 2.;\n    return box(p,vec3(13,.8,13));\n}\n\nfloat DE(vec3 p){\n    vec3 q = p;\n    q.y += 2.;\n    return min(ground(p),min(queens(p), board(q)));\n}\n\n\nfloat march(vec3 ro, vec3 rd){\n \tfloat t = 0., d = 1e10;\n    for(int i=0;i<iter;i++){\n     \tt += .5 * (d = DE(ro+t*rd));\n        if(d<=eps || t>= far) break;\n    }\n    return t+.5*d;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float dist, float k){\n    float t = eps, shade = 1.,  d;\n    for(int i=0; i<50; i++){\n        d = DE(ro + t*rd);\n        if(d < 0.){\n            shade = 0.;\n            break;\n        }\n        shade = min (shade, smoothstep(0.,.5,d*k/t));\n        t+= clamp(.6*d,.02,.2);\n        if(t>dist) break;\n    }\n    return shade;\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps,0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\n//xyz for albedo, w controls specular / reflections\nvec4 getMaterial(vec3 p){\n    float bw = mod (floor(p.x*.5) + floor(p.z*.5), 2.);\n    float d = DE(p);\n\tif(d == queens(p)) return bw > 0. ? vec4(.05,.05,.05, 3.15) : vec4 (.9,.9,.7, 3.15);\n    if(d == ground(p)) return vec4(pow(texture(iChannel1, .2*p.xz).rgb,vec3(2.2)),2.02); \n    return bw > 0. ? vec4(.7,.7,.7,130.99) : vec4 (.1,.1,.1,130.99);          \n}\n\nvec3 getReflection(vec3 ro, vec3 rd){\n    float t = march(ro,rd);\n    vec3 p = ro + t*rd;\n    vec3 col;\n    if(t<far){\n        vec3 p = ro + t*rd;\n        vec3 n = getNorm(p);\n        vec3 r = reflect(rd, n);\n        vec4 mat = getMaterial(p);\n        vec3 l = lightPos - p;\n    \tfloat d = length(l);\n    \tl *= 1./d;\n        float atten = 70. /( 1. + d*d);\n        float diff = max(dot(n,l), 0.) * atten;\n    \tfloat amb = .05 + .01 * n.y;\n    \tfloat spec = pow(max(dot(r,l),0.),floor(mat.w))*(fract(mat.w)*3.*sqrt(atten));\n        col = lightCol * (mat.rgb*(diff+amb)+spec);  \n    }\n    else col = .05*pow(texture(iChannel0,rd).rgb,vec3(2.2));\n    return col;\n}\n\nvec3 light(vec3 p, vec3 v){\n\tvec3 n = getNorm(p);\n    vec3 r = reflect(v, n);\n    vec4 mat = getMaterial(p);\n    vec3 l = lightPos - p;\n    float d = length(l);\n    l *= 1./d;\n    float atten = 70. /( 1. + d*d);\n    atten = min(atten, shadow(p, l, 7., 20.));\n    float diff = max(dot(n,l), 0.) * atten;\n    float amb = .05 + .01 * n.y;\n    float spec = pow(max(dot(r,l),0.),floor(mat.w))*(fract(mat.w)*3.*sqrt(atten));\n    vec3 col = lightCol * (mat.rgb*(diff+amb)+spec);  \n    \n    if(mat.w > 100.){\n        col += .15*getReflection(p+(3.*eps*r), r);\n    }\n    return col;\n}\n\nvec3 getCam(vec2 uv, vec3 ro){\n    \n    vec3 f = normalize(-ro);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 rd = normalize(f + uv.x*r + uv.y *u);\n    return rd;\n}\n\n//iq's sphere density function for glowing light \nfloat sphDensity( vec3  ro, vec3  rd,   // ray origin, ray direction\n                 vec3  sc, float sr) {  // sphere center, sphere radius)       \n    vec3  rc = (ro - sc)/sr;\n\t\n    // find intersection with sphere\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n\n    // not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    //return h*h*h;\n\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    // analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*1.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 s = sin(vec4(iTime*.5,iTime*.5+1.57,iTime*.2,iTime*.3));\n    vec3 ro = vec3((12.+2.*s.z)*s.x ,3. + s.w ,(12.+2.*s.z)*s.y);\n    vec3 rd;\n    vec3 col = vec3 (0);\n    float f = 1. / float(AA);\n    for(int i=0;i<AA;i++){\n        for(int j=0;j<AA;j++){\n            vec2 uv = (fragCoord.xy - .5 * iResolution.xy + f*vec2(i,j)) / iResolution.y;\n    \t\trd = getCam(uv,ro);\n    \t\tfloat t = march(ro,rd);\n    \t\tcol += t<far ? (light(ro+t*rd, rd)) : .05*pow(texture(iChannel0,rd).rgb,vec3(2.2));            \n        }\n    }\n    col *= (f*f);\n    if(dot(rd,normalize(lightPos-ro)) > .99) {\n        \n        float s = sphDensity(ro,rd,lightPos,2.);\n        col += clamp(s*s,0.,1.5) * lightCol;\n    }\n    col = pow(col, vec3(1./2.2));\n\tfragColor = (vec4(col,1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}