{
    "Shader": {
        "info": {
            "date": "1572308867",
            "description": "sdf functions from iq: http://iquilezles.org/articles/distfunctions/distfunctions.htm\nshading formula from original paper: https://users.cs.northwestern.edu/~ago820/SIG98/gooch98.pdf\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Ws3XRj",
            "likes": 2,
            "name": "Shading-Gooch",
            "published": 3,
            "tags": [
                "goochshading"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "#define MAX_DISTANCE 60.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n#define PI 3.1415\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sceneSDF(vec3 p) {\n    float d = sphereSDF(p, 0.5);\n    return d;\n}\nfloat marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.001;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float h = sceneSDF(p);\n        if (t < EPSILON || t > tmax) break;\n        t += h;\n    }\n    return t;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 shading(vec3 p, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 nor = getNormal(p);\n    //light needs to be perpendicular to gaze direction\n    vec3 lightDir = -vec3(0.2, 0.8, 0.6); \n    vec3 viewDir = normalize(rd);\n    vec3 ref = normalize(reflect(-lightDir, nor));\n    vec3 surf = vec3(0.8, 0.5, 0.4);\n    vec3 warm = vec3(0.3, 0.3, 0.0) + 0.25 * surf;\n    vec3 cool = vec3(0.0, 0.0, 0.35) + 0.25 * surf;\n    float dotLN =dot(lightDir, nor);\n    float k = (1.0 + dotLN) / 2.0;\n    vec3 gc = k * cool + (1.0 - k) * warm;\n    float spe = pow(max( dot( viewDir, ref ), 0.0 ),32.0);\n    col = spe + (1.0-spe)*gc;\n    return col;\n}\n\nvec3 render(in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x/iResolution.y; \n    vec2 mo = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mo -= 0.5;\n    \n    vec3 ro = vec3(2.0 * cos(mo.x * 2.0 * PI), 0.0, 2.0 * sin(mo.x * 2.0 * PI));\n    vec3 ta = vec3(0.0, ro.y, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    float d = marching(ro, rd);\n    vec3 col = vec3(0.0);\n    if (d < MAX_DISTANCE) {\n        vec3 p = ro + d * rd;\n        col = shading(p, ro, rd);\n    }\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = render(fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}