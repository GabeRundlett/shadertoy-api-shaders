{
    "Shader": {
        "info": {
            "date": "1667539648",
            "description": "Atempt to extend https://www.shadertoy.com/view/DdX3WH to 3D",
            "flags": 0,
            "hasliked": 0,
            "id": "Dsj3Wh",
            "likes": 1,
            "name": "3D Medial axis",
            "published": 3,
            "tags": [
                "3d",
                "error",
                "medialaxis"
            ],
            "usePreview": 0,
            "username": "scry",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "//Based off of https://www.shadertoy.com/view/DdX3WH\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nvec3 cpos() {\n    vec3 c = vec3(0.,0.,-2.);\n    c.xz *= r2d(deg*40.);\n    c.yz *= r2d(deg*-40.);\n    c.xz *= r2d(sin(time*2.)*0.2-0.1);\n    c.yz *= r2d(cos(time*2.)*0.2-0.1);\n    c.xz *= r2d(time*2.);\n    //c.yz *= r2d(time);\n    return c;\n}\n\nmat4 eye() {\n    vec3 c = cpos();\n    vec3 l = vec3(0.);\n    vec3 f = normalize(l-c);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = cross(f,r);\n    return mat4(r,0.,u,0.,f,0.,vec3(0.),1.);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 q = abs(p)-s;\n    return max(q.z,max(q.x,q.y));\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p = (eye()*vec4(p,1.)).xyz;\n    p += cpos();\n    float d = sdBox(p,vec3(0.5));\n    d = min(d,sdBox(p-vec3(0.4),vec3(0.2)));\n    return vec4(p,d);\n}\n\nvec4 dbmap(vec3 p) {\n    vec3 o = p;\n    p = (eye()*vec4(p,1.)).xyz;\n    p += cpos();\n    float d = map(o).w;\n    \n    \n    //d = min(d,abs(p.z)-0.02);\n    d = abs(p.z)-0.01;\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<30;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 1000. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec2 dbRM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<30;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = dbmap(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 1000. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\n#define EPS 0.01\nvec3 gradient(vec3 p) {\n    vec2 h = vec2(EPS,0.);\n    return vec3(\n        map(p+h.xyy).w-map(p-h.xyy).w,\n        map(p+h.yxy).w-map(p-h.yxy).w,\n        map(p+h.yyx).w-map(p-h.yyx).w\n    )/EPS/2.;\n}\n\nvec4 vRM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    vec3 col = vec3(0.);\n    for (int i=0;i<420;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += abs(dS*0.004)+EPS/2.;\n        ii += 0.01;\n        vec3 cp = (eye()*vec4(p,1.)).xyz+cpos();\n        vec3 mp = map(p).xyz;\n        float e = map(p+gradient(p)*(-dS)).w;\n        float e_ = map(p+gradient(p)*(dO)).w;\n        float ec = smoothstep(EPS,0.,abs(e));\n        //float ee = smoothstep(0.,0.1,-e_+0.4);\n        //float ee = smoothstep(0.,0.5,-(e_)-e_*dS/dO*0.001);\n        float ee = smoothstep(0.,EPS,0.5-(e_));\n        //col += smoothstep(0.05,0.,abs(fract(mp.x*12.+time)/12.))*ee*0.02-0.003;\n        //col += smoothstep(0.05,0.,abs(mp.x)/abs(dO))*ee*0.02;\n        //col += smoothstep(0.05,0.,abs(dS+(sin(time*10.)*0.25+0.25))-0.01)*ee*0.02;\n        col += ee*clamp(-dS,0.,1.);\n        //col += smoothstep(0.9,0.,abs(fract(mp.x*12.+time)/12.))*ee;\n        if (dO > 1000.) {break;}\n    }\n    //col *= 0.1;\n    //col = col*0.3+sin(vec3(1.9,2.,3.)+col*1.-1.)*0.1+0.5;\n    return vec4(col,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p+h.xyy).w-map(p-h.xyy).w,\n        map(p+h.yxy).w-map(p-h.yxy).w,\n        map(p+h.yyx).w-map(p-h.yyx).w\n    ));\n}\n\n\nvec3 colo(vec3 p, vec3 n, vec2 d, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.);\n    vec2 db = dbRM(ro,rd);\n    vec4 dv = vRM(ro,rd);\n    vec3 pdb = ro+rd*db.x;\n    float dbx = abs(map(pdb).w);\n    //float e = map(pdb+gradient(pdb)*db.x).w;\n    float e = map(p+gradient(p)).w;\n    col += sin(vec3(1.,2.,3.)+d.y*30.-time*2.)*0.1;\n    vec3 vp = ro+rd*dv.w;\n    col *= 0.1;\n    col += dv.xyz;\n    if (d.x > 100.) {\n        col *= 0.05;\n        col += dv.w-4.5;\n    }\n    \n    col += (1.-clamp(d.x*0.1,0.,1.))*0.1;\n\n    //col += 1.-clamp(db.x*0.1,0.,1.);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    col += colo(p,n,d,ro,rd);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}