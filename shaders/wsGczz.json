{
    "Shader": {
        "info": {
            "date": "1602111181",
            "description": "Recursively tiling this hexadrafter irreptile from George Sicherman [url]https://userpages.monmouth.com/~colonel/drirrep/index.html[/url]\n\nFork of [url]https://www.shadertoy.com/view/tddyWl[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wsGczz",
            "likes": 22,
            "name": "Irreptile Triangle Zoom",
            "published": 3,
            "tags": [
                "irreptile"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 619
        },
        "renderpass": [
            {
                "code": "/*\n\n    Irreptile Triangle Zoom\n    -----------------------\n\n    Recursively tiling this hexadrafter irreptile from George Sicherman\n    https://userpages.monmouth.com/~colonel/drirrep/index.html\n\n\tForked from https://shadertoy.com/view/tddyWl\n\n*/\n\n// Polygon distance, iq https://www.shadertoy.com/view/wdBXRW\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nvec2 mul(mat3 m, vec2 p) {\n   return (m * vec3(p, 1)).xy;\n}\n\n/*\nfloat decomposeScale(mat3 m) {\n    mat2 m2 = mat2(m);\n\tvec2 a = vec2(0,0) * m2;\n\tvec2 b = vec2(1,0) * m2;\n    return distance(a, b);\n}\n\n// I made this up as I went along, there are probably faster methods?\nvoid decompose(mat3 m, out vec2 translation, out float rotation, out float scale) {\n    mat2 m2 = mat2(m);\n\tvec2 a = vec2(0,0) * m2;\n\tvec2 b = vec2(1,0) * m2;\n\tvec3 c = vec3(0,0,1) * m;\n    translation = c.xy;\n    scale = distance(a, b);\n    rotation = -acos(dot(normalize(b), vec2(1,0)));\n}\n*/\n\n// Optimisations thanks to FabriceNeyret2\n\nfloat decomposeScale(mat3 m) {\n\tvec2 a = vec2(1,0) * mat2(m);\n    return length(a);\n}\n\nvoid decompose(mat3 m, out vec2 translation, out float rotation, out float scale) {\n\tvec2 a = vec2(m[0][0], m[1][0]);\n    translation = vec2(m[0][2], m[1][2]);\n    scale = length(a);\n    rotation = -acos(a.x / scale); // we don't know the real sign, so negating it as a hack\n}\n\n\n// Logarithmic Spiral Center\n// https://www.shadertoy.com/view/tscBDH\nvec2 spiralCenter(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\n\n\n// MAIN\n\nvec2 rotate(vec2 p, float a) {\n    return cos(-a)*p + sin(-a)*vec2(p.y, -p.x);\n}\n\n#define PI 3.1415926\n\nconst int count = 11;\nmat3 tiles[count];\nconst int ITERATIONS = 5;\n//#define ZOOM_OUT\n//#define LOOP\n\nfloat h = sqrt(3.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(0, 0),\n        vec2(2.5, 0),\n        vec2(2.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\nfloat time;\n\nvec3 shadeTile(float d, float s, int i, int iteration, vec2 p) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .0025 * iResolution.y;\n    //d += (.00125 / s + .0015)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        t /= float(count);\n    \t//t *= 1.666;\n        t += time;\n    #else\n        t /= float(count);\n        t = t * mix(1., 10., cos(iTime / 20.) * .5 + .5);\n        t += iTime / 6.;\n    \tt -= (p.x - 2.5/2.) * .05;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float opacity = 1.;\n        \n        if (iteration == 0) {\n        \topacity = 1. - time;\n            #ifdef ZOOM_OUT\n            \topacity = 1. - opacity;\n            #endif\n        }\n        \n        if (iteration == ITERATIONS - 1) {\n        \topacity = time;\n            #ifdef ZOOM_OUT\n            \topacity = 1. - opacity;\n            #endif\n        }\n        \n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration, p) * opacity;\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p, float scale) {\n\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < ITERATIONS; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = mod(iTime / 12., 1.);\n\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y; \n    float pScale = .22;\n    #ifdef ZOOM_OUT\n    \tpScale = .05;\n    #endif\n    p *= pScale;\n    \n\n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect;\n\n    \n    // pick a tile to zoom to, and calculate the translation,\n    // rotation, and scale to smoothly transition to it\n    mat3 zoomTile = inverse(tiles[1]);\n    vec2 translation;\n    float rotation;\n    float scale;\n    decompose(zoomTile, translation, rotation, scale);     \n    vec2 origin = spiralCenter(translation, rotation, scale);\n    \n   \t#ifdef ZOOM_OUT\n\t\tscale = 1./scale;\n    \trotation *= -1.;\n   \t#endif\n    \n    \n    // apply the zoom\n    scale = pow(scale, time);\n    p *= scale;\n    p = rotate(p, rotation * time);\n    p += origin;\n\n    \n    // draw\n   \tvec3 col = render(p, scale * pScale);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}