{
    "Shader": {
        "info": {
            "date": "1531010576",
            "description": "a random planet generator",
            "flags": 0,
            "hasliked": 0,
            "id": "lsyfDt",
            "likes": 22,
            "name": "Civilization Planet",
            "published": 3,
            "tags": [
                "noise",
                "earth",
                "planet",
                "world"
            ],
            "usePreview": 0,
            "username": "AsahiYao",
            "viewed": 1029
        },
        "renderpass": [
            {
                "code": "#define mod3_           vec3(.1031, .22369, .13787)\n#define PI 3.1415926359\n\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 120.0);\n    // random3 has range 0 to 1\n    vec3 random3 = fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n    return normalize(-1. + 2. * random3);\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    // 5th order interpolant from Improved Perlin Noise\n    vec3 pf3 = pf * pf * pf;\n    vec3 pf4 = pf3 * pf;\n    vec3 pf5 = pf4 * pf;\n    vec3 w = 6. * pf5 - 15. * pf4 + 10. * pf3;\n    \n    return mix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n\nfloat restricted_perlin(vec3 pos) {\n    float perlin = perlin_noise3(pos);\n    float x = abs(perlin);\n    \n    float p = 0.5;\n    float q = 0.95;\n    float x1 = 0.5;\n    float x2 = 0.867;\n    float new = 0.0;\n    \n    float a = (q*p - x1) / x1 / x1;\n    float b = 1.;\n    float c = 0.;\n    if (x < x1) {\n        new = a * x * x + b * x + c;\n    } else {\n        float n = - (x2 - x1) * (2. * a * x1 + b) / (q*p - p);\n        float d = (q*p - p) / pow(x2 - x1, n);\n        new = d * pow(x2 - x, n) + p;\n    }\n    \n    return new * sign(perlin);\n}\n\n// -----------------------------------------------------------\n\n// Distance to a sphere centered at the origin\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n\n// Distance to a sphere with perlin noise perturbations\n// centered at the origin.\nfloat sdWeirdSphere(vec3 pos,float frequency) {\n    float noise = perlin_noise3(pos * frequency) / (1. * frequency * 1.32);\n\treturn mix(sdSphere(pos, 0.2) / 1.0,\n               noise,\n               0.85);\n}\n\nvec2 pos3t2(vec3 pos){\n\tfloat r = length(pos);\n\tfloat Y = acos(pos.y / r) / PI; \n\tfloat X = atan(-pos.z/r, pos.x/r) / PI / 2.0;\n    \n\treturn vec2(X,Y);\n}\nvec3 pos2t3(vec2 pos){\n\tfloat X = sin(pos.y*PI) * cos(pos.x* PI*2.0);\n\tfloat Y = cos(pos.y*PI);\n\tfloat Z = -sin(pos.y*PI) * sin(pos.x* PI*2.0);\n\treturn vec3(X,Y,Z);\n}\nfloat height(vec3 p){\n    float ret = sdWeirdSphere(p, 128.0);\n    ret += sdWeirdSphere(p, 64.0);\n    ret += sdWeirdSphere(p, 4.0);\n    ret += sdWeirdSphere(p, 2.0);\n    ret += sdWeirdSphere(p, 1.0);\n    ret += sdWeirdSphere(p, 8.0);\n    ret += sdWeirdSphere(p, 16.0);\n    ret += sdWeirdSphere(p, 32.0);\n    ret /= 2.0;\n    ret -= 0.5;\n    \n    return ret;\n}\n\nvec2 terrain(vec3 p, float h){\n\tfloat col = sdWeirdSphere(p, 32.0);\n    col += sdWeirdSphere(p, 16.0);\n    col += sdWeirdSphere(p, 4.0);\n    \n    float t = 1.0 - (abs(p.y*1.2) - max(h, 0.0)*0.05);\n    t = min((t+ col)/2.0, 1.0);\n    t = pow(t, 0.5) - 0.15;\n    \n    float s = abs((abs(p.y) - 0.5)*2.0);\n    s = min((s+ col)/2.0,1.0) + 0.25;\n    \n    return vec2(t , s);\n}\n\nvec3 color(vec3 p, vec2 th,float h){      \n    if(th.x<0.2)\n        return vec3(1,1,1) * pow(1.0 - min(th.x/0.2,1.0), 0.125)*2.0;\n    \n    vec3 sea = vec3(0,0.18,0.45);\n    if(h < 0.0)\n    \treturn sea * (1.0 + h * 2.0);\n    \n\tvec3 sand = vec3(0.9,0.66,0.3);\n    vec3 grass = vec3(0.05,0.4,0.05);\n    \n    float lp = (th.x + th.y*3.0)/3.0;\n    lp = clamp(lp, 0.0, 1.0);\n    \n    return mix(sand, grass, pow(lp, 8.0)) * (pow(h, 0.25)+ 0.5);\n}\n\nvec2 Spiral(vec2 uv)\n{\n\tfloat reps = 2.0;\n\tvec2 uv2 = fract(uv*reps);\n\tvec2 center = floor(fract(uv*reps)) + 0.5;\n\tvec2 delta = uv2 - center;\n\tfloat dist = length(delta);\n\tfloat angle = atan(delta.y, delta.x);\n\t//if (distance(center, uv2) < 0.02) return vec2(10,10);\n\tfloat nudge = dist * 4.0;\n\tvec2 offset = vec2(delta.y, -delta.x);// * 0.2 / dist ;// vec2(sin(angle+nudge), cos(angle+nudge));\n\tfloat blend = max(abs(delta.x), abs(delta.y))* 2.0;\n\tblend = clamp((0.5 - dist) * 2.0, 0.0, 1.0);\n\tblend = pow(blend, 1.5);\n\t//offset *= clamp(1.0 - blend, 0.0, 1.0);\n\toffset *= clamp(blend, 0.0, 1.0);\n\t//if (dist > 0.5) offset = vec2(0,0);\n\t//offset *= dist;\n\treturn uv + offset*vec2(1.0,1.0)*1.1+ vec2(iTime*-0.03, 0.0);\n}\nfloat cloud(vec3 p){\n    vec3 t = p;\n    p.x=t.x * cos(iTime*0.01) - t.z*sin(iTime*0.01);\n    p.z=t.x * sin(iTime*0.01) + t.z* cos(iTime*0.01);\n    vec2 uv = pos3t2(p);\n\n \t//float c = texture(iChannel0,(Spiral(uv* 3.0) + Spiral(uv* 2.0))).r;\n    vec3 cp = pos2t3(Spiral(uv* 2.0) + Spiral(uv* 3.0));\n    \n    float c =  perlin_noise3(cp*vec3(8.0,16.0,8.0));\n    c += perlin_noise3(cp*vec3(4.0,8.0,4.0))*2.0;\n    c += perlin_noise3(cp*vec3(1.0,2.0,1.0))*3.0;\n    c += perlin_noise3(cp*vec3(32.0,64.0,32.0));   \n    c -= perlin_noise3(p*1.5);\n    c -= perlin_noise3(p*5.0);\n    \n    float s = abs((abs(p.y) - 0.5)*2.0);\n\tc += s;\n    \n    return max(c ,0.0);\n}\n\nvec3 camera(vec2 uv,vec3 camPos, vec3 camLookat, vec3 camUp){\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n   \n    return relVec;\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out float distFromSphere, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nvec3 rotate(vec3 pos, vec2 xy)\n{\n    vec3 camerapos = pos;\n    camerapos.z=pos.z * cos(-xy.y) - pos.y* sin(-xy.y);\n    camerapos.y=pos.z * sin(-xy.y) + pos.y* cos(-xy.y);\n    pos = camerapos;\n   \tcamerapos.x=pos.x * cos(xy.x) - pos.z* sin(xy.x);\n    camerapos.z=pos.x * sin(xy.x) + pos.z* cos(xy.x);\n    \n    return camerapos;\n}\n\nfloat nightLight(vec3 pos, float h, vec2 th){\n    float l= perlin_noise3(pos*vec3(128.0,128.0,128.0))*3.0;\n    \n    float p = perlin_noise3(pos*vec3(32.0,32.0,32.0))*2.0;\n    p += perlin_noise3(pos*vec3(8.0,8.0,8.0));\n    p += perlin_noise3(pos*vec3(16.0,16.0,16.0));\n    p -= perlin_noise3(pos*vec3(4.0,4.0,4.0))*4.0;\n    \n    l*=clamp(p,0.0,1.0)*max(th.x - 0.2, 0.0) * th.y * 2.0;\n    \n    return l*(h>0.0?1.0:0.0);\n}\n\nvec3 earth(vec2 uv){\n    vec3 camerapos = vec3(0,0,1)*2500.0;\n    vec3 up = vec3(0,1,0);\n    \n    vec3 pos = rotate(camerapos,iMouse.xy/iResolution.xy*10.0);\n    up = rotate(up,iMouse.xy/iResolution.xy*10.0);\n    \n    vec3 earthPos = vec3(0,0,0);\n    vec3 dir = camera(uv-0.5, pos, earthPos, up);   \n\n    \n    vec3 ld = vec3(1,0,1);\n   \n    float dis = 0.0;\n    vec3 n;\n    vec3 f;\n\n    vec3 col = vec3(0,0,0);\n    \n    float r = IntersectSphereAndRay(earthPos, 1040.0,pos,pos + dir*2000.0, dis,n,f );\n    \n    float lt = 0.0;\n    if(r > 0.5){\n\t\tvec3 p = normalize(n - earthPos);\n   \t\tp = rotate(p, vec2(iTime*-0.2,0));\n        \n        vec3 v = reflect(-ld, p);\n        \n        lt = max(dot(p, ld), 0.0);\n        float sp = pow(max(dot(-normalize(v), normalize(n - pos)), 0.0), 3.0) * 2.3;\n\n        col = min(vec3(1.0,0.8,0.3)*sp,1.0) + vec3(0.05,0.8,1.0)*lt;\n            \n        float sr = pow(length(f - n)/1200.0, 2.0) * 2.0;\n            \n        col *=sr;\n    }\n    \n    r = IntersectSphereAndRay(earthPos, 1000.0,pos,pos + dir*2000.0, dis,n,f );\n    if(r > 0.5){\n\t\tvec3 p = normalize(n - earthPos);\n   \t\tp = rotate(p, vec2(iTime*-0.2,0));\n        \n        float ht = height(p);\n\n        vec2 t = terrain(p, ht);\n\n        col = color(p, t, ht);\n\n        col *= lt;\n\n        vec3 v = reflect(-ld, p);\n        float sp = pow(max(dot(-normalize(v), normalize(n - pos)), 0.0), 5.0) * lt;\n\n        float ss = sdWeirdSphere(p, 16.0)*2.0* lt;\n\n        col += vec3(1.0,0.8,0.3)*sp * (ht < 0.0?pow(ss,0.5)*2.0:1.0);\n                      \n        float nl = nightLight(p, ht, t);\n        col += vec3(1.0,0.8,0.3)* clamp(nl * (1.2 - lt),0.0,1.0);\n               \n        float c = cloud(p)/2.0;\n        col = mix(col, vec3(c)*lt, c);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = earth(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}