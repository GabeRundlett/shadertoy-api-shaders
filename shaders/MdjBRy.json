{
    "Shader": {
        "info": {
            "date": "1501083039",
            "description": "Image enhancement / post processing with Brightness, Contrast, Saturation, and Hue shifts, all in one\nVibrance forked from https://shadertoy.com/view/llGSzK, performance optimized a little bit\nHueShift forked from https://shadertoy.com/view/MsjXRt",
            "flags": 0,
            "hasliked": 0,
            "id": "MdjBRy",
            "likes": 15,
            "name": "Bright Contrast Saturation Hue",
            "published": 3,
            "tags": [
                "postprocessing",
                "imageprocessing",
                "saturation",
                "hue",
                "brightness",
                "rotation",
                "shift",
                "constrast"
            ],
            "usePreview": 1,
            "username": "starea",
            "viewed": 6011
        },
        "renderpass": [
            {
                "code": "/** \n * Brightness Contrast Saturation Hue\n * Demo: https://www.shadertoy.com/view/MdjBRy\n * starea @ ShaderToy\n * \n * Forked and remixed from: \n * [1] https://shadertoy.com/view/llGSzK\n * [2] https://shadertoy.com/view/MsjXRt\n *\n * Created 7/26/2017\n * Updated 8/11/2017\n **/\n\n/*\nmat4 brightnessMatrix( float b ) {\n    return mat4( \n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        b, b, b, 1 );\n}\n*/\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\n/*\nmat4 contrastMatrix( float c ) {\n\tfloat t = 0.5 - c * 0.5;\n    return mat4( \n        c, 0, 0, 0,\n        0, c, 0, 0,\n        0, 0, c, 0,\n        t, t, t, 1 );\n\n}\n*/\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\n// remixed from mAlk's https://www.shadertoy.com/view/MsjXRt\nvec4 shiftHue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n\tfloat brightness = 0.15;\n\tfloat contrast = 1.2;\n    float saturation = 1.5;\n    float _vibrance = 4.0;\n    float _hue = abs(sin(iTime * 0.1)); \n    \n    vec4 color = texture( iChannel0, fragCoord/iResolution.xy );\n    \n    fragColor = saturationMatrix(saturation) * color; \n    brightnessAdjust(color, brightness); \n    contrastAdjust(color, contrast); \n    fragColor = vibrance(fragColor, _vibrance);\n    fragColor = shiftHue(fragColor.rgb, _hue);\n    fragColor.a = 1.0;\n    if (iMouse.z > 0.5) fragColor = color; \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}