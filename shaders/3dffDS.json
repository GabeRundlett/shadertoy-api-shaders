{
    "Shader": {
        "info": {
            "date": "1588936520",
            "description": "Fibonacci lattice on a sphere defines the locations of the prongs on this strange device. who's inside the ball? is this justice?",
            "flags": 32,
            "hasliked": 0,
            "id": "3dffDS",
            "likes": 30,
            "name": "Satanic Torture Ball",
            "published": 3,
            "tags": [
                "ball"
            ],
            "usePreview": 1,
            "username": "blackle",
            "viewed": 843
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment for fake reflections\n//#define FAKEREF\n//uncomment for outlines\n//#define OUTLINES\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p)-b;\n    return super(max(q,0.))+min(0.,max(q.x,q.y));\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p)-b;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 local;\nfloat brt;\nfloat scene(vec3 p) {\n    local = p;\n    float bump = smoothstep(0.5,0.,length(sin(p*10.))/sqrt(3.));\n    float sphere = length(p)-1.+bump*0.02;\n    brt = 1.;\n\n    vec2 uvs = map_from_sphere(p);\n    vec4 data = texelFetch(iChannel0, ivec2(uvs*iChannelResolution[0].xy), 0);\n    vec3 closest = data.xyz;\n\n    float rot = hash(closest.z,closest.y)*PI*2.;\n    float off = smoothstep(-0.9,0.9,sin(hash(rot,closest.x)*PI*2.+iTime*8.))*0.4-0.2;\n\n    //map to box coordinates\n    p -= closest;\n    vec3 b1 = normalize(cross(closest,vec3(0,0,1)));\n    vec3 b2 = cross(b1, closest);\n    vec3 crds = vec3(dot(p,closest), dot(p,b1), dot(p,b2));\n    crds = erot(crds,vec3(1,0,0),rot);\n    float hole = box(vec2(crds.x,box(crds.yz, vec2(0.04))-.01),vec2(0.01))-.01;\n    if(hole < sphere) brt = 0.4;\n    sphere = smin(sphere, hole, 0.05);\n    \n    crds.x -= off;\n    float obj = box(crds,vec3(0.3,0.005,0.005));\n    vec3 xcrd = abs(crds-vec3(.3,0,0));\n    xcrd.yz = vec2(max(xcrd.y,xcrd.z),min(xcrd.y,xcrd.z));\n    obj = smin(obj, box(xcrd,vec3(0.005,0.1,0.005)), 0.01);\n    obj = smin(obj, length(xcrd-vec3(0,.1,0))-0.02, 0.01);\n    obj = smin(obj, length(crds-vec3(0.34,0,0))-0.02, 0.01);\n    obj -= 0.02;\n    if (obj < sphere) {\n        brt = 0.7 * smoothstep(-0.2,0.3,crds.x);\n    \tlocal = crds+rot*10.;\n    } else if (sphere < 0.01) {\n    \tvec2 uvs2 = map_from_sphere(closest)-uvs;\n        brt *= smoothstep(0.0,0.02, length(uvs2*vec2(2,0.5)+vec2(0,.01))-uvs2.y*0.1)*0.5+0.5;\n    }\n    return min(sphere, obj*0.9);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.0001);\n    return normalize(scene(p)- vec3(scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat trilinear(vec3 p, vec3 n) {\n    \n    float xy = texture(iChannel1, p.xy).x;\n    float zy = texture(iChannel1, p.zy).x;\n    float xz = texture(iChannel1, p.xz).x;\n    return mix(mix(xy,zy, n.x*n.x),xz,n.y*n.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    //fragColor.xyz = cos(texelFetch(iChannel0, ivec2(fragCoord),0)*80.).xxx*0.5+0.5;\n    //return;;\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5,0,0);\n\n   \tfloat yrot = asin(sin(iTime*2.3)*0.95)*0.3;\n    float zrot = 3.5-asin(sin(iTime*0.54)*0.99)*1.5;\n    if (iMouse.z > 0.) {\n        yrot = -4.*mouse.y;\n        zrot = 4.*mouse.x+3.5;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n#ifdef OUTLINES\n    bool triggered = false;\n    bool outline = false;\n#endif\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n#ifdef OUTLINES\n        if (dist < 0.009) triggered = true;\n        if (triggered) {\n            float odist = 0.01-dist;\n            outline = odist < dist;\n            dist = min(odist, dist);\n        }\n#endif\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if(distance(p,init)>7.)break;\n    }\n#ifdef OUTLINES\n    if (outline) {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec3 l = local;\n    float lbrt = brt;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    vec2 uvs = map_from_sphere(p);\n    vec4 data = texture(iChannel0, uvs);\n    float str = smoothstep(0.1,0.0,data.w);\n\n#ifdef FAKEREF\n\tvec2 ao = vec2(0);\n    for (int i = 0; i < 10; i++) {\n        vec3 p2 = p+n*.1;\n        for (int j = 0; j < 10; j++) {\n            float h1 = hash(float(i),float(j));\n            float h2 = hash(h1, h1);\n            float h3 = hash(h1, h2);\n            p2 += normalize(tan(vec3(h1,h2,h3))+r*2.)*scene(p2)*.9;\n        }\n        ao += vec2(smoothstep(-0.1,0.1,scene(p2)),1.);\n    }\n    ao.x/=ao.y;\n#else\n    vec2 ao = vec2(1);\n#endif\n    \n    float tex = trilinear(l*2.+data.w, n)*smoothstep(0.7,0.4,trilinear(l*0.1+2., n));\n    float tex2 = trilinear(l*0.25, n);\n    float spexex = mix(15.,5.,tex);\n    float spec = ao.x*length(sin(r*2.5)*0.5+0.5)/sqrt(3.)*(1.-pow(dot(r,n),2.)*.1);\n    float diff = lbrt*mix(length(sin(n*2.5)*0.5+0.5)/sqrt(3.), spec,0.95);\n\n    \n    vec3 col = mix(srgb(0.1,0.03,0.01), srgb(0.5,0.3,0.3), diff) + pow(spec, spexex)*1.5;\n\n    col = abs(erot(col, normalize(p.zyx), tex2*0.2));\n    col = abs(erot(col, normalize(p), str*0.1));\n    fragColor.xyz = sqrt(hit ? col : smoothstep(1.,0.,length(uv))*vec3(0.1));\n    fragColor.xyz = smoothstep(vec3(-0.2),vec3(1.2),fragColor.xyz) + hash(hash(uv.x,uv.y),float(iFrame))*0.02;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\nconst int NUM_POINTS = 50;\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec3 map_to_sphere(vec2 p)\n{\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\n    if (iFrame != 0) {\n        fragColor = texelFetch(iChannel0,ivec2(iResolution.xy),0);\n    }\n    \n    float dist = 10000.;\n    vec3 closest = vec3(0);\n\n\tfloat gr = (sqrt(5.0) + 1.0) / 2.0;\n    float ga = (2.0 - gr) * (2.0*PI);\n\n    vec3 uvs = map_to_sphere(uv);\n    for (int i = 0; i < NUM_POINTS; i++) {\n        float lat = asin(-1.0 + 2.0 * float(i+1) / float(NUM_POINTS+1));\n        float lon = ga * float(i+1);\n\n        vec3 p = vec3(sin(lon)*cos(lat), cos(lon)*cos(lat),sin(lat));\n        float d = distance(p,uvs);\n        if (d < dist) {\n            closest = p;\n        }\n        dist = smin(dist,d,0.01);\n    }\n    fragColor = vec4(closest, dist);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}