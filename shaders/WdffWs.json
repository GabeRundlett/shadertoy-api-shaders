{
    "Shader": {
        "info": {
            "date": "1590282516",
            "description": "First attempt at some glitch art",
            "flags": 32,
            "hasliked": 0,
            "id": "WdffWs",
            "likes": 5,
            "name": "TV set",
            "published": 3,
            "tags": [
                "noise",
                "sdf",
                "glitch"
            ],
            "usePreview": 1,
            "username": "saticmotion",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nvec4 clamp01(vec4 val)\n{\n    return clamp(val, 0., 1.);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdCircle(vec2 uv, float size)\n{\n    return length(uv) - size;\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat knobsSdf(vec2 p)\n{\n    return min(sdCircle(p + vec2(-.9, -.3), .1), \n               sdCircle(p + vec2(-.9, -.04), .1));\n\n}\n\nfloat knobsSdf2(vec2 p)\n{\n    return min(sdCircle(p + vec2(-.9, -.3), .05), \n               sdCircle(p + vec2(-.9, -.04), .05));\n}\n\nfloat grilleSdf(vec2 p)\n{\n    float sdf = 1.;\n    for (float i = 0.; i < 10.; i++)\n    {\n        sdf = min(sdf, sdRoundBox(p + vec2(0, i/30.), vec2(.12, .008), 0.02));\n    }\n    \n    return sdf;\n}\n\nvec2 rot(vec2 p, float angle)\n{\n    angle = angle * PI / 180.;\n    mat2 rotation = inverse(mat2(cos(angle), sin(angle), -sin(angle), cos(angle)));\n\treturn rotation * p;\n}\n\nfloat legsSdf(vec2 p)\n{\n    vec2 taper = vec2(p.y, 1);\n    return min(sdRoundBox((rot(p + vec2(-0.7, .8), 20.)) / taper,\n        \t\t\tvec2(.04, .3), 0.0),\n               sdRoundBox((rot(p + vec2(0.5, .8), -20.)) / taper,\n        \t\t\tvec2(.04, .3), 0.0));\n}\n\nfloat antennaSdf(vec2 p)\n{\n    vec2 taper = vec2(1. - p.y / 1.1, 1);\n    return min(sdRoundBox((rot(p + vec2(-0.3, -.75), -30.)) / taper,\n        \t\t\tvec2(.015, .25), 0.0),\n               min(sdRoundBox((rot(p + vec2(0.1, -.75), 30.)) / taper,\n        \t\t\t\tvec2(.015, .25), 0.0),\n                   min(sdCircle(p + vec2(-0.42, -.96), .015),\n                       sdCircle(p + vec2(0.22, -.96), .015)\n                  )));\n}\n\nfloat glowColMod(float t)\n{\n    float fps = random(vec2(floor(t * 10.)));\n    float rand = random(vec2(floor(t * fps)));\n    return rand / 20. + 0.2;\n}\n\nvec2 noiseGlitch(vec2 uv)\n{\n    float strength = 15.;\n    float offset = 10. - fract(iTime / 10.) * 25.;\n    float compression = 10. * sin(iTime) + 20.;\n    \n    float x = (uv.y * compression) - offset;\n    float x2 = pow(x, 4.) - 5.*pow(x, 3.) + 5.*pow(x, 2.) + x - 5.;\n    \n    float res = (min(0., x2) / strength);\n    \n    return vec2(res, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 uvcrt = uv * pow(length(vec2(uv.x, uv.y)) + 0.3, .3);\n    \n    float crtSdf = \t\t\t-sign(\t\t\t\t\t\tsdRoundBox(uvcrt, vec2(.75, .5), 0.1));\n    float glossSdf = \t \tsign(min(crtSdf, \t\t\tsdCircle(uvcrt - vec2(-1.1, 3.7), 4.)));\n    float cabTemp = \t\t-(max(crtSdf, \t\t\t\tsdRoundBox(uv + vec2(-.1, .0), vec2(.95, .6), 0.1)));\n    float cabinetSdf = \t\tpow(clamp(cabTemp, 0., 1.) + .3, 1.);\n    float cabinetSdfSign = \tsign(cabTemp);\n    float knobSdf = \t\t-sign(\t\t\t\t\t\tknobsSdf(uv));\n    float knobSdf2 = \t\t-sign(\t\t\t\t\t\tknobsSdf2(uv));\n    float grilleSdf = \t\t-sign(\t\t\t\t\t\tgrilleSdf(uv + vec2(-.9, .15)));\n    float legsSdf = \t\t-sign(max(cabinetSdfSign, \tlegsSdf(uv)));\n    float antennaSdf = \t\t-sign(max(cabinetSdfSign, \tantennaSdf(uv)));\n    float glowSdf = \t\t-clamp(max(crtSdf,\t\t\tsdTrapezoid(uv + vec2(0., .9), 3., .72, 1.1)), -.9, .0);\n    \n    vec2 noiseGlitch = \t noiseGlitch(uv);\n    vec4 noiseCol = \t clamp01(texture(iChannel1, (uv / 2.) + noiseGlitch + vec2(0.5)) * clamp01(crtSdf));\n    vec4 fadeCol = \t\t clamp01(vec4(vec3(0), length(uv)-.3)\t* crtSdf);\n    vec4 noiseColFaded = (fadeCol + noiseCol * 1. - fadeCol.a) * crtSdf;\n    vec4 glossCol = \t clamp01(vec4(vec3(.3), 1)  \t\t\t* glossSdf * .35);\n    vec4 cabinetCol = \t clamp01(texture(iChannel0, uv * 2.) \t* cabinetSdfSign * cabinetSdf);\n    vec4 knobCol = \t\t clamp01(vec4(vec3(1), 1) \t\t\t\t* knobSdf);\n    vec4 knobCol2 =\t\t clamp01(vec4(vec3(.5), 1) \t\t\t\t* knobSdf2) * 2.75;\n    vec4 grilleCol =\t clamp01(vec4(vec3(1), 1) \t\t\t\t* grilleSdf);\n    vec4 legsCol = \t\t clamp01(texture(iChannel0, rot(uv, 90.)) * legsSdf * .15);\n    vec4 antennaCol = \t clamp01(vec4(vec3(.5), 1)\t\t\t\t* antennaSdf);\n    vec4 glowCol = \t \t clamp01(vec4(vec3(glowColMod(iTime)), 1.) * glowSdf);\n    \n    fragColor = (noiseColFaded + glossCol + cabinetCol + legsCol + antennaCol - knobCol + knobCol2 - grilleCol) * (1.-glowCol) + glowCol;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define crtFps 24.\n\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 screenNoise(in vec2 uv, float iTime)\n{\n    float framerate = crtFps;\n    float frametime = floor(iTime * framerate) / framerate;\n    \n    vec2 randseed = floor(uv * 160.) / 160. + random(vec2(frametime));\n    \n    vec3 col = vec3(random(randseed));\n    //NOTE(Satic): Add a bit of blue\n\tcol = vec3(col.r, col.g, pow(col.b, .7));\n    return col;\n}\n\nfloat clamp01(float x)\n{\n    return clamp(x, 0., 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 boxUv = uv + vec2(0, 1. - fract(iTime / 4.) * 2. + 0.25);\n    vec2 boxUv2 = uv + vec2(0, 1. - fract(iTime / 2.85) * 2. + 0.25);\n    float box = -sign(sdBox(boxUv, vec2(2., .1 + sin(iTime) / 20.)));\n    float box2 = -sign(sdBox(boxUv2, vec2(2., .05 + sin(iTime / 2.) / 20.)));\n    \n    vec3 boxCol = vec3(0.1) * max(box, box2);\n    \n    float glitch1Time = fract(iTime / cos(floor(iTime / 2.)));\n    vec2 glitch1 = vec2(cos(uv.x + uv.y * 2.), uv.y * uv.x) * smoothstep(.5, .6, glitch1Time);\n\n    vec3 col = screenNoise(uv + glitch1, iTime) - boxCol;\n    \n    float redGlitch =    clamp01(abs(tan(iTime * 1.5) + 2.)) / 8. + 0.875;\n    float greenGlitch =  clamp01(abs(tan(iTime * 1.2) + 2.)) / 8. + 0.875;\n    float blueGlitch =   clamp01(abs(tan(iTime * 1.1) + 2.)) / 8. + 0.875;\n    \n    fragColor = vec4(vec3(col.r * redGlitch, col.g * greenGlitch, col.b * blueGlitch), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}