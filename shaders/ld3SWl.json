{
    "Shader": {
        "info": {
            "date": "1462109688",
            "description": "Was will uns der KÃ¼nstler damit sagen?",
            "flags": 32,
            "hasliked": 0,
            "id": "ld3SWl",
            "likes": 20,
            "name": "Komplex",
            "published": 3,
            "tags": [
                "chromaticaberration",
                "feedback",
                "polygon"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 956
        },
        "renderpass": [
            {
                "code": "/*\n   (c) 2016, stefan berke\n   \n   Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)\n*/\n\nvec4 tex(in vec2 uv)\n{\n    vec4 t = texture(iChannel0, uv);\n    vec3 col = vec3(1.-t.x);\n    //col.yz *= 1. - t.z; // show edge\n    return vec4(col,1);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 spectral(in float f)\n{\n    // edge fade\n    float v = smoothstep(-0.03, 0.2, f);\n    v = min(v, smoothstep(1.03, 0.8, f));\n    // shift middle part together\n    f = f * f * (3. - 2. * f);\n    // scale\n    f = max(0., f*(0.9) - 0.08);\n    return hsv2rgb(vec3(f, 1., v));\n}\n\n// Insert [-1,1] receive [0,1]\nvec2 lens_lookup(in vec2 uv, float f)\n{\n    uv += f * uv * dot(uv, uv);\n\n    // 'normalize'\n    uv /= 1. + 1.5 * f;\n    \n    return 1. * uv * .5 + .5;\n}\n\n// uv is [-1,1]\nvec4 lens_chroma(in vec2 uv)\n{\n    float f = .1, f1 = 30. / iResolution.x;\n    \n    vec4 col = vec4(0.);\n    float sum = 0.;\n\n    const int num_samples = 5;\n    for (int i=0; i<num_samples; ++i)\n    {\n        float hue = (float(i)+.5) / float(num_samples);\n        // spectral color\n        vec4 sp = vec4(pow(spectral(hue), vec3(1.1)), 1.);\n        col += sp * tex(lens_lookup(uv, f+hue*f1));\n        sum += .35;\n    }\n    return col / sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    \n    fragColor = lens_chroma(tuv*2.-1.)\n        // * pow(1.-max(abs(tuv.x-.5),abs(tuv.y-.5))*2.,.1);\n       \t* pow(1.-length(tuv-.5),.2);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash1(in vec2 uv) { return fract(sin(uv.x*31.+uv.y*37.)*(7654.+uv.y*11.)); }\nvec2  hash2(in vec2 uv) { return vec2(hash1(uv),hash1(uv.yx+3.1)); }\n\nvec4 tex(in vec2 uv) { return texture(iChannel0, mod(uv,vec2(1.))); }\n\nvec4 polygon(in vec2 uv, in float num, in float rot, in vec2 seed)\n{\n    const float Pi = 3.14159265;\n    float Pin = Pi/num;\n    \n    float d = length(uv);\n \tfloat a = atan(uv.x, uv.y) + rot;\n    \n    float am = mod(a+Pin, 2.*Pin)-Pin;\n    \n    vec2 uvm = d * vec2(sin(am), cos(am));\n    vec2 uvr = d * vec2(sin(a), cos(a));\n    \n    // polygon fill\n    float poly = smoothstep(0.01, 0., uvm.y-.7);\n    float edge = smoothstep(0.01, 0., abs(uvm.y-.7)-0.005);\n    // cut out previous frame\n    float sc = 1. + 5. * hash1(seed);\n    float cut = max(0., 1. - 4.*tex(uvr/sc+.5).x);\n    // add previous frame\n    sc = 1. + 5. * hash1(seed*1.1);\n    vec4 add = tex(uvr/sc+.5)/(1.+.3*d);\n    \n    vec4 f = vec4(cut * poly);\n    if (add.y > .5)\n    {\n        add.x = 1.;\n        add.y *= .9;\n        f += add;\n    }\n    f.z = edge;\n    return f;\n}\n    \nvec4 pattern(in vec2 uv)\n{\n    vec4 f=vec4(0.);\n    \n    vec2 seed = vec2(0.1);\n\tfor (int i=0; i<5; ++i)\n    {\n        vec2 pos = uv * (.1+3.*hash1(seed))\n                     \t+ 2.*sin(hash2(seed*3.11)+.2*iTime*hash1(seed*2.1));\n        float num = 3. + floor(hash1(seed*2.1)*5.);\n        float rot = hash1(seed*1.1) * .1*iTime;\n        \n        f = max(f, polygon(pos, num, rot, seed*3.331-3.31 ));\n        seed += hash2(seed*3.);\n    }\n    return clamp(f,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv = fragCoord.xy / iResolution.xy;\n\tvec4 prev = texture(iChannel0, tuv);\n    \n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    vec4 f = pattern(uv*5.);\n    \n    f = prev + .5 * (f - prev);\n\tfragColor = vec4(f.xyz,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}