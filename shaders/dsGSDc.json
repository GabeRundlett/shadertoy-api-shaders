{
    "Shader": {
        "info": {
            "date": "1681799383",
            "description": "to draw wall, mouse press on wall. To erase wall, mouse press on air\nW: water/ auto brush\nG: toggle gravity direction\nV: velocity display\nF: free surface display\nLBM: https://en.wikipedia.org/wiki/Lattice_Boltzmann_methods",
            "flags": 48,
            "hasliked": 0,
            "id": "dsGSDc",
            "likes": 13,
            "name": "Water on the planet",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "water",
                "fluid",
                "lbm",
                "latticeboltzmann",
                "freesurface"
            ],
            "usePreview": 0,
            "username": "ddinhddoong",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "// visualization\n\n#define CUR_ARR 0\n\n/*\nvec3 hue2rgb(float i){\n    //return clamp(3.0*abs(1.-2.*fract(i+vec3(-1./3.,1./3.,0.)))-1.,0.,1.);\n    return 3.0*abs(1.-2.*fract(i+vec3(-1./3.,1./3.,0.)))-1.;\n}//*/\n\n// draw arrows \n// 2D vector field visualization by Morgan McGuire, from @morgan3d, http://casual-effects.com\nconst float PI = 3.1415927;\nconst int   ARROW_V_STYLE = 1;\nconst int   ARROW_LINE_STYLE = 2;\nconst int   ARROW_STYLE = ARROW_LINE_STYLE;\n#if CUR_ARR\n    const float ARROW_TILE_SIZE = 17.;\n    const float ARROW_HEAD_ANGLE = 90.0 * PI / 180.0;\n    const float ARROW_HEAD_LENGTH = ARROW_TILE_SIZE / 7.;\n    const float ARROW_SHAFT_THICKNESS = 2.;\n#else\n    const float ARROW_TILE_SIZE = 10.;\n    const float ARROW_HEAD_ANGLE = 60.0 * PI / 180.0;\n    const float ARROW_HEAD_LENGTH = ARROW_TILE_SIZE / 10.;\n    const float ARROW_SHAFT_THICKNESS = 0.;\n#endif\n\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\nfloat arrow(vec2 p, vec2 v) {\n\tp -= arrowTileCenterCoord(p);\n    float mag_v = length(v), mag_p = length(p);\n\tif (mag_v > .5) {\n\t\tvec2 dir_p = p / mag_p, dir_v = v / mag_v;\n\t\tmag_v = clamp(mag_v, 0.5, ARROW_TILE_SIZE / 3.);\n\t\tv = dir_v * mag_v;\n\t\tfloat dist;\t\t\n\t\tif (ARROW_STYLE == ARROW_LINE_STYLE) {\n\t\t\tdist = max(ARROW_SHAFT_THICKNESS / 4.0 - \n                    max(abs(dot(p, vec2(dir_v.y, -dir_v.x))),\n                        abs(dot(p, dir_v)) - mag_v + ARROW_HEAD_LENGTH / 2.0), \n                        min(0.0, dot(v - p, dir_v) - cos(ARROW_HEAD_ANGLE / 2.0) * length(v - p)) * 2.0 +\n                        min(0.0, dot(p, dir_v) + ARROW_HEAD_LENGTH - mag_v));\n\t\t} else {\n\t\t\tdist = min(0.0, mag_v - mag_p) * 2.0 +\n\t\t\t\t   min(0.0, dot(normalize(v - p), dir_v) - cos(ARROW_HEAD_ANGLE / 2.0)) * 2.0 * length(v - p) +\n\t\t\t\t   min(0.0, dot(p, dir_v) + 1.0) +\n\t\t\t\t   min(0.0, cos(ARROW_HEAD_ANGLE / 2.0) - dot(normalize(v * 0.33 - p), dir_v)) * mag_v * 0.8;\n\t\t}\n\t\t\n\t\treturn clamp(0.6 + dist, 0.0, 1.0);\n\t} else {\n\t\treturn max(0.0, 1.2 - mag_p);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    ivec2 idx = ivec2(fragCoord * 0.5);\n\n    float rho = RHO(iChannel1, idx);\n    float F_len = rho>0.001? F_Len(iChannel0, idx)*min(rho*3.,1.)*8.:0.;\n    //float v_len = rho>0.0001? V_Len(iChannel0, idx)*min(rho*10.,1.)*3.:0.;\n    vec2 v = vec2(V_x(iChannel0, idx),V_y(iChannel0, idx));\n\n    float v_len = length(v);\n    //v_len = rho>0.001? v_len*min(rho*10.,1.)*3.:0.;\n    float wall = Wall(iChannel2, idx);\n    ivec2 size = ivec2(iResolution*0.5);\n\n    vec4 color = vec4(.0,.02,.07,1.);                       // display background (sky)\n    color.xyz += vec3(.05, .2, .25)*rho + v_len*rho/2.;     // display fluid (density)\n    color += vec4(0,F_len,0,0)*KEY_F;                       // display force (free surface)\n    color += vec4(.3,.2,.1,0.)*wall;                        // display wall\n    //color += vec4(hue2rgb(v_len)*v_len*0.8,1)*KEY_V;      // display velocity (color)\n    // display velocity\n    ivec2 idx_tile = ivec2(arrowTileCenterCoord(fragCoord) * 0.5);\n    vec2 v_tile = vec2(V_x(iChannel0, idx_tile),V_y(iChannel0, idx_tile));\n    color -= vec4(-5.,-5.,5.,0.) * arrow(fragCoord.xy,\n#if CUR_ARR\n    v\n#else\n    v_tile\n#endif\n    * ARROW_TILE_SIZE * 10.) * KEY_V*\n    step(.1,RHO(iChannel1, idx_tile)) *\n#if CUR_ARR\n    step(F_Len(iChannel0, idx),.5) *\n#endif    \n    step(wall, .1); //step(Wall(iChannel2, idx_tile),.1);\n    \n    fragColor=color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//from @ndel https://www.shadertoy.com/view/4dK3zG\n/*\n7 3 5\n2 0 1\n6 4 8\n*/\n#define f0(tex,idx) (texelFetch(tex, idx*2, 0).r)\n#define f1(tex,idx) (texelFetch(tex, idx*2, 0).g)\n#define f2(tex,idx) (texelFetch(tex, idx*2, 0).b)\n\n#define f3(tex,idx) (texelFetch(tex, idx*2+ivec2(1,0),0).r)\n#define f4(tex,idx) (texelFetch(tex, idx*2+ivec2(1,0),0).g)\n#define f5(tex,idx) (texelFetch(tex, idx*2+ivec2(1,0),0).b)\n\n#define f6(tex,idx) (texelFetch(tex, idx*2+ivec2(0,1),0).r)\n#define f7(tex,idx) (texelFetch(tex, idx*2+ivec2(0,1),0).g)\n#define f8(tex,idx) (texelFetch(tex, idx*2+ivec2(0,1),0).b)\n\n#define RHO(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).r)\n#define F_Len(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).g)\n#define V_x(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).b)\n#define V_y(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).a)\n\n#define PSI(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).a)\n\n#define Wall(tex, idx) (any(greaterThan(texelFetch(tex, idx*2,0).rg, vec2(0.5)))?1.:0.)\n\n#define KEY_F round(texelFetch(iChannel3, ivec2(70,2) , 0 ).x)\n#define KEY_G round(texelFetch(iChannel3, ivec2(71,2) , 0 ).x)\n#define KEY_V round(texelFetch(iChannel3, ivec2(86,2) , 0 ).x)\n#define KEY_W round(texelFetch(iChannel3, ivec2(87,2) , 0 ).x)\n\n#define dist2Mouse distance(iMouse.xy*0.5, vec2(idx))\n\nbool is_wall(in sampler2D ch,in ivec2 idx, in ivec2 size){\n    return (size.x < idx.x + 1) || (size.y < idx.y + 1) || (idx.x < 0) || (idx.y < 0) || (Wall(ch, idx) > 0.1);\n}\n\nvec4 save_color(in ivec2 off,in vec4[4] colors)\n{\n    return colors[/*3&*/(off.y<<1|off.x)];\n}\n\nconst float G_self = .7;          // affect the surface tension of the liquid molecules\nconst float G_wall = 0.25;         // affect the surface tension between the liquid and the wall\nconst float g = .008;             // gravity\nconst float k = 1.2;//.5;         // affect the viscidity, range: 0.1~1.9",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// streaming step\n\n// kernal\nconst ivec2 off[25] = ivec2[25](\n    ivec2( 0, 0 ),\n    ivec2( 1, 0 ),ivec2( 0, -1 ),ivec2( -1, 0 ),ivec2( 0, 1 ),\n    ivec2( 1, -1 ), ivec2( -1, -1 ), ivec2( -1, 1 ), ivec2( 1, 1 ),\n    ivec2( 2, 0 ), ivec2( 0, -2 ), ivec2( -2, 0 ), ivec2( 0, 2 ),\n    ivec2( 1, -2 ), ivec2( -1, -2 ), ivec2( -1, 2 ), ivec2( 1, 2 ),\n    ivec2( 2, -1 ), ivec2( -2, -1 ), ivec2( -2, 1 ), ivec2( 2, 1 ),\n    ivec2( 2, -2 ), ivec2( -2, -2 ), ivec2( -2, 2 ), ivec2( 2, 2 )\n);\nconst float w[9] = float[9](\n    0., 1. / 21., 4. / 45., 0., 1. / 60., 2. / 315., 0., 0., 1. / 5040.\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 idx = ivec2(fragCoord*0.5);\n    ivec2 size = ivec2(iResolution*0.5);\n    \n    if(is_wall(iChannel2,idx,size))\n    {\n        discard;\n    }\n    \n    // density distribution\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8;\n    // total density\n    float rho;\n    float psi;\n\n    // get f0~8 from BufferB\n    f0 = f0(iChannel1, idx);\n    f1 = f1(iChannel1, idx);\n    f2 = f2(iChannel1, idx);\n    f3 = f3(iChannel1, idx);\n    f4 = f4(iChannel1, idx);\n    f5 = f5(iChannel1, idx);\n    f6 = f6(iChannel1, idx);\n    f7 = f7(iChannel1, idx);\n    f8 = f8(iChannel1, idx);\n    psi = PSI(iChannel1, idx);\n    // density\n    rho = f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8;\n    // velocity\n    /* density gradient = vec2(right - left, top - down)\n    7 3 5\n    2 0 1\n    6 4 8\n    */\n    vec2 v1 = (1./(rho+ 1e-20)) * vec2((f1 - f2 + f5 - f6 + f8 - f7),(f3 - f4 + f5 - f6 + f7 - f8));\n\n    // calculate external force (surface tension)\n    // Shan-Chen-type model, https://journals.aps.org/pre/pdf/10.1103/PhysRevE.47.1815\n    vec2 F = vec2(0, 0);\n    for(int i = 1; i < 25; i++) {\n        ivec2 offset = off[i];\n        ivec2 idx2 = idx + offset;\n        float psi_self = PSI(iChannel1, idx2);\n        float psi_wall = is_wall(iChannel2, idx2, size) ? 1. : 0.;\n        F += (G_self * psi_self + G_wall * psi_wall) * vec2(offset) * w[offset.x * offset.x + offset.y * offset.y];\n    }\n    \n    F *= max(psi,.95);\n    vec2 dir = (KEY_G > 0.)? vec2(0,-1) : normalize(vec2(size/2) - fragCoord*0.5);\n    vec2 a = F * min(1./(rho+ 1e-20), 100.) + g*dir; //gravity\n    vec2 v2 = v1 + a; // velocity2\n    \n    // velocity limit\n    const float max_speed = 0.6;//0.57735027;\n    if(length(v1) > max_speed) {\n        v1 = normalize(v1) * max_speed;\n        //v1 *= 0.1;\n    }\n    if(length(v2) > max_speed) {\n        v2 = normalize(v2) * max_speed;\n        //v2 *= 0.1;\n    }\n\n    // f_eq(i,v)\n    float sq_term = - 1.5 * (v1.x * v1.x + v1.y * v1.y);\n    float f0eq = 4. / 9. * rho * (1. + sq_term);\n    float f1eq = 1. / 9. * rho * (1. + 3. * v1.x + 4.5 * v1.x * v1.x + sq_term);\n    float f2eq = 1. / 9. * rho * (1. - 3. * v1.x + 4.5 * v1.x * v1.x + sq_term);\n    float f3eq = 1. / 9. * rho * (1. + 3. * v1.y + 4.5 * v1.y * v1.y + sq_term);\n    float f4eq = 1. / 9. * rho * (1. - 3. * v1.y + 4.5 * v1.y * v1.y + sq_term);\n    float f5eq = 1. / 36. * rho * (1. + 3. * (v1.x + v1.y) + 4.5 * (v1.x + v1.y) * (v1.x + v1.y) + sq_term);\n    float f6eq = 1. / 36. * rho * (1. - 3. * (v1.x + v1.y) + 4.5 * (v1.x + v1.y) * (v1.x + v1.y) + sq_term);\n    float f7eq = 1. / 36. * rho * (1. + 3. * (- v1.x + v1.y) + 4.5 * (- v1.x + v1.y) * (- v1.x + v1.y) + sq_term);\n    float f8eq = 1. / 36. * rho * (1. - 3. * (- v1.x + v1.y) + 4.5 * (- v1.x + v1.y) * (- v1.x + v1.y) + sq_term);\n    \n    // f_eq(i,v2)\n    float sq_term2 = - 1.5 * (v2.x * v2.x + v2.y * v2.y);\n    float f0eq2 = 4. / 9. * rho * (1. + sq_term2);\n    float f1eq2 = 1. / 9. * rho * (1. + 3. * v2.x + 4.5 * v2.x * v2.x + sq_term2);\n    float f2eq2 = 1. / 9. * rho * (1. - 3. * v2.x + 4.5 * v2.x * v2.x + sq_term2);\n    float f3eq2 = 1. / 9. * rho * (1. + 3. * v2.y + 4.5 * v2.y * v2.y + sq_term2);\n    float f4eq2 = 1. / 9. * rho * (1. - 3. * v2.y + 4.5 * v2.y * v2.y + sq_term2);\n    float f5eq2 = 1. / 36. * rho * (1. + 3. * (v2.x + v2.y) + 4.5 * (v2.x + v2.y) * (v2.x + v2.y) + sq_term2);\n    float f6eq2 = 1. / 36. * rho * (1. - 3. * (v2.x + v2.y) + 4.5 * (v2.x + v2.y) * (v2.x + v2.y) + sq_term2);\n    float f7eq2 = 1. / 36. * rho * (1. + 3. * (- v2.x + v2.y) + 4.5 * (- v2.x + v2.y) * (- v2.x + v2.y) + sq_term2);\n    float f8eq2 = 1. / 36. * rho * (1. - 3. * (- v2.x + v2.y) + 4.5 * (- v2.x + v2.y) * (- v2.x + v2.y) + sq_term2);\n\n    // f_new(i) = (1-k)*f(i) + (k-1)*f_eq(i,v1) + f_eq(i,v2)\n    f0 = (1. - k) * f0 + (k - 1.) * f0eq + f0eq2;\n    f1 = (1. - k) * f1 + (k - 1.) * f1eq + f1eq2;\n    f2 = (1. - k) * f2 + (k - 1.) * f2eq + f2eq2;\n    f3 = (1. - k) * f3 + (k - 1.) * f3eq + f3eq2;\n    f4 = (1. - k) * f4 + (k - 1.) * f4eq + f4eq2;\n    f5 = (1. - k) * f5 + (k - 1.) * f5eq + f5eq2;\n    f6 = (1. - k) * f6 + (k - 1.) * f6eq + f6eq2;\n    f7 = (1. - k) * f7 + (k - 1.) * f7eq + f7eq2;\n    f8 = (1. - k) * f8 + (k - 1.) * f8eq + f8eq2;\n    \n    // save\n    ivec2 off = ivec2(int(fragCoord.x) - 2*idx.x,int(fragCoord.y) - 2*idx.y);\n    fragColor = save_color(off,vec4[4](\n    vec4(f0,f1,f2,1.),\n    vec4(f3,f4,f5,1.),\n    vec4(f6,f7,f8,1.),\n    vec4(rho,length(F),((v1+v2)*0.5).xy)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//collision step\n\n#define SizeChanged() (texelFetch(iChannel2, ivec2(0,0),0).r)\n\n#define PI 3.1415926535898\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    ivec2 idx = ivec2(fragCoord*0.5);\n    ivec2 size = ivec2(iResolution*0.5);\n\n    float f0, f1, f2, f3, f4, f5, f6, f7, f8;\n\n    if(!is_wall(iChannel2,idx,size)&&SizeChanged()<0.5)\n    {\n        ivec2 idx2;\n        //*\n        ivec2 sourcePos = ivec2(size.x/2,size.y/7*6);\n        if(length(vec2(sourcePos-idx))<6.) // water source\n        {\n            f4 = 0.5; //↓\n            //f1 = 1.; //→\n        }\n        else//*/\n        if(iMouse.z > 0. && dist2Mouse < 8.) //add water with mouse\n        {\n           f0 = 0.5*(KEY_W);\n        }\n        else // streaming and handling boundary condition \n        {\n            /* If hit a wall, change to the opposite direction\n                7 3 5\n                2 0 1\n                6 4 8\n            */\n            f0 = f0(iChannel0, idx);\n            idx2 = idx + ivec2(-1, 0);\n            f1 = is_wall(iChannel2,idx2, size) ? f2(iChannel0, idx) : f1(iChannel0, idx2);\n            idx2 = idx + ivec2(1, 0);\n            f2 = is_wall(iChannel2,idx2, size) ? f1(iChannel0, idx) : f2(iChannel0, idx2);\n            idx2 = idx + ivec2(0, -1);\n            f3 = is_wall(iChannel2,idx2, size) ? f4(iChannel0, idx) : f3(iChannel0, idx2);\n            idx2 = idx + ivec2(0, 1);\n            f4 = is_wall(iChannel2,idx2, size) ? f3(iChannel0, idx) : f4(iChannel0, idx2);\n            idx2 = idx + ivec2(-1, -1);\n            f5 = is_wall(iChannel2,idx2, size) ? f6(iChannel0, idx) : f5(iChannel0, idx2);\n            idx2 = idx + ivec2(1, 1);\n            f6 = is_wall(iChannel2,idx2, size) ? f5(iChannel0, idx) : f6(iChannel0, idx2);\n            idx2 = idx + ivec2(1, -1);\n            f7 = is_wall(iChannel2,idx2, size) ? f8(iChannel0, idx) : f7(iChannel0, idx2);\n            idx2 = idx + ivec2(-1, 1);\n            f8 = is_wall(iChannel2,idx2, size) ? f7(iChannel0, idx) : f8(iChannel0, idx2);\n        }\n    }\n    \n    const float rho0 = 1.;\n    float rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n    float r = rho/rho0;\n    float p = max(r-1.,0.);\n    \n    /* pseudo-potential */\n    float psi = sign(r) * rho0 * clamp((\n    /* surface tension */ \n    1. - exp(-abs(r))\n    /* pressure, it makes the fluid more incompressible*/\n    - (1.5*p*sqrt(p))), //-p),\n    /* clamp */\n    -100.,1.);\n    \n    // save\n    ivec2 off = ivec2(int(fragCoord.x) - 2*idx.x,int(fragCoord.y) - 2*idx.y);\n    fragColor = save_color(off,vec4[4](\n    vec4(f0,f1,f2,1.),\n    vec4(f3,f4,f5,1.),\n    vec4(f6,f7,f8,1.),\n    vec4(rho,0,0,psi)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// draw wall\n\n#define IsInBox(box, idx) (idx.x > box.x && idx.x < box.y && idx.y > box.z && idx.y < box.w)\n\n#define Resolution() (texelFetch(iChannel2, ivec2(0,0), 0).zwx)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 idx = ivec2(fragCoord*0.5);\n    vec2 coord = fragCoord*0.5;\n    vec2 size = iResolution.xy*0.5;\n    vec3 resolution_old = Resolution();\n    vec4 data = texelFetch(iChannel2,idx*2,0);\n    \n    if(idx.x==0 && idx.y==0){\n        if(any(notEqual(resolution_old.xy,iResolution.xy))){\n            data = vec4(1., data.y, iResolution.xy);\n        }else{\n            data = vec4(0., data.y, iResolution.xy);\n        }\n    }\n    else if(resolution_old.z>0.5)\n    {    \n        //generate planet\n        vec2 center = size/2.;\n        vec2 dir = coord - center;\n        float ratio = size.y/100.;\n        float nScale = 4. * ratio;\n        float t = iDate.w;\n        float noise = 5. * ratio *(cos(coord.x/nScale + t) * sin(coord.y/nScale + t));\n        float r =  center.y/2.;\n        if(length(dir)+noise < r) \n            data = vec4(1.);\n    }\n\n    if(iMouse.z>0. && KEY_W == 0. && dist2Mouse < 8.) //The size of the eraser is bigger than the size of the brush\n    {\n        float clickData = Wall(iChannel2, ivec2(abs(iMouse.zw) / 2.));\n        if(clickData < 1.) // eraser\n            data.xy = vec2(0);\n        else if(dist2Mouse < 7.) // wall brush\n            data.xy = vec2(1);\n    }\n\n    // save\n    fragColor = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}