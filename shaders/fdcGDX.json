{
    "Shader": {
        "info": {
            "date": "1630697005",
            "description": " Ray-marching multiple cubes. Tiled to reduce cost. 4 cubes per tile.  set SYNCH_ROT to 0 for random rotations. Added some AO. Added an ENV map.\nThe tileRepeat can be set to anything ( i.e draw thousands of cubes) without increasing cost of the shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdcGDX",
            "likes": 14,
            "name": "RayCubesOrtho",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarching",
                "cube",
                "marching"
            ],
            "usePreview": 0,
            "username": "hjd3481",
            "viewed": 437
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 6.0\n#define MAX_STEPS 22\n\n#define TWOPI \t6.283185307179586476925286766559\n#define HALFPI \t1.5707963267948966192313216916398\n#define TORAD \t0.01745329251994329576923690768489\n\n//0 for a random rotation, 1 for a wave-like synchronised rotation\n#define SYNCH_ROT 1\n\n//1 for environment map\n#define ENV_MAP 1\n\n/////////////////////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/////////////////////////////////////////////////////////////////\n//https://iquilezles.org/articles/distfunctions\nfloat getDistanceBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/////////////////////////////////////////////////////////////////\n\nmat4 getRotationX(const float fRadians)\n{\n    mat4 m;\n     float fC = cos(fRadians);\n    float fS = sin(fRadians);\n    m[0] = vec4(1.0f,\t0.0f,\t0.0f, 0.0f);\n    m[1] = vec4(0.0f,\tfC,\t\tfS, 0.0f );\n    m[2] = vec4(0.0f,\t-fS,\tfC, 0.0f);\n    m[3] = vec4(0.0f,0.0f,0.0f,1.0f);\n    return m;\n}\n\n/////////////////////////////////////////////////////////////////\n\nmat4 getRotationY(const float fRadians)\n{       \n    mat4 m;\n    float fC = cos(fRadians);\n    float fS = sin(fRadians);\n    m[0] = vec4(fC,\t0.0f,\t-fS, 0.0f );\n    m[1] = vec4(0.0f,\t1.0f,\t0.0f, 0.0f );\n    m[2] = vec4(fS,\t0.0f,\tfC, 0.0f);\n    m[3] = vec4(0.0f,0.0f,0.0f,1.0f);\n    return m;\n}\n\n/////////////////////////////////////////////////////////////////\n\nmat4 getRotationZ(const float fRadians)\n{\nmat4 m;\n    float fC = cos(fRadians);\n    float fS = sin(fRadians);\n    m[0] = vec4(fC,\tfS,\t\t0.0f, 0.0f);\n    m[1] = vec4(-fS,\tfC,\t\t0.0f, 0.0f );\n    m[2] = vec4(0.0f,\t0.0f,\t1.0f, 0.0f);\n    m[3] = vec4(0.0f,0.0f,0.0f,1.0f);\n    return m;\n}\n/////////////////////////////////////////////////////////////////\nmat4 getBoxTransform( vec3 rot, vec3 loc )\n{\n    mat4 mx = getRotationX(rot.x);\n    mat4 my = getRotationY(rot.y);\n    mat4 mz = getRotationZ(rot.z);\n    \n    mat4 m = mx * my * mz;    \n    m[3] = vec4( loc, 1.0 );\n    \n    return m;\n}\n\n/////////////////////////////////////////////////////////////////\n\nfloat GetRotatedBoxDist(vec3 pos,int boxIndexX, int boxIndexY, vec2 tileIndex )\n{\n    const float roundingValue = 0.025;\n\n    vec3 boxIndex = vec3(boxIndexX,boxIndexY,0);      \n    vec3 boxRand = hash32( tileIndex+boxIndex.xy);\n#if !SYNCH_ROT  \n    //randomized rotations based on the global box-index\n    vec3 vecRot = vec3(iTime+1381.0) * boxRand * vec3(0.398121, 0.4011321, 0.39877874 ) + (boxRand.zyx * vec3(0.44654,0.6212,0.511112));\n#else\n    //rotate in unison plus some per-tile offset for some sweeping waves in the rotations\n    vec3 vecRot = vec3(0.235*iTime+6.0) + vec3((tileIndex + boxIndex.xy),0) * vec3(0.09105) + boxRand * 0.111;\n#endif\n    mat4 boxTransform = getBoxTransform( vecRot, vec3(0,0,0) );\n    vec3 boxOrigin = (pos - boxIndex*vec3(2.0))+vec3(1);\n    vec3 rotPos = vec3( vec4(boxOrigin,1) * boxTransform );            \n    vec3 boxScale = vec3( mix( 0.9, 1.33, sin((iTime+3.1)*boxRand.y*0.9867133)*0.5+0.5));\n    return getDistanceBox( rotPos, boxScale ) - roundingValue;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat GetD( vec3 pos, vec2 tileIndex )\n{\n   float d = MAX_DIST;\n  \n   //per box, get a rotation matrix for the box, transfom the position around the box and get the distance.\n   // add a small rounding value for a slight bevel and less noise.\n  \n   d = min( d, GetRotatedBoxDist(pos, 0,0,tileIndex) );\n   d = min( d, GetRotatedBoxDist(pos, 1,0,tileIndex) );\n   d = min( d, GetRotatedBoxDist(pos, 0,1,tileIndex) );\n   d = min( d, GetRotatedBoxDist(pos, 1,1,tileIndex) );\n   \n   return d;\n}\n\n/////////////////////////////////////////////////////////////////\n\nfloat DoRay( vec3 co, vec3 vd, vec2 tileIndex )\n{\n    vec3 p = co;\n    float dc = 0.0;\n        \n    for( int i=0; i < MAX_STEPS; i++)\n    {  \t\n\t\tfloat ds = GetD(p, tileIndex);\n        //move up ray\n        dc += ds;\n        p += vd * ds;\n        if( ds < 0.01 || dc >= MAX_DIST )\n        {         \n            break;\n        }        \n    }\n    \n    return min(dc,MAX_DIST);\n}\n\n/////////////////////////////////////////////////////////////////\n\nvec3 GetN( vec3 surf_pos, vec2 tileIndex )\n{\n    float ds = GetD( surf_pos, tileIndex );\n    float du = GetD( surf_pos - vec3(0.01,0.00,0.00), tileIndex);  \n    float dv = GetD( surf_pos - vec3(0.00,0.01,0.00), tileIndex);\n    float dw = GetD( surf_pos - vec3(0.00,0.00,0.01), tileIndex);\n    \n    vec3 n = ds - vec3(du,dv,dw);\n    return normalize(n);\n}\n\n/////////////////////////////////////////////////////////////////\n\nvec3 Light( vec3 surf_pos, vec3 light_pos, vec3 world_normal, vec3 lightCol )\n{\n    vec3 surf_to_light = light_pos - surf_pos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float I = max( 0.0, dot( world_normal , surf_to_light ));\n    \n    float Imag = max(1.0,1.0/(light_dist * light_dist));\n            \n    return lightCol * I * Imag;\n}\n\n/////////////////////////////////////////////////////////////////\n\nvec3 LightShad( vec3 surf_pos, vec3 light_pos, vec3 world_normal, vec3 lightCol, vec2 tileIndex )\n{\n    vec3 surf_to_light = light_pos - surf_pos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float I = max( 0.0, dot( world_normal , surf_to_light ));\n    \n    float Imag = max(1.0,1.0/(light_dist * light_dist));\n    \n    float shad_surf_dist = DoRay( surf_pos + (world_normal * 0.02), surf_to_light, tileIndex );    \n    if( shad_surf_dist < MAX_DIST && shad_surf_dist < light_dist )\n    {\n\t\tI = 0.03;\n    }\n        \n    return lightCol * I * Imag;\n}\n\n/////////////////////////////////////////////////////////////////\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Light settings\n    const vec3  ambientLight   = vec3(0.05,0.075,0.1) * 1.3;\n    const vec3  lightCol       = vec3(0.96,0.85,0.691);\n    const float lightIntensity = 0.61;\n    \n    const float specularPower  = 190.0;\n    const vec3  specularCol    = lightCol * 0.33;\n    \n    const float envMapBrightness = 0.61;\n    \n    //zoom settings\n    const float zoomMin = 4.0; // number of tiles vertically\n    const float zoomMax = 12.0; //number of tiles vertically\n    const float zoomSpeed = 0.1137;\n    \n    \n    //centre the UVs around the middle of the texture so that the zoom-pivot is in the middle, rather than the bottom-left\n    vec2 uv = (fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    vec2 startUV = uv;\n    \n    //zooms in and out\n    float tileRepeat = mix( zoomMax, zoomMin, cos(iTime*zoomSpeed)*0.5+0.5 );  //start off zoomed in at zero time\n \n    //Chop up unit-UVs to get Tile Index and new UV\n    vec2 tileIndex = floor(uv * tileRepeat) + vec2(10); //the +10 helps the hashfunction (hash(0) returns 0)\n    uv = fract(uv * tileRepeat)*2.0-1.0; //want uv-origin in the middle of the tile\n    \n    //offset light to compensate for tile-offsets ( extra offset because we shifted the tileIndex origin to avoid hash(0) )\n    vec3 lightPos = vec3( 20.0, 26.0, 9.0 ) - vec3(tileIndex*2.0,0);\n       \n    //Camera - orthographic to prevent perspective projecton - keeps tiles seamless. \n    // You could add a viewport offset projection to have seamless tiled projective camera but \n    // ortho is cheaper and suits this implementation.\n\tvec3 raydir = normalize( vec3(0,0,-1) ); //look straight down z\n    vec3 rayPos = vec3(uv,5.0);  //Spread rays out based on tile-pixel-position, move camera back by 5\n     \n    //Position\n    float d = DoRay( rayPos, raydir, tileIndex );\n    vec3 surfPos = rayPos + (raydir * d);   \n    vec3 worldNormal = (d < MAX_DIST) ? GetN(surfPos, tileIndex ) : vec3(0,0,1);\n    \n    vec3 col = vec3(0);\n         \n    //Light\n    col += LightShad( surfPos, lightPos, worldNormal,  lightCol * lightIntensity, tileIndex );\n    \n    //Ambient\n    col += ambientLight;\n    \n    //AO\n    //Thanks to https://www.shadertoy.com/user/ENDESGA for the idea to add some AO based on the depth\n    col *= smoothstep( 1.1, 0.76, vec3(d/MAX_DIST) ); //set to col = smoothstep... to preview.\n       \n#if ENV_MAP\n    vec3 env = texture( iChannel0, worldNormal.xyz + vec3(startUV * 0.315, 0.0), 0.0 ).rgb;\n    env *= envMapBrightness;\n    col += (env * env);   \n#endif //ENV_MAP\n\n    //specular\n    vec3 surf_to_light = lightPos - surfPos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float spec = 0.0;\n    vec3 refl = reflect( -surf_to_light, worldNormal );\n    spec = clamp(dot( refl, -raydir ), 0.0, 1.0);\n    col += vec3( pow( spec, specularPower )) * specularCol;\n\t\n    \n    \n  \n   //depth visualize\n   //col = smoothstep( 1.0, 0.0, vec3(d/MAX_DIST) );\n   \n   //normal visualize\n   //col = worldNormal;\n   \n   //tile vizualize\n   //col *= hash32(tileIndex)+0.5;     \n   \n\n                 \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}