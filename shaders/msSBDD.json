{
    "Shader": {
        "info": {
            "date": "1689719104",
            "description": "just fooling around",
            "flags": 0,
            "hasliked": 0,
            "id": "msSBDD",
            "likes": 19,
            "name": "implicit curves sketch",
            "published": 3,
            "tags": [
                "implicit"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "\nfloat circle(in vec2 p) {\n    p *= 1.2;\n    // distance^2 is fine, doesn't need to be actual distance.\n    float left = dot(p, p);\n    float right = 1.0;\n    return right - left;\n}\n\nfloat sine(in vec2 p) {\n    p *= 5.0;\n    float left  = sin(p.x + iTime * 1.5);\n    float right = p.y;\n    return right - left;\n}\n\nfloat lemniscate(in vec2 p) {\n\n    float left = p.x * p.x + p.y * p.y;\n    left = left * left;\n    float right = p.x * p.x - p.y * p.y;\n    return right - left;\n}\n\nfloat folium(in vec2 p) {\n    p *= 4.0;\n    float left = p.x * p.x * p.x + p.y * p.y * p.y;\n    float right = 6.0 * p.x * p.y;\n    return right - left;\n}\n\nfloat witchOfAgnesi(in vec2 p) {\n    p *= 8.0;\n    float left = (p.x * p.x + 2.0) * p.y;\n    float right = 10.0;\n    return right - left;\n}\n\nfloat blah(in vec2 p) {\n    p *= 20.0;\n    float left = p.x * cos(p.y) + p.y * cos(p.x);\n    float right = 0.0;\n    return right - left;\n}\n\n\n// gPlatl\nfloat parabel(in vec2 p) \n{ return p.x*p.x-p.y-0.8; }\n\n\n// gPlatl\nfloat Heart(in vec2 p) \n{ float x = p.x;\n  float y = p.y;\n  float a = x*x+y*y-0.5;\n  return a*a*a-x*x*y*y*y;\n}\n\n// gPlatl\nfloat MickeyMouse(in vec2 p) \n{ float x = p.x;\n  float y = p.y;\n  float a = x*x+y*y-0.5;\n  return a*a*a-x*x*y*y*y+0.01;\n}\n\n\n// Envy24\nfloat devil_curve(in vec2 p)\n{\n    p *= 2.;\n    float x = p.x, y = p.y, t0 = (1.+sin(iTime))*0.5;\n    return y * y * (y * y - 1.0) - x * x * (x * x - 1.65 + t0);\n}\n\n// Envy24\nfloat some_random_func(in vec2 p)\n{\n    p *= 4.;\n    float x = p.x, y = p.y;\n    return (x*x - x*y*x) -(y*y - x*y*x)/(y*y + y*x*x) + sin(iTime)*1.0;\n}\n\n// Envy24\nfloat gamma_correction_heart(in vec2 p)\n{\n    p *= 2.;\n    float x = p.x, y = p.y;\n    //               gamma correction of x*x)\n    float term = y - pow(x * x, 1.0 / 2.2);\n    return x * x + term * term - 1.0;\n}\n\n// Envy24\nfloat unknown(in vec2 p) {\n       p = (p - vec2(0.59)) * 8.0;\n    float sx = sin(2.*p.x), sy = sin(p.y);    \n    return sx*sx*sx + 4.*sy*sy*sy - 3.*sx*sy;\n}\n\nconst int numCurves = 12;\nfloat curve(in vec2 p, int index) {\n    switch (index) {\n        case 0:\n            return circle(p);\n        case 1:\n            return lemniscate(p);\n        case 2:\n            return folium(p);\n        case 3:\n            return witchOfAgnesi(p);\n        case 4:\n            return sine(p);\n        case 5:\n            return blah(p);\n        case 6:\n            return parabel(p);\n        case 7:\n            return Heart(p);\n        case 8:\n            return gamma_correction_heart(p);\n        case 9:\n            return MickeyMouse(p);\n        case 10:\n            return devil_curve(p);\n        case 11:\n            return some_random_func(p);\n            \n        default:\n            return 0.0;\n    }\n}\n\nfloat curve(in vec2 p) {\n\n    float t = iTime * 0.2;\n\n    int i0 = int(floor(t)) % numCurves;\n    int i1 = (i0 + 1)      % numCurves;\n    \n    float c0 = curve(p, i0);    \n    float c1 = curve(p, i1);\n    \n    float c = mix(c1, c0, smoothstep(-0.4, 0.4, cos(fract(t) * 3.1415)));\n    \n    return c;\n}\n\n// thanks Envy24!\nfloat fwidth_L2(in float d) {\n    return length(vec2(dFdx(d), dFdy(d)));\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 xy = (XY - iResolution.xy / 2.0)/min(iResolution.x, iResolution.y) * 2.0;\n\n    float d;\n    \n    // grey background\n    float c = 0.5;\n    \n    // axes\n    ivec2 dxy = ivec2(XY) - ivec2(iResolution.xy / 2.0);\n    if (/*dxy.x * */ dxy.y == 0) {\n        c *= 1.0  + -0.8* smoothstep(0.5, 0.6, cos(length(xy * 100.0)));\n    }\n    \n    // shadow\n    d = curve(xy - 0.015 * vec2(1.0, -1.0));\n    c *= mix(1.0, 0.8, smoothstep(8.0, 0.0, abs(d) / fwidth_L2(d) - 4.0));\n    \n    // main curve\n    d = curve(xy - 0.00 * vec2(1.0, -1.0));\n    c = mix(c, 1.0, smoothstep(2.0, 0.0, abs(d) / fwidth_L2(d) - 1.0));\n            \n    RGBA.rgb = vec3(c);\n    RGBA.a   = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}