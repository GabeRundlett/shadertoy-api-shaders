{
    "Shader": {
        "info": {
            "date": "1662418535",
            "description": "...",
            "flags": 0,
            "hasliked": 0,
            "id": "stGyWt",
            "likes": 5,
            "name": "My third RayMarcher",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "ray",
                "raymarch",
                "sun",
                "shadow",
                "light",
                "sphere",
                "marching",
                "march",
                "buffer"
            ],
            "usePreview": 0,
            "username": "SONENEIS",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "#define pi 3.1415926\n#define tau pi * 2.0\n\n#define AA 4\n\n/*settings*/\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.00001\n#define STEPS 5000\n/*end*/\n\n#define pow(a,b) pow(abs(a),b)\n\n//random\nfloat hash(float v){return fract(sin(v*dot(vec2(737.873,777.873),vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec3 uv){return fract(sin(dot(uv,vec3(173.873,515.526,726.873)))*82723.782);}\n\n//noise 1d\nfloat noise(float a){\n\tfloat f = fract(a);\n\tfloat h = f*f*(3.0-2.0*f);\n\treturn mix(hash(a),hash(a + 1.0),h);\n}\n\n//noise 2d\nfloat noise(vec2 uv){\n\tvec2 e = vec2(0.0,1.0);\n\tvec2 p = floor(uv);\n\tvec2 f = smoothstep(0.0,1.0,fract(uv));\n\treturn mix(\n\t\tmix(hash(p + e.xx),hash(p + e.yx),f.x),\n\t\tmix(hash(p + e.xy),hash(p + e.yy),f.x),\n\t\tf.y\n\t);\n}\n\n//noise 3d\nfloat noise(vec3 uv3d){\n\tvec2 e = vec2(0.0,1.0);\n\tvec3 s = vec3(110.0,241.0,171.0);\n\tvec3 i = floor(uv3d);\n\tvec3 f = fract(uv3d);\n\tfloat n = dot(i,s);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\tfloat x1 = mix(hash(n + dot(s,e.xxx)),hash(n + dot(s,e.yxx)),u.x);\n\tfloat x2 = mix(hash(n + dot(s,e.xyx)),hash(n + dot(s,e.yyx)),u.x);\n  float y1 = mix(hash(n + dot(s,e.xxy)),hash(n + dot(s,e.yxy)),u.x);\n  float y2 = mix(hash(n + dot(s,e.xyy)),hash(n + dot(s,e.yyy)),u.x);\n\treturn mix(mix(x1,x2,u.y),mix(y1,y2,u.y),u.z);\n}\n\n//clamp zero one\n#define czo(a) clamp(a,0.0,1.0)\n\n//integer mix\n#define imix(a,b,k) mix(float(a),float(b),k)\n\n//vector min\nfloat vmin(vec2 a){return min(a.x,a.y);}\nfloat vmin(vec3 a){return min(min(a.x,a.y),a.z);}\nfloat vmin(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n\n//vector max\nfloat vmax(vec2 a){return max(a.x,a.y);}\nfloat vmax(vec3 a){return max(max(a.x,a.y),a.z);}\nfloat vmax(vec4 a){return max(max(a.x,a.y),max(a.z,a.w));}\n\n//square\nfloat sq(float a){return pow(a,2.0);}\nvec2 sq(vec2 a){return pow(a,vec2(2.0));}\nvec3 sq(vec3 a){return pow(a,vec3(2.0));}\nvec4 sq(vec4 a){return pow(a,vec4(2.0));}\n\n//length square\n#define lsq(a) dot(a,a)\n\n//smooth min\nfloat smin(float a,float b,float k){\n\tfloat h = czo(0.5 + 0.5*(b-a)/k);\n\treturn mix(b,a,h) - k*h*(1.0-h);\n}\n\n//smooth max\nfloat smax(float a,float b,float k){\n\treturn -smin(-a,-b,k);\n}\n\nstruct Phong{\n\tfloat amb_iten;\n\tfloat diff_iten;\n\tfloat spe_iten;\n\tfloat spe_alpha;\n\tfloat back_iten;\n\tfloat diff_absl; //absorbs light\n};\n\nstruct Obj{\n\tfloat f;\n\tvec3 col;\n\tvec3 pos;\n\tint id;\n\tPhong phong;\n};\n\n//primitive 3d sdfs\nObj fSphere(int id,vec3 p,float rad,vec3 col,Phong phong){\n\tfloat sph = length(p) - rad;\n\treturn Obj(sph,col,p,id,phong);\n}\nObj fEllipsoid(int id,vec3 p,vec3 rad,vec3 col,Phong phong){\n  float p1 = length(p/rad);\n  float p2 = length(p/sq(rad));\n  float elli = p1*(p1-1.0)/p2;\n\treturn Obj(elli,col,p,id,phong);\n}\nObj fCube(int id,vec3 p,float size,vec3 col,Phong phong){\n\tp = abs(p) - size;\n\tfloat cube = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Obj(cube,col,p,id,phong);\n}\nObj fBox(int id,vec3 p,vec3 size,vec3 col,Phong phong){\n\tp = abs(p) - size;\n\tfloat box = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Obj(box,col,p,id,phong);\n}\nObj fBoxInf1(int id,vec3 p,vec2 size,vec3 col,Phong phong){\n\tvec2 p2 = abs(p.xy) - size;\n\tfloat box = length(max(p2,0.0)) + min(vmax(p2),0.0);\n\treturn Obj(box,col,p,id,phong);\n}\nObj fPlane(int id,vec3 p,vec3 n,float d,vec3 col,Phong phong){\n\tfloat plane = dot(p,n) - (-d);\n\treturn Obj(plane,col,p,id,phong);\n}\n\n//transform matrices\nmat3 mRotateX(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(1,0,0),\n\t\tvec3(0,c,-s),\n\t\tvec3(0,s,c)\n\t);\n}\nmat3 mRotateY(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,0,s),\n\t\tvec3(0,1,0),\n\t\tvec3(-s,0,c)\n\t);\n}\nmat3 mRotateZ(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,-s,0),\n\t\tvec3(s,c,0),\n\t\tvec3(0,0,1)\n\t);\n}\nmat3 mRotateXYZ(float x,float y,float z){\n\treturn mRotateX(x) * mRotateY(y) * mRotateZ(z);\n}\n\n//sdf operations\n//union\nObj fOpUn(Obj a,Obj b){\n  if(a.f < b.f) return a; else return b;\n}\nObj fOpUnS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/k);\n\tfloat f = smin(a.f,b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpUnC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/r);\n\tfloat f = min(min(a.f,b.f),(a.f - r + b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//intersection\nObj fOpIn(Obj a,Obj b){\n  if(a.f > b.f) return a; else return b;\n}\nObj fOpInS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5-0.5*(b.f-a.f)/k);\n\tfloat f = smax(a.f,b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpInC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5-0.5*(b.f-a.f)/r);\n\tfloat f = max(max(a.f,b.f),(a.f + r + b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//difference\nObj fOpDi(Obj a,Obj b){\n\ta.f = -a.f;\n\treturn fOpIn(a,b);\n}\nObj fOpDiS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5-0.5*(b.f+a.f)/k);\n\tfloat f = smax(-a.f,b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpDiC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5-0.5*(b.f+a.f)/r);\n\tfloat f = max(max(-a.f,b.f),(-a.f + r + b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//difference in reverse\nObj fOpRDi(Obj a,Obj b){\n\tb.f = -b.f;\n\treturn fOpIn(a,b);\n}\nObj fOpRDiS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5+0.5*(b.f+a.f)/k);\n\tfloat f = smax(a.f,-b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpRDiC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5+0.5*(b.f+a.f)/r);\n\tfloat f = max(max(a.f,-b.f),(a.f + r + -b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//others\nObj fOpPipe(Obj a,Obj b,float r,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/r);\n\tfloat f = length(vec2(a.f,b.f)) - r;\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpEngrave(Obj a,Obj b,float r,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/r);\n\tfloat f = max(a.f,(a.f + r - abs(b.f))*sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpGroove(Obj a,Obj b,float ra,float rb,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/ra);\n\tfloat f = max(a.f,min(a.f + ra,rb - abs(b.f)));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpTongue(Obj a,Obj b,float ra,float rb,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/ra);\n\tfloat f = min(a.f,max(a.f - ra,abs(b.f) - rb));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n\n//texture mappings\nvec3 tpmap(sampler2D sam,vec3 p3,vec3 n){ //triplanar\n  n = abs(n);\n  return (\n  \ttexture(sam,p3.xy) * n.z +\n  \ttexture(sam,p3.xz) * n.y +\n  \ttexture(sam,p3.yz) * n.x\n  ).rgb;\n}\nvec2 cmap(vec3 p3,bool sd){ //cube mapping\n  vec3 n = abs(p3);\n  vec3 v =\n  \t(n.x>n.y && n.x>n.z) ? p3.xyz :\n    (n.y>n.x && n.y>n.z) ? p3.yzx : p3.zxy;\n  vec2 p2 = v.yz/v.x;\n  if(sd) p2 *= 1.25 - 0.25*p2*p2;\n  return 0.5+0.5*p2;\n}\nvec2 cmap(vec3 p3){return cmap(p3,false);}\nvec2 smap(vec3 p3){ //sphere mapping\n  p3 = normalize(p3);\n  vec2 p2;\n  p2.x = 0.5 + atan(p3.z,p3.x) / tau;\n  p2.y = 0.5 - asin(p3.y) / pi;\n  return p2;\n}\nfloat bumpmap(sampler2D sam,vec3 pos,vec3 n,float dist,float factor,float scale){\n\tfloat bump = 0.0;\n\tif(dist < 0.1){\n\t  vec3 normal = normalize(n);\n\t  bump += factor * tpmap(sam,pos*scale,normal).r;\n\t}\n\treturn bump;\n}\n\nObj scene(vec3 pos){\n\tObj d;\n  \n  Obj ball = fSphere(\n  \t1,pos,0.625,\n  \tvec3(1.0,0.0,0.0),\n  \tPhong(1.0,1.0,1.0,10.0,0.1,0.0)\n  );\n  //ball.f -= bumpmap(iChannel0,pos,pos+0.25,ball.f,0.25,0.625);\n\n  Obj elli = fEllipsoid(\n  \t0,pos,vec3(0.5,0.25,0.1),\n  \tvec3(0.0,1.0,0.0),\n  \tPhong(1.0,1.0,0.5,10.0,0.1,0.0)\n  );\n\n  Obj cube = fCube(\n  \t0,pos,0.5,\n  \tvec3(0.0,0.0,1.0),\n  \tPhong(1.0,1.0,0.1,10.0,0.1,0.0)\n  );\n  cube.f -= 0.01;\n\n  Obj box = fBox(\n  \t0,pos,vec3(0.5,0.25,0.1),\n  \tvec3(1.0,1.0,0.0),\n  \tPhong(1.0,1.0,0.5,10.0,0.1,0.0)\n  );\n  box.f -= 0.075;\n\n  Obj wall = fBoxInf1(\n  \t0,pos.xyz,vec2(0.25,0.5),\n  \tvec3(1.0,1.0,1.0),\n  \tPhong(1.0,1.0,0.5,10.0,0.1,0.0)\n  );\n  wall.f -= 0.05;\n\n  Obj ground = fPlane(\n  \t2,pos,vec3(0,1,0),0.5,\n    vec3(0.5+0.5*mod(floor(pos.x*5.0)+floor(pos.z*5.0),2.0)),\n  \tPhong(1.0,1.0,0.0,1.0,0.1,0.0)\n  );\n\n  //d = fOpUn(fOpDi(ball,cube),ground);\n  //d = fOpDi(ball,cube);\n  d = fOpUn(ball,ground);\n  //d = fOpUn(cube,ground);\n  //d = elli;\n  //d = ball;\n  //d = ground;\n\n  ////////////////////////////////////////////////////////////////////\n\n  //normal\n  //d = fOpUn(ball,ground);\n  //d = fOpIn(ball,ground);\n  //d = fOpDi(ball,ground);\n  //d = fOpRDi(ball,ground);\n\n  //smooth\n  //d = fOpUnS(ball,ground,0.25,0);\n  //d = fOpInS(ball,ground,0.1,0);\n  //d = fOpDiS(ball,ground,0.5,0);\n  //d = fOpRDiS(ball,ground,0.1,0);\n\n  //chamfer\n  //d = fOpUnC(ball,ground,0.25,0);\n  //d = fOpInC(ball,ground,0.12,0);\n  //d = fOpDiC(ball,ground,0.5,0);\n  //d = fOpRDiC(ball,ground,0.1,0);\n\n  //d = fOpPipe(ball,ground,0.1,0);\n  //d = fOpEngrave(ball,ground,0.1,0);\n  //d = fOpGroove(ball,ground,0.1,0.1,0);\n  //d = fOpTongue(ball,ground,0.1,0.1,0);\n\n\treturn d;\n}\n\nObj raymarch(vec3 ro,vec3 rd){\n\tfloat dist = 0.0;\n\tObj hit;\n\t\n\tfor(int i=0;i<STEPS;i++){\n\t\tvec3 uv3d = ro + dist*rd;\n\t\t\n    Obj redl = fSphere(\n    \t3,uv3d - vec3(2.5,0.1,1.0),0.25,\n    \tvec3(1.0,0.0,0.0),\n    \tPhong(1.0,1.0,1.0,10.0,0.1,0.0)\n    );\n  \tObj lights;\n  \tlights = redl;\n\t\thit = fOpUn(scene(uv3d),lights);\n    \n    dist += hit.f;\n\t\tif(abs(hit.f) < EPSILON || dist > MAX_DIST) break;\n\t}\n\n  hit.f = dist;\n\n\treturn hit;\n}\n\nfloat softShadow(vec3 ro,vec3 rd){\n\tfloat start = MIN_DIST, end = MAX_DIST;\n\tfloat k = 16.0;\n\tfloat shadow = 1.0;\n\n\tfor(float d=start;d<end;){\n\t\tfloat hit = scene(ro + d*rd).f;\n\n\t\tif(hit < 0.001) return 0.0;\n\t\tshadow = min(shadow,k*hit/d);\n\n        //d += hit / k; //low\n\t\td += hit; //fast\n\t}\n\n\treturn shadow;\n}\n\nfloat getAmbOcc(vec3 ro,vec3 rd){\n  float occ = 0.0;\n  float w = 1.0;\n\n  for(float i=0.0;i<8.0;i++){\n  \tfloat len = 0.1+0.01*sq(i);\n  \tfloat dist = scene(ro + len*rd).f;\n  \tocc += (len - dist) * w;\n  \tw *= 0.775;\n  }\n\n  return 1.0 - czo(0.75 * occ);\n}\n\nvec3 getNormal(vec3 uv3d){\n\tvec2 e = vec2(1.0,-1.0) * EPSILON;\n\treturn normalize(vec3(\n\t\te.yyx * scene(uv3d + e.yyx).f +\n\t\te.xyy * scene(uv3d + e.xyy).f +\n\t\te.yxy * scene(uv3d + e.yxy).f +\n\t\te.xxx * scene(uv3d + e.xxx).f\n\t));\n}\n\nstruct Light{\n\tvec3 pos;\n\tvec3 dir;\n\tvec3 col;\n\tvec3 shader;\n};\nLight light(vec3 uv3d,vec3 rd,vec3 normal,Obj obj,vec3 amb,float iten,vec3 pos,vec3 col){\n\tvec3 dir = normalize(pos - uv3d);\n  \n  switch(obj.id){\n  \tcase 1:\n\t    float softness = 100.0; //the lower this value, the smoother the texture.\n\t    vec3 n = pow(abs(normal),vec3(softness));\n\t    n /= n.x + n.y + n.z;\n\n\t    obj.col = tpmap(iChannel0,uv3d,normal).rgb;\n  \t  break;\n\t  case 2:\n\t    obj.col = tpmap(iChannel1,uv3d,normal).rgb;\n\t    break;\n  }\n  \n\t//shader\n\tvec3 shader = vec3(0.0);\n\t\n\tif(obj.id == 3){\n\t  shader += obj.col;\n\t}else{\n    vec3 L = dir;\n    vec3 N = normal;\n    vec3 R = reflect(-L,N);\n    vec3 V = -rd;\n  \n    //ambient\n    vec3 amb_col = amb*0.05 + obj.col*0.05;\n    float amb_iten = obj.phong.amb_iten;\n    vec3 ambient = amb_col * amb_iten;\n\n\t  //diffuse\n  \tvec3 diff_col = obj.col * (col * iten*(1.0-obj.phong.diff_absl));\n  \tfloat diff_iten = obj.phong.diff_iten;\n  \tfloat diff_val = czo(dot(N,L));\n  \tvec3 diffuse = diff_col * diff_val * diff_iten;\n\n    //specular\n    vec3 spe_col = col;\n    float spe_iten = obj.phong.spe_iten;\n    float spe_alpha = obj.phong.spe_alpha;\n    float spe_val = czo(dot(R,V));\n    vec3 specular = spe_col * pow(max(0.0,spe_val),spe_alpha) * spe_iten;\n\n    //back\n    vec3 b_col = 0.5 * obj.col;\n    float b_iten = obj.phong.back_iten;\n    float b_val = czo(dot(N,-L));\n    vec3 back = b_col * b_val * b_iten;\n\n    //fresnel\n    vec3 him_col = obj.col*0.1;\n    float him_val = czo(pow(max(0.0,1.0 + dot(rd,N)),2.0));\n    vec3 him = him_col * him_val;\n\n    //shadow\n    float shadow = 1.0;\n    shadow = softShadow(uv3d+N*0.02,normalize(pos));\n    \n  \t//ambient occlusion\n    float occ = getAmbOcc(uv3d,N);\n    \n\tshader += occ*(ambient+him + ((diffuse*shadow)+back)) + specular;\n    //shader += ambient + diffuse + specular;\n  }\n\treturn Light(pos,dir,col,shader);\n}\n\nmat3 lookAt(vec3 ro,vec3 la){\n\tvec3 cz = normalize(ro - la);\n\tvec3 cx = normalize(cross(vec3(0,1,0),cz));\n\tvec3 cy = normalize(cross(cz,cx));\n\n\treturn mat3(cx,cy,cz);\n}\n\nvec3 render(vec3 col,vec2 uv){\n  vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n  vec3 bg = vec3(0.1,0.3,1.0);\n  vec3 fog = vec3(0.7,0.825,1.0);\n\n  //camera\n  float fov = 1.5;\n  vec3 la = vec3(0.0,0.0,0.0);\n  vec3 ro = vec3(0.0,0.0,2.5);\n  ro *= mRotateX(mouse.y - 0.5);\n  ro *= mRotateY(-mouse.x * tau * 2.0 + 1.0);\n  vec3 rd = lookAt(ro,la) * normalize(vec3(uv,-fov));\n\n  Obj d = raymarch(ro,rd);\n  {\n    vec3 uv3d = ro + d.f*rd;\n    vec3 normal = getNormal(uv3d);\n\n    bool sun_ = false;\n    Light sun = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(10.0,35.0,-50.0),\n    \tvec3(1.0,1.0,0.7)\n    );\n\n    Light r = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(2.5,0.1,1.0),\n    \tvec3(1.0,0.0,0.0)\n    );\n    Light g = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(-1.0,0.1,1.5),\n    \tvec3(0.0,1.0,0.0)\n    );\n    Light b = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(-1.0,0.1,-1.5),\n    \tvec3(0.0,0.0,1.0)\n    );\n   \n   if(uv.x <= 0.0) sun_ = true;\n   \n   if(d.f < MAX_DIST){\n      //shader\n      col += r.shader;\n      //col += g.shader;\n      //col += b.shader;\n      //col += r.shader + g.shader + b.shader;\n\n      if(sun_) col += sun.shader;\n\n      //gamma correction\n      col = pow(col,vec3(1.0/2.2));\n\n      //fog\n      if(!sun_) fog = vec3(-0.0001);\n      col = mix(col,fog,1.0-exp(-0.0001*pow(max(0.0,d.f),3.0)));\n    }else{\n    \t//sky\n  \t  if(sun_) col += mix(bg,fog,1.0-rd.y);\n      //sun\n      if(rd.x > rd.z && sun_){\n        col += sun.col * pow(max(0.0,dot(rd,normalize(sun.pos))),50.0) * 0.2;\n        col += sun.col * pow(max(0.0,dot(rd,normalize(sun.pos))),1000.0);\n      }\n    }\n    if(rd.x > rd.z && sun_)\n      col += sun.col * pow(max(0.0,dot(rd,normalize(sun.pos))),10.0) * 0.25;\n  }\n\n  //buffers ;-;\n  col += uv.y * 0.25;\n  col += vec3(0.075,0.05,0.1);\n  col = pow(col,vec3(1.25));\n\n  return col;\n}\n\nvec2 getUV(vec2 c,vec2 offset){\n  return (2.0 * (c.xy + offset) - iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec3 col = vec3(0.0);\n\n  if(AA == 1){\n    col += render(col,getUV(fragCoord,vec2(0.0)));\n  }else if(AA == 2){\n    float os1 = float(int(fragCoord.x + fragCoord.y) & 1);\n    float os2 = 1.0 - os1;\n    col += (\n    \trender(col,getUV(fragCoord,vec2(0.33 * os1,0.0))) +\n    \trender(col,getUV(fragCoord,vec2(0.33 * os2,0.66)))\n    ) / 2.0;\n  }else if(AA == 3){\n    float os1 = float(int(fragCoord.x + fragCoord.y) & 1);\n    float os2 = 1.0 - os1;\n    col += (\n    \trender(col,getUV(fragCoord,vec2(0.66 * os2,0.0))) +\n    \trender(col,getUV(fragCoord,vec2(0.66 * os1,0.66))) +\n    \trender(col,getUV(fragCoord,vec2(0.33,0.33)))\n    ) / 3.0;\n  }else if(AA == 4){\n    vec4 e = vec4(0.125,-0.125,0.375,-0.375);\n    col += (\n    \trender(col,getUV(fragCoord,e.xz)) +\n    \trender(col,getUV(fragCoord,e.yw)) +\n    \trender(col,getUV(fragCoord,e.wx)) +\n    \trender(col,getUV(fragCoord,e.zy))\n    ) / 4.0;\n  }\n\n  fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}