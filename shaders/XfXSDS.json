{
    "Shader": {
        "info": {
            "date": "1705673170",
            "description": "Revisiting Apollonian fractals and Raymarching loops.\n\nIf you can / Full screen is very noice!",
            "flags": 32,
            "hasliked": 0,
            "id": "XfXSDS",
            "likes": 28,
            "name": "2024 Re-Fractal ",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 348
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    01/19/24 @byt3_m3chanic \n\n    Re-Fractal\n    Apollonian fractal, retro 90's, early cgi, trippy, experiment.\n \n    My math is crud, I did whatever it took to get 1e-4 close to \n    the sdf. Trashed the distance to several places right of the \n    decimal point, just so I could just get a glimpse of what \n    happens in the ray marcher as math breaksdown.\n    \n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n//@iq box and round box sdf\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat rbox( in vec2 p, in vec2 b, in vec4 r ) {\n    r.xy = (p.x>0.)?r.xy : r.zw;\n    r.x  = (p.y>0.)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.)+length(max(q,0.))-r.x;\n}\n\n//alpha conts\nconst vec4 bz = vec4(.075,.055,.035,.0);\nconst vec4 bo = vec4(.175,.15,.075,.025);\nconst vec2 oa = vec2(.15,.1);\n\n//letters functions\nfloat getA(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n    rbox(p,vec2(.15,.175),bz.xwxw),\n    -rbox(p+vec2(.0,.05),vec2(.1,.175),bz.zwzw)\n    );\n    float bb = box(p,vec2(.15,.025));\n    return min(bt,bb);\n}\nfloat getC(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.wwxx),\n        -rbox(p-vec2(.05,0),vec2(.15,.125),bz.wwzz)\n    );\n    return bt;\n}\nfloat getE(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,oa,bz.wwxx),\n        -rbox(p-of-vec2(.05,0),vec2(.15,.05),bz.wwzz)\n    );\n    float bb = max(\n        rbox(p+of,oa,bz.wwxx),\n        -rbox(p+of-vec2(.05,0),vec2(.15,.05),bz.wwzz)\n    );\n    return min(bt,bb);\n}\nfloat getF(vec2 p) {\n    float bt = min(\n        box(vec2(p.x+.125,p.y),vec2(.025,.175)),\n        box(vec2(p.x,abs(p.y-.075)-.075),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getI(vec2 p) {\n    float bt = min(\n        box(p,vec2(.025,.175)),\n        box(vec2(p.x,abs(p.y)-.15),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getL(vec2 p) {\n    float bt = min(\n        box(p+vec2(.125,0),vec2(.025,.175)),\n        box(p+vec2(0,.15),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getN(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.xwxw),\n        -rbox(p+vec2(.0,.045),vec2(.1,.175),bz.zwzw)\n    );\n    return bt;\n}\nfloat getO(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.xxxx),\n        -rbox(p,vec2(.1,.125),bz.zzzz)\n    );\n    return bt;\n}\nfloat getP(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.xxww),\n        -rbox(p-vec2(.0,.075),vec2(.1,.05),bz.zzww)\n    );\n    float bb = box(p+vec2(.125,0),vec2(.025,.175));\n    return min(bt,bb);\n}\nfloat getR(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.xxww),\n        -rbox(p-vec2(.0,.075),vec2(.1,.05),bz.zzww)\n    );\n    float bb = max(\n        rbox(p+vec2(.0,.075),oa,bz.xwww),\n        -rbox(p+vec2(.0,.12),vec2(.1,.095),bz.zwww)\n    );\n    return min(bt,bb);\n}\nfloat getS(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.wwxx),\n        -rbox(p-vec2(.075,.075),vec2(.175,.05),bz.wwzz)\n    );\n    bt = max(bt,-box(p-vec2(.085,.045),vec2(.08,.08)));\n    float bb = max(\n        rbox(p+vec2(.0,.075),oa,bz.xxww),\n        -rbox(p+vec2(.075,.075),vec2(.175,.05),bz.zzww)\n    );\n    bb = max(bb,-box(p+vec2(.085,.045),vec2(.08,.08)));\n    return min(bt,bb);\n}\n\nfloat getT(vec2 p) {\n    vec2 of = vec2(0,.075);\n    return min(box(p-of-vec2(0,.075),vec2(.15,.025)),box(p,vec2(.025,.175)));\n}\n\nvoid shade(float d, inout vec3 C, vec3 clr, float px) {\n    C = mix(C,C*.4,smoothstep(.02+px,-px,d));\n    C = mix(C,clr,smoothstep(px,-px,d));\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (F.xy - R.xy*.5)/R.y;\n    vec2 xv = uv;\n    vec3 C = texture(iChannel0,(F.xy/R.xy)).rgb;\n\n    float tmod = mod(T*.65,18.);\n    \n    float t1 = lsp(02.,05.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(11.,15.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float ga1 = (t1-t2);\n    \n    uv*=4.5;\n\n    float px = fwidth(xv.x);\n    float kern = .375;\n    vec3 clr = .55 + .55*sin((T*.5+uv.x)*.74+ vec3(1.75,1.,.5));\n    uv-=vec2(-3.35,-1.75+(ga1*-1.75));\n    float d = 0.;\n    \n    d = getA(uv);\n    uv-=vec2(kern,0);\n    d = min(getP(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getO(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getL(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getL(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getO(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getN(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getI(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getA(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getN(uv),d);\n    uv-=vec2(kern*2.,0);\n\n    d = min(getF(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getR(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getA(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getC(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getT(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getA(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getL(uv),d);\n    uv-=vec2(kern,0);\n    d = min(getS(uv),d);\n    shade(d,C,clr,px);\n   \n    float hz = hash21(xv);\n    if(hz>.35) C = mix(C,C+.05,hz);\n    O = vec4(pow(C, vec3(.4545)),1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    01/19/24 @byt3_m3chanic \n\n    Re-Fractal\n    Apollonian fractal, retro 90's, early cgi, trippy, experiment.\n    \n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 10.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@gaz for this cool shape\nfloat gaz( vec3 p, float s) {\n    float e = abs(p.x+p.y)+abs(p.y+p.z)+abs(p.z+p.x)+abs(p.x-p.y)+abs(p.y-p.z)+abs(p.z-p.x)-s;\n    return e/3.5;\n}\n\nvec2 dom (vec2 p) {\n    float size = .5, hlf = size/2.; return mod(p+hlf,size)-hlf;\n}\n\nfloat mid; vec2 suv;\n\nvec3 apollo (vec3 p) {\n    float scale = .45;\n    float ph = suv.x<mid?2.55+1.*sin(T*.1):2.725;\n\n    for( int i=0; i<4;i++ ) {\n        p = -2.+4.*fract(.5*p+.5);\n        float r2 = dot(p,p);  \n        float k = ph/r2;\n        p *= k;\n        scale *= k;\n    }\n\n    float tubes = length(dom(p.xz))-.125;\n    tubes =   min(length(dom(p.xy))-.045,tubes);\n    tubes =   min(length(dom(p.zy))-.025,tubes);\n    float fx = abs(p.y);\n    p.xy=dom(p.xy);\n    float ff = gaz(p,2.5);\n\n    float d = suv.x<mid?max(ff,tubes)/scale:max(fx,tubes)/scale;\n\n    return vec3(d*.0075,p.y,p.z);\n}\n\nvec3 map (in vec3 p) {\n    p+=vec3(0.,.845,0.);\n    vec3 d = apollo(p);\n    return d;\n}\n\nvec3 march( in vec3 ro, in vec3 rd, in int steps ) {\n    float t = 0.01;\n    vec2  data = vec2(0.);\n    for( int i=0; i<steps; i++ ) {\n        float surface = .00025*t;\n        vec3  r = map(ro + rd * t);\n        float h = i<5? r.x*.5:r.x;\n        data = r.yz;\n        if(abs(h)<surface || t>MAX_DIST) break;\n        t += h;\n    }\n    return vec3( t, data );\n}\n\nfloat getao(vec3 p, vec3 n){ //@iq & @shane\n    float r = 0., w = 1., d;\n    for (float i=.5; i<3.+1.15; i++){\n        d = i/5.;\n        r += w*(d-map(p + n*d).x);\n        w *= .5;\n    }\n    return 1.-clamp(r,.0,1.);\n}\n\nfloat getdiff(vec3 p, vec3 lpos, vec3 n) {\n    vec3 l = normalize(lpos);\n    return clamp(dot(n,l),.05 , 1.);\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n\nvec4 FC = vec4(0.);\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout float d) {\n    \n    vec3 C = vec3(0), p = ro;\n    float m = 0., o = 0.;\n\n    vec3 ray = march(ro,rd,255);\n    d = ray.x;\n    m = ray.y;\n    o = ray.z;\n        \n    p = ro + rd * d;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n\n        vec3 lpos1 = vec3( 1.25,2.5,.05);\n        vec3 lpos2 = vec3(-.55,-2.75,-.75);\n        vec3 diff = vec3(.95)*getdiff(p, lpos1, n) + vec3(.65)*getdiff(p, lpos2, n);\n\n        float ao = getao(p,n);\n        if(suv.x<mid) { m=(m*2.5)+25.; } else {m *=5.;}\n        m = floor((.5*m+.5)*6.5);\n        vec3 h = .55 + .55*sin((T*.05+m)*5.35+vec3(2.,1.,.25));\n\n        C = h*diff*ao;\n    }\n\n    return C;\n}\n\nvec3 camera(in vec3 ro, in vec3 lp, in vec2 uv) {\n    vec3 cf = normalize(lp-ro);\n    vec3 cp = vec3(0,1,0);\n    vec3 cr = normalize(cross(cp, cf));\n    vec3 cu = normalize(cross(cf, cr));\n    vec3 c = ro + cf * .85;\n    vec3 i = c + uv.x * cr + uv.y * cu;\n    return i-ro; \n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    float tmod = mod(T*.35,18.);\n    float t1 = lsp(02.,05.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    float t2 = lsp(11.,15.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    float ga1 = (t1-t2)*2.5-1.25;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    suv=uv;\n\n    mid=ga1+.025*sin(uv.y*45.+T*4.5);\n\n    float fx = .0015+.0015*sin(uv.x*1.123+T*.55);\n    float fy = .0015+.0015*cos(uv.y*2.223+T*.51);    \n\n    vec2 nv = ((F.xy/R.xy)*1.002)-vec2(fy,fx);\n    float mf = .00003 + .00002 * sin(T*.35);\n\n    FC = vec4(.5+.45*sin((suv.x<mid?55.:0.)+T*.1+vec3(2.5,1.,.5)),0.);\n    FC.rgb = mix(FC.rgb,(texture(iChannel0,nv).rgb*exp2(-mf*T)),.95);\n    vec3 C = vec3(0);\n\n    vec3 ro = vec3(0,0,.15), lp = vec3(0,0,0);\n\n    float x = M.xy==vec2(0) || M.z<0. ? uv.x<mid ? -.75:0. : (M.y / R.y * 1. - .5) * PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : (M.x / R.x * 1. - .5) * PI;\n\n    mat2 rx = rot(x+(.55*sin(T*.05))), ry = rot(y+T*.03);\n    ro.zy *= rx,ro.zx *= ry;\n    \n    float spd = .075;\n    ro.xz+=1., lp.xz+=1.;\n    \n    if(uv.x<mid) {\n        ro.y-=T*spd, lp.y-=T*spd;\n    } else {\n        ro.z-=T*spd, lp.z-=T*spd;\n    }\n    \n    vec3 rd = camera(ro,lp,uv);\n    float d = 0.;\n\n    C = render(ro, rd, d);\n\n    C = mix(FC.rgb,C,  exp(-.009*d*d*d));\n    C=clamp(C,vec3(.03),vec3(.9));\n    \n    // output\n    O = vec4(C,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}