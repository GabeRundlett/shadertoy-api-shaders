{
    "Shader": {
        "info": {
            "date": "1629651091",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "fscGDH",
            "likes": 22,
            "name": "shortest torus interior mesh",
            "published": 3,
            "tags": [
                "torus",
                "short",
                "golf",
                "tokamak"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 489
        },
        "renderpass": [
            {
                "code": "// more readable version at the end ;-)\n\n// ---  -9 by Fab     now starting with the obfuscating golfing\n\n#define r mat2( cos( A.xyzx + .5 + cos( iTime + A )  // rotation from camera animation\n                                \nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R;                                          // marching point along ray \n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        O.xyz = p, \n        O.yz *= r.y/4.)),                                     // rotations       \n        O.w = length(O.xz *= r.x/2.)) ) - 20., // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O = l* U.x * U.yyyy;    // O = l* vec4(U,0,0);   // colored\n // U  = 18.*atan(O.xy,O.zw); O = l*(.5+.5*sin(U.x+U.yyyy));      // strips\n} \n/**/\n\n\n\n\n\n\n/* // --- 346: -10 by Fab\n\n#define r(a) mat2( cos( .5 + cos( iTime + A ).a + A.xyzx ) )  // rotation from camera animation\n                                \nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R;                                          // marching point along ray \n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        O.xyz = p, \n        O.yz *= r( y/4. ),                                    // rotations\n        O.xz *= r( x/2. ),         \n        O.w = length(O.xz) - 20., // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O = l* U.x * U.yyyy;    // O = l* vec4(U,0,0);   // colored\n // U  = 18.*atan(O.xy,O.zw); O = l*(.5+.5*sin(U.x+U.yyyy));      // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  // 356: -4 by Fab \n\n#define r(a)    mat2( cos( .5 + M.a + A.xyzx ) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R,                                          // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        O.xyz = p, \n        O.yz *= r( y ),                                       // rotations\n        O.xz *= r( x ),         \n        O.w = length(O.xz) - 20., // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O = l* U.x * U.yyyy;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);     // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  // 360: -2 by Fab\n\n#define r(a)    mat2( cos( .5 + M.a + A.xyzx ) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R, q,                                       // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( y ),                                       // rotations\n        q.xz *= r( x ),         \n        O = vec4( q, length(q.xz)-20. ), // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O += l* U.x * U.y - O;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);     // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  // 362: -5 by Fab\n\n#define r(a)    mat2( cos( .5 + M.a + A.xyzx ) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R, q, d,                                    // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( y ),                                       // rotations\n        q.xz *= r( x ),         \n        d = vec3( length(q.xz)-20., q ), // R0=20   R1=17\n        t = 17. - length(d.xz),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(q.yz,d.xy)) ) / fwidth(U), 1.); // mesh\n    O += l* U.x * U.y - O;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);     // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  367:  -4 by Xor\n\n#define r(a)    mat2( cos( a + A.xyzx ) )                     // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R, q,                                       // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float t=9.,d;\n     \n    for ( O += 1.1-O ; O.x > 0. && t > .01 ; O-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( .5+M.y ),                                  // rotations\n        q.xz *= r(    M.x ),    // R0=20   R1=17\n        t = 17. - length(vec2(d=length(q.xz)-20., q.y)),      // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(q.yz,vec2(d,q))) ) / fwidth(U), 1.); // mesh\n    O *= U.x * U.y;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);          // strips\n}  \n/**/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}