{
    "Shader": {
        "info": {
            "date": "1671699002",
            "description": "A primitive test of 4D voxel raycasting with a random perlin noise grid. I have no idea if the result is correct, but it looks interesting.",
            "flags": 0,
            "hasliked": 0,
            "id": "Dls3WH",
            "likes": 11,
            "name": "4D Voxel Raycasting ",
            "published": 3,
            "tags": [
                "raycasting",
                "voxel",
                "4d"
            ],
            "usePreview": 0,
            "username": "SpencerKuan",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "/*\n\n\n    This program generalizes a 3D voxel DDA raycasting \n    approach into 4D, by simply casting a 4D ray into a 4D voxel \n    grid. The result has 4 axis of movement and 6 planes of rotation.\n\n\n*/\n\n\n\n\nstruct Ray4 {\n    vec4 o;\n    vec4 d;\n};\n\nstruct Hit4 {\n    float dist;\n    vec4 normal;\n};\n\nHit4 raycast (Ray4 ray, out bool hit){\n    vec4 p = ray.o;\n\n    vec4 grid = floor(ray.o);\n    \n    vec4 dirSign = sign(ray.d);\n    vec4 dirInv = abs(1.0 / ray.d);\n    \n    vec4 sideDist = vec4(0.0);\n    sideDist = vec4(\n        (dirSign.x == -1. ? p.x - grid.x : -(p.x - grid.x) + 1.) * dirInv.x, \n        (dirSign.y == -1. ? p.y - grid.y : -(p.y - grid.y) + 1.) * dirInv.y, \n        (dirSign.z == -1. ? p.z - grid.z : -(p.z - grid.z) + 1.) * dirInv.z,\n        (dirSign.w == -1. ? p.w - grid.w : -(p.w - grid.w) + 1.) * dirInv.w\n    );\n    \n    int side = 0;\n    \n    int i = 0;\n    hit = false;\n    float dist = 0.0;\n    \n    while (i++ < 50 && hit == false){\n        float minD = min(min(min(sideDist.x, sideDist.y), sideDist.z), sideDist.w);\n        \n        if (minD == sideDist.x){\n            side = 0;\n            \n            sideDist.x += dirInv.x;\n            dist = sideDist.x - dirInv.x;\n            grid.x += dirSign.x;\n        } else if (minD == sideDist.y){\n            side = 1;\n            dist = sideDist.y;\n            sideDist.y += dirInv.y;\n            grid.y += dirSign.y;\n        } else if (minD == sideDist.z){\n            side = 2;\n            dist = sideDist.z;\n            sideDist.z += dirInv.z;\n            grid.z += dirSign.z;\n        } else if (minD == sideDist.w){\n            side = 3; \n            dist = sideDist.w;\n            sideDist.w += dirInv.w;\n            grid.w += dirSign.w;\n        }\n        \n        hit = voxel(grid) > 0.5;\n    }\n\n    if (!hit) return Hit4(0.0, vec4(0));\n    \n    vec4 norm;\n    switch (side){\n        case 0:\n            norm = vec4(dirSign.x, 0, 0, 0);\n            break;\n        case 1:\n            norm = vec4(0, dirSign.y, 0, 0);\n            break;\n        case 2:\n            norm = vec4(0, 0, dirSign.z, 0);\n            break;\n        case 3:\n            norm = vec4(0, 0, 0, dirSign.w);\n            break;\n        \n    }\n    return Hit4(dist, norm);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float z = 0.3;\n    float w = 0.3;\n    vec4 rd = normalize(vec4((fragCoord.xy - iResolution.xy * 0.5) / max(iResolution.x, iResolution.y), z, w));\n    vec4 ro = vec4(0.2, -0.15, -0.1, 0.2) * iTime;\n    \n    \n    float rotations[6] = float[](0.2 * iTime, 0.4, 0.0, 0.1 * iTime, 0.0, -0.1 * iTime);\n    \n    mat4 mat = rotateXY(rotations[0]) * rotateXZ(rotations[1]) * rotateXW(rotations[2])* rotateYZ(rotations[3]) * rotateYW(rotations[4]) * rotateZW(rotations[5]);\n    rd = mat * rd;\n    \n    \n    bool didHit;\n    Ray4 camera = Ray4(ro, rd);\n    Hit4 hit = raycast(camera, didHit);\n    \n    \n    vec3 col = vec3(0);\n    if (didHit){\n        // vec4 col4 = hit.normal.wzyx * 0.25 + 0.5;\n        // col = cmykToRGB(col4);\n        \n        vec3 light = vec3(0);\n        \n        light += max(dot(vec4(0.2, 0.3, 0.5, -0.7), hit.normal), 0.0) * vec3(67, 197, 158) / 255.;\n        light += max(dot(vec4(0.8, -0.6, 0.1, 0), hit.normal), 0.0) * vec3(0, 157, 220) / 255.;\n        light += max(dot(vec4(-0.7, 0.7, -0.4, 0.6), hit.normal), 0.0) * vec3(242, 100, 48) / 255.;\n        \n        col = light / (hit.dist + 15.0) * 15.0;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//////////////////////////////////////////////////////////////\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);vec4 p,s;p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;p.w = 1.5 - dot(abs(p.xyz), ones.xyz);s = vec4(lessThan(p, vec4(0.0)));p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;return p;}float snoise(vec4 v){const vec2  C = vec2( 0.138196601125010504,0.309016994374947451);vec4 i  = floor(v + dot(v, C.yyyy) );vec4 x0 = v -   i + dot(i, C.xxxx);vec4 i0;vec3 isX = step( x0.yzw, x0.xxx );vec3 isYZ = step( x0.zww, x0.yyz );i0.x = isX.x + isX.y + isX.z;i0.yzw = 1.0 - isX;i0.y += isYZ.x + isYZ.y;i0.zw += 1.0 - isYZ.xy;i0.z += isYZ.z;i0.w += 1.0 - isYZ.z;vec4 i3 = clamp( i0, 0.0, 1.0 );vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );vec4 x1 = x0 - i1 + 1.0 * C.xxxx;vec4 x2 = x0 - i2 + 2.0 * C.xxxx;vec4 x3 = x0 - i3 + 3.0 * C.xxxx;vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;i = mod(i, 289.0);float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);vec4 j1 = permute( permute( permute( permute (i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;vec4 p0 = grad4(j0,   ip);vec4 p1 = grad4(j1.x, ip);vec4 p2 = grad4(j1.y, ip);vec4 p3 = grad4(j1.z, ip);vec4 p4 = grad4(j1.w, ip);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;p4 *= taylorInvSqrt(dot(p4,p4));vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);m0 = m0 * m0;m1 = m1 * m1;return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;}\n//\n//////////////////////////////////////////////////////////////\n\n\n\n// scene helper \n\nfloat voxel(vec4 p)\n{\n    p = floor(p) + vec4(543., 423., 9432., 234.);\n    \n    float v = snoise(p * 0.2);\n    return clamp(round(v), 0.0, 1.0);\n}\n\n// --- 4D helper functions --- //\n\nmat4 rotateXY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s, c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateYZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        0.0, s, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, 0.0, -s,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        s, 0.0, 0.0, c\n    );\n}\n\nmat4 rotateYW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, 0.0, -s,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, s, 0.0, c\n    );\n}\n\nmat4 rotateZW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, c, -s,\n        0.0, 0.0, s, c\n    );\n}\n\n\n// --- color helper functions --- //\n\nvec3 cmykToRGB(vec4 cmyk) {\n    float c = cmyk.x;\n    float m = cmyk.y;\n    float y = cmyk.z;\n    float k = cmyk.w;\n\n    float r = (1.0 - c) * (1.0 - k);\n    float g = (1.0 - m) * (1.0 - k);\n    float b = (1.0 - y) * (1.0 - k);\n\n    return vec3(r, g, b);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}