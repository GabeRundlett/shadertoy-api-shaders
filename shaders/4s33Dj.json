{
    "Shader": {
        "info": {
            "date": "1452130061",
            "description": "Each colored circle belongs to a team, and they must flock while segregating from different teams.\nPress SPACE to switch the number of teams! Try it!",
            "flags": 48,
            "hasliked": 0,
            "id": "4s33Dj",
            "likes": 71,
            "name": "Swarm Segregation (ICRA 2014)",
            "published": 3,
            "tags": [
                "robot",
                "control",
                "swarm",
                "robotics",
                "flocks",
                "flocking"
            ],
            "usePreview": 0,
            "username": "vgs",
            "viewed": 2801
        },
        "renderpass": [
            {
                "code": "// Created by Vinicius Graciano Santos - vgs/2016\n// This shader is an implementation of my ICRA 2014 paper:\n// \"Segregation of Multiple Heterogeneous Units in a Robotic Swarm\"\n\n// If you are interested, the paper can be found in these links:\n// http://dx.doi.org/10.1109/ICRA.2014.6906993\n// http://viniciusgraciano.com/downloads/icra2014-segregation.pdf\n\n// The controller works in 3D too, as you can see in the end of this video:\n// https://www.youtube.com/watch?v=tN6yEOUU00I\n\nvec4 loadState(in vec2 id) {\n    vec2 uv = (id + 0.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\n// https://www.shadertoy.com/view/MsS3Wc (by iq)\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    // Center the scene around the centroid of the swarm.\n    vec2 c = vec2(0.0);\n    for (int i = 0; i < 10; ++i)\n        for (int j = 0; j < 10; ++j)\n        \tc += loadState(vec2(i, j)).xy;    \n    \n    vec2 uv = 6.0 * (-iResolution.xy + 2.0*fragCoord) / iResolution.y + c/100.0;     \n    \n    // Render the swarm.\n    float dist = 1e10; int id = 0;\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n       \t \tfloat d = length(uv - loadState(vec2(i, j)).xy);\n        \tif (d < dist) {dist = d; id = 10*i+j;}\n    \t}    \n    }\n    dist = smoothstep(0.1, 0.2, dist);    \n    \n    // Select a color for each team.    \n    int TEAMS = int(loadState(vec2(10.0)).x), RPT = 100 / TEAMS;\n    vec3 col = (1.0 - dist) * hsv2rgb(vec3(float(id/RPT)/float(TEAMS), 1.0, 1.0)) + 0.1;\n    \n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Simulation Logic */\n\n// If the simulation is too fast/slow, decrease/increase the values of ALPHA and DT\n// This happens because the simulation currently depends on the frame rate...\n// I'll try to fix this soon...\n\n// ALPHA controls the magnitude of the pairwise force\n// dAA relates to the spacing between robots in the same team\n// dAB relates to the spacing between robots in different teams\n// DT is the delta time of the simulation\n// HINT: if you switch the values of dAA and dAB the swarm will aggregate instead of segregate\n#define ALPHA 12.5\n#define dAA 4.0\n#define dAB 7.0\n#define DT 0.01\n\n\nvec2 hash(vec2 p);\nvec4 initState(in vec2 id) {    \n    vec2 r = 2.0 * hash(id) - 1.0;\n    return vec4(10.0 * r, 0.0, 0.0);    \n}\n\nvec4 loadState(in vec2 id) {\n    vec2 uv = (id + 0.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 updateState(in vec2 id, in int teams) {\n    int RPT = 100 / teams;\n    \n    vec2 u = vec2(0.0);\n    vec4 qi = loadState(id);\n        \n    for (int i = 0; i < 10; ++i) {\n    \tfor (int j = 0; j < 10; ++j) {        \t\n        \n        \tvec4 qj = loadState(vec2(i, j));\n        \tvec2 qij = qi.xy - qj.xy;\n        \tfloat mqij = length(qij);\n        \tfloat dij = ((10*i+j)/RPT == int(10.0*id.x+id.y)/RPT) ? dAA : dAB;\n        \n        \tif (mqij < 1e-2) continue;\n    \n        \t// Control equation (eq. 2 in the paper)\n        \tu -= ALPHA * (mqij - dij + 1.0/mqij - dij/(mqij*mqij)) * qij / mqij;\n        \tu -= qi.zw - qj.zw;        \n    \t}\n\t}\n\n    // Simple ODE solver.\n    qi.xy += qi.zw * DT + 0.5 * u * DT * DT;\n    qi.zw += u * DT;\n    return qi;\n}\n\n// Hash by Dave Hoskins ( https://www.shadertoy.com/view/4djSRW )\nvec2 hash(vec2 p) {\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    fragCoord = floor(fragCoord);    \n    if (fragCoord.x > 10.0 || fragCoord.y > 10.0) discard;\n    \n    vec4 state = vec4(0.0), data = state;\n    \n    if (iFrame == 0) {\n    \tdata = vec4(5.0, 0.0, 0.0, 0.0);\n    \tstate = initState(fragCoord);\n    } else {\n    \tdata = loadState(vec2(10.0));\n   \t\tstate = updateState(fragCoord, int(data.x));\n    }\n        \n    float space = texture(iChannel1, vec2(32.5/256.0,0.25)).x;\n    if (space > 0.5 && (iTime - data.y) > 0.5) {\n      \tdata.y = iTime;\n       \tif (data.x == 2.0) data.x = 4.0;\n       \telse if (data.x == 4.0) data.x = 5.0;\n       \telse if (data.x == 5.0) data.x = 10.0;\n       \telse data.x = 2.0;\n    }            \n    \n    fragColor = fragCoord != vec2(10.0) ? state : data;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}