{
    "Shader": {
        "info": {
            "date": "1534964926",
            "description": "Use UP/DOWN arrow keys to zoom, LEFT/RIGHT to rotate, PAGE_UP/PAGE_DOWN to Mandelbrot zoom and LMB to move/change parameter",
            "flags": 48,
            "hasliked": 0,
            "id": "4ltyzM",
            "likes": 10,
            "name": "Julia Explorer",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "zizip0p",
            "viewed": 745
        },
        "renderpass": [
            {
                "code": "vec4 FetchColor(float index)\n{\n    return texture( iChannel0, vec2( index, 0.5 / float(textureSize( iChannel0, 0 ).y) ), 0.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 v = texelFetch( iChannel1, ivec2(fragCoord - vec2(0.5)), 0 );\n\n    if (dot(v.xy,v.xy) > BALEOUT2)\n    \tc = FetchColor((v.z + iTime*20.0) * 0.0001);\n    \n    v.xy = ScreenToFrame(fragCoord, iResolution.xy);\n    c = mix(c, vec4(1.0, 1.0, 0.0, 1.0), smoothstep(1.0, 0.0, dot(v.xy, v.xy)*0.1));\n    \n    if (BorderFrame(fragCoord, iResolution.xy)) c = vec4(1.0, 1.0, 0.0, 1.0);\n\n    \n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ITERS0 50\n#define ITERS 50\n#define BALEOUT 2.0\n#define BALEOUT2 (BALEOUT * BALEOUT)\n#define ZOOM_FACTOR 1.03\n#define ROT_DELTA 0.06\n#define MOUSE texelFetch( iChannel0, ivec2(0,0), 0 )\n#define MOUSEP texelFetch( iChannel0, ivec2(1,0), 0 )\n#define SCALER texelFetch( iChannel0, ivec2(2,0), 0 )\n#define ROTATOR texelFetch( iChannel0, ivec2(3,0), 0 )\n#define MOUSE2 texelFetch( iChannel0, ivec2(0,1), 0 )\n#define MOUSEP2 texelFetch( iChannel0, ivec2(1,1), 0 )\n#define SCALER2 texelFetch( iChannel0, ivec2(2,1), 0 )\n#define ZONE texelFetch( iChannel0, ivec2(3,0), 0 )\n#define FWIDTH 0.3\n#define FHEIGHT 0.4\n\nvec2 ScreenToWorld(in vec2 v, in vec2 res)\n{\n    vec2 r = v / res * 2.0 - 1.0;\n    r.x *= res.x/res.y;\n    return r;\n}\n\nvec2 ScreenToWorldS(in vec2 v, in vec2 res)\n{\n    return v / res.y * 2.0;\n}\n\nvec2 ScreenToWorld2(in vec2 v, in vec2 res)\n{\n    return ScreenToWorld(v - res * vec2(1. - FWIDTH, 1. - FHEIGHT), res * vec2(FWIDTH, FHEIGHT));\n}\n\nvec2 ScreenToFrame(in vec2 v, in vec2 res)\n{\n    return v - res * vec2(1. - FWIDTH*0.5, 1. - FHEIGHT*0.5);\n}\n\nbool inFrame(in vec2 pos, in vec2 res)\n{\n    vec2 v = pos / res;\n    return (v.x > (1. - FWIDTH)) && (v.y > (1. - FHEIGHT));\n}\n\nbool BorderFrame(in vec2 pos, in vec2 res)\n{\n    return inFrame(pos + vec2(1.0), res) && !inFrame(pos, res);\n}\n\nvec2 Rotate(in vec2 v, in float angle)\n{\n    vec2 a = vec2(cos(angle), sin(angle));\n    return v * mat2(vec2(a.x, a.y), vec2(-a.y, a.x));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_PAGEUP = 33;\nconst int KEY_PAGEDN = 34;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 res = vec4(0.0);\n    \n    //Mouse Pos\n\tif (fragCoord.xy == vec2(0.5, 0.5))\n\t{\n        res.xy = MOUSE.xy;\n        if ((iFrame > 0) && (iMouse.z > 0.0))\n        {\n            vec2 pos = iMouse.xy;\n            \n            if (!inFrame(pos, iResolution.xy) && (res.x != -1.0))\n                res.zw = pos - res.xy;\n            res.xy = pos;\n        }\n        else //OnMouseUp & OnMouseIdle\n            res.x = -1.0;\n\t}\n    else\n    //Mouse Pos with Scale & Rotate\n\tif (fragCoord.xy == vec2(1.5, 0.5))\n\t{\n        res = MOUSEP;\n        if ((iFrame > 0) && (iMouse.z > 0.0))\n        {\n            vec2 pos = iMouse.xy;\n            if (!inFrame(pos, iResolution.xy) && (res.x != -1.0))\n                res.zw += Rotate(ScreenToWorldS(pos - res.xy, iResolution.xy), ROTATOR.x) * SCALER.x;\n            res.xy = pos;\n        }\n        else //OnMouseUp & OnMouseIdle\n            res.x = -1.0;\n\t}\n\telse\n    //Scale\n\tif (fragCoord.xy == vec2(2.5, 0.5))\n\t{\n        res = SCALER;\n        if (iFrame == 0) res.xy = vec2(1.0);\n        res.y = res.x;\n        if (texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x > 0.0) res.x *= ZOOM_FACTOR;\n        if (texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x > 0.0) res.x /= ZOOM_FACTOR;\n        res.w = res.z;\n        res.z = iResolution.x;\n        //res.w = res.x/s;\n\t}\n    else\n    //Rotate\n\tif (fragCoord.xy == vec2(3.5, 0.5))\n\t{\n        res = ROTATOR;\n        res.y = res.x;\n        if (texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x > 0.0) res.x += ROT_DELTA;\n        if (texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x > 0.0) res.x -= ROT_DELTA;\n\t}\n    else\n    //Mouse Pos2    \n\tif (fragCoord.xy == vec2(0.5, 1.5))\n\t{\n        res.xy = MOUSE2.xy;\n        if ((iFrame > 0) && (iMouse.z > 0.0))\n        {\n            vec2 pos = iMouse.xy;\n            if (inFrame(pos, iResolution.xy) && (res.x != -1.0))\n                res.zw = pos - res.xy;\n            res.xy = pos;\n        }\n        else //OnMouseUp & OnMouseIdle\n            res.x = -1.0;\n\t}\n    else\n    //Mouse Pos2 with Scale & Rotate\n\tif (fragCoord.xy == vec2(1.5, 1.5))\n\t{\n        res = MOUSEP2;\n        if (iFrame == 0) res.zw = vec2(0.0801, -0.6605); //Init Parameter\n        if ((iFrame > 0) && (iMouse.z > 0.0))\n        {\n            vec2 pos = iMouse.xy;\n            if (inFrame(pos, iResolution.xy) && (res.x != -1.0))\n                res.zw += ScreenToWorldS(pos - res.xy, iResolution.xy * vec2(FWIDTH, FHEIGHT)) * SCALER2.x;\n            res.xy = pos;\n        }\n        else //OnMouseUp & OnMouseIdle\n            res.x = -1.0;\n\t}\n\telse\n    //Scale2\n\tif (fragCoord.xy == vec2(2.5, 1.5))\n\t{\n        res = SCALER2;\n        if (iFrame == 0) res.xy = vec2(1.0);\n        res.y = res.x;\n        if (texelFetch( iChannel1, ivec2(KEY_PAGEDN,0), 0 ).x > 0.0) res.x *= ZOOM_FACTOR;\n        if (texelFetch( iChannel1, ivec2(KEY_PAGEUP,0), 0 ).x > 0.0) res.x /= ZOOM_FACTOR;\n        res.w = res.z;\n        res.z = iResolution.x;\n        //res.w = res.x/s;\n\t}\n    \n    fragColor = res;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0.0);\n    vec2 Mouse;\n    vec4 s;\n    \n    if (inFrame(fragCoord, iResolution.xy))\n    {\n        Mouse = MOUSE2.zw;\n        s = SCALER2;\n\n        if (inFrame(fragCoord - Mouse, iResolution.xy) && (s.x == s.y) && (s.z == s.w))\n            c = texelFetch( iChannel1, ivec2(fragCoord - vec2(0.5) - Mouse), 0 );\n    }\n    else\n    {\n        Mouse = MOUSE.zw;\n        s = SCALER;\n        vec2 r = ROTATOR.xy;\n\n        if ((MOUSE2.zw == vec2(0.0, 0.0)) && !inFrame(fragCoord - Mouse, iResolution.xy) && (s.x == s.y) && (s.z == s.w) && (r.x == r.y))\n            c = texelFetch( iChannel1, ivec2(fragCoord - vec2(0.5) - Mouse), 0 );\n    }\n    \n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 MulC(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); \n}\n\nfloat Fractal(inout vec2 z0, vec2 k, int count)\n{\n    int i = 0;\n    if (dot(z0,z0) < BALEOUT2)\n        while (i < count)\n        {\n            vec2 z1 = MulC(z0, z0) + k;\n            i++;\n            if (dot(z1,z1) > BALEOUT2)\n            {\n                float res = length(z0);\n                res = float(i) + (BALEOUT - res)/(length(z1) - res);\n                z0 = z1;\n                return res;\n            }\n            z0 = z1;\n        }\n    return float(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool Frame = inFrame(fragCoord, iResolution.xy);\n    vec2 Mouse;\n    float s;\n    float r = 0.0;\n    vec2 k = vec2(0.0);\n    vec4 c = texelFetch( iChannel1, ivec2(fragCoord - vec2(0.5)), 0 );\n    int it = ITERS;\n    \n    if (Frame)\n    {\n        Mouse = MOUSEP2.zw;\n        s = SCALER2.x;\n        k = s * ScreenToWorld2( fragCoord, iResolution.xy ) - Mouse;\n    }\n    else\n    {\n        Mouse = MOUSEP.zw;\n        s = SCALER.x;\n        r = ROTATOR.x;\n        k = -MOUSEP2.zw;\n    }\n    \n    if (c.z == 0.0)\n    {\n        it = int(float(ITERS0) / pow(s, 0.3));\n        if (!Frame)\n        \tc.xy = Rotate(s * ScreenToWorld( fragCoord, iResolution.xy ), r) - Mouse;\n    }\n\n    c.z += float(Fractal(c.xy, k, it));\n    \n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}