{
    "Shader": {
        "info": {
            "date": "1464264198",
            "description": "Raymarched infinite terrain",
            "flags": 32,
            "hasliked": 0,
            "id": "lsyXD1",
            "likes": 2,
            "name": "Raymarched Infinite Terrain",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "GonzaloQuero",
            "viewed": 918
        },
        "renderpass": [
            {
                "code": "vec3 blur(vec2 texCoords, bool horizontal)\n{\n    float weight[5];\n    weight[0] = 0.227027;\n    weight[1] = 0.1945946;\n    weight[2] = 0.1216216;\n    weight[3] = 0.054054;\n    weight[4] = 0.016216;\n    vec2 tex_offset = vec2(2.0 / iResolution.x, 1.0 / iResolution.y); // gets size of single texel\n    vec3 result = texture(iChannel1, texCoords).rgb * weight[0]; // current fragment's contribution\n\n    for(int i = 1; i < 5; ++i)\n    {\n        result += texture(iChannel1, texCoords + vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i];\n        result += texture(iChannel1, texCoords - vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i];\n        result += texture(iChannel1, texCoords + vec2(0.0, tex_offset.y * float(i))).rgb * weight[i];\n        result += texture(iChannel1, texCoords - vec2(0.0, tex_offset.y * float(i))).rgb * weight[i];\n    }\n \n    return result;\n}\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.411764705882353) * direction;\n  vec2 off2 = vec2(3.2941176470588234) * direction;\n  vec2 off3 = vec2(5.176470588235294) * direction;\n  color += texture(image, uv) * 0.1964825501511404;\n  color += texture(image, uv + (off1 / resolution)) * 0.2969069646728344;\n  color += texture(image, uv - (off1 / resolution)) * 0.2969069646728344;\n  color += texture(image, uv + (off2 / resolution)) * 0.09447039785044732;\n  color += texture(image, uv - (off2 / resolution)) * 0.09447039785044732;\n  color += texture(image, uv + (off3 / resolution)) * 0.010381362401148057;\n  color += texture(image, uv - (off3 / resolution)) * 0.010381362401148057;\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0,uv);\n    vec4 bloom = blur13(iChannel1, uv, iResolution.xy, vec2(1.0, 0.0));\n    bloom += blur13(iChannel1, uv, iResolution.xy, vec2(0.0, 1.0));\n    \n    const float b = 0.5;\n    vec4 final = tex + clamp((b * bloom), 0.0, 1.0);\n    final = (final - 0.5) * 1.2 + 0.5 + 0.0;\n    fragColor = final;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float saturate(float x)\n{\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat fade(float t)\n{\n\treturn t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n}\n\n// improved bilinear interpolated texture fetch\nvec4 textureGood( sampler2D sam, vec2 uv )\n{\n    vec2 res = vec2(512.0);\n\n    vec2 st = uv*res - 0.5;\n\n    vec2 iuv = floor( st );\n    vec2 fuv = fract( st );\n\n    vec4 a = texture( sam, (iuv+vec2(0.5,0.5))/res );\n    vec4 b = texture( sam, (iuv+vec2(1.5,0.5))/res );\n    vec4 c = texture( sam, (iuv+vec2(0.5,1.5))/res );\n    vec4 d = texture( sam, (iuv+vec2(1.5,1.5))/res );\n\n    return mix( mix( a, b, fuv.x),\n                mix( c, d, fuv.x), fuv.y );\n}\n\n#define PI 3.141592\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat heightFromNoise(vec2 position)\n{\n\tconst float numberOfOctaves = 3.0;\n\tfloat fn = 0.0;\n\n\tfor(float i = 1.0; i < numberOfOctaves; i++)\n\t{\n\t\tfloat p = pow(2.0, i);\n\t\tfn += snoise(0.5 * position.xy * p) * (1.0 / p);\n\t}\n\n\treturn fn;\n}\n\nfloat mapHeight(vec2 position)\n{\n\treturn 0.5 * heightFromNoise(position);\n}\n\nfloat estimateMaxDistance(vec3 p, vec3 rayDirection)\n{\n\tfloat h = p.y - mapHeight(p.xz);\n\tconst float M = 0.01;\n\n\tfloat dz = -rayDirection.z;\n\tfloat dx = -sqrt( rayDirection.x * rayDirection.x + dz*dz );\n\tfloat dy = -rayDirection.y;\n\n\tfloat t1 = -h / (-M*dx - dy);\n\tfloat t2 = -h / (M*dx - dy);\n\n\tfloat dt = max(t1,t2);\n\n\treturn dt * 0.025;\n}\n\nfloat initialT(vec3 rayOrigin, vec3 rayDirection)\n{\n    float maxH = 3.0;\n    float height = rayOrigin.y - maxH;\n    float angle = acos(dot(vec3(0.0), normalize(rayDirection)));\n    float thirdAngle = (PI / 2.0) - (PI / 4.0) - angle;\n    \n    float t = (height * sin(PI / 4.0)) / sin(thirdAngle);\n    \n \treturn t;   \n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDirection)\n{\n    rayDirection = normalize(rayDirection);\n\tfloat t = initialT(rayOrigin, rayDirection);\n    \n    if(rayDirection.y > 0.0) \n    {\n        // Avoid rays to the sky\n     \tt = 9999.0;   \n    }\n    \n\tfor (float i = 0.0; i < 512.0; i++)\n\t{\n\t\tvec3 p = rayOrigin + rayDirection * t;\n        float d = (p.y - mapHeight(p.xz)) * 0.6;\n        \n        if(d < 0.0) {\n            p = rayOrigin + rayDirection * (t - (abs(d) * 0.5));\n           \treturn vec4(p.xyz, t);\n        }\n\n\t\tif(d < 0.01) {\n\t\t\treturn vec4(p.xyz, t);\n\t\t}\n\n\t\tt += d * (0.1 * t);\n        \n\t\tif(t > 20.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn vec4(vec3(0.0), 0.0);\n}\n\nfloat softShadow(vec3 rayOrigin, vec3 rayDirection)\n{\n\tconst float steps = 32.0;\n    const float dist = 10.0;\n\tconst float d = dist / steps;\n\tfloat res = 1.0;\n\tfloat t = 0.0;\n\n\tfor (float i = 0.0; i < steps; i++)\n\t{\n\t\tvec3 p = rayOrigin + normalize(rayDirection) * t;\n\t\tfloat h = p.y - mapHeight(p.xz);\n\n        if( h<0.001 )\n        {\n            return 0.0;\n        }\n        \n        res = min( res, 4.0*h/t );\n\t\tt += d;\n\t}\n\n\treturn res;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tconst float eps = 0.001;\n\n\tfloat nx = mapHeight(vec2(p.x - eps, p.z)) - mapHeight(vec2(p.x + eps, p.z));\n\tfloat ny = 2.0 * eps;\n\tfloat nz = mapHeight(vec2(p.x, p.z - eps)) - mapHeight(vec2(p.x, p.z + eps));\n\n\tvec3 n = vec3(nx, ny, nz);\n\n\treturn normalize(n);\n}\n\nfloat orenNayarDiffuse(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float roughness,\n float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nfloat lighting(vec3 normal, vec3 lightDir, vec3 viewDir)\n{\n    return orenNayarDiffuse(lightDir, viewDir, normal, 0.6, 1.0);\n}\n\nvec4 linearize(vec4 color)\n{\n\tconst vec4 gamma = vec4(2.2);\n\treturn pow(color, gamma);\n}\n\nvec4 gammaCorrect(vec4 color)\n{\n\tconst vec4 gammaCurve = vec4(1.0 / 2.2);\n\treturn pow(color, gammaCurve);\n}\n\nvec3 getRayDirection(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\treturn normalize(vec3(uv, 2.5));\n}\n\nfloat getSnowMix(vec3 normal)\n{\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tfloat NdotU = dot(normal, up);\n\tfloat snowMix = saturate(pow(NdotU, 10.0));\n\treturn snowMix;\n}\n\nvec4 toGray(vec4 color, float v)\n{\n   \tfloat luminance = color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\n\treturn mix(color, vec4(luminance), v);\n}\n\nvec4 texturizePoint(vec3 position, vec3 normal)\n{\n    vec2 uv = vec2(position.x, position.z);\n\tvec4 rockColor = linearize(textureGood(iChannel2, uv * 2.0));\n    rockColor = clamp(toGray(rockColor, 0.3) + 0.1, 0.0, 2.0);\n\n\tvec4 snowColor = linearize(textureGood(iChannel3, uv * 8.0));\n    snowColor = toGray(snowColor, 1.0) * 4.0;\n\n\tfloat snowMix = getSnowMix(normal);\n\tvec4 color = mix(rockColor, snowColor, snowMix);\n\n\treturn color;\n}\n\nfloat getFogMix(float depth)\n{\n\tconst float maxDepth = 28.0;\n\tfloat saturatedDepth = depth / maxDepth;\n\tfloat unclampedMix = saturatedDepth * 3.0 - 1.0;\n\n\tfloat fog = saturate(unclampedMix);\n\treturn fog;\n}\n\nvec4 drawTerrain(vec4 t, vec3 rd)\n{\n\tconst vec3 lightDir = vec3(0.5, 0.25, -0.5);\n\tconst vec4 fogColor = vec4(0.1, 0.1, 0.1, 1.0);\n    const float lightPower = 0.2;\n    const float ambientLight = 0.2;\n\n\tvec3 normal = getNormal(t.xyz);\n\n\tfloat light = lighting(normal, lightDir, rd) * lightPower + ambientLight;\n\tfloat shadow = saturate(softShadow(t.xyz, lightDir) + 0.3);\n\tvec4 terrainColor = texturizePoint(t.xyz, normal);\n\n\tfloat fog = getFogMix(t.w);\n\n\tvec4 shadedColor = terrainColor * light * shadow;\n\tvec4 finalColor = mix(shadedColor, fogColor, fog);\n\n\treturn gammaCorrect(finalColor);\n}\n\nvec4 drawSky(vec3 rayDirection)\n{\n    return vec4(0.3, 0.3, 1.0, 1) * (1.15 - rayDirection.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 camPos = vec3(0, 1.5, 1.5 * iTime);\n\tvec3 rayDirection = getRayDirection(fragCoord);\n\tvec4 t = castRay(camPos, rayDirection);\n\n    \n\tif (t.w > 0.0)\n\t{\n\t\tfragColor = drawTerrain(t, rayDirection);\n\t}\n\telse\n\t{\n\t\tfragColor = drawSky(rayDirection);\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 texture = texture(iChannel0,uv);\n    \n    float brightness = dot(texture.rgb, vec3(0.2126, 0.7152, 0.0722));\n    fragColor = mix(vec4(0.0), texture, (brightness - 0.2) * 0.8) * 10.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}