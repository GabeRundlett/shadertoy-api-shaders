{
    "Shader": {
        "info": {
            "date": "1508191588",
            "description": "Approximate equal area maps from cube face to sphere. See [url]https://www.shadertoy.com/view/MtBGRD[/url] for example usage. Mouse to see specific subplots.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlfDl",
            "likes": 14,
            "name": "cube -> sphere maps",
            "published": 3,
            "tags": [
                "cube",
                "sphere",
                "maps",
                "justmath",
                "kindaboring"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1665
        },
        "renderpass": [
            {
                "code": "/* cube -> sphere maps, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Visualizing six approximate equal-area mappings from cube to sphere. \n   See https://www.shadertoy.com/view/MtBGRD for example usage.\n\n   Mappings shown here:\n\n     - identity\n\n     - tangent (used in original shader linked above)  \n\n     - Cass Everitt's piecewise quadratic warp \n       https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n\n     - odd univariate polynomial with 3 params (so 5th degree)\n\n     - COBE quadrilateralized spherical cube method\n       https://en.wikipedia.org/wiki/Quadrilateralized_spherical_cube\n\n     - Arvo's exact equal area method \n       http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.3412&rep=rep1&type=pdf\n\n   The \"dA error\" plot shows how bad a mapping is at preserving area. Flat green means\n   good, equal-area projection. Identity mapping is awful.\n\n   The \"inverse\" plot shows how invertible a mapping is. The polynomial/COBE methods \n   have only an approximate inverse, which can be refined (pixels below diagonal)\n   using either the secant method or Broyden's method.\n   \n     - https://en.wikipedia.org/wiki/Secant_method\n     - https://en.wikipedia.org/wiki/Broyden%27s_method\n\n   Use mouse to see enlarged plots.\n\n*/\n\n\nconst float INV_TOL = 1e-7;\n\nfloat method = 0.0;\nfloat plot = 0.0;\n\n//////////////////////////////////////////////////////////////////////\n// Warp from cube face to sphere\n\nvec2 warp(vec2 x) {\n    if (method == 0.0) { // identity\n        return x; \n    } else if (method == 1.0) { // tan\n        return tan(x * 0.868734829276) * 0.845818541496;\n    } else if (method == 2.0) { // everitt\n        return sign(x)*(1.60841218698 - 1.10841218698*sqrt(2.10567880551 - 1.80438290331*abs(x)));\n    } else if (method == 3.0) { // poly3\n        vec2 x2=x*x;\n        return (0.745558715593 + (0.130546850193 + 0.123894434214*x2)*x2)*x;\n    } else if (method == 4.0) { // cobe\n        vec2 y = x.yx;\n        vec2 x2 = x*x, y2=y*y;\n        vec2 bsum = ( (-0.0941180085824 + 0.0409125981187*y2 - 0.0623272690881*x2)*x2 +\n                      (0.0275922480902 + 0.0342217026979*y2)*y2 );\n        return ( 0.723951234952 + 0.276048765048*x2 + (1.0 - x2)*bsum )*x;\n    } else { // arvo\n        float tan_a_term = tan(x.x * 0.523598775598);\n        float cos_a_term = cos(x.x * 1.0471975512);\n        return vec2(1.41421356237 * tan_a_term / sqrt(1.0 - tan_a_term*tan_a_term),\n                    x.y / sqrt(1.0 + (1.0 - x.y*x.y)*cos_a_term));\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Unwarp from sphere to cube face - only approximate for poly3/cobe\n\nvec2 unwarp(vec2 x) {\n    \n    if (method == 0.0) { // identity\n        return x; \n    } else if (method == 1.0) { // tan\n        return atan(x * 1.18228668555) * 1.151099238;\n    } else if (method == 2.0) { // everitt\n        return x*(1.45109572583 - 0.451095725826*abs(x));\n    } else if (method == 3.0) { // poly3\n        vec2 x2 = x*x;\n        return (1.34318229552 + (-0.486514066449 + 0.143331770927*x2)*x2)*x;\n    } else if (method == 4.0) { // cobe\n        vec2 y = x.yx;\n        vec2 x2 = x*x, y2=y*y;\n        vec2 bsum = ( (-0.212853382041 + 0.0941259684877*y2 + 0.0693532685333*x2)*x2 +\n                     (-0.117847692949 + 0.0107989197181*y2)*y2 );\n        return ( 1.37738198385 - 0.377381983848*x2 + (1.0 - x2)*bsum )*x;\n    } else { // arvo\n        float ss2 = sqrt(x.x*x.x+2.0);\n        return vec2(atan( x.x / ss2 ) * 1.9098593171,\n                    x.y * ss2 / sqrt(dot(x,x) + 1.0));\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Return max abs element.\n\nfloat infnorm(vec2 f) {\n    f = abs(f);\n    return max(f.x, f.y);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Iterative inverse of warp function.\n\nvec2 unwarp_iter(vec2 u) {\n    \n    const int max_iter = 3;\n    \n    vec2 x = unwarp(u);\n    \n    if (method == 3.0) {\n        \n        // can use secant method to refine poly3\n        \n        vec2 f0 = warp(x) - u;\n        vec2 delta_x = -0.1 * f0;\n        x += delta_x;\n        \n        for (int i=0; i<max_iter; ++i) {\n            vec2 f1 = warp(x) - u;\n            if (infnorm(f1) < INV_TOL) { break; }\n            vec2 delta_f = (f1 - f0);\n            vec2 inv_slope = mix(vec2(1.0), delta_x / delta_f, \n                                 lessThan(vec2(1e-7), abs(delta_f)));\n            delta_x = -f1 * inv_slope;\n            x += delta_x;     \n            f0 = f1;\n        }\n        \n    } else if (method == 4.0) {\n        \n        // can use Broyden's method to refine cobe\n        mat2 H = mat2(1.0);\n        \n        vec2 f0 = warp(x) - u;\n        vec2 delta_x = -0.1 * f0;\n        x += delta_x;\n        \n        for (int i=0; i<max_iter; ++i) {\n            \n            vec2 f1 = warp(x) - u;\n            if (infnorm(f1) < INV_TOL) { break; }\n                            \n            vec2 Hdf = H * (f1 - f0);\n\n            H += outerProduct((delta_x - Hdf) / dot(delta_x, Hdf),\n                            delta_x * H);\n            \n            delta_x = -H * f1;\n            \n            x += delta_x;\n            f0 = f1;\n                \n        }\n        \n    }\n    \n    return x;\n    \n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Numerical Jacobian of warp, used to visualize dA error\n\nvoid warpJ(in vec2 x, out vec2 y, out mat2 J) {\n    \n    y = warp(x);\n    \n    const vec2 h = vec2(1e-2, 0);\n\n    J = mat2(warp(x + h.xy) - warp(x - h.xy),\n             warp(x + h.yx) - warp(x - h.yx)) * 0.5 / h.x;\n    \n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Numerical Jacobian of inverse warp, used to visualize grid lines\n\nvoid unwarpJ(in vec2 x, out vec2 y, out mat2 J) {\n    \n    y = unwarp(x);\n    \n    const vec2 h = vec2(1e-2, 0);\n\n    J = mat2(unwarp(x + h.xy) - unwarp(x - h.xy),\n             unwarp(x + h.yx) - unwarp(x - h.yx)) * 0.5 / h.x;    \n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// RGB from hue\n\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h > 1.0 ? vec3(0.5) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Raise number to the 1.5 power.\n\nfloat pow15(float x) {\n    return sqrt(x*x*x);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Distance to character in SDF font texture\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+vec2(0.5, 0.5)+offset)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 dist = abs(uv + vec2(0.0, 0.05)) - vec2(0.4);\n    float b = max(dist.x, dist.y);\n        \n    return max(k-0.5 + 1.0/256.0, b)/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Generate label \n\nvec2 char_offs(int c) {\n    c -= 64;\n    return vec2(0.0 + float(c&0xf), 11.0 - float(c >> 4));\n}\n\n#define C(c) d = min(d, font2d_dist(text_pos, text_size, char_offs(c))); text_pos.x -= advance;\n\nvec2 label(vec2 p, float text_size) {\n    \n    text_size = 14.0;\n    \n    float d = 1e5;\n    float advance = 0.8*text_size;\n    \n\n    vec2 text_pos = p - vec2(0.5, 1.0)*text_size - 2.0;\n\n    C(112); C(108); C(111); C(116); C(58); text_pos.x -= advance;\n    \n    if (plot == 0.0) {\n        C(119); C(97); C(114); C(112);\n    } else if (plot == 1.0) {\n        C(86); C(111); C(114); C(111); C(110); C(111); C(105);\n    } else if (plot == 2.0) {\n        C(100); C(65); C(32); C(101); C(114); C(114); C(111); C(114);\n    } else {\n        C(105); C(110); C(118); C(101); C(114); C(115); C(101);\n    }\n\n    if (iMouse.z > 0.0) {\n        \n        text_pos = p - vec2(0.5, 2.5)*text_size - 2.0;\n        \n        C(109); C(101); C(116); C(104); C(111); C(100); C(58); text_pos.x -= advance;\n        \n        if (method == 0.0) {\n            C(105); C(100); C(101); C(110); C(116); C(105); C(116); C(121);\n        } else if (method == 1.0) {\n            C(116); C(97); C(110);\n        } else if (method == 2.0) {\n            C(69); C(118); C(101); C(114); C(105); C(116); C(116);\n        } else if (method == 3.0) {\n            C(112); C(111); C(108); C(121); C(51);\n        } else if (method == 4.0) {            \n            C(67); C(79); C(66); C(69);\n        } else {\n            C(65); C(114); C(118); C(111);\n        }\n    }\n    \n    \n    return vec2(smoothstep(vec2(0.0), vec2(1.0), d - vec2(2.0, 0.0)));\n    \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    t = clamp(t, 0.0, 1.0);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 pal1(float t) {\n    //return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n}\n\nvec2 hash(vec2 p) {   \n    return textureLod(iChannel0, p/256., 0.).xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float scl; \n    vec2 p;\n    \n    \n    if (iMouse.z > 0.0) {\n        \n        scl = 2.0 / (iResolution.y - 8.0);\n        p = (fragCoord.xy + 0.5 - iResolution.xy * 0.5) * scl;\n        method = 5.0 - floor(6.0 * iMouse.y / iResolution.y);\n        plot = floor(4.0 * iMouse.x / iResolution.x);\n        \n    } else {\n\n        float base_scl = 4.0 / (iResolution.y);\n        scl = 4.0 / (iResolution.y - 8.0);  \n        p = (fragCoord.xy + 0.5 - iResolution.xy * vec2(0.5, 0.25)) * base_scl;\n        vec2 pc = floor(0.5*p + 0.5) * 2.0;\n        pc = clamp(pc, vec2(-2.0, 0.0), vec2(2.0));\n        method = 4.0 + dot(pc, vec2(0.5, -1.5));\n        p -= pc;\n        p *= scl / base_scl;\n        \n        if (max(iMouse.x, iMouse.y) > 10.0) {\n            plot = floor(4.0 * iMouse.x / iResolution.x);\n        } else {\n            plot = mod(floor(iTime*0.25), 4.0);\n        }\n    }    \n    \n    vec2 d = abs(p) - 1.0;\n    \n\tfragColor = vec4(1.0);\n\n    if (max(d.x, d.y) <= 0.0) {\n        \n        vec3 c;\n        \n        if (plot == 0.0) {\n\n            vec2 q;\n            mat2 J;\n            \n            unwarpJ(p, q, J);\n            \n            const float num_grid = 8.0;\n            vec2 g = abs(fract(num_grid*q+0.5)-0.5)/num_grid;\n\n            c = mix(vec3(1.0), hue(method/6.0), 0.1);\n            c *= vec3(smoothstep(0.0, scl, min(g.x, g.y)/sqrt(determinant(J))-0.1*scl));\n            \n        } else if (plot == 1.0) {\n\n            c = mix(vec3(1.0), hue(method/6.0), 0.1);\n            vec2 q = unwarp_iter(p);\n\n            const float N = 12.0;\n\n            vec2 qctr = (floor(0.5*N*q+0.5) + 0.5)*2.0/N;\n\n            vec2 p0, p1;\n            float d0 = 1e5, d1 = 1e5;\n\n            for (int i=-2; i<=1; ++i) {\n                for (int j=-2; j<=1; ++j) {\n                    vec2 qn = qctr + vec2(float(i), float(j))*2.0/N;\n                    vec2 r = textureLod(iChannel0, qn*0.5 + 255./512., 0.).xy;\n                    qn += (r - 0.5)*0.99*2.0/N;\n                    vec2 pn = warp(qn);\n                    float dn = length(p - pn);\n                    if (dn < d0) {\n                        d1 = d0; p1 = p0;\n                        d0 = dn; p0 = pn;\n                    } else if (dn < d1) {\n                        d1 = dn; p1 = pn;\n                    }\n                }\n            }\n\n            vec2 pm = 0.5*(p0 + p1);\n            vec2 n = normalize(p1 - p0);\n            float dm = abs(dot(p-pm, n));\n\n            c *= smoothstep(0., scl, d0 - 0.125/N);\n            c *= smoothstep(0., scl, dm);\n\n            vec2 l = 1. - abs(q);\n            float dg = min(l.x, l.y);\n            c *= smoothstep(0., scl, dg);\n\n\n        } else if (plot == 2.0) {\n        \n            vec2 q;\n            mat2 J;\n            \n            warpJ(p, q, J);\n            \n            float area_element = 1.0 / pow15(1.0 + dot(q, q));\n            const float TARGET = 0.5235987755982988;\n            float err = abs(determinant(J) * area_element - TARGET) / TARGET;\n            c = pal1(err/0.9);\n\n        } else {\n        \n            vec2 q = warp(p);\n            \n            vec2 p2 = p.y > -p.x ? unwarp(q) : unwarp_iter(q);\n            \n            c = pal1(length(p2 - p) / 0.002);\n            \n        }\n\n        fragColor = vec4(c, 1.0);\n\n    }\n    \n    float dborder = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    fragColor.xyz *= smoothstep(0.0, scl, abs(dborder));\n    \n    vec2 text_pos = fragCoord.xy - 0.5*iResolution.xy;\n    float text_size = 24.0;\n    \n    vec2 k = label(fragCoord.xy, text_size);\n\n    fragColor.xyz = mix(vec3(1), fragColor.xyz, k.x);\n    fragColor.xyz = mix(vec3(0), fragColor.xyz, k.y);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}