{
    "Shader": {
        "info": {
            "date": "1454347171",
            "description": "Monte Carlo simulation of the two-dimensional Ising Model",
            "flags": 32,
            "hasliked": 0,
            "id": "lsVGDh",
            "likes": 18,
            "name": "Ising Model",
            "published": 3,
            "tags": [
                "montecarlo",
                "magnetism",
                "anneal"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1465
        },
        "renderpass": [
            {
                "code": "// \"Ising Model\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nMonte Carlo simulation of the two-dimensional Ising Model (see Wikipedia for further\ninformation). The system consists of a grid of spins, and the colors correspond to\nspin direction (up or down). The slider controls temperature T; at low T the spins\nshould align in a ferromagnetic state, while at high T they are in a random\nparamagnetic state; somewhere in between there is a phase transition (reduce T\ngradually to avoid artifacts). (A very crude random number generator is used here\nfor convenience; for quantitative work this must be replaced by something better.)\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nint gSize;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 col;\n  vec2 uv, ut, gPos;\n  float gSizef, tVal;\n  uv = 2. * fragCoord / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  ut = abs (uv) - vec2 (1.);\n  gSize = (iResolution.y > 160.) ? 128 : 32;\n  stDat = Loadv4 (gSize * gSize);\n  tVal = stDat.y;\n  if (max (ut.x, ut.y) > 0.) {\n    col = vec3 (0.82);\n    ut = abs (uv - vec2 (1.15, 0.07 * (tVal - 4.))) / vec2 (0.08, 0.04);\n    if (length (ut) < 1. && max (ut.x, ut.y) > 0.2)\n       col = (tVal > 4.) ? vec3 (1., 0.1, 0.1) :\n       ((tVal > 2.) ? vec3 (0.1, 1., 0.1) : vec3 (0.2, 0.2, 1.));\n    else {\n      ut = abs (uv - vec2 (1.15, 0.)) - vec2 (0.02, 0.3);\n      if (max (ut.x, ut.y) < 0.) col =\n         (min (abs (ut.x), abs (ut.y)) < 0.01) ? vec3 (0.2) :\n\t ((mod (uv.y + 0.3, 0.075) < 0.01) ? vec3 (1., 0., 0.) : vec3 (0.5));\n    }\n  } else {\n    gSizef = float (gSize);\n    gPos = floor (gSizef * (0.5 * uv + 0.5));\n    col = (Loadv4 (int (gSizef * gPos.y + gPos.x)).x > 0.) ?\n       vec3 (1., 1., 0.) : vec3 (1., 0., 1.);\n  }\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// \"Ising Model\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst float pi = 3.14159;\nfloat nStep, tVal;\nint gSize;\n\nvoid Step (int sId, out vec4 p)\n{\n  const vec3 cRand = vec3 (8121., 28411., 134456.);\n  vec2 sv;\n  float f, u, sIdf, gSizef, r;\n  f = Loadv4 (sId).x;\n  r = Loadv4 (sId).y;\n  sIdf = float (sId);\n  gSizef = float (gSize);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  if (mod (nStep, 10.) <= 1. && mod (nStep, 2.) ==\n     ((mod (sv.x, 2.) == mod (sv.y, 2.)) ? 0. : 1.)) {\n    u = 2. * f * (\n        Loadv4 (int (mod (sv.x + 1., gSizef) + gSizef * sv.y)).x +\n        Loadv4 (int (mod (sv.x - 1., gSizef) + gSizef * sv.y)).x +\n        Loadv4 (int (sv.x + gSizef * mod (sv.y + 1., gSizef))).x +\n        Loadv4 (int (sv.x + gSizef * mod (sv.y - 1., gSizef))).x);\n    r = mod (cRand.x * r + cRand.y, cRand.z);\n    if (u < 0. || r < cRand.z * exp (- u / tVal)) f = - f;\n  }\n  p = vec4 (f, r, 0., 0.);\n}\n\nvoid Init (int sId, out vec4 p)\n{\n  float f, r;\n  r = Hashff (mod (17777.7 * float (sId + 10), 2. * pi));\n  f = (r > 0.5) ? 1. : -1.;\n  p = vec4 (f, r, 0., 0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p;\n  vec2 canvas, iFrag;\n  int sId, gSizeSq;\n  iFrag = floor (fragCoord);\n  sId = int (iFrag.x + txRow * iFrag.y);\n  gSize = (iResolution.y > 160.) ? 128 : 32;\n  gSizeSq = gSize * gSize;\n  if (iFrag.x >= txRow || sId > gSizeSq) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tVal = 4.;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    stDat = vec4 (nStep, tVal, 0., 0.);\n    if (sId < gSizeSq) Init (sId, p);\n  } else {\n    stDat = Loadv4 (gSizeSq);\n    nStep = stDat.x;\n    tVal = stDat.y;\n    ++ nStep;\n    if (mPtr.z > 0. && abs (mPtr.x - 0.32) < 0.04)\n       tVal = clamp (30. * (0.02 + mPtr.y) + 4., 0.03, 7.9);\n    if (sId < gSizeSq) Step (sId, p);\n  }\n  if (sId == gSizeSq) stDat = vec4 (nStep, tVal, 0., 0.);\n  Savev4 (sId, ((sId < gSizeSq) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Ising Model\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst float pi = 3.14159;\nfloat nStep, tVal;\nint gSize;\n\nvoid Step (int sId, out vec4 p)\n{\n  const vec3 cRand = vec3 (8121., 28411., 134456.);\n  vec2 sv;\n  float f, u, sIdf, gSizef, r;\n  f = Loadv4 (sId).x;\n  r = Loadv4 (sId).y;\n  sIdf = float (sId);\n  gSizef = float (gSize);\n  sv = vec2 (mod (sIdf, gSizef), floor (sIdf / gSizef));\n  if (mod (nStep, 10.) <= 1. && mod (nStep, 2.) ==\n     ((mod (sv.x, 2.) == mod (sv.y, 2.)) ? 0. : 1.)) {\n    u = 2. * f * (\n        Loadv4 (int (mod (sv.x + 1., gSizef) + gSizef * sv.y)).x +\n        Loadv4 (int (mod (sv.x - 1., gSizef) + gSizef * sv.y)).x +\n        Loadv4 (int (sv.x + gSizef * mod (sv.y + 1., gSizef))).x +\n        Loadv4 (int (sv.x + gSizef * mod (sv.y - 1., gSizef))).x);\n    r = mod (cRand.x * r + cRand.y, cRand.z);\n    if (u < 0. || r < cRand.z * exp (- u / tVal)) f = - f;\n  }\n  p = vec4 (f, r, 0., 0.);\n}\n\nvoid Init (int sId, out vec4 p)\n{\n  float f, r;\n  r = Hashff (mod (17777.7 * float (sId + 10), 2. * pi));\n  f = (r > 0.5) ? 1. : -1.;\n  p = vec4 (f, r, 0., 0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p;\n  vec2 canvas, iFrag;\n  int sId, gSizeSq;\n  iFrag = floor (fragCoord);\n  sId = int (iFrag.x + txRow * iFrag.y);\n  gSize = (iResolution.y > 160.) ? 128 : 32;\n  gSizeSq = gSize * gSize;\n  if (iFrag.x >= txRow || sId > gSizeSq) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tVal = 4.;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    stDat = vec4 (nStep, tVal, 0., 0.);\n    if (sId < gSizeSq) Init (sId, p);\n  } else {\n    stDat = Loadv4 (gSizeSq);\n    nStep = stDat.x;\n    tVal = stDat.y;\n    ++ nStep;\n    if (mPtr.z > 0. && abs (mPtr.x - 0.32) < 0.04)\n       tVal = clamp (30. * (0.02 + mPtr.y) + 4., 0.03, 7.9);\n    if (sId < gSizeSq) Step (sId, p);\n  }\n  if (sId == gSizeSq) stDat = vec4 (nStep, tVal, 0., 0.);\n  Savev4 (sId, ((sId < gSizeSq) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}