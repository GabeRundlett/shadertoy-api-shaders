{
    "Shader": {
        "info": {
            "date": "1464284863",
            "description": "Plexus-like shader. Movement of the vertices is based on the frequencies of the music.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sGXDW",
            "likes": 37,
            "name": "Plex",
            "published": 3,
            "tags": [
                "2d",
                "particles"
            ],
            "usePreview": 0,
            "username": "GonzaloQuero",
            "viewed": 2503
        },
        "renderpass": [
            {
                "code": "#define PNUM 32\n#define PRADIUS 0.005\n#define LINEWIDTH 0.003\n#define LINEFADEDISTANCE 0.1\n#define LINECOLOR vec4(0.4, 0.4, 1.0, 1.0) * 4.0\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat getFreq(int i) {\n    vec2 uv = vec2(float(i) / float(PNUM), 0.25);\n    float freq = texture(iChannel0, uv).x;\n    return mix(-0.5, 0.5, freq) * 0.6;\n}\n\nvec2 makePoint(int i)\n{\n    vec2 position = vec2(rand(vec2(i)) * 2.0, rand(vec2(i + 17)));\n  \treturn position;\n}\n\nvoid getPoints(out vec2[PNUM] p)\n{\n    for(int i = 0; i < PNUM; i++)\n    {\n        float freqx = getFreq(i);\n        float freqy = getFreq(PNUM - 1 - i);\n        p[i] = makePoint(i) + vec2(freqx, freqy);\n    }\n}\n\nfloat DistToLine(const vec2 pt1, const vec2 pt2, const vec2 testPt)\n{\n  \tvec2 lineDir = pt2 - pt1;\n  \tvec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  \tvec2 dirToPt1 = pt1 - testPt;\n    \n    float a = abs(distance(pt1, testPt));\n    float b = abs(distance(pt2, testPt));\n    float c = abs(distance(pt1, pt2));\n    \n    float agtc = sign(a - c);\n    float bgtc = sign(b - c);\n    \n    // a >= c || b >= c\n    float comp = clamp(max(agtc, bgtc), 0.0, 1.0);\n     \n  \treturn mix(abs(dot(normalize(perpDir), dirToPt1)), 1000.0, comp);\n}\n\nfloat inLine(const vec2 testPoint, const vec2 iPoint, const vec2 jPoint)\n{\n  return LINEWIDTH - DistToLine(iPoint, jPoint, testPoint);\n}\n\nfloat distanceToClosestPoint(vec2 uv, vec2[PNUM] points) {\n    float pixelDistanceToClosestPoint = 2.0;\n    \n    for(int i = 0; i < PNUM; i++)\n    {\n    \tvec2 point = points[i];\n        float dist = distance(uv, point);\n        pixelDistanceToClosestPoint = min(dist, pixelDistanceToClosestPoint);        \n    }  \n    \n    return pixelDistanceToClosestPoint;\n}\n\nvec4 drawLines(const vec2[PNUM] points, vec2 uv)\n{\n    const vec4 lineColor = LINECOLOR;\n    const vec4 baseColor = vec4(0.0);\n \tvec4 ret = vec4(0.0);\n\n    vec2 iPoint;\n    vec2 jPoint;\n    \n    for(int i = 0; i < PNUM; i++)\n    {\n        iPoint = points[i];\n        \n     \tfor(int j = 0; j < PNUM; j++)\n        {\n            jPoint = points[j];\n            float lineDist = inLine(uv, iPoint, jPoint);\n            float lineMix = lineDist / LINEWIDTH;\n\n            float fade = pow(LINEFADEDISTANCE / distance(iPoint, jPoint), 2.0);\n            vec4 possibleColor = lineColor * fade;\n            possibleColor = mix(baseColor, possibleColor, lineMix);\n            ret = max(ret, possibleColor);\n   \t\t}\n    }\n    \n    return ret;\n}\n\nvec4 getFragColor(vec2[PNUM] points, vec2 uv)\n{\n    vec4 ret = drawLines(points, uv);    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 points[PNUM];\n    getPoints(points);\n    \n    float x = fragCoord.x * (iResolution.x / iResolution.y) / iResolution.x;\n    float y = fragCoord.y / iResolution.y;\n    vec2 uv = vec2(x, y);\n    \n\tfragColor = getFragColor(points, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}