{
    "Shader": {
        "info": {
            "date": "1523978321",
            "description": "A practice of voronoi.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd3Bzn",
            "likes": 26,
            "name": "Digested",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "fbm",
                "thron"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 889
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.14159265\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.05)*18., sin(p*0.1+2.)*10.,0.);\n}\n\nvec2 hash2(vec2 p) \n{\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\n\n// From Shane: https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nconst mat3 m=mat3(0.00,  0.80,  0.60,\n                  -0.80,  0.36, -0.48,\n                  -0.60, -0.48,  0.64);\n\nfloat fbm(vec3 x)\n{\n    float f=2.0;\n    float s=0.5;\n    float a=0.0;\n    float b=0.5;\n    for(int i=0;i<4;i++)\n    {\n        float n=noise(x);\n        a+=b*n;\n        b*=s;\n        x=f*m*x;\n    }\n\treturn a;\n}\n\n\nfloat tunnel(vec3 p)\n{\n    return 3.-length(p.xy+vec2(sin((iTime+p.z)*1.8)*0.2,0.));\n}\n\n// cone and torus from iq\nfloat cone(vec3 p, vec3 c)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\n//vec4 thorn_texcoord;\nvec3 thorn_texcoord;\n\nfloat thorn(vec3 p, float noi, float base, out float dhole, out float dtorus)\n{\n    float d=10.,dh=10.,dt=10.;\n    \n    vec2 k=normalize(p.xy);\n    \n   \tvec2 n=floor(vec2(asin(k.y)*2.5,p.z));\n    vec2 f=fract(vec2(asin(k.y)*2.5,p.z));\n    \n    for(int i=-1;i<=1;++i)\n    {\n        for(int j=-1;j<=1;++j)\n        {\n            vec2 g=vec2(float(i),float(j));\n            vec2 o=hash2(n+g);\n            vec2 v=hash2(n+g+vec2(13.1,71.7));\n            vec2 r=g-f+o;\n                        \n            vec3 q=vec3(r.x,base,r.y);\n            vec3 qq=q+vec3(0.,-1.+0.6*sin(4.*(iTime+3.*v.x+5.*v.y)),0.);;\n                \n            float d0=cone(qq, vec3(1.,.1, 4.));\n        \tfloat d1=cone(q+vec3(0.,-1.3,0.), vec3(1.,.1, 3.));\n            float d2=torus(q+vec3(0.,-0.08,0.),vec2(0.25,0.07));\n            //if(d0<d)thorn_texcoord=vec4(qq,7.*v.x+17.*v.y);\n            if(d0<d)thorn_texcoord=qq;\n            \n            d=min(d,d0);\n            dh=min(d1,dh);\n            dt=min(d2,dt);\n            \n        }\n    }\n    \n    dhole=dh;\n    dtorus=dt;\n \n    d += noi*noi*0.11;\n    \n    return d;\n}\n\nfloat infi_box(vec3 p, vec2 b)\n{\n    vec2 d = abs(p.xy) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nint mateid=0;\n\nfloat map(vec3 p)\n{    \n    p-=path(p.z);\n    \n    mateid=0;\n    \n    // displacement is too expensive\n    //float noi=fbm(p*3.0);\n    //float d0=tunnel(p)+(.5-noi)*.2;\n    float d0=tunnel(p);\n    float dh,dt;\n    //float d1=thorn(p, noi, dh);\n    float d1=thorn(p, 0., d0, dh, dt);\n    \n    d0=smax(d0,-dh+0.05,.2);\n    d0=smin(dt,d0,.3);\n    \n    \n    if(d1<d0)\n    {\n        d0=d1;\n        mateid=1;\n    }\n    \n    return d0;\n}\n\nvec3 get_normal(in vec3 p) \n{\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat intersect2(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n    for(int i=0;i<96;++i)\n    {\n        if(abs(d)<0.002*(1.+t)||t>50.)\n            continue;\n        t+=step(d,1.)*d*0.2+d*0.5;\n        d=map(ro+t*rd);\n    }\n    if(t>50.)t=-1.;\n    return t;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float dist)\n{\n    float res=1.0;\n    float t=0.05;\n    float h;\n    \n    for(int i=0;i<10;i++)\n    {\n        if(t>dist-0.2)continue;\n        h=map(ro+rd*t);\n        res = min(6.0*h/t, res);\n        t+=h;\n    }\n    return max(res, 0.0);\n}     \n\n// density from aiekick: https://www.shadertoy.com/view/lljyWm\nfloat density(vec3 p, float ms) \n{\n\tvec3 n = get_normal(p); \n\treturn map(p-n*ms)/ms;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.5,0.,-iTime*.6);\n    vec3 ta=ro+vec3(0,0,-1.);\n    \n    vec3 lp0=ro+vec3(0,0.,-3.);\n    \n    ro+=path(ro.z);\n    ta+=path(ta.z);\n\tlp0+=path(lp0.z);\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.xy,PI/2.));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=intersect2(ro,rd);\n    \n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        if(mateid==0)\n        \tn=bump_mapping(pos*0.05, n, 0.08);\n        else \n        \tn=mix(n,bump_mapping(thorn_texcoord.xyz, n, 0.03),\n                  1.-smoothstep(-1.5,-0.5,thorn_texcoord.y));\n            \n\t\tvec3 ld0=lp0-pos;\n        float ldist=length(ld0);\n        ld0/=ldist;        \n        vec3 lc0=vec3(1.1,0.8,.7);\n        \n        float sha=shadow(pos+0.1*n,ld0,ldist);\n        float dif=max(0.,dot(ld0,n));\n        float bac=max(0.,dot(-ld0,n));\n        float amb=max(0.,dot(n,vec3(0,1,0)));\n        float spe=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 128.0));\n        float fre=clamp(1.0+dot(rd,n), .0, 1.); \n        float sca=1.-density(pos,.5);\n\n        vec3 Lo=4.*dif*lc0*sha;\n        Lo+=.5*bac*lc0;\n        Lo+=2.*spe*vec3(1.);\n        Lo+=1.5*pow(fre,8.)*vec3(.6,0.1,0.1);\n        Lo/=ldist;\n\t\t\n        map(pos);\n        \n        float tex=fbm(pos*3.5);\n        \n        vec3 mate=.5*vec3(1.5,0.2,0.)+tex*tex*3.2;\n      \n        if(mateid==1)\n        {\n            // I tried to record and add some randomness here, \n            // but it will crash on my windows nvidia desktop.\n            // it's 1:12 am now, I'm giving up.\n            //float tt=fbm(thorn_texcoord.xyz*15.+thorn_texcoord.w);\n            float tt=fbm(thorn_texcoord*15.);\n            tt=pow(smoothstep(0.1,0.5,tt), 5.);\n            mate=mix(vec3(3.),vec3(3.)-vec3(0.5,1.4*tt,3.*tt),\n                     1.-smoothstep(-1.5,-0.5,thorn_texcoord.y));\n            Lo+=vec3(.4)*(1.-sca)*(1.-sca);\n        }\n        \n        if(mateid==0)\n        {\n            Lo+=5.*spe*vec3(1.,.6,.2)/ldist*sha;\n            Lo+=.3*vec3(0.3,0.07,0.1)*sca*sca*sca;\n        }\n        Lo+=0.2*amb;\n        col=Lo*mate*0.2;        \n    }\n    col=mix(col,vec3(0), 1.0-exp(-0.015*t*t) );\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=pow(col,vec3(0.9,1.,0.95));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}