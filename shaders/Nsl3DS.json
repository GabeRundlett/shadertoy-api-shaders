{
    "Shader": {
        "info": {
            "date": "1616556178",
            "description": "A set of spheres, based on the amazing _Ray Tracing in One Weekend_. See https://raytracing.github.io/books/RayTracingInOneWeekend.html. \nClick and drag to rotate the camera.",
            "flags": 8,
            "hasliked": 0,
            "id": "Nsl3DS",
            "likes": 1,
            "name": " Spheres",
            "published": 3,
            "tags": [
                "raytracer",
                "spheres"
            ],
            "usePreview": 0,
            "username": "personalizedrefrigerator",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "// Ref: https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nconst vec3 ORIGIN = vec3(0.0, 0.0, 0.0);\nconst float MAX_DIST = 999999999.0;\n\n// General options\n#define COLORFUL_BACKGROUND\n#define AUTO_MOVING_CAMERA\n\n// Anti-aliasing (bigger numbers => higher quality, but slower)\nconst int NUM_SAMPLES = 10;\n\n// Ray bouncing\nconst int MAX_RAY_DEPTH = 5;\n\n#define SCENE_NUM_SPHERES 9\nstruct Scene\n{\n    Sphere spheres[SCENE_NUM_SPHERES];\n};\n\nDEF_SCENE_HIT(Scene)\n    DEF_SCENE_OBJ(spheres, SCENE_NUM_SPHERES)\nEND_DEF_SCENE_HIT(Scene)\n\n// Get the vec3(red, green, blue) color associated with\n// the given ray (casts a ray into the scene).\nvec3 ray_color(Ray r, const in Scene scene)\n{\n    color3 colorMask = vec3(1.0, 1.0, 1.0);\n        \n    color3 colorShift;\n    Ray scattered;\n    \n    for (int depth = 0; depth < MAX_RAY_DEPTH; depth++)\n    {\n        vec3 unit_direction = normalize(r.v);\n        HitRecord h = hit(scene, r, 0.0001, MAX_DIST);\n\n        if (!h.valid)\n        {\n#ifdef COLORFUL_BACKGROUND\n            float a = 0.5 * (unit_direction.y + 1.0) * 33.0 + 4.0 * sin(iTime / 8.0);\n            float b = 0.5 * (unit_direction.x + 1.0) * 33.0;\n            \n            color3 background = cos(2.0 * PI * vec3(tan(a / b), a - b, a * b));\n            background = clamp(background, vec3(0.0), vec3(1.0));\n#else\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color3 background = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);\n#endif\n            \n            return colorMask * background;\n        }\n        \n        if (!scatter(r, h, colorShift, scattered))\n        {\n            return colorMask * colorShift;\n        }\n        \n        r = scattered;\n        colorMask *= colorShift;\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nScene generateScene()\n{\n    float t = iTime;\n    float orangeRadius = 2.0 * tan(t / 4.0);\n    \n    Scene scene = Scene\n    (Sphere[](\n        Sphere(vec3(0.6 * cos(t), 0.0, 0.6 * sin(t) - 1.0), 0.05, DEFAULT_MATERIAL_METAL),\n        Sphere(vec3(0.67 * cos(2.0*t), 0.2 * sin(t), 0.5 * sin(2.0*t) - 1.0), 0.03, DEFAULT_MATERIAL),\n        Sphere(vec3(0.0, 0.0, -1.0), 0.5, DEFAULT_MATERIAL_METAL),\n        Sphere(vec3(0.9, -0.2, -1.0), 0.3, DEFAULT_MATERIAL_GLASS),\n        Sphere(vec3(-0.9, -0.2, 1.0), 0.3, Material(vec3(0.9, 0.2, 0.0), 1.1, MATERIAL_GLASS)),\n        Sphere(vec3(-0.9, -0.1, 2.0), 0.4, Material(vec3(0.9, 0.2, 0.0), 0.2, MATERIAL_METAL)),\n        Sphere(vec3(0.0, -500.5, -1.0), 500.0, DEFAULT_MATERIAL_MATTE),\n        Sphere(vec3(0.0, 0.0, -10.0), 5.0, Material(vec3(0.3, 0.9, 0.5), 0.6, MATERIAL_METAL)),\n        Sphere(vec3(4.0 * sin(t), -2.0 * orangeRadius - abs(sin(t)), -6.0), orangeRadius, \n                Material(vec3(0.9, 0.3, 0.1), 0.6, MATERIAL_MATTE))\n    ));\n    \n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    srand(9.0 + fragCoord.y / iResolution.y \n        + fragCoord.x / iResolution.x + fragCoord.x / fragCoord.y);\n    \n    Scene scene = generateScene();\n    float mouseX = iMouse.x / iResolution.x - 0.5;\n    float mouseY = iMouse.y / iResolution.y - 0.5;\n    \n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n    {\n        mouseX = 0.0;\n        mouseY = 0.0;\n    }\n    \n#ifdef AUTO_MOVING_CAMERA\n    vec3 camPos = vec3(sin(iTime / 4.0), 0.0, cos(iTime / 4.0)) * tan(iTime / 12.0) * 2.0;\n#else\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n#endif\n\n    mat3 camMat = yRotMatrix33(mouseX * 2.0 * PI) * xRotMatrix33(-mouseY * PI);\n    \n    vec3 col     = vec3(0.0, 0.0, 0.0);\n    vec3 lastCol = col;\n    vec2 lastOffset = vec2(0.0);\n    \n    for (int i = 0; i < NUM_SAMPLES; i++)\n    {\n        vec2 xy = fragCoord + vec2(rand(), rand());\n    \n        // Normalized pixel coordinates (from -1 to 1)\n        vec2 uv = (2.0 * xy/iResolution.xy - vec2(1.0, 1.0)) * iResolution.xy / iResolution.y;\n\n        Ray ray = Ray(camMat * vec3(uv, -1.0), ORIGIN + camPos);\n        ray.v = normalize(ray.v);\n        \n        vec3 currentCol = ray_color(ray, scene);\n        col += currentCol;\n    }\n    \n    col /= float(NUM_SAMPLES);\n    \n    // Gamma correction. (Gamma=2.0, so raise the color\n    // to the 1/2 power.)\n    col = clamp(sqrt(col), vec3(0.0), vec3(0.999));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// A set of utilities.\n// Based on the tutorial \n// “Ray Tracing in One Weekend.” raytracing.github.io/books/RayTracingInOneWeekend.html\n// (accessed Mar. 23, 2021)\n\n///////////// Type aliases\n#define point3 vec3\n#define color3 vec3\n\n///////////// Constants\nconst float PI = 3.14159265358979323826;\n\n///////////// Struct definitions (methods further below)\n\nstruct Ray\n{\n    vec3 v; // direction (**v**ector)\n    vec3 origin; // origin\n};\n\nstruct Material\n{\n    color3 color;\n    float  param;\n    int    typeId;\n};\n\nstruct HitRecord\n{\n    bool valid;\n    vec3 p; // hit point\n    vec3 norm;\n    Material  material;\n    float t;\n};\n\nstruct Sphere\n{\n    vec3 center; // center\n    float r; // radius\n    Material material;\n};\n\n///////////// Numeric utilities\n\n// Returns a pseudo-random number in [0, 1)\n// See also https://www.shadertoy.com/view/3slSzn\nfloat _rand_seed = 0.0;\nfloat rand()\n{\n    _rand_seed++;\n    \n    return fract(sin(_rand_seed) * 5985.32576);\n}\n\nfloat rand(float min, float max)\n{\n    return min + (max - min) * rand();\n}\n\nvec3 rand_vec3(float comp_min, float comp_max)\n{\n    return vec3(rand(comp_min, comp_max), rand(comp_min, comp_max), rand(comp_min, comp_max));\n}\n\nvoid srand(float seed)\n{\n    _rand_seed = abs(seed);\n}\n\n///////////// Transformation utilities\n\n    \n// See https://en.wikipedia.org/wiki/Rotation_matrix\nmat3 yRotMatrix33(float ry)\n{\n    float cos_part = cos(ry);\n    float sin_part = sin(ry);\n    \n    return mat3(\n        cos_part, 0.0, sin_part,\n        0.0,      1.0, 0.0,\n        -sin_part, 0.0, cos_part\n    );\n}\n\nmat3 zRotMatrix33(float rz)\n{\n    float cos_part = cos(rz);\n    float sin_part = sin(rz);\n    \n    return mat3(\n        cos_part, -sin_part, 0.0,\n        sin_part, cos_part,  0.0,\n        0.0,      0.0,       1.0\n    );\n}\n\nmat3 xRotMatrix33(float rx)\n{\n    float cos_part = cos(rx);\n    float sin_part = sin(rx);\n    \n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos_part, -sin_part,\n        0.0, sin_part, cos_part\n    );\n}\n\n///////////// RAY\n\nvec3 at(const in Ray r, float t)\n{\n    return r.v * t + r.origin;\n}\n\n////////////// MATERIALS\nconst int MATERIAL_MATTE = 0;\nconst int MATERIAL_METAL = 1;\nconst int MATERIAL_GLASS = 2;\n\n\nconst Material DEFAULT_MATERIAL_MATTE = \n    Material(vec3(0.5, 0.5, 0.6), 0.3, MATERIAL_MATTE);\n\nconst Material DEFAULT_MATERIAL_METAL = \n    Material(vec3(0.5, 0.5, 0.5), 0.0, MATERIAL_METAL);\n    \nconst Material DEFAULT_MATERIAL_GLASS = \n    Material(vec3(0.8), 1.3, MATERIAL_GLASS);\n\nconst Material DEFAULT_MATERIAL = DEFAULT_MATERIAL_MATTE;\n\n// Reflects [vecIn] with respect to [normal]. Assumes vecIn has unit length.\nvec3 _reflected(vec3 vecIn, vec3 normal)\n{\n    // Say we have,\n    //  \\   N   /  ^     Where N is the normal,\n    // v \\ θ^  /   |     v is the incident ray\n    //    \\ | / r  | B   and r is the reflected ray.\n    //     \\|/     |\n    //--------------- \n    //       \\     ^\n    //        \\ v  |\n    //         \\   | B\n    //          \\  |\n    //\n    // Notice that v + 2 B = r.\n    // B = proj_N ( v ) = N sin(π/2 - θ) = N cos(θ)\n    //                  = N (unit(v)·N)\n    // As such,\n    vec3 reflected = vecIn - 2.0 * normal * dot(normal, vecIn);\n    return reflected;\n}\n\n// Gets an approximation of reflectance for a surface with\n// ratio of indicies of refraction [refractionRatio].\n// TODO: _Ray Tracing in One Weekend_ states that this is \n//       the Schlick approximation. I don't understand what\n//       this is approximating. Research this.\nfloat _reflectance(float cos_angle, float refractionRatio)\n{\n    float r0 = (1.0 - refractionRatio) / (1.0 + refractionRatio);\n    r0 *= r0;\n    \n    return r0 + (1.0 - r0) * pow(1.0 - cos_angle, 5.0);\n}\n\n// Scatter a ray based on a collision record (takes\n// material into account).\n// Returns:\n// {\n//   true  => scattered\n//   false => absorbed\n// }\nbool scatter(const in Ray rayIn, const in HitRecord hit, \n        out color3 colorShift, out Ray scattered)\n{\n    colorShift = hit.material.color;\n    int materialId = hit.material.typeId;\n    \n    // This seems to not work with switch/case statements in Safari.\n    // Use if statements.\n    \n    if (materialId == MATERIAL_MATTE)\n    {\n        // Matte: Scatter in a random direction with respect\n        //        to the normal.\n        vec3 rand_dir = \n            normalize(rand_vec3(-hit.material.param, 1.0));\n        vec3 rand_vec = rand_dir * rand();\n        scattered.v = hit.p + hit.norm + rand_vec;\n        scattered.origin = hit.p;\n\n        // Matte: Always scatter.\n        return true;\n    }\n    else if (materialId == MATERIAL_METAL)\n    {\n        vec3 rayIn_dir = normalize(rayIn.v);\n        \n        vec3 reflected = _reflected(rayIn_dir, hit.norm);\n        scattered.v = reflected;\n\n        if (hit.material.param > 1e-8) \n        {\n            vec3 random_unit_vec = normalize(rand_vec3(-1.0, 1.0));\n            scattered.v += hit.material.param * random_unit_vec;\n        }\n\n        scattered.origin = hit.p;\n\n        // Absorb if the scattered ray opposes the normal\n        //  (closer to anti-parallel than parallel).\n        return dot(reflected, hit.norm) >= 0.0;\n    }\n    else if (materialId == MATERIAL_GLASS)\n    {\n        vec3 rayIn_dir = normalize(rayIn.v);\n    \n        // For simplicity, assume we're always handling\n        // air and this' material, not some other substance.\n        float refractionRatio = hit.material.param;\n        \n        if (dot(rayIn_dir, hit.norm) <= 0.0)\n        {\n            refractionRatio = 1.0 / refractionRatio;\n        }\n        \n        vec3 in_perp = rayIn_dir - hit.norm;\n        vec3 out_perp = in_perp * refractionRatio;\n        \n        scattered.origin = hit.p;\n        scattered.v = out_perp - hit.norm;\n        \n        float cos_angle = dot(-rayIn_dir, hit.norm);\n        float sin_angle = sqrt(1.0 - pow(cos_angle, 2.0));\n        float sin_otherAngle = refractionRatio * sin_angle;\n        \n        // Impossible sine of other angle?\n        // We need to reflect.\n        if (sin_otherAngle > 1.0 || _reflectance(cos_angle, refractionRatio) > rand())\n        {\n            vec3 reflected = _reflected(rayIn_dir, hit.norm);\n            scattered.v = reflected;\n        \n            return dot(reflected, hit.norm) >= 0.0;\n        }\n        \n        return true;\n    }\n    \n    // Unknown: Absorb.\n    return false;\n}\n\n////////////// HIT-ABLES\n\nHitRecord hit(const in Sphere s, const in Ray r, float t_min, float t_max)\n{\n    HitRecord result;\n    \n    // Compute ray-sphere intersection.\n    //   Say r(t) = At + B and the sphere has center C and radius s.\n    //   We then have (r(t) - C)·(r(t) - C) = s².\n    //   Expanding, \n    //          (At + B - C)·(At + B - C) = s²\n    //           A·A t² + 2 A·(B - C) t + (B - C)·(B - C) = s²\n    //   which can be solved with the quadratic formula.\n    vec3 BC = r.origin - s.center;\n    \n    // Finding (a, b, c) for (-b ± sqrt(b² - 4ac)) / 2 / a\n    //  or equivalently\n    //         (a, b/2, c) for (-b/2 ± sqrt((b/2)² - ac)) / a\n    float a = dot(r.v, r.v);\n    float half_b = dot(r.v, BC);\n    float c = dot(BC, BC) - s.r * s.r;\n    \n    // The descriminant tells us whether we have a solution\n    float desc = half_b * half_b - a * c;\n    \n    // We're not taking square roots of negative numbers,\n    result.valid = (desc >= 0.0);\n    \n    if (!result.valid)\n    {\n        // So just return an arbitrary result that we've marked as\n        // invalid.\n        return result;\n    }\n    \n    // Substitute into the quadratic formula for t such that\n    //    r(t) is a point on the sphere.\n    result.t    = ( -half_b - sqrt(desc) ) / a;\n    \n    if (result.t < t_min || result.t > t_max)\n    {\n        // Try again with the other root.\n        result.t = ( -half_b + sqrt(desc) ) / a;\n    \n        if (result.t < t_min || result.t > t_max)\n        {\n            result.valid = false;\n            return result;\n        }\n    }\n    \n    vec3 hit_pos = at(r, result.t);\n    \n    // Finally, the normal is from the center of the sphere to\n    // the collision point.\n    // This gives us the outward normal.\n    result.norm = normalize(hit_pos - s.center);\n    \n    result.p = hit_pos;\n    result.material = s.material;\n    \n    // Make sure the normal is pointing outwards relative to the\n    // face the ray intersected with.\n    bool front_face = dot(r.v, result.norm) < 0.0;\n    \n    if (!front_face)\n    {\n        result.norm = -result.norm;\n    }\n    \n    return result;\n}\n\n// Scene tables\n\n#define DEF_SCENE_HIT(SceneTypename) \\\nHitRecord hit(SceneTypename s, Ray r, float t_min, float t_max) \\\n{\\\n    HitRecord result;\\\n    result.valid = false;\\\n    result.t = t_max;\\\n    \\\n    float closestSoFar = t_max;\\\n\n\n#define DEF_SCENE_OBJ(fieldName, objCount) \\\n    for (int i = 0; i < objCount; i++) \\\n    { \\\n        HitRecord rec = hit(s.\\\n        fieldName\\\n        [i], r, t_min, result.t);\\\n        if (rec.valid)\\\n        { \\\n            result = rec; \\\n        } \\\n    } \\\n\n\n#define END_DEF_SCENE_HIT(SceneTypename) \\\n    return result; \\\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "struct Note\n{\n    float duration;\n    float pitch;\n    float volume;\n};\n\n// Beats per minute.\nconst float BPM = 240.0;\nconst int NUM_NOTES = 12;\n\nfloat[] MINOR_SCALE = float[](\n    0.0, 2.0, 3.0, 5.0, 7.0, 8.0, 10.0, 12.0, 14.0, 15.0, 17.0, 18.0, 24.0\n);\n\nvoid getCurrentBeat(float time, float bpm, out float noteStartTime, out int beat)\n{\n    beat          = int(floor(time / 60.0 * bpm));\n    noteStartTime = float(beat) * 60.0 / bpm;\n}\n\nfloat playNote(const in Note note, float absTime, float relTime)\n{\n    float frequency = 110.0 * pow(2.0, note.pitch / 12.0);\n    return note.volume * round(sin(frequency * 2.0 * PI * absTime + 6.0 * sin(relTime * 2.0 * PI))) * exp(-relTime / note.duration + 0.1);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    int beat;\n    float noteStartTime;\n    getCurrentBeat(time, BPM, noteStartTime, beat);\n    \n    beat %= 300;\n    float result = 0.0;\n    \n    for (int i = 0; i < NUM_NOTES; i++)\n    {\n        int noteIdx = ((i - 1) ^ beat) - ((i + 1) ^ beat) + beat;\n        float pitchShift = 0.0;\n        float volume = 1.0;\n        \n        if (i >= 5)\n        {\n            float beatf = float(beat);\n            noteIdx = int(sin(tan(beatf) - beatf)\n                       * float(MINOR_SCALE.length()));\n            \n            pitchShift = -float(i ^ beat) / float(NUM_NOTES) / 4.0;\n            volume *= sin(float(i) - beatf) + 1.0;\n        }\n        \n        noteIdx = abs(noteIdx);\n        noteIdx %= MINOR_SCALE.length();\n        \n        float pitch = MINOR_SCALE[noteIdx] + pitchShift;\n        Note note = Note(0.3, pitch, volume);\n        result += playNote(note, time, time - noteStartTime);\n    }\n    \n    result /= float(NUM_NOTES);\n    \n    return vec2( result );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}