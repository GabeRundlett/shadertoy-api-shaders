{
    "Shader": {
        "info": {
            "date": "1693900332",
            "description": "Following @demofox's third tutorial. Drag with the mouse to rotate the camera.",
            "flags": 32,
            "hasliked": 0,
            "id": "dtjfz1",
            "likes": 19,
            "name": "My Third Pathtraced Scene",
            "published": 3,
            "tags": [
                "globalillumination",
                "pathtracer",
                "stochastic"
            ],
            "usePreview": 1,
            "username": "oneshade",
            "viewed": 378
        },
        "renderpass": [
            {
                "code": "// Based on https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// and https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy\n// and https://blog.demofox.org/2020/06/14/casual-shadertoy-path-tracing-3-fresnel-rough-refraction-absorption-orbit-camera/\n// And yes, I am sticking with my uncreative naming scheme :)\n\n// https://64.github.io/tonemapping/#uncharted-2\nvec3 Uncharted2(in vec3 color) {\n    color *= 2.0;\n\n    float A = 0.15, B = 0.50, C = 0.10;\n    float D = 0.20, E = 0.02, F = 0.30;\n    color = (((A * color + C * B) * color + D * E) / ((A * color + B) * color + D * F)) - E / F;\n\n    float whiteMax = 4.0;\n    color /= (((A * whiteMax + C * B) * whiteMax + D * E) / ((A * whiteMax + B) * whiteMax + D * F)) - E / F;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(Uncharted2(fragColor.rgb), vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Settings\n#define MAX_BOUNCES 16\n#define CAMERA_POSITION vec3(0.0, 2.0, 0.25)\n#define LENS_DISTANCE 1.0\n#define APERTURE_RADIUS 0.04\n#define FOCUS_DISTANCE 3.0\n\n// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n#define EPSILON 0.001\n\n// Structs\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    bool fromInside;\n    float hitDist;\n    vec3 hitPos;\n    vec3 surfNor;\n    vec2 surfUv;\n    int objId;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n    vec3 absorption;\n    vec3 emission;\n    float specularAmount;\n    float specularRoughness;\n    float refractionAmount;\n    float refractionRoughness;\n    float refractiveIndex;\n};\n\n// Defaults\nHitInfo noHit() {\n    HitInfo hit;\n    hit.fromInside = false;\n    hit.hitDist = -1.0;\n    hit.hitPos = vec3(0.0);\n    hit.surfNor = vec3(0.0);\n    hit.surfUv = vec2(0.0);\n    hit.objId = -1;\n    return hit;\n}\n\nMaterial baseMaterial() {\n    Material mtl;\n    mtl.albedo = vec3(0.0);\n    mtl.specular = vec3(0.0);\n    mtl.absorption = vec3(0.0);\n    mtl.emission = vec3(0.0);\n    mtl.specularAmount = 0.0;\n    mtl.specularRoughness = 0.0;\n    mtl.refractionAmount = 0.0;\n    mtl.refractionRoughness = 0.0;\n    mtl.refractiveIndex = 1.0;\n    return mtl;\n}\n\n// Schlick aproximation\nfloat getFresnel(in float n1, in float n2, in vec3 normal, in vec3 incident, in float f0, in float f90) {\n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2) {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosX * cosX);\n        if (sinT2 > 1.0) return f90; // Total internal reflection\n        cosX = sqrt(1.0 - sinT2);\n    }\n\n    float x = 1.0 - cosX;\n    float x2 = x * x;\n    return mix(f0, f90, mix(r0, 1.0, x2 * x2 * x));\n}\n\n// RNG utilities\nuint wangHash(inout uint seed) {\n    seed = (seed ^ 61u) ^ (seed >> 16u);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4);\n    seed *= 668265261u;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand01(inout uint state) {\n    return float(wangHash(state)) / 4294967296.0;\n}\n\nvec2 randInUnitDisc(inout uint state) {\n    float a = rand01(state) * TAU;\n    return vec2(cos(a), sin(a)) * sqrt(rand01(state));\n}\n\nvec3 randUnitVec(inout uint state) {\n    float z = rand01(state) * 2.0 - 1.0;\n    float a = rand01(state) * TAU;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Camera basis matrix\nmat3 getCameraBasis(in vec2 an) {\n    mat3 matrix;\n    vec2 c = cos(an), s = sin(an);\n    matrix[0] = vec3(c.x, 0.0, s.x);\n    matrix[1] = vec3(s.x * -s.y, c.y, c.x * s.y);\n    matrix[2] = vec3(s.x * c.y, s.y, -c.x * c.y);\n    return matrix;\n}\n\n// Replaces the current hit with a new one if it is closer\nvoid addRayHit(inout HitInfo curHit, in HitInfo newHit, in int objId) {\n    if (newHit.hitDist > 0.0 && (curHit.hitDist < 0.0 || newHit.hitDist < curHit.hitDist)) {\n        curHit = newHit;\n        curHit.objId = objId;\n    }\n}\n\n// Transformations\nmat4 Translate(in vec3 t) {\n    mat4 matrix = mat4(1.0);\n    matrix[3].xyz = t;\n    return matrix;\n}\n\nmat4 Scale(in vec3 s) {\n    mat4 matrix = mat4(1.0);\n    matrix[0][0] = s.x;\n    matrix[1][1] = s.y;\n    matrix[2][2] = s.z;\n    return matrix;\n}\n\nmat4 Rotate(in float a, in int i, in int j) {\n    mat4 matrix = mat4(1.0);\n    float co = cos(a), si = sin(a);\n    matrix[i][i] = co;\n    matrix[i][j] = si;\n    matrix[j][i] = -si;\n    matrix[j][j] = co;\n    return matrix;\n}\n\n// Primitive intersectors\n// Ray vs. Plane intersection\nHitInfo planeIsect(in Ray ray, in mat4 mat) {\n    HitInfo hit = noHit();\n    mat4 matInv = inverse(mat);\n    ray.orig = (matInv * vec4(ray.orig, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    hit.hitDist = -ray.orig.y / ray.dir.y;\n    hit.hitPos = ray.orig + ray.dir * hit.hitDist;\n    hit.fromInside = ray.orig.y < 0.0;\n    hit.surfNor = transpose(matInv)[1].xyz * sign(ray.orig.y);\n    hit.surfUv = hit.hitPos.xz;\n    hit.hitPos = (mat * vec4(hit.hitPos, 1.0)).xyz;\n\n    return hit;\n}\n\n// Ray vs. Sphere intersection\nHitInfo sphereIsect(in Ray ray, in mat4 mat) {\n    HitInfo hit = noHit();\n    mat4 matInv = inverse(mat);\n    ray.orig = (matInv * vec4(ray.orig, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.orig, ray.dir);\n    float c = dot(ray.orig, ray.orig) - 1.0;\n\n    float dis = b * b - a * c;\n    if (dis < 0.0) return hit;\n\n    hit.hitDist = (-b - sign(c) * sqrt(dis)) / a;\n    hit.hitPos = ray.orig + ray.dir * hit.hitDist;\n    hit.fromInside = c < 0.0;\n    hit.surfNor = (transpose(matInv) * vec4(hit.hitPos, 0.0)).xyz * sign(c);\n    hit.surfUv = vec2(atan(hit.hitPos.z, hit.hitPos.x), atan(hit.hitPos.y, length(hit.hitPos.xz)));\n    hit.hitPos = (mat * vec4(hit.hitPos, 1.0)).xyz;\n\n    return hit;\n}\n\n// Not so primitive intersectors\n// Ray vs. Bilinear Patch intersection\nfloat cross2D(in vec2 a, in vec2 b) { return a.x * b.y - a.y * b.x; }\nHitInfo patchIsect(in Ray ray, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in bool solid) {\n    HitInfo hit = noHit();\n    vec2 m = ray.dir.yz / ray.dir.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 ip = p.yz - p.x * m, iq = q.yz - q.x * m, ir = r.yz - r.x * m;\n    vec2 ia = (a.yz - ray.orig.yz) - (a.x - ray.orig.x) * m;\n\n    // Reversed coefficients (solving for 1/x seems most stable)\n    float qa = cross2D(iq, ia);\n    float qb = cross2D(ip, ia) + cross2D(iq, ir);\n    float qc = cross2D(ip, ir);\n\n    float dis = qb * qb - 4.0 * qa * qc;\n    if (dis > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(dis) - qb);\n        vec2 u = -(ia.x + ir.x * v) / (ip.x * v + iq.x);\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ray.orig.x) / ray.dir.x;\n\n        // Check the validity of both intersections\n        bvec2 valid = bvec2(\n            t.x > 0.0 && u.x >= 0.0 && u.x <= 1.0 && v.x >= 0.0 && v.x <= 1.0,\n            t.y > 0.0 && u.y >= 0.0 && u.y <= 1.0 && v.y >= 0.0 && v.y <= 1.0\n        );\n\n        // Choose closest intersection in the patch\n        if (valid.y && (!valid.x || t.y < t.x)) {\n            u = u.yx;\n            v = v.yx;\n            t = t.yx;\n            valid = valid.yx;\n        }\n\n        if (valid.x) {\n            hit.hitDist = t.x;\n            hit.hitPos = ray.orig + ray.dir * t.x;\n            hit.surfNor = cross(p * u.x + r, p * v.x + q);\n            float viewAngle = dot(hit.surfNor, -ray.dir);\n            hit.fromInside = solid && viewAngle < 0.0;\n            hit.surfNor *= sign(viewAngle);\n            hit.surfUv = vec2(u.x, v.x);\n        }\n    }\n\n    return hit;\n}\n\nHitInfo traceRay(in Ray ray) {\n    HitInfo hit = noHit();\n\n    addRayHit(hit, planeIsect(ray, mat4(1.0)), 1);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.7, -3.0)) * Scale(vec3(0.4))), 2);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.5, 1.5, -5.0)) * Scale(vec3(0.75))), 3);\n\n    mat4 jellyMat = Translate(vec3(0.0, 1.5, -4.5)) * Rotate(-0.25, 2, 1) * Scale(vec3(0.75));\n    mat4 topTwist = Rotate(-1.5, 0, 2);\n    mat4 bottomTwist = Rotate(0.0, 0, 2);\n    float wiggle = 0.5;\n    vec3 v0 = (jellyMat * bottomTwist * vec4(-1.0, -1.0 + wiggle, -1.0, 1.0)).xyz;\n    vec3 v1 = (jellyMat * bottomTwist * vec4(-1.0, -1.0 - wiggle,  1.0, 1.0)).xyz;\n    vec3 v2 = (jellyMat *    topTwist * vec4(-1.0,  1.0 - wiggle, -1.0, 1.0)).xyz;\n    vec3 v3 = (jellyMat *    topTwist * vec4(-1.0,  1.0 + wiggle,  1.0, 1.0)).xyz;\n    vec3 v4 = (jellyMat * bottomTwist * vec4( 1.0, -1.0 - wiggle, -1.0, 1.0)).xyz;\n    vec3 v5 = (jellyMat * bottomTwist * vec4( 1.0, -1.0 + wiggle,  1.0, 1.0)).xyz;\n    vec3 v6 = (jellyMat *    topTwist * vec4( 1.0,  1.0 + wiggle, -1.0, 1.0)).xyz;\n    vec3 v7 = (jellyMat *    topTwist * vec4( 1.0,  1.0 - wiggle,  1.0, 1.0)).xyz;\n    addRayHit(hit, patchIsect(ray, v7, v5, v4, v6, true), 4);\n    addRayHit(hit, patchIsect(ray, v2, v0, v1, v3, true), 4);\n    addRayHit(hit, patchIsect(ray, v2, v3, v7, v6, true), 4);\n    addRayHit(hit, patchIsect(ray, v1, v0, v4, v5, true), 4);\n    addRayHit(hit, patchIsect(ray, v6, v4, v0, v2, true), 4);\n    addRayHit(hit, patchIsect(ray, v3, v1, v5, v7, true), 4);\n\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.3, 1.5, -3.0)) * Scale(vec3(0.75))), 5);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 1.5, -2.0)) * Scale(vec3(0.75))), 6);\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.0, 1.2, -1.0)) * Scale(vec3(0.25))), 7);\n\n    return hit;\n}\n\nMaterial getMaterial(in vec2 surfUv, in int objId) {\n    Material mtl = baseMaterial();\n\n    if (objId == 1) {\n        mtl.albedo = vec3(mod(floor(surfUv.x) + floor(surfUv.y), 2.0));\n        mtl.specular = vec3(1.0, 0.4, 0.2);\n        mtl.specularAmount = 0.5;\n        mtl.specularRoughness = 0.7;\n    }\n\n    if (objId == 2) {\n        mtl.absorption = vec3(0.0, 0.0, 2.0);\n        mtl.specular = vec3(1.0);\n        mtl.specularAmount = 0.1;\n        mtl.specularRoughness = 0.3;\n        mtl.refractionAmount = 0.9;\n        mtl.refractionRoughness = 0.5;\n        mtl.refractiveIndex = 1.5;\n    }\n\n    if (objId == 3) {\n        mtl.specular = vec3(1.0);\n        mtl.absorption = vec3(1.0, 0.5, 0.0);\n        mtl.specularAmount = 0.1;\n        mtl.refractionAmount = 0.9;\n        mtl.refractiveIndex = 1.5;\n    }\n\n    if (objId == 4) {\n        surfUv *= 8.0;\n        mtl.albedo = vec3(mod(floor(surfUv.x) + floor(surfUv.y), 2.0));\n    }\n\n    if (objId == 5) {\n        mtl.albedo = vec3(0.9, 0.25, 0.25);\n        mtl.specular = vec3(0.8);\n        mtl.specularAmount = 0.02;\n    }\n\n    if (objId == 6) {\n        mtl.albedo = vec3(0.9, 0.25, 0.25);\n        mtl.specular = vec3(0.8);\n        mtl.absorption = vec3(0.0, 1.5, 3.0);\n        mtl.specularAmount = 0.02;\n        mtl.refractionAmount = 0.98;\n        mtl.refractiveIndex = 1.5;\n    }\n\n    if (objId == 7) {\n        mtl.albedo = vec3(0.0, 1.0, 0.0);\n        mtl.specular = vec3(0.0, 1.0, 0.0);\n        mtl.specularAmount = 1.0;\n        mtl.specularRoughness = 0.5;\n    }\n\n    return mtl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate a seed value\n    uint rngState = (uint(fragCoord.x) * 1973u + uint(fragCoord.y) * 9277u + uint(iFrame) * 26699u) | 1u;\n\n    // Read the current average sample\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Reset on mouse down\n    if (iMouse.z > 0.0) fragColor = vec4(0.0);\n\n    // Jitter within the pixel for antialiasing\n    fragCoord += vec2(rand01(rngState), rand01(rngState));\n    vec2 viewportCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - viewportCenter) / iResolution.y;\n\n    // Calculate a ray for the pixel\n    vec2 mouse = (iMouse.xy - viewportCenter) / iResolution.y;\n    if (iMouse.xy == vec2(0.0)) mouse = vec2(0.07, -0.04);\n    mat3 camBasis = getCameraBasis(mouse * TAU);\n\n    // Adding depth of field as a bonus\n    // Based on this lesson https://pathtracing.home.blog/depth-of-field/\n    Ray primaryRay = Ray(CAMERA_POSITION, camBasis * normalize(vec3(uv, LENS_DISTANCE)));\n    vec3 aperturePoint = camBasis * vec3(randInUnitDisc(rngState) * APERTURE_RADIUS, 0.0);\n    Ray ray = Ray(primaryRay.orig + aperturePoint, normalize(primaryRay.dir * FOCUS_DISTANCE - aperturePoint));\n\n    // Pathtrace!\n    vec3 acc = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {\n        HitInfo hit = traceRay(ray);\n        if (hit.hitDist < 0.0) {\n            acc += pow(texture(iChannel1, ray.dir).rgb, vec3(2.2)) * throughput;\n            break;\n        }\n\n        hit.surfNor = normalize(hit.surfNor);\n        Material mtl = getMaterial(hit.surfUv, hit.objId);\n\n        // If the ray hit inside, some light gets absorbed\n        if (hit.fromInside) throughput *= exp(-mtl.absorption * hit.hitDist);\n\n        // Initial chances of reflecting or refracting\n        float specularChance = mtl.specularAmount;\n        float refractionChance = mtl.refractionAmount;\n\n        if (specularChance > 0.0) {\n            // Adjust specular chance to account for the Fresnel effect\n            specularChance = getFresnel(\n                hit.fromInside ? mtl.refractiveIndex : 1.0,\n                hit.fromInside ? 1.0 : mtl.refractiveIndex,\n                ray.dir, hit.surfNor, mtl.specularAmount, 1.0\n            );\n\n            // Make sure diffuse / refraction ratio is the same\n            // Diffuse chance is implied (1 - specularChance - refractionChance)\n            float correctionRatio = (1.0 - specularChance) / (1.0 - mtl.specularAmount);\n            refractionChance *= correctionRatio;\n        }\n\n        // Choose whether to diffuse, reflect, or refract\n        float doSpecular = 0.0;\n        float doRefraction = 0.0;\n        float rayProbability = 1.0 - specularChance - refractionChance;\n        float selector = rand01(rngState);\n        if (specularChance > 0.0 && selector < specularChance) {\n            doSpecular = 1.0;\n            rayProbability = specularChance;\n        } else if (refractionChance > 0.0 && selector < specularChance + refractionChance) {\n            doRefraction = 1.0;\n            rayProbability = refractionChance;\n        }\n\n        // Step to the intersection and push off the surface a tiny bit\n        ray.orig = hit.hitPos + hit.surfNor * (doRefraction == 1.0 ? -EPSILON : EPSILON);\n\n        // Calculate a new ray direction\n        // Diffuse uses a random reflection from a cosine distribution about the normal\n        // Specular uses the perfect reflection across the normal\n        // Refraction uses the perfect refraction across the normal\n        // Squaring the roughness is just a convention to make roughness appear more linear\n        vec3 diffuseRay = normalize(hit.surfNor + randUnitVec(rngState));\n        vec3 specularRay = reflect(ray.dir, hit.surfNor);\n        specularRay = normalize(mix(specularRay, diffuseRay, mtl.specularRoughness * mtl.specularRoughness));\n        vec3 refractionRay = refract(ray.dir, hit.surfNor, hit.fromInside ? mtl.refractiveIndex : 1.0 / mtl.refractiveIndex);\n        refractionRay = normalize(mix(refractionRay, normalize(-hit.surfNor + randUnitVec(rngState)), mtl.refractionRoughness * mtl.refractionRoughness));\n        ray.dir = mix(diffuseRay, specularRay, doSpecular);\n        ray.dir = mix(ray.dir, refractionRay, doRefraction);\n\n        // Accumulate light emission from the surface\n        acc += mtl.emission * throughput;\n\n        // Update the throughput for diffuse and specular reflections only\n        if (doRefraction == 0.0) throughput *= mix(mtl.albedo, mtl.specular, doSpecular);\n\n        // Adjust the throughput to account for the actions that got discarded\n        throughput /= max(EPSILON, rayProbability);\n\n        // Russian roulette optimization\n        // Increases the chance of terminating as the throughput decreases\n        // Surviving samples get boosted to make up for the eliminated ones\n        float stopChance = max(throughput.r, max(throughput.g, throughput.b));\n        if (rand01(rngState) > stopChance) break;\n        throughput /= stopChance;\n    }\n\n    // Combine the new sample with the current average\n    fragColor.w += 1.0;\n    fragColor.rgb = mix(fragColor.rgb, acc, 1.0 / fragColor.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}