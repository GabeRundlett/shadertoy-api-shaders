{
    "Shader": {
        "info": {
            "date": "1641282028",
            "description": "Custom mandelbox by loicvdb. https://shadertoy.com/view/3t3GWH mixed with a nice cube map sky thingy someone kindly made. Luscious colours, thanks whoever you are, I forget",
            "flags": 32,
            "hasliked": 0,
            "id": "7lGSWG",
            "likes": 15,
            "name": "Anemone",
            "published": 3,
            "tags": [
                "fractal",
                "gi",
                "dof",
                "bloom",
                "depthoffield",
                "ao",
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 469
        },
        "renderpass": [
            {
                "code": "// Fork of \"Psynthetika spectrum muted tun\" by xenn. https://shadertoy.com/view/7tyXRG\n// 2022-01-04 07:39:48\n\n// Forkmerge with \"Fork mandelbulb rogo1965 883\" by rogo1965. https://shadertoy.com/view/slGSR3\n// 2022-01-04 07:38:29\n\n// Forkmerge with \"Kleinian Landscape\" by amoser. https://shadertoy.com/view/WttBRr\n// 2021-11-28 02:34:24\n\n// Final post-processing\n// \n\n// Sample scene color with FXAA, 0-1 range uvs\nvec4 sceneColor(vec2 uv)\n{\n    vec4 outColor = vec4(FXAA(uv, iChannel1, 1.0/iResolution.xy), 1.0);\n    \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvAspectCorrected = uv - 0.5;\n    uvAspectCorrected = vec2(uvAspectCorrected.x*(iResolution.x/iResolution.y), uvAspectCorrected.y);\n    uvAspectCorrected += 0.5;\n    \n    // Fringe\n\tconst int fringeSamples = 6;\n    float fringeAmount = fringeStrength*saturate(distance(uvAspectCorrected, vec2(0.5))-fringeStart);\n\n    vec4 outColor = vec4(0);\n\n    if(fringeAmount > 0.0)\n    {\n        for(int i = 0; i < fringeSamples; i++)\n        {\n            float fringe = 1.0+(float(i-fringeSamples/2)*fringeAmount)/float(fringeSamples);\n            outColor += vec4(sceneColor(((uv-0.5)*fringe + 0.5)))*HUE(mod(0.85-1.0*float(i)/float(fringeSamples), 1.0));\n        }\n        outColor /= float(fringeSamples)*0.6;\n    }\n    else\n    {\n        outColor = vec4(sceneColor(uv));\n    }\n\n    \n    // Vignette\n    outColor *= pow(saturate(1.25-1.5*distance(uv, vec2(0.5))), 0.9);\n    outColor += 0.001*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    // Saturation / discolor highlights\n    outColor = mix(outColor, vec4(1, 1, 0.66, 1)*vec4(dot(outColor.rgb, luma)), 1.0-saturate(1.05-dot(outColor.rgb, luma))); \n    \n    // Saturation / discolor shadows\n    outColor = mix(outColor, vec4(0.6, 0.8, 1, 1)*vec4(dot(outColor.rgb, luma)), saturate(0.3-3.0*dot(outColor.rgb, luma))); \n    \n    // Tonemap + color grade\n   \toutColor = toneMap(outColor, vec3(0.95,0.95,0.85), vec3(1.15, 1.3, 1.3));\n    \n    // Ungraded tonemap\n   // outColor = toneMap(outColor, vec3(1), vec3(1));\n    \n    fragColor = pow(outColor, vec4(1.0/gamma));\n    \n    // For debugging depth\n //   fragColor = vec4(1.0-UDEPTH(fragCoord)*maxDepth);\n    // For debugging GI\n\t//fragColor = textureLod(iChannel0, uv, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 9; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.062;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, iTime*0.2);// rotation of mb\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<96; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n     \n    pixel_size = 1.0/(iResolution.x * 3.0);\n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.01, 2.2, 0.01);\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n\tvec3 rd = normalize(uv.x*cs + uv.y*cu + /*zoom*/(5.5- (1.0*sin(iTime/4.)))*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.2); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n    float halo= clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           vec3 n=nor(p); \n           float shadow = softshadow(p, sundir, 10.0 );\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * shadow; \n           lin += 0.8 * bac * sun; \n           lin += 0.6 * sky * skycolor*shadow; \n           lin += 3.0 * spe * shadow; \n\n\t\t   res.y = pow(clamp(res.y, 0.0, 1.0), 0.95);\n\t\t   vec3 tc0 = 0.5 + 0.5 * cos(-6.0*iTime + 9.2 * res.y + vec3(0.9, 0.0, 0.0));\n           col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    //col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor + vec3(1.2) * (1.0*factor);\n    fragColor = vec4(col, 1.0);\n//}\n// float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 coloro = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor * vec3(1.2) * (1.0/factor);\n//    fragColor = vec4(col, 1.0);\n//void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n//{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n//    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    vec3 groundCol = coloro;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 colo = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "//first DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//second DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Kleinian Landscape\n//\n// Except where otherwise specified or cited, all work is my own and available under\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Constants, helper functions\n// \n\n#define CLAMP_INDIRECT\n#define ANIMATE_CAMERA\n#define ANIMATE_SUN\n#define INTERACTIVE\n#define ROUGHNESS_MAP\n#define INDIRECT_GATHER_CHECK_DIRECTION\n\n\n////////// GENERAL\n\n#define PI 3.1415926536\n\nconst float gamma = 2.2;\n\n// Dynamic range; keep as low as possible since these buffers are packed with very low precision\nconst float hdrScale = 2.0;\nconst float depthScale = 8.0;\nconst float maxDepth = 1.0;\nconst float depthDistributionExponent = 1.0;\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\nconst float goldenAngle = 2.4;\n\n#ifdef TEMPORAL_JITTER\n\tconst float AAjitter = 1.0;\n#else\n\tconst float AAjitter = 0.0;\n#endif\n\nfloat saturate(float a)\n{\n    return clamp(a, 0.0, 1.0);\n}\n\n// from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// from Fabrice Neyret\n#define ROT(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define HUE(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0) ) )\n\n\n\n// Buffer unpacking\n#define UBOUNCE_COLOR(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).y))\n#define UBOUNCE_POSITION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).z))\n#define UBOUNCE_LIGHT(coord) (texelFetch(iChannel2, ivec2(coord), 0))\n#define UBOUNCE_LIGHT_BLUR(coord) UBOUNCE_LIGHT(coord)\n\n#define UDIRECT_ILLUMINATION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).x))\n#define UNORMAL(coord) (((unpack(texelFetch(iChannel0, ivec2(coord), 0).w)).xyz - 0.5)*2.0)\n#define UDEPTH(coord) (pow(texelFetch(iChannel0, ivec2(coord), 0).w, depthDistributionExponent))\n\n#define UDEPTH_CHANNEL1(coord) (texelFetch(iChannel1, ivec2(coord), 0).w)\n#define UBASE_COLOR(coord) vec3((unpack(texelFetch(iChannel0, ivec2(coord), 0).x)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).y)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).z)).w)\n\n// Color packing from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint packSnorm4x8(vec4 x) \n{\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 unpackSnorm4x8(uint x) \n{\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\n\n////////// SCENE\n\nstruct pointLight\n{\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 color;\n};\n    \nstruct directionalLight\n{\n    vec3 worldPosition;\n    float angle;\n    vec3 color;\n};\n    \nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float metal;\n};\n\nvec3 initialSunDirection = normalize(vec3(-0.2, 0.7, -0.4));\nvec3 initialSunColor = 0.25*vec3(0.7,0.50,0.3);\n// \"Moon\" is just sun reflected and re-colored when it crosses horizon line\nvec3 moonColor = 1.5*vec3(0.70,0.50,0.3)*vec3(0.25, 0.45, 0.75);\nvec3 skyColor = vec3(0);\n\n// Sphere inversion fractal, similar to iq's \"Apollonian\" (https://www.shadertoy.com/view/4ds3zn) but with octogonal symmetry\nfloat map(vec3 p, inout vec4 orbitTrap)\n{\n    const float s = 1.0;//0.97;\n    const float horizontalWrap = sqrt(s*2.0)/2.0;\n    \n\tfloat scale = 1.0;\n\n\torbitTrap = vec4(1000.0); \n    \n    for(int i=0; i<9; i++)\n\t{\n        p.xz /= horizontalWrap;\n        vec3 pOffset = (0.5*p+0.5);\n\n        vec3 pOffsetWrap = 2.0*fract(pOffset);\n        \n        p = -1.0 + pOffsetWrap;\n        p.xz *= horizontalWrap;\n        \n\t\tfloat r2 = dot(p,p);\n\t\t\n        if(i < 2)\n        {\n\t        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);\n        }\n        if(i > 2)\n        {\n            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);\n        }\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat fractal = 0.33*abs(p.y)/scale;\n    return fractal;\n}\n\nfloat sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)\n{\n    return map(p, orbitTrap);\n}\n\nvec3 calcNormal(in vec3 position)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    vec4 dummyOrbitTrap;\n\n    return normalize( \n        vec3(\n        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))\n    \t);\n}\n\nvec3 getSky(ray cameraRay, vec3 sunDirection, vec3 sunColor)\n{\n    // TODO could take dot product with some random hemisphere samples to create fake stars\n    vec3 bgColor = vec3(1.0);\n\n    #ifdef WATER\n        if(cameraRay.direction.y < 0.0)\n        {\n            cameraRay.direction *= vec3(1, -1, 1);\n            bgColor *= waterColor;\n        }\n    #endif\n\n    bgColor *= skyColor + saturate((dot(cameraRay.direction, sunDirection)-.9975)*800.0)*sunColor*80.0 + saturate(dot(cameraRay.direction, sunDirection)+0.75)*sunColor*0.015;\n\treturn bgColor;\n}\n\n\n////////// PATH TRACING\n    \nconst int unpackedNone = 0;\n\n// TODO flags for applying filters to packed textures\n/*\nconst int unpackedDirect = 1;\nconst int unpackedBounce = 2;\nconst int unpackedDepth = 3;\nconst int unpackedBaseColor = 4;\n*/\n\n// from hornet, who says:\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleLevel0(sampler2D sceneTexture, vec2 uv, float mipLevel)\n{\n    return textureLod(sceneTexture, uv, mipLevel);\n}\nvec4 SampleTextureCatmullRom(sampler2D sceneTexture, vec2 uv, vec2 texSize, float mipLevel, int getPacked)\n{\n    vec4 result = vec4(0.0);\n    if(getPacked == unpackedNone)\n    {\n        // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n        // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n        // location [1, 1] in the grid, where [0, 0] is the top left corner.\n        vec2 samplePos = uv * texSize;\n        vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n        // Compute the fractional offset from our starting texel to our original sample location, which we'll\n        // feed into the Catmull-Rom spline function to get our filter weights.\n        vec2 f = samplePos - texPos1;\n\n        // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n        // These equations are pre-expanded based on our knowledge of where the texels will be located,\n        // which lets us avoid having to evaluate a piece-wise function.\n        vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n        vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n        vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n        vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n        // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n        // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n        vec2 w12 = w1 + w2;\n        vec2 offset12 = w2 / w12;\n\n        // Compute the final UV coordinates we'll use for sampling the texture\n        vec2 texPos0 = texPos1 - vec2(1.0);\n        vec2 texPos3 = texPos1 + vec2(2.0);\n        vec2 texPos12 = texPos1 + offset12;\n\n        texPos0 /= texSize;\n        texPos3 /= texSize;\n        texPos12 /= texSize;\n        \n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos0.y), mipLevel) * w0.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos0.y), mipLevel) * w12.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos0.y), mipLevel) * w3.x * w0.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos12.y), mipLevel) * w0.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos12.y), mipLevel) * w12.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos12.y), mipLevel) * w3.x * w12.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos3.y), mipLevel) * w0.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos3.y), mipLevel) * w12.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos3.y), mipLevel) * w3.x * w3.y;\n    }\n    \n    return result;\n}\n\n\nvec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)\n{\n    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;\n    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;\n    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;\n    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));\n    \n    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);\n}\n\n// from tux: https://www.shadertoy.com/view/lsj3z3\nvec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)\n{\n    vec3 signs = sign(normal);\n    \n    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;\n    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;\n    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;\n    \n    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n  \n    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));\n}\n    \n\n// from iq\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)\n{\n    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);\n    vec2 random = hash22(randomSeed);\n    float u = random.x;\n    float v = random.y;\n    \n    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n\n// Camera projection stuff\nvec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) \n{\n    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;\n    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;\n    return vec3(\n        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), \n\t    (-1.0 + x2 + y2) / (1.0 + x2 + y2),\n        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));\n}\nvec2 stereographicSphereToPlane(vec3 cartPointOnSphere) \n{\n    return vec2(\n        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), \n        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));\n}\nvec2 cameraRayToUv(ray cameraRay, float projectionDist)\n{\n    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);\n    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));\n    return uv;\n}\nray uvToCameraRay(vec2 uv, float projectionDist)\n{\n    ray cameraRay;\n    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));\n    return cameraRay;\n}\n\n\n////////// POST\n\n// Bloom settings\nconst float bloomIntensity = 0.2;\nconst float bloomRadius = 0.006;\n\n// Fringe/chromatic aberration settings\nconst float fringeStrength = 0.1;\nconst float fringeStart = 0.4;\n\n// Bokeh settings\nconst float bokehScale = 0.0075;\nconst float bokehClamp = 0.0125;\nconst float bokehForceSharp = 0.001;\nconst float bokehFringe = 0.6;\nfloat bokehAspectRatio = 1.75;\n\n// FXAA settings\nconst float spanMax = 3.0;\nconst float reduceMult = (1.0/spanMax);\nconst float reduceMin = (1.0/48.0);\nconst float subPixelShift = (1.0/4.0);\n\nvec3 FXAA( vec2 uv2, sampler2D tex, vec2 rcpFrame) \n{\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + subPixelShift)));\n   \n    float lumaTopLeft = dot(textureLod(tex, uv.zw, 0.0).xyz, luma);\n    float lumaTopRight = dot(textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomLeft = dot(textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomRight = dot(textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaCenter  = dot(textureLod(tex, uv.xy, 0.0).xyz,  luma);\n\n    float lumaMin = min(lumaCenter, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));\n\n    vec2 direction;\n    direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));\n    direction.y =  ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));\n\n    float dirReduce = max(\n        (lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (0.25 * reduceMult),\n        reduceMin);\n    float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + dirReduce);\n    \n    direction = min(vec2( spanMax,  spanMax),\n          max(vec2(-spanMax, -spanMax),\n          direction * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + direction * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + direction * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// \"Airy disc\" bloom, complete gibberish and not based on anything physical; I just like the way it looks.\nvec4 getBloom(sampler2D sceneTexture, vec2 uv, vec2 resolution, float seed, float aspectRatio)\n{ \n    vec2 randomSeed = (uv*resolution * .152 + seed);\n    float random = hash12(randomSeed)*PI*2.0;\n\n    float stepsCenter = 7.0;\n    float stepsRing = 6.0;\n    float mipLevel = log2(resolution.x)/2.25;\n    vec4 outColor = vec4(0);\n    \n    float bloomSum = 0.0;\n    float weight = 0.0;\n    float totalBloom = 0.0;\n\n    vec2 radius = vec2(bloomRadius);\n    radius.y *= aspectRatio;\n\n    vec2 offsetUv = uv;\n    \n    for(float j = 1.0; j < (stepsCenter + 1.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsCenter + 1.0), 0.75))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 1.0;\n        \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsCenter), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    radius *= 2.0;\n    \n    for(float j = 2.0; j < (stepsRing + 2.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsRing + 2.0), 0.25))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 0.5;\n       \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsRing), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    return outColor/totalBloom;\n}\n\nvec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)\n{\n    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);\n    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);\n    \n    vec3 x = clamp(graded.xyz,0.0001,0.999);\n    \n    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);\n}\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * 2.5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * 2.5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Bokeh with fake color fringing + autofocus, anamorphic (including realistic \"swirly\" artifacts near edges)\n//\n// Ended up quite hairy/hacky from to trying to avoid edge/background bleed artifacts, but works pretty well.\n// I originally wanted to do a separable version but didn't have enough buffers left, so it's fairly slow.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 randomSeed = (fragCoord * .152 + iTime * 1500. + iMouse.x);\n    float random = hash12(randomSeed)*PI*2.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float depth = textureLod(iChannel0, uv, 0.0).w*depthScale;\n        \n    // Autofocus\n    float focalDepth = texelFetch(iChannel1, ivec2(0), 0).w;\n    float focalDepthNew = min(min(min(textureLod(iChannel0, vec2(0.5, 0.25), 5.5).w*depthScale, textureLod(iChannel0, vec2(0.6, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.4, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.5, 0.5), 8.0).w*depthScale);\n    focalDepth = mix(focalDepth, focalDepthNew, 0.05);\n    \n    vec2 offsetUv = vec2(0);\n    vec4 foregroundColor = vec4(0);\n    vec4 backgroundColor = vec4(0);\n    vec4 midgroundColor = vec4(0);\n    vec4 midgroundColorNoFringe = vec4(0);\n    vec4 totalColor = vec4(0);\n    \n    const float steps = 32.0;\n    const float stepsSmooth = 24.0;\n    \n    vec2 radiusClamp = vec2(bokehClamp);\n    radiusClamp.y *= iResolution.x/iResolution.y;\n    \n    // Radius of circle of confusion based on depth at current pixel\n    vec2 trueRadius = vec2(bokehScale);\n    trueRadius.y *= iResolution.x/iResolution.y;\n    trueRadius *= 1.0-focalDepth/depth;\n  \n    vec2 erodedRadius = vec2(1);\n    vec2 smoothedRadius = vec2(0);\n    \n    const float additionalDilation = 1.25;\n    const float searchMipLevel = 0.0;\n    \n    // Preprocess, estimate kernel size etc.\n    for(float i = 0.0; i < stepsSmooth; i++)\n    {   \n        vec2 searchRadius = additionalDilation/**vec2(1.0/bokehAspectRatio, 1)*/*(radiusClamp*pow((i)/steps, 0.5));\n        offsetUv = uv + searchRadius*vec2(sin(i*goldenAngle/* + random*/), cos(i*goldenAngle/* + random*/));\n        \n        float depthGathered = textureLod(iChannel0, offsetUv, searchMipLevel).w*depthScale;\n\n        vec2 radiusGathered = vec2(bokehScale);\n        radiusGathered.y *= iResolution.x/iResolution.y;\n        radiusGathered *= 1.0-focalDepth/depthGathered;\n        \n        if(length(radiusGathered) >= length(radiusClamp))\n        {\n            radiusGathered = radiusClamp;\n        }\n        \n        smoothedRadius += abs(radiusGathered);\n        erodedRadius = min(abs(radiusGathered), erodedRadius);\n    }\n    smoothedRadius /= stepsSmooth;\n    \n    // Main blur\n    // Limited radius\n    vec2 radiusBias = vec2(bokehForceSharp);\n    radiusBias.y *= iResolution.x/iResolution.y;\n    vec2 radius = max(vec2(0), smoothedRadius-radiusBias);\n    radius /= (1.0-bokehForceSharp);\n    \n    float totalBlur = 0.0;\n    bool fringeValid = true;\n    \n    // Try to sample from lower-res mips to reduce noise, but don't want to go too low and introduce any visible blockiness\n    float mipLevel = min(max(log2(length(erodedRadius*iResolution.xy/3.0))+0.5, 0.0), max(log2(length(min(smoothedRadius, trueRadius)*iResolution.xy/3.0))-1.5, 0.0));   \n    mipLevel = min(mipLevel, 2.0);\n  \n    vec4 currentColor;\n    vec4 colorFringed;\n    float falloff = 1.0;\n    float vignette = 1.0;\n    if(length(radius) > 1.0/length(iResolution.xy))\n    {\n        for(float i = 0.5; i < steps; i++)\n        {   \n            vec2 offset = (radius*pow(i/steps, 0.5))*vec2(sin(i*goldenAngle + random), cos(i*goldenAngle + random));\n            \n            // \"Swirly\" bokeh\n            offset *= ROT(atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)-PI);\n            if(offset.y >= radius.y-3.0*(radius.y)*distance(uv, vec2(0.5)))\n            {\n                vignette = saturate(offset.y - (radius.y-3.0*(radius.y)*distance(uv, vec2(0.5))));\n                vignette = saturate(1.0 - 0.8*vignette/radius.y);\n                vignette = saturate(0.0001 + vignette);\n                offset.y /= 1.0+saturate(1.0-vignette)/2.0;\n                \n            }\n            offset *= ROT(-atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)+PI);\n\n            offset *= vec2(1.0/bokehAspectRatio, 1);\n            \n            offsetUv = uv + offset;\n\n            falloff = ((i+1.0)/steps);\n\n            // Using dilated depth to reduce bleed\n            float depthGathered = textureLod(iChannel2, offsetUv, 0.0).w*depthScale;\n\n            vec2 radiusGathered = vec2(bokehScale);\n            radiusGathered.y *= iResolution.x/iResolution.y;\n            radiusGathered *= 1.0-focalDepth/depthGathered;\n            radiusGathered *= vec2(1.0/bokehAspectRatio, 1);\n          \n            float distanceFromCenter = distance(offsetUv, uv);\n\n            if((depthGathered > depth && length(trueRadius) < bokehScale/6.0 /*&& length(radiusGathered) > length(trueRadius)*/))\n            {\n                float factor = smoothstep(bokehScale/80.0, bokehScale/6.0, length(trueRadius));\n                offsetUv = mix(uv, offsetUv, factor);\n            }\n            float curMipLevel = mipLevel;\n            currentColor = textureLod(iChannel0, offsetUv, mipLevel);\n            colorFringed = currentColor * 12.1*vec4(1.0, 0.16, 0.3, 1.0) * HUE(mod((0.2 + 0.3*float(i)/float(steps-1.0)), 1.0)) * falloff;\n            totalBlur += 1.0*vignette;\n\n            // Is the sample we gathered at a depth such that it would actually be scattered onto the current pixel?\n            if((length(radiusGathered) < distanceFromCenter*0.66))\n            {\n                fringeValid = false;\n                currentColor = vec4(0,0,0,1);\n                colorFringed = vec4(0,0,0,1);\n                totalBlur -= 1.0*vignette;\n            }\n             \n            midgroundColor += mix(currentColor, colorFringed, bokehFringe)*vignette;\n            midgroundColorNoFringe += currentColor*vignette;\n        }\n        // If we rejected some samples, the color fringe would become biased\n        if(!fringeValid)\n        {\n            midgroundColor = midgroundColorNoFringe;\n        }\n        else\n        {\n            midgroundColor = mix(midgroundColorNoFringe, midgroundColor, smoothstep(0.0, 4.0/length(iResolution.xy), length(radius)));\n        }\n        if(totalBlur > 0.0)\n        {\n\t        midgroundColor /= totalBlur;\n        }\n        else\n        {\n            midgroundColor = textureLod(iChannel0, uv, 0.0);\n        }\n    }\n    else\n    {\n        midgroundColor = textureLod(iChannel0, uv, 0.0);\n        // For debugging\n        //midgroundColor = vec4(1,0,0,1)*textureLod(iChannel0, uv, 0.0)*steps;\n    }\n    \n    totalColor += midgroundColor;\n    \n    // Bloom\n    totalColor += bloomIntensity*getBloom(iChannel0, uv, iChannelResolution[0].xy, mod(iTime*13.8 + iMouse.x, 1024.0), bokehAspectRatio*iResolution.x/iResolution.y);\n    \n    // Auto exposure\n    float exposure = texelFetch(iChannel1, ivec2(1, 0), 0).w;\n    float exposureNew = length(textureLod(iChannel0, vec2(0.5, 0.5), 8.0).rgb)*3.0 + 0.5;\n    exposure = mix(exposure, exposureNew, 0.05);  \n    exposure = max(exposure, 0.0) + 0.001;\n    totalColor /= exposure;\n\n    float outAlpha = 0.0;\n    \n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store focal depth\n        fragColor.w = focalDepth;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Store exposure\n        fragColor.w = exposure;\n        return;\n    }\n    \n    fragColor = vec4(totalColor.rgb, fragColor.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}