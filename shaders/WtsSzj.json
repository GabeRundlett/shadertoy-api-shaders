{
    "Shader": {
        "info": {
            "date": "1563572466",
            "description": "A transparent object where the transparency depends of the traveled distance inside the object.\nYou can move the camera with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtsSzj",
            "likes": 4,
            "name": "Thickness-dependent transparency",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction"
            ],
            "usePreview": 0,
            "username": "Eseris",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "#define pow(a,b) pow(abs(a),(b))\n\nconst int ALIASING_STEPS = 1;\n\nconst int NB_PASSES = 5;\nconst int MARCHING_STEPS = 150;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 vUnion(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(sdPlane(p, vec4(0, 1, 0, 1.)), .1);\n    \n    //d = vUnion(d, vec2(sdSphere(p - vec3(4, 0., 1), 1.3), 2.27));\n    float dist = sdSphere(p - vec3(-3, 2, 0), 2.);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(3, 2, 0), 2.), 1.);\n    dist = opSmoothUnion(dist, sdCapsule(p, vec3(2, 2, 0), vec3(-2, 2, 0), 1.), 1.);\n    d = vUnion(d, vec2(dist, 2.27));\n    \n    //d = vUnion(d, vec2(sdRoundedCylinder(p - vec3(0, 1.1, 0), 1., .3, 1.7), 2.85));\n\n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n\t));\n}\n\nvec2 rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n   \tvec2 e = vec2(end, 0.);\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tvec2 dist = map(camPos + depth * rayDir);\n\t\tif(abs(dist.x) < EPSILON) return vec2(depth, dist.y);\n\t\tdepth += abs(dist.x);\n\t\tif(dist.x >= end) return e;\n\t}\n\treturn e;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z, 2.);              \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y; \n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(0, iFrame); i<30; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res + .4, 0.0, 1.0 );\n}\n\nvec3 palette(float t) {\n\treturn vec3(.6, .5, .5) \n\t\t+ .5 * cos(6.283185 * (-vec3(1., 1., .5) * t + vec3(.2, .15, -.1) - .2));\n}\n\nvec3 applyLight(vec3 p, vec3 rd, vec3 nor, float id) {\n    vec3 col = vec3(0.);\n\n    // material        \n    vec3 mate = .7 * palette(fract(id));\n    if(id < 1.) {\n        float f = checkerboard(p);\n        mate = 0.2 + f*vec3(0.08);\n    }\n\n    // key light\n    vec3  lig = normalize(vec3(-8., 8., 5.));\n    vec3  hal = normalize( lig-rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow(dot( nor, hal ), 100.0);\n    dif *= calcSoftshadow(p, lig, .1, 3.);\n\n    col = mate * 3.*dif*vec3(.80,0.70,0.6);\n    col +=      .6*spe*vec3(1.00,0.70,0.5);\n\n    // ambient light\n    float amb = .6;\n    col += mate*amb;\n    \n\treturn col;\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\n\nvec3 shadingReflection(vec3 ro, vec3 rd, int nStep) {\n    vec3 p = ro + rd * 1e-2;\n    float alpha = 1.;\n    vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    p += d.x * rd;\n    vec3 nor = mapGradient(p);\n\n    vec3 col = applyLight(p, rd, nor, d.y);\n    col *= pow(smoothstep(MAX_DIST, 10., d.x), 2.); // fog\n\n    if(d.y < 1.) {\n        float kr = pow(1. - abs(dot(nor,-rd)), 5.) + .03;\n        col = col * alpha * (1. - kr);\n    }\n    \n\treturn col;\n}\n\n\nvec3 shading(vec3 ro, vec3 rd) {\n    vec3 resCol = vec3(0);\n    vec3 p = ro;\n    float alpha = 1.;\n    for(int i = NB_PASSES; i > 0; --i) {\n        vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += d.x * rd;\n    \tvec3 nor = mapGradient(p);\n        \n    \tvec3 col = applyLight(p, rd, nor, d.y);\n        col *= pow(smoothstep(MAX_DIST, 10., d.x), 2.); // fog\n        \n        if(d.y < 2.) {\n       \t\tfloat kr = pow(1. - abs(dot(nor,-rd)), 5.) + .03;\n        \tresCol += col * alpha * (1. - kr);\n       \t\talpha *= kr;\n            break;\n        }\n        else {\n       \t\tfloat kr = .1 + pow(1. - abs(dot(nor,-rd)), 5.);\n            resCol += shadingReflection(p, reflect(rd, nor), i-1) * alpha * kr;\n            \n            rd = refract2(rd, nor, 1.15);\n        \tp += rd * 1e-2; // small incr to avoid null dist\n            \n            // ############ transparency formula ###############\n            float depth = rayProcess(p, rd, MIN_DIST, MAX_DIST).x;\n            float transparency = 1. - exp(-5e-2 * pow(depth, 2.));\n            resCol += col * alpha * transparency;\n            \n           \talpha *= (1. - kr) * (1. - transparency);\n        }\n        \n    }\n    \n\treturn resCol;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 6., 10.);\n            vec3 rd = rayDirection(50., (fragCoord + offset) / iResolution.xy);\n            \n            float yaw = .5 * iTime;\n            float pitch = .2 + .3 *sin(.3 * iTime);\n            \n            if(iMouse.z > 0.) {\n                vec2 ang = iMouse.xy / iResolution.xy;\n                yaw = 7. * ang.x;\n                pitch = 1.5 * ang.y - .5;\n            }\n            \n            \n            camPos.yz *= rot(pitch);\n            camPos.zx *= rot(yaw);\n            rd.yz *= rot(.5 + pitch);\n            rd.zx *= rot(yaw);\n            //rd.yz *= rot(pitch);\n\n            vec3 col = vec3(0.);\n            col = shading(camPos, rd);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n    \n#if 0\n\tvec2 uv = fragCoord/iResolution.yy;\n    float x = fragCoord.x / iResolution.x;\n\ttot = mix(tot, palette(x), step(abs(uv.y - .03), .02));\n#endif\n\tfragColor = vec4(tot, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}