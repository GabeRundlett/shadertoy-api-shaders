{
    "Shader": {
        "info": {
            "date": "1698870552",
            "description": "CC0: Dark Aurelia\nAnother take on the aurelia logo\nShader gallery here: https://mrange.github.io/windows-terminal-shader-gallery/",
            "flags": 0,
            "hasliked": 0,
            "id": "DlcyzH",
            "likes": 24,
            "name": "Dark Aurelia 4 Windows Terminal",
            "published": 3,
            "tags": [
                "2d",
                "aurelia"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 352
        },
        "renderpass": [
            {
                "code": "// CC0: Dark Aurelia for Windows Terminal\n// Another take on the aurelia logo\n// Shader gallery here: https://mrange.github.io/windows-terminal-shader-gallery/\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define REV(x)      exp2((x)*zoom)\n#define FWD(x)      (log2(x)/zoom)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 baseCol00 = HSV2RGB(vec3(341.0/360.0, 0.96, 0.85));\nconst vec3 baseCol01 = HSV2RGB(vec3(260.0/360.0, 0.75, 0.36));\nconst vec3 baseCol10 = HSV2RGB(vec3(285.0/360.0, 0.68, 0.45));\nconst vec3 baseCol11 = HSV2RGB(vec3(268.0/360.0, 0.72, 0.40));\nconst vec3 gcol = HSV2RGB(vec3(0.6, 0.95, 0.00025));\nconst mat2 arot = ROT(radians(34.0));\nconst vec2 soff = vec2(0.01, 0.01)*(arot);\nconst float zoom = log2(1.8);\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  k = max(k, 1E-3);\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec4 daurelia(vec2 p, float r) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x += -0.033;\n  p1.y += -0.004;\n  vec2 p2 = p;\n  p2.x += 0.48;\n  p2.y += -0.06;\n  vec2 p3 = p;\n  p3.x += -0.495;\n  p3.y += -0.06;\n  vec2 p4 = p;\n  p4.x += 0.39;\n  p4.y += -0.86;\n  vec2 p5 = p;\n  p5.x += 0.78;\n  p5.y += 0.4;\n  vec2 p6 = p;\n  p6.x += 0.035;\n\n  float d0 = box(p0, vec2(1.0, 0.285)-r);\n  float d1 = box(p1, vec2(0.225, 1.01)-r);\n  float d2 = box(p2, vec2(0.17, 0.63)-r);\n  float d3 = box(p3, vec2(0.11, 0.63)-r);\n  float d4 = box(p4, vec2(0.06, 0.06)-r);\n  float d5 = box(p5, vec2(0.06, 0.07)-r);\n  float d6 = box(p6, vec2(0.55, 0.45)-r);\n\n  d0 -= r;\n  d1 -= r;\n\n  float d7 = -(d0 - 0.06);\n\n  d1 = pmax(d1, d7, r);\n\n  float d = d2;\n  d = min(d, d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d -= r;\n  d = pmax(d, d7,r);\n  return vec4(d0, d1, d, d6);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nvec3 aurelia(vec3 col, float aa, vec2 p) {\n\n  p *= arot;\n  vec4 ad = daurelia(p, 0.0);\n  vec4 sad = daurelia(p+soff, 0.025);\n  float m0 = clamp(0.35*dot2(p-vec2(1.0, 0.0)), 0.0, 1.0);\n  float m1 = clamp(0.35*dot2(p-vec2(0.0, 1.0)), 0.0, 1.0);\n  float shd = mix(0.75, 1.0, smoothstep(aa, -aa, -ad.w));\n  vec3 bcol0 = mix(baseCol00, baseCol01, m0);\n  vec3 bcol1 = mix(baseCol00, baseCol01, m1)*shd;\n  vec3 bcol2 = mix(baseCol10, baseCol11, m1)*shd;\n  float sd = min(min(sad.x, sad.y), sad.z);\n  float od = min(min(ad.x, ad.y), ad.z);\n  od = abs(od)-aa;\n\n  sd += 0.025;\n  sd = max(sd, 0.0175);\n  sd *= sd;\n\n  col += gcol/sd;\n  col = mix(col, mix(bcol0, col, 0.0), smoothstep(aa, -aa, ad.x));\n  col = mix(col, mix(bcol1, col, 0.0), smoothstep(aa, -aa, ad.y));\n  col = mix(col, mix(bcol2, col, 0.0), smoothstep(aa, -aa, ad.z));\n  col = mix(col, vec3(1.0), smoothstep(aa, -aa, od));\n  return col;\n}\n\nvec3 effect(vec3 col, float aa, vec2 op) {\n  const float angle = TAU/10.0; \n  const mat2 rot = ROT(0.5*angle);\n\n  float gtm = 0.125*TIME;\n  op *= ROT(0.25*gtm);\n  float od = 1E4;\n  \n  for (int j = 0; j < 2; ++j){\n    float tm = gtm+float(j)*0.5;\n    float ctm = floor(tm);\n    float ftm = fract(tm);\n    float z = REV(ftm);\n    vec2 p = op;\n    p /= z;\n  \n    float d = 1E4;\n    float n = floor(FWD(length(p)));\n    float r0 = REV(n);\n    float r1 = REV(n+1.0);\n    \n    for (int i = 0; i < 2; ++i) {\n      vec2 pp = toPolar(p);\n      mod1(pp.y, angle);\n      vec2 rp = toRect(pp);\n      \n      float d0 = circle(rp, r0);\n      float d1 = circle(rp, r1);\n      float d2 = segment(rp, rot*vec2(r0, 0.0), vec2(r1, 0.0));\n      float d3 = segment(rp, transpose(rot)*vec2(r0, 0.0), vec2(r1, 0.0));\n      d0 = abs(d0);\n      d1 = abs(d1);\n      d = min(d, d0);\n      d = min(d, d1);\n      d = min(d, d2);\n      d = min(d, d3);\n      float gd = d*z;\n      p *= rot;\n    }\n    d *= z;\n    od = min(od, d);\n  }\n\n  od -= aa*0.5;\n  col = mix(col, mix(baseCol00, baseCol01, tanh(dot2(op*1.0))), smoothstep(aa, -aa, od));\n  col += 50.0*gcol.zxy/max(dot2(op), 0.01);\n\n  return col;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  float aa = sqrt(2.0)/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  \n  vec2 ap = p;\n  float aaa = aa; \n  const float iz = sqrt(0.5);\n  ap /= iz;\n  aaa /= iz;\n\n  col = effect(col, aa, p);\n  col = aurelia(col, aaa, ap);\n  col *= smoothstep(1.25, 0.5, length(pp));\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}