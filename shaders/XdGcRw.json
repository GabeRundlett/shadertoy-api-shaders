{
    "Shader": {
        "info": {
            "date": "1521947454",
            "description": "Phase portrait on the sphere and hemisphere views.\nMove the camera by mouse.\nReference:\nVisual Complex Functions: An Introduction with Phase Portraits by Elias Wegert\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XdGcRw",
            "likes": 10,
            "name": "PhasePortraitOnSphere",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "complex",
                "phaseportrait"
            ],
            "usePreview": 0,
            "username": "soma_arc",
            "viewed": 568
        },
        "renderpass": [
            {
                "code": "const float PI = 3.141592;\nconst float TWO_PI = 2. * PI;\nconst float FOUR_PI = 4. * PI;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float CIRCLE_RADIUS = 0.02;\nconst float OUTER_CIRCLE_GRAY_SCALE = 0.4;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\n\n// Suggestions by FabriceNeyret2.\n#define gammaCorrect(rgb)  min( pow( rgb, vec3(DISPLAY_GAMMA_COEFF) ), 1.)\n#define degamma(rgb)       min( pow( rgb, vec3(GAMMA_COEFF) ), 1.)\n#define compProd(a,b)      mat2(a,-a.y,a.x) * b\n#define compQuot(a,b)      mat2(a,(a).y,-(a).x)  * (b) / dot(b, b)\n\nvec2 compFunc(vec2 position){\n\treturn position = compQuot(position - vec2(1. + sin(iTime), 0.4 + cos(iTime)), compProd(position, position) + position + vec2(1, 0)); \n\t//return position = compQuot(position - vec2(1., 0.), compProd(position, position) + position + vec2(1, 0));         \n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float GRAY_SCALE = 0.6;\nfloat computeGrayComponent(vec2 position, out float arg) {\n    float absModulus = 2. * log(length(position));\n    float modulusG = mix(1., fract(absModulus), GRAY_SCALE);\n        \n    arg = atan(position.y, position.x) / TWO_PI;\n    float argG = mix(1., fract(arg * 10.), GRAY_SCALE);\n    \n    return modulusG * argG;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(radians(fov) * .5);\n    vec3 v = normalize(target - eye);\n    vec3 focalXAxis = normalize(cross(v, up));\n    vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n    return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nconst float EPSILON = 0.0001;\nvec4 intersectSphere(int objId, int mtl,\n                     vec3 sphereCenter, float radius,\n                     vec3 rayOrigin, vec3 rayDir,\n                     vec4 isect, inout int outObjId){\n    vec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 intersection = (rayOrigin + t * rayDir);\n            outObjId = objId;\n            return vec4(t, normalize(intersection - sphereCenter));\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(int objId, int mtl,\n                    vec3 p, vec3 n,\n                    vec3 rayOrigin, vec3 rayDir, vec4 isect,\n                   \tinout int outObjId){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        outObjId = objId;\n        return vec4(t, n);\n    }\n    return isect;\n}\n\nconst float NO_HIT = 99999999.;\nconst int MTL_DIFFUSE = 0;\nconst int MTL_TRANSPARENT = 1;\n\nconst int OBJ_PLANE = 0;\nconst int OBJ_SPHERE = 1;\n\nvec4 getIntersection(vec3 eye, vec3 ray, out int outObj){\n    outObj = -1;\n    vec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(OBJ_PLANE, MTL_DIFFUSE,\n                           vec3(0, -2, 0), vec3(0, 1, 0),\n                           eye, ray, isect, outObj);\n    isect = intersectSphere(OBJ_SPHERE, MTL_DIFFUSE,\n                            vec3(0), 1.,\n                            eye, ray, isect, outObj);\n    return isect;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n    vec3 v = lightPos - p;\n    float d = dot(n, normalize(v));\n    float r = length(v);\n    return (d > 0. )//&& visible(p + EPSILON * n, lightPos)) \n        ?\n        (lightPower * (d / (FOUR_PI * r * r))) * diffuseColor\n        : BLACK;\n}\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.y), p.z / (1. - p.y));\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));\nconst vec3 LIGHT_POS = vec3(3, 5, 0);\nconst vec3 LIGHT_POWER = vec3(300.);\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\n\nvec3 castRay(vec3 eye, vec3 ray) {\n    vec3 l = BLACK;\n    int objId;\n    vec4 isect = getIntersection(eye, ray, objId);\n\tif(isect.x != NO_HIT){\n\t\tvec3 matColor = WHITE;\n        vec3 normal = isect.yzw;\n\t\tvec3 intersection = eye + isect.x * ray;\n\t\tif(objId == OBJ_PLANE){\n\t\t\tmatColor = LIGHT_GRAY;\n\t\t}else if(objId == OBJ_SPHERE){\n            vec2 position = stereoProject(intersection);\n            if (abs(length(position) - 1.) < 0.02) {\n                matColor = BLACK;\n            } else {\n            \tposition = compFunc(position); \n            \n            \tfloat arg;\n\t\t\t\tfloat g = computeGrayComponent(position, arg);\n\t\t\t\tmatColor = degamma(hsv2rgb(vec3(arg, 1., g)));\n            }\n\t\t}\n\t\t// diffuse lighting by directionalLight\n\t\t//vec3 diffuse = clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n\t\tvec3 diffuse = diffuseLighting(intersection, normal, matColor,\n\t\t\t\t\t\t\t\t\t   LIGHT_POS, LIGHT_POWER);\n\t\tvec3 ambient = matColor * AMBIENT_FACTOR;\n\t\tl += (diffuse + ambient);\n\t}  \n    return l;\n}\n\n\n\nconst int SAMPLE_NUM = 20;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    const vec3 up = vec3(0, 1, 0);\n    const float fov = 60.;\n    \n    for(int i = 0 ; i < SAMPLE_NUM ; i++){        \n        if(fragCoord.x < iResolution.x/2.){\n            float my = 3. * (iMouse.y - iResolution.y * 0.5) / iResolution.y + 0.5;\n            float r =  1. + 2. * iMouse.x / iResolution.x;\n            vec3 eye = vec3(r * sin(iTime), r * sin(atan(my, 1.)), r * cos(iTime));\n    \t\tvec3 target = vec3(0, 0, 0);\n        \tvec3 ray = calcRay(eye, target, up, fov,\n                         \t   iResolution.x/2., iResolution.y,\n                         \t   fragCoord.xy + rand2n(fragCoord.xy, float(i)));\n        \tsum += castRay(eye, ray);\n        }else{\n            vec2 size = iResolution.xy / 2.;\n        \tvec2 p = 2. * (vec2(fragCoord.x - size.x, fragCoord.y) - size * 0.5) / size.y\n                     + 2. * rand2n(fragCoord.xy, float(i)) / size.y;\n            if(p.y <= 1.){\n                vec2 position = p * 1.1;\n                if (abs(length(position) - 1.) < CIRCLE_RADIUS) continue;\n                float s = length(position) > 1. ? OUTER_CIRCLE_GRAY_SCALE : 1.;\n\n                position = compFunc(position);\n                \n                float arg;\n\t\t\t\tfloat g = computeGrayComponent(position, arg);\n\t\t\t\tsum += hsv2rgb(vec3(arg, 1., g * s));\n            } else {\n                p.y -= 2.;\n\t\t\t\tvec2 position = p * 1.1;\n                if (abs(length(position) - 1.) < CIRCLE_RADIUS) continue;\n                float s = length(position) > 1. ? OUTER_CIRCLE_GRAY_SCALE : 1.;\n\n\t\t\t\tposition = compFunc(compQuot(vec2(1, 0), position)); // 1 / z\n                \n                float arg;\n\t\t\t\tfloat g = computeGrayComponent(position, arg);\n                sum += hsv2rgb(vec3(arg, 1., g * s));\n            }\n        }\n        \n    }\n    \n    if(fragCoord.x < iResolution.x/2.){\n    \tfragColor = vec4(gammaCorrect(sum/float(SAMPLE_NUM)), 1.);\n    } else {\n    \tfragColor = vec4((sum/float(SAMPLE_NUM)), 1.);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}