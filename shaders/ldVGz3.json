{
    "Shader": {
        "info": {
            "date": "1455698747",
            "description": "A test of using the Shadertoy app to create a VR app for Google Cardboard",
            "flags": 0,
            "hasliked": 0,
            "id": "ldVGz3",
            "likes": 2,
            "name": "Google VR Experiment",
            "published": 3,
            "tags": [
                "raymarcher",
                "vr",
                "google",
                "headset"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 1164
        },
        "renderpass": [
            {
                "code": "#define MAX_ITERATIONS 256\n#define MIN_DISTANCE  .001\n\n#define LIGHT_DIR normalize(vec3(45.,30.,-45.))\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dst { float dst; int id;  };\nstruct Hit { vec3 p; int id; \t };\n    \nDst dstSphere(vec3 p, vec3 pos, float r) {\n\n    float disp = 0.;\n    if(iMouse.z > 0.) {\n        vec3 n  = normalize(p-pos);\n        vec2 uv = mod(asin(n.xy) / 3.14159 + .5, 1.);\n    \tdisp += texture(iChannel1,uv).x*.25;   \n    }\n    return Dst(length(pos - p) - (r+disp), 0);\n    \n}\n\nDst dstFloor(vec3 p, float y) {\n \n    return Dst(p.y - y, 1);\n    \n}\n\nDst minDst(Dst a, Dst b) {\n \n    if(a.dst < b.dst) return a;\n    return b;\n    \n}\n\nDst dstScene(vec3 p) {\n \n    p.x -= 1.;\n    \n    Dst dst = dstSphere(p, vec3(1.,0.,0.), 1.);\n    dst = minDst(dst, dstSphere(p, vec3(9.,0.,2.), 1.));\n    dst = minDst(dst, dstFloor(p, -1.));\n    \n    return dst;\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dst scn = dstScene(p);\n        p += ray.dir * scn.dst * .5;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001,0.);\n    vec3   n = vec3(dstScene(p + eps.xyy).dst - dstScene(p - eps.xyy).dst,\n                    dstScene(p + eps.yxy).dst - dstScene(p - eps.yxy).dst,\n                    dstScene(p + eps.yyx).dst - dstScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n    \nvec3 calcLighting(vec3 p, vec3 ld, vec3 n) {\n \n    float d = max(dot(ld,n),0.);\n    \n    Ray sr = Ray(p + ld * .04, ld);\n    Hit sh = raymarch(sr);\n    if(sh.id != -1) d = 0.;\n    \n    return vec3(d);\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn  = raymarch(ray);\n    vec3 col = texture(iChannel0, ray.dir).xyz;\n    \n    if(scn.id == 0) {\n     \n        vec3 n = calcNormal(scn.p);\n        vec3 d = calcLighting(scn.p,LIGHT_DIR,n);\n        \n        vec3 r = normalize(reflect(ray.dir,n));\n       \tvec3 s = pow(max(dot(r,LIGHT_DIR), 0.), 60.) * d;\n        \n        col = vec3(1.,0.,0.) * d + s;\n        \n    } else if(scn.id == 1) {\n     \n        vec3 n = calcNormal(scn.p);\n        vec3 d = calcLighting(scn.p,LIGHT_DIR,n);\n        \n        col = texture(iChannel1,mod(scn.p.xz / 4., 1.)).xyz * d;\n        \n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(uv.x > .5) fragCoord.x -= iResolution.x * .5;\n    \n    //fragCoord.xy *= 5.;\n    \n    vec3 ori = vec3(.03 * (uv.x > .5 ? -1. : 1.) + 4.5 + sin(iTime), 0., -5.);\n    vec3 dir = vec3((fragCoord - iResolution.xy * .5) / iResolution.y, 1.);\n    \n    vec3 col = shade(Ray(ori,dir));\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}