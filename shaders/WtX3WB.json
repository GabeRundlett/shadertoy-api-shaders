{
    "Shader": {
        "info": {
            "date": "1557922299",
            "description": "Change USER_SEED to generate different tunes.\n\nI want to do more on this but I also want to take it in a different direction, so I'm going to share this early sketchy version. Apologies for various unimplemented/partially implemented things in the code.",
            "flags": 8,
            "hasliked": 0,
            "id": "WtX3WB",
            "likes": 18,
            "name": "Generative Synth Loops",
            "published": 3,
            "tags": [
                "music",
                "generative"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "/*\n\n ^\n/|\\\n |\n |        .--------.\nSwitch to |Common  |\n\n\nthis is just the music visualiser\n\n*/\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = .25*(60./440.)*(fragCoord.x/iResolution.x - .5) + iTime;\n    \n    // use different colours for the stereo channels - even though we only use stereo for the reverb\n    fragColour = step( mainSound( 0,time).xyyy, vec4( ((fragCoord.y/iResolution.y)*2.-1.)*1. ) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n ^\n/|\\\n |\n |        .--------.\nSwitch to |Common  |\n\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n\n// CHANGE THIS VALUE TO RANDOMISE EVERYTHING!\n// 3, 58, 70, 36, 313, 0, 21, 29, 55, 69421    - nice sounding values\n// -1    - special value to play through a selection of nice seeds\n#define USER_SEED -1\n\n\n\n// parameters controlling the type of sequence created\nconst float BPM = 120.;\nconst float instrumentRandomness = .5; // 0 means we get a mix of different instruments, 1 means more variety\n\n// reverb is slow to compile, so you might want to disable it when messing with other parameters\n#define DO_REVERB 1\nconst float reverbLength = 1.3;\nconst float reverbWetness = .5;\n\n\n\n\n#if USER_SEED == -1\n\tuint SEED;\n\t#define ANIMATE_SEED\n#else\n\t// CHANGE THIS VALUE TO RANDOMISE THINGS!\n\tconst uint SEED = uint(USER_SEED); \n#endif\n\n\n// Maths Constants\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\n\n// Random Functions\n// from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nvec2 quasirand2 = vec2(.754877666247,.569840290998); // from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n\nuint randCount = 0u;\n// Do not call Rand() inside conditionals! it will mess up later rands\nfloat Rand()\n{\n    return hash1( coord2( uvec2( SEED, randCount++ ) ) );\n}\n\n\n/*\nInstrument parameters:\noctave offset - so we can get bass notes (not animatable)\n\nwaveform, volume, noise, pitch modifier\n\nAll of these (not octave) are animateable with envelopes\n=> could have ADSR parameters for each value! yikes.\nTo avoid going completely nuts, have a single envelope and a multiplier for how much it impacts^ those things\n\nAlso could modulate these by pitch\n\nand by LFO/bar\n*/\nstruct Instrument\n{\n    vec4 ADSR; // amplitude * 0 at time 0, * 1 at time A, * .5 from time D to time S, * 0 at time R\n    vec3 waveform; // slope up, slope down (vertical, scallop, linear), pulse width (0=full width, 1 = all high)\n    float amplitude;\n    float noise;\n    vec3 envelopeToWaveform;\n    float envelopeToNoise;\n//    float envelopeToPitch; - I can't do this without knowing the integral of ADSR and I'm too lazy for that much maths\n    \n    // sequence parameters - some of these get quantized after lerping\n    float baseNote; // it's a pentatonic scale, so 5 = one octave higher\n    float noteRange; // range notes can vary from that\n    float sequenceLength;\n    float beatPeriod;\n    float beatRandomness;\n};\n\n \n#define PowMix(a,b,c,p) pow( mix( pow( a, 1./p ), pow( b, 1./p ), c ), p )\n    \nInstrument LerpInstruments( Instrument a, Instrument b, float c )\n{\n    // do not clamp c! might get nice results when out-of-range\n    return Instrument(\n        mix( a.ADSR, b.ADSR, c ),\n        PowMix( a.waveform, b.waveform, c, vec3(1) ),\n        PowMix( a.amplitude, b.amplitude, c, 2. ), // favour lower amplitudes\n        mix( a.noise, b.noise, c ),\n        mix( a.envelopeToWaveform, b.envelopeToWaveform, c ),\n        mix( a.envelopeToNoise, b.envelopeToNoise, c ),\n        mix( a.baseNote, b.baseNote, c ),\n        mix( a.noteRange, b.noteRange, c ),\n        mix( a.sequenceLength, b.sequenceLength, c ),\n        mix( a.beatPeriod, b.beatPeriod, c ),\n        mix( a.beatRandomness, b.beatRandomness, c )\n    );\n}\n\n\n// Don't just randomise each parameter independently, that would sound weird\n// rather create a multi-dimensional space between extreme archetypes of pleasant instruments\n// e.g. qualities of a kick-drum are only found in a low octave\n// e.g. trilinear blend between 8 archetypes, or bilinear between 4, using 3/2 random params respectively\nInstrument instrumentSpace[] = Instrument[](\n    \tInstrument( vec4(0,.03,.03,.2), vec3(1,1,.2), 1., .15, vec3(-.5,-.5,.5), -.1,   -20., 0., 16., 4., 0. ) // kick\n    \t,Instrument( vec4(.01,.05,.15,.5), vec3(.1,.1,0), .1, .0, vec3(0,0,0), .0,  -5., 4., 16., 3., .5 ) // friendly square synth\n    \t,Instrument( vec4(.0,.01,.03,.18), vec3(.3,0,0), .08, .0, vec3(0,1,0), .0,   5., 4., 16., 1., 0. ) // little bleepy arpeggio\n    \t,Instrument( vec4(0,0,1.8,2.2)*2., vec3(1,1,0), .4, .0, vec3(-.3,0,0), .0,    -8., 4., 128., 32., 0. ) // pads\n\t);\n    \n\nint instrumentCount = 0;\nvec2 firstInstrument = vec2(-1);\nInstrument GenerateInstrument()\n{\n    vec2 rand = vec2(Rand(),Rand());\n    \n    if ( instrumentCount == 0 )\n    {\n        firstInstrument = rand;\n    }\n    else\n    {\n        rand = mix( fract(quasirand2*float(instrumentCount)), rand, instrumentRandomness );\n    }\nint oi = instrumentCount;\n    instrumentCount++;\n    \n    // stretch the range toward the extremes to get more distinct instruments\n    rand = smoothstep(.2,.8,rand);\n    \n//return instrumentSpace[oi]; // test the arcetype instruments\n    return\n\t\tLerpInstruments( \n\t\t\tLerpInstruments( instrumentSpace[0], instrumentSpace[1], rand.x ),\n\t\t\tLerpInstruments( instrumentSpace[2], instrumentSpace[3], rand.x ),\n\t\t\trand.y\n\t\t);\n}\n\n\n// play a note\n// seed = randomise the instrument sound based on this\n// time = from the start of the note\n// frequency = tau*440*exp2(pitch/12) where pitch is in semitones\nvec2 PlayInstrument( Instrument instrument, vec2 timeFreq )\n{\n    float time = timeFreq.x;\n    float frequency = timeFreq.y;\n    \n    vec4 adsr = instrument.ADSR;\n\tvec3 adsrRange = max( adsr.xyw - vec3(0,adsr.xz), .001 );\n    \n    // play the instrument\n    float envelope = min( time/adsrRange.x, \n                         mix(\n                             max( (adsr.y-time)/adsrRange.y, 0. ),\n                             max( min( (adsr.w-time)/adsrRange.z, 1. ), 0. ),\n                             .5 // sustain value (damn I love this bit of maths)\n                         )\n                     );\n    \n    float f = fract(time*frequency);\n    \n    vec3 waveform = instrument.waveform;\n    \n    waveform += instrument.envelopeToWaveform*envelope;\n    \n    waveform.xy = clamp(waveform.xy,.001,1.);\n    \n    float pulseWidth = waveform.z;\n    f = clamp( f/(1.-pulseWidth), 0., 1. );\n    \n    f = min(\n        \tpow( clamp( f/.5, 0., 1. ), waveform.x ),\n        \t1.-pow( clamp( f/.5-1., 0., 1. ), waveform.y )\n        );\n    \n    // noise\n//    float noise = hash1( coord1( uint( time * 44100. *exp2(-6.) ) ) );  // low-fi!\n    // low pass filter sound - low frequency noise with smoothing\n    float noiseIndex = time * 44100. *exp2(-6.); // maybe shift with pitch?\n    float noise = mix(\n            hash1( coord1( uint( noiseIndex ) ) ),\n            hash1( coord1( uint( noiseIndex ) + 1u ) ),\n            smoothstep( .0, 1., fract( noiseIndex ) )\n        );\n    f = mix( f, noise, instrument.noise + envelope*instrument.envelopeToNoise );\n    \n    f = f*2.-1.;\n    \n\tf *= envelope * instrument.amplitude;\n    \n    return vec2(f);\n}\n\n\nuint noteRandCount = 0u;\nfloat NoteRand( int count )\n{\n    return hash1( coord3( uvec3( noteRandCount++, SEED, count ) ) );\n}\n\n// output: time from note start, frequency\nvec2 PlaySequence( float time, Instrument instrument )\n{\n    const float middleA = 440.;\n    \n/*    float octave; // pitch of middle note\n    float noteRange; // range notes can vary from that\n    float sequenceLength;\n    float beatPeriod;\n    float beatRandomness;  */\n    \n    const float bps = 4.*BPM/60.; // we want 4 notes per beat\n    const float spb = 1./bps;\n    \n    float sequenceLength = floor( instrument.sequenceLength + .5 ) * spb;\n    float beatPeriod = floor( instrument.beatPeriod + .5 ) * spb; // n.b. maybe I want to allow half-beats? or maybe only on random notes\n    \n    // wrap time at sequence length\n    time = fract( time/sequenceLength ) * sequenceLength;\n\n    \n    // regular beats\n    int beatIndex = int(floor(time/beatPeriod));\n    time -= float(beatIndex)*beatPeriod;\n    \n    \n\t// pick a note    \n    int note = int( floor( ( NoteRand(beatIndex) - .5 ) * instrument.noteRange + .5 ) );\n    \n\tnote += int( floor(instrument.baseNote+.5) );\n\n    // modulo and div are stupid on negative numbers, so offset by 5 octaves and subtract after\n    note += 5*5;\n    note = 12 * (note/5) // octave\n\t\t\t+ (((note%5)*7)%12); // pentatonic scale - spacing of 5 fifths wrapped in an octave\n    note -= 5*12;\n                  \n    \n\tfloat frequency = middleA * exp2(float(note)/12.);\n                          \n\treturn vec2( time, frequency );\n}\n\n\n\nInstrument instrument0;\nInstrument instrument1;\nInstrument instrument2;\nInstrument instrument3;\n\n\nvec2 Dry( float time )\n{\n    noteRandCount = 0u;\n//\treturn PlayInstrument( instrument0, PlaySequence( time, instrument3 ) );\n\treturn\n        PlayInstrument( instrument0, PlaySequence( time, instrument0 ) ) +\n        PlayInstrument( instrument1, PlaySequence( time, instrument1 ) ) +\n        PlayInstrument( instrument2, PlaySequence( time, instrument2 ) ) +\n        PlayInstrument( instrument3, PlaySequence( time, instrument3 ) );\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n#ifdef ANIMATE_SEED\n    uint niceSeeds[] = uint[]( 3u, 58u, 70u, 36u, 313u, 0u, 21u, 29u, 55u, 69421u );\n    SEED = niceSeeds[ int(time*(BPM/60.)/32.) ]; // change seed every 64 beats\n#endif\n    \n    randCount=0u; instrumentCount=0; // UGLY!\n    \n    instrument0 = GenerateInstrument();\n    instrument1 = GenerateInstrument();\n    instrument2 = GenerateInstrument();\n    instrument3 = GenerateInstrument();\n    \n    vec2 mixed = vec2(0);\n\n#if defined(DO_REVERB) && DO_REVERB != 0\n    const int reverbCount = 50;\n    vec2 off = vec2(1);\n    for ( int reverb=0; reverb < reverbCount; reverb++ )\n    {\n        // using independent stereo offsets creates a better feeling of space\n        vec2 off = hash2(coord1(uint(reverb))); // not uniform enough - creates echoes\n        // this causes audible hum because the samples are uniformly spaced\n        //vec2 off = fract(quasirand2*float(reverb));\n        //vec2 off = mix ( fract(quasirand2*float(reverb)), hash2(coord1(uint(reverb))), .1 ) ;\n\n        vec2 t = time - off*reverbLength;\n\n//        vec2 amp = exp2(-off*4.);\n        vec2 amp = 1./(1. + 8.*off*off); // inverse square - e.g. if the sound was bouncing off an array of reflectors of equal size evenly distributed over distance - implausible but it sounds ok\n\n        mixed.x += amp.x * dot( Dry(t.x), vec2(.5) );\n        mixed.y += amp.y * dot( Dry(t.y), vec2(.5) );\n    }\n    \n    mixed *= 10./float(reverbCount); // should * the integral of the curve\n\n    mixed = mix( Dry(time), mixed, reverbWetness );\n#else\n    \n    mixed = Dry(time);\n    \n#endif    \n    \n    return mixed;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}