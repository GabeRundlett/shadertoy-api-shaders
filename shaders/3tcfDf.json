{
    "Shader": {
        "info": {
            "date": "1617107041",
            "description": "March 31st is Transgender Day of Visibility, so I thought it was a good time to revisit the [url=https://www.shadertoy.com/view/ldX3DX]flag shader[/url] I made 8 years ago (before I came out as trans!).\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3tcfDf",
            "likes": 42,
            "name": "Realistic Flag",
            "published": 3,
            "tags": [
                "raymarching",
                "uvmapping"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 1096
        },
        "renderpass": [
            {
                "code": "// Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// Trans day of visibility is March 31st.\n\n\nconst float tau = 6.28318530717958647692;\n\nvec2 gFragCoord;\n\n\n// Tone Mapping\n\nconst float exposure = .75;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.1);\nconst vec3 blackClip = vec3(.0);\nconst vec3 blackSoftness = vec3(.05);\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n    col *= exposure;\n\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\n\nfloat linstep( float a, float b, float c )\n{\n    return clamp((c-a)/(b-a),0.,1.);\n}\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = gFragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec4 Noise( in vec2 x )\n{\n    x = x*sqrt(3./4.) + x.yx*vec2(1,-1)*sqrt(1./4.); // tilt the grid so it's not aligned to the flag to make it less visible\n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec2 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p + f;\n\n#if (0)\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 fuv = uv - vec2(iuv);\n    \n\tvec4 rg = mix( mix(\n\t\t\t\ttexelFetch( iChannel0, iuv&255, 0 ),\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(1,0))&255, 0 ),\n\t\t\t\tfuv.x ),\n\t\t\t\t  mix(\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(0,1))&255, 0 ),\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(1,1))&255, 0 ),\n\t\t\t\tfuv.x ),\n\t\t\t\tfuv.y );\n#endif\t\t\t  \n\n\treturn rg;\n}\n\n\n// ----------------------\n\nfloat RippleHeight( vec2 pos )\n{\n    float time = iTime*2.;\n\n\tvec2 p = pos+vec2(-2,.2)*time;\n\t\n\tp += vec2(1,0)*Noise(p).y; // more natural looking ripples\n\tfloat f = Noise(p).x-.5;\n\tp *= 2.0;\n\tp += vec2(0,-.5)*time;\n\tf += (Noise(p).x-.5)*.2;\n\tp *= 1.6;\n\tp += vec2(-1,0)*time;\n\tf += (Noise(p).x-.5)*.05;\n\t\n\tf = f*(1.0-exp2(-abs(pos.x)));\n\treturn f*1.2;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn (RippleHeight(pos.xy)-pos.z)*.5;\n}\n\nvec3 Normal( vec3 pos )\n{\n\tvec2 delta = vec2(-1,1)*.01;//*length(fwidth(pos)); // gets moire artefacts if this is too small\n\treturn normalize(\n                DistanceField( pos + delta.xxx )*delta.xxx +\n                DistanceField( pos + delta.yyx )*delta.yyx +\n                DistanceField( pos + delta.yxy )*delta.yxy +\n                DistanceField( pos + delta.xyy )*delta.xyy\n            );\n}\n\n// map a uv space onto a distorted surface\nvec2 UVMapping( vec2 target )\n{\n    // bow the left edge so it's just mounted at 2 points\n    float bow = cos(target.y*6.283185/4.)*.08;\n    target.x -= bow;\n\n    float droop = 2.; // the technique isn't really robust enough for this to look realistic at bigger values\n    target.y += droop;\n    \n\t// need to march vertically to absorb vertical creases, and horizontally for horizontal ones\n\t// cheat, by seperating these two\n\tvec2 uv = vec2(0);\n\t\n    // make flag droop toward the right by offsetting target y\n    // hopefully this means it will droop more the more disruption there is\n//    target.y += target.x*.5;\n    \n    \n\tconst int n = 16;\n\tconst float fudge = 1.0; // use values > 1 to allow for extra ripples we're not measuring\n\tvec2 d = target/float(n);\n\tvec2 l;\n\tl.x = RippleHeight( vec2(0,target.y) );\n\tl.y = RippleHeight( vec2(target.x,0) );\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tvec2 s;\n\t\ts.x = RippleHeight( vec2(d.x*float(i),target.y) );\n\t\ts.y = RippleHeight( vec2(target.x,d.y*float(i)) );\n\t\t//uv.x += sign(d.x)*sqrt(pow(fudge*,2.0)+d.x*d.x);\n\t\t//uv.y += sign(d.y)*sqrt(pow(fudge*,2.0)+d.y*d.y);\n        \n\t\tuv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);\n\t\tl = s;\n\t}\n    \n//    uv.y += (uv.x+1.)*uv.x*.05; // droop toward the end\n\t\n    uv.y -= droop;\n    \n\treturn (uv+vec2(0,1))/vec2(3.0,2.0);\n}\n\nvec3 Pattern( vec2 uv )\n{\n    // striped patterns\n\n    // trans flag\n    vec3 colours[] = vec3[]( vec3(.3,.7,1), vec3(1,.2,.4), vec3(1), vec3(1,.2,.4), vec3(.3,.7,1) );\n\n    // lesbian\n    //vec3 colours[] = vec3[]( vec3(.8,.05,.0), vec3(1,.3,.0), vec3(1,.5,.2), vec3(1), vec3(1,.3,.6), vec3(.7,.1,.4), vec3(.5,.0,.2) );\n    \n    float smoothidx = (1.-uv.y)*float(colours.length()) + .5;\n    int idx = int(floor( smoothidx ));\n    float fidx = smoothidx - float(idx);\n    fidx -= .5;\n    \n    return mix(colours[max(0,idx-1)],colours[idx],\n                //step(.0,fidx)); // aliased\n                 smoothstep( -fidx, 1.-fidx, fidx/max(fwidth(smoothidx),.0001) ));// anti-aliased\n\n/*\n    // checker\n    float pattern = (fract(uv.x/.2)-.5)*(fract(uv.y/.3)-.5);\n    return mix( vec3(.03), vec3(1), smoothstep( -fwidth(pattern)*.5, fwidth(pattern)*.5, pattern ) ); // this antialiasing doesn't work\n*/\n}\n\nfloat Mask( vec2 uv )\n{\n    // todo: use fwidth so it is correct for distance\n\n\treturn max(\n            smoothstep(.495,.5,abs(uv.x-.5)),\n            smoothstep(.495,.5,abs(uv.y-.5))\n        );\n}\n\n\nfloat Weave( vec2 uv )\n{\n\tvec2 a = uv*vec2(3.0,2.0)*500.*.85;\n\tfloat f = (sin(a.x)+sin(a.y))*.25+.5;\n\n    f = mix( f, .5, min( 1., .2*max( fwidth(a.x), fwidth(a.y) ) ) ); // prevent moire\n\n    return f;\n}\n\n\nfloat Seam( vec2 uv )\n{\n    return smoothstep( .5, .48, abs(uv.y-.5) )\n          *smoothstep( 1., .985, uv.x )\n          *smoothstep( .02, .03, uv.x );\n}\n\n\nvec3 airColourLog2 = vec3(.1,.3,.6);\n\n// quick and pretty sky colour\nvec3 SkyColour( vec3 ray )\n{\n    vec3 col = exp2(-ray.y/airColourLog2); // blue - from https://www.shadertoy.com/view/4ljBRy\n    \n    // add some clouds\n    vec2 cloudUV = ray.xz/(ray.y+.2) + iTime*vec2(-.03,0);\n    vec4 clouds = (\n          Noise(4.*cloudUV)\n        + Noise(10.*cloudUV)*.4\n        + Noise(25.*cloudUV)*.16\n        + Noise(50.*cloudUV)*.04\n        )/1.6;\n    \n    col = mix( col, clouds.yyy, pow(smoothstep(.05,.6,clouds.x),8.)*1.*max(0.,ray.y) );\n    \n    // horizon\n    float horizonSDF = ray.y - .09 - .04*Noise(ray.xz*9.).x - .03*(.5-abs(Noise(ray.xz*5.).x-.5));\n    col = mix( col, mix( vec3(1), vec3(.1), exp2(-3.*airColourLog2*.01/(.01+max(0.,-horizonSDF))) ), smoothstep(.003, -.003, horizonSDF ) );\n    \n    return col;\n}\n\n\nvec3 Ambient( vec3 normal )\n{\n    return mix( vec3(.1,.07,.05), vec3(.15,.2,.25), normal.y*.3+.7 );\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    gFragCoord = fragCoord;\n\n\n    vec3 camPos, ray;\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    if ( dot(iMouse.xy,vec2(1)) <= 0. ) mousePos = (.5-.5*cos(vec2(1.,.618)*.1*iTime)) * vec2(1,.5);\n    CamPolar( camPos, ray, vec3(1.5,0,0), vec2(-.8,-.5)+vec2(1.2,1.5)*mousePos.yx, 20.0, 5. );\n    \n    if ( dot(iMouse.xy,vec2(1)) <= 0. )\n    {\n        // keep the camera on the ground, so it feels like we're looking up at a flag in a physical space\n        camPos = camPos * (-20.)/(camPos.y);\n        // for some reason this is offsetting the view to the right, so the flag's not at the centre of the frame\n        // this wasn't intentional but I like it!\n    }\n\n    float t = 0.0;\n    float h = 1.0;\n    for ( int i=0; i < 30; i++ ) // this holds up surprisingly well at low counts\n    {\n        if ( h < .01 )\n            break;\n        float h = DistanceField( camPos+t*ray );\n        t += h;\n    }\n\n    vec3 pos = camPos + t*ray;\n\n    vec2 uv = UVMapping( pos.xy );\n\n    vec3 albedo = Pattern( uv );\n\n    float mask = Mask(uv);\n\n    float weave = Weave(uv);\n    float seam = Seam(uv);\n\n    vec3 normal = Normal( pos );\n\n    const vec3 lightCol = vec3(1.8,1.6,1.3);\n    const vec3 lightDir = normalize(vec3(-3,.7,-.6));\n\n    float nl = dot(normal,lightDir);\n    float l = max( nl, .0 );\n//    float bl = max( mix(-nl,1.,.3), .0 ); // back light - including some scatter to prevent dark line where nl=0\n    vec3 scatteredLight = pow(albedo,vec3(2)) * smoothstep( .7, -1., nl ); // scattered light, favouring back-light\n    vec3 ambient = Ambient( normal ) * .3;\n\n    scatteredLight *= mix( .3, .7, weave );\n    ambient *= mix( 1.7, .3, weave );\n    l *= mix( 1.15, .85, weave );\n    \n    scatteredLight *= mix( .5, 1., seam );\n    \n    vec3 col = albedo;\n    col *= (l + scatteredLight)*lightCol + ambient;\n    \n    // todo: do GGX specular\n    col += lightCol * weave * pow(max(0.,dot(normalize(lightDir-ray),normal)),80.)*.2;\n    \n    // rim light - to make it feel a bit fuzzy\n    col += pow( dot(normal,ray)+1., 4. ) * (ambient+lightCol) * albedo *.5;\n\n    // atmospheric fog\n    col = mix( vec3(1), col, exp2( -t * airColourLog2 / 200. ) );\n\n    //if ( uv.x < .0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n    vec4 flagCol = vec4( col, 1. - mask );\n\n\n    fragColour.rgb = SkyColour(ray);\n    \n    // add flagpole\n    const float poleThickness = .05;\n    vec3 polePos = vec3(-poleThickness,1.1,0) - camPos; // centred on sphere at top of pole\n    \n    float distanceOfPoleAlongRay = dot( ray.xz, polePos.xz )/dot(ray.xz,ray.xz);\n    \n    float poleT = 1.;\n    bool intersection = false;\n    \n    // this is hacky and wrong, but it made the maths simpler and the error won't be obvious unless the camera gets close enough for a lot of perspective distortion\n    // basically I'm drawing a slice through the centre of the pole, rather than a 3D pole, for no reason other than I'm too lazy to look up/figure out the correct maths!\n    float poleOutlineSDF = length( vec2( length(ray.xz*distanceOfPoleAlongRay-polePos.xz), max(0.,ray.y*distanceOfPoleAlongRay-polePos.y) ) )  - poleThickness;\n    float halfFWidthPoleSDF = fwidth(poleOutlineSDF)*.5;\n    if ( poleOutlineSDF < halfFWidthPoleSDF )\n    {\n        poleT = distanceOfPoleAlongRay;\n        intersection = true;\n    \n        vec3 polePos = poleT*ray - polePos;\n    \n        vec3 poleNorm = polePos / poleThickness; // this is a hack\n        poleNorm.y = max(poleNorm.y,0.);\n    \n        poleNorm -= ray*sqrt(1.-min(1.,dot(poleNorm,poleNorm)));\n        poleNorm = normalize(poleNorm);\n    \n        vec3 poleCol = vec3(.6) * ( lightCol*max( dot( poleNorm, lightDir ), .0 ) + Ambient(poleNorm)*.5 );\n    \n        poleCol = mix( vec3(1), poleCol, exp2( -poleT * airColourLog2 / 200. ) );\n\n        fragColour.rgb = mix( poleCol, fragColour.rgb, linstep(-halfFWidthPoleSDF,halfFWidthPoleSDF,poleOutlineSDF) );\n        // todo - fake AA with rim-alpha\n    }\n\n    if ( !intersection || poleT > t )\n    {\n        fragColour.rgb = mix( fragColour.rgb, flagCol.rgb, flagCol.a );\n    }\n\n    // fake flat flagpole - I don't like this, I can replace it with a real one easily enough\n//    col = mix( col, vec3(cos(uv.x*50.0)),smoothstep(0.015,0.01,abs(uv.x+.01))*smoothstep(1.01,1.0,uv.y));\n\n    // tone mapping\n    fragColour.rgb = fragColour.rgb;\n\n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n\n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}