{
    "Shader": {
        "info": {
            "date": "1645138488",
            "description": "It turned out kind of artsy.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdfyz4",
            "likes": 12,
            "name": "Heaven & Hell",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "gurkanizmirligil",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "#define SURFACE_DIST .01\n#define MAX_DIST 50.0\n#define MAX_STEPS 100\n\n//most of this shader is derived from Inigo Quilez's SDFs\n\nfloat displacement(vec3 p)\n{\n    float stAnim = step(.7, sin(iTime * .5));\n     return sin(1.*p.x)*sin(1.*p.y)*sin(.3*p.z + iTime * 2.0 - iTime * 1.5 * stAnim);\n}\n\nfloat sdPyramid( vec3 p, float s)\n{\n  float stAnim = step(.7, sin(iTime * .5));\n  float angle = (100. - 75. * stAnim)*(sin(iTime * .1 + 3.14) + iTime * .1) + 7.;\n  float xx = p.x * cos(angle) - p.z * sin(angle);\n  float zz = p.x*sin(angle) + p.z*cos(angle);\n  p.xz = vec2(xx, zz);\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h + displacement(p) * .2;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n      float stAnim = step(.7, sin(iTime * .5));\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  float bf =  min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.5 * stAnim))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.5))+min(max(q.x,max(q.y,p.z)),0.0));\n  return bf;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    float stAnim = step(.7, sin(iTime * .5));\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return min(sdBoxFrame(q, vec3(1.5), .2), sdPyramid(q + vec3(0,.3,0), .4));\n}\n\n\n\n\nfloat GetDist( vec3 p)\n{\n  float stAnim = step(.7, sin(iTime * .5));\n  float ground = sdPlane(p, vec3(0.0,1.0,0.0), -4.2+ stAnim * 4545.45);\n  float bf = opRep(p, vec3(4.75 + stAnim * 5.));\n  float gr = opSmoothUnion(bf, ground, .5 );\n  float d = gr;\n  return d;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd){\n    float d0 = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro+d0*rd;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(dS < SURFACE_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 ld){\n   vec3 lightDir = ld;\n   vec3 l = normalize(lightDir);\n   vec3 n = GetNormal(p);\n   float dif = clamp(dot(n, l), 0., 1.0);\n   vec3 l2 = vec3(-l.x, l.yz);\n   float dif2 = clamp(dot(n, l2), 0., 1.0);\n   dif = mix(dif, dif2, .5);\n   float lightDistance = 5.0;\n   //shadow\n   //float d = raymarch(p+n*SURFACE_DIST*2.0, l);\n   //if(d<lightDistance) dif *= .5;\n   return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stAnim = step(.7, sin(iTime * .5));\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 bg = vec3(mix(.9, 0., uv.y), mix(0.2, 0.0, uv.y), 0.0);\n    if(stAnim > .5) bg = vec3(1.,.99,.95);\n    vec3 ro = vec3(0, 5., -5) - vec3(0, 0,iTime - iTime * .75 * stAnim) * ((-stAnim * 1.6) + 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = raymarch(ro, rd);    \n    vec3 p = ro + rd * d;\n    float anim = clamp(abs(sin(sin(iTime))) / (10. * sin(iTime * 3.) * sin(iTime* 3.)), .5, 4.);\n    float dif = GetLight(p, vec3(10. * sin(iTime * .1) - 5., 5., 5.));\n    float dif2 = GetLight(p, vec3(-15.,1. + stAnim * 10.,-5.));\n    dif = mix(dif * anim, dif2, stAnim);\n    float m = clamp(d / MAX_DIST ,0.,1.);\n    vec3 mat = vec3(100., 0, 0.) / 255.;\n    if(stAnim > .5) mat = vec3(1.5,1.5,1.5);\n    vec3 s = vec3(dif) * mat;\n    vec3 col = mix(s, bg,  m);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}