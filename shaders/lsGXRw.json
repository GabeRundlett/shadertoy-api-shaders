{
    "Shader": {
        "info": {
            "date": "1463835432",
            "description": "First attempt at ray marching a distance field ;)\n(Color blending is messed up...)",
            "flags": 0,
            "hasliked": 0,
            "id": "lsGXRw",
            "likes": 1,
            "name": "Ray Marching Distance Field test",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "cpcdoy",
            "viewed": 787
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100.0\nvec4 color = vec4(0, 0, 0.7, 0.0);\nfloat epsilon = 0.001;\nvec4 sphereColor = normalize(vec4(1.0, 1.0, 1.0, 1.0));\nvec3 lightPos = vec3(1.2, 5.0, 1.25);\nvec4 lightColor = normalize(vec4(1.0, 0.87, 0.93, 1.0));\nint colorIndex = 0;\n\nvec4 fog(vec4 color, float dist)\n{\n  float fog = 1.0 - exp(-dist*color.b);\n  return mix(color, vec4(0.5, 0.6, 0.7, 1.0), fog);\n}\n\nvec3 rotateY(vec3 v, float t)\n{\n\tfloat cost = cos(t); float sint = sin(t);\n\treturn vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nvec3 rotateX(vec3 v, float t)\n{\n\tfloat cost = cos(t); float sint = sin(t);\n\treturn vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t, float x, float y)\n{\n  vec3 p2 = rotateY(p, y);\n  vec3 p3 = rotateX(p2, x);\n  vec2 q = vec2(length(p3.xz)-t.x,p3.y);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b, float x, float y)\n{\n  colorIndex = 0;\n  vec3 p2 = rotateY(p, y);\n  vec3 p3 = rotateX(p2, x);\n  return length(max(abs(p3)-b,0.0));\n}\n\nfloat sphere_dist(vec3 p, float r, float x, float y)\n{\n  vec3 p2 = rotateY(p, y);\n  vec3 p3 = rotateX(p2, x);\n  return length(p3) - r;\n}\n\nfloat torusTwist(vec3 p, vec2 t, float x, float y)\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, t, x, y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n\tvec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat dist_func(vec3 p)\n{\n    float d6 = sdPlane(p); \n    //Repetition\n    //p.x = mod(p.x, 5.0) - 1.5;\n    //p.y = mod(p.y, 5.0) - 1.5;\n    //p.z = mod(p.z, 5.0) - 1.5;\n    float d1 = sphere_dist(p + vec3(0.87, -0.0, 0.0), 0.5, 0.7, 0.7);\n    float d2 = udBox(p + vec3(0.75, 0.5, 0.2), vec3(0.25), iMouse.y / 100.0, iMouse.x / 100.0);\n    float d3 = udBox(p + vec3(0.3, -1.2, 0.2), vec3(0.25), iMouse.y / 100.0, iMouse.x / 100.0);\n    //float d4 = torusTwist(p + vec3(1.1, -0.5, 0.2), vec2(0.25), 2.0, 2.0);\n    //float d7 = udBox(p + vec3(-0.85, -1.2, -0.9), vec3(0.25), 0.0, 0.0);\n    float d4 = min(udBox(p - vec3(0.8, 0.5, 0.2), vec3(0.6), 0.0, 0.0), sdTriPrism(p - vec3(0.8, 1.5, 0.2), vec2(0.8, 0.6)));\n    float d5 = sphere_dist(p + vec3(0.875, -0.45, 0.0), 0.3, 0.7, 0.7);\n    float r = min(d1, d2);\n    colorIndex = 0;\n    r = min(r , d3);\n    if (r == d3)\n        colorIndex = 1;\n    r = min(r , d4);\n    if (r == d4)\n        colorIndex = 2;\n    r = min(r , d5);\n  \tif (r == d5)\n        colorIndex = 0;\n    r = min(r , d6);\n    if (r == d6)\n        colorIndex = 2;\n    \n    return r;\n}\n\nfloat visibility(vec3 origin, vec3 dir)\n{\n\tfloat t = epsilon;\n    float amount = 1.0;\n\tfor (float i = 0.0; i < MAX_STEPS; i ++)\n\t{\n\t\tfloat d = dist_func(origin + dir * t);\n        \n        amount = min(amount, 32.0*d/t);\n        \n        t += clamp(d, 0.02, 0.1);\n        \n        if (d > 2.5)\n           break;\n        if (t < epsilon)\n           break;\n\t}\n    \n\treturn clamp(amount, 0.0, 1.0);\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.01;\n\tfloat t = stepSize;\n\tfloat oc = 0.0;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tfloat d = dist_func(p + n * t);\n\t\toc += t - d;\n\t\tt += stepSize;\n\t}\n \treturn min(max(oc, 0.0), 1.0);\n}\n\nvec3 get_normal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdist_func(p + vec3(h, 0, 0)) - dist_func(p - vec3(h, 0, 0)),\n\t\tdist_func(p + vec3(0, h, 0)) - dist_func(p - vec3(0, h, 0)),\n\t\tdist_func(p + vec3(0, 0, h)) - dist_func(p - vec3(0, 0, h))));\n}\n\nvec4 getColor()\n{\n    if (colorIndex == 0)\n        return sphereColor;\n    else if (colorIndex == 1)\n        return normalize(vec4(0.0, 1.0, 1.0, 1.0));\n   \telse if (colorIndex == 2)\n        return normalize(vec4(0.0, 1.0, 0.0, 1.0));\n    return normalize(vec4(1.0));\n}\n\nvec4 shade(vec3 p, vec3 dir)\n{\n    //Get normal\n    vec3 n = get_normal(p);\n    //Compute light direction\n    vec3 lightDir = normalize(lightPos - p);\n    \n\t//N dot L Phong lighting\n   \tfloat nDotL = dot(n, lightDir);\n    \n    //Reflect the dir according to the normal n\n    vec3 refl = reflect(n, dir);\n    //Specular lighting\n    float spec = pow(clamp(dot(refl, lightDir), 0.0, 1.0), 16.0);\n \n    //Visibility for shadows\n    float vis = visibility(p, lightDir);\n    \n    float dom = smoothstep(-0.1, 0.1, refl.y);\n \t\n    //Ambiant Occlusion\n    float AO = 1.0 - ao(p, n);\n    \n    //Ambient lighting\n\tfloat ambient = clamp( 0.5+0.5*n.y, 0.0, 1.0) / 10.0;\n    \n    vec4 currColor = getColor();\n    \n    //Resulting color\n    vec4 res = AO * currColor * lightColor * (ambient + //Ambient + AO\n        nDotL * vis);//Direct lighting + AO\n    \n    currColor = getColor();\n    return fog(res + AO * dom * visibility(p, refl) * vis * ambient + //Soft Shadows + AO\n        spec * vis * AO * currColor, 1.0); //Specular + AO\n}\n\nfloat raymarch(vec3 origin, vec3 dir)   \n{\n    float t = 0.0;\n    for (float steps = 0.0; steps < MAX_STEPS; steps++)\n    {\n        vec3 p = origin + t * dir;\n        //float dist = min(sdPlane(p + vec3(0.5, 1, 0), vec4(0, 1, 0, 0)), \n        float dist = dist_func(p);//);\n        if (dist < epsilon)\n        {\n            color = shade(p, dir);\n            return 0.0;\n        }\n        t += dist;\n    }\n\tvec2 uv = (gl_FragCoord.xy * 2.0) / (iResolution.xy - 1.0);\n    color = texture(iChannel0, vec3(uv, 1.0));\n    return t;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    \n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\n\tfloat time = 15.0 + 2.0 * iTime;\n\n\t// camera\t\n\tvec3 ro = vec3(-0.5+2.5*cos(0.1*time + 6.0*mo.x), 2.0 + 10.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x));\n    \n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\t\n   \t// camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,2.0));\n\n    raymarch(ro, rd);\n    \n    //Gamma correction (1/2.2)\n    color = pow( color, vec4(vec3(0.4545), 1.0));\n    \n\tcolor = mix(vec4(.5), mix(vec4(dot(vec4(.2125, .7154, .0721, 1.0), color*1.0)), color*1.3, 1.3), 1.1);\n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}