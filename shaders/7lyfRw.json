{
    "Shader": {
        "info": {
            "date": "1664344018",
            "description": "doughnut.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lyfRw",
            "likes": 3,
            "name": "My first scene",
            "published": 3,
            "tags": [
                "3d",
                "struct",
                "doughnut"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "//scene setup\n\nconst Material myMat = Material(\n    vec3(1,0.5,0), //base color\n    vec3(1,0.5,0), //ambient color\n    vec3(1,0.5,0), //diffuse color\n    vec3(1,1,1), //specular color\n    0.5, //ambient amount\n    1.0, //diffuse amount\n    0.1, //specular amount\n    1.0  //smoothness\n);\n\nFog myFog = Fog(10.0,20.0,vec3(0.6));\n\nPointLight myLight = PointLight(vec3(0,20,0),vec3(1));\n\nSphere mySphere = Sphere(vec3(0,0,10), vec3(0), vec3(0,0,10), 2.0, myMat);\n\nTorus myTorus = Torus(vec3(0,0,0), vec3(PI/2.0,0,0), vec3(0,0,0), 2.0, 0.8, myMat);\n\n//main drawing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float time = iTime*0.1;\n    Camera cam = createCamera(fragCoord.xy, iResolution.xy, vec3(-sin(time)*5.0,3,-cos(time)*5.0), vec3(sin(time)/10.0 + 0.5,time,0), 1.0);\n    vec4 col = vec4(0,0,0,-1);\n    \n    //set depth\n    col.w = torIntersect(cam.ray, myTorus);\n    //col.w = sphIntersect(cam.ray, mySphere);\n    if (col.w >= 0.0){ //draw the hit object\n        vec3 drawnPoint = col.w*cam.ray.direction + cam.ray.origin;\n        vec3 normal = torNormal(drawnPoint, myTorus);\n        //vec3 normal = normalize(drawnPoint - mySphere.origin);\n        vec3 lightDirection = myLight.origin - drawnPoint;\n        Material mat = mySphere.mat;\n        \n        vec3 icingColor = vec3(0.7,0.7,0.6);\n        vec3 baseColor = vec3(0.5,0.25,0) - 0.15*voronoi3d(rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin));\n        \n        float icingInterpolant = voronoi3d(rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin)*2.0) + 2.0*rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin).z + 0.5;\n        vec3 b = mix(icingColor, baseColor, smoothstep(0.0, 0.01, icingInterpolant));\n        normal = mix(roundNormal(0.6, icingInterpolant, normal), normal, smoothstep(0.0, 0.2, icingInterpolant));\n\n        float cracks = voronoi3dedges(rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin)*10.0)*0.1;\n\n        float d = clamp(dot(normal,normalize(lightDirection))*mat.diffuse,0.0,1.0);\n        float s;\n        if (icingInterpolant < 0.02){ //icing\n            s = pow(max(dot(reflect(cam.ray.direction,normal),normalize(lightDirection)),0.0),mat.smoothness + cracks*10.0)*(mat.specular + cracks*10.0);\n        } else { //dough\n            s = pow(max(dot(reflect(cam.ray.direction,normal),normalize(lightDirection)),0.0),mat.smoothness)*mat.specular;\n        }\n        float a = mat.ambient;\n        col.rgb = b*a + b*d + mat.specularColor*s;\n        //col.rgb = normal;\n        col.rgb = mix(col.rgb,myFog.color,smoothstep(myFog.start, myFog.end, col.w));\n    \n    } else { //draw the sky\n    \n        float interpolant = dot(cam.ray.direction,vec3(0,1,0));\n        vec3 water = vec3(0.3,0.4,0.8);\n        vec3 sky = vec3(0,0.6,1);\n        vec3 haze = vec3(0.9);\n        if (interpolant < 0.0) {\n            col.rgb = mix(haze, water, -interpolant);\n        } else {\n            col.rgb = mix(haze, sky, interpolant);\n        }\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.14;\n\nstruct Material {\n    vec3 baseColor;\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float ambient;\n    float diffuse;\n    float specular;\n    float smoothness;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Fog {\n    float start;\n    float end;\n    vec3 color;\n};\n\nstruct Sphere {\n    vec3 origin;\n    vec3 rotation;\n    vec3 pivot;\n    float radius;\n    Material mat;\n};\n\nstruct Torus {\n    vec3 origin;\n    vec3 rotation;\n    vec3 pivot;\n    float width;\n    float radius;\n    Material mat;\n};\n\nstruct PointLight {\n    vec3 origin;\n    vec3 color;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n};\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    point *= mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y * 2.0, frustumLength);\n    Ray ray = Ray(rotate3d(uv,camRot,vec3(0)) + cameraPos, rotate3d(normalize(uv), camRot, vec3(0)));\n    \n    return Camera(cameraPos, ray);\n}\n\n// https://www.shadertoy.com/view/4d2XWV\n// sphere of size ra centered at point ce\n// returns x = first intersect, y = second intersect\nfloat sphIntersect(in Ray ray, in Sphere sph){\n    vec3 oc = ray.origin - sph.origin;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius*sph.radius;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0; // no intersection\n    h = sqrt( h );\n    return -b-h;\n}\n\nvec3 sphNormal(in vec3 pos, in Sphere sph){\n    pos -= sph.origin; \n    return normalize(pos);\n}\n\n// https://www.shadertoy.com/view/4sBGDy\n// input: ray origin, ray direction, torus origin, torus width, torus radius\nfloat torIntersect(in Ray ray, in Torus tor){\n    vec3 ro = ray.origin - tor.origin;\n    float po = 1.0;\n    \n    vec3 rd = ray.direction = rotate3d(ray.direction,-tor.rotation,vec3(0));\n    ro = rotate3d(ray.origin,-tor.rotation,tor.pivot);\n    \n    float Ra2 = tor.width*tor.width;\n    float ra2 = tor.radius*tor.radius;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        return t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    if (t == 1e20) t = -1.0;\n    return t;\n}\n\nvec3 torNormal( in vec3 pos, in Torus tor){\n    pos -= tor.origin; \n    pos = rotate3d(pos,-tor.rotation,tor.pivot);\n    vec3 normal = normalize(pos*(dot(pos,pos) - tor.radius*tor.radius - tor.width*tor.width*vec3(1,1,-1)));\n    return rotate3d(normal,tor.rotation,tor.pivot);\n}\n\n//given a radius, distance, and normal, bends the normal to add a circular bevel\nvec3 roundNormal(float r, float d, vec3 normal){\n    if (d < -r) return vec3(0,1,0);\n    float b = d*d + 2.0*d*r;\n    float m = (d+r)/sqrt(abs(b));\n    float l = sqrt(d*d*(m*m + 1.0));\n    vec2 v = sign(d)*vec2(-m*d,d)/l;\n    vec2 a = normalize(normal.xz)*v.x;\n    vec3 x = vec3(-a.y,v.y,-a.x);\n    return x/length(x);\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat voronoi3d(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = min(n,distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv));\n            }\n        }\n    }\n    return n;\n}\n\nfloat powDist(vec3 a, vec3 b, float p){\n    vec3 d = abs(a-b);\n    return pow(d.x,p) + pow(d.y,p) + pow(d.z,p);\n}\n\nfloat voronoi3dedges(vec3 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                float d = powDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv,3.0);\n                if (d < d1) {\n                    d2 = d1;\n                    d1 = d;\n                } else if (d < d2){\n                    d2 = d;\n                }\n            }\n        }\n    }\n    return abs(d1-d2);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}