{
    "Shader": {
        "info": {
            "date": "1620344228",
            "description": "How to render wang-tile style auto tiles with interlocking square gradients.\nVisit me on twitch: www.twitch.com/kanjicoder",
            "flags": 0,
            "hasliked": 0,
            "id": "7sSSWm",
            "likes": 3,
            "name": "AutoTile Basics",
            "published": 3,
            "tags": [
                "rule",
                "auto",
                "autotile",
                "ruletile",
                "autotiling"
            ],
            "usePreview": 0,
            "username": "DEKTEN",
            "viewed": 287
        },
        "renderpass": [
            {
                "code": "//:----------------------------------------------------------://\n//:                                                          ://\n//:              www.twitch.com/kanjicoder                   ://\n//:                                                          ://\n//:----------------------------------------------------------://\n//:##########################################################://\n//:                                                          ://\n//: Ever wonder how to do wang-tile style auto tiling        ://\n//: with shader code? Here is the basic math to get          ://\n//: you started. Once you've got this figured out,           ://\n//: you can map interesting patterns onto the interlocking   ://\n//: gradient tiles.                                          ://\n//:                                                          ://\n//: If you want to see a more impressive demo of this        ://\n//: you can check out my heroku server demo:                 ://\n//:                                                          ://\n//: https://d3m0.herokuapp.com/                              ://\n//: Sroll down to \"Exhibit #22\"                              ://\n//: Note: Server is freely hosted on heroku,                 ://\n//:       so might take 30 seconds to load page.             ://\n//:                                                          ://\n//:##########################################################://\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //: Pretend the entire screen is one tile for this  -----://\n    //: example code. Center is at [0,0] , top left is  -----://\n    //: at [-1,-1] and bottom right is at [+1,+1]       -----://\n    vec2 uvc   = (fragCoord -0.5*iResolution.xy)/iResolution.y;\n         uvc.y =( 0.0 - uvc.y ); //:Invert Y axis\n\n//+----------------------------------------------------------+//\n//| What is the current wang-tile touching mask for          |//\n//| the tile you are drawing. In this example,               |//\n//| pretend the entire screen is one tile.                   |//\n//| TIL == Your One Tile                                     |//\n//|          +---+                                           |//\n//|          |y_0|                                           |//\n//|      +---+---+---+      0|1  0|1  |  0|1  0|1            |//\n//|      |x_0|TIL|x_1| -->  ___  ___  |  ___  ___            |//\n//|      +---+---+---+      X_0  X_1  |  Y_0  Y_1            |//\n//|          |y_1|                                           |//\n//|          +---+                                           |//\n//|                                                          |//\n//| toutang means : Touching Tangent                         |//\n//|                                                          |//\n//| [-1,-1]                                                  |//\n//|     +-------------+                                      |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     |     0.0     | <--[ TIL ] www.twitch.com/kanjicoder |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     +-------------+                                      |//\n//|                 [+1,+1]                                  |//\n//|                                                          |//\n//+----------------------------------------------------------+//\n\n    //:Animate the touching value of your tile.         -----://\n    //:Emulating all different combinations of which    -----://\n    //:neighbors can exist above,below,left,and right:  -----://\n\n    uint toutang=(uint(int(mod(iTime,16.0))));\n\n//+----------------------------------------------------------+//\n//|   +-----------------+ If( touself ==BINARY[ 1000 ] )THEN:|//\n//|   |\\\\     y_0     //|                                    |//\n//|   |  \\\\         //  |   We are in the x_0 pie slice.     |//\n//|   |    \\\\     //    |                                    |//\n//|   |      \\\\ //      | If( touself ==BINARY[ 1010 ] )THEN:|//\n//|   |x_0  ( 0.0 )  x_1|                                    |//\n//|   |      // \\\\      |   I fucked up the formula because  |//\n//|   |    //     \\\\    |   only ONE_BIT in touself should   |//\n//|   |  //         \\\\  |   have been set.                   |//\n//|   |//     y_1     \\\\|                                    |//\n//|   +-----------------+                                    |//\n//|   BITS[  0   0   0   0  ]                                |//\n//|   SIDE[ x_0 x_1 y_0 y_1 ]     www.twitch.com/kanjicoder  |//\n//|                                                          |//\n//|   touself means: \"TOUching SELF\"                         |//\n//+----------------------------------------------------------+//\n\n    //:Figure out which pie slice the pixel of  -------------://\n    //:your tile belongs to and set that bit:   -------------://\n    #define A abs\n    #define U uint\n    #define X uvc.x\n    #define Y uvc.y\n    U touself =( U(0)\n    | (( (X <= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 3)\n    | (( (X >= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 2)\n    | (( (Y <= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 1)\n    | (( (Y >= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 0)\n    );;\n    #undef A\n    #undef U\n    #undef X\n    #undef Y\n\n    //:If we are on a pie slice that is touching a           ://\n    //:neighbor, use the connected gradient(congrad).        ://\n    //:If we are on a pie slice that is __NOT__              ://\n    //:touching a neighbor, use walled-off gradient(walgrad).://\n    float walgrad = float( max( abs(uvc.x),abs(uvc.y) ) );\n    float congrad = float( min( abs(uvc.x),abs(uvc.y) ) );\n    float tougrad = (( touself & toutang )>=uint(1)) \n                 ? congrad   //:TRUE : Connected  Gradient\n                 : walgrad ; //:FALSE: Walled Off Gradient\n\n    //: Output to screen\n    fragColor = vec4(tougrad,tougrad,tougrad,1.0);\n\n} //:[mainImage]:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<://",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}