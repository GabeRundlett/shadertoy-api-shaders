{
    "Shader": {
        "info": {
            "date": "1552754550",
            "description": "Ray tracing tutorial - step 7\nMultiple reflections",
            "flags": 0,
            "hasliked": 0,
            "id": "wd2XRR",
            "likes": 7,
            "name": "RayTracing tutorial - step 7",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "BrunoLevy",
            "viewed": 951
        },
        "renderpass": [
            {
                "code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-6;\n\n// The viewing parameters\n// Gathers all parameters needed to launch primary rays\nstruct Camera {\n    vec3 Obs;    // The position of the observer\n    vec3 View;   // Unit vector, points to the target\n    vec3 Up;     // Unit vector, vertical direction\n    vec3 Horiz;  // Unit vector, horizontal direction\n    float H;     // Screen height in pixels\n    float W;     // Screen width in pixel\n    float z;     // offset of the screen along View\n};\n\n// \\brief A ray, in parametric form. \nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n// \\brief Initializes a Camera\n// \\param[in] Obs the position of the observer\n// \\param[in] Target the point that will be in the center\n// \\param[in] aperture the aperture angle in degrees\n// \\return the initialized Camera\nCamera camera(in vec3 Obs, in vec3 Target, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(Target - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\n// \\brief Launches a primary Ray\n// \\param[in] C the Camera\n// \\param[in] XY the pixel coordinates in [0,W-1] x [0,H-1]\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\n// \\brief A sphere, defined by its center and radius\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n// \\brief Material gathers all shading properties\nstruct Material {\n    vec3 Kd;       // diffuse color\n    vec3 Ke;       // emissive color\n    vec3 Kr;       // reflective material\n    float checker; // checkerboard size\n    vec3 Ks;       // specular\n    float s;       // specular factor\n};\n\n// \\brief Shorthand for the zero vector\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\n\n// \\brief Creates a diffuse material\n// \\param[in] Kd the diffuse color\n// \\return the created Material\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, zero3, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief Creates a light (emissive) material\n// \\param[in] Ke the color of the light\n// \\return the created Material\nMaterial light(in vec3 Ke) {\n   return Material(zero3, Ke, zero3, 0.0, zero3, 0.0);\n}\n\n// \\brief Creates a mirror material\n// \\param[in] Kd the diffuse color\n// \\param[in] Kr the reflection coefficient\n// \\return the created Material\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(\n     Kd, zero3, Kr, 0.0, vec3(1.0, 1.0, 1.0), 30.0\n   );\n}\n\n// \\brief Creates a shiny material\n// \\param[in] Kd the diffuse color\n// \\param[in] Ks the specular coefficient\n// \\return the created Material\nMaterial shiny(in vec3 Kd, in vec3 Ks) {\n   return Material(Kd, zero3, zero3, 0.0, Ks, 30.0);\n}\n\n// \\brief Creates a checkerboard material\n// \\param[in] Kd the diffuse color\n// \\param[in] sz size of the checkers\n// \\return the created Material\nMaterial checkerboard(in vec3 Kd, in float sz) {\n   return Material(Kd, zero3, zero3, sz, zero3, 0.0);\n}\n\n// \\brief An Object, with a shape (Sphere) and a Material\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\n// \\brief The scene is stored in a global array\nObject scene[23];\n\n// \\brief Initializes the scene\nvoid init_scene() {\n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      mirror(vec3(0.2, 0.5, 0.2), vec3(0.5, 0.5, 0.5))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.0, 0.0, -10000.0),9999.5),\n      checkerboard(vec3(1.0, 0.2, 0.5), 0.5)\n   );\n\n   scene[2] = Object(\n      Sphere(vec3(1.0, 0.0, 1.0),0.02),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n\n   for(int i=0; i<20; ++i) {\n     float beta = float(iFrame)/30.0 + float(i)*6.28/19.0;\n     float s = sin(beta);\n     float c = cos(beta); \n\n     scene[i+3] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n        mirror(vec3(1.0, 0.7, 0.7), vec3(0.3, 0.3, 0.3))\n     );\n   }\n}\n\n// \\brief Computes a Ray Sphere intersection\n// \\param[in] R the Ray\n// \\param[in] S the Sphere\n// \\param[out] t the intersection parameter\n// \\retval true if there was an intersection\n// \\retval false otherwise\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\n// \\brief Computes a reflected Ray\n// \\param[in] I the incident Ray\n// \\param[in] P the point at which the reflection occurs\n// \\param[in] N the normal at P\n// \\return the reflected Ray\nRay reflect_ray(in Ray I, in vec3 P, in vec3 N) {\n   return Ray(\n      P,\n      -2.0*dot(N,I.Dir)*N + I.Dir\n   );\n}\n\n// \\brief Tests whether a Ray is in shadow\n// \\param[in] R a Ray that connects a point to a lightsource\n// \\retval true if the point is in shadow w.r.t. the lightsource\n// \\retval false otherwise\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\n// \\brief Computes the lighting\n// \\param[in] P the intersection point\n// \\param[in] N the normal to the intersected surface at P\n// \\param[in] material the material\n// \\param[in] Ray the incident Ray\n// \\return the computed color\nvec3 lighting(\n   in vec3 P, in vec3 N, in Material material, in Ray R\n) {\n\n   // If it is a lightsource, then return its color\n   // (and we are done) \n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   // Compute the influence of all lightsources\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n  \n           // Diffuse lighting\n           float lamb = max(0.0, dot(E,N) / length(E));\n           vec3 Kd = material.Kd;\n           if(material.checker != 0.0 && \n              sin(P.x/material.checker)*\n              sin(P.y/material.checker) > 0.0) {\n               Kd = vec3(1.0, 1.0, 1.0) - Kd;\n           }\n           result += lamb * Kd * scene[i].material.Ke;\n\n           // Specular lighting\n           if(material.Ks != zero3) {\n               vec3 Er = 2.0*dot(N,E)*N - E;\n               vec3 View = R.Origin - P;\n               float spec=max(dot(Er,View),0.0);\n               spec /= sqrt(dot(Er,Er)*dot(View,View));\n               spec = pow(spec, material.s);\n               result += \n                  spec * material.Ks * scene[i].material.Ke;\n           }\n         }\n      }\n   }\n\n   return result;\n}\n\n// \\brief Computes the nearest intersection along a Ray\n// \\param[in] R the ray\n// \\param[out] P the intersection point\n// \\param[out] N the normal to the intersected surface at P\n// \\param[out] material the material of the intersected object\nbool nearest_intersection(\n   in Ray R, \n   out vec3 P, out vec3 N, out Material material\n) {\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON \n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n   return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   // Yes, it is a bit stupid to call this for each pixel,\n   // but well, does not cost that much...\n   init_scene();\n\n   float beta = float(iFrame)/150.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera (and make it orbit around the\n   // origin)\n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.0),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n\n   // Lauch the primary ray that corresponds to this pixel\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n   vec3 P;  // Current intersected point\n   vec3 N;  // Normal to the intersected object at P\n   Material material; // Material of the intersected object\n \n   // Compute up to 5 ray bounces\n   vec3 Kr_cumul = vec3(1.0, 1.0, 1.0);\n   for(int k=0; k<5; ++k) {\n       if(nearest_intersection(R, P, N, material)) {\n          fragColor.rgb += Kr_cumul * lighting(P,N,material,R);\n          if(material.Kr == zero3) {\n              break;\n          }\n          Kr_cumul *= material.Kr;\n          R = reflect_ray(R, P, N);\n       } else {\n          fragColor.rgb += Kr_cumul * vec3(0.5, 0.5, 1.0);\n          break;\n       }\n   }  \n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}