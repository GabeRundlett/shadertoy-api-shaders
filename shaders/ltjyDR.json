{
    "Shader": {
        "info": {
            "date": "1508278320",
            "description": "code golfing fork of\nhttps://www.shadertoy.com/view/XsXfRH\ncould make it easier to swivel-permute the values of noiseVcDx()\n, to a point where it may return a mat4 instead of a vec4,\nthat makes it a \"noise43\" with derivatives?",
            "flags": 0,
            "hasliked": 0,
            "id": "ltjyDR",
            "likes": 4,
            "name": "noiseVal13dx Crunch",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "perlin",
                "analytic",
                "automatic",
                "dervivative",
                "differentiation"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 583
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/ltjyDR\n//hash 3d v13 wihth derivatives (iq) \n\n//parent: https://www.shadertoy.com/view/XsXfRH\n\n/*\nComputes the analytic derivatives of a 3D Value Noise. \nThis can be used for example to compute normals to \n3d rocks based on Value Noise \nwithout approximating the gradient via 4* or 6* sampling\nsee: https://www.shadertoy.com/view/XttSz2)\n\nValue    Noise 2D, dx: https://www.shadertoy.com/view/4dXBRH\nGradient Noise 2D, dx: https://www.shadertoy.com/view/XdXBRH\nValue    Noise 3D, dx: https://www.shadertoy.com/view/XsXfRH\nGradient Noise 3D, dx: https://www.shadertoy.com/view/4dffRH\nValue    Noise 2D    : https://www.shadertoy.com/view/lsf3WH\nValue    Noise 3D    : https://www.shadertoy.com/view/4sfGzS\nGradient Noise 2D    : https://www.shadertoy.com/view/XdXGW8\nGradient Noise 3D    : https://www.shadertoy.com/view/Xsl3Dl\nSimplex  Noise 2D    : https://www.shadertoy.com/view/Msf3WH\n*/\n\n//open question; is there any good replacement for hash()\n//especially the one that takes a mat3 and returns a vec3;\n\n // replace this by something better\nfloat hash(vec3 p)\n{p=50.0*fract(p*.3183099+vec3(.71,.113,.419))\n;return fract(p.x*p.y*p.z*(p.x+p.y+p.z))*2.-1.;}\n\n//any better way to mix the above and the below function?\nvec3 hash(mat3 p){return vec3(hash(p[0]),hash(p[1]),hash(p[2]));}\n\n\n// return value noise (cubic sampling) as .x\n//, and analytic 1st_derivatives (difference to nearby x) as .yzw\nvec4 noiseVcDx(vec3 x){vec3 p=floor(x),w=fract(x)   \n#if 1\n ;vec3 u=w*w*w*(w*(w*6.-15.)+10.)// quintic hermite interpolation (3*1*1 binomial)  \n ,n=30.*w*w*(w*(w-2.)+1.)\n//higher degree hermites can have FASTER gradient descents\n//for newer hardware with longer pipelines, with more iterations.\n#else\n ;vec3 u=w*w*(3.-2.*w)//cubic hermite interpolation (2*1 binomial)\n ,n=6.*w*(1.-w)//likely faster on older hardware, with less iterations\n#endif   \n;float a=hash(p+vec3(0))//smallest corner coefficient\n,      h=hash(p+vec3(1))//largest  corner coefficient\n;vec3 b=hash(   mat3(1)+mat3(p,p,p))//3 corners that are adjacent to smallest corner\n,     c=hash(1.-mat3(1)+mat3(p,p,p))//3 corners that are adjacent to largest  corner//8 cube corners\n,k=b-a,l=a-b.xyx-b.yzz+c.zxy,v=((l*u).zxy+k)*u//+9 coefficients in 3 vectors.\n;b-=c;h+=b.x+b.y+b.z-a//modify b to modify h\n;return vec4(a+v.x+v.y+v.z+h*u.x*u.y*u.z, n*(l*u.yzx+l.zxy*u.zxy+h*u.yzx*u.zxy+k) );}\n//automatic differentiation by iq, crunched by ollj.\n\n//===============================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\n        vec4 n = noiseVcDx( 12.0*pos );\n        col = 0.5 + 0.5*((p.x>0.0)?n.yzw:n.xxx);\n\t\t\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\t//fragColor = vec4(col, 1.0 );\n\tfragColor = vec4(1.-col, 1.0 );//inverse universe\n}\n\n/*\n The MIT License\n Copyright Â© 2017 Inigo Quilez\nPermission is hereby granted, free of charge\n, to any person obtaining a copy of this software \nand associated documentation files (the \"Software\")\n, to deal in the Software without restriction\n, including without limitation the rights to use\n, copy, modify, merge, publish, distribute, sublicense\n, and/or sell copies of the Software\n, and to permit persons to whom the Software is furnished to do so\n, subject to the following conditions: \nThe above copyright notice and this permission notice \nshall be included in all copies or substantial portions \nof the Software. THE SOFTWARE IS PROVIDED \"AS IS\"\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED\n, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\n, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT\n. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS \nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY\n, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE\n, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE \nOR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}