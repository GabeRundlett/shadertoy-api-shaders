{
    "Shader": {
        "info": {
            "date": "1686040844",
            "description": "Draw your own zen-ish garden from water and stone. Keys:\nL/W select Land/Water drawing modes. When neither is active, make waves.\nI/F: toggle isolines/false color.\nR/C: randomize/clear landscape.\nD: hold to damp waves.\nM/N/H: other visualization options.",
            "flags": 48,
            "hasliked": 0,
            "id": "mlVSRW",
            "likes": 8,
            "name": "The Mechanical Zen Gardener",
            "published": 3,
            "tags": [
                "simulation",
                "nature",
                "calm"
            ],
            "usePreview": 0,
            "username": "Matthias_H",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "// Created by Matthias_H, 2023.\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Usage: Draw with mouse on water to cause ripples/waves.\n// Keys: \n// W = [W]ater mode (draw water areas), \n// L = [L]and mode (draw land areas),\n// K = [K]lear all waves,\n// C = [C]lear all land (water everywhere),\n// S = hold for [S]eismic excitation, \n// D = hold to [D]amp (apply viscous attenuation),\n// R = [R]andomize,\n// M = toggle between 2-color and textured [M]ode,\n// F = toggle [F]alse color for surface slope.i\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // This main file just displays the compute buffer in various more or less \n    // fancy ways, depending on the chosen mode\n\n    bool displaymode = texelFetch(iChannel2, ivec2(77, 2), 0).x > 0.;\n    bool truecolor = texelFetch(iChannel2, ivec2(70, 2), 0).x > 0.;\n    bool falsecolor = truecolor;//!truecolor;\n    bool height = texelFetch(iChannel2, ivec2(72, 2), 0).x > 0.;\n    bool isolines = texelFetch(iChannel2, ivec2(73, 2), 0).x > 0.;\n    bool wetness = (texelFetch(iChannel2, ivec2(78, 2), 0).x > 0.);\n    // Draw mode in a channel of buffer\n    float drawmode = texelFetch(iChannel0, ivec2(0,0), 0).a;\n    \n    bool set_water = drawmode>0.0;\n    bool set_land = drawmode<0.0;    \n    \n    float pos = texture(iChannel0, uv).r;\n\n    // Numerical gradient / derivatives along x and y direction \n    // -explicit forward differences seem to work better than dFdx() and dFdy()     \n    vec2 gradient = (vec2(textureOffset(iChannel0, uv, ivec2(1,0)).r,\n    textureOffset(iChannel0, uv, ivec2(0,1)).r)-pos)/wavescale;\n    \n    float wet = texture(iChannel0, uv).a;\n    if (wetness) wet = -1.0e6;\n    \n    float shadingcosine = 2.0*(smoothstep(-1.0,1.0,textureOffset(iChannel0, uv, ivec2(1,0)).b-texture(iChannel0, uv).b)-0.5)\n    +5.0*smoothstep(0.0,2.0,texture(iChannel0, uv).b)*(textureOffset(iChannel1, uv, ivec2(1,0)).r-texture(iChannel1, uv).r);\n    \n    // Is it a land or water pixel?\n    float land = texture(iChannel0, uv).b;\n        if (land>pos && land > 0.0)\n        {\n        gradient *= 0.0;\n        }\n    const float isoscale = 5.0;    \n    vec4 neigh = vec4(textureOffset(iChannel0, uv, ivec2(1,0)).b,\n    textureOffset(iChannel0, uv, ivec2(0,1)).b,\n    textureOffset(iChannel0, uv, ivec2(0,-1)).b,\n    textureOffset(iChannel0, uv, ivec2(-1,0)).b)/isoscale;\n    bool isoline = isnotequal(neigh);\n    if (!isoline) isoline = posi(neigh.x) != posi(land/isoscale);\n    // Compute a fake \"z component\" of a normal vector \n    // with x and y components (dx,dy), and clamp to zero.\n    float cosine = max(0.0,cos(3.0*length(gradient)));\n    \n    // False color display: Encode 2D slope in R and B channel\n    fragColor = vec4(gradient + 0.5, (pos>land)?1.0:(exp(wet)),1.0);\n    \n    if (!falsecolor) // Shade waves using fake cosine\n    {\n        fragColor = vec4(0.5*cosine,0.5*cosine,0.995*cosine*((pos>land)?1.0:(exp(wet))),1.0);\n\n    }\n    \n    \n    if (!displaymode)  // uhm, let's call this the \"photorealistic\" mode :-P\n    {\n        // Encode 2D slope in R and B channel\n        fragColor.b = 0.5;\n        if (!falsecolor)\n            fragColor.b = 0.5*cosine;\n        fragColor.rgb *= 0.35;\n        // Distorted texture lookup by slope of water surface\n        fragColor = mix(fragColor, texture(iChannel1,uv+0.1*gradient),0.5*(1.0+((pos>land)?0.0:(1.0-exp(min(0.0,wet))))));\n        //fragColor = mix(fragColor, texture(iChannel1,uv+0.1*gradient),0.5);\n        \n        fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),\n        smoothstep(0.0,1.0,(land - 20.0 - (5.0*megarandomsinusoid(10.0*uv,20.0,15.0)+10.0+30.0*texture(iChannel1, uv).r))));\n        \n        if (land>pos && wet < -100.0)\n        {\n            //fragColor = texture(iChannel1,uv);\n        }\n\n        if (pos>land || land< 0.0)\n        {\n        float depth = max(0.0,0.0-land);\n        fragColor *= 1.5*vec4(pow(0.97,depth),pow(0.995,depth),pow(0.99,depth),1.0)*(1.0+0.2*shadingcosine);\n        }\n        else\n        //if (land>pos) \n        fragColor *= 1.5* (1.0+shadingcosine);\n    } \n    \n    if (set_land || set_water) // indicate drawing mode by blinking land or water\n    {\n        bool blink = (land>pos) ^^ set_water;\n        bool highlight = mod((fragCoord.x+fragCoord.y)/15.0+1.0*iTime,2.0)>1.0;\n        //if (isolines) highlight = highlight ^^ isoline;\n        //highlight = mod(land/2.0,2.0)>1.0;\n        if (blink && highlight)\n        fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),0.1+0.1+0.0*sign(sin(15.0*iTime)));\n    }\nif (( isolines || set_land || set_water) && isoline )\n        fragColor = mix(fragColor,vec4(1.0,1.0,1.0,1.0),0.2);\n    if (height)\n    {\n    if (land<0.0) \n    fragColor.rg *= 1.0+0.0*exp(land/40.0);\n    else\n    fragColor.rgb = mix(fragColor.rgb,vec3(1.0,1.0,1.0),1.0-exp(-land/40.0));\n}\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Matthias_H, 2023.\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Usage: Draw with mouse on water to cause ripples/waves.\n// Keys: \n// W = [W]ater mode (draw water areas), \n// L = [L]and mode (draw land areas),\n// K = [K]lear all waves,\n// C = [C]lear all land (water everywhere),\n// S = hold for [S]eismic excitation, \n// D = hold to [D]amp (apply viscous attenuation),\n// R = [R]andomize,\n// M = toggle between 2-color and textured [M]ode,\n// F = toggle [F]alse color for surface slope.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get keyboard flags\n\n    bool clear_waves = texelFetch(iChannel1, ivec2(75, 0), 0).x > 0.;\n    bool damp_waves = texelFetch(iChannel1, ivec2(68, 0), 0).x > 0.;\n    bool clear_land = texelFetch(iChannel1, ivec2(67, 1), 0).x > 0.;\n    bool seismic = texelFetch(iChannel1, ivec2(83, 0), 0).x > 0.;\n    bool randomize = texelFetch(iChannel1, ivec2(82, 1), 0).x > 0.;\n        \n    vec2 uv = fragCoord / iResolution.xy; // Texture coordinate for this fragment\n\n    // Retrieve pixel variables from previous iteration (Buffer A in iChannel0).\n    // Meaning of color channels:\n    // r: position, g: velocity, b: land, a: flags/state\n    vec4 oldvalue = textureOffset(iChannel0, uv, ivec2(0,0));\n    float pos = oldvalue.r;\n    float vel = oldvalue.g * (damp_waves?0.95:0.997);  \n    \n    float land = oldvalue.b;\n    //vel *= (pos > land && land > 0.0)?0.995:1.0;\n    vel *= (pos < land && land > 0.0)?exp(0.05*(pos-land)):1.0;\n    \n    // Texel (0,0).a: drawmode;\n    float drawmode = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    float boredom = texelFetch(iChannel0, ivec2(1, 0), 0).a;\n    float init = texelFetch(iChannel0, ivec2(2, 0), 0).a;\n    float wet = texture(iChannel0, uv).a;\n    float wetAvg = (textureOffset(iChannel0, uv, ivec2(-1,0)).a \n    +textureOffset(iChannel0, uv, ivec2(1,0)).a \n    +textureOffset(iChannel0, uv, ivec2(0,1)).a \n    +textureOffset(iChannel0, uv, ivec2(0,-1)).a )/4.0;\n    if (fragCoord.x>0.0 && fragCoord.y>0.0) {\n        wet = (pos>land)?0.0:(mix(wet,wetAvg,0.4)-0.005/iFrameRate*60.0);\n        }\n        \n    \n    if (texelFetch(iChannel1, ivec2(87, 1), 0).x > 0.) // W (ater)\n    {\n        if (drawmode > 0.0)\n        drawmode = 0.0;\n        else \n        drawmode = 1.0;\n    }\n    if (texelFetch(iChannel1, ivec2(76, 1), 0).x > 0.) // L (and)\n    {\n        if (drawmode < 0.0)\n        drawmode = 0.0;\n        else \n        drawmode = -1.0;\n\n    }\n    if (texelFetch(iChannel1, ivec2(80, 1), 0).x > 0.) // P (ush)\n        drawmode = 0.0;\n        \n    bool set_water = drawmode>0.0;\n    bool set_land = drawmode<0.0;\n    \n \n    \n    // BEGIN SIMULATION CODE >>>\n    // The following three lines of code contain the entire simulation engine.\n    \n    // Every pixel wants to be at the average height of its four neighbors,\n    // so let's model that as a linear spring-like force (to be precise: as an \n    // acceleration, since the particle mass is implied to be unitless m = 1)\n    float acc = (textureOffset(iChannel0, uv, ivec2(-1,0)).r \n    + textureOffset(iChannel0, uv, ivec2(0,1)).r\n    + textureOffset(iChannel0, uv, ivec2(0,-1)).r \n    + textureOffset(iChannel0, uv, ivec2(1,0)).r)/4.0\n    - pos;\n    \n    acc += 0.02*(0.0-pos);\n        \n    // Euler update:\n    // What the following really means is: vel += acc * dt with time step dt = 1.0\n    vel += acc/max(iFrameRate,60.0)*60.0;// / max(1.0,exp(pos-land));\n    pos += vel/max(iFrameRate,60.0)*60.0;\n    \n    // <<< END SIMULATION CODE. The rest is plumbing, UI and visualization.\n\n    // Generate new landscape by Black Magic (i.e., combining a bunch of sinusoids)\n    if (randomize || iTime<0.02 || init == 0.0) {\n        float t = iDate.a; // Use system time for more randomness\n        float value = 0.0;\n        for (float i = 1.0; i < 100.0; ++i)\n            value += megarandomsinusoid(uv,t,i);\n        land = value;\n        vel = 0.005*sin(3.0*value); // give it an ever so slight nudge to have some initial motion\n        pos = 0.0;\n        if (pos<land) wet = -1.0;\n        init = 1.0;\n    }       \n    \n   \n    if (iMouse.z > 0.0) // mouse button pressed\n    {    \n        if (set_land || set_water)  // Draw land/water with a brush 1/15 the frame width\n        {\n            //if (length(fragCoord-iMouse.xy) < (iResolution.x/30.0))\n                land += 0.1*exp(-pow(length(fragCoord-iMouse.xy),2.0)/900.0)*(set_land?1.0:-1.0);\n        }\n        else if (pos > land || land < 0.0) // Excite wave by adding a Gaussian bit of velocity around the mouse\n            //vel += 40.0*exp(-pow(length(fragCoord-iMouse.xy),2.0)/5.0);\n            //vel -= 10.0*exp(-pow(length(fragCoord-iMouse.xy),2.0)/20.0);\n            \n            vel += wavescale*sin(iTime*5.0)*exp(-pow(length(fragCoord-iMouse.xy),2.0)/5.0);\n            boredom = 0.0;\n    }\n\n\n    // Some rain\n    if (boredom > 1000.0)\n    {    \n        float x = 5.0*iResolution.x*sin(3.0*iTime)+cos(14.0*iTime)-2.0*iResolution.x;\n        float y = 5.0*iResolution.y*cos(8.220*iTime)+cos(4.5*iTime)-2.0*iResolution.y;\n        if (pos>land)\n        vel += sin(iTime) * wavescale*exp(-pow(length(fragCoord-vec2(x,y)),2.0)/5.0);\n    }\n\n\n    \n    // Land pixels are fixed to velocity/position zero. \n    // Produce seismic waves by oscillating land pixels up+down.\n    if (land>pos || clear_waves)\n    { \n        //vel = 0.0;\n        //pos = 0.0;\n        if (land>0.0 && seismic)\n        pos = sin(8.0*iTime);\n    }\n    \n    // Clear all land to obtain a water-only world.\n    if (clear_land)\n        land = -1.0;\n\n    boredom += 1.0;\n    // Write state of motion back to buffer.\n    float state = fragCoord.y<1.0?(fragCoord.x<1.0?drawmode:(fragCoord.x<2.0?boredom:(fragCoord.x<3.0?init:wet))):wet;\n    fragColor = vec4(pos,vel,land,state);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float posi( float a )\n{\n    return fract(a)>0.5?0.0:1.0;\n}\n\nbool isnotequal (vec4 a) {\n  return (posi(a.x)!=posi(a.y) || posi(a.y)!=posi(a.z) || posi(a.z)!=posi(a.w));\n}\n\nfloat higherpos(vec4 a)\n{\n    return max(a.r, a.b);\n}\n\nfloat megarandomsinusoid(vec2 uv, float t, float i)\n{\n return sin(sin(2.0*i)*16.0*(1.5+sin(10.0*t))*sin(i+t)*uv.x+sin(2.5*i)*16.0*(1.5+sin(10.0*t))*cos(i)*uv.y + i);\n }\n \n const float wavescale = 10.0;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}