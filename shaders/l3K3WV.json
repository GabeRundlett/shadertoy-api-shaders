{
    "Shader": {
        "info": {
            "date": "1718435421",
            "description": "A shader representing the AC Brotherhood compass. This is my first shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3K3WV",
            "likes": 1,
            "name": "AC Brotherhood Compass",
            "published": 3,
            "tags": [
                "ellipse",
                "pie",
                "compass",
                "ac",
                "brotherhood"
            ],
            "usePreview": 0,
            "username": "Tidus74",
            "viewed": 89
        },
        "renderpass": [
            {
                "code": "float sdEllipse( in vec2 p, in vec2 ab );\nfloat sdPie( in vec2 p, in vec2 c, in float r );\nmat2 rotationMatrix(float angle);\nvec3 invert(in vec3 v);\n\nconst float PI = 3.1415;\nconst vec3 blue = vec3(0.780,0.871,0.992);\nconst vec3 white = vec3(1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.0);    \n    \n    vec2 out_ellipse = 0.1*vec2(10.0,5.6);\n    float out_ellipse_distance = sdEllipse( uv, out_ellipse);\n    out_ellipse_distance = smoothstep(0.0, 0.03, abs(out_ellipse_distance));\n    vec2 in_ellipse  = out_ellipse/2.25;\n    float in_ellipse_distance = sdEllipse( uv, in_ellipse);\n    in_ellipse_distance = smoothstep(0.0, 0.025, abs(in_ellipse_distance));\n    vec3 in_out = invert(white * out_ellipse_distance * in_ellipse_distance);\n    in_out *= (0.75 + 0.25*sin(3.0*iTime));\n    \n    float pie = sdPie(uv * rotationMatrix(45.0), vec2(cos(iTime),sin(iTime)),1.75);\n    pie = step(0.001, pie);        \n    float in_ellipse_distance_2 = step(0.005, sdEllipse( uv, in_ellipse));\n    float out_ellipse_distance_2 = step(0.005, sdEllipse( uv, out_ellipse));\n    if(in_ellipse_distance_2 < 0.1) pie = 1.0;\n    else if(out_ellipse_distance_2 > 0.1) pie = 1.0;\n    vec3 fill = invert(white * pie);\n    fill *= blue;\n    \n    col = in_out + fill;\n    \n    fragColor = vec4(col, 1.0);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r));\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float sine = sin(angle), cosine = cos(angle);\n    return mat2( cosine, -sine, \n                 sine,    cosine );\n}\n\nvec3 invert(in vec3 v)\n{\n    return 1.0 - v;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}