{
    "Shader": {
        "info": {
            "date": "1573686116",
            "description": "?",
            "flags": 32,
            "hasliked": 0,
            "id": "ldyBWz",
            "likes": 3,
            "name": "fbm thing",
            "published": 3,
            "tags": [
                "ting"
            ],
            "usePreview": 0,
            "username": "05gash",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "const float pi = 3.1415;\n\n//credit to IQ for these FBM & noise functions https://iquilezles.org/articles/warp\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n    float amb = texture(iChannel1, vec2(0.2, 0.1)).x;\n    vec2 q = vec2( fbm6( p + vec2(0.0,0.0) ),\n                  fbm6( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( fbm6( p + 4.0*q + vec2(-1.2,9.2) ),\n                  fbm6( p + 4.0*q + vec2(8.3,2.8) ) );\n\n    return fbm6( p + 4.0*r + sin(sin(sin(iTime/3.))));\n}\n\n#define pi 3.1415\n// simple noise from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n/*\nfloat somple(vec2 uv, float t){\n    uv += normalize(vec2(rand(uv.x + t), rand(uv.y + t)))/iResolution.xy;\n\treturn step(mod(length(uv) + t*3., 0.2), 0.1);\n}\n*/\n\nfloat somple(vec2 uv, float t){ \n    float param = fbm6(vec2(fbm6(uv.yx*20. + t),fbm6(uv*20. + t)));\n   \tfloat c = cos(param + t*3./pi);\n    float s = sin(param + t*3./pi);\n    mat2 rot = mat2(vec2(c, s), vec2(-s,c));\n    uv *= vec2(c*c,s*s);\n    uv = rot*uv;\n\treturn length(step(mod(uv.x, 0.2) + param*0.1*sin(sin(t*3.)), 0.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy - .5;\n    uv *=1.2;\n    //uv = vec2(noise(uv.x + iTime), noise(uv.y));\n    float s = 0.;\n    for(int i = 0; i<16; i++){\n        float f = float(i);\n        s += somple(uv + vec2(mod(f,4.), f/16.)/iResolution.xy, iTime + iTimeDelta*float(i)/16.)/16.;\n    }\n\t//float b = sin(300.*length(uv - .5) + iTime*100.);\n    fragColor = vec4(s);\n}\n    \n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 len = vec3(length(uv - vec2(.5)));\n    \n    len*=len*len;\n    \n    len *= vec3(.03, .015, 0.0);\n    \n    vec2 uvR = uv + normalize(vec2(.5) - uv)*len.r;\n    vec2 uvG = uv + normalize(vec2(.5) - uv)*len.g;\n    vec2 uvB = uv + normalize(vec2(.5) - uv)*len.b;\n\n    fragColor = texture(iChannel0, uv);\n    fragColor.xyz = vec3(texture(iChannel0, uvR).r, texture(iChannel0, uvG).g, texture(iChannel0, uvB).b);\n\tfragColor += (texture(iChannel2, fragCoord/256.)-.5)/16.;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}