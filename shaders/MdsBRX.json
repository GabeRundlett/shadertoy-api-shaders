{
    "Shader": {
        "info": {
            "date": "1497312033",
            "description": "explicit (and branchless) atan2 for automatic differentiation\nfor\nhttps://www.shadertoy.com/view/lsffRX\nthe core is line 32:\n return mix(1.57+atan(-y/xx),mix(3.14+b,b,step(0.,y)),step(x,0.));}",
            "flags": 0,
            "hasliked": 0,
            "id": "MdsBRX",
            "likes": 4,
            "name": "explicit branchless atan2",
            "published": 3,
            "tags": [
                "atan",
                "branchless"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 824
        },
        "renderpass": [
            {
                "code": "//explicit (and branchless) atan2 for automatic differentiation\n//for\n//https://www.shadertoy.com/view/lsffRX\n\n//optionally ignore (linux) incompatibility, for better precision and performance\n//#define ignorelinux\n\n#define v0 float\n#define pi acos(-1.)\n#define pih acos(0.)\n\n//wrapping for namespace sake:\n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 atand(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n\nv0 signd(v0 a){return sign(a);}\nv0 absd(v0 a){return abs(a);}\nv0 negd(v0 a){return -a;}\nv0 mind(v0 a,v0 b){return min(a,b);}\nv0 divd(v0 a,v0 b){return a/b;}\nv0 addd(v0 a,v0 b){return a+b;}\nv0 stepd(v0 a,v0 b){return step(a,b);}\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\n\n#ifndef ignorelinux\n //should be smallest positive float, or close to it, and still >0.\n const float smallestP=exp2(1e-125);\n //all for linux compatibility, \n //linux distegards that IEEfloats are DEFIED AS BEING JUST FINE when dividing by +-0 !!!\n #define not0(a) signd(a)*mind(smallestP,absd(a))\n#endif \n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\n//is equivalent to atan(x,y) as far as I can tell.\nv0 atand(v0 x,v0 y){\n #ifdef ignorelinux\n  float yy=y,xx=x,\n #else\n  float yy=not0(y),xx=not0(x),// (needs extreme resolution to show a difference)\n #endif\n b=atand(divd(x,yy));\n return mixd(pih+atand(divd(negd(y),xx)),mixd(addd(pi,b),b,stepd(0.,y)),stepd(x,0.));}\n\n//below just tests above for consistency\n//carthesian to polar\nvec2 c2p(vec2 c){\n  //float y=mix(atand(c.y,c.x),atan(c.y,c.x),sin(iTime*99.));//see flicker?  \n  float y=atand(c.y,c.x);\n  return vec2(length(c),y);}\n//polar to carthesian\nvec2 p2c(vec2 c){return vec2(c.x*cos(c.y),c.x*sin(c.y));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 u = fragCoord.xy / iResolution.xy;\n u-=.5;\n u.x*=iResolution.x/iResolution.y;\n //u*=6.;//zoom out\n u=c2p(u);\n //u.y+=2.61;\n u.y+=iTime;//inefficient rotation transform (polar transform is overkill)\n u=p2c(u);    \n u=fract(u);    \n fragColor = vec4(u,0.5,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}