{
    "Shader": {
        "info": {
            "date": "1474577035",
            "description": "Combining my loves of vinyl and shaders!\n\nYou can 'scratch' with the mouse :)",
            "flags": 0,
            "hasliked": 0,
            "id": "XtG3DD",
            "likes": 18,
            "name": "Vinyl Turntable",
            "published": 3,
            "tags": [
                "noise",
                "distancefields",
                "sdf",
                "animation",
                "df",
                "anisotropic"
            ],
            "usePreview": 1,
            "username": "valentingalea",
            "viewed": 1771
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\n#if defined(GL_ES) || defined(GL_SHADING_LANGUAGE_VERSION)\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\n#define PI 3.14159265359\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8\n_constant(hit_t) no_hit = _begin(hit_t)\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\t-1, // material id\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n_end;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t_end;\n\treturn r;\n}\n\n_constant(mat3) mat3_ident = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\nmat2 rotate_2d(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n// http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html\nvec3 linear_to_srgb(\n\t_in(vec3) color\n){\n\tconst float p = 1. / 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\nvec3 srgb_to_linear(\n\t_in(vec3) color\n){\n\tconst float p = 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n// ----------------------------------------------------------------------------\n// Signed Distance Fields functions\n// ----------------------------------------------------------------------------\n\nvec2 op_add( // union\n\t_in(vec2) d1,\n\t_in(vec2) d2\n){\n\t// minimum distance (preserving material info)\n\treturn d1.x < d2.x ? d1 : d2;\n}\n\nfloat op_add( // union\n\t_in(float) d1,\n\t_in(float) d2\n){\n\treturn min(d1, d2);\n}\n\nfloat op_sub( // difference\n\t_in(float) d1,\n\t_in(float) d2\n){\n\t// intersection between first and\n\t// complement of the second field\n\t// aka the second 'carved out' from the first\n\treturn max(d1, -d2);\n}\n\nfloat op_intersect( // intersection\n\t_in(float) d1,\n\t_in(float) d2\n){\n\t// what's common for both fields\n\treturn max(d1, d2);\n}\n\nfloat op_blend(\n\t_in(float) a,\n\t_in(float) b,\n\t_in(float) k // factor of smoothing\n){\n\t// from https://iquilezles.org/articles/smin\n\t// NOTE: not true distance but estimate\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k*h*(1.0 - h);\n}\n\nfloat sd_plane(\n\t_in(vec3) p,\n\t_in(vec3) n, // normal\n\t_in(float) d // distance\n){\n\t// distance from point to plane\n\t// http://mathworld.wolfram.com/Point-PlaneDistance.html\n\treturn dot(n, p) + d;\n}\n\nfloat sd_sphere(\n\t_in(vec3) p,\n\t_in(float) r\n){\n\t// distance to center of sphere offset by the radius\n\treturn length(p) - r;\n}\n\nfloat sd_box(\n\t_in(vec3) p,\n\t_in(vec3) b // dimensions of box\n){\n\t// intersection of 3 axis aligned 'slabs'\n\treturn max(abs(p.x) - b.x, max(abs(p.y) - b.y, abs(p.z) - b.z));\n}\n\nfloat sd_torus( // around Z axis\n\t_in(vec3) p,\n\t_in(float) R, // 'donut' radius\n\t_in(float) r  // thickness\n){\n\t// projected circle of radius R on xy plane\n\t// combined with circle of radius r around z axis\n\treturn length(vec2(length(p.xy) - R, p.z)) - r;\n}\n\nfloat sd_y_cylinder(\n\t_in(vec3) p,\n\t_in(float) r, // radius\n\t_in(float) h  // height\n){\n\t// distance to the Y axis, offset (aka inflated) by the cylinder radius\n\t// then intersected with 2 cutting planes\n\treturn max(length(p.xz) - r, abs(p.y) - h / 2.);\n}\n\nfloat sd_cylinder(\n\t_in(vec3) P,\n\t_in(vec3) P0, // start point (relative to 'p')\n\t_in(vec3) P1, // end point (relative to 'p')\n\t_in(float) R  // thickness\n){\n\t// distance to segment -- http://geomalgorithms.com/a02-_lines.html\n\t// then cut it with 2 planes at the ends\n\t// then offset it with radius    \n\tvec3 dir = normalize(P1 - P0);\n\tfloat dist = length(cross(dir, P - P0));\n\tfloat plane_1 = sd_plane(P, dir, length(P1));\n\tfloat plane_2 = sd_plane(P, -dir, -length(P0));\n\treturn op_sub(op_sub(dist, plane_1), plane_2) - R;\n}\n\n// 3D Bezier curved cylinder\n// original by http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// adapted by iq https://www.shadertoy.com/view/ldj3Wh\nfloat det2(\n\t_in(vec2) a,\n\t_in(vec2) b\n){\n\treturn a.x*b.y - b.x*a.y;\n}\nvec3 sd_bezier_get_closest(\n\t_in(vec2) b0,\n\t_in(vec2) b1,\n\t_in(vec2) b2\n){\n\tfloat a = det2(b0, b2);\n\tfloat b = 2.0*det2(b1, b0);\n\tfloat d = 2.0*det2(b2, b1);\n\tfloat f = b*d - a*a;\n\tvec2  d21 = b2 - b1;\n\tvec2  d10 = b1 - b0;\n\tvec2  d20 = b2 - b0;\n\tvec2  gf = 2.0*(b*d21 + d*d10 + a*d20); gf = vec2(gf.y, -gf.x);\n\tvec2  pp = -f*gf / dot(gf, gf);\n\tvec2  d0p = b0 - pp;\n\tfloat ap = det2(d0p, d20);\n\tfloat bp = 2.0*det2(d10, d0p);\n\tfloat t = clamp((ap + bp) / (2.0*a + b + d), 0.0, 1.0);\n\treturn vec3(mix(mix(b0, b1, t), mix(b1, b2, t), t), t);\n}\nvec2 sd_bezier(\n\t_in(vec3) a, // start\n\t_in(vec3) b, // knot (control point)\n\t_in(vec3) c, // end\n\t_in(vec3) p, \n\t_in(float) thickness\n){\n\tvec3 w = normalize(cross(c - b, a - b));\n\tvec3 u = normalize(c - b);\n\tvec3 v = normalize(cross(w, u));\n\n\tvec2 a2 = vec2(dot(a - b, u), dot(a - b, v));\n\tvec2 b2 = vec2(0., 0.);\n\tvec2 c2 = vec2(dot(c - b, u), dot(c - b, v));\n\tvec3 p3 = vec3(dot(p - b, u), dot(p - b, v), dot(p - b, w));\n\n\tvec3 cp = sd_bezier_get_closest(a2 - p3.xy, b2 - p3.xy, c2 - p3.xy);\n\n\treturn vec2(0.85*(sqrt(dot(cp.xy, cp.xy) + p3.z*p3.z) - thickness), cp.z);\n}\n\n// adapted from http://mercury.sexy/hg_sdf/\nfloat sd_capsule(\n\t_in(vec3) p,\n\t_in(vec3) a,\n\t_in(vec3) b,\n\t_in(float) r\n){\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab), 0., 1.);\n\treturn length((ab*t + a) - p) - r;\n}\n// ----------------------------------------------------------------------------\n// Materials system definitions\n// ----------------------------------------------------------------------------\n\nstruct material_t {\n\tvec3 base_color;\n\tfloat metallic;\n\tfloat roughness;\n\tfloat ior; // index of refraction\n\tfloat reflectivity;\n\tfloat translucency;\n};\n\n#define num_materials 8\n#define mat_invalid -1\n#define mat_debug 0\n_mutable(material_t) materials[num_materials];\n\nmaterial_t get_material(\n\t_in(int) index\n){\n#if defined(HLSL) && defined(__cplusplus)\n\treturn materials[index];\n#else\n\tmaterial_t mat;\n\n\tfor (int i = 0; i < num_materials; ++i) {\n\t\tif (i == index) {\n\t\t\tmat = materials[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mat;\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------------------------------------\n\nfloat hash(\n\t_in(float) n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(\n\t_in(vec3) x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\n#if 1\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n#else\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// Fractional Brownian Motion\n// macro function generators, depend on custom basis function\n// ----------------------------------------------------------------------------\n\n#define DECL_FBM_FUNC(_name, _octaves, _basis) float _name(_in(vec3) pos, _in(float) lacunarity, _in(float) init_gain, _in(float) gain) { vec3 p = pos; float H = init_gain; float t = 0.; for (int i = 0; i < _octaves; i++) { t += _basis * H; p *= lacunarity; H *= gain; } return t; }\n\n#define DECL_FBM_FUNC_TILE(_name, _octaves, _basis) float _name(_in(vec3) pos, _in(float) lacunarity, _in(float) init_gain, _in(float) gain) { vec3 p = pos; float H = init_gain; float L = lacunarity; float t = 0.; for (int i = 0; i < _octaves; i++) { t += _basis * H; L *= lacunarity; H *= gain; } return t; }\n\n#define noise_func ((noise_iq(p) * 2. - 1.))\nDECL_FBM_FUNC(fbm, 4, noise_func)\n\n// ----------------------------------------------------------------------------\n// Vinyl disk animation\n// ----------------------------------------------------------------------------\n\nvec3 background(_in(ray_t) ray)\n{\n\treturn vec3(1, 1, 1);\n}\n\n#define mat_groove 1\n#define mat_dead_wax 2\n#define mat_label 3\n#define mat_logo 4\n#define mat_shiny 5\n\nvoid setup_mat(\n\t_inout(material_t) mat,\n\t_in(vec3) diffuse,\n\t_in(float) metallic,\n\t_in(float) roughness\n){\n\tmat.base_color = diffuse;\n\tmat.metallic = metallic;\n\tmat.roughness = roughness;\n\tmat.ior = 1.;\n\tmat.reflectivity = 0.;\n\tmat.translucency = 0.;\n}\n\nvoid setup_scene()\n{\n\tsetup_mat(materials[mat_debug],\n\t\tvec3(1, 1, 1), .0, .0);\n\tsetup_mat(materials[mat_groove],\n\t\tvec3(.01, .01, .01), .0, .013);\n\tsetup_mat(materials[mat_dead_wax],\n\t\tvec3(.05, .05, .05), .0, .005);\n\tsetup_mat(materials[mat_label],\n\t\tvec3(.5, .5, .0), .0, .5);\n\tsetup_mat(materials[mat_logo],\n\t\tvec3(0, 0, .7), .0, .5);\n\tsetup_mat(materials[mat_shiny],\n\t\tvec3(.7, .7, .7), 1., .01);\n}\n\nvoid setup_camera(\n\t_inout(vec3) eye,\n\t_inout(vec3) look_at\n){\n#if 1\n\teye = vec3(0, 5.75, 6.75);\n\tlook_at = vec3(0, -2.75, 0);\n#else\n\teye = vec3(-2, 1.5, 5.5);\n\tlook_at = vec3(-1.5, 0, 0);\n#endif\n}\n\n_mutable(mat3) platter_rot;\n\nfloat sdf_logo(\n\t_in(vec3) pos,\n\t_in(float) thick\n){\n\tvec3 b = vec3(.25, thick, 1.2);\n\tvec3 d = vec3(.7, 0, 0);\n\t\n\tvec3 p = mul(pos, rotate_around_y(30.));\n\tfloat v1 = sd_box(p - d, b);\n\t\n\tp = mul(pos, rotate_around_y(-30.));\n\tfloat v2 = sd_box(p + d, b);\n\t\n\tfloat x = sd_box(pos, vec3(1.5, thick, 1.35));\n\tfloat v = op_add(v1, v2);\n\treturn op_intersect(v, x);\n}\n\nvec2 sdf_platter(_in(vec3) p)\n{\n\tconst float thick = .1;\n\n\tvec2 lead_in = vec2(\n\t\tsd_y_cylinder(p, 6., thick - .05),\n\t\tmat_dead_wax);\n\tvec2 groove = vec2(\n\t\tsd_y_cylinder(p, 5.9, thick),\n\t\tmat_groove);\n\tvec2 dead_wax = vec2(\n\t\tsd_y_cylinder(p, 3., thick),\n\t\tmat_dead_wax);\n\tvec2 label = vec2(sd_y_cylinder(p, 2., thick),\n\t\tmat_label);\n\tvec2 logo = vec2(\n\t\tsdf_logo(p, thick - .0175),\n\t\tmat_logo);\n\tfloat spc = sd_y_cylinder(p, .10, .6);\n\tfloat sps = sd_sphere(p - vec3(0, .3, 0), .10);\n\tvec2 spindle = vec2(\n\t\top_add(spc, sps), mat_shiny);\n\t\n\tvec2 d0 = op_add(groove, lead_in);\n\tvec2 d1 = op_add(d0, dead_wax);\n\tvec2 d2 = op_add(label, logo);\n\tvec2 d3 = op_add(d1, d2);\n\tvec2 d4 = op_add(d3, spindle);\n\n\t// cut some holes at the edges of the disk\n\t// to make the rotation more visible\n\tfloat defect1 = sd_sphere(p + vec3(6.05, 0, 0), .1);\n\tfloat defect2 = sd_sphere(p + vec3(-6.05, 0, 0), .1);\n\tfloat defect = op_add(defect1, defect2);\n\n\treturn vec2(op_sub(d4.x, defect), d4.y);\n}\n\nvec2 sdf_tonearm(_in(vec3) pos)\n{\n\tvec3 base_p = vec3(-7, 0, -5);\n\n\tfloat platter = sd_y_cylinder(pos, 6.25, 1.);\n\tfloat base_0 = sd_y_cylinder(pos - base_p, 3., .25);\n\tfloat base_1 = op_sub(base_0, platter);\n\tfloat base_2 = sd_y_cylinder(pos - base_p, 1.25, 1.);\n\tfloat base_12 = op_add(base_1, base_2);\n\tvec2 base_a = vec2(base_12, mat_shiny);\n\tvec2 base_b = vec2(sd_y_cylinder(pos - base_p, 0.5, 2.5), mat_shiny);\n\tvec2 base = op_add(base_a, base_b);\n\n\t// slight wobble to mimic needle going up/down\n\tvec3 p = mul(pos, rotate_around_x(\n\t\tsin(u_time * 3.6758) * .1));\n\n\tconst float R = .1;\n\tconst float H = .8;\n\tvec3 a1 = vec3(-6, H, -3);\n\tvec3 a11 = vec3(-4.25, H, 2);\n\tvec3 a2 = vec3(-4.1, H, 2.45);\n\tvec3 a33 = vec3(-3.5, H, 3);\n\tvec3 a3 = vec3(-2, H, 4);\n\tfloat arm1 = sd_capsule(p, base_p + vec3(-1, H, -2), a1, R);\n\tfloat arm2 = sd_capsule(p, a1, a11, R);\n\tfloat arm3 = sd_capsule(p, a33, a3, R);\n\tvec2 armb = sd_bezier(a11, a2, a33, p, R);\n\tfloat arm_link1 = op_add(arm1, arm2);\n\tfloat arm_link2 = op_add(arm_link1, arm3);\n\tvec2 arm = vec2(\n\t\top_add(arm_link2, armb.x),\n\t\tmat_shiny);\n\n\t// construct a rotation matrix\n\t// from the orientation of the arm\n\tvec3 arm_fwd = normalize(a3 - a33);\n\tvec3 arm_up = vec3(0, 1, 0);\n\tvec3 arm_right = cross(arm_fwd, arm_up);\n\tmat3 arm_xform = mat3(\n\t\tarm_fwd,\n\t\tarm_up,\n\t\tarm_right);\n\n\t// collar 'clr' (or flange)\n\tvec3 clr_p = p - a3;\n\tfloat clr_r = R * 1.5;\n\tfloat collar = sd_cylinder(clr_p,\n\t\tvec3(0, 0, 0),\n\t\tvec3(0, 0, 0) + arm_fwd * .05,\n\t\tclr_r);\n\n\t// finger lift (or grip) 'fl'\n\tconst float fl_w = .045;\n\tconst float fl_h = .020;\n\tfloat fl_len1 = clr_r * 1.;\n\tfloat fl_len2 = fl_len1 * 1.2;\n\n\t// the first fl part is rotated\n\t// and 'pushed' back to fit inside the collar\n\t// a new (local) transform space is created by\n\t// combining the arm one plus a new rotation\n\tmat3 fl_rot =\n\t\tmul(arm_xform, rotate_around_x(45.));\n\tvec3 fl_p = mul(clr_p -\n\t\tarm_right * clr_r -\n\t\tarm_up * clr_r,\n\t\tfl_rot);\n\tfloat fl1 = sd_box(fl_p,\n\t\tvec3(fl_w, fl_h, fl_len1));\n\n\t// the second fl part is positioned\n\t// relative to the first, working in this\n\t// new local transform space\n\tmat3 fl_rot2 = rotate_around_x(-45.);\n\tfloat fl2 = sd_box(\n\t\tmul(fl_p - vec3(0, 0, fl_len1), fl_rot2)\n\t\t- vec3(0, 0, fl_len2),\n\t\tvec3(fl_w, fl_h, fl_len2));\n\tfloat finger_lift = op_add(fl1, fl2);\n\n\tvec2 headshell = vec2(\n\t\top_add(collar, finger_lift),\n\t\tmat_shiny);\n\n\t// the cartridge 'ctg'\n\tconst float ctg_w = .05;\n\tconst float ctg_h = .05;\n\tfloat ctg_len1 = .3;\n\tfloat ctg_len2 = .5;\n\n\tvec3 ctg_p = mul(clr_p, arm_xform);\n\tfloat ctg1 = sd_box(ctg_p,\n\t\tvec3(ctg_len1, ctg_h, ctg_w));\n\tmat3 ctg_rot = rotate_around_z(44.);\n\tvec3 ctg2_p =\n\t\tmul(ctg_p - vec3(ctg_len1, 0, 0), ctg_rot)\n\t\t- vec3(ctg_len2 - 0.03, -.01, 0);\n\tfloat ctg2 = sd_box(\n\t\tctg2_p,\n\t\tvec3(ctg_len2, ctg_h, ctg_w));\n\n\t// a series of boxes that will be used \n\t// to carve out the shape of the 'needle'\n\tfloat cut = sd_box(mul(\n\t\tmul(ctg2_p, rotate_around_x(10.)) - vec3(0, .05, .175),\n\t\trotate_around_y(-5.)),\n\t\tvec3(ctg_len2 * 2., ctg_h * 3., ctg_w * 3.2));\n\tfloat cut2 = sd_box(\n\t\tmul(ctg2_p - vec3(.3, .2, 0),\n\t\t\trotate_around_z(10.)),\n\t\tvec3(.4, .2, .3));\n\n\tfloat ctg12 = op_add(ctg1, ctg2);\n\tfloat ctg12c = op_sub(ctg12, cut);\n\tvec2 cartridge = vec2(\n\t\top_sub(ctg12c, cut2),\n\t\tmat_shiny);\n\n\tvec2 tone1 = op_add(base, arm);\n\tvec2 tone2 = op_add(headshell, cartridge);\n\treturn op_add(tone1, tone2);\n}\n\nvec2 sdf(_in(vec3) pos)\n{\n\tvec3 p = mul(pos, platter_rot);\n\tvec2 plat = sdf_platter(p);\n\n\tvec2 arm = sdf_tonearm(pos);\n\n\treturn op_add(plat, arm);\n}\n\nvec3 sdf_normal(_in(vec3) p)\n{\n\tfloat dt = 0.001;\n\tvec3 x = vec3(dt, 0, 0);\n\tvec3 y = vec3(0, dt, 0);\n\tvec3 z = vec3(0, 0, dt);\n\treturn normalize(vec3(\n\t\tsdf(p + x).r - sdf(p - x).r,\n\t\tsdf(p + y).r - sdf(p - y).r,\n\t\tsdf(p + z).r - sdf(p - z).r\n\t));\n}\n\nfloat saw(_in(float) x)\n{\n\treturn x - floor(x);\n}\n\nfloat pulse(_in(float) x)\n{\n\treturn saw(x + .5) - saw(x);\n}\n\n_mutable(vec3) sun_dir = \n\tnormalize(vec3(-1, 4, -3));\n\nvec3 illuminate(\n\t_in(vec3) eye,\n\t_inout(hit_t) hit\n){\n#if 0\n\treturn vec3(hit.normal);\n#endif\n\n\tvec3 L = sun_dir;\n\tvec3 V = normalize(eye - hit.origin);\n\n\tmaterial_t mat = get_material(hit.material_id);\n\n\tif (hit.material_id == mat_groove ||\n\thit.material_id == mat_dead_wax) {\n\t\thit.origin = mul(hit.origin, platter_rot);\n\t\tL = mul(L, platter_rot);\n\t\tV = mul(V, platter_rot);\n\t\t\n\t\tfloat r = length(hit.origin);\n\t\tvec3 B = hit.origin / r;\n\t\tvec3 N = vec3(0, 1, 0);\n\t\tif (hit.material_id == mat_groove) {\n\t\t\tfloat rr = r + .07575 *\n\t\t\t\tnoise_iq(hit.origin * 2.456);\n\t\t\t\t//fbm(hit.origin * 4.07, 2.08, .5, .5);\n\t\t\tfloat s = pulse(rr * ((u_res.x < 400.) ? 12. : 24.));\n\t\t\tif (s > 0.) {\n\t\t\t\tN = normalize(N + B);\n\t\t\t\tN = reflect(N, vec3(0, 1, 0));\n\t\t\t}\n\t\t}\n\t\tif (hit.material_id == mat_dead_wax) {\n\t\t\tfloat s = saw(r * 4.);\n\t\t\tN = normalize(N + B * float(s > .9));\n\t\t}\n\t\t//return N;\n\t\tvec3 T = cross(B, N);\n\t\t\n\t\tconst float ro_diff = 1.;\n\t\tconst float ro_spec = .0725;\n\t\tconst float a_x = .025;\n\t\tconst float a_y = .5;\n\t\t\n\t\tvec3 H = normalize(V + L);\n\t\tfloat dotLN = dot(L, N);\n\n\t\tvec3 diffuse = mat.base_color *\n\t\t\t(ro_diff / PI) *\n\t\t\tmax(0., dotLN);\n\t\t\t\n\t\tfloat spec_a = ro_spec /\n\t\t\tsqrt(dotLN * dot(V, N));\n\t\t\t\n\t\tfloat spec_b = 1. /\n\t\t\t(4. * PI * a_x * a_y);\n\n\t\tfloat ht = dot(H, T) / a_x;\n\t\tfloat hb = dot(H, B) / a_y;\n\t\tfloat spec_c = -2. *\n\t\t\t(ht * ht + hb * hb) /\n\t\t\t(1. + dot(H, N));\n\n\t\tvec3 specular = vec3(1, 1, 1) *\n\t\t\tspec_a * spec_b * exp(spec_c);\n\t\t\t\n\t\treturn diffuse + specular;\n\t} else {\n\t\thit.normal = sdf_normal(hit.origin);\n\n#if 0\n\t\tif (hit.material_id == mat_label || hit.material_id == mat_logo) {\n\t\t\tfloat r = length(hit.origin);\n\t\t\tvec3 B = hit.origin / r;\n\t\t\tfloat s = saw(r * .9);\n\t\t\thit.normal = normalize(hit.normal + B * float(s > .975));\n\t\t}\n#endif\n\t\t\n#ifdef SHADERTOY\n\t\tif (hit.material_id == mat_shiny) {\n\t\t\tvec3 refl = (reflect(V, hit.normal));\n\t\t\treturn textureLod(iChannel0, refl, 0.).rgb;\n\t\t}\n#endif\n\n\t\tvec3 diffuse = mat.base_color * max(0., dot(L, hit.normal));\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 specular = pow(max(0., dot(H, hit.normal)), 50.)\n\t\t\t* vec3(1, 1, 1);\n\t\treturn diffuse + specular;\n\t}\n}\n\nfloat sdf_shadow(_in(ray_t) ray)\n{\n\tconst int steps = 20;\n\tconst float end = 5.;\n\tconst float penumbra_factor = 16.;\n\tconst float darkest = .05;\n\tfloat t = 0.;\n\tfloat umbra = 1.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tvec3 p = ray.origin + ray.direction * t;\n\t\tvec2 d = sdf(p);\n\n\t\tif (t > end) break;\n\t\tif (d.x < .005) {\n\t\t\treturn darkest;\n\t\t}\n\n\t\tt += d.x;\n\t\t// from https://iquilezles.org/articles/rmshadows\n\t\tumbra = min(umbra, penumbra_factor * d.x / t);\n\t}\n\n\treturn umbra;\n}\n\nvec3 render(\n\t_in(ray_t) ray,\n\t_in(vec3) point_cam\n){\n\tconst int steps = 80;\n\tconst float end = 40.;\n\n\tfloat rot = u_time * 200.;\n#ifdef SHADERTOY\n\t// scratching support :)\n\tif (u_mouse.z > 0.) {\n\t\trot = u_mouse.y;\n\t}\n#endif\n\tplatter_rot = mul(\n\t\trotate_around_y(-rot), \n\t\trotate_around_x(sin(u_time) * .1));\n\n\tfloat t = 0.;\n\tfor (int i = 0; i < steps; i++) {\n\t\tvec3 p = ray.origin + ray.direction * t;\n\t\tvec2 d = sdf(p);\n\n\t\tif (t > end) break;\n\t\tif (d.x < .005) {\n\t\t\thit_t h = _begin(hit_t)\n\t\t\t\tt, // ray length at impact\n\t\t\t\tint(d.y), // material id\n\t\t\t\tvec3(0, 1, 0), // normal\n\t\t\t\tp // point of impact\t\t\t\t\n\t\t\t_end;    \n\t\t\n\t\t\tfloat sh = 1.;\n#if 1\n\t\t\tray_t sh_ray = _begin(ray_t)\n\t\t\t\tp + sun_dir * 0.05, sun_dir\n\t\t\t\t_end;\n\t\t\tsh = sdf_shadow(sh_ray);\n#endif   \n\t\t\treturn illuminate(ray.origin, h) * sh;\n\t\t}\n\n\t\tt += d.x;\n\t}\n\n\treturn background(ray);\n}\n\n#define FOV 1. // 45 degrees\n// ----------------------------------------------------------------------------\n// Main Rendering function\n// depends on external defines: FOV\n// ----------------------------------------------------------------------------\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n#ifdef SHADERTOY\n\tvec2 fragCoord\n#else\n\t_in(vec2) fragCoord\n#endif\n){\n\t// assuming screen width is larger than height \n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\n\tvec3 eye, look_at;\n\tsetup_camera(eye, look_at);\n\n\tsetup_scene();\n\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n#ifdef HLSL\n\t\tpoint_ndc.y = 1. - point_ndc.y;\n#endif\n\tvec3 point_cam = vec3(\n\t\t(2.0 * point_ndc - 1.0) * aspect_ratio * FOV,\n\t\t-1.0);\n\n\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\tvec3 color = render(ray, point_cam);\n\n\tfragColor = vec4(linear_to_srgb(abs(color)), 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}