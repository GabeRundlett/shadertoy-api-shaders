{
    "Shader": {
        "info": {
            "date": "1642012456",
            "description": "A helix spiral with a ball pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dXcW8",
            "likes": 11,
            "name": "Spiral fractal",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "control",
                "infinite"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "\n# define MAX_NUM_STEPS 200\n# define PI 3.1415926538\n# define EXPONENT 4.\n# define MAX_DEPTH 8.\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\n\nfloat sdSphereWorld(in vec3 pos){\n    pos = mod(pos, 1.0);\n    return sdSphere(pos, vec3(0.5), 0.5);\n}\n\nvec3 normalSphereWorld(in vec3 pos){\n    float sd = sdSphereWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdSphereWorld(pos - e.xyy),\n    \tsdSphereWorld(pos - e.yxy),\n    \tsdSphereWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nfloat sdSpiral(in vec3 pos){\n    float radius = 1.;\n    vec3 pos1 = vec3(cos(pos.z)*radius, sin(pos.z)*radius, pos.z);\n    float angle = atan(pos.y, pos.x);\n    float offset = pos.z / PI / 2. - angle / PI / 2.;\n    vec3 pos2 = vec3(\n        pos.xy / length(pos.xy)*radius,\n        pos.z + abs(offset - round(offset)) * PI * 2.\n    );\n    float rr = length(pos - (pos1 + pos2) / 2.0);\n    float sd = rr-0.4;\n    \n    return sd*0.5;\n}\n\nvec3 normalsdSpiral(in vec3 pos){\n    float sd = sdSpiral(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdSpiral(pos - e.xyy),\n    \tsdSpiral(pos - e.yxy),\n    \tsdSpiral(pos - e.yyx)\n    ));\n    return normal;\n}\n\nfloat sdTotalWorld(in vec3 pos, float resolution){\n\n    \n    // Modulus repeat.\n    float size = 100.;\n    pos.xy = mod(pos.xy + size*0.5, size) - size*0.5;\n    \n    // Add rotation.\n    float speed = 0.2;\n    float sine = sin(iTime*speed);\n    float cosine = cos(iTime*speed);\n    pos = vec3(\n        cosine * pos.x + sine * pos.y,\n        sine * pos.x - cosine * pos.y,\n        pos.z\n    );\n    \n    \n    float ss = sdSphereWorld(pos);\n    float ff = 1.0;\n    for(int i=0; i<int(resolution); i++){\n        ff *= EXPONENT;\n        ss = min(ss, sdSphereWorld(pos*ff)/ff);\n    }\n    ff *= EXPONENT;\n    ss = mix(\n        ss,\n        min(ss, sdSphereWorld(pos*ff)/ff),\n        mod(resolution, 1.)\n    );\n    return max(min(sdSpiral(pos), sdSpiral(vec3(pos.xy, pos.z - PI))), -ss);\n}\nvec3 normalSdTotalWorld(in vec3 pos, float resolution, float delta){\n    float sd = sdTotalWorld(pos, resolution);\n    vec2 e = vec2(delta, 0.);\n    vec3 normal = normalize(sd - vec3(\n    \tsdTotalWorld(pos - e.xyy, resolution),\n    \tsdTotalWorld(pos - e.yxy, resolution),\n    \tsdTotalWorld(pos - e.yyx, resolution)\n    ));\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rr = 3.;\n    float ss = 0.1;\n    vec3 cameraPos = vec3(sin(iTime*ss)*rr,cos(iTime*ss)*rr,-iTime*1.2);\n    vec3 forward = normalize(vec3(normalize(-cameraPos.xy), -1.8+1.4*sin(iTime*0.3)));\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    float zoom = 0.9;\n    vec3 viewDir = normalize(forward*0.8*zoom + right * uv.x + up * uv.y);\n    \n    float debug = 0.0;\n    \n    // Calculate color.\n    vec3 color = vec3(0.1,0,0);\n    vec3 reflectionConstant = vec3(1.0);\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.0;\n    float maxDist = 200.0;\n    int maxNumSteps = MAX_NUM_STEPS;\n    int numSteps = 0;\n    float minDist = 0.0001;\n    vec3 prevPos = pos;\n    float prevSD = 0.0;\n    float sd = 0.0;\n    bool shaddowMode = false;\n    float distToSurface = maxDist;\n    int numStepsToSurface = maxNumSteps;\n    for(; numSteps < maxNumSteps; numSteps++){\n        prevSD = sd;\n        float dd = shaddowMode? distToSurface: dist;\n        float resolution =  clamp(-log2(dd*0.003)/log2(EXPONENT), 0., MAX_DEPTH);\n        sd = sdTotalWorld(pos, resolution);\n        if(sd < minDist){\n            // Collision with sphere.\n            float backFactor = (minDist - sd) / (prevSD - sd);\n            pos = mix(pos, prevPos, backFactor);\n            sd *= (1.0-backFactor);\n            \n            vec3 normal = normalSdTotalWorld(pos, resolution, 0.001);\n            vec3 surfaceColor = vec3(1,1,0.9);\n            float ambient = 0.1;\n            if(shaddowMode){\n                color = surfaceColor * ambient;\n                //debug += 1.0;\n                break;\n            }\n            shaddowMode = true;\n            pos += normal * minDist;\n            const vec3 lightDir = normalize(vec3(1,1,2));\n            color = surfaceColor * (vec3(dot(lightDir, normal)) + ambient);\n            distToSurface = dist;\n            numStepsToSurface = numSteps;\n            dir = lightDir;\n            //debug += 1.;\n            //break;\n            //\n        }\n        const float brightnessFactor = 0.1;\n        if(dist + sd > maxDist){\n            dist = maxDist;\n            break;\n        }\n        prevPos = pos;\n        pos += normalize(dir) * sd;\n        dist += sd;\n    }\n    //debug += numStepsToSurface == numSteps? 1.:0.;\n    // Mist.\n    float fogFactor = max(\n        float(numStepsToSurface)/float(maxNumSteps),\n        distToSurface / maxDist\n    );\n    vec3 fogColor = mix(vec3(0.3,0.3,.6), vec3(0.1,0.1,.2), viewDir.z);\n    color = mix(color, fogColor, fogFactor);\n    color.r += debug;\n    //if(debug > 0.) color = vec3(1,0,0);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}