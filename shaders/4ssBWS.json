{
    "Shader": {
        "info": {
            "date": "1498061307",
            "description": "trippy halftone experiment + outlines + shading towards the edges",
            "flags": 32,
            "hasliked": 0,
            "id": "4ssBWS",
            "likes": 145,
            "name": "tripney spears",
            "published": 3,
            "tags": [
                "halftone",
                "truchet",
                "crosshatch",
                "outlines",
                "layers"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 4576
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// halftone experiment + outlines + shading towards the edges\n// basically an improved version of https://www.shadertoy.com/view/4ssyz4 using my\n// pattern from https://www.shadertoy.com/view/lssfzX, and added some outline shading \n// inspired by shanes https://www.shadertoy.com/view/ldscWH\n//\n// BufA and BufB are only for blurring the image, so that the edges dont get too noisy\n\n// uncomment those if you want a slight chrome look, engrave of pattern,\n// brushed metal style, or a moving halftone pattern\n#define REFLECTION\n//#define ENGRAVE\n//#define BRUSHED\n//#define MOVE_PATTERN\n\n#define Res (iResolution.xy)\n#define Res1 (iChannelResolution[1].xy)\n#define PI 3.14159265358979\n\nvec2 tr_i(vec2 p)\n{\n    return (p*vec2(1,.5*sqrt(3.))+vec2(.5*p.y,0));\n}\n\nvec2 tr(vec2 p)\n{\n    return (p-vec2(p.y/sqrt(3.),0))/vec2(1,.5*sqrt(3.));\n}\n\nvoid getTri(vec2 p, inout vec2 p1, inout vec2 p2, inout vec2 p3, float size)\n{\n    vec2 pt=tr(p)/size;\n    vec2 pf=floor(pt);\n    vec2 pc=ceil(pt);\n    p1=vec2(pf.x,pc.y);\n    p2=vec2(pc.x,pf.y);\n    p3=pc;\n    if(dot(pt-pf,vec2(1))<1.) p3=pf;\n    p1=tr_i(p1)*size;\n    p2=tr_i(p2)*size;\n    p3=tr_i(p3)*size;\n}\n\nfloat tri01(float x)\n{\n    return abs(fract(x)-.5)*2.;\n}\n\nvec4 getRand(vec2 pos)\n{\n    return texture(iChannel1,pos/Res1);\n}\n\n// emulated nearest sampling\nvec4 getRandN(vec2 p)\n{\n    vec2 texc=(floor(p)+.5)/iChannelResolution[0].xy;\n    return texture(iChannel1,texc);\n}\n\n// truchet-ish spirally pattern (see https://www.shadertoy.com/view/lssfzX)\nfloat dist(vec2 p, float period, float size)\n{\n    vec2 p1,p2,p3;\n    getTri(p,p1,p2,p3,size);\n    vec4 rnd=getRandN((p1+p2+p3)/2.);\n\tfloat r=rnd.x;\n\tfloat r2=rnd.y;\n\tfloat r3=rnd.z;\n    if(fract(r*2.)>.3333) { vec2 d=p3; p3=p2; p2=p1; p1=d; }\n    if(fract(r*2.)>.6666) { vec2 d=p3; p3=p2; p2=p1; p1=d; }\n    float d = 10000.;\n    float ang;\n    ang = acos(dot(normalize(p-p1),normalize(p3-p1)));\n    d = min(d,length(p-p1)+(floor(r2*2.)*2.-1.)*period*ang/PI*3.);\n    ang = acos(dot(normalize(p-p2),normalize(p3-p2)));\n    d = min(d,length(p-p2)+(floor(r3*2.)*2.-1.)*period*ang/PI*3.);\n    return tri01((d-.5*size)/period)*.5*period;\n}\n\nvec4 getCol(vec2 pos)\n{\n    return texture(iChannel0,pos/iResolution.xy);\n}\n\nfloat getVal(vec2 pos)\n{\n    return dot(getCol(pos).xyz,vec3(.3333));\n}\n\n// modified version of shane's sFloor (https://www.shadertoy.com/view/ldscWH), but\n// just using linear (1.-fx) smoothing also does the trick instead of fx*(1.-fx)\n// and im smoothing after the step (not before as in shane's version)\nfloat sFloorOld(float x, float sm){ float fx = fract(x); return x - max(fx, 1. - fx/fwidth(x)/sm); }\n\n// ... but finally chose to use some power func, to get differentiable smooth edge \n// (gives better normals - see further below)\n// x^n has 1st moment (in the interval 0..1) of 1-1/n (so the width of the edge towards x=1 \n// is prop to 1/n), so (1-fract)^(1/smooth) should give a proper differentiable smoothing\nfloat sFloor(float x, float sm){ float fx = fract(x); return x - fx - pow(1.-fx,2./fwidth(x)/sm); }\n\nfloat quantize(float v, int num)\n{\n    return floor(v*float(num)+.5)/float(num);\n}\n\nfloat squantize(float v, int num, float sm)\n{\n    return sFloor(v*float(num)+.5,sm)/float(num);\n}\n\nfloat gauss(float x)\n{\n    return exp(-x*x);\n}\n\n// final pattern of quantized layers\nfloat htPattern(vec2 pos, int lnum, out vec3 n)\n{\n    float b0=getVal(pos);\n    float bq=quantize(b0,lnum);\n\n    float size=50./sqrt(600./iResolution.x)*(.2+.8*bq)*4.5;\n    size = max(20.,size);\n    float per = size/15.;\n    float thr = per*.5*clamp(.8-sqrt(bq),0.1,.7);\n    \n    vec2 offs = vec2(0);\n    #ifdef MOVE_PATTERN\n    offs = size * .1*vec2(cos(iTime+bq),sin(iTime+bq)*(mod(bq*float(lnum),2.)*2.-1.));\n    #endif\n    float d = dist(pos+offs,per,size);\n    float p = smoothstep(thr-per*.1,thr+per*.1,d)*1.7-.7;\n    n=vec3(0);\n    #ifdef ENGRAVE\n    n=normalize(vec3(-dFdx(d),-dFdy(d),1))*gauss((d-1.5*thr)/per/.07)*.2;\n    #endif\n    return p;\n}\n\n// simple cubemap reflection\nvec4 getReflection(vec2 fragCoord, vec3 n)\n{\n    vec3 dir=normalize(vec3(0,0,-1)+1.5*vec3((fragCoord.xy-iResolution.xy*.5)/iResolution.x,0));\n    float fres=1.-clamp(dot(-dir,n),0.,1.);\n    vec3 R=reflect(dir,normalize(n*vec3(1,1,1)))*vec3(1,-1,1);\n    float c=cos(iTime*.5);\n    float s=sin(iTime*.5);\n    mat2 m=mat2(c,s,-s,c);\n    R.xz=m*R.xz;\n    //fres*=fres;\n    return texture(iChannel3,R*vec3(1,-1,1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define SampNum 24\n    #define Quant (3+int(sqrt(iResolution.x/1920.)*10.))\n    #define Spread 7.\n\tvec2 pos=fragCoord;\n\tfloat b = quantize(getVal(pos),Quant);\n    // smooth quantization\n\tfloat bs  = squantize (getVal(pos),Quant,5.);\n    float delta=2.7*sqrt(iResolution.y/1080.);\n    vec2 eps=vec2(delta,0);\n    // gradient of smooth quantization (for normals)\n\tvec2 bsgrad=vec2(0);\n    bsgrad.x += squantize (getVal(pos+eps.xy),Quant,delta);\n    bsgrad.x -= squantize (getVal(pos-eps.xy),Quant,delta);\n    bsgrad.y += squantize (getVal(pos+eps.yx),Quant,delta);\n\tbsgrad.y -= squantize (getVal(pos-eps.yx),Quant,delta);\n\tfloat bs3 = squantize (getVal(pos),Quant,3.7);\n\n    // calc some ambient occlusion\n    float ao=0.;\n    float ao2=0.;\n    float spread = Spread*sqrt(Res.x/600.);\n    for(int i=0;i<SampNum;i++)\n    {\n        vec2 delta = texture(iChannel1,(pos+vec2(0,123*i))/Res1).xy*2.-1.;\n\t    // lets spread slightly off axis\n    \t// so we get the impression of a diffuse lightsource from upper left\n        // and lets take 2 diffuse light sources\n        vec2 delta1=delta+vec2(-.5,.3)*.7;    // from upper right\n        vec2 delta2=delta+vec2(.7,.5)*.7;     // from upper left\n        \n        float b1 = quantize(getVal(pos+spread*delta1),Quant);\n        float b2 = quantize(getVal(pos+spread*delta2),Quant);\n        if(b1>b) ao+=(1.-length(delta1))+1.;\n        if(b2>b) ao2+=(1.-length(delta2))+1.;\n        //if(b2>b) ao+=1.;\n    }\n    ao/=float(SampNum);\n    ao2/=float(SampNum);\n\n    // 2 light colors from 2 different directions\n    vec3 col1=vec3(.5,0.,-.5)*2.+1.;\n    vec3 col2=vec3(-.5,0.,.5)*2.+1.;\n    \n    float bc = getVal(pos);\n    float s=sin((bc*float(Quant)+.5)*PI)*.03*sqrt(1280./iResolution.y)/fwidth(bc);\n    float outline=exp(-s*s);\n    \n    vec4 rand=vec4(0);\n    #ifdef BRUSHED\n    rand=getRand(pos*vec2(1.3,.15)*.75)-.5+getRand(pos*vec2(.15,1.3)*.75)-.5;\n    #endif\n    \n    // calc pattern and normals\n    vec3 n=normalize(vec3(-1.5*bsgrad,1));\n    vec3 n2;\n\tfloat patt = htPattern(pos,Quant,n2);\n    n=normalize(n+vec3(rand.xy*.03,0)+vec3(n2.xy,0));\n\n    \n    fragColor=vec4(1);\n    \n#ifdef REFLECTION\n    // cubemap reflection\n    fragColor=fragColor*.6+getReflection(fragCoord,n)*.4;\n#endif\n    \n    // apply ao and pattern\n\tfragColor *= vec4(0)+(\n        +.45*vec4(col1,1)*(1.-.5*ao )\n        +.55*vec4(col2,1)*(1.-.5*ao2)\n                        )*(.8+.3*b)*(.6+.05*rand.x+.4*patt);\n\t\n    // diffuse lighting\n    fragColor*=max(.9,dot(n,vec3(1,1,1)));\n    \n    // vignetting\n    vec2 c=(fragCoord.xy-.5*Res)/(.8*Res.x);\n    float vign=clamp(1.2-1.*dot(c,c),0.,1.);\n    fragColor*=vign;\n    \n    // slightly emphasize the outlines of the quantization layers\n    fragColor.xyz*=1.-.4*outline;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// smoothing in X\n\n#define Res  iResolution.xy\n#define Res0 iChannelResolution[0].xy\n\nvec2 TC(vec2 c)\n{\n    //all image visible on screen\n    float sc=min(Res.x/Res0.x,Res.y/Res0.y)*.95;\n    \n    //one axis of image fully visible on screen\n    //float sc=max(Res.x/Res0.x,Res.y/Res0.y);\n    \n    //compromise of the 2 above cases\n    //float sc=mix(Res.x/Res0.x,Res.y/Res0.y,.5);\n    \n    return (c-Res*.5)/sc+Res0*.5;\n}\n\nvec2 sstep(float x1, float x2, vec2 x)\n{\n    return smoothstep(x1,x2,x);\n    return clamp((x-x1)/(x2-x1),0.,1.);\n}\n\nvec4 getVal(vec2 c) {\n    vec2 uv=TC(c)/Res0.xy;\n    //if(uv.x<.0 || uv.y<.0 || uv.x>1. || uv.y>1.) return vec4(.5);\n    float fade = .05;\n    vec2 s=sstep(1.-fade,1.,uv);\n    s=max(s,-(sstep(.0,fade,uv)-1.));\n    float d;\n\t// edge-rounded fade out\n    d=length(max(\n            \tmax(uv-vec2(1.-fade),vec2(0)),\n             \tmax(-uv+vec2(fade),vec2(0))\n             ))/fade;\n\t// strict rectangular fade out\n    d=max(s.x,s.y);\n    return mix(texture(iChannel0,uv),vec4(.5),clamp(d,0.,1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c=vec4(0);\n    float n=0.;\n#define W 2\n    for(int i=-W;i<=W;i++)\n    {\n        float fact=1.-.0*float(i)/float(W+1);\n        c+=fact*getVal(fragCoord+vec2(float(i),0)*Res.x/Res0.x);\n        n+=fact;\n    }\n    fragColor = c/n;\n    // no vid tex in next pass so put its size on pixel 0,0\n    if(floor(fragCoord.x)==0. && floor(fragCoord.y)==0.) fragColor.xy=Res0;\n    //fragColor = getVal(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// smoothing in Y\n\n#define Res  iResolution.xy\n\nvec4 getVal(vec2 c) {\n    vec2 uv=c/Res.xy;\n    if(uv.x<.0 || uv.y<.0 || uv.x>1. || uv.y>1.) return vec4(.5);\n    return texture(iChannel0,uv); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // no vid tex here so get its size on pixel 0,0 from previous pass\n    vec2 Res0 = getVal(vec2(0.5,0.5)).xy;\n    vec4 c=vec4(0);\n    float n=0.;\n#define W 2\n    for(int i=-W;i<=W;i++)\n    {\n        float fact=1.-.0*float(i)/float(W+1);\n        c+=fact*getVal(fragCoord+vec2(0,float(i))*Res.x/Res0.x);\n        n+=fact;\n    }\n    fragColor = c/n;\n    //fragColor = getVal(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}