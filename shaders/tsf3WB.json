{
    "Shader": {
        "info": {
            "date": "1548451130",
            "description": "3D voxels with a 2D outline. Analytic box intersections. Supersampling to anti-alias interior. Cividis colors for color-blind safe perceptually uniform shading. Perlin background.\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tsf3WB",
            "likes": 39,
            "name": "Cuborder",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "distancefield",
                "ray",
                "cube",
                "perlin",
                "voxel",
                "antialiasing",
                "analytic",
                "outline",
                "cividis"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 1037
        },
        "renderpass": [
            {
                "code": "/// by Dom Mandy in 2019\n\n\n/*\nvector form of a line\n*/\nstruct Line {\n    // unit vector in the direction of the line\n    vec3 direction;\n    // position of a point on the line\n    vec3 point;\n};\n\n\n/*\ngeometry of a shape used for rendering\n*/\nstruct Shape {\n    // distance to outline of shape\n    float dist;\n    // surface normal of shape\n    vec3 normal;\n};\n\n\n/*\nlocation in the hexagonal grid\n*/\nstruct Hex {\n    // index of current hexagon\n    vec2 index;\n    // offset from center of current hexagon\n    vec2 point;\n};\n\n\n/*\nclone geometry in hexagonal pattern\n*/\nHex hexGrid (vec2 point, float gridSize) {\n    const float hexSize = 1.0;\n    vec2 q = point * gridSize;\n    Hex hex;\n    hex.index = pixel_to_pointy_hex(q, hexSize);\n    hex.point = q - pointy_hex_to_pixel(hex.index, hexSize);\n    return hex;\n}\n\n\n/*\nmaximum element of absolute value of vector\nhttps://en.wikipedia.org/wiki/Uniform_norm\n*/\nfloat supremumNorm(vec3 v) {\n    vec3 u = abs(v);\n    float norm = max(max(u.x, u.y), u.z);\n    return norm;\n}\n\n\n/*\ncalculates geometry of a cube\n*/\nShape cube(Line line, float radius) {\n    /// find distance\n    float dist;\n    const int size = 3;\n    // search edges of cube for nearest point\n    dist = 999999999.0;\n    for (int m = 0; m < size; m++)\n    {\n        float t;\n        vec3 v;\n        float d;\n        \n        int n = (m + 1) % size;\n        float x = line.point[m];\n        float y = line.point[n];\n        float i = line.direction[m];\n        float j = line.direction[n];\n        \n        t = (-x + y) / (i - j);\n        v = line.point + line.direction * t;\n        d = supremumNorm(v);\n        dist = min(dist, d);\n        \n        t = (-x - y) / (i + j);\n        v = line.point + line.direction * t;\n        d = supremumNorm(v);\n        dist = min(dist, d);\n    }\n    dist -= radius;\n    /// find normal\n    // sample normals in plane around point\n    vec3 horizontal = cross(line.direction, vec3(0.0, 1.0, 0.0));\n    vec3 vertical = cross(horizontal, line.direction);\n    // give extra weight to the normal of the current point\n    float total;\n    vec3 normal;\n    // sample normals in octagonal pattern\n    for(float i = -1.0; i <= 1.0; i++)\n    {\n        for(float j = -1.0; j <= 1.0; j++)\n        {\n            vec3 offset = 0.015625 * radius * (i * horizontal + j * vertical);\n            normal += boxNormal(line.direction, line.point + offset, radius);\n            \n            total++;\n        }\n    }\n    // blur normals together\n    normal /= total;\n    /// return shape data\n    Shape shape;\n    shape.dist = dist;\n    shape.normal = normal;\n    \n    return shape;\n}\n\n\n/*\nrotates a vector by a given angle (in radians) around a given axis (must be a unit vector)\nhttps://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\n*/\nvec3 rotationRodrigues(vec3 v, vec3 axis, float angle) {\n    float c = cos(angle);\n    return v * c + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - c);\n}\n\n\n/*\ndiffuse lighting\n*/\nvec3 lightDiffuse(vec3 normal, vec3 light) {\n    float intensity = 0.5 + 0.5 * dot(normal, light);\n    // cache useful cividis values for performance\n\tconst int cividisCount = cividis.length() - 1;\n\tconst float cividisScale = float(cividisCount);\n    // approximately cividis scale sampling\n    intensity *= cividisScale;\n    int index = int(round(intensity));\n    vec3 color = cividis[index];\n    return color;\n}\n\n\n/*\nmanage the light and camera for the scene\n*/\nvoid lightsCameraAction(vec2 point, out Line viewLine, out vec3 light, float time) {\n    vec3 viewPoint, viewDirection;\n    float angle;\n    vec3 axis;\n    // rotate 1/8th turn around the x-axis and 1/8th turn around the y-axis\n    angle = 1.09606;\n    axis = vec3(0.678598, 0.678598, -0.281086);\n    viewPoint = vec3(point, -100.0);\n    viewPoint = rotationRodrigues(viewPoint, axis, angle);\n    viewDirection = vec3(0.5, -0.707108, 0.499998);\n    light = vec3(-0.406773, 0.814675, 0.41333);\n    // animate rotation\n    angle = time;\n    axis = vec3(0.57735, 0.57735, 0.57735);\n    viewPoint = rotationRodrigues(viewPoint, axis, angle);\n    viewDirection = rotationRodrigues(viewDirection, axis, angle);\n    light = rotationRodrigues(light, axis, angle);\n    // construct view line\n    viewLine.point = viewPoint;\n    viewLine.direction = viewDirection;\n}\n\n\n/*\ndraw antialiased point with minimum pixel size\n*/\nvec3 draw(in vec3 buffer, in float dist, in float radius, in vec3 color) {\n    float up = min(iResolution.x, iResolution.y);\n    dist *= up;\n    const float scale =  1.0 / 360.0;\n    radius *= up * scale;\n  \tfloat aa = 0.5 * fwidth(dist);\n    vec3 mixed = mix(buffer, color, 1.0 - smoothstep(radius - aa, radius + aa, dist));\n   \treturn mixed;\n}\n\n\n/*\nrender scene\n*/\nvec3 render(vec2 fragCoord, Line line, vec3 light, float gridSize, float time, float zoom) {\n    // find shape\n    const float radius = 1.0 / 3.0;\n    Shape cube = cube(line, radius);\n    float dist = cube.dist;\n    vec3 normal = cube.normal;\n    // no-see-um green with Perlin noise for background\n    const vec3 green = vec3(139.0 / 255.0, 153.0 / 255.0, 153.0 / 255.0);\n    vec3 background = green + 0.0625 * vec3(perlin(fragCoord, 1.0, fract(iTime)));\n    // add lighting\n    vec3 color;\n    color = lightDiffuse(normal, light);\n    // check whether the pixel is on a shape or the background\n    float isInside = float(dist <= 0.0);\n    color = background * (1.0 - isInside) + isInside * color;\n    // distance to shape edge\n    float outline = abs(dist);\n    // desired pixel radius of line\n    float lineRadius = 1.0;\n    // compensate for grid\n    lineRadius *= gridSize;\n    // draw shape outline\n    vec3 border = mix(vec3(0.0), vec3(0.25), zoom);\n    color = draw(color, outline, lineRadius, border);\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    const float pi = 3.1415926535897932384626433832795;\n    // normalize pixel coordinates and center on origin\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    // zoom in and out\n    float zoom = smoothstep(-1.0, 1.0, cos(0.5 * iTime));\n    float gridSize = mix(3.0, 21.0, zoom);\n    // map to hexagonal grid\n    Hex hex = hexGrid(uv, gridSize);\n    // lock everything to running time\n    const float speed = 2.0;\n    float time = speed * iTime;\n    // alternate animation timing on hex grid\n    const vec2 c = vec2(1.0, 2.0);\n    float vertexColor = dot(mod(hex.index, 2.0), c);\n    const float shift = pi / 6.0;\n    time += vertexColor * shift;\n    // set up the camera and light for the scene\n    Line viewLine;\n    vec3 light;\n    lightsCameraAction(hex.point, viewLine, light, time);\n    // render objects\n    vec3 color = render(fragCoord, viewLine, light, gridSize, time, zoom);\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// color-blind safe and perceptually uniform color scale\n/// adapted from:\n/// https://github.com/marcosci/cividis\nconst vec3[] cividis = vec3[]\n(\n    vec3(0.0000, 0.1262, 0.3015),\n\n\tvec3(0.0000, 0.1408, 0.3334),\n\n\tvec3(0.0000, 0.1546, 0.3676),\n\n\tvec3(0.0000, 0.1685, 0.4031),\n\n\tvec3(0.0000, 0.1817, 0.4347),\n\n\tvec3(0.0000, 0.1930, 0.4361),\n\n\tvec3(0.0000, 0.2073, 0.4329),\n\n\tvec3(0.0710, 0.2215, 0.4293),\n\n\tvec3(0.1204, 0.2357, 0.4262),\n\n\tvec3(0.1566, 0.2498, 0.4236),\n\n\tvec3(0.1868, 0.2639, 0.4217),\n\n\tvec3(0.2133, 0.2780, 0.4205),\n\n\tvec3(0.2375, 0.2920, 0.4200),\n\n\tvec3(0.2599, 0.3060, 0.4202),\n\n\tvec3(0.2811, 0.3200, 0.4210),\n\n\tvec3(0.3014, 0.3340, 0.4224),\n\n\tvec3(0.3209, 0.3481, 0.4244),\n\n\tvec3(0.3398, 0.3622, 0.4270),\n\n\tvec3(0.3582, 0.3763, 0.4302),\n\n\tvec3(0.3763, 0.3904, 0.4338),\n\n\tvec3(0.3940, 0.4047, 0.4381),\n\n\tvec3(0.4114, 0.4189, 0.4430),\n\n\tvec3(0.4286, 0.4333, 0.4485),\n\n\tvec3(0.4456, 0.4477, 0.4547),\n\n\tvec3(0.4622, 0.4622, 0.4620),\n\n\tvec3(0.4790, 0.4767, 0.4691),\n\n\tvec3(0.4971, 0.4915, 0.4723),\n\n\tvec3(0.5158, 0.5065, 0.4736),\n\n\tvec3(0.5349, 0.5216, 0.4738),\n\n\tvec3(0.5541, 0.5368, 0.4733),\n\n\tvec3(0.5735, 0.5522, 0.4720),\n\n\tvec3(0.5931, 0.5678, 0.4701),\n\n\tvec3(0.6129, 0.5835, 0.4673),\n\n\tvec3(0.6328, 0.5993, 0.4641),\n\n\tvec3(0.6529, 0.6153, 0.4600),\n\n\tvec3(0.6732, 0.6315, 0.4553),\n\n\tvec3(0.6936, 0.6478, 0.4499),\n\n\tvec3(0.7142, 0.6643, 0.4437),\n\n\tvec3(0.7350, 0.6810, 0.4368),\n\n\tvec3(0.7560, 0.6979, 0.4290),\n\n\tvec3(0.7771, 0.7150, 0.4205),\n\n\tvec3(0.7985, 0.7322, 0.4111),\n\n\tvec3(0.8200, 0.7497, 0.4007),\n\n\tvec3(0.8417, 0.7674, 0.3892),\n\n\tvec3(0.8636, 0.7853, 0.3766),\n\n\tvec3(0.8858, 0.8035, 0.3627),\n\n\tvec3(0.9082, 0.8219, 0.3474),\n\n\tvec3(0.9308, 0.8405, 0.3306),\n\n\tvec3(0.9536, 0.8593, 0.3116),\n\n\tvec3(0.9767, 0.8785, 0.2901),\n\n\tvec3(1.0000, 0.8979, 0.2655),\n\n\tvec3(1.0000, 0.9169, 0.2731)\n);\n/// Inigo Quilez's analytic box normal  \n/// adapted from:\n/// https://iquilezles.org/articles/boxfunctions\nvec3 boxNormal( vec3 direction, vec3 point, float radius )\n{\n    vec3 n = point / direction;\n    vec3 s = sign(direction);\n    vec3 k = s * radius / direction;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 normal = -s * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    \n    return normal;\n}\n/// math to convert from cartesian coordinates to hexagonal coordinates\n/// adapted from: \n/// https://www.redblobgames.com/grids/hexagons\nvec2 cube_to_axial(vec3 cube)\n{\n    return cube.xz;\n}\nvec3 axial_to_cube(vec2 hex)\n{\n    float x = hex.x;\n    float z = hex.y;\n    float y = -x - z;\n    return vec3(x, y, z);\n}\nvec3 cube_round(vec3 cube)\n{\n    float rx = round(cube.x);\n    float ry = round(cube.y);\n    float rz = round(cube.z);\n\n    float x_diff = abs(rx - cube.x);\n    float y_diff = abs(ry - cube.y);\n    float z_diff = abs(rz - cube.z);\n\n    bool isA = x_diff > y_diff && x_diff > z_diff;\n    float fIsA = float(isA);\n    rx = fIsA * (-ry-rz) + (1.0 - fIsA) * rx;\n    \n    bool isB = !isA && y_diff > z_diff;\n    float fIsB = float(isB);\n    ry = fIsB * (-rx-rz) + (1.0 - fIsB) * ry;\n    \n    float isC = float(!isA && !isB);\n    rz = isC * (-rx-ry) + (1.0 - isC) * rz;\n\n    return vec3(rx, ry, rz);\n}\nvec2 hex_round(vec2 hex)\n{\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\nconst float sqrt3 = sqrt(3.0);\nvec2 pixel_to_pointy_hex(vec2 point, float size)\n{\n    vec2 hex;\n    const float thirdSqrt3 = sqrt3 / 3.0;\n    const float third = 1.0 / 3.0;\n    const float twoThirds = 2.0 / 3.0;\n    hex.x = (thirdSqrt3 * point.x -     third * point.y) / size;\n    hex.y = (\t\t\t\t\t    twoThirds * point.y) / size;\n    return hex_round(hex);\n}\nvec2 pointy_hex_to_pixel(vec2 hex, float size)\n{\n    const float halfSqrt3 = 0.5 * sqrt3;\n    vec2 pixel;\n    pixel.x = size * (sqrt3 * hex.x  +  halfSqrt3 * hex.y);\n    pixel.y = size * (                        1.5 * hex.y);\n    return pixel;\n} \n/// Perlin noise\n/// adapted from: \n/// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n#define M_PI 3.14159265358979323846\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand (vec2 co, float l) {return rand(vec2(rand(co), l));}\nfloat rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}