{
    "Shader": {
        "info": {
            "date": "1723903681",
            "description": "3d projection of 4d raymarch",
            "flags": 32,
            "hasliked": 0,
            "id": "MXVSDm",
            "likes": 5,
            "name": "bubble trouble",
            "published": 3,
            "tags": [
                "raymarch",
                "4d",
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 100
        },
        "renderpass": [
            {
                "code": "// Fork of \"mandelbubbles4d\" by pb. https://shadertoy.com/view/M3VSDw\n// 2024-07-04 04:37:35\n\n//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Gaussian blur effect\n    vec2 texel = 1.0 / iResolution.xy;\n    vec4 total_color = vec4(0.0);\n\n    // Gaussian kernel\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    // Apply Gaussian blur to the texture from channel 0\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i) - 2.0;\n        for (int j = 0; j < 5; j++) {\n            float fj = float(j) - 2.0;\n            vec4 color = texture(iChannel0, uv + vec2(texel.x * fi, texel.y * fj));\n            total_color += color * gk1s[i * 5 + j];\n        }\n    }\n\n    // Output the final color\n    fragColor = total_color;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos(  h + vec3(3,2,6)   )*.6 + .5 )\n\n#define H2(h)  (  cos(  h + vec3(1,2,1)   )*.7 + .2 )\n\n//formula for mapping scale factor \n#define M(c)  log(1.+c)\n\n#define R iResolution\n\n\nvoid mainImage( out vec4 O, vec2 U) {\n  \n    O = vec4(0);\n    \n    vec3 c=vec3(0);\n    vec4 rd = normalize( vec4(U-.5*R.xy, .5*R.y, R.y*2.))*100.;\n    \n    float param = mod(iTime,10.)<5.?.2:.15;\n    \n    float sc,dotp,totdist=0., tt=iTime/3., t=0.;\n    \n    for (float i=0.; i<70.; i++) {\n        \n        float snd = texture(iChannel0, vec2(i,.25)).r;\n        vec4 p = vec4( rd*totdist);\n            \n        p.xyz += vec3(0,0,-400); \n        \n        p.xz *= rot( iTime*.1 + tt/2. + abs(sin(tt/3.)));\n           \n        p.yzw = ROT(p.xyz, normalize( vec3(sin(t/2.), cos(t/3.), 0. )  ),t);\n\n        sc = 1.; \n        \n        p.zw *= rot(tt);\n  \n        vec4 w = p;\n        \n        for (float j=0.; j<7.; j++) {\n          \n            p = abs(p)*.65+.25*snd;\n       \n            \n            dotp = max(1./dot(w,w),.1);\n            sc *= dotp*1.05+.2*snd; \n            \n            p = p * dotp - .65; \n            \n            w = .8*log(1.+abs(p)*p*p) - param;\n            \n        }\n         \n        float dist = abs( length(p)-.1)/sc ;  //funky distance estimate\n        float stepsize = dist/8. ;     \n        totdist += stepsize;                  //move the distance along rd\n        \n        //accumulate color, fading with distance and iteration count\n        c +=\n             3e-2* H2(  atan( p.w, p.z )) + \n             + mix( vec3(1), H(M(sc)),.95) *.02*  exp(-i*i*stepsize*stepsize/4.);\n    }\n    \n    c = 1. - exp(-c*c);\n    O = ( vec4(c,0) );\n               \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}