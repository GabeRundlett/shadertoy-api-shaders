{
    "Shader": {
        "info": {
            "date": "1600168525",
            "description": "inspired by https://www.youtube.com/watch?v=iAHlyoCfhfo\nconvex recomended",
            "flags": 0,
            "hasliked": 0,
            "id": "WtjfDt",
            "likes": 4,
            "name": "PolygonSpiralDrawing(drug mouse)",
            "published": 3,
            "tags": [
                "2d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "Arseny",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "const int N = 4;\n//must be counterclockwise order\nvec2 points[N] = vec2[N](vec2(0., 0.4), vec2(0.), vec2(-0.34641, -0.2), vec2(0.34641, -0.2));\n\n#define points(i) (points[((i) % N + N) % N])\n\nconst int steps = 20;\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat cross2(vec2 a, vec2 b){\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 rot90(vec2 a){\n    return vec2(-a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    points(1) = m;\n    \n    float mask = sdSegment(uv, points(0), points(N - 1));\n    \n    float t = mix(0.17, 0.3, sin(iTime) / 2. + 0.5);\n    \n    for (int k = 0; k < steps; k++){\n        for (int i = 0; i < N; i++){\n            vec2 now = points(i);\n            mask = min(mask, sdSegment(uv, now, points(i + 1)));\n            vec2 np = mix(now, points(i + 1), t);\n            vec2 prev = points(i - 1);\n            if (cross2(now - prev, np - prev) < 0.){\n                // trying to reflect new segment to inside of uncovex polygon but look interesting\n                // if polygon is convex it's not used\n                // actually it's not best way because it's not good with self-crossing\n                vec2 n = normalize(now - prev);\n                vec2 v = np - now;\n                //np = reflect(np - now, rot90(n)) + now;\n                np = 2. * dot(v, n) * n - v + now;\n            }\n            points[i] = np;\n        }\n    }\n    \n    vec3 col = vec3(mask * iResolution.y);\n    //fragColor = vec4( pow( mask * iResolution.y / 3., 1./2.2) );  look bad i think\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}