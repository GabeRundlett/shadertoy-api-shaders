{
    "Shader": {
        "info": {
            "date": "1708388786",
            "description": "I was doing some pie-charts at work, so decided to make a pie-chart shader. Kind of looks like donuts though.\nI also figured out this pretty tiny function for drawing arcs.",
            "flags": 0,
            "hasliked": 0,
            "id": "X3S3Dh",
            "likes": 5,
            "name": "Simple arc / pie-chart function",
            "published": 3,
            "tags": [
                "chart",
                "donut",
                "arc",
                "pie"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nfloat hash21(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat arc(vec2 p, vec2 angles, float t, float radi) {\n  angles = radians(angles);\n  float angle = mod(atan(p.y, p.x), TAU);\n  float dist = length(p);\n  float c1 = dist - (radi - t);\n  float c2 = (radi + t) - dist;\n  float c3 = angle - angles.x;\n  float c4 = angles.y - angle;\n  return exp(min(c1, min(c2, min(c3, c4)))/t);\n}\n\nvec3 pie(vec2 p, vec2 v[4], mat4x3 colors, float g) {\n  vec3 col = vec3(0.0);\n  vec3 c1 = colors[0]; c1 = c1 * c1;\n  vec3 c2 = colors[1]; c2 = c2 * c2;\n  vec3 c3 = colors[2]; c3 = c3 * c3;\n  vec3 c4 = colors[3]; c4 = c4 * c4;\n  return arc(p, v[0].xy, g, 0.3)*c1 +\n         arc(p, v[1].xy, g, 0.3)*c2 +\n         arc(p, v[2].xy, g, 0.3)*c3 +\n         arc(p, v[3].xy, g, 0.3)*c4;\n}\n\nvec3 grid(vec2 p) {\n    vec3 col = vec3(0.0);\n    vec2 id = floor(p);\n    vec2 lv = fract(p)-0.5;\n    \n    float v1 = hash21(id, 49.6327);\n    float v2 = hash21(id, 31.9182);\n    float v3 = hash21(id, 88.7715);\n    float v4 = hash21(id, 55.1193);\n    float v5 = hash21(id, 12.4512);\n    float dt = (dFdx(p.x) + dFdy(p.y));\n    float gt = dt*24.;\n    col += 0.025*max(\n        smoothstep(gt, 0.0, abs(lv.x-(1.0-gt))),\n        smoothstep(gt, 0.0, abs(lv.y-(1.0-gt)))\n    );\n    float b1 = v1 +TAU*(0.5+0.5*sin(T+40.0*TAU*v1));\n    float b2 = v1 + TAU*(0.5+0.5*cos(T+40.0*TAU*v2));\n    float s1 = 0.0;\n    float s2 = s1+(b2*90.0);\n    float s3 = s2+(90.0/b2);\n    float s4 = s3+b1*90.0;\n    float s5 = s4+(90.0/b1);\n    \n    v1 += b1*b1*v2*0.15;\n    v2 += b2*b2*v1*0.15;\n    v3 += v5*v5*0.15;\n    v4 += v5*v4*v3*0.15;\n    col += pie(lv, vec2[4](\n        vec2(s1, s2),\n        vec2(s2, s3),\n        vec2(s3, s4),\n        vec2(s4, s5)\n    ), mat4x3(\n        vec3(v1,  v4,   v3),\n        vec3(v4,  v2,   v5),\n        vec3(v5,  v2,   v3),\n        vec3(v1,  v5,   v4)\n    ), mix(dt*0.25, dt*0.5, fract(v4*10.091812+v5*3.3)));\n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n  uv *= mix(0.5, 1.5, 0.5+0.5*sin(T));\n  col += grid((uv-0.5)*8.);\n  col = aces(col);\n  col = pow(col, vec3(1.0/2.2)); \n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}