{
    "Shader": {
        "info": {
            "date": "1670534083",
            "description": "challange: \nwho can make 1000 polygons rotating seperatly without calculating 1000 polygons and taking the min distance\nmatrix transformation is oviously not working?\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ddBXzV",
            "likes": 4,
            "name": "polygons like 11235 #3?",
            "published": 3,
            "tags": [
                "polygon"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 165
        },
        "renderpass": [
            {
                "code": "// signed distance to a regular n-gon\nfloat f_n_dist_ngon( \n    float n_sides,\n    float n_radius,\n    vec2 o_trpino\n    )\n{\n    vec2 o_delta = -o_trpino;\n    float n_tau = 6.2831;\n    float n_ang_rad = atan(o_delta.y, o_delta.x)+(n_tau/2.);\n    float n_rad_per_side = n_tau / n_sides;\n    float n_side = floor(n_ang_rad / n_rad_per_side);\n    if(fract(n_ang_rad / n_rad_per_side) > 0.5){\n        n_side +=1.;\n    }\n    float n_radius_plusminus = (0.5-abs(fract(n_ang_rad / n_rad_per_side)-0.5));\n\n    float n_ang_rad_side = n_rad_per_side * n_side;\n    vec2 o_delta_side = \n        o_trpino - \n        vec2(\n            cos(n_ang_rad_side)*(n_radius+n_radius_plusminus), \n            sin(n_ang_rad_side)*(n_radius+n_radius_plusminus) \n        );\n    float n_dist_side = length(o_delta_side);\n    float n_dist = length(o_trpino);\n    return length(o_trpino)+sin(n_radius_plusminus*n_tau)*n_dist*0.14;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_scale = vec2(0.032);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    float n_tau = 6.2831;\n    //float rot = (sin(length(o_trpino)+iTime));\n    float n_radians_matrot = (sin(length(o_trpino)*10.+iTime));\n    //n_radians_matrot = 0.;\n    // algebra formula for rotation by matrix , https://en.wikipedia.org/wiki/Rotation_matrix\n    mat2 o_mat = mat2(cos(n_radians_matrot), -sin(n_radians_matrot), sin(n_radians_matrot), cos(n_radians_matrot));\n    o_trpino = o_mat*o_trpino;\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n\n    float n_dist = f_n_dist_ngon(\n        3., \n        length(o_trpino)/2., \n        o_trpino\n    );\n    fragColor = vec4(sin(n_dist*n_tau*20.));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}