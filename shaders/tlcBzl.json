{
    "Shader": {
        "info": {
            "date": "1613240307",
            "description": "Abs(vec3) not working???? This should display a volumetric cube, on my system it displays a tower(due to negative y).",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcBzl",
            "likes": 6,
            "name": "Abs(vec3) bug on my Nvidia GPU",
            "published": 3,
            "tags": [
                "working",
                "not",
                "abs",
                "vec3"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "/*Correct result: https://i.imgur.com/LPINgi4.png\nIncorrect result: https://i.imgur.com/2A0D9GR.png\n\nThis should display a volumetric cube when abs() functions properly.\nInstead on my system(Win10, Nvidia GTX 980) it displays a tower,\nbecause y axis stays signed for some reason. It's not just WebGL this shader is broken\nfor me on desktop OpenGL as well and when I disable ANGLE.\n\nThis can be fixed by manually doing abs() with rp*sign(rp), but it's absolutely\ncrazy to me that abs() doesn't work here. Testing a bit more if you just output\nrp.y by doing\n\no = vec4(rp.y);\nreturn;\n\nit shows a proper mirrored gradient, meaning rp.y as being unsigned and\nabs() functioning correctly! Something about the box distance function\ncauses the compiler or GPU to remove the Y axis part of abs?\n\nMore testing I found that abs(rp*vec3(1,1.00001,1)) fixes it as well, I\nam confuse.\n*/\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    o = vec4(0);\n    vec3 rd = normalize(vec3((u*2.-iResolution.xy)/iResolution.y,1));\n    for (float q = .1; q < 4.; q += .1) {\n        vec3 rp = rd*q;\n        rp.z -= 2.;\n        float a = iTime;\n        rp.xz *= mat2(cos(a),-sin(a),sin(a),cos(a));\n        \n        \n        //broken for me? y axis stays signed and creates tower instead of box??????\n        rp = abs(rp);\n        \n        //manual abs, works properly\n        //rp = rp*sign(rp);\n        \n        //mutliplying y by a small amount forces it to work properly\n        //rp = abs(rp*vec3(1,1.001,1));\n        \n        \n        //output rp.y, its signed if the bottom half of the screen is black\n        //o = vec4(rp.y*10.);\n        //return;\n        \n        \n        //box unsigned distance function\n        float s = length(max(rp-vec3(.5),0.));\n        \n        \n        //volume accumulation\n        o += vec4(max(0.,1.-s*10.)*.1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}