{
    "Shader": {
        "info": {
            "date": "1607872035",
            "description": "Implicit function distance estimation.\nThis is mainly a test to verify if WebGL does a good job at optimising expression. It seems to be the case.",
            "flags": 32,
            "hasliked": 0,
            "id": "tsyfDy",
            "likes": 16,
            "name": "Implicit Function DE",
            "published": 3,
            "tags": [
                "de",
                "function",
                "implicit"
            ],
            "usePreview": 0,
            "username": "knighty",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "// --- sliders and mouse widgets -------------------------------------------\n//Adapted from FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n\nvec2 R; //= iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { // display mouse states ( color )\n    vec4 mouse = UI(33);                       // current mouse pos\n    float k = length(mouse.xy/R.y-uv)/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy/R.y-uv)/Mradius;     // prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)/R.y-uv)/Mradius;  // drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { // display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l/Bradius);\n    }\n    return 0.;\n}        \n\n//------------------------------------------------------------------------------------\n\n#define PI2\t( PI * 2.0 )\n\n//Dynamic variables\n//bool DisplayOriginal = false;\n\n//float halfWidth = 0.5, SFactor=1., RFactor=0., Radius=1.;\n//vec3 Offset = vec3(0);\n\nvoid init() {//setup folding planes and vertex\n\tfloat t=iTime;\n    /*halfWidth=0.1*UI(1).a;// Voxel width / 2.\t\t\tLeftmost slider\n    SFactor  =UI(2).a;// Shrink factor of Voxels\n    RFactor  =UI(3).a;// Roundness of Voxels\n    Offset.x =UI(4).a;// Voxel offset\n    Offset.y =UI(5).a;\n    Offset.z =UI(6).a;\n    \n    Radius   =UI(7).a * 2.;\n    \n    DisplayOriginal = UI(17).a < 0.;*/\n}\n\nvec3 getColor(vec3 pos, vec3 normal){\n\n\treturn baseColor(pos, normal);\n    //return vec3(.9,0.6,0.8);\n}\n\n//------------------------------------------------------------------\n//From gaz's : https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p)\n{\n    return DE(p);//DE() is defined in \"Common\"\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.0001;//cusps look better with high precision\n    float h = precis * 2.0;\n    float t = 1.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 256; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    vec4 mouse = UI(35);//R.y;\n    //mouse.xy = clamp(mouse.xy, vec2(-180.,-90.), vec2(180.,90.));\n    \n    p.zx = rotate(p.zx, iTime * 0. - (mouse.x)*PI/360.);\n    p.yz = rotate(p.yz, iTime * 0. + (mouse.y)*PI/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Global variable init\n    R = iResolution.xy;\n    //--------------------\n    vec2 uv = fragCoord.xy/R.y;\n    //vec4 mouse = UI(33)/R.y;\n    \n\t// display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float s = aff_buttons(uv); if (s>0.) { fragColor = s*vec4(0,.2,1,1); return;}}\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.3 + p.y * 0.1);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 5.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos,n) * dif + .5*pow(dif, 200.);\n        col = pow(col, vec3(0.45));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//By FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n//With some modifications\n\n// only line 0, pixels 0 to 33 of bufA are used\n// if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 1 // fake mouse motion if no user input\n#define Sradius .02  // influence radius for sliders\n#define Bradius .04  // influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\nvec2 R;// = iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\nbool insideSlider(vec2 U, vec4 S){\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Sradius && abs(U.x-S.x-l/2.)<l/2. ) return true;\n        if (S.z<0. && abs(U.x-S.x)<Sradius && abs(U.y-S.y-l/2.)<l/2. ) return true;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return true;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return true;\n    return false;       \n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    R = iResolution.xy;\n    \n    O = texture(iChannel0,U/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        //add_slider (.05,.05,VERTIC,.5,.5); // --- define your sliders here ---\n                \n        //add_button ( .05,.95, -1.);          // --- define your buttons here ---\n                \n        if (U==vec2(0,0)) O = vec4(nbS, nbB, 0., 0.);\n        if (U==vec2(35,0)) O = vec4(0.);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)==0. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (U==vec2(35,0)){\n        if(iMouse.z/iResolution.y > 0.0 && iMouse.z/iResolution.y < float(iResolution.x)/float(iResolution.y)-0.0)\n            O.xy = O.zw + iMouse.xy - iMouse.zw;\n        else O = O.xyxy;\n        return;\n    }\n    \n    \n    if (iMouse.z>0. && U.y==0.) {          // --- let mouse trigers the right slider or button\n       \tvec2 M = iMouse.xy/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n        \tvec2 m = iMouse.xy/iResolution.y;\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l/2.)<l/2. ) O.a = (M.x-S.x)/l;\n    \t    if (S.z<0. && abs(M.x-S.x)<Sradius && abs(M.y-S.y-l/2.)<l/2. ) O.a = (M.y-S.y)/l;\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#######################Testing automatic differentiation###################\n//... also testing if the shader compiler is good at optimizing expressions... :)\n//\n//  Every thing relevant is in this \"Common\" section. \"BufferA\" and \"Image\" are\n// from https://www.shadertoy.com/view/MdKGRw]shader and https://www.shadertoy.com/view/XtXGRS#\n//\n//  \n// \n//  1st part is a little automatic differentiation library\n//\n//  2nd part is the distance to implicit function surface code both using \n// numerical or automatic differentiation.\n//\n//  3rd part is a python module used to generate the function calls to the\n// automatic differentiation library\n//-------------------------------------------------------------------\n/*\n Fast and dirty automatic differentiation library.\n\n\t.x --> f\n\t.y --> Df\n\nPrefix : AD (for automatic differentiation)\nBinary functions/operations :\n\t- add :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- sub :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- mul :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- div :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- min :\n\t\t(ADvec, ADvec)\n\t- max :\n\t\t(ADvec, ADvec)\n\t\t\nUnary functions/operations :\n\t- neg (negate)\n\t- inv (multiplicative inverse)\n\t- abs\n\t- sqr  \n\t- sqrt \n\t- exp\n\t- log  \n\t- pow :\n\t\t* by real number exponent so the user should check the bounds.\n\t\t* by integer exponent\n\t- asin, Acos  \n\t- atan\n\t- sin\n\t- cos\n*/\n\n#ifndef TWO_PI \n\t#define TWO_PI 6.2831853 \n#endif \n#ifndef PI \n\t#define PI 3.141592653 \n#endif \n\nstruct DualFloat{\n\tfloat f;\n\tfloat df;\n};\n\n//Add\nDualFloat ADadd(in DualFloat v0, in DualFloat v1){\n\tv0.f  += v1.f;\n\tv0.df += v1.df;\n\treturn v0;\n}\n\nDualFloat ADadd(in float v0, in DualFloat v1){\n\tv1.f += v0;\n\treturn v1;\n}\n\nDualFloat ADadd(in DualFloat v0, in float v1){\n\treturn ADadd(v1, v0);\n}\n\n//Negate\nDualFloat ADneg(in DualFloat v){\n\tv.f = -v.f; \n\tv.df = -v.df;\n\treturn v;\n}\n\n//Subtract\nDualFloat ADsub(in DualFloat v0, in DualFloat v1){\n\treturn ADadd(v0, ADneg(v1));\n}\n\nDualFloat ADsub(in float v0, in DualFloat v1){\n\treturn ADadd(v0, ADneg(v1));\n}\n\nDualFloat ADsub(in DualFloat v0, in float v1){\n\treturn ADadd(v0, -v1);\n}\n\n//Multiply\nDualFloat ADmul(in DualFloat v0, in DualFloat v1){\n\treturn DualFloat( v0.f * v1.f, v0.f * v1.df + v1.f * v0.df);\n}\n\nDualFloat ADmul(in float v0, in DualFloat v1){\n\tv1.f *= v0; v1.df *= v0;\n\treturn v1;\n}\n\nDualFloat ADmul(in DualFloat v0, in float v1){\n\treturn ADmul(v1 , v0);\n}\n\n//Multiplicative inverse\nDualFloat ADinv(in DualFloat v){\n\tv.f = 1./v.f;\n\treturn ADmul( DualFloat( 1., -v.df * v.f ) , v.f );\n}\n\n//Divide\nDualFloat ADdiv(in DualFloat v0, in DualFloat v1){\n\treturn ADmul(v0, ADinv(v1) );\n}\n\nDualFloat ADdiv(in float v0, in DualFloat v1){\n\treturn ADmul(v0, ADinv(v1) );\n}\n\nDualFloat ADdiv(in DualFloat v0, in float v1){\n\treturn ADmul( v0, 1./v1 );\n}\n\n//util\n#ifndef EVENFUNC \n#define EVENFUNC \nbool even(in float n){return fract(n*0.5)==0.;}\nbool even(in int n){return even(float(n));}\n//bool even(in int n){return (n&1)==0;}\n\nfloat Npow(in float x, in int n){\n\tif(n==2) return x*x;\n\tif(n<0){n=-n; x=1./x;}\n\tfloat r = 1.;\n\tfloat p = x;\n\twhile(n>0){\n\t\tif(!even(n)){r*=p; n--;}\n\t\telse {p*=p; n/=2;}\n\t}\n\treturn r;\n}\n#endif \n\n\n//Some common functions\n//Monotonous functions are the easiest: just apply the function to the bounds of the interval and swap them in the case where the function decreases.\n//Othetwise it can become a little bit complicated.\n\nDualFloat ADexp(in DualFloat v){\n\treturn ADmul( DualFloat( 1., v.df) , exp(v.f) );\n}\n\nDualFloat ADsqr(in DualFloat v){\n\treturn DualFloat( v.f * v.f , 2. * v.df * v.f) ;\n}\n\nDualFloat ADabs(in DualFloat v){\n\tif( v.f < 0. ) {\n\t\tv.f = -v.f;\n\t\tv.df= -v.df;\n\t}\n\treturn v;\n}\n\nDualFloat ADmin(in DualFloat v0, in DualFloat v1){\n\tif( v0.f < v1.f ) return v0;\n\telse return v1;\n}\n\nDualFloat ADmax(in DualFloat v0, in DualFloat v1){\n\tif( v0.f > v1.f ) return v0;\n\telse return v1;\n}\n\n#if 1\n//quite complicated. In general p is a constat so the compiler should be able to simplify things a lot.\nDualFloat ADpow(in DualFloat v, in int p){\n\tif(p==0) return DualFloat( 1. , 0. );\n\tif(p<0) { v = ADinv(v); p = -p;}\n\tif(p==1) return v;\n\tif(p==2) return ADsqr(v);\n\tif(p==3) return DualFloat( v.f * v.f  * v.f , 3. * v.df * v.f * v.f );\n\tif(p==4) {float vx2 = v.f * v.f; return DualFloat( vx2 * vx2 , 4. * v.df * vx2 * v.f ) ;}\n\tif(p==5) {float vx2 = v.f * v.f; return DualFloat( v.f * vx2  * vx2 , 5. * v.df * vx2  * vx2 ) ;}\n\tif(p==6) {float vx2 = v.f * v.f; return DualFloat( vx2 * vx2  * vx2 , 6. * v.df * vx2  * vx2 * v.f );}\n\t// p > 4\n\tfloat s=sign(v.f);\n\tv = ADabs(v);\n\tfloat f = pow( v.f , float(p-1) ) ;\n\tv = DualFloat( v.f * f , float(p) * v.df * f ) ;// if v<0 --> nan that is why it is done this way\n\tif(even(p)) return v;\n\treturn ADmul( s , v );\n}\n#else\nDualFloat ADpow(in DualFloat v, in int p){\n\tif(p==0) return DualFloat( 1. , 0. );\n\tif(p<0) { v = ADinv(v); p = -p;}\n\t\n\tvec2 r = vec2( v.f , float(p) * v.df ) * Npow( v.f , p-1 );\n\treturn DualFloat( r.x , r.y );\n}\n#endif\n\n\nDualFloat ADlog(in DualFloat v){\n\treturn DualFloat( log(v.f) , v.df / v.f );\n}\n\nDualFloat ADsqrt(in DualFloat v){\n\tfloat r = sqrt(v.f);\n\treturn DualFloat( r , 0.5 * v.df / r );\n}\n\nDualFloat ADpow(in DualFloat v, in float p){//v must be positive ! //p is a constant .\n\treturn ADmul( DualFloat( v.f , p * v.df ) , pow( v.f , p - 1. ) );\n}\n\nDualFloat ADpow(in DualFloat v, in DualFloat p){//v.x must be positive ! //p is a constant .\n\treturn ADexp( ADmul( p , ADlog( v ) ) );\n}\n\nDualFloat ADasin(in DualFloat v){\n\treturn DualFloat( asin(v.f) , v.df / sqrt( 1. - v.f * v.f ) );\n}\n\nDualFloat ADacos(in DualFloat v){\n\treturn DualFloat( acos(v.f) , - v.df / sqrt( 1. - v.f * v.f ) );\n}\n\nDualFloat ADatan(in DualFloat v){\n\treturn DualFloat( atan(v.f) , v.df / ( 1. + v.f * v.f ) );\n}\n\nDualFloat ADcos(in DualFloat v){\n\treturn DualFloat( cos( v.f ) , - v.df * sin( v.f ) );\n}\n\nDualFloat ADsin(in DualFloat v){\n\treturn DualFloat( sin( v.f ) ,  v.df * cos( v.f ) );\n}\n//-------------------------------------------------------------------\n\n#define Phi (.5*(1.+sqrt(5.)))\n\n#define PHI  1.618034\n#define PHI2 2.618034\n#define PHI4 6.854102\n\n#define Tau (1.+2.*Phi)\n\n#define Eps 0.00048828125               //epsilon\n#define IEps 2048.0                     //Inverse of epsilon\n\nfloat param2       = 3.0;               //a prameter used in the DE formula. The value depends on the function\nfloat IntThick     = 0.001;             //interior thickness. Interior is where the function is <0\nfloat SphereCutRad = 2.5;               //the radius of the sphere that limits the extension of the rendered parts of the implicit  \n\n//The implicit function -------------------------------------\n//This is a degree 6 algebraic implicit function discovered by Barth.\nfloat Barth(float x, float y, float z){\n   \tfloat phi1=(1.+sqrt(5.))/2., phi2=phi1*phi1;\n\tfloat x2=x*x, y2=y*y, z2=z*z;\n   \treturn -(4.*(phi2*x2-y2)*(phi2*y2-z2)*(phi2*z2-x2)-(1.+2.*phi1)*(x2+y2+z2-1.)*(x2+y2+z2-1.));\n}\n\n//just a wrapper---------------------------------------\nfloat Fn1(vec3 p)\n{\n\treturn Barth(p.x,p.y,p.z);\n}\n\n//Estimate distance using numerical derivatives\nfloat Fn(vec3 p)\n{\n\tfloat v =Fn1(p);\n\tvec2 eps=vec2(Eps,0);\n\t//Compute gradient's length\n\tfloat dv=length(IEps*(vec3(Fn1(p+eps.xyy),Fn1(p+eps.yxy),Fn1(p+eps.yyx))-vec3(v)));\n\t\n\t//Use function value and gradient magnitude to get a distance estimate. param2 depends on the function at hand.\n    float k = 1.-1./(abs(v)+1.);\n\tv=v/(dv+param2*k+.001);\n\treturn 0.5*v;\n}\n\n//Using AutoDiff. The compiler seems to optimise the xpresesions very well.\n//This function was generated using a python script that converts expression to function calls form.\n//The python script is in the commented section belooow.\nDualFloat Barth(DualFloat x, DualFloat y, DualFloat z){\n\treturn ADneg(ADsub(ADmul(ADmul(ADmul(ADsub(ADmul(ADpow(x,2),2.618033988749895),ADpow(y,2)),4.0),ADsub(ADmul(ADpow(y,2),2.618033988749895),ADpow(z,2))),ADsub(ADmul(ADpow(z,2),2.618033988749895),ADpow(x,2))),ADmul(ADpow(ADsub(ADadd(ADadd(ADpow(x,2),ADpow(y,2)),ADpow(z,2)),1.0),2),4.23606797749979)));\n}\n\n//just a wrapper---------------------------------------\nDualFloat Fn1_(DualFloat x, DualFloat y, DualFloat z)\n{\n\treturn Barth(x,y,z);\n}\n\n//Estimate distance using automatic differentiation technique\nfloat Fn_(vec3 p){\n\t\n    //Compute gradient. The compiler should be able to inline and simplify.\n\tDualFloat vx = Fn1_( DualFloat(p.x, 1.), DualFloat(p.y, 0.), DualFloat(p.z, 0.) );\n\tDualFloat vy = Fn1_( DualFloat(p.x, 0.), DualFloat(p.y, 1.), DualFloat(p.z, 0.) );\n\tDualFloat vz = Fn1_( DualFloat(p.x, 0.), DualFloat(p.y, 0.), DualFloat(p.z, 1.) );\n\t\n\t//Length of gradient\n\tfloat dv = length(vec3( vx.df, vy.df, vz.df ));\n\t\n\t//Function value\n\tfloat v = vx.f;\n\t\n\t//Compute distance estimate\n\tfloat k = 1.-1./(abs(v)+1.);\n\tv=v/(dv+param2*k+.001);\n\treturn 0.5*v;\n}\n\n//---------------------------------------- \n\nfloat DE(vec3 z)\n{\n\tfloat v =Fn_(z); v=abs(v+IntThick)-IntThick;\n\n\tv = max(v,length(z)-SphereCutRad);\n\t\n\treturn v;\n}\n\nvec3 baseColor(vec3 z, vec3 n){\n\tfloat v =Fn(z);\n\tif(v>-2.*IntThick) return mix(n,vec3(0.75,0.75,0.75),0.8);\n\treturn vec3(.95,0.05,0.0);\n}\n\n//Python script------------------------------------------\n/*\n\nfrom numbers import Number\nimport math\n\n#The prefix and suffix are here because my IA and autoDiff functions have different prefixes...\nprefix = \"AD\"\nsuffix = \"\"\n    \n#isinstance(n,number)\n#type(n)\n\ndef sgn(x):\n    if(x<0):\n        return -1.\n    else:\n        return 1.\n\ndef mmin(x,y):\n    if(x<y):\n        return x\n    else:\n        return y\n\ndef mmax(x,y):\n    if(x>y):\n        return x\n    else:\n        return y\n\nclass expression:\n\n    \"\"\"The purpose of this class is to 'symbolically' compute the derivative of an expression.\n       It outputs the expression (and its derivative) in function calls form. The output is in\n       glsl syntax. to be used with \"SimpleIA.frag\". \n       The glsl compiler should be good enought to simplify the returned expression... I hope!\n       It also computes constant expressions to some extent.\n       For an usage example see Dervish function below (&co.).\"\"\"\n    \n    def __init__(self, val, dval):\n        self.val = val\n        self.dval = dval\n\n    def __str__(self):\n        return \" f: \" + self.val + \"\\ndf: \" + self.dval \n\n    def __repr__(self):\n        return str(self)\n\n    def __neg__(self):\n        return expression( \"-(\" + self.val + \")\" , \"-(\" + self.dval + \")\" )\n    \n    def __add__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"add\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"add\" + suffix + \"(\" + self.dval + \",\" + b.dval + \")\" )\n        else:\n            if(b!=0):\n                return expression( prefix + \"add\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\" ,\n                                   self.dval )\n            else:\n                return self\n\n    def __radd__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"add\" + suffix + \"(\" + b.val + \",\" + self.val + \")\" ,\n                               prefix + \"add\" + suffix + \"(\" + b.dval + \",\" + self.dval + \")\" )\n        else:\n            if(b!=0):\n                return expression( prefix + \"add\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\",\n                                   self.dval )\n            else:\n                return self\n\n    def __sub__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"sub\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"sub\" + suffix + \"(\" + self.dval + \",\" + b.dval + \")\" )\n        else:\n            if(b!=0):\n                return expression( prefix + \"sub\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\" ,\n                                   self.dval )\n            else:\n                return self\n\n    def __rsub__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"sub\" + suffix + \"(\" + b.val + \",\" + self.val + \")\" ,\n                               prefix + \"sub\" + suffix + \"(\" + b.dval + \",\" + self.dval + \")\")\n        else:\n            if(b!=0):\n                return expression( prefix + \"sub\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\" ,\n                                   prefix + \"neg\" + suffix + \"(\" + self.dval + \")\" )\n            else:\n                return expression( prefix + \"neg\" + suffix + \"(\" + self.val + \")\" ,\n                                   prefix + \"neg\" + suffix + \"(\" + self.dval + \")\" )\n\n    def __mul__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"add\" + suffix + \"(\" + \n                                   prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + b.dval +\n                               \"),\" +\n                                   prefix + \"mul\" + suffix + \"(\" + b.val + \",\" + self.dval + \"))\" )\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                if(b==1):\n                    return self\n                else:\n                    return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\",\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(float(b)) + \")\")\n\n    def __rmul__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"mul\" + suffix + \"(\" + b.val + \",\" + self.val + \")\",\n                               prefix + \"add\" + suffix + \"(\" + \n                                   prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + b.dval +\n                               \"),\" +\n                                   prefix + \"mul\" + suffix + \"(\" + b.val + \",\" + self.dval + \"))\" )\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                if(b==1):\n                    return self\n                else:\n                    return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\",\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(float(b)) + \")\" )\n\n    def __truediv__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"div\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"div\" + suffix + \"(\" + \n                                   prefix + \"sub\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + b.val + \"),\" +\n                                       prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" + self.val + \")),\" +\n                                   prefix + \"pow\" + suffix + \"(\" + b.val + \",2))\")\n        else:\n            if(b==1):\n                return self\n            else:\n                return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + str(1./float(b)) + \")\",\n                                   prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(1./float(b)) + \")\")\n\n    def __rtruediv__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"div\" + suffix + \"(\" + b.val + \",\" + self.val + \")\",\n                               prefix + \"div\" + suffix + \"(\" + \n                                   prefix + \"sub\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" + self.val + \"),\" +\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + b.val + \")),\" +\n                                   prefix + \"pow\" + suffix + \"(\" + self.val + \",2))\")\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                return expression( prefix + \"div\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\",\n                                   prefix + \"div\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(-\" + str(float(b)) + \",\" + self.dval + \"),\" +\n                                       prefix + \"pow\" + suffix + \"(\" + self.val + \",2))\" )\n#-----------------------------\n    def __pow__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"mul\" + suffix + \"(\" +\n                                   prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + b.val + \"),\" +\n                                   prefix + \"add\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" + prefix + \"log\" + suffix + \"(\" + self.val + \")),\" + \n                                       prefix + \"div\" + suffix + \"(\" + b.val + \",\" + self.val + \")))\" )\n        else:\n            if(b==0):\n                return expression(\"1.\",\"0.\")\n            else:\n                if(b==1):\n                    return self\n                else:\n                    if(b==2):\n                        return expression( prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + str(b) + \")\",\n                                           prefix + \"mul\" + suffix + \"(\" + str(float(b)) + \",\" +\n                                               prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + self.val + \"))\" )\n                    else:\n                        return expression( prefix + \"pow(\" + suffix + \"(\" + self.val + \",\" + str(b) + \")\",\n                                           prefix + \"mul\" + suffix + \"(\" + str(float(b)) + \",\" +\n                                           prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" +\n                                           prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + str(b-1) + \")))\" )\n                        \n\n    def __rpow__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"pow\" + suffix + \"(\" + b.val + \",\" + self.val + \")\",\n                               prefix + \"mul\" + suffix + \"(\" +\n                                   prefix + \"pow\" + suffix + \"(\" + b.val + \",\" + self.val + \"),\" +\n                                   prefix + \"add\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + prefix + \"log\" + suffix + \"(\" + b.val + \")),\" + \n                                       prefix + \"div\" + suffix + \"(\" + self.val + \",\" + b.val + \")))\" )\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                if(b==1):\n                    return expression(\"1.\",\"0.\")\n                else:\n                    return expression( prefix + \"pow\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\",\n                                       prefix + \"mul\" + suffix + \"(\" +\n                                           prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(math.log(b)) + \")),\" +\n                                           prefix + \"pow\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \"))\" )\n\n#TOFIX : Interval library specific output!!! not general purpose :-/\n    def __abs__(self):\n        return expression( prefix + \"abs\" + suffix + \"(\" + self.val + \")\",\n                           self.val + \".lo>0.?\" + self.dval + \":\" +\n                               \"(\" + self.val + \".hi<0.?\" + prefix + \"neg\" + suffix + \"(\" + self.dval + \"):\" +\n                                prefix + \"mul\" + suffix + \"(Interval(-1.,1.),\" + self.dval +\"))\" )\n\n    def __neg__(self):\n        return expression( prefix + \"neg\" + suffix + \"(\" + self.val + \")\",\n                           prefix + \"neg\" + suffix + \"(\" + self.dval + \")\" )\n\n#------------------------------------------------------------------------------------------------------------------\n#functions\n\n#TOFIX : Interval library specific output!!! not general purpose :-/\ndef fabs(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"abs\" + suffix + \"(\" + self.val + \")\",\n                           self.val + \".lo>0.?\" + self.dval + \":\" +\n                               \"(\" + self.val + \".hi<0.?\" + prefix + \"neg\" + suffix + \"(\" + self.dval + \"):\" +\n                                prefix + \"mul\" + suffix + \"(Interval(-1.,1.),\" + self.dval +\"))\" )\n    else:\n        return expression( str(float(abs(b))),\"0.\" )\n    \ndef sign(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"sign\" + suffix + \"(\" + b.val + \")\" ,\n                           \"0.\" )\n    else:\n        return expression( str(float(sgn(b))),\"0.\" )\n\ndef sin(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"sin\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"cos\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.sin(b)) ,\"0.\" )\n\ndef cos(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"cos\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"mul\" + suffix + \"(\" + prefix + \"neg\" + suffix + \"(\" + b.dval + \"),\" +\n                               prefix + \"sin\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.cos(b)) ,\"0.\" )\n\ndef exp(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"exp\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"exp\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.exp(b)) ,\"0.\" )\n\ndef log(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"log\" + suffix +\"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix +\"(\" + b.dval + \",\" + b.val + \")\" )\n    else:\n        return expression( str(math.log(b)) ,\"SimpleIA.frag\" )\n\ndef sqrt(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"sqrt\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" +\n                               prefix + \"mul\" + suffix + \"(0.5,\" + b.dval + \"),\" +\n                               prefix + \"sqrt\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.sqrt(b)) ,\"0.\" )\n\ndef atan(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"atan\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"add\" + suffix + \"(1.,\" + prefix + \"pow\" + suffix + \"(\" + b.val + \",2)))\" )\n    else:\n        return expression( str(math.atan(b)) ,\"0.\" )\n\ndef asin(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"asin\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"sub\" + suffix + \"(1.,\" + prefix + \"pow\" + suffix + \"(\" + b.val + \",2)))\" )\n    else:\n        return expression( str(math.asin(b)) ,\"0.\" )\n\ndef acos(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"acos\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"sub\" + suffix + \"(\" + prefix + \"pow\" + suffix + \"(\" + b.val + \",2),1.))\" )\n    else:\n        return expression( str(math.acos(b)) ,\"0.\" )\n\n#TOFIX : Interval library specific output!!! not general purpose :-/\n#these two are nasty wrt performance simply because they are two arguments functions. Imagine what would happen when nesting mins and maxs!!!\n#One needs to evaluate the arguments first and then use these min & max on new variables.\n#example: see getfun()\n#... Anyway... better avoid using min and max :D\ndef min(a,b):\n    if( isinstance( a , expression)):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"min\" + suffix + \"(\" + a.val + \",\" + b.val + \")\",\n                               a.val + \".hi<\" + b.val + \".lo?\" + a.dval + \":(\" +\n                                   b.val + \".hi<\" + a.val + \".lo?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + a.dval + \".lo,\" + b.dval + \".lo),max(\" + a.dval + \".hi,\" + b.dval + \".hi)))\" )\n        else:\n            return expression( prefix + \"min\" + suffix + \"(\" + a.val + \",\" + str(float(b)) + \")\",\n                               a.val + \".hi<\" + str(float(b))+ \"?\" + a.dval + \":(\" +\n                                   str(float(b)) + \"<\" + a.val + \".lo?Interval(0.,0.):\" +\n                                       \"Interval(min(\" + a.dval + \".lo,0.),max(\" + a.dval + \".hi,0.)))\" )\n    else:\n        if( isinstance( b , expression)):\n            return expression( prefix + \"min\" + suffix + \"(\" + str(float(a)) + \",\" + b.val + \")\",\n                               str(float(a)) + \"<\" + b.val + \".lo?Interval(0.,0.):(\" +\n                                   b.val + \".hi<\" + str(float(a)) + \"?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + b.dval + \".lo,0.),max(\" + b.dval + \".hi,0.)))\" )\n        else:\n            return expression( str(float(mmin(a,b))),\n                               \"0.\" )\n\ndef max(a,b):\n    if( isinstance( a , expression)):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"max\" + suffix + \"(\" + a.val + \",\" + b.val + \")\",\n                               a.val + \".lo>\" + b.val + \".hi?\" + a.dval + \":(\" +\n                                   b.val + \".lo>\" + a.val + \".hi?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + a.dval + \".lo,\" + b.dval + \".lo),max(\" + a.dval + \".hi,\" + b.dval + \".hi)))\" )\n        else:\n            return expression( prefix + \"max\" + suffix + \"(\" + a.val + \",\" + str(float(b)) + \")\",\n                               a.val + \".lo>\" + str(float(b))+ \"?\" + a.dval + \":(\" +\n                                   str(float(b)) + \">\" + a.val + \".hi?Interval(0.,0.):\" +\n                                       \"Interval(min(\" + a.dval + \".lo,0.),max(\" + a.dval + \".hi,0.)))\" )\n    else:\n        if( isinstance( b , expression)):\n            return expression( prefix + \"max\" + suffix + \"(\" + str(float(a)) + \",\" + b.val + \")\",\n                               str(float(a)) + \">\" + b.val + \".hi?Interval(0.,0.):(\" +\n                                   b.val + \".lo>\" + str(float(a)) + \"?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + b.dval + \".lo,0.),max(\" + b.dval + \".hi,0.)))\" )\n        else:\n            return expression( str(float(mmax(a,b))),\n                               \"0.\" )\n\n#------------------------------------------------------------------------------------------------------------------\n#Example: the dervish is spinning fast\n#Better use math.xxx functions for constants.\ndef Dervish(x,y,z):\n   z=-z\n   c=math.sqrt(5-math.sqrt(5))/2                            #constant\n   r=(1+3*math.sqrt(5))/4\n   q=(1-c*z)*(x**2+y**2-1+r*z**2)**2;                       #not a constant\n   a=-(8/5)*(1+1/math.sqrt(5))*math.sqrt(5-math.sqrt(5))    \n   Pi=math.pi\n   h1=x-z\n   h2=cos(2*Pi/5)*x-sin(2*Pi/5)*y-z                         #hopefully the autodiff fully computes the constants in this case\n   h3=cos(4*Pi/5)*x-sin(4*Pi/5)*y-z\n   h4=cos(6*Pi/5)*x-sin(6*Pi/5)*y-z\n   h5=cos(8*Pi/5)*x-sin(8*Pi/5)*y-z\n   FF=h1*h2*h3*h4*h5\n   return a*FF+q\n\n#Another one\ndef wave(x,y,z):\n    r=exp(-(x**2+y**2))*sin(2*x)\n    return z-r\n\ndef Barth(x,y,z):\n    phi1 = ( 1 + math.sqrt(5) ) / 2\n    phi2= phi1**2\n    r = -(4*(phi2*x**2-y**2)*(phi2*y**2-z**2)*(phi2*z**2-x**2)-(1+2*phi1)*(x**2+y**2+z**2-1)**2)\n    return r\n\n#another one\ndef getfun():\n    x = expression(\"x\",\"dx\")\n    y = expression(\"y\",\"dy\")\n    z = expression(\"z\",\"dz\")\n    r1= x**2 + y**2\n    r2= x**2 + z**2\n    fr1=expression(\"r1\",\"dr1\")\n    fr2=expression(\"r2\",\"fr2\")\n    r3 =min(fr1,fr2)\n    #let's return the glsl function code\n    str = (\"Interval getfun(Interval x, Interval y, Interval z, Interval dx, Interval dy, Interval dz){\\n\" +\n           \"    Interval r1 = \" + r1.val + \", dr1 = \" + r1.dval + \";\\n\" +\n           \"    Interval r2 = \" + r2.val + \", dr2 = \" + r2.dval + \";\\n\" +\n           \"    Interval r3 = \" + r3.val + \", dr3 = \" + r3.dval + \";\\n\" +\n           \"    return dr3; //well I can only return one interval :o)\\n\" +\n           \"}\")\n    return str\n                \n#basic usage\ndef basicUsage():\n    x = expression(\"x\",\"dx\")    #define variables\n    y = expression(\"y\",\"dy\")\n    z = expression(\"z\",\"dz\")\n    c = Barth(x,y,z)            #expression. you can also do for example: c = wave(x,y,z) #wave() is defined above\n    print(c.val)                # val member contains the original expression written in function calls\n    #print(c.dval)               #dval contains the derivative expression also written in function calls\n    #or : print(c)\n\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}