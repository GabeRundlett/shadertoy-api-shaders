{
    "Shader": {
        "info": {
            "date": "1584469616",
            "description": "A shader that helps explore ray marched object using familiar controls (WASD + MOUSE + QE (UP/DOWN)) \nBaked Ambient | Collision | Ray Intersection ",
            "flags": 48,
            "hasliked": 0,
            "id": "wdsyzM",
            "likes": 10,
            "name": "Menger Interactive Explorer(v.1)",
            "published": 3,
            "tags": [
                "raymarching",
                "template"
            ],
            "usePreview": 0,
            "username": "quizcanners",
            "viewed": 491
        },
        "renderpass": [
            {
                "code": "// Fork of \"Interactive Explorer (v.0)\" by quizcanners. https://shadertoy.com/view/wtKSzd\n// 2020-03-17 16:42:23\n// Next version: https://www.shadertoy.com/view/WsscWr  (v.2)\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec4 Volume(vec3 pos){\n\tfloat hmix;\n                 \n    vec4 bakeUV = SampleVolume(pos, GetVolumeHSlices(iResolution.y), hmix);\n             \n    return mix( texture(iChannel0, bakeUV.xy), texture(iChannel0, bakeUV.zw), hmix);\n}\n\nvec3 getFishEye(vec2 uv, float level) {\n    \n    float len = length(uv);\n    float a = len * level;\n    vec3 fishUV = vec3(uv / len * sin(a), cos(a));\n    \n    vec3 camForward = \t\tloadValue(CAM_FORWARD).xyz;\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    return (fishUV.x * camRight) + (fishUV.y * camUp) + (fishUV.z * camForward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cameraPosition = loadValue(CAM_POS_PRSST).xyz;\n\tvec3 rayDirection = getFishEye(uv,  1.5);\n    \n    vec2 rayCast = GetRaycastDist(cameraPosition, rayDirection);\n\n    vec3 col = vec3(0);\n    \n    float dist = max(0.,rayCast.x);\n    \n    if (dist<MAX_DIST) {\n\n      \n        float steps;\n        \n        float mxDist = \n           \n        #ifdef DEBUG\n            rayCast.y;\n        #else \n         \tMAX_DIST;\n        #endif\n        \n        GetRayMarchDist(cameraPosition, rayDirection, mxDist, dist, steps);\n        \n        steps /= 30.; // DEBUG\n\n         if(dist<mxDist) {\n            vec3 hitPos = cameraPosition + rayDirection * dist;\n            vec3 n = GetNormal(hitPos, dist);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.6;\n            col += dif;  \n             \n            #ifdef DEBUG\n             col.r =  steps; \n            #endif\n             \n             vec3 safeHitPos = hitPos + n * 0.0001*dist  ; // To start other calculations not trom inside the object\n             \n             float shadow = Shadow(safeHitPos, lightSource_0.xyz, SHADOW_RADIUS, lightSource_0.w);\n\n             vec4 baked = Volume(safeHitPos + n*VOLUME_SCALE * .3);\n             \n             col.rgb *= (shadow * lightSource_0_Color + baked.b * skyColor);\n             \n         \t  col.rgb = max(vec3(0.), col.rgb);\n             col = pow(col, vec3(.4545));\t// gamma correction\n             vec3 mixed = col.gbr + col.brg;\n\n            col.rgb += mixed*mixed *  .2;\n             \n         } else {\n              col.rgb = \n             #ifdef DEBUG\n                 vec3(steps,0.,0.);\n             #else\n             \t SkyBox(rayDirection);\n             #endif\n         }\n\n    \n   } else {\n    \tcol.rgb = SkyBox(rayDirection); \n   }\n    \n   \n    // Volumetric lights \n     \n    const float VOL_STEPS = 16.;\n    \n    const float VOL_STEP_SIZE = 2. * VOLUME_SCALE/ VOL_STEPS;\n    \n    const float FOG_DENSITY = .1/VOL_STEPS;\n    \n    vec4 ambientLight = vec4(0., 0., 0., FOG_DENSITY);\n    \n    float volDist = VOL_STEP_SIZE;\n    \n    for (float i=0.; i<VOL_STEPS; i+=1.)\n    {\n    \tvec3 volumePosition = cameraPosition + rayDirection * volDist;\n        \n        vec3 volCol = Volume(volumePosition).rgb;\n        \n        float addStep = VOL_STEP_SIZE * (1. + i/VOL_STEPS);\n        \n        float smoothAdd = smoothstep(dist, dist-addStep, volDist);\n       \n        float adding = FOG_DENSITY * smoothAdd;\n        \n        ambientLight.rgb += volCol * adding / ambientLight.a;\n      \n        ambientLight.a += adding;\n        \n        volDist += VOL_STEP_SIZE * (1. + i/VOL_STEPS); \n        \n        i+= (1. - smoothAdd) * 100.;\n    }\n    \n    ambientLight.a = min(1., ambientLight.a);\n  \n    ambientLight.rgb =  \n        lightSource_0_Color.rgb *  (lightSource_0.w * 0.3 * smoothstep(0., 10., ambientLight.r)) +\n        skyColor * ambientLight.b\n        ;\n    \n    col.rgb = mix(col.rgb, ambientLight.rgb , ambientLight.a);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CONFIGS\n\n#define MAX_STEPS 30\n#define MAX_DIST 500.\n#define SURF_DIST .001\n//#define DEBUG\n#define MARCH_VOLUME_SHADOW\n//___ MOVEMENT\nconst float PLAYER_SPEED = .6;\nconst float PLAYER_RUN_SPEED = 1.;\nconst float MOUSE_SENSITIVITY = 3.;\nconst float PLAYER_SIZE = .1;\nconst float SLOWDOWN_RANGE = 5.;\n\nconst vec4 SCENE_OFFSET = vec4(0.,0.,20.,0.);\n\n//__ RENDERING\nconst float  SHADOW_RADIUS = 6.;\n\nvec3 skyColor= vec3(.1,.1, .7);\nvec3 eqColor = vec3(.5,.4,.4);\nvec3 floorColor = vec3(.1,.3,.1);\n\nvec3 SkyBox(vec3 rayDirection)\n{\n    return  floorColor * max(0., -rayDirection.y)\n        +   eqColor * (1.-abs(rayDirection.y)) \n        +\tskyColor * (max(0., rayDirection.y));\n}\n\n\n// *************** PERSISTANCE\n\nconst ivec2 CAM_POS_PRSST       \t= ivec2(1, 1);\nconst ivec2 CAM_ROT_PRSST       \t= ivec2(3, 1);\nconst ivec2 CAM_MOUSE_PREV_PRSST    = ivec2(7, 1);\nconst ivec2 CAM_ROTATION_PRSST      = ivec2(9, 1);\nconst ivec2 CAM_FORWARD       \t\t= ivec2(11, 1);\nconst ivec2 GAME_STATE       \t\t= ivec2(13, 1);\n\nconst float PRSST_MAX_Y = 2.;\n\n\n\n// ************** MATH\n\nfloat sharpstep(float a, float b, float x){\n    return (x-a)/(b-a);\n}\n\nvec2 Rot(vec2 uv, float angle){\n\tfloat si = sin(angle);\n\tfloat co = cos(angle);\n    return vec2(co * uv.x - si* uv.y, si * uv.x + co * uv.y);\n}\n\n// ************** VOLUME\n\nconst float VOLUME_SCALE = 10.;\nconst vec4 VOLUME_POSITION_N_SIZE = vec4(0, -40., 0, 1./VOLUME_SCALE) + SCENE_OFFSET; // w = 1/size\nconst float VOLUME_HEIGHT = 16.;\nconst float DE_VOL_HEIGHT = 1./VOLUME_HEIGHT;\n\n\nvec4 GetVolumeHSlices(float resolutionY)\n{\n  float sliceWidth = (resolutionY - VOLUME_HEIGHT * 2.) * DE_VOL_HEIGHT;       \n  return vec4(VOLUME_HEIGHT, sliceWidth* .5, 1./sliceWidth, DE_VOL_HEIGHT);\n}\n\nvec4 SampleVolume(vec3 worldPos, vec4 VOLUME_H_SLICES, out float hmix) {\n\n    vec4 outputUV = vec4(0.);\n    \n\tvec3 bsPos = (worldPos.xyz - VOLUME_POSITION_N_SIZE.xyz) * VOLUME_POSITION_N_SIZE.w;\n\n\tbsPos.xz = clamp((bsPos.xz + VOLUME_H_SLICES.y)* VOLUME_H_SLICES.z, 0., 1.)*VOLUME_H_SLICES.w;\n\tfloat h = min(max(0., bsPos.y), VOLUME_H_SLICES.x*VOLUME_H_SLICES.x - 1.);\n\n\tfloat sectorY = floor(h * VOLUME_H_SLICES.w);\n\tfloat sectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n    vec2 uv_low = vec2(sectorX, sectorY) * VOLUME_H_SLICES.w;\n    \n\tvec2 sector = clamp(uv_low, 0., 1.)+ bsPos.xz;\n\n    outputUV.xy = sector;\n\n\th += 1.;\n\n\tsectorY = floor(h * VOLUME_H_SLICES.w);\n\tsectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n\tsector = clamp(vec2(sectorX, sectorY)*VOLUME_H_SLICES.w, 0., 1.) + bsPos.xz;\n\n    outputUV.zw = sector;\n\n\thmix = fract(h); \n\n\treturn outputUV;\n}\n\n// **************  RAYMARCHING\n\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat smAdd(float d1, float d2, float smth)\n{\n\tfloat h = max(smth - abs(d1 - d2), 0.0) / (smth + 0.0001);\n\treturn min(d1, d2) - h * h*h*smth*(1.0 / 6.0);\n}\n\nfloat smMinus(float d1, float d2, float k) {\n\n\tfloat h = clamp((1. - (d2 + d1) / (k + 0.0001))*0.5, 0.,1.);\n\n\treturn mix(d1, -d2, h) + k * h * (1. - h);\n}\n\nfloat Minus(float d1, float d2){\n\treturn max(d1, -d2);\n}\n\n// ****************** SHAPES\n\nfloat sdSphere(vec4 sphere, vec3 pos) {\n\treturn length(pos-sphere.xyz)-sphere.w; \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat distToBox(in vec2 pos, in vec2 boxMin, in vec2 boxMax, in float expand)\n{\n    boxMin -= vec2(expand,expand);\n    boxMax += vec2(expand,expand);\n    float bMax = max(pos.x - boxMax.x, pos.y - boxMax.y);\n    float bMin = max(boxMin.x - pos.x, boxMin.y - pos.y);\n    return max(bMax, bMin);\n}\n\n\n// ****************** RAY CASTING\n\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nvoid iBox( in vec3 ro, in vec3 m, in vec3 boxSize, inout vec2 nearestCast) \n{ \n    \n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n    float isNear = step(tN, tF) * step(0., tF) * step(tN, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(tN, tF), isNear);\n}\n\nvoid IntersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 pos, float radius, inout vec2 nearestCast)\n{\n    float t = max(0.,dot(pos - rayOrigin, rayDirection));\n    vec3 p = rayOrigin + rayDirection * t;\n    float y = length(pos - p);\n    \n    float hit = step(y, radius);\n    \n    float x = sqrt(mix(1., radius * radius - y * y,  hit));\n\n    float isNearest = hit * step(t-x, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(t-x,t+x), isNearest);\n}\n\n\n// ***************** TEST SCENE\n\n\nconst vec4 lightSource_0 = vec4(30., 50., 60., 20.) + SCENE_OFFSET;\n\nconst vec3 lightSource_0_Color = vec3(.8, .8, .1);\n\nconst vec4 Sphere_0 = vec4(1., 7., 20., 15) + SCENE_OFFSET;\nconst vec4 Sphere_1 = vec4(55., -40., 30., 30) + SCENE_OFFSET;\n\nconst vec4 MinusSphere_0 = vec4(55., -30., 30., 55) + SCENE_OFFSET;\nconst vec4 Box_0 = \t\t\tvec4(55., -40., 30., 50) + SCENE_OFFSET;\n\nconst vec4 Box_1 = \t\t\tvec4(-50., 64., 0., 50) + SCENE_OFFSET;\n\nvec2 GetRaycastDist(vec3 rayPos, vec3 rayDir)\n{\n    vec2 nearestCast = vec2(MAX_DIST+1.,MAX_DIST+1.);\n    \n    IntersectSphere(rayPos, rayDir, Sphere_0.xyz , Sphere_0.w, nearestCast);\n\n    vec3 precalculateBox = sign(rayDir)/max(abs(rayDir), 1e-8);\n    \n    iBox(rayPos - Box_0.xyz, precalculateBox, vec3(Box_0.w), nearestCast);\n \tiBox(rayPos - Box_1.xyz, precalculateBox, vec3(Box_1.w), nearestCast);\n    \n    return nearestCast;\n}\n\n\nfloat GetDist(vec3 p) {\n    \n\n    float minDist = sdBox(p - Box_0.xyz, vec3(Box_0.w));\n\n    minDist = min(minDist, sdBox(p - Box_1.xyz, vec3(Box_1.w)));\n    \n    minDist = Minus(minDist, sdSphere(MinusSphere_0,p));\n    \n    const int MENGER_ITERATIONS = 2;\n    float scale = .1;\n \tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tminDist = max(minDist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n    \n     minDist = smAdd(minDist, sdSphere(Sphere_0, p), 6.);\n    \n     minDist = min(minDist, sdSphere(Sphere_1, p));\n    \n    return minDist;\n}\n\nvec3 GetNormal(vec3 p, float dist ) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat Shadow(vec3 p, vec3 pos, float radius, float lightPower)\n{\n\tvec3 rayDir = normalize(pos - p);\n\tfloat maxDist = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * maxDist;\n\t\n    float minStep = radius * 0.15;\n    \n\t// distance traveled\n\tfloat dt =minStep;\n\n    float sd = 0.;\n    \n    float fullShadow = 0.;\n    \n\tfor (float i = 0.; i < 32.; i+=1.)\n\t{\t\t\t\t\n\t\tsd = GetDist(p + rayDir * dt);\n\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(minStep, abs(sd));\n\t\t\n        fullShadow = step(sd, -radius);\n        \n        i+= (fullShadow + step(maxDist,dt))* 100.;\n\t}\n\n\tlf = clamp((lf*maxDist + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\n\treturn lf * lightPower / maxDist ;\n}\n\n\n\nvoid GetRayMarchDist(vec3 rayPos, vec3 rayDir, float maxDist, inout float dist, out float steps){\n    \n    steps = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayPos + rayDir*dist;\n        float dS = GetDist(p);\n        dist += dS;\n        #ifdef DEBUG\n        steps += 1.; // DEBUG\n        #endif\n        if(dist>maxDist || abs(dS)<SURF_DIST*(1.+dist)\n          )\n        { \n            break;\n        }\n    }\n   \n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// This buffer handles camera movement and volume baking\n// ASCII: https://www.ascii-code.com/\n\nconst float KEY_E            = 69.5 / 256.0;\nconst float KEY_Q            = 81.5 / 256.0;\nconst float KEY_W            = 87.5 / 256.0;\nconst float KEY_A            = 65.5 / 256.0;\nconst float KEY_S            = 83.5 / 256.0;\nconst float KEY_D            = 68.5 / 256.0;\nconst float KEY_LEFT         = 37.5 / 256.0;\nconst float KEY_UP           = 38.5 / 256.0;\nconst float KEY_RIGHT        = 39.5 / 256.0;\nconst float KEY_DOWN         = 40.5 / 256.0;\nconst float KEY_SHIFT        = 16.5 / 256.0;\nconst float KEY_SPACE \t     = 32.5 / 256.0;\n\nbool inStoreArea( in ivec2 dataIndex, in ivec2 fragCoord)\n{\n  return ( dataIndex.x==fragCoord.x && dataIndex.y==fragCoord.y);\n}\n\nbool inStoreRange( in ivec2 dataIndex1, in ivec2 dataIndex2, in ivec2 fragCoord)\n{\n  return ( dataIndex1.x<=fragCoord.x && dataIndex1.y<=fragCoord.y && dataIndex2.x>=fragCoord.x && dataIndex2.y>=fragCoord.y);\n}\n\nvoid storeValue( in ivec2 dataIndex, in vec4 data, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = inStoreArea(dataIndex, fragCoord) ? data : fragColor;\n}\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec3 volumeUVtoWorld(vec2 uv, vec4 VOLUME_H_SLICES) {\n\n\tfloat hy = floor(uv.y*VOLUME_H_SLICES.x);\n\tfloat hx = floor(uv.x*VOLUME_H_SLICES.x);\n\n\tvec2 xz = uv * VOLUME_H_SLICES.x;\n\n\txz.x -= hx;\n\txz.y -= hy;\n\n\txz = (xz*2. - 1.) *VOLUME_H_SLICES.y;\n\t\n\tfloat h = hy * VOLUME_H_SLICES.x + hx;\n\n\tvec3 bsPos = vec3(xz.x, h, xz.y) / VOLUME_POSITION_N_SIZE.w;\n\n\tvec3 worldPos = VOLUME_POSITION_N_SIZE.xyz + bsPos;\n\n\treturn worldPos;\n}\n\nvec3 hash33(vec3 pos)\n{\n\tpos = fract(pos * vec3(.1234, .5678, .923));\n    pos += dot(pos, pos.yxz+23.45);\n    return fract((pos.xxy + pos.yxx)*pos.zyx);\n\n}\n\nvec4 Quat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    return normalize(vec4(axis * sin(angle), cos(angle)));\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + (q.w * t) + cross(q.xyz, t);\n}\n\nvec4 QxQ(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = (q1.w * q2.w) - dot(q1.xyz, q2.xyz);\n    res.xyz = (q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz);\n    return normalize(res);\n}\n\nvec2 GetMouseDelta()\n{\n        vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n        float downPrevious = mousePrevious.z; \n        float down = clamp(iMouse.z * 800., 0. , 1.);\n        return down * downPrevious *  (iMouse.xy/iResolution.xy-mousePrevious.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    if (fragCoord.y<=PRSST_MAX_Y) {\n        \n      fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        \n       ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n        \n       #define WRITE_INDEX(data) inStoreArea(data, ifragCoord)  \n       #define PRSST_RANGE(data1, data2) inStoreRange(data1, data2, ifragCoord)  \n        \n        \n        vec4 gameState = loadValue(GAME_STATE);\n        \n        if (gameState.x == 0.)\n        {\n        \n            if (WRITE_INDEX(CAM_FORWARD)){\n             \tfragColor = vec4(vec3(0.,0.,1.), 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(GAME_STATE)){\n             \tfragColor = vec4(1., 0., 0. , 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(CAM_ROTATION_PRSST))\n       \t\t{\n                fragColor = vec4(0., 0., 0., 1.0);\n                return;\n            }\n            \n            discard;\n        }\n        \n        // Camera persistance: \n        \n        if (WRITE_INDEX(CAM_FORWARD)) {\n            \n             vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n            \n            fragColor = vec4(Rotate(lastQuat, vec3(0.,0.,1.)), 0.0);\n            \n       } else  if (WRITE_INDEX(CAM_ROTATION_PRSST)) {\n            \n            vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n           \n       } else  if (WRITE_INDEX(CAM_MOUSE_PREV_PRSST)) {\n           \n           vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n           mousePrevious.xy = iMouse.xy/iResolution.xy;\n           mousePrevious.z = clamp(iMouse.z * 800., 0. , 1.);\n           fragColor = mousePrevious;\n           \n           \n       } else if (WRITE_INDEX(CAM_POS_PRSST)) {\n           \n \t\t\tvec4 camera = loadValue(CAM_POS_PRSST);\n  \n           \n             vec3 off;\n\n            off.x -=  texture( iChannel1, vec2(KEY_A,0)).x;\n            off.x +=  texture( iChannel1, vec2(KEY_D,0)).x;\n            off.z +=  texture( iChannel1, vec2(KEY_W,0)).x;\n            off.z -=  texture( iChannel1, vec2(KEY_S,0)).x;\n            off.y +=  texture( iChannel1, vec2(KEY_E,0)).x;\n            off.y -=  texture( iChannel1, vec2(KEY_Q,0)).x;\n\n            if (length(off)>0.0001){\n                \n                off = normalize(off);\n                \n                vec3 camForward = \tloadValue(CAM_FORWARD).xyz;\n    \t\t\tvec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n\n                vec3 add = camForward * off.z + camRight * off.x;\n             \n                float run = texture( iChannel1, vec2(KEY_SHIFT,0)).x;\n                \n                float dist = min(1., GetDist(camera.xyz) / SLOWDOWN_RANGE);\n                \n                camera.xyz += (vec3(add.x,0.,add.z) + vec3(0., 1., 0.) * off.y) * max(0.1, dist)  * mix(PLAYER_SPEED, PLAYER_RUN_SPEED, run);\n            \n                if (dist<PLAYER_SIZE)\n                {\n                    camera.xyz += GetNormal(camera.xyz, 1.) * (PLAYER_SIZE - dist);\n                }\n            }\n            \n            \n            fragColor = camera;\n       }\n    } else {\n\n        // Ambient Light Baking\n        \n        vec2 uv = fragCoord/iResolution.xy;\n \n        fragColor = texture(iChannel0, uv);\n                \n        vec3 pos = volumeUVtoWorld(uv, GetVolumeHSlices(iResolution.y));\n\n        vec3 randomDirection = normalize(hash33(pos + iTime));\n        \n        pos += randomDirection* VOLUME_SCALE * 0.5;\n        \n        float dist = GetDist(pos);\n        \n        if (dist<0.)\n            return;\n        \n        vec3 addColor = vec3(0.);\n        \n        // SKY LIGHT\n        \n        vec2 rayCast = GetRaycastDist(pos, randomDirection);\n        \n        if (rayCast.x + 1. > MAX_DIST) \n        {\n        \taddColor.b = (randomDirection.y + 1.) * 0.5;  //SkyBox(randomDirection);\n        }\n        \n        // LIGHT POINT\n        \n        vec3 toLight = lightSource_0.xyz- pos;\n        float len = length(toLight);\n        \n        #ifdef MARCH_VOLUME_SHADOW\n        \tfloat visible =  Shadow(pos, lightSource_0.xyz, SHADOW_RADIUS, MAX_DIST);\n        #else\n         \tvec2 lightPointRay = GetRaycastDist(pos, normalize(toLight));\n        \tfloat visible = step(0., dist) * step(length(toLight), lightPointRay.x + 0.01);\n        #endif\n        \n       \n        addColor.r += visible;\n      \n        \n        //addColor += lightSource_0_Color.rgb *  ( lightSource_0.w * visible * 1000. / (len*len + 1.));\n\n        // STORING\n        \n        fragColor.a += 1.;\n        \n        float newPortion = 1./ (fragColor.a);\n        \n        fragColor.a = min(100., fragColor.a);\n        \n        fragColor.rgb = mix(fragColor.rgb, addColor, newPortion);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}