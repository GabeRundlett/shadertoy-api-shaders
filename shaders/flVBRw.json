{
    "Shader": {
        "info": {
            "date": "1664424039",
            "description": "Attempting to simulate the recrystalization of cooling metal. I am primarily trying to demonstrate the effect of cooling rate on grain size.\n*mouse to add heat*\n*shift + mouse to remove heat*\n*space to reset and resume attract mode*",
            "flags": 48,
            "hasliked": 0,
            "id": "flVBRw",
            "likes": 16,
            "name": "Metal Recrystalization",
            "published": 3,
            "tags": [
                "automata",
                "cellular",
                "polarization",
                "crystal",
                "ising",
                "annealing",
                "atomaton"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Attempting to simulate the recrystalization of cooling metal. I am primarily trying\n//  to demonstrate the effect of cooling rate on grain size. You should see smaller grains\n//  where the material cools quickly.\n//\n//  I am not any kind of expert on this, but from my Googling and reading Wikipedia, I\n//  believe that the two direction scenes could be called Ising (or Ising-Lenz) models, but\n//  that the more general term is a Classical XY Model.\n//\n//  https://en.wikipedia.org/wiki/Ising_model\n//  https://en.wikipedia.org/wiki/Classical_XY_model\n//  https://en.wikipedia.org/wiki/Recrystallization_(metallurgy)\n//\n//  When above the melting point, the directions become randomized. As the material cools,\n//  it becomes solid, but the atoms are still free to reorient themselves to match their\n//  neighbors. Once the material cools below its recrystalization temperature, the grain\n//  pattern becomes frozen, and the pattern it is frozen in has significant effects on the\n//  material properties such has hardness.\n//\n//  In this shader there is a discrete set of directions the crystals can align to, controlled\n//  by the w component of the state vector (stored in 0, 0 of buffer A). This is randomized\n//  each time the scene resets or when you press the space bar. Lower counts are more\n//  likely so that low (2- and 3-) color scenes have higher chances, just because I think they\n//  look interesting. You can increase MAX_DIRECTIONS but at some point you can't see\n//  much difference.\n//\n//  Clicking interrupts the attract mode and gives you mouse control over the heat. Click\n//  to add heat, shift-click to remove heat. Space resets and resumes the attract mode.\n//\n//  You can see multi-colored micrographs similar to this in real life using a polarized\n//  light and/or various colorizing etchants:\n//\n//  https://vacaero.com/information-resources/metallography-with-george-vander-voort/991-color-metallography.html\n//\n//  Buffer A computes the temperature (mostly just diffusion)\n//  Buffer B computes the grain directions\n//\n// ---------------------------------------------------------------------------------------\n\n\nconst float TWO_PI = 3.141592653589793 * 2.;\n\nvec2 circ(float a)\n{\n    return vec2(sin(a * TWO_PI), cos(a * TWO_PI));\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nconst float MAX_TEMP = 1.0;\n\nvec3 fxBlackBody(float _t)\n{\n    _t = max(0., _t);\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dir = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float directions = abs(state.w);\n\n    vec2 steelCoord = rot2((dir + 0.5) * TWO_PI / (directions*2.)) * fragCoord * vec2(2.0, 0.004);\n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n\n  \tvec2 p = fragCoord/iResolution.xy;\n    steelNorm = normalize(steelNorm);\n    vec2 c = circ(iTime*0.3)*0.4;\n    vec3 lightDir = normalize(vec3(c.x + 1., 1., c.y + 1.));\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, p.x - 0.5, p.y - 0.5));\n    vec3 steel = vec3(steelSpec) * 0.9 + 0.5;\n\n    vec3 color = sin((dir + 1.) * vec3(5, 11, 14) / directions * 0.5 + iTime*0.25) * 0.3 + 0.7;\n    fragColor.xyz = steel * color;\n    \n    // Add heat radiative light\n    fragColor.xyz += fxBlackBody(texelFetch(iChannel0, ivec2(fragCoord), 0).x) * 0.5;\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// -----------------------------------------------------------------------------------------------\n// Computes the temperature, which is mostly just diffusion cooling inwards from the edge,\n// but there is a constant sapping of heat simulating the heat being lost in the Z direction also.\n// -----------------------------------------------------------------------------------------------\n\nconst float HEAT_LOSS = 0.99;\n\nfloat initHeat(vec2 fc)\n{\n    vec3 res = iResolution;\n    vec2 coord = (fc/iResolution.y)*2. - vec2(iResolution.x / iResolution.y, 1.);\n    switch(iFrame % 7)\n    {\n        case 0:\n            // spiral\n            return atan(coord.y, coord.x) + 4.;\n            \n        case 1:\n            // phoenix\n            coord.x *= 0.6;\n            float sdp = sdPhoenix(coord);\n            if (sdp < 0.) return 2.5;\n            return 0.9;\n            \n        case 2:\n            // diagonal\n            return abs(coord.x + coord.y) * 1.6 + 0.9;\n\n        case 3:\n            // checker       \n            vec2 fl = floor(coord * 5.);\n            if ((int(fl.x) + int(fl.y)) % 2 == 0) return 2.5;\n            return 0.83;\n            \n        case 4:\n            // multi-spiral\n            return mod((atan(coord.y, coord.x) + 4.) * 3.0, 4.0) + 0.82;\n            \n        case 5:\n            // vertical fade\n            return square(coord.y - 1.0) + .9;\n\n        case 6:\n            // stripes\n            return step(0.5, mod(coord.x * 3.0, 1.0)) * 1.6 + 0.84;\n            \n    }\n}\n\nvoid handleState(inout vec4 fragColor, ivec2 ifc)\n{\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame * 984 + int(iDate.w)));\n    \n    if (iFrame == 0) fragColor = vec4(0, 0, -1, 3);\n    if (iMouse.z > 0.)\n    {\n        // Remember last mouse position so we can draw a line\n        fragColor.xy = iMouse.xy;\n    }\n\n    if (keyClick(KEY_SPACE) ||\n        abs(fragColor.z) != iResolution.x * iResolution.y ||\n        (fragColor.xy == vec2(0) && (iFrame % 331 == 0))) \n    {\n        if (fragColor.z >= 0.)\n        {\n            // Compute how many directions to allow\n            fragColor.w = max(2., floor(pow(h.x, 2.) * float(MAX_DIRECTIONS)));\n        }\n        fragColor.xy = vec2(0);\n        fragColor.z = -iResolution.x * iResolution.y;\n    }\n    else\n    {\n        // Reset the reset\n        fragColor.z = abs(fragColor.z);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n    \n    if (ifc == ivec2(0))\n    {\n        handleState(fragColor, ifc);\n        return;\n    }\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = initHeat(fragCoord);\n        fragColor.yzw = vec3(0);\n    }\n    else\n    {\n        // Diffuse heat\n        float avgTemp = 0.;\n        const int RANGE = 3;\n        for (int x = -RANGE; x <= RANGE; ++x)\n        {\n            for (int y = -RANGE; y <= RANGE; ++y)\n            {\n                ivec2 ni = ifc + ivec2(x, y);\n                if (ni == ivec2(0)) continue;\n                vec4 n = texelFetch(iChannel0, ni, 0);\n                avgTemp += n.x;\n            }\n        }\n        \n        fragColor.r = HEAT_LOSS * avgTemp / square(float(RANGE + RANGE + 1));\n        \n        // Handle mouse input\n        if (iMouse.z > 0. && iMouse.w < 0. && state.xy != vec2(0))\n        {\n            float dist = sqrt(linePointDist2(iMouse.xy, state.xy, fragCoord));\n            \n            if (keyDown(KEY_SHIFT))\n            {\n                fragColor.r -= 20. / dist;\n            }\n            else\n            {\n                fragColor.r += 10. / dist;\n            }\n            \n            fragColor.r = clamp(fragColor.r, 0., 2.5);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int MAX_DIRECTIONS = 23;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n// from my Spark Phoenix shader: https://www.shadertoy.com/view/7tGcRz\nconst int NUM_WING_POINTS = 25;\nvec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(-0.9,  0.8),\n    vec2(-0.65,  0.5),\n    vec2(-0.85,  0.45),\n    vec2(-0.55,  0.3),\n    vec2(-0.75,  0.125),\n    vec2(-0.45,  0.1),\n    vec2(-0.63,  -0.2),\n    vec2(-0.35, -0.1),\n    vec2(-0.51,  -0.45),\n    vec2(-0.25, -0.3),\n    vec2(-0.2, -0.3),\n    vec2(-0.1, -0.4),\n    vec2(-0.075, -0.6),\n    vec2(-0.175, -0.75),\n    vec2(-0.05, -0.7),\n    vec2(-0.15, -0.85),\n    vec2(-0.045, -0.8),\n    vec2(-0.05, -0.9),\n    vec2(-0.0, -0.85),\n    vec2(-0.0, 0.125),\n    vec2(-0.045, 0.0),\n    vec2(-0.125, -0.1),\n    vec2(-0.2, -0.0),\n    vec2(-0.3,  0.2),\n    vec2(-0.6,  0.6)\n);\n\nfloat sdPolygon( in vec2[NUM_WING_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_WING_POINTS-1; i<NUM_WING_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst int NUM_HEAD_POINTS = 9;\nvec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(-0.0, -0.2),\n    vec2(0.0, 0.3),\n    vec2(-0.1, 0.4),\n    vec2(-0.2, 0.425),\n    vec2(-0.145, 0.5),\n    vec2(-0.05, 0.7),\n    vec2(0.15, 0.75),\n    vec2(0.25, 0.55),\n    vec2(0.2, 0.35)\n);\n\nfloat sdPolygon( in vec2[NUM_HEAD_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_HEAD_POINTS-1; i<NUM_HEAD_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\nfloat sdPhoenix(in vec2 p)\n{\n    float minDist = sdPolygon(WING_POINTS, p);\n    minDist = min(minDist, sdPolygon(WING_POINTS, vec2(-p.x, p.y)));\n    minDist = min(minDist, sdPolygon(HEAD_POINTS, p));\n    return minDist;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// --------------------------------------------------------------------------------------------\n// Computes the grain directions by attempting to match nearby pixels under correct conditions.\n// --------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame + int(iDate.w)));\n    \n    fragColor = texelFetch(iChannel1, ifc, 0);\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float directions = abs(state.w);\n    \n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = floor(h.x * float(directions));\n        fragColor.zw = vec2(0);\n    }\n    else\n    {\n        float t = texelFetch(iChannel0, ifc, 0).x;\n        if (t > 0.99 + 0.9 * h.x)\n        {\n            fragColor.x = floor(h.y * float(directions));            \n        }\n        else if (t > 0.8 && h.x < 0.99)\n        {\n            // Count how many neighbors in range have each possible direction\n            int counts[MAX_DIRECTIONS];\n            for (int i = 0; i < int(directions); ++i)\n            {\n                counts[i] = 0;\n            }\n\n            const int RANGE = 3;\n            for (int x = -RANGE; x <= RANGE; ++x)\n            {\n                for (int y = -RANGE; y <= RANGE; ++y)\n                {\n                    ivec2 ni = ifc + ivec2(x, y);\n                    if (any(lessThan(ni, ivec2(0)))) continue;\n                    if (any(greaterThanEqual(ni, ivec2(iResolution)))) continue;\n                    vec4 n = texelFetch(iChannel1, ni, 0);\n                    counts[int(n.x)]++;\n                }\n            }\n\n            // Find the direction most popular among neighbors\n            int bestCount = -1;\n            int bestDir;\n            bool unique;\n\n            for (int d = 0; d < int(directions); ++d)\n            {\n                if (counts[d] > bestCount)\n                {\n                    bestCount = counts[d];\n                    bestDir = d;\n                    unique = true;\n                }\n                else if (counts[d] == bestCount)\n                {\n                    unique = false;\n                }\n            }\n\n            if (unique)\n            {\n                fragColor.r = float(bestDir);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}