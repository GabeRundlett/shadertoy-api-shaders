{
    "Shader": {
        "info": {
            "date": "1719406443",
            "description": "?",
            "flags": 0,
            "hasliked": 0,
            "id": "lXcXzl",
            "likes": 2,
            "name": "Literally What",
            "published": 3,
            "tags": [
                "random"
            ],
            "usePreview": 0,
            "username": "anAccount",
            "viewed": 104
        },
        "renderpass": [
            {
                "code": "vec3 hash(vec3 p)\n{\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n              dot(p, vec3(269.5, 183.3, 246.1)),\n              dot(p, vec3(113.5, 271.9, 124.6)));\n    return fract(sin(p) * 43758.5453123) * 2.0 - 1.0;\n}\n\nfloat fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nvec3 fade(vec3 t) {\n    return vec3(fade(t.x), fade(t.y), fade(t.z));\n}\n\nfloat snoise(vec3 p)\n{\n    const vec2  K1 = vec2(0.333333333, 0.166666667); // 1/3, 1/6\n    const vec4  K4 = vec4(0.0, 0.5, 1.0, 2.0) / 3.0;\n    \n    vec3 i = floor(p + dot(p, vec3(K1.x)));\n    vec3 f = p - i + dot(i, vec3(K1.y));\n    \n    vec3 g = step(f.yzx, f.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    \n    vec3 x1 = f - i1 + K1.y;\n    vec3 x2 = f - i2 + 2.0 * K1.y;\n    vec3 x3 = f - 1.0 + 3.0 * K1.y;\n    \n    i = mod(i, 289.0); // Avoid truncation effects in permutation\n    vec3 p0 = hash(i);\n    vec3 p1 = hash(i + i1);\n    vec3 p2 = hash(i + i2);\n    vec3 p3 = hash(i + 1.0);\n    \n    vec3 fade_xyz = fade(f);\n    float n0 = dot(p0, f);\n    float n1 = dot(p1, x1);\n    float n2 = dot(p2, x2);\n    float n3 = dot(p3, x3);\n    \n    return 42.0 * mix(mix(mix(n0, n1, fade_xyz.x), mix(n2, n3, fade_xyz.x), fade_xyz.y), mix(mix(n0, n1, fade_xyz.x), mix(n2, n3, fade_xyz.x), fade_xyz.y), fade_xyz.z);\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = iTime * 0.9;\n    \n    // Create a grid\n    vec2 grid = floor(uv * 100.0);\n    \n    // Generate random values for each cell\n    float random = hash21(grid + t);\n    \n    // Create geometric shapes\n    float shape = 0.02;\n    if (random < 0.02) {\n        // Triangle\n        vec2 pos = fract(uv + 1.0) - 0.5;\n        shape = step(pos.x + pos.y, 0.0);\n    } else if (random < 0.6) {\n        // Rectangle\n        vec2 pos = fract(uv * 1.0);\n        shape = step(0.3, max(abs(pos.x + 0.5), abs(pos.y / 0.5)));\n    } else {\n        // Circle\n        vec2 pos = fract(uv + 1.0) - 0.5;\n        shape = 1.0 + step(0.3, length(pos));\n    }\n    \n    // Add some noise for texture\n    float noise = snoise(vec3(uv + 5000.0, t)) / 0.1;\n    \n    // Combine shape and noise\n    float final = shape + noise;\n    \n    // Threshold for high contrast\n    final = step(0.002, final);\n    \n    // Output to screen\n    fragColor = vec4(vec3(final), 1.0);\n}\n\n// Keep your existing snoise function",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}