{
    "Shader": {
        "info": {
            "date": "1530833050",
            "description": "Recursive Tetrahedron using raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "MdyBDc",
            "likes": 9,
            "name": "Recursive Tetrahedron",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "tetrahedron"
            ],
            "usePreview": 0,
            "username": "pedrolb",
            "viewed": 749
        },
        "renderpass": [
            {
                "code": "// CONSTANTS\n//\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.01;\nint MAX_ITERATIONS = 10;\nfloat SCALE = 2.0;\n\n\n// HERE WE DEFINE CAMERA PROPERTIES\n//\nfloat camFOV = 45.0;\nvec3 cameraPos = vec3(0.0, 0.0, -6.0);\nmat3x3 camMatrix = mat3x3(\n    vec3(1.0, 0.0, 0.0), // right vec\n    vec3(0.0, 1.0, 0.0), // up vec\n    vec3(0.0, 0.0, 1.0) // forward vec\n);\n\n\n// TRANSFORM A SCREEN PIXEL IN A VECTOR IN THE WORLD\n//\nvec3 ScreenPointToWorld (vec2 screenPoint) // Don't consider camera position, it needs to be added if needed\n{\n\tvec2 xyWorld = screenPoint - iResolution.xy / 2.0;\n    float zWorld = abs(iResolution.x / 2.0) / tan(radians(camFOV / 2.0));\n    \n    return normalize(camMatrix * vec3(xyWorld, zWorld));\n}\n\n\n// RECURSIVE TETRAHEDRON\n//\nfloat DistTetrahedron (vec3 p)\n{\n    mat3x3 rotMatrix = mat3x3(\n    \tvec3(cos(iTime * 0.5), -sin(iTime * 0.5), 0.0),\n        vec3(sin(iTime * 0.5), cos(iTime * 0.5), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    \n    mat3x3 rotMatrix2 = mat3x3(\n    \tvec3(cos(iTime * 0.5), 0.0, -sin(iTime * 0.5)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(sin(iTime * 0.5), 0.0, cos(iTime * 0.5))\n    );\n    \n\tvec3 v1 = rotMatrix * rotMatrix2 * vec3(1.0, 1.0, 1.0);\n    vec3 v2 = rotMatrix * rotMatrix2 * vec3(-1.0, 1.0, -1.0);\n    vec3 v3 = rotMatrix * rotMatrix2 * vec3(1.0, -1.0, -1.0);\n    vec3 v4 = rotMatrix * rotMatrix2 * vec3(-1.0, -1.0, 1.0);\n    \n    vec3 c;\n    int counter = 0;\n    \n    float distToVertex, d;\n    while(counter < MAX_ITERATIONS)\n    {\n        c = v1;\n        distToVertex = length(p - v1);\n        \n        d = length(p - v2); if(d < distToVertex) {c = v2; distToVertex = d;} \n        d = length(p - v3); if(d < distToVertex) {c = v3; distToVertex = d;} \n        d = length(p - v4); if(d < distToVertex) {c = v4; distToVertex = d;} \n        \n        p = SCALE * p - c * (SCALE - 1.0);\n        counter++;\n    }\n    \n    return length(p) * pow(SCALE, float(-counter));\n}\n\n\n// SURFACE NORMAL\n//\nvec3 GetTetrahedronNormals(vec3 p)\n{\n    return normalize(vec3(\n        DistTetrahedron(vec3(p.x + EPSILON, p.y, p.z)) - DistTetrahedron(vec3(p.x - EPSILON, p.y, p.z)),\n        DistTetrahedron(vec3(p.x, p.y + EPSILON, p.z)) - DistTetrahedron(vec3(p.x, p.y - EPSILON, p.z)),\n        DistTetrahedron(vec3(p.x, p.y, p.z + EPSILON)) - DistTetrahedron(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n// RETURNS THE DISTANCE FROM THE CAMERA OF THE CLOSEST POINT TO THE SURFACE\n//\nfloat RayMarchingClosestPoint(vec3 camPos, vec3 lookDir, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float distToSurface = DistTetrahedron(camPos + lookDir * depth);\n        if(distToSurface < EPSILON)\n        {\n            return depth;\n        }\n        depth += distToSurface;\n        if(depth >= end)\n        {\n        \treturn end;    \n        }\n    }\n    return end;\n}\n\n\n// CONTRIBUTION FOR EACH LIGHT USING PHONG\n//\nvec3 LightContribution(\n    vec3 diffuseColor, \n    vec3 specularColor, \n    vec3 ambientColor,\n    float glossiness,\n    vec3 normal,\n    vec3 viewDir,\n    vec3 surfacePos,\n    vec3 lightColor,\n    float lightIntensity,\n    vec3 lightPos\n)\n{\n    vec3 N = normal;\n    vec3 V = -viewDir;\n    vec3 L = normalize(lightPos - surfacePos);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = max(0.0, dot(L, N));\n    float dotRV = max(0.0, dot(R, V));\n    float dotVN = 1.0 - max(0.0, dot(V, N));\n    \n    return \n        (lightIntensity * lightColor *\n            (dotLN * diffuseColor\n             + (1.0 - mix(0.1, 1.0, dotVN * dotVN)) * specularColor * pow(dotRV, glossiness)\n             + texture(iChannel0, R).rgb * dotVN * dotVN * 0.3) * ambientColor\n        );\n}\n\n\n// MAIN\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = ScreenPointToWorld (fragCoord);\n    float dist = RayMarchingClosestPoint(cameraPos, viewDir, MIN_DIST, MAX_DIST);\n    \n    vec3 col = mix(vec3(0.02), vec3(0.2, 0.16, 0.1), pow(dot(viewDir, vec3(0.0, 0.0, 1.0)), 30.0));\n    \n    if(dist <= MAX_DIST - EPSILON)\n    {\n        vec3 surfPos = cameraPos + viewDir * dist;\n        vec3 surfNormals = GetTetrahedronNormals(surfPos);\n        \n        col = LightContribution(\n            vec3(0.05, 0.05, 0.015), //vec3 diffuseColor, \n            vec3(0.99, 0.65, 0.34), //vec3 specularColor, \n            vec3(1.0, 1.0, 1.0), //vec3 ambientColor,\n            15.0, //float glossiness,\n            surfNormals, //vec3 normal,\n            viewDir, //vec3 viewDir,\n            surfPos, //vec3 surfacePos,\n            vec3(1.0, 1.0, 1.0), //vec3 lightColor,\n            3.0, //float lightIntensity,\n            vec3(5.0, 5.0, -5.0) //vec3 lightPos\n        );\n        //col = vec3(1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}