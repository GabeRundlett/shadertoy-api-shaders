{
    "Shader": {
        "info": {
            "date": "1656550557",
            "description": " Computes 4 512x512 horizontal/vertical FFT passes per cubemap face (1 per component R/G/B/A).\nAlpha channel FFT isn't shown by default but can be seen in the SPLIT_COMPONENTS/SPLIT_PHASE modes.",
            "flags": 32,
            "hasliked": 0,
            "id": "7scyWl",
            "likes": 12,
            "name": "512x512 Pipelined RGB FFT",
            "published": 3,
            "tags": [
                "fft",
                "color",
                "cubemap",
                "rgb",
                "frequency",
                "fourier",
                "pipeline"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "#define SPLIT_RGB 0\n#define SPLIT_COMPONENTS 1\n#define SPLIT_PHASE 2\n\n#define VIEW_MODE SPLIT_RGB\n\nvec3 rainbow(float x)\n{\n    vec3 col = vec3(0);\n    col.r = cos(x * tau - (0.0/3.0)*tau);\n    col.g = cos(x * tau - (1.0/3.0)*tau);\n    col.b = cos(x * tau - (2.0/3.0)*tau);\n    \n    return col * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat cubeRes = float(textureSize(iChannel0,0).x);\n    \n    #if(VIEW_MODE == SPLIT_RGB)\n        vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*fftSize);\n        uvIn.x = reverseBits(mod(uvIn.x,fftSize), numStages);\n        uvIn /= fftSize*2.;\n        \n        vec2 fftInR = textureCubeFace(iChannel0,0., uvIn+vec2(0.0,0.0)).xy;\n        vec2 fftInG = textureCubeFace(iChannel0,0., uvIn+vec2(0.5,0.0)).xy;\n        vec2 fftInB = textureCubeFace(iChannel0,0., uvIn+vec2(0.0,0.5)).xy;\n        vec3 fftInRGB = vec3(length(fftInR),length(fftInG),length(fftInB));\n\n        vec2 fftR = textureCubeFace(iChannel0,5., uv.yx*(fftSize/cubeRes)+vec2(0.0,0.0)).zw;\n        vec2 fftG = textureCubeFace(iChannel0,5., uv.yx*(fftSize/cubeRes)+vec2(0.5,0.0)).zw;\n        vec2 fftB = textureCubeFace(iChannel0,5., uv.yx*(fftSize/cubeRes)+vec2(0.0,0.5)).zw;\n        vec3 fftRGB = log(-2.0+vec3(fftR.x,fftG.x,fftB.x))/log(fftSize*fftSize);\n        \n        fragColor = (side == 0.) ? vec4(fftInRGB,0) : \n                                   vec4(fftRGB,0);                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n    \n    #if(VIEW_MODE == SPLIT_COMPONENTS)\n        vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*cubeRes);\n        vec2 quadOffs = floor(uvIn/fftSize)*fftSize;\n        uvIn.x = quadOffs.x + reverseBits(mod(uvIn.x,fftSize), numStages);\n        vec2 uvFFT = clamp(mod(uv.yx,0.5) + floor(uv/0.5)*0.5, 0.0, (cubeRes-1.0)/cubeRes);\n        \n        vec2 fftIn = textureCubeFace(iChannel0,0., uvIn/cubeRes).xy;\n        vec2 fftHV = textureCubeFace(iChannel0,5., uvFFT).zw;\n        \n        fragColor = (side == 0.) ? vec4(length(fftIn)) : \n                                   vec4(log(0.1+fftHV.x)/log(fftSize*fftSize));                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n    \n    #if(VIEW_MODE == SPLIT_PHASE)\n                vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*cubeRes);\n        vec2 offs = floor(uvIn/fftSize)*fftSize;\n        uvIn.x = offs.x+reverseBits(mod(uvIn.x,fftSize), numStages);\n        vec2 fftIn = textureCubeFace(iChannel0,0., uvIn/cubeRes).xy;\n\n        vec2 uvFFT = clamp(mod(uv.yx,0.5)+floor(uv/0.5)*0.5, 0.0,(cubeRes-1.)/cubeRes);\n        vec2 fftHV = textureCubeFace(iChannel0,5., uvFFT).zw;\n        \n        fragColor = (side == 0.) ? vec4(length(fftIn)) : \n                                   vec4(rainbow(fftHV.y),0);                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float fftSize = 512.;\nconst float numStages = ceil(log2(float(fftSize)));\n\n// -- Constants --\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n// -- Math Functions --\n\n//Complex multiply\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(dot(a,b*vec2(1,-1)), dot(a,b.yx));\n}\n\n//Reverse 0 to 'n' in integer 'x'\nfloat reverseBits(float x, const float n)\n{\n    int r = 0;\n    int xi = int(x);\n    for(int i = 0;i < int(n);i++)\n    {\n        r = r << 1 | (xi & 1);\n        xi >>= 1;\n    }\n    return float(r);\n}\n\n/*\nButterfly operation\n\n(x0)____________(+)_(xy)\n            \\  /\n             \\/\n             /\\\n(x1)_W(i,n)_/__\\(-)_(zw)\n\nxy = x0 + W(i,n)*x1\nzw = x0 - W(i,n)*x1\n\n*/\nvec4 butterfly(vec2 x0, vec2 x1, float i, float n)\n{\n    float a = -floor(i)*tau/floor(n);\n    vec2 w = vec2(cos(a),sin(a));\n    x1 = cmul(x1, w);\n    return vec4(x0 + x1, x0 - x1);\n}\n\n// -- Windowing Functions --\n\n//Rectangular window\nfloat Rectangle(float i, float N)\n{\n    return step(0.0,i)-step(N,i);\n}\n\n//Hann Window\nfloat Hann(float i, float N)\n{\n    float x = clamp(floor(i)/floor(N),0.0,1.0);\n    float w = sin(pi*x);\n    return w*w;\n}\n\n//Triangular window\nfloat Triangle(float i, float N)\n{\n    float x = clamp(floor(i)/floor(N),0.0,1.0);\n    return 1.0-abs(2.0*x - 1.0);\n}\n\n// -- Cubemap Sampling Helper Functions --\n\n//Converts a ray direction to uv coords (xy, normalized) & a face id (z, 0-5).\n//for the cubemap face it's pointing to.\nvec3 rayToFace(vec3 rd)\n{\n    vec3 asign = sign(rd);\n    rd = abs(rd);\n    float amax = max(max(rd.x,rd.y),rd.z);\n    \n    vec3 face = (rd.x == amax) ? vec3(asign.yz*rd.yz, floor(1.+.5*asign.x)) :\n                (rd.y == amax) ? vec3(asign.xz*rd.xz, floor(3.+.5*asign.y)) :\n                (rd.z == amax) ? vec3(asign.xy*rd.xy, floor(5.+.5*asign.z)) : \n                                 vec3(0,0,-1);\n    face.xy = .5+.5*(face.xy/amax);\n    face.xy = floor(face.xy*1024.)/1024.; \n    return face;\n}\n\n//opposite of rayToFace\n//Converts normalized uv coords & a face id to a ray direction\n//for cubemap sampling\nvec3 faceToRay(vec3 face)\n{\n    face.xy = face.xy + 0.5/1024.;\n    vec3 rd = vec3(2.0*fract(face.xy)-1.0, sign(mod(face.z,2.)-.5));\n    rd = (face.z <= 1.) ? rd.zxy :\n         (face.z <= 3.) ? rd.xzy :\n         (face.z <= 5.) ? rd.xyz :\n                          vec3(0);\n    return normalize(rd);\n}\n\n//Sample a cubemap face (0-5) with normalized uv coords.\nvec4 textureCubeFace(samplerCube cube, float face, vec2 uv)\n{\n    vec3 rd = faceToRay(vec3(uv,floor(face)));\n    return texture(cube, rd, 0.0).rgba;  \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n//Input Windowing Function (Rectangle/Triangle/Hann)\n#define WINDOW_FUNCTION Hann\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    float cubeRes = float(textureSize(iChannel0,0).x);\n    vec3 face = rayToFace(rd);\n    vec2 uv = face.xy*cubeRes;\n    \n    vec2 quadOffs = floor(uv/fftSize)*fftSize;\n    int quadId = int(uv.x/fftSize) + 2*int(uv.y/fftSize);\n    \n    uv = mod(uv, vec2(fftSize));\n    \n    float idx = uv.x;\n    float stage = face.z;\n    vec4 cout = vec4(0.0); \n    \n    if(stage == 0.0)\n    {\n        //XY = Horizonal FFT Input (Channel 1)\n        //Input image is mapped 1:1 into the input buffer with no scaling.\n        //Input image centered in the 512x512 buffers.\n        vec2 texRes = iChannelResolution[1].xy;\n        vec2 texUV = vec2(reverseBits(uv.x, numStages), uv.y);\n        vec2 texOrig = vec2(fftSize/2.0)-vec2(texRes/2.0);\n        \n        vec2 windowOrig = texUV - max(vec2(0),texOrig);\n        vec2 windowSize = min(vec2(fftSize),\n                          min(vec2(fftSize) - texOrig,\n                          min(texOrig + texRes, texRes)));\n                          \n        vec4 col = texelFetch(iChannel1, ivec2(texUV - texOrig), 0);\n        \n        cout.xy = vec2(col[quadId], 0);         \n        cout.xy *= WINDOW_FUNCTION(windowOrig.x, windowSize.x);\n        cout.xy *= WINDOW_FUNCTION(windowOrig.y, windowSize.y);\n\n        //ZW = Vertical FFT Input (Horizontal FFT output rotated 90deg)\n        uv.x = float(reverseBits(uv.x, numStages));\n        cout.zw = textureCubeFace(iChannel0, 5.0, (uv.yx + quadOffs.xy)/cubeRes).xy;\n    }\n    else\n    {\n        //2x Horizontal 4-sample FFTs on XY & ZW components\n        float stage1Size = floor(exp2(float(stage)*2.0));\n        float stage0Size = floor(stage1Size/2.0);\n\n        float offs = floor(idx / stage1Size)*stage1Size;\n        idx -= offs;\n        \n        float w0 = mod(idx, stage0Size/2.0);\n        float w1 = mod(idx, stage1Size/2.0);\n        \n        vec4 soffs = mod(offs + w0 + vec4(0,1,2,3)*stage0Size/2., fftSize) + quadOffs.x;\n        uv.y += quadOffs.y;\n        \n        vec4 x0 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[0], uv.y)/cubeRes);\n        vec4 x1 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[1], uv.y)/cubeRes);\n        vec4 x2 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[2], uv.y)/cubeRes);\n        vec4 x3 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[3], uv.y)/cubeRes);\n\n        vec4 y0y1_H = butterfly(x0.xy, x1.xy, w0 - fftSize/2.0, stage0Size);\n        vec4 y2y3_H = butterfly(x2.xy, x3.xy, w0 - fftSize/2.0, stage0Size);\n\n        vec4 y0y1_V = butterfly(x0.zw, x1.zw, w0 - fftSize/2.0, stage0Size);\n        vec4 y2y3_V = butterfly(x2.zw, x3.zw, w0 - fftSize/2.0, stage0Size);\n        \n        vec4 z0z1_H, z0z1_V;\n        \n        if(mod(idx, stage0Size) < stage0Size/2.0)\n        {\n            z0z1_H = butterfly(y0y1_H.xy, y2y3_H.xy, w1 - fftSize/2.0, stage1Size);            \n            z0z1_V = butterfly(y0y1_V.xy, y2y3_V.xy, w1 - fftSize/2.0, stage1Size);\n        }\n        else\n        {\n            z0z1_H = butterfly(y0y1_H.zw, y2y3_H.zw, w1 - fftSize/2.0, stage1Size);            \n            z0z1_V = butterfly(y0y1_V.zw, y2y3_V.zw, w1 - fftSize/2.0, stage1Size);\n        }\n        \n        cout = (idx < stage1Size/2.0) ? vec4(z0z1_H.xy,z0z1_V.xy): \n                                        vec4(z0z1_H.zw,z0z1_V.zw);\n    }\n    \n    if(face.z == 5.0) //Convert to magnitude/phase on last stage of vertical FFT\n    {\n        cout.zw = vec2(length(cout.zw), atan(cout.w, cout.z)/pi + 0.5);\n    } \n    \n    fragColor = vec4(cout);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "//Debugging Test Pattern\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0) / iResolution.y;\n    \n    vec4 f = 500.0*vec4(uv.x, uv.y, (uv.x+uv.y)/sqrt(2.0), (uv.x-uv.y)/sqrt(2.0));\n    float l = length(uv)*120.0;\n    \n    fragColor = sin(l)/l * sin(f);\n}\n//*/\n\n//*\nvoid mainImage( out vec4 c, vec2 o )\n{\n    vec2 r = iResolution.xy;o-=r/2.;o*=r.y/512.;\n    o = vec2(length(o) / r.y - .25, atan(o.y,o.x));    \n    vec4 s = c.yzwx = .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.),\n    f = max(o.x-s, c-o.x);\n    c = dot(10.*(s-c), clamp(f*r.y, 0., 6.)) * (s-.1) + f;\n}\n//*/",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}