{
    "Shader": {
        "info": {
            "date": "1726551011",
            "description": "click to pic and press (w s a d) to move",
            "flags": 16,
            "hasliked": 0,
            "id": "lXXyRs",
            "likes": 0,
            "name": "WASD moving fractal",
            "published": 3,
            "tags": [
                "fractal",
                "moving"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 81
        },
        "renderpass": [
            {
                "code": "vec4 loadValue(in ivec2 coords) {\n    return texelFetch(iChannel1, coords, 0);\n}\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.1, 0.5, 0.1);\n    vec3 b = vec3(0.5, 0.1, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel0, vec2(key, 0.25) ).x > .0;\n}\n\nbool checkCollision(in vec2 circlePos, in float radius, in vec2 platformPos, in vec2 platformSize) {\n    vec2 closestPoint = clamp(circlePos, platformPos - platformSize, platformPos + platformSize);\n    vec2 delta = circlePos - closestPoint;\n    float distanceSquared = dot(delta, delta);\n    return distanceSquared <= radius * radius;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000);\n\n// display digits\nint PrintInt(in vec2 uv, in int value) {\n    const int maxDigits = 3; \n    if (abs(uv.y - 0.5) < 0.5) {\n        int iu = int(floor(uv.x));\n        if (iu >= 0 && iu < maxDigits) {\n            int n = (value / powers[maxDigits - iu - 1]) % 10;\n            uv.x = fract(uv.x);\n            ivec2 p = ivec2(floor(uv * vec2(4.0, 5.0)));\n            return (font[n] >> (p.x + p.y * 4)) & 1;\n        }\n    }\n    return 0;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n      vec2 uv2 = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    // now the uv ranges from 0 to 1, with center being (0.5, 0.5). We want the center to be (0,0)\n    // uv = uv * 2.0 - 1.0; //now the uv is centered at (0,0), ranges from (-1 to 1)\n    // uv.x *= iResolution.x/ iResolution.y; //times the ratio to avoid stretching\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n      float aPressed = texelFetch(iChannel0, ivec2(65, 0), 0).x; // A\n   \n     float wPressed = texelFetch(iChannel0, ivec2(68, 0), 0).y; // A\n  \n   // main logic circle\n   vec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n      const float initialPlatformFallSpeed = 0.03; \n    const float maxPlatformSpeed = 0.25;        \n    const float speedIncreaseInterval = 10.0;    \n    const float borderLimit = 6.3;              \n    const float groundPosition = -3.1;         \n    const float platformHeightReset = 4.5;     \n    \n    vec2 platformSize = vec2(0.7, 0.15) * 3.5;\n    float circleRadius = 0.2 * 3.5;          \n\n    // load previous states \n    vec4 playerPosition = loadValue(ivec2(0, 0));     \n    vec4 platformSpeedData = loadValue(ivec2(1, 0));  \n    vec4 platformPosition = loadValue(ivec2(3, 0));  \n     \n\n    \n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\t uv = fragCoord.xy/iResolution.xy+(cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n        uv = fract(uv * 5.5) - 0.5; //center the repeated uv\n   \n    vec2 uvScene = fragCoord / iResolution.xy;\n\n    float scale = 0.25; \n    uvScene = (uvScene - 0.5) / scale + 0.5; \n\n    uvScene = uvScene * 2.0 - 1.0;\n    uvScene.x *= iResolution.x / iResolution.y;\n    \n    int score ;\n    if (platformPosition.y <= -6.3) {          \n        platformPosition.y = platformHeightReset;\n        platformPosition.x = (rand(vec2(iTime, float(score))) * 2.0 - 1.0) * (borderLimit - platformSize.x); \n        score += 1; \n    }\n   \n    for (float i = 0.0; i < 2.0; i++) {\n     if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{\n     score += 100; \n\t\tuv.y += 0.05+0.7*iTime;\n        \n\t}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{\n\t\t\t\tuv.y -= 0.05+0.7*iTime;\n                  score += 10; \n    }\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{\n\t\tuv.x += 0.05+0.7*iTime;\n          score += 100; \n\t}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{\n\t\tuv.x -= 0.05+0.7*iTime;\n          score += 100; \n\t}\n   \n        uv = fract(uv * 5.5) - 0.5; //center the repeated uv\n\n\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + iTime * 0.4);\n        d = sin(d * 8. + iTime)/8.; //sdf for 2D circle\n        d = abs(d);\n        d = 0.02 / d;\n\n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor,1.0);  \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n     fragColor+= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,1.15), 1.0);\n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,1.15), 1.0);\n   \n   \n    // display count in the highest point centre of screen \n    vec2 scoreUV = (uvScene - vec2(-0.6, 3.4)) * 0.2; \n    float scoreDisplay = float(PrintInt(scoreUV * 10.0, score));\n    fragColor = mix(fragColor, vec4(0.5, 1.0, 1.0, 1.0), scoreDisplay); \n}\n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}