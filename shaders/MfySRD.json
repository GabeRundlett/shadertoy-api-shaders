{
    "Shader": {
        "info": {
            "date": "1714863982",
            "description": "Multiple distortion types are demonstrated.",
            "flags": 8,
            "hasliked": 0,
            "id": "MfySRD",
            "likes": 3,
            "name": "Sound: Distortion Types",
            "published": 3,
            "tags": [
                "sound",
                "distortion",
                "soft",
                "hard",
                "clipping",
                "bitreduction"
            ],
            "usePreview": 0,
            "username": "taylormatson",
            "viewed": 173
        },
        "renderpass": [
            {
                "code": "// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Sound: Destortion Types\n// Goal: Demonstrate various types of distortion\n// Requirements: Mono signal input and output\n\nvec2 mainSound( int samp, float time )\n{\n    // Initialize oscillator\n    float osc = sin(6.2831*80.0*time)*exp(-1.0*time);\n    \n    // hardClip Variable\n    float thresh = 0.5; // [0 to 1]\n    \n    // cubic Variable\n    float a = 3.; // [0 to 6] - (amplitude of the third harmonic, starts clipping above 6)\n    \n    // arctan Variable\n    float alpha = 10.; // [0 to 10] approaches a square wave the higher alpha is\n    \n    // exponential Variable\n    float G = 10.; // [ 0 to 10 ]\n    \n    // bitReduce Variable\n    float nBits = 4.; // nBits is the number of bits used. Redux range: [Crush > 1]\n    \n    // asym Variable\n    float dc_offset = 0.; // [0 to 1]\n    \n    // slew Variable\n    float maxFreq = 1000.;\n    \n    // --- Check common tab for the different fuctions\n    \n     return vec2(osc);\n    \n    // return vec2(infinite(osc)); // VERY LOUD\n  \n    // return vec2(halfwave(osc));\n    \n    // return vec2(fullwave(osc));\n    \n    // return vec2(hard(osc, thresh)); \n    \n    // return vec2(cubic(osc, a));\n    \n    // return vec2(arctan(osc, alpha));\n    \n    // return vec2(sine(osc));\n    \n    // return vec2(exponential(osc, G));\n    \n    // return vec2(bitRedux(osc, nBits));\n    \n    // return vec2(peicewise(osc));\n    \n    // return vec2(diode(osc));\n    \n    // return vec2(asym(osc, dc_offset));\n     \n    // return vec2(fuzzy(osc, time));\n     \n    // return vec2(slew(osc, iSampleRate, maxFreq));\n    \n    // ---------------------------------------\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define PI 3.1415926535\n#define TAU 6.2831853071\n\n// Functions by Taylor Matson, education from Eric Tarrs book and YT series 'Hack Audio'\n// Sound: Distortion Types © 2024 by Taylor Matson is licensed under CC BY 4.0\n\nfloat infinite( float signal )\n{\n    // infinite\n    // This function implements infinite clipping\n    // distortion. Amplitude values of the input signal\n    // that are positive are changed to 1 in the\n    // output signal. Amplitude values of the input signal\n    // that are negative are changed to –1 in the\n    // output signal.\n    \n    if (signal >= 0. ){\n        return 1.;  \n    } return -1.;\n    \n}\n\nfloat halfwave( float signal )\n{\n    // half\n    // This function implements half–wave rectification\n    // distortion. Amplitude values of the input signal\n    // that are negative are changed to zero in the\n    // output signal.\n\n    if (signal >= 0.){\n        return signal;\n    } return 0.;\n    \n}\n\nfloat fullwave( float signal )\n{\n    // full\n    // This function implements full–wave rectification\n    // distortion. Amplitude values of the input signal\n    // that are negative are changed to positive in the\n    // output signal.\n    \n    if (signal >= 0.){\n        return signal;\n    } return -1.*signal;\n    \n}\n\nfloat hard( float signal, float thresh )\n{\n    // hard\n    // This function implements hard–clipping\n    // distortion. Amplitude values of the input signal\n    // that are greater than a threshold are clipped.\n    \n    if (signal > thresh){\n        return thresh;\n    } \n    \n    if (signal < -thresh){\n        return -thresh;\n    }\n    \n    return signal;\n}\n\nfloat cubic( float signal, float a )\n{\n    // cubic\n    // This function implements cubic soft–clipping\n    // distortion. An input parameter \"a\" is used\n    // to control the amount of distortion applied\n    // to the input signal.\n    \n    return signal - a*(1./3.)*pow(signal, 3.);\n}\n\nfloat arctan( float signal, float alpha )\n{\n    // arctan\n    // This function implements arctangent soft–clipping\n    // distortion. An input parameter \"alpha\" is used\n    // to control the amount of distortion applied\n    // to the input signal.\n\n    return (2./PI) * atan(alpha * signal); \n}\n\nfloat exponential( float signal, float G )\n{\n    // exponential\n    // This function implements exponential soft–clipping\n    // distortion. An input parameter \"G\" is used\n    // to control the amount of distortion applied\n    // to the input signal.\n    \n    return sign(signal) * (1. - exp(-abs(G*signal)));\n    \n    // return mono_in/abs(mono_in) * (1. - exp(-abs(G*mono_in)));\n    // This does the same thing but has pops and clicks\n    // demonstrating the effect of gpu accelerated functions like sign\n    \n}\n\nfloat bitRedux( float signal, float nBits )\n{\n    // bitReduce\n    // This function creates a bit reduction or\n    // bit crushing distortion. It uses an input\n    // variable, \"nBits\", to determine the number of\n    // amplitude values in the output signal. This\n    // algorithm can have a fractional number of bits.\n    \n    float ampValues = pow(2., nBits);\n    float prepInput = .5*signal+.5;\n    float scaleInput = ampValues*prepInput;\n    float roundInput = round(scaleInput);\n    float prepOut = roundInput / ampValues;\n    return 2.*prepOut-1.;\n}\n\nfloat peicewise( float signal )\n{\n    // pieceWise\n    // This function implements a piecewise distortion\n    // algorithm. Within one operating region, the\n    // input signal is not distorted. When the signal\n    // is outside of that operating region, it is clipped.\n    \n    if (abs(signal) < 1./3.) {\n        return signal*2.;\n    } \n    \n    if (abs(signal) > 2./3.) {\n        return sign(signal);\n    }\n    \n    return sign(signal) * (3.-pow((2. - (3. * abs(signal))), 2.)) / 3.;\n}\n\nfloat diode( float signal )\n{\n    // diode\n    // This function implements the Shockley\n    // ideal diode equation for audio signals\n    // with an amplitude between –1 to 1 FS\n    \n    float Vt = 0.0253; // thermal voltage\n    float eta = 1.68; // emission coefficient - between 1 and 2 for diff diodes\n    float Is = .105; // saturation current\n    return Is * ( exp( (.1*signal)/(eta*Vt) ) - 1.);\n}\n\nfloat asym( float signal, float offset )\n{\n    // asym\n    // This function creates a signal that  has\n    // both even and odd harmonics.\n    // distortion can be any distorting function of the signal.\n    // Just remove or add the offset at the beginning and then\n    // after the distortion calculation, do the opposite.\n    \n    signal -= offset;\n    float distorted = sin(signal);\n    \n    return distorted+offset;\n}\n\nfloat fuzzy( float signal, float time )\n{\n    \t// Taken from https://shadertoy.com/view/WlS3Dd\n        float tck = time * 1.8; // time/60.*108\n        float ftm = mod(4. * tck, 1.);\n        float fuzzy = mix(signal, .0125 * max(0., .25 - (700. * asin(signal))), .3);\n\t\tfuzzy *= min(1., 1. * ftm) * max(0., 1. - ftm);\n\t\treturn fuzzy;\n}\n\nfloat slew( float signal, float Fs, float maxFreq)\n{\n    float Ts = 1./Fs; // Time per sample\n    float peak = 1.; // Max amplitude\n    float slewRate = maxFreq*TAU*peak; // Convert freq to slew rate\n    float slope = slewRate * Ts; // Convert slew rate to slope/sample\n    float prevOut; // Initialize feedback delay sample\n    float delta = signal - prevOut; // Determine the change between samples\n\n    if (delta > slope){\n        delta = slope;\n        \n    } else if (delta < -slope){\n        delta = -slope;\n    \n    }\n    \n    return prevOut + delta;\n    prevOut = signal;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}