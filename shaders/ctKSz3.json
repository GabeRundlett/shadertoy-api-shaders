{
    "Shader": {
        "info": {
            "date": "1686592221",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n\nif slow turn AA off 1 ",
            "flags": 0,
            "hasliked": 0,
            "id": "ctKSz3",
            "likes": 19,
            "name": "Year of Truchets #035",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #035\n    06/12/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Square truchet with offset to match corner roundness \n    \n*/\n\n//if slow turn AA off 1 \n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n#define MAX_DIST    45.\n\nvec3 hp,hitpoint;\nfloat gid,sid,speed,tspd;\nmat2 r90,rta;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n//@iq\nfloat box(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2(d,abs(z)-h);return min(max(w.x, w.y),0.)+length(max(w,0.));\n}\n\nconst float sz = 8.5;\nconst float hf = 4.25;\nconst float scale = .1;\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    \n    //@mla inversion\n    float k = 8./dot(p,p); \n    p *= k;\n    \n    p.y += speed;\n    vec3 pp = p;\n    \n    float pid = floor((p.y+hf)/sz);\n    p.y = mod(p.y+hf,sz)-hf;\n\n    p.xz*=rot(tspd+(pid*.234));\n    pp.xz = p.xz;\n    \n    vec2 id = floor(p.xz*scale), q = fract(p.xz*scale)-.5;\n    float hs = hash21(id.xy+pid);\n    if(hs>.5)  q.xy *= r90;\n    \n    hs = fract(hs*575.3+pid);\n    const float pf = .45,wd = .1;\n    \n    vec2 p2 = vec2(length(q.xy-pf),length(q.xy+pf));\n    vec2 r = p2.x<p2.y? q.xy-pf : q.yx+pf;\n    \n    // patterns\n    float d = abs(box(r,vec2(.15))-.3)-wd;\n    float d1 = 1e5, d2=1e5, d3=1e5;\n    \n    p.y *= scale;\n    \n    if(hs>.75) {\n        d2 = length(q.x)-wd;\n        d = length(q.y)-wd;\n        \n        float ff = .125*cos(q.y*PI2)+.125;\n        float py = fract(hs*37.72)>.65? p.y-ff : p.y+ff;\n        d3 = opx(d2,py,wd);\n    } else if(hs<.25) {\n        d = length(q.x)-wd;\n        d = min(length(abs(q.xy)-vec2(.5,0))-wd,d);\n    }\n\n    d1 = opx(d,p.y,wd);\n    \n    if(d1<res.x) {\n        res = vec2(d1,2.);\n        hp = pp;\n    }\n   \n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hp = pp;\n    }\n    \n    // compensate for scaling and warp\n    res.x /= scale;\n    res.x *= 1./k;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<80;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<MIN_DIST) hit = true;\n        d += i<45? t.x*.3 : t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout float d) {\n        \n    vec3 RC = vec3(0), p = ro;\n    float m = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p,hit);\n    d = ray.x;\n    m = ray.y;\n    hitpoint = hp;\n\n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 l = normalize(vec3(.2,8,.2)-p);\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        float spec = .75*pow(max(dot(normalize(p-ro),reflect(l,n)),0.),5.);\n        vec3 h = hsv2rgb(vec3(hitpoint.y*.01,1.,.5));\n        RC = h * diff+min(shdw,spec);\n    } \n    return RC;\n}\n\nmat2 rx,ry;\n\nconst vec3 FC = vec3(.012,.098,.188);\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    speed=T*.7;\n    r90=rot(1.5707);\n    tspd=T*.012*PI2;\n    \n    // mouse\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*1.-.5)*PI;\n \n    rx =rot(-x-1.5707);\n    ry =rot(-y);\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        // ro + rd\n        vec3 ro = vec3(0,0,1.);\n        vec3 rd = normalize(vec3(uv,-1));\n\n        ro.zy*=rx;rd.zy*=rx;\n        ro.xz*=ry;rd.xz*=ry;\n\n        float d = 0.;\n\n        vec3 color = render(ro,rd,d);\n        color = mix(FC,color,exp(-2.5*d*d*d));\n        \n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}