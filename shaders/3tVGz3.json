{
    "Shader": {
        "info": {
            "date": "1579873936",
            "description": "newer version of Scale Sequencer\n",
            "flags": 40,
            "hasliked": 0,
            "id": "3tVGz3",
            "likes": 13,
            "name": "[â™ª]Scale Sequencer 2",
            "published": 3,
            "tags": [
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 573
        },
        "renderpass": [
            {
                "code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\nfloat circle(vec2 p,vec2 s,float r1,float r2){\n    float d=1./iResolution.y;\n    float v=(s.x+s.y)*.5;\n    float l=length(p);r1+=v*.01;r2+=r1;\n    float r=min(smoothstep(r1,r1+d,l),smoothstep(r2+d,r2,l));\n    s=abs(s);\n    v=p.x<0.?s.x*3.+s.y:s.x+s.y*3.;\n    r=min(r,smoothstep(v+d,v,atan(abs(p.x),-p.y)));\n    return v>0.?r*.6:0.;\n}\nvec4 tx1(int x){\n    return texture(iChannel1,vec2((float(x)+.5)/iResolution.x,.5/iResolution.y))*2.-1.;\n}\nmat2 rot(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec3 e=vec3(.07,.07,0);\n    vec4 c=texture(iChannel0,uv+e.xz)*.2;\n    c=max(c,texture(iChannel0,uv-e.xz)*.2);\n    c=max(c,texture(iChannel0,uv+e.zy)*.2);\n    c=max(c,texture(iChannel0,uv-e.zy)*.2);\n    c*=1.-length(uv-.5)*1.5;\n    c=max(c,texture(iChannel0,uv));\n    c.w=1.;\n    \n    uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    float vol=tx1(0).x*.5+.5;\n    vec4 tx=vec4(0);\n    if(length(uv)<.5){\n        tx=tx1(6);c.xy+=circle(uv,tx.xy   *vol,0.15,.09);c.z +=circle(uv,tx.zw   *vol,0.15,.09);\n        tx=tx1(5);c.x +=circle(uv,tx.xy*6.*vol,0.25,.02);c.yz+=circle(uv,tx.zw*6.*vol,0.25,.02);\n        tx=tx1(4);c.xy+=circle(uv,tx.xy*5.*vol,0.28,.02);c.z +=circle(uv,tx.zw*5.*vol,0.28,.02);\n        tx=tx1(3);c.x +=circle(uv,tx.xy*2.*vol,0.31,.04);c.yz+=circle(uv,tx.zw*2.*vol,0.31,.04);\n        tx=tx1(2);c.xy+=circle(uv,tx.xy*2.*vol,0.36,.06);c.z +=circle(uv,tx.zw*2.*vol,0.36,.06);\n        tx=tx1(1);c.x +=circle(uv,tx.xy*2.*vol,0.43,.04);c.yz+=circle(uv,tx.zw*2.*vol,0.43,.04);\n        c+=circle(uv*rot(-iTime*6.283*bpm/120.),vec2(vol*.7),0.12,.02);\n        c+=circle(uv*rot(-iTime*6.283*bpm/120.),vec2(vol*(iTime/180.)),0.48,.01);\n    }\n\tfragColor=c;    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// see \"Common\" tab",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\n//BufferA:animation\n\nvec3 hsv(float h,float s,float v){\n    return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec4 c=texture(iChannel0,fragCoord/iResolution.xy).gbra*.3;\n\tfloat t=iTime*.2,a=0.,x=0.,y=0.;\n\tvec2 uv=(fragCoord/iResolution.y-.5)*mat2(sin(t),cos(t),-cos(t),sin(t)),p=uv*3.;\n\tfor(int i=0;i<25;i++){\n        x=sin(t*1.107+a*.1)*3.,y=sin(t*.907+a*.4)*3.;\n        p=vec2(cos(p.x+x),sin(p.x+a*3.-y))*exp(p.y+a*3.+4.4)*.05+uv;\n        if(p.y>100.)break;\n        a+=.04;\n    }\n\tc=max(c,a<1.?vec4(hsv(a*.4+t*.05,sin(log(abs(p.x))*.1)*.5+.5,1.5-fract(log(abs(p.y))*.05)-a),0):vec4(0));\n    c.w=a;\n    fragColor=c;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=188.;\nconst float noteseed=177.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=10;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x31001434u,0x31001491u,0x31001022u,0x31001022u,  //0C-0F backing\n    0x10000000u,0x10000000u,0x10000000u,0x10000000u,  //10-13 chord\n    0x44504789u,0x4461a890u,0x44143327u,0x44957631u,  //14-17 bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu,\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x1100011fu);\nconst uint[16] seq3=uint[]( //bass\n    0x11000114u,0x11000114u,0x11000214u,0x11000616u,\n    0x11000114u,0x11000114u,0x11000214u,0x11000717u,\n    0x11000614u,0x11000414u,0x11000514u,0x11000116u,\n    0x11000614u,0x11000414u,0x11000514u,0x11000717u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000110u,0x11000110u,0x11000210u,0x11000612u,\n    0x11000110u,0x11000110u,0x11000210u,0x11000713u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000112u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000713u);\nconst uint[16] seq5=uint[]( //backing\n    0x1100010cu,0x00000000u,0x1100020cu,0x190d860eu,\n    0x1100010cu,0x00000000u,0x1100020cu,0x110d870fu,\n    0x1100060cu,0x00000000u,0x1100050cu,0x170d810eu,\n    0x1100060cu,0x00000000u,0x1100050cu,0x110d870fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000101u,0x11000102u,0x11000203u,0x11000604u,\n    0x11000101u,0x11000102u,0x11000203u,0x11000705u,\n    0x11000606u,0x11000407u,0x11000508u,0x11000109u,\n    0x11000606u,0x11000407u,0x1100050Au,0x1100070Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),4),osc_c30(f*(1.+detune),4))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 NES noise snaredrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nessd(n.x)*.8:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 NES sqr bassdrum,lowconga,highconga\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 NES sqr bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*.35:vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 N163 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30chord(freq(n.y+60.03)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.z+60.02)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.w+60.01)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 N163 backing\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+72.05)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 N163 & NES tri melody\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30lead(freq(n.y+36.05)*n.x,n.x)*.6+tri4lead(freq(n.y+60.)*n.x,n.x)*.6:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    vec4  n=vec4(0);  //chord info x:gate yzw:notes\n    o+=track1(t,l,s); //TRACK 1 NES noise snaredrum,closehh,openhh\n    o+=track2(t,l,s); //TRACK 2 NES sqr bassdrum,lowconga,highconga\n    o+=track3(t,l,s); //TRACK 3 NES sqr bass\n    o+=track4(t,l,s); //TRACK 4 N163 chord\n    o+=track5(t,l,s); //TRACK 5 N163 backing\n    o+=track6(t,l,s); //TRACK 6 N163 & NES tri melody\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.5\n#define MASTER_PRESSURE 1.1\nfloat mvol=0.; //for indicator\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o);\n    mvol=vol;\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\n//BufferB:samples for level indicator\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p=fragCoord;\n    int x=int(p.x),y=int(p.y);\n    if((x>6)||(y>0))discard;\n    vec2 o=vec2(0);\n    float t=iTime,l=steps/bpm,vol=1.;\n    if(t>sec-fade){vol=(sec-min(t,sec))/fade;}\n    t-=start*60./bpm;\n    if(t>0.){\n        int s=int(t/l);\n        if(x==0){o=vec2(vol,0);}\n        if(x==1){o=track1(t,l,s)*.5+.5;}\n        if(x==2){o=track2(t,l,s)*.5+.5;}\n        if(x==3){o=track3(t,l,s)*.5+.5;}\n        if(x==4){o=track4(t,l,s)*.5+.5;}\n        if(x==5){o=track5(t,l,s)*.5+.5;}\n        if(x==6){o=track6(t,l,s)*.5+.5;}\n    }    \n    vec2 b=texture(iChannel1,fragCoord/iResolution.xy).xy;\n    fragColor = vec4(o,b);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}