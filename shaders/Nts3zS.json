{
    "Shader": {
        "info": {
            "date": "1622326174",
            "description": "A useful coordinate system for procedural effects around lines for my reference",
            "flags": 0,
            "hasliked": 0,
            "id": "Nts3zS",
            "likes": 5,
            "name": "Line segment Coordinate System",
            "published": 3,
            "tags": [
                "2d",
                "line",
                "coordinatesystem"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 350
        },
        "renderpass": [
            {
                "code": "\n// The coordinate is a vec3: X is the projection along the line (dot product), \n// Y is the distance to that projection clamped between the beginning and the end \n// of the segment to the actual pixel, Z is the projection of the error \n// vector on the orthogonal of p1 - p2. Note that \n// the Error vector (projection on line - pixelUV) is not nesssecrly orthogonal to the p1-p2,\n// since this projection is clamped to remain between p1 and p2, to function as a line segment\n// X and Z are good for doing procedural textures around the line, since they nicely/seamlessly wrap\n// around the line. Y is good for actually drawing the line with step and fwidth.\n// -------------------------------\nfloat rand(float seed) \n{\n  return fract(sin(seed *52.02) * 762.2);\n}\n\n\nfloat aaStep(float threshold, float x)\n{\n    float afwidth = clamp(length(vec2(dFdx(x), dFdy(x))) * 0.70710678118654757, 0. ,0.05);\n    return smoothstep(threshold-afwidth, threshold+afwidth, x);\n}\n\n\n// -------------------------------\n// THE ACTUAL LINE COORD FUNCTION\n// Alternativly you could also construct a 3x3 matrix with p2-p1 in x column, ortho to that in the y column and z column coordinates of p1, then multiply the pixel coordinates with that to transform the coordinate to the line coordinate. For line segments you would still have to clamp. This will probably be more instructions due to 3x3 having unnesscerly multiplications on zero entries\nvec3 LineSegCoord(vec2 p1, vec2 p2, vec2 uv){\n    \n\n    vec2 vector = p2 - p1;                      // Find the vector between the two lines\n          uv   -= p1;                           // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = length(vector);               // Find the ditance between the two points\n       vector  /= len;                          // normalize the vector \n    float vUv   = dot(vector, uv);              // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ; // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);               // the actual distance between the current pixel and its projection on the line\n    \n    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    \n    return vec3(vUv, d, signedD); \n}\n\n// -------------------------------\nfloat movement(float seed)\n{\n  float speed = 1.;\n  float d = sin(rand(seed           ) * 512.2 + iTime  *0.4 * speed) *0.5;\n        d+= sin(rand(seed*12.+613.52) * 61.2  + iTime  *0.3 * speed) *0.25;\n        d+= sin(rand(seed*83.+22.52 ) * 721.2 + iTime  *1.2 * speed) *0.25;\n\n  return d;\n}\n\n\n\n\n// ---------------------\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// From https://www.shadertoy.com/view/Xd23Dh\nfloat voronoise( in vec2 p, float u)\n{\n\t\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    float shortestDis = 1000.0;\n    \n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n        float dis = length(d);\n        \n        if(dis<shortestDis) shortestDis = dis;\n    }\n\t\n    return shortestDis;\n}\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        uv -= vec2(0.5);\n        uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 col = vec3(0.8);\n\n    vec2 p1 = vec2(movement(0.)      *0.5*iResolution.x/iResolution.y,  movement(52.21) *0.5);\n    vec2 p2 = vec2(movement(251.83)  *0.5*iResolution.x/iResolution.y,  movement(73.521) *0.5);\n    \n    vec3 lCord = LineSegCoord(p1, p2, uv);\n    \n    \n    col = (1.-pow(voronoise(lCord.xz *10., 1.), 3.)) * lCord;\n    col = mix(vec3(1.), col, aaStep(0.005,lCord.y));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}