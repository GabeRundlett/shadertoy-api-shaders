{
    "Shader": {
        "info": {
            "date": "1644757721",
            "description": "A cell by cell traversal of offset rectangular columns. There are also options to traverse hexagon prisms and rectangles on a regular grid.",
            "flags": 32,
            "hasliked": 0,
            "id": "sslfz7",
            "likes": 50,
            "name": "Offset Grid Prism Traversal",
            "published": 3,
            "tags": [
                "procedural",
                "raytracing",
                "grid",
                "hexagon",
                "rectangle",
                "brick",
                "traversal",
                "fly"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 983
        },
        "renderpass": [
            {
                "code": "/*\n\n    Offset Grid Prism Traversal\n    ---------------------------\n\n    See Buffer A for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    \n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Offset Grid Prism Traversal\n    ---------------------------\n    \n    I wanted to produce a grid traverser that most wouldn't have seen, so \n    here's a grid of towering offset rectangular prisms. So far, all cell\n    by cell traversal tilings on Shadertoy have consisted of edge-to-edge \n    arrangements; The defalt scene here is not. Additionally, I wanted to \n    construct something that could only be raytraced via a cell by cell \n    traversal approach. That is to say, a scene with so much overlap that \n    you couldn't raymarch it on a repeat grid... I wouldn't say raymarching \n    this would be impossible, but I haven't seen it done yet.\n    \n    I've had a glitchy version of this sitting around for a while, but wasn't \n    motivated to fix it and finish it until recently. I'm not a fan of \n    writing traversal code, but like a lot of people, I can write a regular \n    square grid pylon or voxel traverser without too much trouble -- Mostly\n    becaues that was a pretty common coding task back in the 90s, or the \n    olden days, as some of the younger crowd would say. :)\n    \n    Because I was lazy and didn't want to start from scratch, I used IQ's\n    \"Grid of Cylinders\" as a template. There's not much of the original left\n    at this point, but that shader and a few of IQ's other ones were an \n    invaluable reference, which I've listed below. I also referenced a couple\n    of Fizzer's examples.\n    \n    It would have been nice to render a few samples, but I'd imagine slow \n    machines would have a hard enough time rendering this in one sample mode, \n    so I left it alone. However, I did the next best thing and utilized IQ's \n    temporal camera reprojection routine to give the impression that a few \n    samples were taken. I've said this before, but I feel IQ's reprojection\n    code is one of the coolest underutilized pieces of code on here.\n    \n    There's a bit of code here, but not too much. For whatever reason, I got\n    bored and included options to raymarch hexagons and a non offset rectangle\n    option. That complicated things a bit, but if you were to traverse just a\n    single grid, the code size and entanglement would drop considerably.\n    \n    I plan to put up some more interesting traversals later. By the way, if\n    you're interested in less common 3D traversals, Fizzer's work is definitely \n    worth looking at.\n    \n    \n    References:\n    \n    // Raymarching inside of traversed cells. Very cool, and I intend to\n    // make use of it at some stage. In fact, I used it as a template for \n    // the example you're looking at, then proceeded to overwrite almost \n    // all of it. However, I did keep a couple of cool lighting snippets \n    // and variable names. :)\n    Grid of Cylinders - iq\n    https://www.shadertoy.com/view/4dSGW1\n    \n    // IQ's 3D hexagonal traverser: It's beautifully rendered and the \n    // traversal code leaves very little room for improvement.\n    Hexagonal Grid Traversal - 3D -- iq\n    https://www.shadertoy.com/view/WtSfWK\n    \n    // I like the traversal code on this. When producing a single traverser of\n    // a tiled plane with joining neighboring vertex points, this is the method\n    // I'll be using.\n    Triangle Grid Traversal - fizzer\n    https://www.shadertoy.com/view/WtBfDd\n    \n    // A rough 2D version of this that is much easier to consume. If \n    // you can understand the following, then this will make more sense.\n    Offset Grid Traversal - Shane\n    https://www.shadertoy.com/view/fdScWd\n    \n    \n    \n*/\n\n// Maximum distance.\n#define FAR 1e8\n\n// Make use of IQ's well written temporal reprojection code. Unfortunately, \n// if you have a slow machine, all you'll see is blur, so you'll need\n// to turn it off.\n#define REPROJECTION\n\n\n// Hexagon option. \n//#define HEXAGON\n\n// Offset grid rows.\n#define OFFSET\n\n// Hexgons must have an offset defined.\n#ifdef HEXAGON\n#ifndef OFFSET\n#define OFFSET\n#endif\n#endif\n\n#define sqrt3 1.7320508 // sqrt(3.).\n\n// Scale.\n#ifdef HEXAGON\n// Hexagons will only work with the \"1 to sqrt3\" ratio -- Scaling is fine though. \n// At some stage, I'll arrange for anything to work, but it's not trivial.\nconst vec2 s = vec2(1, sqrt3)*1.5; \n#else\n// Rectangle dimensions. Any numbers should work. Obviously, vec2(1)\n// will produce squares.\nconst vec2 s = vec2(1.5, 1); \n#endif\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n \n// IQ's vec2 to float hash function.\nfloat hash21(vec2 p) { return fract(sin(dot(p, vec2(1 , 113)))*43758.5453123); }\n \n\n// The path is a 2D sinusoid that varies over time, which depends upon the \n// frequencies and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2((cos(z*.36/8.)*1. - sin(z*.2/8.)*1.2)*6., sin(z*.12/2.)*3.);\n} \n\n\n// The height function.\nfloat map(vec2 p){ \n    \n    // Only one texture read.\n    vec3 tx = texture(iChannel0, p/iChannelResolution[0].xy).xyz;  tx *= tx;\n    // Greyscale height. Using \"tx.x\" would work, too.\n\tfloat f = dot(tx, vec3(.299, .587, .114));\n    float f2 = min(f, .44); // Ground noise, so it doesn't look too flat.\n    \n    // Using the camera path to carve out a channel for the camera to glide through.\n    vec2 pth = path(p.y);\n    float pX = abs(p.x - pth.x); // The channel.\n    f *= clamp(pX*pX/24., 0., 1.); // Carving it out.\n    \n    // Returning the terrain and ground noise, then adding the undulating camera\n    // height to keep the ground close to the viewer for that rollercoaster feel. :)\n\treturn f*40. + f2*14. + pth.y;\n}\n\n// Sign function without the zero, which can cause problems for some routines.\nvec3 sign2(in vec3 p){ return vec3(p.x<0.? -1 : 1, p.y<0.? -1 : 1,  p.z<0.? -1 : 1); }\n//vec2 sign2(in vec2 p){ return vec2(p.x<0.? -1 : 1, p.y<0.? -1 : 1); }\n \n\n// Grid cell function.\nvec2 gridID(vec2 p){\n\n    \n    // Returns the cell center position-based IDs for a hexagon \n    // grid, offset rectangle grid and regular rectangle grid.\n\n    #ifdef HEXAGON\n    \n    // Hexagons.  \n    //\n    vec4 hC = floor(vec4(p/s, p/s - vec2(.5, sqrt3/3.))) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? hC.xy : hC.zw + .5;\n    \n    #else\n    \n    // Rectangles.   \n    //    \n    #ifdef OFFSET\n    // Rectangles with an offset. \n    vec2 idOff = vec2(0);\n    if(mod(floor(p.y/s.y), 2.)>.5){\n       p.x -= s.x/2.;\n       idOff.x += .5;\n    }\n    vec2 ip = floor(p/s) + .5;\n    //p -= (ip)*s;\n    return ip + idOff;\n    #else\n    // Rectangles with no offset. \n    vec2 ip = floor(p/s) + .5;\n    //p -= (ip)*s;\n    return ip;\n    #endif    \n    \n    #endif\n  \n}\n\n\n/*\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n\n    // Normally, there'd be more checks, but the boundary lines \n    // have been chosen such that a hit will always occur.    \n    float s = dot(p - ro, n)/dot(rd, n);\n    return s<0. ? 1e8 : s;\n}\n*/\n\n// Ray origin, point on the line, normal. \nfloat rayLineF(vec2 ro, vec2 p, vec2 n){\n\n    // Normally, there'd be more checks, but the boundary lines \n    // have been chosen such that a hit will always occur.    \n    return dot(p - ro, n);\n    \n}\n\n \n// Cell by cell prism traversal: It is literally the same as 2D traversal,\n// but you're testing for a top plane hit as well. That's explained below.\n// There are three sets of tile traversals here. All are regular and monohedral,\n// and two are edge-to-edge. The offset retangles are not edge-to-edge, so need \n// to be handled differently.\nvec4 raycast( in vec3 ro, in vec3 rd ){\n\n    // Result, unit vector directions, and initial postion.\n    vec4 res = vec4(1e8); // Distance, face ID and cell ID.\n    vec3 srd = sign2(rd); \n    vec3 pos3 = ro; \n    \n    \n    \n    #ifdef HEXAGON\n    // Hexagon edge normals -- Only three faces and the top can be hit by the ray.\n    // Any three normals will do.\n    vec3 i1 = vec3(.5, 0, .5); // Right forward face index.\n    vec3 i2 = vec3(1, 0, 0); // Right face index.\n    vec3 i3 = vec3(-.5, 0, .5); // Left forward face index.\n    vec3 n1 = vec3(.5, 0, sqrt3/2.); // Right forward.\n    vec3 n2 = vec3(1, 0, 0); // Right face normal.\n    vec3 n3 = vec3(-.5, 0, sqrt3/2.); // Left forward.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n\n    // Back face selection: When the ray swings in the direction of the \n    // back face, use the opposing index and normal. You can only use this\n    // trick when there's... opposing face symmetry involved. Although, with \n    // an assymetric polygon, you'll still want to check this to avoid doing\n    // the ray face distance calculation.\n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz);\n    float d3 = dot(rd.xz, n3.xz); \n    // As discussed above.\n    if(d1<0.) { i1 *= -1.; n1 *= -1.; }\n    if(d2<0.) { i2 *= -1.; n2 *= -1.; }\n    if(d3<0.) { i3 *= -1.; n3 *= -1.; }\n    \n    vec3 invN = -1./vec3(dot(rd, n1), dot(rd, n2), dot(rd, n3));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec3 t;\n\n    #else\n    // Square edge normals -- Only two faces and the top can be hit by the ray.\n    // Any two normals will do. Indexes and normals are the same, in this case.\n    vec3 n1 = vec3(1, 0, 0); // Right face normal.\n    vec3 n2 = vec3(0, 0, 1); // Forward (or back) face normal.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n    \n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz); \n\n    if(d1<0.) n1 *= -1.;\n    if(d2<0.) n2 *= -1.;\n    \n    vec2 invN = -1./vec2(dot(rd, n1), dot(rd, n2));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec2 t;\n    \n    #endif\n    \n\n    \n    \n    // Minimum top plane distance.\n    float tT;\n    \n    // Minimum plane difference, and total distance.\n    float mint = 0.;// dist = 0.;\n     \n    // Plane hit. The default is no hit.\n    int hit = 0;\n    \n    vec2 ip = gridID(pos3.xz);\n    \n    for(int i = 0; i<160; i++){\n       \n         \n        res.zw = ip*s;\n        float ma = map(res.zw); \n         \n        \n        // At this point, we haven't advanced the ray to the back of the cell boundary,\n        // so we're at one of the front cell face positions. Therefore, check to see if \n        // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n        // then break.\n        if(pos3.y<ma){\n            // Hit a side.\n            hit = 1;\n            break; \n        \n        } \n             \n        #ifdef HEXAGON        \n        // Hexagon.\n        // Ray origin, ray direction, point on the line, normal.\n        // Side face distances.\n        t.x = rayLineF(pos3.xz, res.zw + i1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, res.zw + i2.xz*s*.5, -n2.xz);\n        t.z = rayLineF(pos3.xz, res.zw + i3.xz*s*.5, -n3.xz);\n        \n        t *= invN;\n        \n        mint = min(min(t.x, t.y), t.z);   \n        \n        // Normal selection, but not needed here.\n        //vec3 n = t.x>t.y && t.x<t.z? n1 : t.y<t.z? n2 : n3;\n    \n        #else\n        \n        // Square.\n        // Ray origin, ray direction, point on the line, normal. \n        // Side face distances.\n        t.x = rayLineF(pos3.xz, res.zw + n1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, res.zw + n2.xz*s*.5, -n2.xz);\n       \n        t *= invN;\n \n        mint = min(t.x, t.y);\n        \n        // Normal selection, but not needed here.\n        //vec3 n = t.x<t.y? n1 : n2;\n \n        #endif\n        \n        // Top face distance.\n        tT = (ma - pos3.y)/(rd.y);\n        tT = tT<0. ? 1e8 : tT;\n        \n        \n        // We've now advanced to one of the back faces of the cell. Check to see whether\n        // we're still under the pylon height, and if so, we've hit the top face --  \n        // I always have to think about this, but the logic is that we haven't hit a front\n        // cell face and we're still under the height, so we've hit the top. Anyway, mark \n        // the top face as hit, advance the distance in the Y direction to the top face, \n        // then break.\n        if(tT<mint){\n            \n            //dist += tT;\n            pos3 += rd*tT; \n            hit = 2;\n            break;\n             \n        }      \n\n         \n         // Top plane, early exit.\n         //if(pos3.y>60.) { dist = 1e8; break; }\n         \n        \n         // Adding the minimum distance.\n         //dist += mint;\n         // Updating the position.\n         pos3 += rd*mint; \n         \n         // For hexagon and non offset rectangles, and other tilings where all vertices\n         // are shared by neighbors, you should call this once (outside the loop), then \n         // add the index relating to the shortest side. However, for offset rectangles, \n         // this isn't the case, so we call it every iteration. Having said that, it's \n         // not a hugely expensive operation and there's no face normal selection, so\n         // all in all, this isn't too bad at all.\n         ip = gridID(pos3.xz + srd.xz*.001);\n    \n    } \n    \n     \n    if(hit>0){\n\n        // Flag a top hit for use in normal calculations.\n        // The prism sides are calculated via polar angles.\n        res.y = hit == 2? 0. : 1.; \n        /*\n        // Face ID, to determine normals.\n        #ifdef HEXAGON        \n        res.y = t.x<t.y && t.x<t.z && t.x<tT? 1. : t.y<t.z && t.y<tT? 2. : t.z<tT? 3. : 0.;\n        if(res.y == 1. && d1<0.) res.y *= -1.;\n        if(res.y == 2. && d2<0.) res.y *= -1.;\n        if(res.y == 3. && d3<0.) res.y *= -1.;\n        #else\n        res.y = t.x<t.y && t.x<tT? 1. : t.y<tT? 2. : 0.;      \n        if(res.y == 1. && d1<0.) res.y *= -1.;\n        if(res.y == 2. && d2<0.) res.y *= -1.;\n        #endif\n        */\n        \n        res.x = length(pos3 -  ro);\n       \n    }\n    else {\n    \n        // If we don't record a hit, max out the distance.\n        res.x = 1e8;\n        //res.y = -1e8;\n    }\n  \n    // Return the distance, the faceID and the cell ID.\n    return res; // length(ro - pos3) \n    \n}    \n  \n\n \n  \n\n// Cell by cell prism traversal for shadows:\nfloat castShadowRay(in vec3 ro, in vec3 rd){\n\n    // Unit ray direction vector and initial position.\n    vec3 srd = sign2(rd);\n    vec3 pos3 = ro;\n    \n    \n    #ifdef HEXAGON\n    // Hexagon edge normals -- Only three faces and the top can be hit by the ray.\n    // Any three normals will do.\n    vec3 i1 = vec3(.5, 0, .5); // Right forward face index.\n    vec3 i2 = vec3(1, 0, 0); // Right face index.\n    vec3 i3 = vec3(-.5, 0, .5); // Left forward face index.\n    vec3 n1 = vec3(.5, 0, sqrt3/2.); // Right forward.\n    vec3 n2 = vec3(1, 0, 0); // Right face normal.\n    vec3 n3 = vec3(-.5, 0, sqrt3/2.); // Left forward.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n\n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz);\n    float d3 = dot(rd.xz, n3.xz); \n\n    if(d1<0.) { i1 *= -1.; n1 *= -1.; }\n    if(d2<0.) { i2 *= -1.; n2 *= -1.; }\n    if(d3<0.) { i3 *= -1.; n3 *= -1.; }\n    \n    vec3 invN = -1./vec3(dot(rd, n1), dot(rd, n2), dot(rd, n3));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec3 t;\n\n    #else\n    // Square edge normals -- Only two faces and the top can be hit by the ray.\n    // Any two normals will do. Indexes and normals are the same, in this case.\n    vec3 n1 = vec3(1, 0, 0); // Right face normal.\n    vec3 n2 = vec3(0, 0, 1); // Forward (or back) face normal.\n    //vec3 nT = vec3(0, 1, 0); // Top face.\n    \n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz); \n\n    if(d1<0.) n1 *= -1.;\n    if(d2<0.) n2 *= -1.;\n    \n    vec2 invN = -1./vec2(dot(rd, n1), dot(rd, n2));\n    \n    // Minimum distance from the current cell position to the opposing\n    // planes, which covers the planes in front of the ray in the\n    // direction it's travelling.\n    vec2 t;\n    \n    #endif\n    \n \n    float mint = 0.; \n    \n    // Result: Shadowed or not.\n    float res = 1.;\n    \n    vec2 ip = gridID(pos3.xz);\n    \n    \n    for(int i = 0; i<64; i++){\n       \n        vec2 id = ip*s; \n        \n        float ma = map(id);  \n\n        if(pos3.y<ma){\n            // Hit a side.\n            res = 0.;\n            break; \n        \n        }\n        \n        #ifdef HEXAGON        \n        // Hexagon.\n        // Ray origin, ray direction, point on the line, normal. \n        t.x = rayLineF(pos3.xz, id + i1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, id + i2.xz*s*.5, -n2.xz);\n        t.z = rayLineF(pos3.xz, id + i3.xz*s*.5, -n3.xz);\n        \n        t *= invN;\n \n        mint = min(min(t.x, t.y), t.z); \n        \n        #else\n        \n        // Square.\n        // Ray origin, ray direction, point on the line, normal. \n        t.x = rayLineF(pos3.xz, id + n1.xz*s*.5, -n1.xz);\n        t.y = rayLineF(pos3.xz, id + n2.xz*s*.5, -n2.xz);\n \n        t *= invN;\n        \n        mint = min(t.x, t.y);\n        \n        #endif\n        \n        // Top plane distance.\n        float tT = (ma - pos3.y)/(rd.y);\n        tT = tT<0. ? 1e8 : tT; \n     \n        // Top plane hit.\n        if(tT<mint){\n         \n            // Hit the top.\n            res = 0.;\n            break;\n        }  \n\n        // Top plane, early exit.\n        //if(pos3.y>60.){ dist = 1e8; break; }\n         \n      \n        pos3 += rd*mint; \n        \n        ip = gridID(pos3.xz + srd.xz*.001);\n    \n    }    \n \n    return res;\n}    \n  \n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better one than this somewhere. \nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    #ifdef REPROJECTION\n    // Initial hit point and distance.\n    vec3 resPos = vec3(0);\n    float resT = 1e8;\n    #endif\n\n    // Screen coordinates: The coordinates are already in one to one ratio form, so \n    // a simple translation and scaling is all that is necessary in this setting.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Experiment involving random jittering: Visually speaking, it's better in some \n    // ways and worse in others. There are always trade offs with cheaper effects.\n    //vec2 tm = fract(iTime*vec2(.01327, .02183));\n    //uv += (vec2(hash21(uv + tm.x), hash21(uv + tm.y)) - .5)/2./iResolution.y;\n    \n    \n    // Lens warping -- Needs to be performed camera side to work with\n    // temporal reprojection, but I've forgotten how... I'll look at one\n    // of Dr2's examples at some stage to see how it's done.\n    //uv *= 1. + dot(uv, uv)*.2;\n    \n \n    // Ray origin.\n    vec3 ro = vec3(0, 7, iTime*8.);\n    \n    \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(0, -.0, 1.);//vec3(0, -.25, iTime);  \n \n    \n\t// Sending the camera and \"look at\" vectors along the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n\n    vec3 fwd = normalize(lk - ro);    \n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    // Camera.\n    mat3 mCam = mat3(rgt, up, fwd);\n    \n    // Camera movement. Rotation, swivle, etc.\n    mCam *= rot(vec3(-path(ro.z).x/32., 0, 0)); // Camera roll.\n    //mCam *= rot(vec3(0, 0, iTime/4.)); // Camera pitch.\n    \n    // Unit direction ray.\n    vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n \n    // Directional light.\n    vec3 ld = normalize(vec3(.2, .7, .8)); \n    \n    \n    // Sky function, based on one of IQ's simple snippets. \t\n    float sun = clamp(dot(rd, ld), 0., 1.);\n    vec3 sky = mix(vec3(1, .75, .6), vec3(1, .75, .6).xzy, max(rd.y, 0.)*.5);\n    sky += .3*pow(sun, 4.);\n    \n    // Scene function, initially set to the sky.\n    vec3 col = sky;\n\n    // Raycasting.\n    vec4 res = raycast( ro, rd );\n    vec2 cellID = res.zw;\n    float ry = res.y;\n    float t = res.x;\n    \n    // If we've hit the scene geometry, render it.\n    if(t<1e8 - 1e-4){\n    \n    \n        // 3D surface postion.\n        vec3 pos = ro + rd*t;\n        float rnd = hash21(cellID + .04);\n        \n        // Local 2D cell face coordinates -- Centered at vec2(0).\n        vec2 lP = pos.xz - cellID;\n        \n        // Cell height.\n        float h = map(cellID);\n        \n        #ifdef REPROJECTION\n        // Only save the initial hit point and \n        // distance. Ignore other bounces.\n        resPos = pos;\n        resT = t;\n        #endif\n        \n       \n         \n        \n        #ifdef HEXAGON\n        const float aNum = 6.;\n        #else\n        const float aNum = 4.;\n        #endif\n         \n        \n        // Normal and texture UV coordinates. You should do this via face\n        // identification in your raycasting function, but I was curious\n        // to see if could be done this way. You can, but I wouldn't advise\n        // it. I'll update this with something easier to read later.\n        //\n        // Top facing.\n        vec3 nor = vec3(0, 1, 0);\n        vec2 tuv = pos.xz - hash21(cellID + .2 + h)*8.;// - vos;\n\n        if(abs(res.y)>.01){\n        \n           vec2 qq = lP; // Centered 2D cell face coordinates.\n           \n           #ifdef HEXAGON\n           qq *= rot2(-3.14159/aNum); \n           // Prism side angle matrix, relative to the center.\n           float aa = (floor(atan(qq.y, qq.x)/6.2831*aNum) + .5)/aNum;\n           mat2 mR = rot2(-aa*6.2831);\n           // Right plane, then rotate.\n           nor.xz = mR*vec2(1, 0);\n           nor.y = 0.;\n           \n            // UV coordinates.\n           // The X coordinate is the local XZ coordinates dotted with the \n           // face normal. There are other ways to do this, but that's the \n           // easist way. The Y coordinate is just the Y position.\n           tuv = vec2(dot((lP), nor.xz), pos.y);\n           // Adjusting the UV by the height and a random figure for some \n           // cell face texture variance. \n           tuv -= vec2(hash21(cellID + aa + .1), h);\n           \n           \n           // Rotating the normal back to the center.\n           nor.xz *= rot2(3.14159/aNum);\n           #else\n           \n           float aa;\n           if(dot(qq, s.yx)<0.) {\n               if(dot(qq, s.yx*vec2(1, -1))<0.){ nor = vec3(-1, 0, 0); aa = 0.; tuv.x = qq.y; }\n               else{ nor = vec3(0, 0, -1); aa = 1.; tuv.x = qq.x; }\n           }\n           else {\n               if(dot(qq, s.yx*vec2(1, -1))>0.){  nor = vec3(1, 0, 0); aa = 2.; tuv.x = qq.y; }\n               else{ nor = vec3(0, 0, 1); aa = 3.; tuv.x = qq.x; }\n           }\n           \n           tuv.y = pos.y;\n           \n           //tuv = vec2(dot((pos.xz - vos), nor.xz*rot2(3.14159/aNum)), pos.y);\n           tuv -= vec2(hash21(cellID + aa + .1), h);\n           #endif\n           \n           \n        }\n        \n        \n          \n\n        // Object color.\t\n        vec3 objCol = .5 + .45*sin(rnd*6.2831/6. + vec3(0, 1, 2)/3. + 2.);\n\n        // Applying some texture.\n        vec3 tx = texture(iChannel1, rot2(-3.14159/6.)*tuv/4. + h).xyz; tx *= tx;\n        vec3 tx2 = texture(iChannel1, rot2(3.14159/3.)*tuv/2. + .33).xyz; tx2 *= tx2;\n        tx = mix(tx, tx2, .5);\n        objCol *= .35 + tx*1.5;\n     \n        \n        // Very rough ambient occlusion. It's designed to give the feel of AO,\n        // but it won't be winning any awards, that's for sure. :)\n        float occ = 1.;//   + nor.y*.5; // Occlusion.\n        float ds = 1.; // Analogous to sample spread. // .01*t           \n        float k = .3;//.05/ds;  // Intensity.\n        float dst = ds*1.; // Initial distance.          \n\n        for(int i = 0; i<4; i++){\n            //vec2 oCoord = pos.xz + nor.xz*dst;\n            //vec2 ps = mix(oCoord, gridID(oCoord)*s, .5);\n             float hn = map(pos.xz + nor.xz*dst);\n             //float hn = map(mix(vos, pos.xz, .5) + nor.xz*dst);\n             //float hn = map(gridID(pos.xz + nor.xz*dst)*s);\n             occ -= (dst - max(pos.y + nor.y*dst  - hn, 0.))*k;//*smoothstep(-1., 1., h - hn);\n             dst += ds;\n             k *= .5;\n        }\n        \n        occ = clamp(occ, 0., 1.);\n       \n        // This is a left over line from IQ's cylinder traversal example that I\n        // forgot to take out until after the coloring was done, so it's here to stay. :)\n        // If you were to attribute some science to it, buildings would be more shadowy\n        // at ground level... Yeah, I'm not convinced either. :D\n        occ *= pow(clamp((pos.y + .01)/(h + .01), 0., 1.), 2.);\n        // Manipulating for whatever shade we're after. \n        occ = mix(occ, occ*occ, .5)*.8 + .2;\n     \n        // Lighting.\n \n  \n        // Diffuse lighting term.\n        float dif = max(dot(nor, ld), 0.);\n        \n        // Shadows.\n        //\n        // Old fashioned hard shadows. Not as nice as soft ones, but still appreciated. :) \n        // Actually, if you were path tracing, then soft shadows would be the result anyway.\n        // You could also blur these on a separate buffer then reintegrate.\n        float shad = 0.;\n        if(dif>0.){ shad = castShadowRay(pos + nor*1e-3, ld); }\n\n        \n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some silhouette lighting.\n        float rim = pow(clamp(1. + dot(rd, nor), 0., 1.), 5.);\n        \n         \n        // Specular reflection. \n        float spe = pow(clamp(dot(ld, reflect(rd, nor)), 0., 1.), 4.);\n        \n\n        // Putting the above terms together. \n        col = objCol*(dif*shad + .5 + vec3(2, .4, .3)*spe*shad + sky*rim*2.);\n \n        \n        col *= occ;\n        \n        \n         \n        \n        #ifdef HEXAGON\n        float shape = max(abs(lP.y)*.8660254 + abs(lP.x)*.5, abs(lP.x)) - s.x/2.;\n        #else\n        vec2 aLP = abs(lP) - s/2.;\n        float shape = max(aLP.x, aLP.y);\n        #endif\n        \n        // Top face edge height.\n        float edgeY = pos.y - h;\n        \n        // Shape edge.\n        float shapeEdge = abs(shape);\n        shapeEdge = abs(shapeEdge - edgeY) - .03;\n    \n       \n        #ifdef HEXAGON\n        // Hexagon vertical edges.\n        // Lines eminating from the center to the vertices.\n        vec2 p = rot2(3.14159/aNum)*lP; \n        float a = mod(atan(p.x, p.y), 6.2831)/6.2831;\n        a = (floor(a*aNum) + .5)/aNum;\n        p *= rot2(a*6.2831);\n        float edge = abs(p.x) - .02; \n        #else\n        vec2 p = lP;\n        // Square vertical edges. Much easier. :)\n        float edge = -min(abs(p.x) + .04 - s.x/2., abs(p.y) + .04 - s.y/2.);\n        #endif\n         \n        // Chop out the inside face lines... I'm making this up as\n        // I go along. I'll tidy it up later.  :) \n        edge = max(edge, -(shape + .02));\n\n      \n        // Combining the top face edge with the side edges.\n        edge = min(edge, shapeEdge);\n\n\n        // Cheap reflective pass. A full reflective pass would be nicer, but\n        // this is the next best thing. Trace out from the hit point along\n        // the direction ray. If we hit the scene, add nothing, but if we\n        // hit the sky, index into a sky-looking cube map. Not perfect, but\n        // any stretch, but it gives a pretty cool reflective pass glow.\n \n        vec3 refl = reflect(rd, nor);\n        float resRef = castShadowRay(pos + nor*2e-3, refl);\n        //t = resRef.x;\n\n        vec3 refTex = textureLod(iChannel2, refl, 0.).rgb; refTex *= refTex;\n    \n        //float rsun = clamp(dot(refl, ld), 0., 1.);\n        //vec3 rsky =  mix(vec3(1, .75, .6), vec3(1, .75, .6).xzy, max(rd.y, 0.)*.5);\n        //rsky = (rsky + .3*pow(rsun, 4.));\n        vec3 spec = resRef<.5? vec3(0) : refTex*4. ;\n\n        float fr = mix(.03, .25, pow(max(0., 1. + dot(rd, nor)), 3.));\n\n        col = mix(col, spec, fr);\n \n        // Occlusion debug.\n        //col = vec3(occ);\n         \n       \n      \n        // Applying edges at the end.\n        float sf = 3./450.*(1.35 + t*t*.005);\n        col = mix(col, col*1.8, (1. - smoothstep(0., sf, edge - .05))); \n        col = mix(col, col*.1, (1. - smoothstep(0., sf, edge))); \n    \n  \n\n        // Fogging out to the horizon..\n        col = mix( col, sky, smoothstep(0., 1., t*t/140./140.));\n        //col = mix(sky, col, exp(-t*t/120./120.)); // Alternative.\n         \n    }\n    \n    // Another one of IQ's touches that I like. Running a small portion of sunlight\n    // over the whole scene for a little extra scattering.\n    col += pow(sun, 8.)*.08;\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col = clamp(col, 0., 1.)*pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    \n\n\n    \n    // This is IQ's temporal reprojection code: It's well written and\n    // it makes sense. I wrote some 2D reprojection code and was not\n    // looking forward to writing the 3D version, and then this \n    // suddenly appeared on Shadertoy. If you're interested in rigid \n    // realtime path traced scenes with slowly moving cameras, this is \n    // much appreciated. :)\n    //\n    #ifdef REPROJECTION\n    //-----------------------------------------------\n\t// Reproject to previous frame and pull history.\n    //-----------------------------------------------\n    \n    float kFocLen = 1./FOV;\n    vec3 pos = resPos;\n    ivec2 q = ivec2(fragCoord);\n    col = clamp(col, 0., 1.);\n\n    // fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4(texelFetch(iChannel3, ivec2(0, 0), 0),\n                           texelFetch(iChannel3, ivec2(1, 0), 0),\n                           texelFetch(iChannel3, ivec2(2, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos*oldCam;\n    // Convert to NDC space (project).\n    vec2 npos = (kFocLen*2.)*cpos.xy/cpos.z;//*iRes/iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5*npos*vec2(iResolution.y/iResolution.x, 1);\n\t// Convert to raster space.\n    vec2 rpos = spos*iResolution.xy;\n\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = textureLod( iChannel3, spos, 0.);\n    // If we consider the data contains the history for this point.\n    if(iFrame>0 && resT<FAR && (rpos.y>1.5 ||rpos.x>3.5)){\n    \n        // Blend with history (it's an IIR low pas filter really).\n        col = mix( ocolt.xyz, col, 1./4.);\n    }\n    \n    // Color and depth.\n    fragColor = vec4(col, resT);\n    \n    // Output.\n\tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) fragColor = vec4(mCam[0], -dot(mCam[0], ro));\n        else if(q.x == 1) fragColor = vec4( mCam[1], -dot(mCam[1], ro));\n        else fragColor = vec4( mCam[2], -dot(mCam[2], ro));\n    } \n    #else\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    //vec4 preCol = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    //float blend = (iFrame < 2) ? 1. : 1./8.; \n    //fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    fragColor = vec4(max(col, 0.), 1);\n    #endif\n    \n     \n    //fragColor = vec4(max(col, 0.), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}