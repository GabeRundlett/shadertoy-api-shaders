{
    "Shader": {
        "info": {
            "date": "1581821630",
            "description": "Following along https://www.youtube.com/watch?v=rvDo9LvfoVE&feature=emb_title this week!",
            "flags": 0,
            "hasliked": 0,
            "id": "wtcXWX",
            "likes": 20,
            "name": "Art Of Code: Starfield! (SS7)",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "stars"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 1035
        },
        "renderpass": [
            {
                "code": "/*\n\tShader Sundays! (7/52) \n\t\"Starfield from Art of Code\"\n\t\n\tHad relatives visiting this week so couldn't spend too much time on this one. \n\tInstead I decided to follow along one of @Bigwings excellent shader tutorials and get \n\tsomething cool going in under an hour. This is basically a one for one version of his \n\tshader, except I added a cool nebula cloud that I repurposed from a previous shader.\n\tLots of details could be added to this to make it better, like random nebula variation,\n\tphysically accurate star color pattern and nicer star clustering. But alas, maybe for\n\tthe next star pattern. Cheers!\n\n\tPart1:\n\thttps://www.youtube.com/watch?v=rvDo9LvfoVE&feature=emb_title\n\n\tPart2:\n\thttps://www.youtube.com/watch?v=dhuigO4A7RY&feature=emb_title\n\t\n\tCheckout his patreon! \n\thttps://www.patreon.com/TheArtOfCode\n*/\n\nfloat\nmakeStar(vec2 uv, float flare)\n{\n    float d = length(uv);\n    float star = .06/d;\n    float m = star;\n\n\n    float rays = max(1.0 - abs(uv.x*uv.y * 1000.0), 0.0);\n    m +=rays * flare;\n\n    uv = rotate(uv, M_PI/ 4.0);\n        rays = max(1.0 - abs(uv.x*uv.y * 1000.0), 0.0);\n        m +=rays*flare *0.3;\n\n    m *= smoothstep(1.0, .2, d);\n\n    return m;\n}\n\nfloat\nhash21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec2 \nrandom2D(vec2 val){\n    val = vec2(dot(val, vec2(127.1, 311.7)),\n               dot(val, vec2(242.51, 184.2)));\n    \n    float scale = 182364.0;\n    return 1.0 -  2.0 * fract(sin(val) * scale);\n}\n\nfloat \nnoise(vec2 p){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor( p + (p.x + p.y) * K1);\n\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step(a.yx, a.xy);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\n    vec3 n = h*h*h*h*vec3(dot(a, random2D(i)), dot(b, random2D(i + o)), dot(c, random2D(i+1.0)));\n\n    return dot(n, vec3(100.0));\n}\nfloat \nsimplex(vec2 p, int octaves){\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\n    float f = 0.0;\n    float scale = 1.0;\n    for(int i = 0; i < octaves; i++){\n        scale /= 2.0;\n        f += scale*noise(p);\n        p *= m;\n    }\n\n    return 0.5 + 0.5*f;\n}\n\nvec3\nStarLayer(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv) - 0.5;\n\n    for(int y = -1; y <= 1; ++y)\n    for(int x = -1; x <= 1; ++x)\n    {\n        vec2 offset = vec2(x, y);\n        float n = hash21(id + offset);\n        float size = fract(n*345.45);\n\n        float star = makeStar(gv - offset - vec2(n, fract(n*34.0) ) + .5, smoothstep(.9, 1.0, size)* 0.6);\n        vec3 color = sin(vec3(1.2, .3, .2)*fract(n*2345.2) * 123.2)*.5 + 0.5;\n        color = color * vec3(1.0, 0.25, 1.0 + size);\n        star *= sin(iTime*3.0 + n*M_TAU)*.5 +1.;\n        col += star*size*color;\n    }\n\n    return col;\n}\n\nvec3\ngas_halo_outer(vec2 uv, float size, int density)\n{\n    float halo_mask = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 color =  vec3(0.1, 0.3, 1.8);\n    for(int i = 0; i < density; ++i){\n        float offset = hash21(vec2(i));\n        float r = size + (size / 2.0f) * cos(atan(uv.y + offset * 0.2f, uv.x)* (3.0 ) + radians(offset * 360.0f));\n        halo_mask = smoothstep(r, r + 0.35f, length(uv));\n        col += color * (1.0 - halo_mask - simplex(uv, 5)) *  1.0f / float(density);\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\n#define NUM_LAYERS 8.0\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPosition)\n{\n    vec2 uv  = ((fragPosition) - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float t = iTime*.04;\n    \n    for(float i = 0.0;i < 1.0; i += 1.0/NUM_LAYERS)\n    {\n        float depth = fract(i +t);\n\n        float scale = mix(20.0, 0.5, depth);\n\n        float fade = depth*smoothstep(1., .9, depth);\n\n        float size = 1.6;\n\n        col += StarLayer(uv*scale + i*453.2)*fade;\n        scale = mix(10.0, 0.5, fract(i + 1.0*t));\n        col += gas_halo_outer(uv*scale + i*400.2, size, 10)*fade;\n    }\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tJust a bunch of common variables/functions that I use in most of my shaders\n\tProbably very few of these got used in this shader, but it's easier to just include\n\tthe whole thing.\n*/\n\n#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}