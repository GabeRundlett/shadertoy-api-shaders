{
    "Shader": {
        "info": {
            "date": "1586732660",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "wdSyWw",
            "likes": 19,
            "name": "Day 115",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 glow = vec3(0);\n\n\n\nfloat minRadius2 = 0.9;\nfloat fixedRadius2 = 5.7 ;\nfloat foldingLimit = 1.3;\n\nint Iterations = 7;\nfloat Scale = 2.;\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\n\n#define pmod(p,j) mod(p,j) - 0.5*j\n\nfloat map(vec3 z, float t){\n\tfloat d = 10e7;\n\tvec3 p = z;\n    z.z = pmod(z.z, 10.);\n    \n    \n    for(int i = 0; i < 4;i ++){\n    \tz = abs(z);\n        \n        z.xy *= rot(0.125*pi);\n        //z.t -= 0.2;\n        //z.z -= 0.3;\n    }\n    \n    \n    vec3 q = vec3(z);\n    \n    vec3 j;\n    float jdr;\n    \n\tvec3 offset = z;\n\tfloat dr = 1.;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\tsphereFold(z,dr);    // Sphere Inversion\n        \n        if(n == 2){\n            j = z;\n            jdr = dr;\n        }\n \t\t\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n    \n    \n    //z = abs(z);\n    //z.y -= 10.4;\n    \n\tfloat r = length(z);\n    \n    \n    \n    d = r/abs(dr);\n    \n    d *= 0.7;\n    \n    d += smoothstep(1.,0.,t*0.75)*0.15;\n    \n    float db = length(j)/abs(jdr);;\n    \n    glow += 0.5/(0.6 + pow( (abs(d) + 0.001)*0.7,2.)*800000.)*0.9;\n    \n    db += 0.001;\n    \n    \n    float att = pow(abs(sin(p.z + iTime + length(p.xy))),50.);\n    glow -= 0.92/(0.04 + pow( (abs(db) + 0.001)*0.7,2.)*16000.)*vec3(0.5,0.9,1.4)*att;\n    \n    \n    \n    d = min(d, db);\n        \n    //d *= 0.7;\n    d = abs(d) + 0.001;\n    \n    //glow -= 0.01/(0.1 + d*d*10.)*vec3(0.7,0.4,0.8);\n    //glow += 0.12/(0.001 + d*d*4000.);\n    \n    \n    return d;\n    \n    \n    //float da = length(z.xyz)/q.w - 0.01;\n    \n        \n    \n    float sc = 0.5;\n    //d = min(d,da);\n    d *= sc;\n    d += smoothstep(1.,0.,t*.5)*0.7;\n    d = abs(d) + 0.003;\n    \n    vec3 c = vec3(1,1.,1.);\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0.,1.,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    vec3 col = vec3(0.9,0.6,0.4);\n\n    vec3 ro = vec3(0);\n    ro.z += iTime;\n    \n    //ro.xz -= 4.6;\n    \n    float T = iTime*1./tau + pi*0.25;\n    ro.xy += vec2(cos(T), sin(T))*0.7;\n    \n    vec3 lookAt = vec3(0.001);\n    \n    lookAt.z = ro.z + 4.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float d;\n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    for(int i = 0; i < 120; i++){\n    \td = map(p, t);\n        if(d < 0.001){\n        \thit = true;\n            //break;\n        }\n\t\tt += d;\n    \tp = ro + rd*t;\n    }\n    \n    \n    col -= glow*0.07;\n    \n    col = max(col, 0.);\n    \n    col = pow(col, vec3(1. + dot(uv,uv)*1.));\n    \n    //col = smoothstep(0.,1.,col);\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}