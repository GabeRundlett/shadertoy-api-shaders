{
    "Shader": {
        "info": {
            "date": "1548781171",
            "description": "Each dance is unique! :) This was going to be part of a bigger shader, but I figured it works well on its own too.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBGDh",
            "likes": 60,
            "name": "Dancing icons",
            "published": 3,
            "tags": [
                "dancing",
                "dance",
                "dancer"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 5724
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n#define saturate(a) clamp(a, 0.0, 1.0)  // Clamp [0..1] range\n\n// Got this line drawing function from https://www.shadertoy.com/view/4tc3DX\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    // Don't let it get more round than circular.\n    //thick = vec2(0.005, 0.005);\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    return dist;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\nfloat Wobble(float a, float seed) {\n    //seed = floor(seed) * 3.14159 * 0.5;\n    a += seed;\n    return sin(a) + sin(a * 2.0)*0.5 + sin(a * 4.0)*0.25;\n}\n\n// makes a dancer in the 0..1 uv space. Seed is which dancer to draw.\nfloat Dancer(vec2 uv, vec2 seed)\n{\n    float time = iTime*4.0;\n\n    float legLen = 0.18;\n    float armLen = 0.15;\n\n    // Define joint positions\n    vec2 hipA = vec2(0.57,0.33);\n    vec2 kneeA = vec2(0.65 + Wobble(time, seed.x*7.6543)*0.1, 0.2);\n    vec2 footA = vec2(0.6 + Wobble(time, seed.x*237.6543)*0.1, 0.0);\n    // Constrain joints to be a fixed length\n    kneeA = normalize(kneeA - hipA) * legLen + hipA;\n    footA = normalize(footA - kneeA) * legLen + kneeA;\n\n    vec2 hipB = vec2(0.43,0.33);\n    vec2 kneeB = vec2(0.35 + Wobble(time, seed.x*437.6543)*0.1, 0.2);\n    vec2 footB = vec2(0.4 + Wobble(time, seed.x*383.6543)*0.1, 0.0);\n    kneeB = normalize(kneeB - hipB) * legLen + hipB;\n    footB = normalize(footB - kneeB) * legLen + kneeB;\n\n    vec2 shoulderA = vec2(0.62, 0.67);\n    vec2 elbowA = vec2(0.8, 0.43 + Wobble(time, seed.x*7.6543)*0.3);\n    vec2 handA = elbowA + vec2(.14, 0.0 + Wobble(time, seed.x*73.6543)*0.5);\n    elbowA = normalize(elbowA - shoulderA) * armLen + shoulderA;\n    handA = normalize(handA - elbowA) * armLen + elbowA;\n\n    vec2 shoulderB = vec2(0.38, 0.67);\n    vec2 elbowB = vec2(0.2, 0.43 + Wobble(time, seed.x*17.6543)*0.3);\n    vec2 handB = elbowB + vec2(-0.14, 0.0 + Wobble(time, seed.x*173.6543)*0.5);\n    elbowB = normalize(elbowB - shoulderB) * armLen + shoulderB;\n    handB = normalize(handB - elbowB) * armLen + elbowB;\n\n    vec2 headPos = vec2(0.5 + Wobble(time, seed.x*573.6543)*0.03, 0.83 + sin(time*2.0)* 0.01);\n\n    // Find an approximate center of mass on the x axis\n    float balance = (kneeA.x + kneeB.x + footA.x + footB.x +\n                    elbowA.x + elbowB.x + handA.x + handB.x +\n                    headPos.x * 1.0) - (0.5*9.0);\n\n    // Make the dancer stick to the ground even when they lift their legs.\n    float ground = min(footA.y, footB.y);\n    uv.y += ground - 0.025;\n    // Make them counter-balance based on approximate center of mass\n    uv.x += balance*0.1;\n\n    // Torso\n    float l = max(0.0, FillLine(uv, vec2(0.5,0.45), vec2(0.5,0.6), vec2(0.12,0.12), 0.0));\n\n    // Legs\n    l = min(l, FillLine(uv, kneeA, hipA, vec2(0.05,0.05), 1.0));\n    l = min(l, FillLine(uv, kneeA, footA, vec2(0.05,0.05), 1.0));\n    l = min(l, FillLine(uv, kneeB, hipB, vec2(0.05,0.05), 1.0));\n    l = min(l, FillLine(uv, kneeB, footB, vec2(0.05,0.05), 1.0));\n\n    // Arms\n    l = min(l, FillLine(uv, elbowA, shoulderA, vec2(0.05,0.05), 1.0));\n    l = min(l, FillLine(uv, elbowA, handA, vec2(0.05,0.05), 1.0));\n    l = min(l, FillLine(uv, elbowB, shoulderB, vec2(0.05,0.05), 1.0));\n    l = min(l, FillLine(uv, elbowB, handB, vec2(0.05,0.05), 1.0));\n\n    // Head\n    l = min(l, FillLine(uv, headPos, headPos, vec2(0.1,0.1), 1.0));\n\n    // Optional skirt\n    if (fract(seed.x*123.4567) > 0.5) {\n        l = min(l, FillLine(uv, vec2(0.5, 0.55), vec2(0.65, 0.33), vec2(0.05,0.05), 1.0));\n        l = min(l, FillLine(uv, vec2(0.5, 0.55), vec2(0.35, 0.33), vec2(0.05,0.05), 1.0));\n        l = min(l, FillLine(uv, vec2(0.35, 0.33), vec2(0.65, 0.33), vec2(0.05,0.05), 1.0));\n    }\n\n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.x += iTime * 0.05;\t// scroll left with time\n\n\t// make a grid for drawing.\n\tuv *= 3.0;// * (sign(iMouse.z) + 2.0);\n\tuv.y *= 0.8;\n    uv.y += 0.3;\n\tvec2 newSeed = floor(uv);\n\n    // Make those dancing people!\n\tfloat finalLine = Dancer(fract(uv), newSeed-0.41);\n    finalLine *= mod(newSeed.y, 2.0);  // the mod kills every other line.\n\n    float lseed = length(newSeed);\n    vec3 backColor = vec3(sin(lseed), cos(lseed*918.7654), sin(lseed * 3.4567))*0.5+0.5;\n    backColor = normalize(max(backColor, vec3(0.1,0.1,0.1)));\n    vec3 finalColor = backColor * finalLine;\n\n\tfragColor = vec4(sqrt(finalColor),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}