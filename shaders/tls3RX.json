{
    "Shader": {
        "info": {
            "date": "1557170078",
            "description": "Martian grass fields at noon, v2.\nAdded lens dirt, stars, sun light pulse and a falling meteor.",
            "flags": 0,
            "hasliked": 0,
            "id": "tls3RX",
            "likes": 21,
            "name": "Grassfield on Mars",
            "published": 3,
            "tags": [
                "grass",
                "animation"
            ],
            "usePreview": 0,
            "username": "sergei_am",
            "viewed": 1027
        },
        "renderpass": [
            {
                "code": "const float GRASS_BLADE_HEIGHT = 7.35;\nconst float GRASS_BLADE_HALFWIDTH = 0.35;\n\nconst vec3  GRASS_COLOR_1 = vec3(1.0,0.45,0.0);\nconst vec3  GRASS_COLOR_2 = vec3(0.7,0.6,0.5);\nconst vec3  CLEAR_SKY_COLOR = vec3(0.1, 0.2, 0.6);\nconst vec3  FOG_COLOR = vec3(0.4, 0.7, 1.0);\nconst vec3  SUN_COLOR = vec3(1.0,1.0,3.0);\n\nconst vec3\tSUN_DIRECTION = normalize(vec3(-0.4,0.2,0.0));\nconst float SUN_DISC_SIZE = 0.04;\n\nconst float CAMERA_HEIGHT = 18.5;\n\nconst float CAMERA_PITCH_1 = -0.2;\nconst float CAMERA_PITCH_2 = 0.2;\n\nconst float CAMERA_YAW = 0.0; //4.4;\nconst float CAMERA_PITCH = -0.4;\n\nconst float CAMERA_SPEED = 0.25;\n\nconst float\tGRASS_FIELD_STEP = 0.3;\n\nconst bool\tANTI_ALIASING_4X = false;\n\n\n\n\nstruct CAMERA_RAY\n{\n    vec3 eye, ray, right, up;\n};\n\nfloat freq(float K)\n{\n    return K / 0.4;\n}\n\nfloat noise_func( vec2 xy )\n{\n    float x = xy.x;\n    float y = xy.y;\n    float rx = x + sin(y/43.0)*43.0;\n    float ry = y + sin(x/37.0)*37.0;\n    \n    float f = sin(rx/11.2312) + sin(ry/14.4235);\n    \n    f = f*0.5 + sin(rx/24.0) * sin(ry/24.0);\n    \n    rx += sin(y/210.23)*210.23;\n    ry += sin(x/270.0)*270.0;\n    \n    f = f*0.5 + sin(rx/65.0) * sin(ry/65.0);\n    f = f*0.5 + sin(rx/165.0) * sin(ry/165.0);\n    \n    return f / 1.0;\n}\n\n\nfloat wind_power( float x )\n{\n    float w = sin(x/freq(5.0)) + sin(x/freq(13.0));\n    w *= 1.2;\n    \n    float bigw = sin(x/freq(35.0)) + sin(x/freq(33.0));\n    \n    bigw = bigw*0.25 + 0.5;\n    bigw *= bigw;\n  \n    w += bigw*3.0;\n\n    \n    float hf = sin(x/freq(0.65))*0.2;\n    float lowf = sin(x/freq(17.0));\n    \n    lowf = max( lowf, 0.0 );\n    \n    w = lowf * (hf - lowf*0.6) + w;\n    \n    return w;\n}\n\n\nvoid generate_grass_blade_at_position( in CAMERA_RAY cam, in vec3 pos, out vec3 v0, out vec3 v1, out vec3 v2, out vec3 color )\n{\n    vec3 eye = cam.eye;\n    vec3 ray = cam.ray;\n    \n    vec3\tcenter\t= vec3(floor(pos.x), 0, floor(pos.z));\n    float\tnoise_angle\t= fract( center.x/4.5678234 * center.z/3.1415 );\n    \n    vec3 right = normalize( cross( normalize(pos - eye), vec3(0,1,0) ) );\n    \n\tfloat noise = max( (sin(center.x/34.0) * cos(center.z/34.0)*0.5 + (sin(center.x/13.0) * cos(center.z/13.0))*0.4) / 1.5, 0.0 );\n    \n    center.x += cos(noise_angle*8.5)*GRASS_BLADE_HALFWIDTH*2.0;\n    center.z += sin(noise_angle*8.5)*GRASS_BLADE_HALFWIDTH*2.0;\n    \n    \n    v0 = center + cam.right * GRASS_BLADE_HALFWIDTH;\n    v1 = center - cam.right * GRASS_BLADE_HALFWIDTH;\n    v2 = center + vec3(0,GRASS_BLADE_HEIGHT*(0.8 + 0.2*noise),0);\n    \n    float wind_pow = wind_power( sin(center.x/10.0)* sin(center.z/10.0)*19.0 + iTime*40.0 ) * 1.3;\n    \n    v2.x -= wind_pow;\n    \n    float noise2 = max( sin(center.x/7.31) + sin(center.z/14.02), 0.0);\n    \n    float n3 = noise_func( center.xz*5.0 );\n    \n    float xt = center.x - iTime*40.0;\n    float clouds = sin(xt/50.0)*sin(center.z/50.0) + sin(xt/87.0) * sin(center.z/87.0);\n    \n    clouds = clamp( clouds, 0.0, 1.0 );\n    \n    color = mix( GRASS_COLOR_1, GRASS_COLOR_2, clamp(n3,0.0,1.0) );\n    \n    color *= 1.0 - 0.5*clouds;\n}\n\nbool intersect_triangle( in CAMERA_RAY cam, in vec3 v0, in vec3 v1, in vec3 v2, out vec3 P )\n{\n    const float EPSILON = 0.0000001;\n    \n    vec3 edge1, edge2, h, s, q;\n    float a,f,u,v;\n    edge1 = v1 - v0;\n    edge2 = v2 - v0;\n    h = cross( cam.ray, edge2 );\n    a = dot( edge1, h );\n    if (a > -EPSILON && a < EPSILON)\n        return false;\n    f = 1.0 / a;\n    s = cam.eye - v0;\n    u = f * dot( s, h );\n    if (u < 0.0 || u > 1.0)\n        return false;\n    q = cross( s, edge1 );\n    v = f * dot( cam.ray, q );\n    if (v < 0.0 || u + v > 1.0)\n        return false;\n    float t = f * dot( edge2, q );\n    if (t > EPSILON)\n    {\n        P  = cam.eye + cam.ray * t;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool intersect_sphere( in vec3 ray, in vec3 center, in float R, out float T )\n{\n    float B = dot(center,ray);\n    float det = B*B - dot(center,center) + R * R;\n    if( det < 0.0 ) return false;\n    \n    T = dot(ray, center) - sqrt(det);\n    return T > 0.0;\n}\n\nvec3 sky_color( in CAMERA_RAY cam )\n{\n    vec3 ray = cam.ray;\n    \n    // sky color, brighter on the horizon\n    \n    float horizon = ray.y;\n    horizon = 1.0 - horizon;\n    horizon *= horizon;\n    horizon *= horizon;\n    horizon = 1.0 - horizon;    \n\n    float space = ray.y;\n    space *= space;\n   \tspace = 1.0 - space*0.5;\n    \n    ray = normalize( ray );\n    \n    vec3 clear_sky = CLEAR_SKY_COLOR;\n    vec3 horizon_sky = FOG_COLOR;\n    \n    vec3 sky = mix( vec3(0,0,0), mix( horizon_sky, clear_sky, horizon ), space);\n    \n    // pulsing sun light\n    \n    float view_dot_sun = max( dot(ray, SUN_DIRECTION), 0.0 );\n    float sun_pulse = 0.4 * abs( sin(view_dot_sun*200.0 + iTime*2.0));\n    float view_dot_sun_mask = pow( view_dot_sun, 64.0 );\n    \n    sky += SUN_COLOR * (view_dot_sun_mask + sun_pulse * 0.2 * min( view_dot_sun_mask, 1.0) );\n    \n    float empty_space = 1.0;\n    \n    // big white moon\n    \n    float TI;\n    vec3 moon = vec3(0.6,0.1,-1.5);\n    if( intersect_sphere( ray, moon, 0.4, TI ))\n    {\n        vec3 pos = ray*TI;\n        vec3 N = normalize(pos - moon);\n        \n        sky += max( dot(N,SUN_DIRECTION), 0.0) * (0.3 + 0.05*noise_func( N.yz/0.00007 )) * vec3(0.5,0.5,0.5);\n        \n        empty_space = 0.0;\n    }\n    \n    // smaller red moon\n    \n    moon = vec3(-1.4,0.3,1.5);\n    if( intersect_sphere( ray, moon, 0.3, TI ))\n    {\n        vec3 pos = ray*TI;\n        vec3 N = normalize(pos - moon);\n        \n        sky += max( dot(N,SUN_DIRECTION), 0.0) * (0.5 + 0.2*noise_func( N.yz/0.001 )) * vec3(1.5,0.3,0.3);\n        \n        empty_space = 0.0;\n    }\n    \n    // falling meteor\n    \n    float meteor_anim = fract( iTime*80.0 / 1300.0 ) * 1300.0 - 800.0;\n    \n    vec3 out_p;\n    vec3 fs_orig = vec3(2000.0,300.0 - meteor_anim,meteor_anim);\n    if(intersect_triangle(cam, fs_orig, fs_orig - vec3(0.0,5.0,5.0), fs_orig - vec3(0.0,-200.0,200.0), out_p))\n    {\n        sky += vec3(0.3,0.4,0.1);\n    }\n    \n    // stars in the sky, blocked by the moons\n    \n    vec2 sky_coord = vec2( atan(ray.x, ray.z), ray.y );\n    float starfield = texture( iChannel1, sky_coord*1.6 ).x;\n    vec3 star_color = texture( iChannel2, sky_coord ).xyz;\n    \n    starfield = pow( starfield, 32.0 );\n    star_color *= starfield;\n    star_color *= empty_space;\n    star_color *= 4.0;\n    star_color *= max( 1.0 - max( view_dot_sun, 0.0)*1.2, 0.0 );\n    \n    sky += star_color;\n    \n    return sky;\n}\n\nvec3 post_process( in vec3 ray, in vec2 screen_uv, in vec3 color )\n{\n\tvec3 t = texture( iChannel0, screen_uv ).xyz;\n    \n    // camera lens dirt\n    \n    float dirt = pow( t.x, 9.0 );\n    vec3 dirt_mask = vec3(dirt, dirt, dirt);\n\n    float view_dot_sun = max( dot(ray, SUN_DIRECTION), 0.0 );\n    \n    //dirt_mask *= pow( max(1.0 - view_dot_sun, 0.0), 1.0);\n    dirt_mask *= min( view_dot_sun * 0.1, 1.0 );\n    dirt_mask *= 17.0;\n    \n    color += dirt_mask;\n\n    return color;\n}\n\nvec3 ground_color(vec3 eye, vec3 ray)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nbool test_grass_blade(in CAMERA_RAY cam, in vec3 pos, out vec3 color)\n{\n    vec3 v0, v1, v2;\n\tgenerate_grass_blade_at_position( cam, pos, v0, v1, v2, color );\n    \n    vec3 P;\n    if( intersect_triangle( cam, v0, v1, v2, P ))\n    {\n        color *= 0.0 + P.y / v2.y;\n        return true;\n    }\n    return false;\n}\n\nvec3 trace_ray( in CAMERA_RAY cam, in vec2 screen_uv )\n{\n    vec3 color;\n    \n    if( cam.ray.y > 0.0 )\n    {\n        color = sky_color(cam);\n    }\n    else\n    {\n        vec3 pos = cam.eye;\n\n        if( pos.y > GRASS_BLADE_HEIGHT )\n        {\n            pos += cam.ray*(pos.y - GRASS_BLADE_HEIGHT) / -cam.ray.y;\n        }\n\n        vec3 ray_step = cam.ray / -cam.ray.y * GRASS_FIELD_STEP;\n\n        vec3 right = cam.right;\n\n        vec3 final_color = vec3(0.0, 0.0, 0.0);\n        int intersections = 0;\n        float coverage = 0.0;\n\n        for( int i=0; i<100 && intersections < 2; ++i )\n        {\n            for( float k=-2.0; k<=2.1; k += 1.0 )\n            {\n                if( test_grass_blade( cam, pos + right*k, color ))\n                {\n                    float dist_coverage_coef = 1.0 - min( length(pos - cam.eye) / 40.0, 1.0 )*0.7;\n\n                    final_color += color; //*(1.0 - coverage)*dist_coverage_coef;\n                    coverage = 1.0;\n\n                    coverage += (1.0 - coverage)*0.9 *dist_coverage_coef;\n                    intersections++;\n                    break;\n                }\n            }\n\n            if( pos.y < 0.0 ) break;\n            pos += ray_step;        \n        }\n\n        if(intersections>0)\n        {\n            final_color *= 1.0/float(intersections);\n        }\n\n        final_color += ground_color(cam.eye, cam.ray )*(1.0 - coverage);\n\n        // apply some fog\n        float fog_coef = 1.0 - exp( -length(cam.eye - pos) * 0.002);\n        final_color = mix( final_color, FOG_COLOR, fog_coef );\n    \n    \tcolor = final_color;\n    }\n    return post_process( cam.ray, screen_uv, color );\n}\n\nvec3 rotate_around_y( in vec3 v, float angle )\n{\n    float s = sin(angle), c = cos(angle);\n    return vec3( v.x*c - v.z*s, v.y, v.x*s + v.z*c );\n}\n\nvec3 rotate_around_x( in vec3 v, float angle )\n{\n    float s = sin(angle), c = cos(angle);\n    return vec3( v.x, v.y*c - v.z*s, v.y*s + v.z*c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera position and direction movement\n    CAMERA_RAY cam;\n    cam.ray = normalize( vec3( fragCoord/iResolution.yy - 0.5, 1.0 ));\n    \n    if(CAMERA_YAW > 0.0)\n    {\n        cam.ray = rotate_around_x( cam.ray, CAMERA_PITCH );\n        cam.ray = rotate_around_y( cam.ray, CAMERA_YAW );\n        cam.eye = vec3(0.0, CAMERA_HEIGHT, 0.0);\n    }\n    else\n    {\n\t    cam.ray = rotate_around_x( cam.ray, mix(CAMERA_PITCH_1, CAMERA_PITCH_2, 0.5+0.5*sin(iTime * CAMERA_SPEED * 2.0)) );\n\t    cam.ray = rotate_around_y( cam.ray, iTime * CAMERA_SPEED );\n\t\tcam.eye = vec3( 20.0*sin(5.0*iTime * CAMERA_SPEED), CAMERA_HEIGHT, 20.0*sin(4.0*iTime * CAMERA_SPEED));  // 5:4 Lissajous\n    }\n    \n\t\n\tcam.right = normalize(cross(cam.ray, vec3(0,1,0)));\n    cam.up = normalize(cross(cam.ray, cam.right));\n    \n    vec2 screen_uv = fragCoord / iResolution.xy;\n\n    vec3 color = trace_ray( cam, screen_uv );\n    \n    if(ANTI_ALIASING_4X)\n    {\n        vec3 eye = cam.eye;\n        cam.eye += eye  + cam.right * (1.5/iResolution.y);\n\t    color += trace_ray( cam, screen_uv );\n        cam.eye = eye  - cam.right * (1.5/iResolution.x);\n\t    color += trace_ray( cam, screen_uv );\n        cam.eye = eye  + cam.up * (1.5/iResolution.x);\n\t    color += trace_ray( cam, screen_uv );\n\t    color *= 0.25;\n    }\n    \n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}