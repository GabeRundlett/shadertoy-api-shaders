{
    "Shader": {
        "info": {
            "date": "1513626046",
            "description": "A learning experience in raytracing. Unfinished, but it's good enough for having a feel for the algorithm now. Glad with the result. ToDo: swap blinn/phong with PBR, CSG, FXAA. Rays: 1x shadow, 3x reflection, 4x refraction. Lights: 2x point. Mouse control",
            "flags": 0,
            "hasliked": 0,
            "id": "MtlBDj",
            "likes": 8,
            "name": "BeamRacer",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "study",
                "fresnel",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "MacSlow",
            "viewed": 2087
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// BeamRacer - a basic raytracer for learning the fundamentals\n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Ray {\n\tvec3 ro; // ray origin\n    vec3 rd; // ray direction\n};\n\nstruct Result {\n    bool  hit;    // did a ray hit anything?\n    vec3  point;  // where did it hit in world-space\n    vec3  normal; // surface-normal at the hit-point\n    float dist;   // distance from ro to hit-point\n    int   id;     // material-id at that hit-point\n};\n\nstruct Light {\n    vec3 position; // self-explanatory\n\tvec3 ambient;  // kind of a hack\n    vec3 diffuse;  // the light's color\n    vec3 specular; // kind of a hack\n    float attenuation; // attenuation factor\n};\n\nstruct Material {\n    // PBR part\n    vec3  albedo;    // base-color\n    float metallic;  // .0 dielectric, 1. metal\n    float roughness; // .0 .. 1. polished to rough/dull\n\n    // Blinn/Phong part\n    vec3  ambient;     // fake GI-term\n    vec3  diffuse;     // base-color\n    vec3  specular;    // color of specular highlight under white light\n    float shininess;   // \"hardness\" of surface\n    vec3  emissive;    // light emitted?\n    bool  doesReflect; // flag indicating if surface reflects\n    float reflAmount;  // factor for reflection influence\n    bool  doesRefract; // flag indicating if surface refracts\n    float ior;         // index of refraction\n};\n\nfloat saturate (in float v) {return clamp (v, .0, 1.);}\nmat2 r2d (in float a) { float c = cos(a); float s = sin (a); return mat2 (vec2 (c, s), vec2 (-s, c));}\nconst float PI = 3.14159265359;\nconst Result nullResult = Result (false, vec3 (.0), vec3 (.0), .0, 0);\n\nResult minResult (in Result a, in Result b) {\n    if (!a.hit)\n        return b;\n\n    if (!b.hit)\n        return a;\n\n    bool favourA = a.dist <= b.dist;\n    return  Result (true,\n                    favourA ? a.point : b.point,\n                    favourA ? a.normal : b.normal,\n                    favourA ? a.dist : b.dist,\n                    favourA ? a.id : b.id);\n}\n\nResult sphereIntersect (in Ray ray, in vec3 p, in float r, in int id) {\n    Result res = nullResult;\n\n    float a = dot (ray.rd, ray.rd);\n\n    // exit early, if denominator would almost be zero \n    if (a <= 1e-6) {\n        return res;\n    }\n\n    // set up coefficients a, b and c\n    float b = dot (2. * ray.rd, ray.ro - p);\n    vec3 op = ray.ro - p;\n    float c = dot (op, op) - r * r;\n    float d = sqrt (b * b - 4. * a * c);\n    float twoA = 1. / 2.*a;\n\n    // compute possible values for t\n    float t1 = (-b + d) * twoA;\n    float t2 = (-b - d) * twoA;\n\n    // this case should not be possible \n    if (t1 <= .0 && t2 <= .0) {\n\t\treturn res;\n    }\n\n    if (t1 > .0 && t2 > .0) {\n        if (t1 < t2) {\n            vec3 i1 = ray.ro + t1 * ray.rd;\n            float d1 = distance (i1, ray.ro);\n            res.hit = true;\n            res.point = i1;\n            res.normal = normalize (i1 - p);\n            res.dist = d1;\n            res.id = id;\n        } else {\n            vec3 i2 = ray.ro + t2 * ray.rd;\n            float d2 = distance (i2, ray.ro);\n            res.hit = true;\n            res.point = i2;\n            res.normal = normalize (i2 - p);\n            res.dist = d2;\n            res.id = id;\n        }\n    }\n\n    return res;\n}\n\nResult planeIntersect (in Ray ray, in vec3 p, in vec3 n, in int id) {\n    Result res = nullResult;\n\n\t// are ray and plane parallel?\n    if (dot (n, ray.rd) > 1e-6) {\n        return res;\n    }\n\n    // determine ray-plane intersection point\n    vec3 i = ray.ro + (dot(p - ray.ro, n) / dot (ray.rd, n)) * ray.rd;\n\n\n    // prepare result\n    res.hit = true;\n    res.point = i;\n    res.normal = normalize (n);\n    res.dist = distance (i, ray.ro);\n    res.id = id;\n\n    return res;\n}\n\nResult cylinderIntersect(in Ray ray, in vec3 p, in vec3 n, in float h , in float r, in int id){\n    Result res = nullResult;\n\treturn res;\n}\n\nRay cameraRay (in vec2 uv, in vec3 ro, in vec3 lookAt, in float zoom) {\n\tRay ray = Ray (vec3 (.0), vec3 (.0));\n\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 forward = normalize (lookAt - ro);\n    vec3 right = normalize (cross (worldUp, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + zoom * forward;\n    vec3 i = camCenter + uv.x * right + uv.y * up;\n    vec3 rd = normalize (i - ro);\n\n    ray.ro = ro;\n    ray.rd = rd;\n\n\treturn ray;\n}\n\nResult trace (in Ray ray) {\n    Result ball1 = sphereIntersect (ray,\n                                    vec3 (-2., -1.4*(cos(iTime)*.5+.5), -.5), // center of sphere\n                                    .6,                   // radius of sphere\n                                    3);                   // material-id\n    Result ball2 = sphereIntersect (ray,\n                                    vec3 (1., -1.5*(cos(1.+iTime)*.5+.5), .5),  // center of sphere\n                                    .5,                   // radius of sphere\n                                    3);                   // material-id\n    Result ball3 = sphereIntersect (ray,\n                                    vec3 (.0, -1.6*(cos(2.+iTime)*.5+.5), 1.5),  // center of sphere\n                                    .4,                   // radius of sphere\n                                    3);                   // material-id\n\n    Result plane1 = planeIntersect (ray,\n                                    vec3 (.0, -2., .0),   // point on plane\n                                    vec3 (.0, 1., .0),    // normal of plane\n                                    1);                   // material-id\n    Result plane2 = planeIntersect (ray,\n                                    vec3 (.0, .0, 4.),    // point on plane\n                                    vec3 (.0, .0, -1.),   // normal of plane\n                                    2);                   // material-id\n    Result plane3 = planeIntersect (ray,\n                                    vec3 (-6.0, .0, 0.),  // point on plane\n                                    vec3 (1., .0, 0.),    // normal of plane\n                                    0);                   // material-id\n    Result plane4 = planeIntersect (ray,\n                                    vec3 (6.0, .0, 0.),   // point on plane\n                                    vec3 (-1., .0, 0.),   // normal of plane\n                                    0);                   // material-id\n    Result plane5 = planeIntersect (ray,\n                                    vec3 (.0, 2.0, 0.),   // point on plane\n                                    vec3 (.0, -1.0, 0.),  // normal of plane\n                                    1);                   // material-id\n    Result plane6 = planeIntersect (ray,\n                                    vec3 (.0, .0, -4.),   // point on plane\n                                    vec3 (.0, .0, 1.),    // normal of plane\n                                    2);                   // material-id\n\n    Result res = minResult (plane1, plane2);\n\tres = minResult (plane3, res);\n\tres = minResult (plane4, res);\n\tres = minResult (plane5, res);\n\tres = minResult (plane6, res);\n\n    res = minResult (ball1, res);\n    res = minResult (ball2, res);\n\tres = minResult (ball3, res);\n\n    return res;\n}\n\nLight light[2] = Light[2] (Light (vec3 (1., .5, -1.), // position\n                                  vec3 (.1),          // ambient\n                                  vec3 (1., 1., .5),  // diffuse\n                                  vec3 (1.),          // specular\n                                  1.),                // attenuation\n                           \n                           Light (vec3 (-2., 1., 2.), // position\n                                  vec3 (.1),          // ambient\n                                  vec3 (.5, 1., 1.),  // diffuse\n                                  vec3 (1.),          // specular\n                                  1.));               // attenuation\n\nMaterial material[4] = Material[4] (Material (vec3 (.5),         // PBR: albedo\n                                              .0,                // PBR: metallic\n                                              1.,                // PBR: roughness\n                                              vec3 (.1),         // Blinn/Phong: ambient\n                                              vec3 (.3, .6, .9), // Blinn/Phong: diffuse\n                                              vec3 (1.),         // Blinn/Phong: specular\n                                              20.,               // Blinn/Phong: shininess\n                                              vec3 (.0),         // Blinn/Phong: emissive\n                                    \t\t  false,             // does reflect\n                                              .05,               // reflection strength\n                                    \t\t  false,             // does refract\n                                    \t\t  .31),              // ior\n\n                                    Material (vec3 (.5),         // PBR: albedo\n                                              .0,                // PBR: metallic\n                                              1.,                // PBR: roughness\n                                              vec3 (.1),         // Blinn/Phong: ambient\n                                              vec3 (.9, .3, .6), // Blinn/Phong: diffuse\n                                              vec3 (1.),         // Blinn/Phong: specular\n                                              20.,               // Blinn/Phong: shininess\n                                              vec3 (.0),         // Blinn/Phong: emissive\n                                    \t\t  true,              // does reflect\n                                              .05,               // reflection strength\n                                    \t\t  false,             // does refract\n                                    \t\t  .31),              // ior\n\n                                    Material (vec3 (.5),         // PBR: albedo\n                                              .0,                // PBR: metallic\n                                              1.,                // PBR: roughness\n                                              vec3 (.1),         // Blinn/Phong: ambient\n                                              vec3 (.6, .9, .3), // Blinn/Phong: diffuse\n                                              vec3 (1.),         // Blinn/Phong: specular\n                                              20.,               // Blinn/Phong: shininess\n                                              vec3 (.0),         // Blinn/Phong: emissive\n                                    \t\t  true,              // does reflect\n                                              .05,               // reflection strength\n                                    \t\t  false,             // does refract\n                                    \t\t  .31),              // ior\n\n                                    Material (vec3 (.5),           // PBR: albedo\n                                              .0,                  // PBR: metallic\n                                              1.,                  // PBR: roughness\n                                              vec3 (.1),           // Blinn/Phong: ambient\n                                              vec3 (.95, .9, .85), // Blinn/Phong: diffuse\n                                              vec3 (.1),           // Blinn/Phong: specular\n                                              20.,                 // Blinn/Phong: shininess\n                                              vec3 (.0),           // Blinn/Phong: emissive);\n                                    \t\t  true,                // does reflect\n                                              .15,                 // reflection strength\n                                    \t\t  true,                // does refract\n                                    \t\t  .752));               // ior\n\nvec3 shade (in Ray ray, in Result res) {\n    vec3 amb = vec3 (.0);\n    vec3 diffC[4];\n\n\tfloat pattern1 = saturate (pow (abs(15. * cos(res.point.x+iTime) * sin (res.point.z+iTime)), .3));\n    float pattern2 = saturate (pow (abs(2. * cos(res.point.x+iTime) * sin (res.point.z+iTime) * .5 + .5), .3));\n    float pattern3 = saturate (pow (length (4.*sin(mod((res.point.y*res.point.x), .3))), .125));\n    float pattern4 = saturate (mod (length(res.point*sin(.1*iTime)), .5));\n\n    diffC[0] = mix (vec3 (.3, .6, .9), vec3 (.8), 1. - pattern1);\n    diffC[1] = mix (vec3 (.9, .3, .6), vec3 (.9), 1. - pattern2);\n    diffC[2] = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern4);\n    diffC[3] = vec3 (.0);\n    vec3 specC = vec3 (.0);\n    vec3 specC2 = vec3 (.0);\n    float shininess = 20.;\n    float shininess2 = 20.;\n\n    vec3 lCol = vec3 (.95, .95, .75);\n    vec3 lPos = vec3 (cos (2. * -iTime) * 3., .5, 1. + sin (1.5 *iTime) * .75);\n    vec3 lDir = normalize (lPos - res.point);\n    float diff = max (dot (res.normal, lDir), .0);\n    vec3 ref = normalize (reflect (ray.rd, res.normal));\n    float spec = pow (clamp (dot (ref, lDir), .0, 1.), shininess);\n    Result shaRes = trace (Ray (res.point, lDir));\n    float lDist = length (lPos - res.point);\n    float attenuation = 2. / (lDist * lDist);\n    lCol *= attenuation;\n    specC *= attenuation;\n    float sha = shaRes.dist < lDist ? .5 : 1.;\n\n    vec3 lCol2 = vec3 (.75, .95, .95);\n    vec3 lPos2 = vec3 (sin (iTime) * 4., -.25, 1. - cos (iTime) * .5);\n    vec3 lDir2 = normalize (lPos2 - res.point);\n    float diff2 = clamp (dot (res.normal, lDir2), .0, 1.);\n    vec3 ref2 = normalize (reflect (ray.rd, res.normal));\n    float spec2 = pow (clamp (dot (ref2, lDir2), .0, 1.), shininess2);\n    Result shaRes2 = trace (Ray (res.point, lDir2));\n    float lDist2 = length (lPos2 - res.point);\n    float attenuation2 = 3. / (lDist2 * lDist2);\n    lCol2 *= attenuation2;\n    specC2 *= attenuation2;\n    float sha2 = shaRes2.dist < lDist2 ? .5 : 1.;\n\n    vec3 col = amb +\n        \t   sha * (diff * diffC[res.id] * lCol) +\n\t\t\t   (sha >= .5 ? .0 : spec) * specC +\n\t\t\t   sha2 * (diff2 * diffC[res.id] * lCol2) +\n               (sha2 >= .5 ? .0 : spec2) * specC;\n\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    // generate primary ray from camera\n    vec3 ro = vec3 (.0, .0, -3.);\n    ro.xz *= r2d (PI*sin (.5*PI*(iMouse.x/iResolution.x * 2. - 1.)));\n    ro.yz *= r2d (.25*PI*sin (-.5*PI*(iMouse.y/iResolution.y * 2. - 1.)));\n    vec3 lookAt = vec3 (.0);\n    float zoom = 1.75;\n    Ray ray = cameraRay (uv, ro, lookAt, zoom);\n\n    // ray-trace the scene (primary view-ray)\n    Result res = trace (ray);\n    vec3 col = material[res.id].doesRefract ? vec3 (.0) : shade (ray, res);\n\n    if (material[res.id].doesReflect) {\n        const float airIOR = 1.;\n        const float waterIOR = 1.33;\n        float rZero = pow (((airIOR - waterIOR) / (airIOR + waterIOR)), 2.);\n\n\t    vec3 lPos1 = vec3 (cos (2. * -iTime) * 3., .5, 1. + sin (1.5 *iTime) * .75);\n    \tvec3 lPos2 = vec3 (sin (iTime) * 4., -.25, 1. - cos (iTime) * .5);\n    \tvec3 lDir1 = normalize (lPos1 - res.point);\n    \tvec3 lDir2 = normalize (lPos2 - res.point);\n        \n        float cosTheta1 = max (.0, dot (res.normal, lDir1));\n        float cosTheta2 = max (.0, dot (res.normal, lDir2));\n        float fresnel1  = rZero + (1. - rZero) * pow((1. - cosTheta1), 5.);\n        float fresnel2  = rZero + (1. - rZero) * pow((1. - cosTheta2), 5.);\n\n        // first reflection bounce\n\t    Ray reflectedRay = Ray (res.point + .01 * res.normal,\n                                normalize (reflect (ray.rd, res.normal)));\n        Result bounce = trace (reflectedRay);\n        col += fresnel1*fresnel2*.75*material[res.id].reflAmount * shade (reflectedRay, bounce);\n\n        // second reflection bounce\n        reflectedRay = Ray (bounce.point + .01 * bounce.normal,\n                            normalize (reflect (reflectedRay.rd, bounce.normal)));\n        bounce = trace (reflectedRay);\n        col += fresnel1*fresnel2*.5*material[res.id].reflAmount * shade (reflectedRay, bounce);\n\n        // third reflection bounce\n        reflectedRay = Ray (bounce.point + .01 * bounce.normal,\n                            normalize (reflect (reflectedRay.rd, bounce.normal)));\n        bounce = trace (reflectedRay);\n        col += fresnel1*fresnel2*.25*material[res.id].reflAmount * shade (reflectedRay, bounce);\n    }\n\n    if (material[res.id].doesRefract) {\n        // first refraction\n\t    Ray refractedRay = Ray (res.point - .01 * res.normal,\n                                normalize (refract (ray.rd,\n                                                    res.normal,\n                                                    material[res.id].ior)));\n        Result refracted = trace (refractedRay);\n        col += .5 * shade (refractedRay, refracted);\n\n        // second refraction\n\t    refractedRay = Ray (refracted.point - .01 * refracted.normal,\n                            normalize (refract (refractedRay.rd,\n                                                refracted.normal,\n                                                material[res.id].ior)));\n        refracted = trace (refractedRay);\n        col += .25 * shade (refractedRay, refracted);\n\n        // third refraction\n\t    refractedRay = Ray (refracted.point - .01 * refracted.normal,\n                            normalize (refract (refractedRay.rd,\n                                                refracted.normal,\n                                                material[res.id].ior)));\n        refracted = trace (refractedRay);\n        col += .125 * shade (refractedRay, refracted);\n\n        // fourth refraction\n\t    refractedRay = Ray (refracted.point - .01 * refracted.normal,\n                            normalize (refract (refractedRay.rd,\n                                                refracted.normal,\n                                                material[res.id].ior)));\n        refracted = trace (refractedRay);\n        col += .0625 * shade (refractedRay, refracted);\n    }\n\n    // tone-map and gamma-correct\n    col = col / (1. + col);\n    col = .1*col + .9*sqrt (col);\n\n\tfragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}