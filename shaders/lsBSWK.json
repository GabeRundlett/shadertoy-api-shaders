{
    "Shader": {
        "info": {
            "date": "1548291651",
            "description": "Raytracing 32 thousand boxes through a procedural BVH traversal. This could bee much faster I suppose, so I'll just say this is an offline render for now. A faster/simpler version of this here: [urlhttps://www.shadertoy.com/view/4tKBWy]/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "lsBSWK",
            "likes": 34,
            "name": "Procedural BVH ",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raytracing",
                "bvh",
                "boxes"
            ],
            "usePreview": 1,
            "username": "iq",
            "viewed": 3183
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// Procedural BVH. You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/canvas-print/Procedural-BVH-by-InigoQuilez/43594348.5Y5V7\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // source\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n\n    // instafilter\n    col = 1.5*pow( col, vec3(0.95,0.95,1.0) ) + vec3(-0.03,-0.02,0.01);\n\n    // vignete     \n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    // output\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ZERO min(0,iFrame)\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+3.0))*vec2(43758.5453123,22578.1459123)); }\n\nvec3 ihash3( uint n )\n{\n    uvec3 x = uvec3(n,n*7U+1U,n*13U+31U);\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    return vec3(x>>8)*(1.0/float(0x00ffffffU));\n}\n\n//=====================================================================\n\nstruct Box\n{\n\tvec3 cen;\n    vec3 rad;\n};\n\n// returns t and normal\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 ird, in Box box, out vec3 nor ) \n{\n    vec3 n = ird*(box.cen-ro);\n    vec3 k = abs(ird)*box.rad;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n\tnor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n\treturn vec2( tN, tF );\n}\n\n// returns t and normal\nbool boxIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird, in Box box ) \n{\n    vec3 n = ird*(box.cen-ro);\n    vec3 k = abs(ird)*box.rad;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    return tN<tF && tF>0.0;\n}\n\n\n//=====================================================================\n\nstruct Data\n{\n\tBox  box;\n    uint id;\n};\n\n    \nData stack[16];\nint stPtr;\n\nvoid stack_reset(void) { stPtr=-1; }\nbool stack_is_empty(void) { return stPtr==-1; }\nData stack_pop( void ) { return stack[stPtr--]; }\nvoid stack_push( in Data s ) { stack[++stPtr] = s; }\n\n//=====================================================================\n\nData generate( Data x, in uint id )\n{\n    vec3 ra = ihash3( x.id + 33U );\n    vec3 rb = ihash3( x.id + 14U );\n    vec3 nr = x.box.rad*(0.51+0.45*rb);\n    vec3 di = -1.0+2.0*ra.xyz;\n#ifdef ANIMATE    \n    float sc = (x.id>=(1U<<15U)) ? 0.2+0.8*smoothstep(-0.98,-0.9,cos( float(id)*0.005 + iTime*1.0 )) : 1.0;\n    return Data( Box(x.box.cen+(x.box.rad-nr)*di, nr*sc), id );\n#else    \n    return Data( Box(x.box.cen+(x.box.rad-nr)*di, nr), id );\n#endif\n}\n\nconst uint  lths = (1U<<16U);\nconst vec3  ibox = vec3(8.0,4.0,4.0);\n\n//=====================================================================\n\nvec4 iStructure( in vec3 ro, in vec3 rd, float tmax, out uint oID)\n{\n    vec3 ird = 1.0/rd;\n    vec4 res = vec4(-1.0);\n    \n    stack_reset();\n\n    // start with the root\n    Data x = Data( Box(vec3(0.0), ibox), 1U );\n    \n\tfor( int i=ZERO; i<2048; i++ )\n\t{\n        // intersect node\n        vec3 nor;\n        vec2 tmp = boxIntersect( ro, rd, ird, x.box, nor );\n        if( tmp.x<tmp.y && tmp.y>0.0 && tmp.x<tmax )\n        {\n            // if leaf\n            if( x.id>=lths )\n            {\n                tmax = tmp.x;\n                res = vec4( tmp.x, nor );\n                oID = x.id;\n\n                // pop next node from the stach\n                if( stack_is_empty() ) break;\n                x = stack_pop();\n            }\n            // else, generate two children\n            else\n            {\n                stack_push( generate(x,(x.id<<1U)+0U) ); // push one on the stack\n                        x = generate(x,(x.id<<1U)+1U);   // and start traversing the other\n            }\n        }\n        // pop next node from the stack\n        else\n        {\n            if( stack_is_empty() ) break;\n            x = stack_pop();\n        }\n\t}\n\n    return res;\n}\n\nbool iStructureAny( in vec3 ro, in vec3 rd, in vec3 ird )\n{\n    bool res = false;\n\n    // start with the root\n    Data x = Data( Box(vec3(0.0), ibox), 1U );\n\n    stack_reset();\n\n    for( int i=ZERO; i<2048; i++ )\n\t{\n        // intersect node\n        if( boxIntersectAny( ro, rd, ird, x.box ) )\n        {\n            // if leaf\n            if( x.id>=lths )\n            {\n                res = true;\n                break;\n            }\n            // else, generate two children\n            else\n            {\n                stack_push( generate(x,(x.id<<1U)+0U) ); // push one on the stack\n                        x = generate(x,(x.id<<1U)+1U);   // and start traversing the other\n            }\n        }\n        // pop next node from the stack\n        else\n        {\n            if( stack_is_empty() ) break;\n            x = stack_pop();\n        }\n\t}\n\n    return res;\n}\n\n//=====================================================================\n\n// method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    vec2 uv = hash2( seed);\n    float a = 6.2831853 * uv.y;\n    float u = 2.0*uv.x - 1.0;\n    return /*normalize*/( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-0.21 - ro.y)/rd.y;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n//=====================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2  offs = ihash3(uint(iFrame)).xy;\n    float seed = texelFetch( iChannel2, ivec2(fragCoord+offs*1024.0)&255, 0 ).x;\n    \n\tvec2 off = ihash3(uint(iFrame*3+17)).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+off)-iResolution.xy)/iResolution.y;\n\n\t// camera\n    float an = 0.6+0.0002*iTime;\n    float cr = 0.2*sin(-0.05*an);\n\tvec3  ta = vec3(2.2,0.20,0.4);\n\tvec3  ro = ta + vec3( 3.5*sin(an), 1.0, -3.5*cos(an) );\n    float fl = 3.52;\n\n\t// camera\n    mat3 cam = setCamera( ro, ta, cr );\n    vec3 rd = normalize( cam * vec3(p,-fl) );\n\n\n    // background\n    vec3 col = vec3(0.07+0.04*rd.y);\n    float tmin = 100.0;\n\n    \n    vec3 pos, nor, sur;\n\n    // trace floor plane\n    {\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        pos = ro + tmin*rd;\n        nor = vec3(0.0,1.0,0.0);\n        sur = texture( iChannel1, pos.xz + 0.5 ).xyz;\n        sur *= 0.3;\n    }\n    }\n    \n    // trace boxes\n    {\n    uint id = 0U;\n    vec4 res = iStructure( ro, rd, tmin, id );\n    if( res.x>0.0 && res.x<tmin )\n    {\n        tmin = res.x;\n        pos = ro + tmin*rd;\n        nor = res.yzw;\n\t\tsur = abs(nor.x)*texture( iChannel1, 2.0*pos.yz ).xyz + \n              abs(nor.y)*texture( iChannel1, 2.0*pos.zx ).xyz + \n              abs(nor.z)*texture( iChannel1, 2.0*pos.xy ).xyz;\n        \n        sur *= 0.6 + 0.4*sin(float(id)*0.005+vec3(0.0,0.5,1.0));\n        sur *= 1.0 + 0.3*sin(float(id+2U));\n\t}\n    }\n\n    // shade and lit\n    if( tmin<1e9 )\n    {\n        // compute occlusion\n        float occ = 0.0;\n\t\tfor( int j=ZERO; j<1; j++ )\n\t\t{\n            float s = seed + float(j) + float(iFrame)*13.1;\n            vec3 rr = cosineDirection( s, nor);\n            if( rr.y>0.0 )\n            {\n            vec3 irr = 1.0/rr;\n\t\t\tocc += (iStructureAny( pos+nor*0.001, rr, irr ) ? 0.0 : 1.0 );\n            }\n\t\t}\n\t\tocc /= 1.0;\n        \n\n        col = sur*occ*mix(vec3(1.0,0.6,0.3),vec3(0.8,0.9,1.0),clamp(0.2+0.8*nor.y,0.0,1.0));\n        float spe = smoothstep(0.0,0.13,reflect(rd,nor).y);\n        float fre = 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0),5.0);\n        col += spe*fre*occ*vec3(0.5,0.7,1.0)*sur.x*sur.x*1.5;\n        \n        // fog\n        col = mix( col, vec3(0.08,0.07,0.06), 1.0-exp( -0.002*tmin ) );\n    }\n    float t = tmin;\n\n    // gamma    \n    col = pow( col, vec3(0.4545) );\n\n\n\n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( texelFetch(iChannel0,ivec2(0,0), 0),\n                        texelFetch(iChannel0,ivec2(1,0), 0),\n                        texelFetch(iChannel0,ivec2(2,0), 0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*t,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = -fl * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= off/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy - .5;\n    ivec2 ipos = ivec2(floor(rpos));\n    // blend pixel color history\n    if( (ipos.y>0 || ipos.x>2) && iFrame>0 )\n    {\n        col = mix( textureLod( iChannel0, spos, 0.0 ).xyz, col, 0.01 );\n        col = clamp(col,0.0,10.0);\n    }\n\n    //----------------------------------\n    // output\n\tivec2 ifc = ivec2(floor(fragCoord));\n\tif( ifc.y==0 && ifc.x<=2 )\n    {\n        // camera\n        fragColor = vec4( cam[ifc.x], -dot(cam[ifc.x],ro) );\n    }\n    else\n    {\n        // color\n        fragColor = vec4( col, 1.0 );\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}