{
    "Shader": {
        "info": {
            "date": "1629297421",
            "description": "right: naive tiling of the torus\nleft: conformal mapping\n( simpler approach than https://www.shadertoy.com/view/tdGfzz )",
            "flags": 0,
            "hasliked": 0,
            "id": "sdd3R4",
            "likes": 30,
            "name": "Conformal Torus Texture Mapping2",
            "published": 3,
            "tags": [
                "torus",
                "uv",
                "conformal",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 653
        },
        "renderpass": [
            {
                "code": "#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,d,  k = 2., // .9                              // tile multiplier\n          R0 = 20., R1 = 10.;                                 // large and small radii\n\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q,                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p,\n        q.yz *= rot( .5+6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        t = min(9., length(vec2(d=length(q.xz)-R0,q.y)) - R1),// abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj          \n\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/2.);                  // luminance (depth + pseudo-shading )\n    float a = atan(q.z,q.x), b = atan(q.y,d);\n    \n    if (U.x < R.x/2. ) {                                     // left: conformal mapping\n     // b -= R1/R0 * sin(b); //  wrong (or approx): antiderivative of circonf(b)\n        float r = R1/R0, ir = sqrt(1.-r*r);       // antiderivative of 1/circonf(b) \n        b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );        \n     //                                NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n    }\n    O *= hue( floor(k*R0*a/6.283) + 17.*mod(round(k*R1*b/6.283),R1) ); // colored tiles \n\n    a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n    O *= sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) );// tiles borders\n    \n    if (int(U)==int(R/2.) ) O++;                              // vertical separator\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}