{
    "Shader": {
        "info": {
            "date": "1547358288",
            "description": "visualizing the decision boundary of an SVM.\nthis is a lot more interesting when the decision boundary animates.\nif you want to see the decision boundary animate checkout the cpp version at github.com/xdaimon/svm\n\nbest viewed in fullscreen",
            "flags": 0,
            "hasliked": 0,
            "id": "wdfGDB",
            "likes": 11,
            "name": "Decision Boundary",
            "published": 3,
            "tags": [
                "visualization",
                "data"
            ],
            "usePreview": 0,
            "username": "xdaimon",
            "viewed": 540
        },
        "renderpass": [
            {
                "code": "const int numberOfClasses = 6;\nconst int numberOfExamples = 60;\n\nconst vec4 Examples[ numberOfExamples ] = vec4[](vec4(-0.509688,-0.422557,1.28391, 1.),\n                                           vec4(-0.670389,-0.485958,1.30473, 1.),\n                                           vec4(-0.438064,-0.564474,1.0997, 1.),\n                                           vec4(-0.694895,-0.53187,1.10122, 1.),\n                                           vec4(-0.427009,-0.420648,1.21593, 1.),\n                                           vec4(-0.637149,-0.59757,1.07595, 1.),\n                                           vec4(-0.64486,-0.572116,1.26599, 1.),\n                                           vec4(-0.762001,-0.520566,1.00108, 1.),\n                                           vec4(-0.424265,-0.698889,1.0366, 1.),\n                                           vec4(-0.462792,-0.466572,1.00454, 1.),\n                                           vec4(1.12512,0.741453,-0.831244, 1.),\n                                           vec4(1.01668,0.576655,-0.31921, 1.),\n                                           vec4(1.16555,1.19365,-0.796705, 1.),\n                                           vec4(1.07064,1.18215,-0.794199, 1.),\n                                           vec4(0.721892,0.849783,-0.818938, 1.),\n                                           vec4(0.607071,0.529939,-0.995394, 1.),\n                                           vec4(0.810309,0.83389,-0.588174, 1.),\n                                           vec4(1.07951,0.743696,-0.33843, 1.),\n                                           vec4(0.546061,0.563446,-0.468585, 1.),\n                                           vec4(0.512923,1.1988,-0.825351, 1.),\n                                           vec4(-1.02341,0.797913,0.323148, 1.),\n                                           vec4(-1.30261,0.798807,0.584477, 1.),\n                                           vec4(-1.59718,0.919545,0.655692, 1.),\n                                           vec4(-1.07527,1.15425,0.727181, 1.),\n                                           vec4(-1.51128,1.17793,0.457625, 1.),\n                                           vec4(-1.46092,1.02161,0.357892, 1.),\n                                           vec4(-1.18804,0.854426,0.388368, 1.),\n                                           vec4(-1.5128,0.684935,0.566907, 1.),\n                                           vec4(-1.29835,0.968902,0.561818, 1.),\n                                           vec4(-1.14322,1.06997,0.461825, 1.),\n                                           vec4(-1.08478,-0.974159,-0.907624, 1.),\n                                           vec4(-1.4285,-1.12899,-0.830452, 1.),\n                                           vec4(-1.43432,-1.17942,-0.933799, 1.),\n                                           vec4(-1.48049,-1.35411,-1.00348, 1.),\n                                           vec4(-1.38776,-1.38561,-0.927782, 1.),\n                                           vec4(-1.46636,-1.27017,-1.14142, 1.),\n                                           vec4(-1.20252,-1.00595,-1.07651, 1.),\n                                           vec4(-1.1207,-0.980235,-0.798928, 1.),\n                                           vec4(-1.01821,-0.956798,-1.14246, 1.),\n                                           vec4(-1.16749,-1.32199,-1.1117, 1.),\n                                           vec4(1.33533,-0.582544,0.820304, 1.),\n                                           vec4(1.63371,-1.01899,0.709675, 1.),\n                                           vec4(1.6095,-0.890699,0.123319, 1.),\n                                           vec4(1.91293,-0.5854,0.558924, 1.),\n                                           vec4(1.15823,-0.621298,0.445074, 1.),\n                                           vec4(1.92099,-0.762227,0.790525, 1.),\n                                           vec4(1.54328,-1.12239,0.553002, 1.),\n                                           vec4(1.94063,-0.829535,0.815582, 1.),\n                                           vec4(1.46287,-1.22129,0.839934, 1.),\n                                           vec4(1.34636,-0.69071,0.769754, 1.),\n                                           vec4(0.76432,-0.720917,-1.22886, 1.),\n                                           vec4(0.515876,-0.713896,-1.02217, 1.),\n                                           vec4(0.714848,-0.705678,-1.36335, 1.),\n                                           vec4(0.705932,-0.247416,-1.39287, 1.),\n                                           vec4(0.698353,-0.978587,-1.08291, 1.),\n                                           vec4(0.692341,-0.00349816,-1.14678, 1.),\n                                           vec4(0.537378,-0.725154,-1.32035, 1.),\n                                           vec4(0.69357,-0.265905,-1.63304, 1.),\n                                           vec4(0.728966,-0.441841,-1.43902, 1.),\n                                           vec4(0.752253,-0.0785455,-1.61995, 1.));\n\t\nconst vec4 Weights[ numberOfClasses ] = vec4[](\n    vec4(-0.00660, -0.04639, 0.169740, 0.0191),\n    vec4(0.195536, 0.190433, -0.03664, 0.0266),\n    vec4(-0.11302, 0.192075, 0.170938, 0.0143),\n    vec4(-0.09638, -0.01133, -0.06069, 0.0724),\n    vec4(0.242151, -0.02131, 0.094378, 0.0181),\n    vec4(0.119821, 0.012547, -0.10512, 0.0029));\n\nconst vec3 Colors[ numberOfClasses ] = vec3[](\n    vec3( 80. / 255.0,255. / 255.0,0. / 255.0),\n    vec3(  0. / 255.0,131. / 255.0,255. / 255.0),\n    vec3(255. / 255.0,220. / 255.0,0. / 255.0),\n    vec3(255. / 255.0,0. / 255.0,0. / 255.0),\n    vec3(225. / 255.0,225. / 255.0,225. / 255.0),\n    vec3(220. / 255.0,0. / 255.0,120. / 255.0));\n\nconst float weightToClassMap[ numberOfClasses ] = float[](0., 1., 2., 3., 4., 5.);\n\nconst float Gamma = 1.81;\nconst float Bound = 2.5;\nconst float Lens = 2.2;\n\nconst float Shininess = 23.;\nconst float PlaneOpacity = .80;\nconst float ExampleOpacity = .86;\nconst float ExampleSphereRadius = 0.1;\n\n//#define COLORFUL_ISOLINES\n\nvec3 Light0;\nvec3 Light1;\nconst vec3 SKY = vec3(.85);\n\n#define EXAMPLE 0\n#define PLANE 1\n\nstruct Intersection {\n    // What type of object did we intersect\n    int objectID;\n\n    // Which two weights define the plane we've intersected\n    ivec2 ids;\n\n    float t;\n\n    float opacity;\n};\n\nvoid makeRay(in vec2 pixelCoord, out vec3 ro, out vec3 rd) {\n    rd = vec3(pixelCoord, Lens);\n    rd = normalize(rd);\n\n    ro = vec3(0.0, 0.0, -7.0);\n\n    vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse *= 3.14;\n    \n    float cx = cos(mouse.x);\n    float cy = cos(mouse.y);\n    float sx = sin(mouse.x);\n    float sy = sin(mouse.y);\n    mat3 rotate = mat3(cx, -sx*sy, sx*cy,\n                       0.,     cy,    sy,\n                       -sx, -cx*sy, cx*cy);\n    rd *= rotate;\n    ro *= rotate;\n}\n\n// Plane-Ray intersection\nfloat plane(in vec3 ro, in vec3 rd, in vec3 norm, in vec3 pointInPlane) {\n    return dot(pointInPlane-ro,norm)/dot(rd, norm);\n}\n\n// Sphere-Ray intersection\nvec3 sphere(in vec3 ro, in vec3 rd, in vec3 center, in float radius) {\n    vec3 oc = ro-center;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - radius*radius;\n    float h = b*b - c;\n    float sqmh = sqrt(max(h,0.));\n    return vec3(-b-sqmh, -b+sqmh, h);\n}\n\nint maxClassAtPoint(in vec3 p) {\n    // Find the class of the point\n    int max_class = -1;\n    float score = 0.;\n    float max_score = -1e7;\n    for (int i = 0; i < numberOfClasses; ++i) {\n        score = dot(vec4(p,1.0), Weights[i]);\n        if (score > max_score) {\n            max_score = score;\n            max_class = i;\n        }\n    }\n    return max_class;\n}\n\n#define withinBound(t) (t>BoundInterval.x&&t<BoundInterval.y)\n\n// Enough intersection structs for all the planes and examples\nIntersection intersections[numberOfClasses*(numberOfClasses-1)/2];\nint numIntersections = 0;\n\n// Fill the intersections array\nbool intersect(in vec3 ro, in vec3 rd) {\n    // Intersect bounding sphere\n    vec2 BoundInterval;\n    vec3 sphereIntersect = sphere(ro, rd, vec3(0.), Bound);\n    // float nearestSphereRayDist = sqrt(max(Bound*Bound-sphereIntersect.z, 0.0))-Bound;\n    // if (nearestSphereRayDist < 0.01)\n    if (sphereIntersect.z > 0.) {\n        // intersections[numIntersections].objectID = BOUND;\n        // // intersections[numIntersections].opacity = 1.-clamp(nearestSphereRayDist/0.02, 0., 1.);\n        // intersections[numIntersections].opacity = abs(sphereIntersect.y - sphereIntersect.x);\n        // intersections[numIntersections].t = sphereIntersect.x;\n        // numIntersections++;\n        BoundInterval = sphereIntersect.xy;\n    } else {\n        return false;\n    }\n\n    // Find intersections with examples\n    for (int i = 0; i < numberOfExamples; ++i) {\n        sphereIntersect = sphere(ro, rd, Examples[i].xyz, ExampleSphereRadius);\n\n        // float nearestSphereRayDist = sqrt(max(ExampleSphereRadius*ExampleSphereRadius-sphereIntersect.z, 0.0))-ExampleSphereRadius;\n        // const float closeEnough = ExampleSphereRadius/5.;\n        //if (nearestSphereRayDist < closeEnough)\n\n        if (sphereIntersect.z  > 0.) {\n            // checking for positive is needed when tracing the shadows??\n            if (withinBound(sphereIntersect.x) && sphereIntersect.x > 0.) {\n                intersections[numIntersections].objectID = EXAMPLE;\n\n                intersections[numIntersections].ids.x = i;\n                intersections[numIntersections].t = sphereIntersect.x;\n\n                // intersections[numIntersections].opacity = 1.-clamp(nearestSphereRayDist/closeEnough, 0., 1.);\n                // intersections[numIntersections].opacity *= ExampleOpacity;\n                intersections[numIntersections].opacity = clamp(ExampleOpacity * (sphereIntersect.y-sphereIntersect.x)/ExampleSphereRadius, 0., 1.);\n\n                numIntersections++;\n            }\n        }\n    }\n\n    // Find intersections of ray(t) = ro+rd*t with SVM decision boundaries\n    //\n    // f(x,y,z) is a linear function and is represented as a coefficient matrix and is formed by the\n    // difference between two functions (two parameter vectors, the SVM weights)\n    // The solutions to f(x,y,z) == 0 form a plane (the decision boundary) that we want to draw.\n    vec4 f;\n    // A point on the plane f(x,y,z) == 0\n    // used to solve for t in ray(t) = ro+rd*t such that ray(t) is on the plane f(x,y,z) = 0\n    vec3 P;\n    float t;\n    int max_class;\n    // Find points on ray where scores for any two classes are equivalent\n    // and where those two scores are greater than the scores for all other classes\n    for (int i = 0; i < numberOfClasses; ++i) {\n        // Check weight score equality\n        for (int j = numberOfClasses-1; j > i; --j) {\n            // Construct the coefficients for f(x,y,z)\n            f = Weights[i]-Weights[j];\n            // Let P be the z intercept of f(x,y,z) == 0\n            P = vec3(0.,0.,-f.w/f.z);\n            // Solve for t such that ro+rd*t is on the plane\n            // ((ro+rd*t)-P)*norm == 0\n            // (ro+rd*t)*Norm == P*norm\n            // t*rd*norm + ro*norm == P*norm\n            // t == (P-ro)*norm/(rd*norm)\n            t = dot(P-ro, f.xyz)/dot(rd, f.xyz);\n            // Don't consider any intersections behind ray origin or outside our bounding volume.\n            if (withinBound(t) && t > 0.) { // checking for positive is needed when tracing the shadows??\n                // Try to ensure that intersections[k].ids.x holds the id of the max class in the space before\n                // the ray hits the plane -> so find the max class slightly before the intersection\n                max_class = maxClassAtPoint(ro+rd*(t-0.0001));\n                if (max_class == j || max_class == i) {\n                    intersections[numIntersections].objectID = PLANE;\n                    if (max_class == j) {\n                        intersections[numIntersections].ids.x=j;\n                        intersections[numIntersections].ids.y=i;\n                    } else {\n                        intersections[numIntersections].ids.x=i;\n                        intersections[numIntersections].ids.y=j;\n                    }\n                    intersections[numIntersections].t = t;\n                    intersections[numIntersections].opacity = PlaneOpacity;\n                    numIntersections++;\n                }\n            }\n        }\n    }\n    // Sort intersections. Intersection closest to ro is in intersections[0]\n    for( int i=0; i<numIntersections-1; i++ )\n        for( int j=i+1; j<numIntersections; j++ ) {\n            if(intersections[j].t<intersections[i].t) {\n                Intersection temp = intersections[i];\n                intersections[i] = intersections[j];\n                intersections[j] = temp;\n            }\n        }\n\n    return numIntersections > 0;\n}\n\n// This shader really needs to take into consideration shadowing. Especially since the specular component\n// shows up in places where there should be no light from the sun.\nvec3 lighting(in vec3 hit, in vec3 rd, in vec3 norm, in vec3 diffuseColor) {\n    vec3 ret;\n\n    vec3 lr = normalize(hit-Light0);\n    float diff = max(dot(norm, -lr),0.0);\n    vec3 refL = reflect(lr, norm);\n    float spec = pow(max(dot(refL, -rd),0.0), Shininess);\n    vec3 diffComp = diffuseColor * diff;\n    vec3 specComp = vec3(spec);\n    vec3 ambientComp = diffuseColor*.3;\n\n    // Add a flashlight with the camera\n    diffComp = mix(diffComp, abs(dot(rd, norm))*diffuseColor, .5);\n    ret = diffComp + .2 * specComp + ambientComp;\n\n    lr = normalize(hit - Light1);\n    diff = max(dot(norm, -lr), 0.0);\n    refL = reflect(lr, norm);\n    spec = pow(max(dot(refL, -rd),0.0), Shininess);\n    diffComp = diffuseColor * diff;\n    specComp = vec3(spec);\n\n    diffComp = mix(diffComp, abs(dot(rd, norm))*diffuseColor, .5);\n    ret = mix(diffComp + .2 * specComp + ambientComp, ret, .5);\n\n    return ret;\n}\n\nvec3 getPlaneColor(in vec3 ro, in vec3 rd, in float t, in int i, in int j) {\n    vec3 f = (Weights[i]-Weights[j]).xyz;\n    f = normalize(f);\n    return lighting(ro + rd*t, rd, f.xyz, Colors[int(weightToClassMap[i])]);\n}\n\n// k -> kth intersection\nvec3 isolines(in vec3 ro, in vec3 rd, in int k, in vec3 baseColor) {\n\n    // f(x,y,z) is represented as a coefficient matrix and is formed by the\n    // difference between two functions (two parameter vectors, the SVM weights)\n    // The solutions to f(x,y,z) == 0 form a plane (the decision boundary)\n    // that we want to draw. This plane can be parameterized by solving for z\n    // and forming the coefficent matrix for a funtion h(x,y). We perform\n    // this process of finding the null set twice, for some f0(x,y,z) and\n    // f1(x,y,z), to obtain h0(x,y) and h1(x,y). The space of solutions to\n    // h0(x,y) - h1(x,y) == 0 forms a line which can be parameterized by\n    // solving for y and forming the function g(x). Given this function g(x)\n    // we can perform antialiasing on the seams where two planes intersect.\n\n    // AntiAlias the seams where two planes intersect, i.e where two decision boundaries meet.\n    // The goal is to find two points on this seam. A line is constructed from these points.\n    // The minimum distance between the primary rays intersecting point Q and\n    // the line is found and used for color mixing.\n    float dist_to_seam = 1e10;\n    vec4 f0;\n    vec4 f1;\n    vec3 g;\n    vec3 z0;\n    vec3 z1;\n    int idOfPlane;\n    float s;\n    float t;\n    vec3 Q;\n    vec2 line;\n    vec3 lineP0;\n    vec3 lineP1;\n    vec3 lineDir;\n    // We've already found the max class decision boundary during ray tracing.\n    Q = ro+rd*intersections[k].t;\n    f0 = Weights[intersections[k].ids.x]-Weights[intersections[k].ids.y];\n    // A point on the z0 plane is then vec3(s, t, dot(z0, vec3(s,t,1.)))\n    z0 = -vec3(f0.x,f0.y,f0.w)/f0.z;\n    for (int i = 0; i < numberOfClasses; ++i) {\n        //TODO project into screen plane and then take distances in order to smooth out the pixel mixing gradients?\n\n        if (i == intersections[k].ids.y)\n            continue;\n\n        f1 = Weights[intersections[k].ids.x] - Weights[i];\n\n        // Coefficients for equation of plane\n        z1 = -vec3(f1.x,f1.y,f1.w)/f1.z;\n\n        g = z0-z1;\n\n        // A point on the line is vec2(s, dot(line, vec2(s, 1.)))\n        line = -vec2(g.x,g.z)/g.y;\n\n        s = 0.;\n        t = dot(line, vec2(s, 1.));\n        lineP0 = vec3(s, t, dot(z0, vec3(s, t, 1.)));\n\n        s = 1.;\n        t = dot(line, vec2(s, 1.));\n        lineP1 = vec3(s, t, dot(z0, vec3(s, t, 1.)));\n\n        lineDir = normalize(lineP1-lineP0);\n\n        // Point on line such that point-Q is orthogonal to line\n        lineP1 = lineP0+lineDir*dot(lineDir, Q-lineP0);\n        float D = length(Q-lineP1);\n        if (D < dist_to_seam) {\n            dist_to_seam = D;\n            idOfPlane = i;\n        }\n    }\n\n    vec3 colToLerp = getPlaneColor(ro, rd, intersections[k].t, intersections[k].ids.x, idOfPlane);\n    #ifdef COLORFUL_ISOLINES\n    // return mix(baseColor, colToLerp, .5-.5*smoothstep(0., 20./resolution.x, dist_to_seam));\n    return mix(baseColor, colToLerp, .5-.5*smoothstep(0., .022, dist_to_seam));\n    #else\n    // return mix(baseColor, vec3(0.), .5-.5*smoothstep(0., 20./resolution.x, dist_to_seam));\n    return mix(baseColor, .2*colToLerp, .5-.5*smoothstep(0., .027, dist_to_seam));\n    #endif\n}\n\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec3 color = SKY;\n    vec3 objColor = vec3(0.);\n    for (int i = numIntersections-1; i >= 0; --i) {\n        switch(intersections[i].objectID) {\n            case PLANE:\n            objColor = getPlaneColor(ro, rd, intersections[i].t, intersections[i].ids.x, intersections[i].ids.y);\n            objColor = isolines(ro, rd, i, objColor);\n            break;\n            case EXAMPLE:\n            vec3 hit = ro + rd * intersections[i].t;\n            objColor = lighting(hit, rd, normalize(hit-Examples[intersections[i].ids.x].xyz), Colors[int(intersections[i].ids.x / 10)]);\n            break;\n        }\n        color = mix(color, objColor, intersections[i].opacity);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pixelCoord = fragCoord.xy / iResolution.xy;\n    pixelCoord = pixelCoord * 2.0 - 1.0;\n    pixelCoord.x *= iResolution.x/iResolution.y;\n\n    vec3 ro;\n    vec3 rd;\n    makeRay(pixelCoord, ro, rd);\n\n    Light0 = 1.5*vec3(Bound, .75, Bound);\n    Light1 = 1.5*vec3(-Bound, .75, -Bound);\n\n    fragColor.rgb = SKY;\n    if ( intersect(ro, rd) ) {\n        vec3 color = getColor(ro, rd);\n        // if (intersect(toward light))\n        // {\n        // \tcolor = shadow;\n        // }\n        fragColor.rgb = color;\n    }\n    // TODO intersect another ray from hit in the direction toward light\n    // if there is no occluders then intersect() returns false\n\n    // I dont really understand gamma i guess.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./Gamma));\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}