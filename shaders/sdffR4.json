{
    "Shader": {
        "info": {
            "date": "1644538796",
            "description": "Fractal using MFSDF scene description, and using the awesome Good sliders from shader XtG3Rt\nBecause of the 18 sliders it takes sometime to compile... \nLeft Sliders are the fractal parameters, bottom one is the animation speed\nRight Sliders are colors",
            "flags": 32,
            "hasliked": 0,
            "id": "sdffR4",
            "likes": 29,
            "name": "MFSDF Fractal",
            "published": 3,
            "tags": [
                "fractal",
                "mfsdf"
            ],
            "usePreview": 1,
            "username": "PauloFalcao",
            "viewed": 717
        },
        "renderpass": [
            {
                "code": "// MFSDF Fractal\n// By PauloFalcao\n//\n// This is a fractal using the MSSDF scene description explained here\n// https://www.shadertoy.com/view/7dySRc\n//\n// Use https://www.shadertoy.com/view/NdXfzM to shade presets\n//\n// Made in the node base material maker\n// Sliders from the awesome Good shader https://www.shadertoy.com/view/XtG3Rt\n//\n// Youtube video playing with this on material maker\n// https://www.youtube.com/watch?v=LbkMJ1xJFQ0\n//\n// The original Material Maker file is here\n// https://www.materialmaker.org/material?id=362\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n//\n\nvoid mainImage( out vec4 o, in vec2 p ){\n    o = texture(iChannel0,p.xy/iResolution.xy); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// MFSDF Fractal\n// By PauloFalcao\n//\n// This is a fractal using the MSSDF scene description explained here\n// https://www.shadertoy.com/view/7dySRc\n//\n// Made in the node base material maker\n// Sliders from the awesome Good shader https://www.shadertoy.com/view/XtG3Rt\n//\n// Youtube video playing with this on material maker\n// https://www.youtube.com/watch?v=LbkMJ1xJFQ0\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n\n\n#define SEED_VARIATION 0.0\n\nfloat f1,f2,f3,f4,f5,f6,f7,f8,f9;\nfloat f10,f11,f12,f13,f14,f15,f16,f17,f18;\n\nvec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright Â© 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}float mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o502144_LookAtX = 0.000000000;\nconst float p_o502144_LookAtY = 0.000000000;\nconst float p_o502144_LookAtZ = 0.000000000;\nconst float p_o502144_CamD = 1.500000000;\nconst float p_o502144_CamZoom = 1.000000000;\nconst float p_o502144_SunX = 2.500000000;\nconst float p_o502144_SunY = 2.500000000;\nconst float p_o502144_SunZ = 2.500000000;\nconst float p_o502144_AmbLight = 0.250000000;\nconst float p_o502144_AmbOcclusion = 1.000000000;\nconst float p_o502144_Shadow = 1.000000000;\nconst float p_o502144_Gamma = 1.300000000;\nconst float p_o502134_Correction = 0.000000000;\nconst float p_o502161_k = 0.199000000;\n#define p_o502157_BaseColor_r (f13)\n#define p_o502157_BaseColor_g (f14)\n#define p_o502157_BaseColor_b (f15)\nconst float p_o502157_BaseColor_a = 1.000000000;\nconst float p_o502157_Metallic = 0.002000000;\nconst float p_o502157_Specular = 0.500000000;\nconst float p_o502157_Roughness = 0.000000000;\nconst float p_o502157_Emission = 0.000000000;\nconst float p_o502157_Normal = 0.000000000;\nconst float p_o502157_Alpha = 0.000000000;\nconst float p_o502157_AmbientOcclusion = 0.000000000;\nconst float p_o502157_scale = 0.963000000;\nconst float p_o502157_TranlateX = 0.148000000;\nconst float p_o502157_TranlateY = -0.386000000;\nconst float p_o502157_TranlateZ = 0.295000000;\nconst float p_o502157_RotateX = 0.000000000;\nconst float p_o502157_RotateY = 0.000000000;\nconst float p_o502157_RotateZ = 0.000000000;\nvec3 o502157_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o502157_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o502157_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o502157_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o502157_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502157_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o502157(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o502157_TranlateX,p_o502157_TranlateY,p_o502157_TranlateZ),vec3(p_o502157_RotateX,p_o502157_RotateY,p_o502157_RotateZ)*6.28318530718)/p_o502157_scale;\n\tfloat sdf=o502157_input_sdf3d(uv.xyz, _seed_variation_)*p_o502157_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o502157_AmbientOcclusion*o502157_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o502157_Alpha*o502157_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o502157_Normal*o502157_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o502157_Emission*o502157_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o502157_Roughness*o502157_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o502157_Specular*o502157_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o502157_Metallic*o502157_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o502157_BaseColor_r, p_o502157_BaseColor_g, p_o502157_BaseColor_b, p_o502157_BaseColor_a).rgb*o502157_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\n#define p_o502140_BaseColor_r (f10)\n#define p_o502140_BaseColor_g (f11)\n#define p_o502140_BaseColor_b (f12)\nconst float p_o502140_BaseColor_a = 1.000000000;\nconst float p_o502140_Metallic = 0.000000000;\nconst float p_o502140_Specular = 0.500000000;\nconst float p_o502140_Roughness = 0.000000000;\nconst float p_o502140_Emission = 0.000000000;\nconst float p_o502140_Normal = 0.000000000;\nconst float p_o502140_Alpha = 0.000000000;\nconst float p_o502140_AmbientOcclusion = 0.000000000;\nconst float p_o502140_scale = 0.984000000;\nconst float p_o502140_TranlateX = -0.083000000;\nconst float p_o502140_TranlateY = 0.147000000;\nconst float p_o502140_TranlateZ = 0.000000000;\nconst float p_o502140_RotateX = 0.000000000;\nconst float p_o502140_RotateY = 0.000000000;\nconst float p_o502140_RotateZ = 0.000000000;\nconst float p_o502162_scale = 0.579000000;\n#define p_o502162_scale_x (f16*32.0)\n#define p_o502162_scale_y (f17*32.0)\n#define p_o502162_scale_z (f18*32.0)\nconst float p_o502162_transx = 0.000000000;\nconst float p_o502162_transy = 0.000000000;\nconst float p_o502162_transz = 0.000000000;\nconst float p_o502162_persistence = 0.500000000;\nconst float p_o502162_brightness = 0.000000000;\nconst float p_o502162_contrast = 4.139000000;\nfloat o502162_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o502162_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o502140_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec3 o502162_0_out = vec3(o502162_bc(o502162_fbm((p).xyz*vec3(p_o502162_scale_x,p_o502162_scale_y,p_o502162_scale_z)*0.5*p_o502162_scale+vec3(p_o502162_transx,p_o502162_transy,p_o502162_transz),p_o502162_persistence, _seed_variation_)*0.5+0.5,p_o502162_contrast,p_o502162_brightness, _seed_variation_));vec3 o502162_0_1_tex3d = clamp(o502162_0_out,vec3(0),vec3(1));\n\nreturn o502162_0_1_tex3d;\n}\nfloat o502140_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o502140_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o502140_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o502140_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o502140_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o502140(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o502140_TranlateX,p_o502140_TranlateY,p_o502140_TranlateZ),vec3(p_o502140_RotateX,p_o502140_RotateY,p_o502140_RotateZ)*6.28318530718)/p_o502140_scale;\n\tfloat sdf=o502140_input_sdf3d(uv.xyz, _seed_variation_)*p_o502140_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o502140_AmbientOcclusion*o502140_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o502140_Alpha*o502140_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o502140_Normal*o502140_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o502140_Emission*o502140_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o502140_Roughness*o502140_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o502140_Specular*o502140_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o502140_Metallic*o502140_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o502140_BaseColor_r, p_o502140_BaseColor_g, p_o502140_BaseColor_b, p_o502140_BaseColor_a).rgb*o502140_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o502134_input_obj3d(vec4 p, float _seed_variation_) {\nvec4 o502157_0_1_v4v4 = PBRObjectMaker_o502157((p), _seed_variation_);\nvec4 o502140_0_1_v4v4 = PBRObjectMaker_o502140((p), _seed_variation_);\nvec4 o502161_0_1_v4v4 = mfsdf3d_smooth_union(o502157_0_1_v4v4, o502140_0_1_v4v4,p_o502161_k);\n\nreturn o502161_0_1_v4v4;\n}\nconst float p_o502156_xyz = 0.799000000;\nconst float p_o502156_x = 1.000000000;\nconst float p_o502156_y = 1.000000000;\nconst float p_o502156_z = 1.000000000;\n#define p_o502155_ax (f1*360.0-180.0+f2*20.0+sin(iTime*0.9)*50.0*f9)\n#define p_o502155_ay (f3*360.0-180.0+f4*20.0+sin(iTime*0.8)*50.0*f9)\n#define p_o502155_az (f5*360.0-180.0+f6*20.0+sin(iTime)*50.0*f9)\n#define p_o502153_smooth (max(f8*0.05,0.001))\n#define p_o502154_x (f7*0.5+0.1)\nconst float p_o502154_y = 0.256000000;\nconst float p_o502154_z = 0.202000000;\nvec4 o502134_input_trans3d(vec4 p, float _seed_variation_) {\nvec4 o502152_0_1_v4v4 = (vec4((vec4(vec3(sqrt((vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz*(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz+p_o502153_smooth)),(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).w)).xyz-vec3(p_o502154_x, p_o502154_y, p_o502154_z),(vec4(vec3(sqrt((vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz*(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).xyz+p_o502153_smooth)),(vec4(v4v4_rotate((vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).xyz, -vec3(p_o502155_ax, p_o502155_ay, p_o502155_az)*0.01745329251), (vec4((p).xyz/vec3(p_o502156_x, p_o502156_y, p_o502156_z)/p_o502156_xyz,(p).w)).w)).w)).w));\nvec4 o502154_0_1_v4v4 = o502152_0_1_v4v4;\nvec4 o502153_0_1_v4v4 = o502154_0_1_v4v4;\nvec4 o502155_0_1_v4v4 = o502153_0_1_v4v4;\nvec4 o_o502156_0=o502155_0_1_v4v4;vec4 o502156_0_1_v4v4 = vec4(o_o502156_0.xyz,(p).w/min(min(p_o502156_x, p_o502156_y), p_o502156_z)/p_o502156_xyz);\n\nreturn o502156_0_1_v4v4;\n}\nfloat o502134_input_custombool(vec2 uv, float _seed_variation_) {\n\nreturn min((uv).x,(uv).y);\n}\n\nvec4 for_fold_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n  }\n  vec4 o=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  return vec4(o.xyz,o.w/p.w);\n}\n\nvec4 for_min_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n\td=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\td.w=d.w/p.w;\n\tm=m.w<d.w?m:d;\n  }\n  return m;\n}\n\nvec4 for_custom_o502134(vec4 p,float mfsdftype, float _seed_variation_) {\n  vec4 d=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n  vec4 m=d;\n  for(int i=0;i<8;i++){\n    p=o502134_input_trans3d(p, _seed_variation_);\n\td=o502134_input_obj3d(vec4(p.xyz,mfsdftype), _seed_variation_);\n\tfloat a=m.w;\n\tfloat b=d.w/p.w;\n\tfloat v=o502134_input_custombool(vec2(a,b), _seed_variation_);\n    float e=0.001;\n\tvec2 n=normalize(vec2(o502134_input_custombool(vec2(a+e,b), _seed_variation_)-o502134_input_custombool(vec2(a-e,b), _seed_variation_),\n                          o502134_input_custombool(vec2(a,b+e), _seed_variation_)-o502134_input_custombool(vec2(a,b-e), _seed_variation_)));\t\t\t\t\n\tm=vec4(mix(m.xyz,d.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),v);\n  }\n  return vec4(m.xyz,m.w/(1.0+p_o502134_Correction));\n}\nvec4 o502144_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o502134_0_1_v4v4 = for_fold_o502134(vec4((vec4(v4v4_rotate((p).xyz, -vec3((iTime*23.0), (iTime*21.0), (iTime*19.0))*0.01745329251), (p).w)).xyz,1.0),(vec4(v4v4_rotate((p).xyz, -vec3((iTime*23.0), (iTime*21.0), (iTime*19.0))*0.01745329251), (p).w)).w, _seed_variation_);\nvec4 o502167_0_1_v4v4 = o502134_0_1_v4v4;\n\nreturn o502167_0_1_v4v4;\n}\nvec3 o502144_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o502144_SunX,p_o502144_SunY,-p_o502144_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o502144(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o502144_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o502144_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o502144_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o502144_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o502144(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = o502144_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 50.0 || abs(dS) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o502144( in vec3 pos, in vec3 nor , float _seed_variation_) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = o502144_input_mfsdf(vec4( pos + h*nor ,0.0), _seed_variation_).w;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o502144( in vec3 ro, in vec3 rd, in float mint, in float tmax, float _seed_variation_) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = o502144_input_mfsdf(vec4( ro + rd*t ,0.0), _seed_variation_).w;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o502144(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.1))*6.0),(sin(iTime*0.03)+2.0),(cos(sin(iTime*0.1))*4.0))*p_o502144_CamZoom;\n\tvec3 lookat=vec3(p_o502144_LookAtX,p_o502144_LookAtY,p_o502144_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o502144_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o502144(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o502144_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o502144_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o502144_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o502144_SunX,p_o502144_SunY,p_o502144_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o502144(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o502144(p,n, _seed_variation_),p_o502144_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o502144(p,light,0.05,5.0, _seed_variation_),p_o502144_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o502144_AmbLight)),max(l,p_o502144_AmbLight))*max(cAO,p_o502144_AmbLight)*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o502144(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=o502144_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o502144(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o502144_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o502144_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o502144_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o502144_Gamma));\n}\n\n\n\n\nvec3 shader(vec2 fragCoord){\n    \n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o502144_0_1_rgb = raymarch_o502144((UV), _seed_variation_);\n\n    return vec3(o502144_0_1_rgb);\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n//   Awesome slider lib from Good shadertoy.com/view/XtG3Rt START  //\n/////////////////////////////////////////////////////////////////////\nconst vec4 _sa=vec4(16777216.,65536.,256.,1.);const vec4 _sb=vec4\n(1./16777216.,1./65536.,1./256.,1.);vec4 _sc(int v){vec4 r=\nfloor(float(v)*_sb);r.yzw-=r.xyz*256.;return r;}float _sd(const in\nvec4 v){return dot(v,_sa);}vec4 _se(const in float v){bool n=sign(v)\n==-1.;vec4 r=floor(abs(v)*1000.*_sb);r.gba-=r.rgb*256.;if(n)r.r\n+=256.;return r;}float _sf(in vec4 v){float m=1.;if(v.r>=256.){v.r-=\n256.;m=-1.;}return dot(v,_sa)/1000.*m;}bool _sg(in vec2 p,in vec2 a)\n{return floor(p)==a;}void _sh(vec4 v,vec2 a,inout vec4 c,vec2 p){\nif(_sg(p,a))c=v;}vec4 _si(vec2 a){return texture(iChannel0,(floor(a)\n+0.5)/iChannelResolution[0].xy);}void _sj(int v,vec2 a,inout vec4 c,\nvec2 p){if(_sg(p,a))c=_sc(v);}float _sk(vec2 a){return _sd(_si(a));}\nvoid _sl(float v,vec2 a,inout vec4 c,vec2 p){if(_sg(p,a))c=_se(v);}\nfloat _sm(vec2 a){return _sf(_si(a));}float _sn(vec2 p,vec4 b){vec2\nd=abs(-b.xy-b.zw*.5 + p)-b.zw*.5;return max(d.x,d.y);}float _so(vec2\np,vec4 b,float r){vec2 s=b.zw*.5-vec2(r);vec2 d=abs(-b.xy-b.zw*.5+p)\n-s;return min(max(d.x,d.y),0.)+length(max(d,0.))-r;}float _sp\n(float n,float b){return mod(floor(n/exp2(floor(b))),2.);}float\n_sq(float n,float i){return mod(n/pow(10.,i),10.);}float _sr(int n\n,vec2 p){p=floor(p);int i=n==0?0x69996:n==1?0x62227:n==2?0xE168F:\nn==3?0xE161E:n==4?0x99711:n==5?0xF8E1E:n==6?0x68E96:n==7?0xF1244:\nn==8?0x69696:n==9?0x69716:n==10?0x00700:n==11?0x00004:0xFFFFF;return\n_sp(float(i),mod(p.y,5.)*4.+3.-p.x);}float _ss(in float v,in\nfloat f,in vec2 p,vec2 l,int z){p-=l;p/=float(z);float n=floor(p.x/\n5.);p.x-=n*5.;if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.)return\n0.;if(sign(v)<0.){if(n==0.)return _sr(10,p);n-=1.;v=abs(v);}float i\n=floor(v)==0.?1.:floor(log(v)/2.302585)+1.;float c=i+f;if(f>0.)\n{v*=pow(10.,f);}if(i<=n){if(i==n)return _sr(11,p);n-=1.;}if(c<=n)\nreturn 0.;return _sr(int(_sq(v,c-n-1.)),p);}const vec2 _st=vec2(0,4)\n;float slider(in float id,in vec4 c,in vec2 l,in vec2 j,inout vec4 q,\ninout float u){float v=_sm(vec2(id,0));vec4 g=_si(vec2(id,3));float\nk=_sk(_st);float w=_so(floor(j),vec4(l,124,20),5.);w=max(-w-2.,w);\nif(g.x==0.){v=c.x;g.x=.05;_sl(v,vec2(id,0),q,j);}if(iMouse.z<=0.){g.g\n=0.;_sh(vec4(0),_st,q,j);}else if(_sn(iMouse.xy,vec4(l,120,20))<2.&&k\n==0.){g.g=.05;_sj(int(id),_st,q,j);}else if(g.g>0.&&k==id){float h=\nclamp(iMouse.x,l.x,l.x+120.)-l.x;v=mix(c.y,c.z,h/120.);v=floor(v/c.\nw)*c.w;_sl(v,vec2(id,0),q,j);}w=min(w,_so(floor(j),vec4(l+vec2(2,2),\n120.*(v-c.y)/(c.z-c.y),16),3.));u=min(u,-_ss(v,2.,j,l+vec2(128,8)\n,1));u=min(u,w);_sh(g,vec2(id,3),q,j);return v;}\n/////////////////////////////////////////////////////////////////////\n//   Awesome slider lib from Good shadertoy.com/view/XtG3Rt END    //\n//   Minified by PauloFalcao                                       //\n/////////////////////////////////////////////////////////////////////\n\n\n\nvoid drawSliders(inout vec4 col, in vec2 sp ){\n    \n    float xp;\n    float yp;\n    \n    //Number of sliders\n    float n_sliders=9.0;\n    \n    //Aux vars\n    float ui = 0.;\n\n    //left\n    xp=20.0;\n    yp=n_sliders*25.0;  \n    //    VarName     VarId     InitVal StartVal EndVal StepVal\n    f1 = slider(1.0, vec4(0.82,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f2 = slider(2.0, vec4(0.37,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f3 = slider(3.0, vec4(0.44,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f4 = slider(4.0, vec4(0.10,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f5 = slider(5.0, vec4(0.22,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f6 = slider(6.0, vec4(0.50,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f7 = slider(7.0, vec4(0.59,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f8 = slider(8.0, vec4(0.24,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f9 = slider(9.0, vec4(0.60,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);\n\n    xp=iResolution.x-170.0;\n    yp=n_sliders*25.0;\n    //right\n    //    VarName     VarId     InitVal StartVal EndVal StepVal\n    f10 = slider(10.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f11 = slider(11.0, vec4(0.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f12 = slider(12.0, vec4(0.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f13 = slider(13.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f14 = slider(14.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f15 = slider(15.0, vec4(1.00,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f16 = slider(16.0, vec4(0.50,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f17 = slider(17.0, vec4(0.10,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);yp-=25.0;\n    f18 = slider(18.0, vec4(0.10,    0,       1,     .01    ), vec2(xp, yp), sp, col, ui);\n\n\n\n    if(sp.y > 5.){\n        col = vec4(shader(sp), 1.0);\n    }\n\n    if(sp.y > 5.){//Slider  R    G    B\n        col = mix(col, vec4(1.0, 1.0, 1.0, 1.0), clamp(-ui, 0.0, 1.0));\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 p ){\n    o = p.y <= 5.? texture(iChannel0,p.xy/iResolution.xy) : vec4(0);\n    drawSliders(o, p);   \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}