{
    "Shader": {
        "info": {
            "date": "1707486479",
            "description": "uhh... yea\n\nyour honor, my client pleads nuh uh",
            "flags": 0,
            "hasliked": 0,
            "id": "MXXGDn",
            "likes": 2,
            "name": "NUH UH",
            "published": 3,
            "tags": [
                "meme"
            ],
            "usePreview": 0,
            "username": "aerowave",
            "viewed": 92
        },
        "renderpass": [
            {
                "code": "#define REFLECTIONS\nconst float EPSILON = .0001;\nconst int MAX_STEPS = 256;\nconst float MAX_DIST = 25.0;\nconst float PI = asin(1.0) * 2.0;\n\n// gets color for given object\nvec3 albedo(vec3 p, int ID) {\n    switch (ID) {\n        case 0:\n            return vec3(0.75,0,1);\n            return vec3(mod(floor(p.x) + floor(p.y) + floor(p.z), 2.0)) * 0.5 + 0.5;\n        case 1:\n            return vec3(0.9);\n    }\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRing(in vec2 p, in vec2 n, in float r, in float th) {\n    p.x = abs(p.x);\n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n    return max(abs(length(p)-r)-th*0.5,\n               length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x));\n}\n\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\nfloat sceneSDF(vec3 p, out int ID) {\n    // floor\n    ID = 0;\n    float dist = p.y;\n        \n    // text\n    if (dist > EPSILON) ID = 1;\n    float text = 2E32;\n    \n    // N\n    text = min(text, sdBox(p.xy - vec2(-3.5, 7.5), vec2(0.5, 2.5)));\n    text = min(text, sdOrientedBox(p.xy, vec2(-6.368, 9.779), vec2(-3.632, 5.221), 1.0));\n    text = min(text, sdBox(p.xy - vec2(-6.5, 7.5), vec2(0.5, 2.5)));\n    // U\n    text = min(text, sdRing(-p.xy + vec2(0, 7), vec2(0, 1), 1.5, 1.0));\n    text = min(text, sdBox(p.xy - vec2(-1.5, 8.5), vec2(0.5, 1.5)));\n    text = min(text, sdBox(p.xy - vec2(1.5, 8.5), vec2(0.5, 1.5)));\n    // H\n    text = min(text, sdBox(p.xy - vec2(3.5, 7.5), vec2(0.5, 2.5)));\n    text = min(text, sdBox(p.xy - vec2(5, 7.5), vec2(1, 0.5)));\n    text = min(text, sdBox(p.xy - vec2(6.5, 7.5), vec2(0.5, 2.5)));\n    \n    // U\n    text = min(text, sdRing(-p.xy + vec2(-2.5, 2), vec2(0, 1), 1.5, 1.0));\n    text = min(text, sdBox(p.xy - vec2(-1, 3.5), vec2(0.5, 1.5)));\n    text = min(text, sdBox(p.xy - vec2(-4, 3.5), vec2(0.5, 1.5)));\n    // H\n    text = min(text, sdBox(p.xy - vec2(1, 2.5), vec2(0.5, 2.5)));\n    text = min(text, sdBox(p.xy - vec2(2.5, 2.5), vec2(1, 0.5)));\n    text = min(text, sdBox(p.xy - vec2(4, 2.5), vec2(0.5, 2.5)));\n    \n    \n    // clamp to 0 < z < 1\n    dist = min(dist, max(text, abs(p.z + 1.0) - 1.0));\n\n    \n    // nothing hit\n    if (dist > EPSILON) ID = -1;\n    return dist;\n}\n\n\n// idk how this one works, i stole it from iq >:)\nvec3 calcNormal(in vec3 pos) {\n    int a = 0;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sceneSDF(pos + e.xyy, a) + \n\t\t\t\t\t  e.yyx*sceneSDF(pos + e.yyx, a) + \n\t\t\t\t\t  e.yxy*sceneSDF(pos + e.yxy, a) + \n\t\t\t\t\t  e.xxx*sceneSDF(pos + e.xxx, a));\n}\n\n\n// trace a ray towards the sun\nfloat shadow( in vec3 rayOrigin, in vec3 rayDir, inout int steps) {\n    int ID = -1;\n    float res = 1.0;\n    float rayLength = 0.0;\n    while (steps < MAX_STEPS && rayLength < MAX_DIST) {\n        float dist = sceneSDF(rayOrigin + rayDir * rayLength, ID);\n        if (dist < EPSILON) {\n            return 0.0;\n        }\n        res = min( res, 16.0 * dist / rayLength);\n        rayLength += dist;\n        steps++;\n    }\n    \n    return res;\n}\n\n\n\n// Main code execution\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // centered screen coords\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    \n    vec3 cameraPos = vec3(-5.5+cos(iTime)*0.2, 1.5, 8.0+sin(iTime)*0.2);\n    vec3 rayPosition = cameraPos;\n    vec3 sunDirection = normalize(vec3(2, 1, 2));\n\n    // ray direction for fragCoord.xy... what is this code lol\n    vec3 rayDirection = normalize(vec3(q, 0.) - vec3(0,0,0.6));\n    pR(rayDirection.yz, -0.3);\n    pR(rayDirection.xz, -0.4);\n    \n    rayPosition = cameraPos;\n    float dist, rayLength = 1.0;\n    int steps = 0;\n    int ID = -1;\n    \n    // raymarch camera ray\n    while (steps < MAX_STEPS) {\n        dist = sceneSDF(rayPosition + rayDirection * rayLength, ID);\n        rayLength += dist;\n        \n        // hit\n        if (dist < EPSILON) {\n            break;\n        }\n        // render distance\n        if (rayLength > MAX_DIST) {\n            ID = -1;\n            break;\n        }\n        steps++;\n    }\n    rayPosition += rayDirection * (rayLength - EPSILON * 2.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if (ID != -1) {\n        vec3 color = vec3(0);\n        color = albedo(rayPosition, ID);\n        vec3 normal = calcNormal(rayPosition);\n        vec3 reflection = reflect(rayDirection, normal);\n        \n        color *= dot(normal, sunDirection) * 0.25 + 0.75;\n        color *= shadow(rayPosition, sunDirection, steps) * 0.5 + 0.5;\n        color += clamp(dot(reflection, sunDirection) - 0.9, 0.0, 1.0) * 2.0;\n        // apply specular color\n        finalColor += color * 0.8;\n        \n        // REFLECTION!!!\n        rayDirection = reflection;\n        #ifdef REFLECTIONS\n        dist, rayLength = 0.0;\n        while (steps < MAX_STEPS) {\n            dist = sceneSDF(rayPosition + rayDirection * rayLength, ID);\n            rayLength += dist;\n\n            // hit\n            if (dist < EPSILON) {\n                break;\n            }\n            // render distance\n            if (rayLength > MAX_DIST) {\n                ID = -1;\n                break;\n            }\n            steps++;\n        }\n        rayPosition += rayDirection * (rayLength - EPSILON * 2.0);\n        color = albedo(rayPosition, ID);\n        normal = calcNormal(rayPosition);\n        reflection = reflect(rayDirection, normal);\n        \n        color *= dot(normal, sunDirection) * 0.25 + 0.75;\n        //color *= shadow(rayPosition, sunDirection, steps) * 0.5 + 0.5;\n        color += clamp(dot(reflection, sunDirection) - 0.9, 0.0, 1.0) * 2.0;\n        // apply color\n        finalColor += color * 0.2;\n        #endif\n    }\n\n    // DEBUG: show steps\n    //finalColor = vec3(sqrt(float(steps) / (float(MAX_STEPS))));\n\n    fragColor = vec4(finalColor, 1);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "uvec2 murmurHash23(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 3 inputs\nvec2 hash23(vec3 src) {\n    uvec2 h = murmurHash23(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\n// rotate function\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}