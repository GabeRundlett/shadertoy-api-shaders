{
    "Shader": {
        "info": {
            "date": "1574736118",
            "description": "experimenting iq's swiss cheese noise, but in reverse (adding up domain repeated objects instead of subtracting from a volume)\n\ntwitch recording: https://www.twitch.tv/videos/513390770",
            "flags": 0,
            "hasliked": 0,
            "id": "tsySzd",
            "likes": 14,
            "name": "Twitch: You Are Inside A Heart",
            "published": 3,
            "tags": [
                "noise",
                "twitch",
                "liveshader"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float k) {\n  int x = FK(k);int y = FK(cos(k));\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float k) {\n  float t1 = hash(k);\n  float t2 = hash(t1);\n  float t3 = hash(t2);\n  return vec3(t1, t2, t3);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat bumps(vec3 p, float scale) {\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p)-scale*0.5;\n}\n\nfloat comp(vec3 p, vec3 off, vec3 rot) {\n  float phi = acos(rot.x);\n  float theta = rot.y * acos(-1.);\n  float lambda = rot.z * acos(-1.);\n  vec3 ax = vec3(cos(phi), sin(theta)*sin(phi), cos(theta)*sin(phi));\n  \n  p = erot(p, ax, lambda);\n  p += off;\n\n  vec3 ind = floor(p);\n  p = fract(p)-0.5;\n  p *= mod(ind,2.)*2.-1.;\n  \n  return (p.x+p.y+p.z)/sqrt(3.);\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat bpm = 60.;\n\nfloat scene(vec3 p) {\n  float dist = 100000.;\n  \n  for (int i = 0; i < 10; i++) {\n    float rnd = cos(float(i));\n    vec3 off = hash3(rnd);\n    vec3 rot = hash3(cos(rnd));\n    float str = hash(cos(cos(rnd)));\n    float d = comp(p, vec3(off)*str*iTime*0.3, vec3(rot))+0.6;\n    dist = sminCubic(dist, d, 0.5);\n  }\n  \n  float off = sin(p.x*0.5);\n  float bt = pow(abs(fract(iTime/60.*bpm + off)-0.5)*2., 2.);\n  return mix(dist, bumps(p, 0.04), 0.5*bt);\n}\n\n#define AP(f,k) vec3(f(k[0]),f(k[1]),f(k[2]))\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - AP(scene,k));\n}\n\nvec3 gam(int x,int y, int z) {\n  return pow(vec3(float(x),float(y),float(z))/float(0xff),vec3(2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 cam = normalize(vec3(0.5, uv));\n  vec3 init = vec3(0, iTime/7., 0);\n  vec3 p = init;\n  bool hit = false;\n  float sgn = 1.;\n  for (int i = 0; i < 50; i++) {\n    float dist = scene(p);\n    if (i == 0) sgn = sign(dist);\n    dist *= sgn;\n    if (abs(dist)<0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) break;\n    p += cam*dist;\n  }\n  \n  vec3 n = norm(p);\n  vec3 rf = reflect(cam,n);\n  float col1 = dot(rf, normalize(vec3(-1,-0.6,0)))*0.5+0.5;\n  float col2 = dot(rf, normalize(vec3(-1,0.5,0)))*0.5+0.5;\n  float fog = pow(exp(-distance(p, init)*0.5)/exp(0.), 2.);\n  //Corn Harvest #876310 / Blue Romance #C6F5E0\n  fragColor.xyz = sqrt(mix(gam(0x07,0x03,0x10), gam(0x87,0x63,0x10)*col2 + gam(0xC6,0xF5,0xE0)*col1, fog));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}