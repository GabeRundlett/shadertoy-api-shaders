{
    "Shader": {
        "info": {
            "date": "1598021603",
            "description": "Using a basic multiple bounce template to render a simple reflective block wall.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtffDS",
            "likes": 28,
            "name": "Reflective Block Wall",
            "published": 3,
            "tags": [
                "reflection",
                "wall",
                "template",
                "block"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 908
        },
        "renderpass": [
            {
                "code": "/*\n\n\tReflective Block Wall\n\t---------------------\n\n\tThis is a reflective block wall that I coded up a while ago in order to\n\ttest multipass reflections. At the time, it was a little on the slow side,\n\tbut the real problem was compile time. However, I've noticed lately that \n    it runs and compiles fine. I've also employed some weird tricks that IQ \n    figured out to help the compiler out.\n\n    The distance field itself and resultant visuals are nothing exciting, but \n    it's simple to use and provides the basis for a lot of the stock imagery \n    you may have seen around. The stock imagery tends to be path traced by \n    skillful artists using things like Blender, but you get the general idea. \n    By the way, I intend to produce something along those lines at some stage.\n\n\tBy the way, I'm only using one bounce in this example, because more don't \n    really improve things enough to warrant the extra calculations. However, \n    this is a working, albeit run of the mill, multipass template. I have a \n    few reflective\\refractive examples that I'll post at some stage also.\n\n   \n    Other examples:\n\n\t// Simple and pretty.\n    Infinite Pinballs - BradyInstead\n\thttps://www.shadertoy.com/view/3ssfW8\n\n    // Elegant op art style -- I have things along these lines \n    // that I might post later.\n    Reflection of a stripy room - bencoder\n    https://www.shadertoy.com/view/wtyXRG\n\n*/\n\n// Far plane, or max ray distance.\n#define FAR 40.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// Global block scale.\n#define GSCALE vec2(1./6.)*vec2(2, 1)\n\n// Block arrangement: Adjusts the cell offset for each row to give three different patterns.\n// 0 - No offset, 1 - Half cell offset, 2 - Quarter cell offset.\n#define ARRANGEMENT 1\n\n// Display the trimmings.\n#define SHOW_TRIMMINGS\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D tex, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(tex, fract(p/4. + .5)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel1, p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Hacked in at the last minute to differentiate between the block and\n// the metallic trimmings.\nfloat blockPartID;\n\nvec4 blocks(vec3 q){\n\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = GSCALE;//vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block central postions.\n    //const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    #if ARRANGEMENT == 0\n    // No X offset.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    #elif ARRANGEMENT == 1\n    // Offset by half a cell width to produce a conventional brick pattern.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(1, -.5), vec2(0, -.5));\n    #else\n    // Offset by quarter a cell width to produce a staggered pattern.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5 + .5/2., -.5), vec2(-.5 + .5/2., -.5));\n    #endif\n    \n    float height = 0.; // Block height initialization.\n    \n    blockPartID = 0.; // Block part ID initialization.\n    \n    // Height scale.\n    const float hs = .125;\n\n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0]/2.;\n        \n        #if ARRANGEMENT == 2\n        // Moving each row a quarter of a cell width to produce a staggered pattern.\n        //cntr.x -= mod(floor((q.y/s.y - cntr.y)), 2.)/4.;\n        cntr.x -= floor((q.y/s.y - cntr.y))/4.;\n        #endif\n        \n        // Local coordinates.\n        p = q.xy;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n        \n        p -= idi; // New local position.\n\n  \n        // Face block. \n        float h1 = hm(idi);\n        h1 = floor(h1*7.999)/7.; // Discreet heights.\n        h1 *= hs;\n        float face1 = sBoxS(p, dim/2. - .02*dim.x, .02);\n        float face1Ext = opExtrusion(face1, (-q.z - h1), h1, .005); \n\n        \n        #ifdef SHOW_TRIMMINGS\n        \n        // Cylinder center.\n        float face2Ext = opExtrusion(length(p) - .016, (-q.z - h1 - .008), h1 + .008, .005);\n        \n        // Trimming.\n        vec2 tr = vec2(face1 + .005/2., (-q.z - h1*2. - .005));\n        face2Ext = min(face2Ext, length(tr) - .005);\n        \n        // Face warp... I didn't like it, but I might revisit at some stage.\n        //face1Ext += -max(face1, -.02)*.4 + face1*.2;\n        \n        // Cell object ID.\n        float blPtID = face1Ext < face2Ext? 0. : 1.;\n        \n        // Minimum distance.\n        face1Ext = min(face1Ext, face2Ext);\n        #else\n        float blPtID = 0.;\n        #endif\n        \n        \n        \n        vec4 di = vec4(face1Ext, idi, h1);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box height. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            blockPartID = blPtID;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, height);\n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Reflecting the wall opposite to give the light something to relect off of.\n    p.z =  abs(p.z - .25) - .75;\n    \n    // Wall behind the pylons to stop the light getting through.\n    float wall = -p.z  + .01;\n    \n \n    // Blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n\n \n    // Overall object ID.\n    objID = wall<d4.x? 1. : 0.;\n    \n    // Combining the wall with the extruded blocks.\n    return min(wall, d4.x);\n \n}\n\n\n// Basic raymarcher.\nfloat trace(vec3 ro, vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.5 : d*.9; // Slower, but more accuracy.\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nfloat fBm(vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    p.x += iTime/2.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c*c); // Bluish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/4. - .5*.3*cos(iTime/2.)*0., -.5*.2*sin(iTime/2.)*0., -.0); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.02, .01, .1);//vec3(0, -.25, iTime);  \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1, .25); // Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n    \n   \n    \n    float alpha = 1.;\n    \n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        // Used for refractions, but not here.    \n        //float distanceFactor = 1.;\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd);\n\n        // Saving the object ID, block ID and cell object (block part) ID.\n        float svObjID = objID;\n        vec3 svGID = gID;\n        float svBPID = blockPartID;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp);// *distanceFactor; // For refractions.\n            \n            // Texture size factor.\n            float sz0 = 2.;\n           \n            /* \n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel0, sp*sz0, sn, .0007);///(1. + t/FAR)\n            vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            if(j == 0) gSh = softShadow(sp, lp, sn, 12.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + ao*.25, 1.); // Adding a touch of light to the shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 32.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            \n            dif = pow(dif, 4.)*2.; // Ramping up the diffuse.\n\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n      \n            // Object color.\n            vec3 oCol;\n            \n             \n            if(svObjID == 0.) {\n\n                // Block coloring.\n                vec3 tx = tex3D(iChannel0, sp*sz0, sn);\n                vec3 tx2 = getTex(iChannel1, svGID.xy);\n                tx = smoothstep(0., .5, tx);\n                tx2 = smoothstep(0., .5, tx2);\n                \n                if(svBPID == 1.) {\n                    // Trimming coloring and reflective power.\n                    oCol = tx*vec3(1, .9, .7);\n                    objRef = .35;\n                    \n                }\n                else {\n                    // Face coloring and reflective power.\n                    oCol = tx2*tx*2.5;\n                \tobjRef = .25;\n                }\n                \n                /*\n                // Edge coloring, but has been replaced by trimming.\n                // Needs to match the box function inside the distance field.\n                const vec2 scale = GSCALE;\n                float fdf = sBoxS(sp.xy - svGID.xy, scale/2. - .02*scale, .02);\n                 \n                // The ring that surrounds the face edges.\n                const float th = .0025;\n                float fdfR = max(abs(fdf + th/2.), abs((sp.z + svGID.z*2.) - 1.)) - th;// \n                oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .01, fdfR))*.25);\n                */\n                \n            }\n            else {\n                // Dark wall behind the tiny gaps in the blocks. \n                oCol = vec3(0);\n                objRef = .0;\n            }\n\n            colL = oCol*(dif + .125 + vec3(1, .5, .3)*spe*4. + vec3(1, .4, .2)*pow(freS, 4.)*0.);\n            \n            // Optional environmental mapping. Not used.\n            //vec3 envCol = envMap(reflect(rd, sn)).zyx;\n            //colL += colL*envCol*3.;\n            \n            colL *= sh*ao*att;\n\n            // Used for refraction, but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        col = mix(col, colL, 1./float(1 + j)*alpha);\n        // In you face additive blend. Sometimes, I prefer this.\n        //col += colL*alpha;\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}