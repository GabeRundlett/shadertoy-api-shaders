{
    "Shader": {
        "info": {
            "date": "1590068902",
            "description": "Big (Rubik's Revenge) or small cubes; each shuffle is different (only pretending to solve)",
            "flags": 0,
            "hasliked": 0,
            "id": "3djfWW",
            "likes": 10,
            "name": "Big Rubik Pseudosolver",
            "published": 3,
            "tags": [
                "cube",
                "puzzle"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 462
        },
        "renderpass": [
            {
                "code": "// \"Big Rubik Pseudosolver\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SIZE4  1  // =1 for 4^3 cube; =0 for 3^3\n\n#define AA     0  // optional antialiasing\n\nmat3 VToRMat (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashff (float p);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 vuMat;\nvec2 qBlk;\nfloat tCur, dstFar, bSize, rSeed;\nconst float pi = 3.1415927;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 p, mat3 m)\n{\n  vec3 rdm, v, tm, tp, u, fcBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  rdm = m * rd;\n  v = (m * ro - p) / rdm;\n  tp = bSize / abs (rdm) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < min (df, dMin)) {\n    dMin = dn;\n    fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rdm;\n  }\n  if (dMin < dstFar) {\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\n#if SIZE4\nconst float nbE = 4.;\nconst float nTwist = 28.;\n#else\nconst float nbE = 3.;\nconst float nTwist = 22.;\n#endif\n\nmat3 RotSeq (vec3 bId, float nt, float aRot)\n{                     // Derived rotation matrix sequence from Kali's \"Rubik\"\n  mat3 rMat, m;\n  vec3 ax[3], vSlice;\n  vec2 e;\n  float s, sa;\n  e = vec2 (1., 0.);\n  ax[0] = e.xyy;\n  ax[1] = e.yxy;\n  ax[2] = e.yyx;\n  rMat = mat3 (e.xyy, e.yxy, e.yyx);\n  for (float n = float (VAR_ZERO); n < nTwist; n ++) {\n    if (n > nt) break;\n    s = mod (n + floor (6. * Hashff (99. + rSeed)), 6.);\n    sa = sign (s - 2.5);\n    s = mod (s, 3.);\n    vSlice = (s == 0.) ? e.xyy : ((s == 1.) ? e.yxy : e.yyx);\n    if (length ((bId + 0.5 * (nbE + 1.)) * vSlice) - 1. == floor (nbE * Hashff (n + rSeed))) {\n      m = VToRMat (sa * ((s == 0.) ? ax[0] : ((s == 1.) ? ax[1] : ax[2])),\n         0.5 * pi * ((n < nt) ? 1. : aRot));\n      for (int k = 0; k < 3; k ++) ax[k] = m * ax[k];\n      rMat = m * rMat;\n      if (n < nt) bId = VToRMat (sa * vSlice, -0.5 * pi) * bId;\n    }\n  }\n  return rMat;\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatH;\n  vec4 col4, bs4;\n  vec3 col, vn, ltDir, fcBlk, bId, bidH, cc[6], de3, ld, bLab;\n  vec2 qBlkH, de;\n  float dstBlk, dstSphr, d, nt, tCyc, shSpd, tWait, aRot, dSum, sSum, bMin;\n  cc[0] = vec3 (1., 0.2, 0.2);\n  cc[1] = vec3 (1., 0.4, 0.2);\n  cc[2] = vec3 (0.2, 0.2, 1.);\n  cc[3] = vec3 (0.2, 1., 0.2);\n  cc[4] = vec3 (1., 1., 0.2);\n  cc[5] = vec3 (1., 1., 1.);\n  bSize = 0.48;\n  shSpd = 10.;\n  tWait = 3.;\n  tCyc = (nTwist + tWait) * (1. + 1. / shSpd) + tWait;\n  nt = nTwist - max (0., mod (tCur, tCyc) - tWait);\n  if (nt + tWait < 0.) nt = - shSpd * (nt + tWait);\n  aRot = smoothstep (0.1, 0.9, max (0., fract (nt) * sign (nt)));\n  nt = max (0., floor (nt));\n  rSeed = 17.77 * floor ((tCur + (nTwist + tWait) / shSpd + tWait) / tCyc + 1.);\n  bMin = 0.5 * (nbE - 1.) - 0.5;\n  bLab = vec3 (0., 0., -1.);\n  if (nbE == 4.) bLab -= 0.5;\n  dstBlk = dstFar;\n  for (float j = float (VAR_ZERO); j < nbE * nbE * nbE; j ++) {\n    bId = vec3 (mod (j, nbE), mod (floor (j / nbE), nbE), floor (j / (nbE * nbE))) - 0.5 * (nbE - 1.);\n    if (Maxv3 (abs (bId)) > bMin) {\n      rMat = RotSeq (bId, nt, aRot);\n      bs4 = BlkHit (ro, rd, bId, rMat);\n      d = bs4.x;\n      if (d < dstBlk) {\n        dstBlk = d;\n        fcBlk = bs4.yzw;\n        rMatH = rMat;\n        qBlkH = qBlk;\n        bidH = bId;\n      }\n    }\n  }\n  bs4 = SphHit (ro, rd, (nbE - 0.2) * bSize);\n  dstSphr = bs4.x;\n  if (min (dstBlk, dstSphr) < dstFar) {\n    if (dstBlk < dstSphr) {\n      ro += dstBlk * rd;\n      de = smoothstep (-0.08, 0., abs (qBlkH.xy) - bSize);\n      de3 = vec3 (0.25 * pi * de * sign (qBlkH.xy), 0.);\n      vn = normalize (fcBlk + ((fcBlk.x != 0.) ? de3.zxy : ((fcBlk.y != 0.) ? de3.xzy : de3))) * rMatH;\n      if (length (max (abs (qBlkH) - bSize + 0.12, 0.)) < 0.07) {\n        if (abs (bidH.x) > bMin && sign (bidH.x) == fcBlk.x ||\n            abs (bidH.y) > bMin && sign (bidH.y) == fcBlk.y ||\n            abs (bidH.z) > bMin && sign (bidH.z) == fcBlk.z) {\n          if      (abs (fcBlk.x) == 1.) col4.rgb = (fcBlk.x > 0.) ? cc[0] : cc[1];\n          else if (abs (fcBlk.y) == 1.) col4.rgb = (fcBlk.y > 0.) ? cc[2] : cc[3];\n          else if (abs (fcBlk.z) == 1.) col4.rgb = (fcBlk.z > 0.) ? cc[4] : cc[5];\n          col4 = vec4 (mix (col4.rgb, vec3 (0.2, 0.2, 0.2), max (de.x, de.y)), 0.2);\n        } else {\n          col4 = vec4 (0.1, 0.1, 0.1, 0.);\n        }\n        if (bidH == bLab && sign (bidH.z) == fcBlk.z)\n           col4 *= 1. - 0.6 * smoothstep (-0.05, 0., LabSym (-16. * (vec2 (0.5, 0.5) * bSize + qBlkH.yx)));\n      } else {\n        col4 = vec4 (0.2, 0.2, 0.2, 0.2);\n      }\n    } else if (dstSphr < dstFar) {\n      ro += dstSphr * rd;\n      vn = bs4.yzw;\n      col4 = vec4 (0.1, 0.1, 0.1, 0.);\n    }\n    dSum = 0.;\n    sSum = 0.;\n    ltDir = normalize (vec3 (1., 1., -0.6));\n    for (int j = 0; j < 4; j ++) {\n      ltDir.xy = Rot2D (ltDir.xy, 0.5 * pi);\n      ld = vuMat * ltDir;\n      dSum += pow (max (dot (vn, ld), 0.), 1.5);\n      sSum += pow (max (dot (normalize (ld - rd), vn), 0.), 32.);\n    }\n    col = col4.rgb * (0.2 + 0.5 * dSum) + col4.a * sSum;\n    col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  } else {\n    col = vec3 (0.6);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.04 * pi * tCur;\n    el -= 0.07 * pi * (1. + sin (0.05 * pi * tCur));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10. * nbE / 3.);\n  zmFac = 3.7;\n  dstFar = 100.;\n  if (length (uv) < 0.99) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = mix (vec3 (0.6), vec3 (0.82), smoothstep (0., 0.1, length (uv) - 0.99));\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}