{
    "Shader": {
        "info": {
            "date": "1380494400",
            "description": "A wonderful place to explore. The structure is very repetitive and regular, I didn't add any big scale variation cause I didn't expect to move the camera in this one, but focus in this one shot. It runs slow too, I'll try to optimize it later.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsfGD4",
            "likes": 215,
            "name": "Woods",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 31086
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n#define LIGHTRIG 1 // 0 or 1\n//#define GODRAYS\n//#define HIGH_QUALITY_NOISE \n\n//==============================================================================\n\nfloat hash( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*13.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nvec2 hash2( vec2 x )\n{\n\tfloat n = dot(x,vec2(1.0,113.00));\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\n\n#ifndef HIGH_QUALITY_NOISE \nfloat noise( in vec2 x )\n{\n\t//return texture( iChannel0, (x+0.5)/256.0 ).x;\n\n\tvec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, -0.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n#else\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tf =  f*f*(3.0-2.0*f);\n\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n\n\treturn mix( mix( a, b, f.x ), mix( c, d, f.x ), f.y );\n\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rga = textureLod( iChannel0, (uv+vec2(0.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rgb = textureLod( iChannel0, (uv+vec2(1.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rgc = textureLod( iChannel0, (uv+vec2(0.5,1.5))/256.0, 0.0 ).yx;\n\tvec2 rgd = textureLod( iChannel0, (uv+vec2(1.5,1.5))/256.0, 0.0 ).yx;\n\t\n\tvec2 rg = mix( mix( rga, rgb, f.x ),\n\t\t\t\t   mix( rgc, rgd, f.x ), f.y );\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat fbm( in vec3 p )\n{\n    return 0.5000*noise(p*1.0)+\n           0.2500*noise(p*2.0)+\n           0.1250*noise(p*4.0)+\n           0.0625*noise(p*8.0);\n}\n\nfloat fbm( in vec2 p )\n{\n    return 0.5000*noise(p*1.0)+\n           0.2500*noise(p*2.0)+\n           0.1250*noise(p*4.0)+\n           0.0625*noise(p*8.0);\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy.yx ).xyz;\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n#define ZERO (min(iFrame,0))\n\n//==============================================================================\n\nfloat treeBase( vec2 pos )\n{\n\tfloat chsca = 0.2;\n\tvec2 chos = fract(chsca*pos) - 0.5;\n\treturn length( chos );\n}\t\n\nfloat terrain( vec2 pos )\n{\n\tfloat h = 12.0*fbm( pos*0.1 );\n\t\n\tfloat r = treeBase( pos );\n\tr = max(0.0,r-0.1);\n\tfloat ar = 1.0*exp( -50.0*r*r );\n\t\n\treturn h + ar;\n}\n\nvec2 grassDistr( in vec2 pos )\n{\n\tfloat f = fbm( pos );\n    return vec2( smoothstep( 0.45, 0.55, f ), smoothstep(0.4, 0.75, f) );\n}\n\nfloat mushroomAnim( float t )\n{\n    float f = sin( 0.5*t );\t\t\n\t\n\tf = -1.0 + 2.0*smoothstep( 0.45, 0.55, 0.5 + 0.5*f );\n\t\n\treturn 1.0 + 0.1*f;\n}\n\t\nfloat map( in vec3 pos, out vec4 suvw, out float info )\n{\n    float dis;\n\t\n\t//-----------------------------\n\t// terrain\n\tfloat h = terrain( pos.xz );\n\tfloat mindist = pos.y - h;\n\n\tfloat t = treeBase( pos.xz );\n\tfloat treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);\n\tsuvw = vec4( 0.0, 0.0, 0.0, treeOcc );\n\n\t// grass\n\tvec2 gd = grassDistr(pos.xz);\n\tfloat hi = 1.0*clamp( 2.0*textureLod( iChannel0, pos.xz, 0.0 ).x, 0.0, 1.0 );\n\tfloat g = 0.2*hi * (gd.x * gd.y);\n    mindist -= g;\n\n\n\t// mushroom position\t\n\tfloat mushSca = 2.0;\n\tvec2  mushWPos = (0.5+floor(mushSca*pos.xz))/mushSca;\n\tvec3  mushPos = vec3( fract(mushSca*pos.x)-0.5, mushSca*(pos.y-h), fract(mushSca*pos.z)-0.5 );\n    float mushID  = hash( floor(mushSca*pos.xz) );\n\tfloat mushToTree = treeBase(mushWPos);\n\t\n\tfloat sh = 0.2 * (0.5 + 1.0*mushID);\n\t\n\tsuvw.w *= mix( 0.33 + 0.67*clamp( (length( mushPos.xz )-sh)*5.0, 0.0, 1.0 ), 1.0, 1.0*smoothstep( 0.35, 0.45, mushToTree + 0.5*(gd.x * gd.y) ) );\n\tsuvw.w *= mix( smoothstep( 0.5, 1.0, hi ), 1.0, 1.0-gd.x );\n\tsuvw.w *= 0.2 + 0.8*clamp( 2.0*abs(gd.x-0.5), 0.0, 1.0 );\n\t\n\t//-----------------------------\n\t// trees\n\t{\n\tfloat chsca = 0.2;\n\tvec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );\n\tfloat y = chos.y;\n\tfloat r = length( chos.xz );\n\t\t\n\tfloat ss = exp(-40.0*y*y);\n\tfloat dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );\n\tfloat sh = 0.08 + (0.1+0.25*ss)*dd;\n\t\t\n    dis = (r - sh)/chsca;\n\tif( dis<mindist )\n\t{\n\t\tmindist = dis;\n\t\tsuvw.x = 1.0;\n\t\tsuvw.y = y;\n\t\tsuvw.z = smoothstep( 0.0, 1.0, dd );\n\t\tsuvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);\n\t\tinfo = atan( chos.x, chos.z );\n\t}\t\t\n\t\t\n\t}\n\t\n\t//-----------------------------\n\t// mushrooms\n\tif( mushToTree < 0.4)\n\t{\n    float an = mushroomAnim( iTime*(1.0+mushID) + 6.28*mushID );\t\t\n\n\tfloat y = mushPos.y - 0.2 * 0.5;\n\tfloat r = length( vec3(mushPos.xz,y*2.0) );\n\tfloat sh = 0.2 * (0.5 + 1.0*mushID);\n    sh *= an;\t\t\n    dis = (r - sh)/mushSca;\n\tif( dis<mindist )\n\t{\n\t\tmindist = dis;\n\t\tsuvw.x = 2.0;\n\t\tsuvw.y = mushID;\n\t\tsuvw.z = mushPos.x / an;\n\t\tsuvw.w = clamp( 0.5 + 0.5*y/.1, 0.0, 1.0 ) * treeOcc;\n\t\tinfo = mushPos.z / an;\n\t}\t\t\n\t\t\n\t}\n\n\n\t\n    return mindist * 0.5;\n}\n\n\nfloat map2( in vec3 pos )\n{\n    float dis;\n\t\n\t//-----------------------------\n\t// terrain\n\tfloat h = terrain( pos.xz );\n\tfloat mindist = pos.y - h;\n\n\t// grass\n\tvec2 gd = grassDistr(pos.xz);\n\tfloat g = 0.2*(gd.x * gd.y);\n    mindist -= g;\n\n\n\t// mushroom position\t\n\tfloat rockSca = 2.0;\n\tvec2  rockWPos = (0.5+floor(rockSca*pos.xz))/rockSca;\n\tvec3  rockPos = vec3( fract(rockSca*pos.x)-0.5, rockSca*(pos.y-h), fract(rockSca*pos.z)-0.5 );\n    float  rockID  = hash( floor(rockSca*pos.xz) );\n\tfloat rockToTree = treeBase(rockWPos);\n\t\n\tfloat sh = 0.2 * (0.5 + 1.0*rockID);\n\t\n\t\n\t//-----------------------------\n\t// trees\n\t{\n\tfloat chsca = 0.2;\n\tvec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );\n\tfloat y = chos.y;\n\tfloat r = length( chos.xz );\n\t\t\n\tfloat ss = exp(-40.0*y*y);\n\tfloat dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );\n\tfloat sh = 0.08 + (0.1+0.25*ss)*dd;\n\t\t\n    dis = (r - sh)/chsca;\n\tmindist = min( dis, mindist );\n\t\t\n\t}\n\t\n\t//-----------------------------\n\t// mushrooms\n\tif( rockToTree < 0.4)\n\t{\n\tfloat y = rockPos.y - 0.2 * 0.5;\n\tfloat r = length( vec3(rockPos.xz,y*2.0) );\n\tfloat sh = 0.2 * (0.5 + 1.0*rockID);\n    sh *= mushroomAnim( iTime*(1.0+rockID) + 6.28*rockID );\n    dis = (r - sh)/rockSca;\n\tmindist = min( dis, mindist );\n\t\t\n\t}\n\n\n\t\n    return mindist;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec4 kk;\n\tfloat kk2;\n#if 0    \n    float eps = 0.01;\n\tfloat ref = map(pos,kk,kk2);\n\tvec3 nor = vec3( map( vec3(pos.x+eps, pos.y, pos.z), kk, kk2 ) - ref,\n                     map( vec3(pos.x, pos.y+eps, pos.z), kk, kk2 ) - ref,\n                     map( vec3(pos.x, pos.y, pos.z+eps), kk, kk2 ) - ref );\n\treturn normalize( nor );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*0.01,kk,kk2);\n    }\n    return normalize(n);\n#endif    \n    \n    \n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 suvw, out float info )\n{\n    const float maxd = 50.0;\n\tfloat precis = 0.01;\n    float h = 1.0;\n    float t = 0.0;\n    suvw = vec4(0.0);\n\tinfo = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h  = map( ro+rd*t, suvw, info );\n        t += h*min(0.25+0.15*t,1.0);\n    }\n\n\tif( t>maxd ) { t=-1.0; suvw=vec4(512.0); }\n    return t;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k, float l )\n{\n    float res = 1.0;\n    float t = 0.1;\n\tvec4 kk;\n\tfloat kk2;\n\tfloat h = 1.0;\n\n\tfor( int i=0; i<38; i++ )\n    {\n\t\th = map2( ro + rd*t );\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.001, 0.3 );\n\t\tif( h<0.0001 ) break;\n    }\n\t\n#ifdef GODRAYS\n    // fake leaves shadow\t\n\tvec3 pp = ro - rd*dot(rd,ro);\n\tres *= mix( 1.0, smoothstep( 0.3, 0.5, texture(iChannel2,2.0*pp.zx).x ), 0.5+0.5*l );\n#endif\t\n    return clamp(res,0.0,1.0);\n}\n\nvec4 lpos[7];\n\n\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, float matID, in vec3 uvw, in float info, in vec3 sunDirection )\n{\n\t\n    vec3 rgb = vec3(0.0);\n\t\n    // ground\n    if( matID<0.5 )\n    {\n\t\tfloat f = grassDistr( pos.xz ).x;\n\t\t\t\n\t\tfloat rs = 1.5;\n\t\tvec3 stones = texture(iChannel3,rs*pos.xz).xyz;\n\t\tvec3 nnoise = texture( iChannel1, pos.xz*0.5 ).xyz;\n\n        // dirt\n \t\tvec3 ground = vec3(0.04,0.03,0.01);\n\t\tground *= 0.33 + 1.25*nnoise.x;\n\t\tground = mix( ground, ground+0.02, smoothstep( 0.2, 0.5, stones.x ) );\n\n\t\t// frass\n\t\tvec3 grass = vec3(0.1,0.1,0.0);\n        // color variation\t\t\n\t\tgrass += 0.015*sin( nnoise.x*10.0 + vec3(0.0,1.0,2.0) );\n        // flowers\t\t\n\t\tfloat fl = smoothstep( 0.5, 0.6, texture(iChannel3,10.0*pos.xz).z ) ;\n\t\tfl *= smoothstep( 0.3, 0.35, nnoise.z );\n\t\tgrass = mix( grass, vec3(0.4,0.3,0.1), fl );\n\t\t\n\t\trgb = mix( ground, grass, f );\n\t\t\n\t\trgb *= 0.3 + 0.7*texture( iChannel2, pos.xz*2.0 ).x;\n\t\t\n        //bump\t\t\n\t\tnor.x -= (1.0-f)*1.0*(smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz+vec2(0.05,0.0)).x) - smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz-vec2(0.05,0.0)).x));\n\t\tnor.z -= (1.0-f)*1.0*(smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz+vec2(0.0,0.05)).x) - smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz-vec2(0.0,0.05)).x));\n\t\tnor = normalize( nor );\n    }\n\t// trees\n    else if( matID<1.5 )\n    {\n        rgb = vec3(0.35,0.1,0.0);\n\t\t\n\t\trgb = mix( rgb*0.15, vec3(0.2,0.12,0.03), smoothstep( 0.0, 1.0, uvw.y ) );\n\t\t\n\t\tfloat tt = texturize( iChannel1, 1.5*pos*vec3(1.0,0.5,1.0), nor ).x;\n\t\trgb *= 0.2+1.5*tt;\n\t\t\n\t\ttt = texturize( iChannel1, 0.03*pos, nor ).x;\n\t\t\n\t\tfloat ff = texturize( iChannel1, 1.5*pos, nor ).x;\n\t\tfloat green = (1.0-smoothstep(0.0, 0.5, uvw.x*4.0 - tt + 0.1));\n\t\trgb = mix( rgb, 2.4*vec3(0.045,0.05,0.00)*ff, 0.8*green );\n\t\t\n\t\t// bump\n\t\tvec2 cuv = vec2( uvw.x*3.0, info );\n\t\tfloat bu = 0.0;\n\t\tbu = 0.5 + 0.25*green;\n\t\tnor = normalize( nor + bu * (-1.0 + 2.0*texture( iChannel0, cuv ).xyz) );\n\t}   \n    // mushrooms\n    else if( matID<2.5 )\n    {\n        // base color\t\t\n\t\tvec3 tcol = mix( vec3(0.1,0.01,0.00), vec3(0.14,0.04,0.0), pow( clamp(1.0+dot(rd,nor),0.0,1.0), 2.0 ) );\n\t\t\n        // color variation\t\t\n\t\ttcol += 0.03*sin( uvw.x*10.0 + vec3(0.0,1.0,2.0) );\n\t\t\n\t\t// white\n        vec2 uv = vec2(uvw.y,info);\n\t\tvec2 iuv = floor(uv*9.0);\n\t\tvec2 fuv = fract(uv*9.0 );\n\t\tuv = fuv - 0.5 + 0.25*(-1.0+2.0*hash2( iuv ));\n\t\tuv *= 0.5 + 0.5*hash( iuv );\n\t\tfloat f = 1.0 - smoothstep( 0.1, 0.3, length( uv ) );\n\t\tf *= smoothstep( 0.3, 0.31, hash( iuv.yx*1.3 ) );\n\t\tf *= smoothstep( 0.4, 0.5, nor.y );\n\t\trgb = mix( tcol, vec3(0.23,0.21,0.19), f );\n\n\n\t\t//float an = clamp(0.5 + 0.5*(mushroomAnim( iTime*(1.0+uvw.x) + 6.28*uvw.x )-1.0)/0.1,0.0,1.0);\n        //rgb *= 0.25 + 2.5*an*vec3(1.0,0.7,0.5);\n\t\t\n\t\trgb *= 0.9;\n\t}\n\t\n\t// lighting terms\n\tfloat occ = uvw.z;\n\tfloat sha = softshadow( pos, sunDirection, 64.0, 0.0 );\n    float sun = clamp( dot( nor, sunDirection ), 0.0, 1.0 );\n    float sky = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n    float ind = clamp( dot( nor, normalize(sunDirection*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0 ), 5.0 );\n\t\n\tfloat spe = pow( clamp( dot( reflect( rd, nor ), sunDirection ), 0.0, 1.0 ), 16.0 );\n\t\n    // compute lighting\n    vec3 lin  = 3.5*sun*vec3(1.75,1.30,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n         lin += 2.5*sky*vec3(0.82,0.75,0.50)*occ;\n         lin += 1.1*ind*vec3(0.30,0.35,0.25)*occ;\n         lin += 6.0*spe*sha*(0.5+0.5*fre);\n         lin *= 1.0 + 1.0*fre*occ*vec3(1.5,1.0,0.5);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 lig = lpos[i].xyz - pos;\n        float llig = dot(lig,lig);\n        float im = inversesqrt( llig );\n        lig = lig * im;\n\t\tlin += vec3(1.0,0.5,0.2)*1.5*lpos[i].w * clamp(dot(lig,nor),0.0,1.0)*im*im*occ;\n\t}\n\t\t\t\n\treturn rgb * lin * 1.3;\n}\n\n\nvoid moveLights( void )\n{\n\n    for( int i=0; i<7; i++ )\n\t{\n\t\tvec3 pos;\n\t    pos.x = 3.2*cos(0.0+0.08*iTime*2.0 + 17.0*float(i) );\n\t    pos.z = 3.2*cos(1.65+0.07*iTime*2.0 + 13.0*float(i) );\n\t    pos.y = terrain( pos.xz ) + 0.4;\n\t\t\n\t\t// make the lights avoid the trees\n\t    vec2 chos = 2.5 + 5.0*floor( pos.xz/5.0);\n\t    float r = length( pos.xz - chos);\n\t    pos.xz = chos + max( r, 1.5 )*normalize(pos.xz-chos);\n\t\t\n\t\tlpos[i].xyz = pos;\n\t\tlpos[i].w = smoothstep(5.0,10.0,iTime)*(0.85 + 0.15*sin(25.0*iTime+ 23.1*float(i)));\n\t}\n}\n\nfloat doFirefly( in vec3 ro, in vec3 rd, in float t, in vec3 lpo, in float ra )\n{\n\tfloat h = 0.0;\n\tvec3 lv = ro - lpo;\n\tfloat ll = dot(lv,lv);\n    if( ll < (t*t) ) // depth comparison\n    {\n\t\tfloat b = dot(rd,lv);\n\t\tfloat c = ll - ra;\n\t\th = max(b*b-c,0.0)/ra;\n        h = h*h*h*h;\n    }\n\treturn h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    \n\tp.y *= iResolution.y/iResolution.x;\n\n    vec2 m = vec2(0.5); if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    // animate\t\n\tmoveLights();\n\t\t\n    // camera\n\tfloat an = 7.5 + 0.0*0.2*sin(0.05*(iTime-10.0)) - m.x*3.0;\n\n    vec3  ro = vec3( 5.0*sin(an), 0.0, 5.0*cos(an));\n    vec3  ta = vec3( 0.0, 8.5, 0.0 );\n\tro.y = terrain( ro.xz ) + max( 0.25, 1.0 - 2.0*(m.y-0.5) );\n\t//ro.y = 8.3;\n\tta.y = terrain( ta.xz ) - 0.0;\n\t\n    vec3  ww = normalize( ta - ro );\n    vec3  uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3  vv = normalize( cross(uu,ww));\n    vec3  rd = normalize( p.x*uu + p.y*vv + 1.11*ww );\n\n\tvec3 col = vec3(0.0);\n\n    // ray march scene\n\tvec4 suvw;\n\tfloat info;\n\tfloat t = intersect( ro, rd, suvw, info );\n\n    #if LIGHTRIG==0\n\tvec3 sunDirection = normalize( vec3(-0.1,0.5,-0.6) );\n\t#else\n\tvec3 sunDirection = normalize( vec3(0.4,0.4,-0.05) );\n    #endif\n\n\tif( t>0.0 )\n\t{\n\t    vec3 pos = ro + t*rd;\n\t    vec3 nor = calcNormal( pos );\n\n        #if LIGHTRIG==0\n\t\tcol = shade( pos, nor, rd, suvw.x, suvw.yzw, info, sunDirection );\n\t\t#else\n  \t    // super trick\n        vec3 sunDirectionA = normalize( vec3(0.54,0.1,0.0) );\n\t\tvec3 fakeSunDirection = normalize( mix(sunDirection,sunDirectionA,smoothstep(2.0,4.0,t)));\n\t\tcol = shade( pos, nor, rd, suvw.x, suvw.yzw, info, fakeSunDirection );\n        #endif\n\n\t}\n    else\n\t{\n\t\tt = 1e10;\n\t}\t\t\n\n    // fog\t\n    col = mix( col, vec3(0.20,0.15,0.05), 1.0 - exp(-0.0007*t*t) );\n\n    // godrays (only Linux)\t\n\t#ifdef GODRAYS\n\tfloat v = 0.0;\n\tfloat s = 0.5 + 0.15*texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy ).x;\n\tfor( int i=ZERO; i<32; i++ )\n    {\n\t\tif( s>t ) continue;\n\t\tvec3 pos = ro + rd*s;\n\t\tfloat h = softshadow( pos, sunDirection, 32.0, 1.0 );\n\t\tv += h * exp(-0.2*s);\n\t\ts += 0.15;\n\t}\n\tv /= 32.0;\n\t#if LIGHTRIG==1\n\tfloat vm = 2.0;\n\t#else\n\tfloat vm = 1.0;\n\t#endif\n    col += vm*v*v*vec3(1.0,0.75,0.4);\n    #endif\t\n\t\t\n\t\n\t\n\t\n\t// iluminating fireflies\n\tfor( int i=0; i<7; i++ )\n\t{\n\t\tcol += 3.0*vec3(1.0,0.3,0.05)*lpos[i].w*doFirefly( ro, rd, t, lpos[i].xyz, 0.05 );\n    }\n\n\t// non iluminating fireflies\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tvec3 rrr = 1.5*sin( hash3(float(i)) + float(i)*vec3(1.2,1.1,1.7) + vec3(0.0,1.0,2.0) + 0.01*iTime);\n\t\tfloat br = 0.5 + 0.5*sin(2.0*iTime+ 23.1*float(i));\n\t\t\n\t\tcol += vec3(1.0,0.7,0.3)*br*doFirefly( ro, rd, t, rrr.xyz*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,2.0), 0.0017 );\n\t\tcol += vec3(1.0,0.7,0.3)*br*doFirefly( ro, rd, t, rrr.yzx*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,2.0), 0.0017 );\n\t\tcol += vec3(1.0,0.7,0.3)*br*doFirefly( ro, rd, t, rrr.zxy*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,2.0), 0.0017 );\n\t}\n\n\t// gamma\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    // contrast\t\n    col = col*0.7 + 0.3*col*col*(3.0-2.0*col); \n\t\n    // blue color balance darks\t\n\tcol = mix( col, vec3(0.0,0.0,1.0)*dot(col,vec3(0.33)), 0.25*pow( 1.0-dot(col,vec3(0.33)), 8.0 ) );\n\t\n\t// vigneting\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    // fade\t\n\tcol *= smoothstep( 0.0, 3.0, iTime );\n\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}