{
    "Shader": {
        "info": {
            "date": "1659786011",
            "description": "Another 4D cube. It's the same as [url]https://www.shadertoy.com/view/4tVyWw[/url] but rendering faces (with gaps) instead of edges.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftcyW4",
            "likes": 80,
            "name": "4D Cube II",
            "published": 3,
            "tags": [
                "3d",
                "4d",
                "tesseract",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 3045
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2022 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Another 4D cube. It's like https://www.shadertoy.com/view/4tVyWw\n// but rendering faces instead of edges.\n\n    \n// make this 2 is your machine is fast\n#define AA 1\n\n\n//------------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    // based on a 1D hash by Hugo Elias\n    int n = 1376312589;\n    n += frame; n = (n<<13)^n; n=n*(n*n*15731+789221); \n    n += p.y;   n = (n<<13)^n; n=n*(n*n*15731+789221);\n    n += p.x;   n = (n<<13)^n; n=n*(n*n*15731+789221);\n    seed = n;\n}\n\n//------------------------------------------------------------------\n// intersecting a quadrilateral with a window in it\n//------------------------------------------------------------------\nvec4 quadIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, in float tmin, float tmax, out float oDisSq )\n{\n    // make v0 the origin\n    vec3 r1 = v1 - v0;\n    vec3 r2 = v2 - v0;\n    vec3 r3 = v3 - v0;\n    vec3 rz = ro - v0;\n\n    // intersect with the quad's plane\n    vec3 nor = cross(r1,r2);\n    float t = -dot(rz,nor)/dot(rd,nor);\n    \n    // early exit\n    if( t<tmin || t>tmax ) return vec4(-1.0);\n    \n    // intersection point\n    vec3 rp = rz + t*rd;\n    \n    \n    // build reference frame for the quad (uu,vv,ww)\n    vec3 ww = normalize(nor);\n    float l1 = length(r1);\n    vec3 uu = r1/l1;\n    vec3 vv = cross(uu,ww);\n    \n    // project all vertices to 2D into to the (uu,vv) plane\n    vec2 k0 = vec2( 0.0, 0.0 );\n    vec2 k1 = vec2( l1,  0.0 );\n    vec2 k2 = vec2( dot(r2,uu), dot(r2,vv) );\n    vec2 k3 = vec2( dot(r3,uu), dot(r3,vv) );\n    vec2 kp = vec2( dot(rp,uu), dot(rp,vv) );\n\n    // compute 2D distance from intersection point to quad edges\n    vec2  e0 = k1 - k0, p0 = kp - k0; \n    vec2  e1 = k2 - k1, p1 = kp - k1;\n    vec2  e2 = k3 - k2, p2 = kp - k2;\n    vec2  e3 = k0 - k3, p3 = kp - k3;\n    \n    float c0 = e0.x*p0.y - e0.y*p0.x;\n    float c1 = e1.x*p1.y - e1.y*p1.x;\n    float c2 = e2.x*p2.y - e2.y*p2.x;\n    float c3 = e3.x*p3.y - e3.y*p3.x;\n    \n    // if outside, early out\n    if( max(max(c0,c1),max(c2,c3))>0.0 ) return vec4(-1.0);\n    \n    // euclidean internal distance squared\n    float d = min(min(c0*c0/dot(e0,e0),\n                      c1*c1/dot(e1,e1)),\n                  min(c2*c2/dot(e2,e2),\n                      c3*c3/dot(e3,e3)));\n    \n    // open window of size 0.3\n    if( d>0.3*0.3 )  return vec4(-1.0);\n    \n    // return ray distance, normal, and distance from intersection to quad edges\n    oDisSq = d; \n    return vec4(t,ww);\n}\n\n//-------------------------------------------------------------------\n// 4D cube stuff\n//-------------------------------------------------------------------\n// 2d ->  4 verts, 1 face  per vertex -> ( 4*1)/4 =  1 quad\n// 3d ->  8 verts, 3 faces per vertex -> ( 8*3)/4 =  6 quads\n// 4d -> 16 verts, 6 faces per vertex -> (16*6)/4 = 24 quads\n//\n// So, the vertex indices of a quad differ by one bit each, in\n// a 00, 01, 11, 10 pattern. I feel I should be able to generate\n// this LUT on the fly instead of hardcoding it here below, but\n// I can't afford rabbit-holing myself into this right now :(\n#define DF(f) (ivec4((f)>>12,(f)>>8,(f)>>4,(f))&15);\n#define EF(a,b,c,d) (((a)<<12)|((b)<<8)|((c)<<4)|(d))\n#define QF(x,y,a) EF(a,a^(1<<x),a^(1<<x)^(1<<y),a^(1<<y))\nconst int kFaces[24] = int[24](\n    // xy\n    QF(0,1,  0),  //  0, 1, 3, 2\n    QF(0,1,  7),  //  7, 6, 4, 5\n    QF(0,1, 11),  // 11,10, 8, 9\n    QF(0,1, 12),  // 12,13,15,14\n    // xz\n    QF(0,2,  0),  //  0, 1, 5, 4\n    QF(0,2,  7),  //  7, 6, 2, 3\n    QF(0,2, 11),  // 11,15,14,10\n    QF(0,2, 12),  // 12, 8, 9,13\n    // xw\n    QF(0,3,  0),  //  0, 1, 9, 8\n    QF(0,3,  7),  //  7,15,14, 6\n    QF(0,3, 11),  // 11,10, 2, 3\n    QF(0,3, 12),  // 12, 4, 5,13\n    // yz\n    QF(1,2,  0),  //  0, 2, 6, 4\n    QF(1,2,  7),  //  7, 5, 1, 3\n    QF(1,2, 11),  //  11,15,13,9\n    QF(1,2, 12),  //  12,8,10,14\n    // yw\n    QF(1,3,  0),  //  0, 2,10, 8\n    QF(1,3,  7),  //  7,15,13, 5\n    QF(1,3, 11),  // 11, 9, 1, 3\n    QF(1,3, 12),  // 12, 4, 6,14\n    // zw\n    QF(2,3,  0),  //  0, 4,12, 8\n    QF(2,3,  7),  //  7,15,11, 3\n    QF(2,3,  9),  //  9, 1, 5,13\n    QF(2,3, 14)); //  14,10,2, 6\n\nvec4 intersectClosest( in vec3 ro, in vec3 rd, in vec3 verts[16], out int oFace, out float oDisSq )\n{\n    vec4 res = vec4(1e10,0.0,0.0,0.0);\n    oFace = -1;\n    \n    for( int i=0; i<kFaces.length(); i++ )\n    {\n        float tmpd;\n        ivec4 idx = DF(kFaces[i]); // decode face indices\n        vec4 tmp = quadIntersect( ro, rd, verts[idx.x], verts[idx.y], verts[idx.z], verts[idx.w], 0.0, res.x, tmpd );\n        if( tmp.x>0.0 )\n        {\n            res = tmp;\n            oFace = i;\n            oDisSq = tmpd;\n        }\n    }\n\n    res.yzw = (dot(res.yzw,rd)<0.0) ? res.yzw : -res.yzw;  // face camera\n\n    return (res.x<1e9)?res:vec4(-1.0);\n}\n\nfloat intersectAny( in vec3 ro, in vec3 rd, in vec3 v[16], int obj )\n{\n    for( int i=0; i<kFaces.length(); i++ )\n    {\n        if( i!=obj ) // prevent self shadowing, without epsilons\n        {\n            float kk;\n            ivec4 idx = DF(kFaces[i]); // decode face indices\n            if( quadIntersect( ro, rd, v[idx.x], v[idx.y], v[idx.z], v[idx.w], 0.001, 10.0, kk ).x>0.0 )\n                return 0.0;\n        }\n    }\n    return 1.0;\n}\n\n// regular ambient occlusion\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in vec3 verts[16], int obj )\n{\n    float occ = 0.0;\n    const int num = 16;   // 16 samples, can change it of course\n    for( int j=0; j<num; j++ )\n    {\n        // uniform distribution on sphere\n        float u = frand();\n        float v = frand();\n        float a = 6.2831853*v; float b = 2.0*u-1.0;\n        vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n        \n        // convert to cosine distribution around normal\n        dir = normalize( nor + dir );\n        \n        // cast shadow ray\n        if( dir.y>0.0 ) // but only towards the sky\n        occ += intersectAny( pos, dir, verts, obj );\n    }\n    return occ/float(num);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 verts[16], in vec2 px )\n{ \n    // background\n    vec3 col = mix(vec3(0.05,0.4,0.4),vec3(0.05,0.2,0.4),0.5+0.5*px.y)*0.45;\n    col *= 1.0-0.4*length(px);\n\n    // 4D cube\n    if( abs(px.x)<1.0)\n    {\n        int   face;\n        float disSq;\n        vec4  tnor = intersectClosest(ro,rd,verts,face,disSq);\n        float t = tnor.x;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n\n            // material\n            ivec4 idx = DF(kFaces[face]); // decode face indices\n            float l = length( verts[idx.x]-verts[idx.y] );\n            l = max(l,length( verts[idx.y]-verts[idx.z] ));\n            l = max(l,length( verts[idx.z]-verts[idx.w] ));\n            l = max(l,length( verts[idx.w]-verts[idx.x] ));\n            l += nor.x*1.5; \n            vec3 mate = vec3(0.6,0.4,0.52) + 0.5*sin(0.26*l+vec3(0,1.5,2)+1.35);\n            mate = max(mate,0.0);\n            mate.z += 0.2*(1.0-exp2(-0.02*t*t));\n            mate *= 1.2-1.2*vec3(0.5,0.5,0.1)*smoothstep(0.6,0.7,-cos(sqrt(disSq)*80.0));\n\n            // lighting\n            col = mate * calcOcclusion( pos, nor, verts, face );\n        }\n    }\n    return col;\n}\n\n// look-at from r(ray)o(origin) to ta(rget) with c(amera)r(oll)\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// a rotation matrix\nmat2 rot( float a )\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// animation will repeat every 18 second\nvec3 transform( in vec4 p, float time )\n{\n    // some rotations in 4D\n    p.xy = rot(6.283185*time/18.0)*p.xy;\n    p.zw = rot(6.283185*time/ 6.0)*p.zw;\n    // perspective projection (4D to 3D)\n    return 2.8*p.xyz/(3.0+p.w); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init randoms\n    srand( ivec2(fragCoord), iFrame );\n    \n    // camera (static)\n    vec3 ro = vec3( 3.8, 2.0, 3.3 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float time = iTime + frand()/30.0;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n        // rotate 4D cube\n        vec3 v[] = vec3[]( transform(vec4(-1,-1,-1,-1),time),\n                           transform(vec4(-1,-1,-1, 1),time),\n                           transform(vec4(-1,-1, 1,-1),time),\n                           transform(vec4(-1,-1, 1, 1),time),\n                           transform(vec4(-1, 1,-1,-1),time),\n                           transform(vec4(-1, 1,-1, 1),time),\n                           transform(vec4(-1, 1, 1,-1),time),\n                           transform(vec4(-1, 1, 1, 1),time),\n                           transform(vec4( 1,-1,-1,-1),time),\n                           transform(vec4( 1,-1,-1, 1),time),\n                           transform(vec4( 1,-1, 1,-1),time),\n                           transform(vec4( 1,-1, 1, 1),time),\n                           transform(vec4( 1, 1,-1,-1),time),\n                           transform(vec4( 1, 1,-1, 1),time),\n                           transform(vec4( 1, 1, 1,-1),time),\n                           transform(vec4( 1, 1, 1, 1),time));\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, v, p );\n\n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n        #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dither to remove banding from background (should be triangular, ie, two frand()s)\n    tot += frand()/255.0;\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}