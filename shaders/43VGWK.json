{
    "Shader": {
        "info": {
            "date": "1718363963",
            "description": "First time with this iterative rendering technique. It is fast!\nI updated it with an optional fwidth experiment to try to make skinny square rings ... not very good ... uncomment FWIDTH define to try.\nI removed sound - I stopped liking it.",
            "flags": 0,
            "hasliked": 0,
            "id": "43VGWK",
            "likes": 5,
            "name": "Breathing squares thing",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "#define PI (3.14159265)\n#define TAU (PI*2.)\n\n// #define FWIDTH   // uncomment this for experiment\n\n/*\n#define SINC(X) sin(X)/(X)\nvec2 XmainSound( int samp, float time ) // removed sound for now\n{\n  return vec2( \n    clamp( \n       sin(TAU*time*\n         (220.+SINC(time*.3+PI/2.)*150.)\n       )\n       +sin(TAU*time*25.),\n     -1.,1.)\n  );\n}\n*/\n\nfloat spread = 0.;\nfloat depth = 0.;\n\nvec3 Dist(vec3 beg,vec3 dir) { // return location in side of object\n    float zz = 1. - fract(beg.z); // distance to next plane of objects\n#ifdef FWIDTH\n    vec3 hit = vec3(0.,0.,1000.);\n#endif            \n    while ( beg.z < 50. )\n    {\n        beg += dir * (zz - fract(dir.z)); // position in next plane\n        float x = fract(beg.x), y = fract(beg.y);\n#ifdef FWIDTH\n        float ff = max(x,y) < .5 ? 1. : 0.;\n        if ( fwidth(ff) > .5) if ( hit.z >= 1000. ) { hit.z = beg.z; hit.x = depth; }\n#else\n        if ( max(x,y) < .5 && ! ( x > .1 && x < .4 && y > .1 && y < .4 ) && beg.z > 3. )\n            break; // hit something\n#endif            \n        zz = beg.z > 3. ? spread : 1.;\n        if ( beg.z > 3. ) ++depth;\n    }\n#ifdef FWIDTH\n    if ( hit.z < 1000. ) depth = hit.x; // messy kludge code for experiment\n    return hit;\n#else    \n    return beg;\n#endif            \n}\n\n\nvec2 rot2d(vec2 inp,float ang) {\n    float s = sin(ang);\n    float c = cos(ang);\n    return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy/2.) / min(iResolution.x,iResolution.y);\n    uv = rot2d( uv, iTime/17.);\n\n    spread = .8+sin(iTime*.7)*.75;\n\n    vec3 cam = vec3(0.+sin(iTime*.13)*.5+iTime,0.+sin(iTime/12.)+iTime/2.,2.+cos(iTime*.2)*1.9);\n    vec3 camdir = vec3( uv.x, uv.y, 1. );\n\n    vec3 hit = Dist(cam,camdir);\n  \n    vec3 col = 5.*sin( vec3(0.,PI/3.,PI*2./3.) + depth*.6)/hit.z;\n    col = mix( col, vec3(4./hit.z), .85);\n\n    fragColor = vec4( col, 1. );\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}