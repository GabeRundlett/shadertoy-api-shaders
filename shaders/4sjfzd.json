{
    "Shader": {
        "info": {
            "date": "1501753607",
            "description": "My first submission!\n\nIt uses the grid iteration technique used in iq's Cubescape (www.shadertoy.com/view/Msl3Rr), but transforms the coordinate space so that each square of the grid corresponds to two equilateral triangles.  Thanks Íñigo!\n\nSupports AA.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4sjfzd",
            "likes": 5,
            "name": "The Two Worlds",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sound",
                "music",
                "bezier",
                "soundcloud"
            ],
            "usePreview": 1,
            "username": "andyborrell",
            "viewed": 864
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Andy Borrell 2017\n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader uses lots of code by iq and is inspired by his Cubescape (https://www.shadertoy.com/view/Msl3Rr). \n * It uses the grid iteration technique used in iq's Cubescape, but I transform the coordinate space first so that each\n * grid square of the iteration corresponds to two equilateral triangles.   \n * It uses raymarching (also iq's) through each grid cell using an SDF describing the two triangles.\n *\n * Credit to F.O.D. for the remix of DeadMau5's 4ware  (https://soundcloud.com/therealfod/deadmau5-4ware-01-fod-remake)\n *\n */\n\n//#define ANTIALIAS   \n\n//=========================================================================\nconst float animSpeed = 1.4;\n\n\nconst vec4 light1 = vec4(1.0000000,0.0000000,0.0000000,1.0000000);\nconst vec4 light2 = vec4(1.0000000,1.0000000,1.0000000,1.0000000);\nconst vec3 beamColor = vec3(1.0000000,1.0000000,1.0000000);\nconst float colorRange =  0.3500000;\nconst vec3 skyColor1 = vec3(0.0078431,0.0078431,0.0549020);\nconst vec3 skyColor2 = vec3(0.0313726,0.0313726,0.0470588);\nconst vec3 upDir = vec3(0,1,0);\nconst vec3 flip = vec3(-1,1,-1);\nconst vec2 tri = vec2(0,1);\n\nconst float root3 = 1.73205080756887;\nconst float root2 = 1.4142135623730951;\nconst float pi = 3.141592653589793;\n\nconst mat4 f1mat = mat4(1, 0, 0, 0, 0, -0.8164966, 0.5773503, 0, 0, 0.5773503, 0.8164966, 0, 0, 0.3333333, 0, 1);\nconst mat4 f2mat = mat4(0.5, -0.8164966, -0.2886752, 0, -0.5, -8.413279E-09, -0.8660254, 0, -0.7071068, -0.5773503, 0.4082483, 0, 0, 0.3333333, 0, 1);\nconst mat4 f3mat = mat4(0.5, -8.413279E-09, -0.8660254, 0, 0.5, 0.8164966, 0.2886752, 0, -0.7071068, 0.5773503, -0.4082483, 0, 0, 0.3333333, 0, 1);\nconst mat4 f4mat = mat4(-0.5, 0.8164966, 0.2886752, 0, 0.5, 8.413279E-09, 0.8660254, 0, -0.7071068, -0.5773503, 0.4082483, 0, 0, 0.3333333, 0, 1);\nconst mat3 warp = mat3(1, 0, 0, 0, 1, 0,1. / root3, 0, -2. / root3);\n\nconst vec3 bevelPlane1 = vec3(-0.5980844128924556, 0.8014331132758906, 0.0);\nconst vec3 bevelPlane2 = vec3(0.0, 0.8014331132758906, -0.5980844128924556);\nconst vec3 bevelPlane3 = vec3(0.47827732475813883, 0.7365470801275338, 0.47827732475813883);\n\nconst float surface = 0.002;\nconst int gridTraverseIterations = 18;\nconst int rayMarchIterations = 40;\nconst float tmax = 1000000000.;\n\nconst float tileThickness = 0.25;\nconst vec3 pyramid1Pos = vec3(0, 0, 0);\nconst vec3 pyramid2Pos = vec3(2, 16, -24);\nconst float pyramidSize =  9.;\nconst vec3 color1 = vec3(0.6468425,0.4779412,1.0000000);\nconst vec3 color2 = vec3(0.3088235,0.6035901,1.0000000);\n\nconst float beamStartHeight = 2.13;\nconst float beamWideningPoint = 7.82;\nconst float beamEnd = -0.31;\nconst float beamTailOff = 2.2;\n\nconst float fov = 2.6;\n\nconst float loopLen = 8.;\nconst float segmentDuration = 10.;\n\nconst float darkModeRoll = -2.;\nconst float transitionHeading = -0.8;\n\n// Global variables, some WebGL compilers seems more stable using globals instead\n// of function params\nfloat darkMode;\nfloat showInnerBeams;\nfloat scaledTime;\nfloat beamWidth;\nvec3 orbitPos;\n\nmat4 rot1, rot2, rotA, rotB;\nvec3 ro_alt;\nmat3 cam;\nvec3 ro;\n\nfloat fft[8];\n\nvec2 hash2(vec2 n) { return fract(sin(n)*63763.8465261); }\nfloat maxcomp(in vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat mincomp(in vec3 v) { return min(min(v.x, v.y), v.z); }\n\nmat3 rotate_x(float t)\n{\n    return mat3(1, 0, 0,\n                0, cos(t), sin(t),\n                0, -sin(t), cos(t));\n}\nmat3 rotate_y(float t)\n{\n    return mat3(cos(t), 0, -sin(t),\n                0, 1, 0,\n                sin(t), 0, cos(t));\n}\nmat3 rotate_z(float t)\n{\n    return mat3(cos(t), sin(t), 0,\n               -sin(t), cos(t), 0,\n                0, 0, 1);\n}\n\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p, n) - d;\n}\n\nmat3 setLookAt(in vec3 ro, in vec3 ta, float roll)\n{\n    vec3  cw = normalize(ta - ro);\n    vec3  cp = upDir;\n    vec3  cu = normalize(cross(cw, cp));\n    vec3  cv = cross(cu, cw);\n    return mat3(cu, cv, cw) * rotate_z(roll);\n}\n\nfloat fftLookup(int index)\n{\n    if (index < 3)  // Webgl doesn't support non-const array indices\n    {\n        if (index == 0) return fft[0];\n        if (index == 1) return fft[1];\n        if (index == 2) return fft[2];\n    }\n    else\n    {\n        if (index == 3) return fft[3];\n        if (index == 4) return fft[4];\n        if (index == 5) return fft[5];\n    }\n}\n\n// Returns height of both triangles in a square of the grid\nvec2 mapH(vec2 ipos)\n{\n    vec2 realPos = vec2(ipos.x + 0.5 * ipos.y + 0.25, ipos.y * root3/2. + root3/12.);\n    ivec2 layer =  ivec2(min(min (-tri + (8. - ipos.x - ipos.y) * 2.,  tri + ipos.x * 2.), tri + ipos.y * 2.));\n    return vec2(fftLookup(layer.x), fftLookup(layer.y)) * (2.44 - length(realPos - vec2(0.4444,0.2633) * pyramidSize)*0.44) + 0.37;\n}\n\n// Returns color of tile (tri should be 0 or 1)\nvec3 mapColour(vec2 ipos, float tri)\n{\n    vec2 seed =  vec2 (0,631) + (ipos.x*30. + ipos.y + tri * 2041.);\n    vec2 random = hash2(seed);\n    return vec3(vec3(mix(color1,color2,tri) + (vec3(random.x,random.y,1. - random.x - random.y)- 0.5) * colorRange) );    \n}\n\n// SDF function for two triangles\nfloat twotris(vec3 p, vec2 h, int numTris)\n{\n    const float ss = 0.995; // Having this scale factor stops the normal calculation from spanning multiple cells\n    float s = dot(p, vec3(1. / root2, 0., 1. / root2));\n\n    //Vertical planes\n    s = intersect(s, -p.x - 0.5*ss); \n    s = intersect(s, -p.z - 0.5*ss); \n\n    // horizontal planes\n    s = intersect(s, p.y - h.x);\n    s = intersect(s, -p.y + h.x - tileThickness);\n\n    // bevel\n    float bevelH = dot(bevelPlane1, vec3(-0.5, h.x - 0.1, 0));\n    s = intersect(s, plane(p, bevelPlane1, bevelH));\n\n    // other bevel\n    s = intersect(s, plane(p, bevelPlane2, bevelH));\n\n    // third bevel\n    bevelH = bevelPlane3.y*(h.x - 0.1);\n    s = intersect(s, plane(p, bevelPlane3, bevelH)); \n\n    if (numTris == 1)\n        return s;\n   \n    // Now the other triangle...\n    bevelH = dot(bevelPlane1, vec3(-0.5, h.y - 0.1, 0));\n    float t = plane(p, vec3(-1. / root2, 0., -1. / root2), 0.);\n    t = intersect(t, plane(p, vec3(1., 0., 0.), 0.5*ss));\n    t = intersect(t, plane(p, vec3(0., 0., 1.), 0.5*ss));\n    t = intersect(t, plane(p, vec3(0, 1, 0), h.y));\n    t = intersect(t, plane(p, vec3(0, -1, 0), -h.y + tileThickness));\n    p = p * flip;\n    t = intersect(t, plane(p, bevelPlane1, bevelH));\n    t = intersect(t, plane(p, bevelPlane2, bevelH));\n    bevelH = bevelPlane3.y*(h.y - 0.1);\n    t = intersect(t, plane(p, bevelPlane3, bevelH)); \n    return  _union(s, t);\n}\n\n// Get normal from twotris signed distance field\nvec3 trisNormal(in vec3 pos, vec2 h, int numTris)\n{\n    const float eps = 0.0001;\n    vec3 n;\n    float d = twotris(pos, h, numTris);\n    n.x = twotris(vec3(pos.x + eps, pos.y, pos.z), h, numTris) - d;\n    n.y = twotris(vec3(pos.x, pos.y + eps, pos.z), h, numTris) - d;\n    n.z = twotris(vec3(pos.x, pos.y, pos.z + eps), h, numTris) - d;\n    return normalize(n);\n}\n\n// return (rgb, dist)\nvec4 traceTiles(vec3 ro, in vec3 rd, in float tmin, in float tmax, inout vec3 normal)\n{\n    /* Transform into triangular space. Squares in this space\n     * look like two equilateral triangles in world space\n     * This allows me to use iq's grid traversal code  */\n    ro = warp * ro; \n    rd = warp * rd; \n    ro += tmin * rd;\n\n    vec3 rdi = 1.0 / rd;\n    vec3 rda = abs(rdi);\n    vec2 rds = sign(rd.xz);\n    vec4 res = vec4(tmax*2.);\n\n    float tgtz_x;\n    float tgtz_z;\n    float tgtz = 0.;\n\n    // The following if statement checks whether the ray origin is a point within the bounds of the \n    // grid. If it is then we'll just start the grid traversal from where we are. If we're not then \n    // jump to a point on the edge of the grid. The + 0.0001 is so that we don't end up outside\n    // the grid and do an early exit on the grid straight away\n\n    if (!(ro.x > 0. && ro.x < pyramidSize && ro.z > 0. && ro.z < pyramidSize))\n    {\n        if (rds.x > 0.)\n        {\n            tgtz_x = (0.0001 - ro.x) * rda.x;\n        }\n        else\n        {\n            tgtz_x = -(pyramidSize - 0.0001 - ro.x) * rda.x;\n        }\n        if (rd.z > 0.)\n        {\n            tgtz_z = ( 0.0001 - ro.z) * rda.z;\n        }\n        else\n        {\n            tgtz_z = -(pyramidSize - 0.0001 - ro.z) * rda.z;\n        }\n        tgtz = max(tgtz_x, tgtz_z);\n        ro += tgtz * rd;\n    }\n\n    vec2 pos = floor(ro.xz); //always points to corner of cell\n    vec2 dis = (pos - ro.xz + 0.5 + rds*0.5) * rdi.xz; // a vector of how many rd vectors we need to add to get to next boundary\n\n    for (int i = 0; i<gridTraverseIterations; i++)\n    {\n        if (pos.x >= pyramidSize || pos.y >= pyramidSize || pos.x < 0. || pos.y < 0.)\n        {\n            return vec4(0, 0, 0, tmax);\n        }\n\n        if ((pos.x + pos.y) < pyramidSize) // we're iterating over a grid, but we just ignore half so that it's a triangle\n        {\n            vec2 hs = mapH(pos); \n\n            float hmax = max(hs.x, hs.y);\n\n            // intersect box\n            vec3  ce = vec3(pos.x + 0.5, 0.33 + 0.5 * hmax, pos.y + 0.5);\n            vec3  rb = vec3(0.5, hmax*0.5, 0.5);\n            vec3  rc = ro - ce;\n            float tN = maxcomp(-rdi*rc - rda*rb);\n            float tF = mincomp(-rdi*rc + rda*rb);\n            if (tN < tF)\n            {\n                rc.y = rc.y + 0.5 * hmax; // let rc be relative to ground plane\n                                    \n                float s = tN;\n\n                int numTris = 2;\n\n                if (pos.x + pos.y  + 1. == pyramidSize)\n                    numTris = 1;  // Only one triangle in a 'square' for squares along the diagonal\n\n                float h = 1.0;\n\n                for (int j = 0; j<rayMarchIterations; j++) \n                {\n                    vec3 p = rc + s * rd;\n                    h = twotris(p, hs, numTris);\n                    s += h;\n\n                    if (s>tF) break;\n\n                    if (h < surface)\n                    {\n                        res = vec4(mapColour(pos, step(p.x, -p.z) ) + \n                               (1. -darkMode * 1.3) * vec3(fft[5],fft[6],fft[7]),s + tmin + tgtz);\n                        normal = trisNormal(p, hs, numTris);\n                        break;\n                    }\n                }\n                if (h < (surface))\n                    break;\n            }\n        }\n\n        // step to next cell          \n        vec2 mm = step(dis.xy, dis.yx); \n        dis += mm*rda.xz;\n        pos += mm*rds;\n    }\n    return res;\n}\n\n// returns (rgb, dist)\nvec4 testPyramidFace(mat4 transform, vec3 ro, in vec3 rd, vec4 current, inout vec3 normal)\n{\n    ro = (transform*vec4(ro, 1)).xyz + vec3(0.5, -0.2, -0.288) * pyramidSize; \n    \n    rd = (transform*vec4(rd, 0)).xyz; //direction\n    vec3 rdi = 1.0 / rd;\n    vec3 rda = abs(rdi);\n\n    // intersect box\n    vec3  ce = vec3(4.4, 0.97, -3.93);\n    vec3  rb = vec3(4.69, 1., 3.98);\n    vec3  ra = rb;\n    vec3  rc = ro - ce;\n    float tN = maxcomp(-rdi*rc - rda*ra);\n    float tF = mincomp(-rdi*rc + rda*ra);\n\n    // Early out based on enclosing box to improve perf\n    if (tN > tF || tN > current.w)\n    {\n        return current;\n    }\n    \n    vec3 newNormal;\n    vec4 r = traceTiles(ro, rd, 0., current.w, newNormal);\n\n    if (r.w < current.w)\n    {\n        normal = newNormal;\n        return r;\n    }\n    else\n    {\n        return current;\n    }\n}\n\n// return (rgb, dist)\nvec4 tracePyramid(vec3 centre, vec3 ro, in vec3 rd, vec4 a, mat4 rot, inout vec3 normal)\n{\n    ro -= centre;\n    float d = length(ro);\n    float sd = dot(rd,ro);\n    \n    if ((d*d) - (sd*sd) < 38.)  // Test against an enclosing sphere\n    {\n        a = testPyramidFace(f1mat * rot, ro, rd,  a, normal);\n        a = testPyramidFace(f3mat * rot, ro, rd,  a, normal);\n        a = testPyramidFace(f2mat * rot, ro, rd,  a, normal);\n        a = testPyramidFace(f4mat * rot, ro, rd,  a, normal);\n    }\n    return a;\n}\n\n// Returns beam intensity for beam\nfloat pyramidBeamFace(mat4 transform, vec3 ro, in vec3 rd, float tmax, float widthMod)\n{\n    ro = (transform*vec4(ro, 1)).xyz; \n    rd = (transform*vec4(rd, 0)).xyz; //direction\n    \n    float distance2D = length(ro.xz);\n    float lengthToIntersection = distance2D / length(rd.xz);\n    float beamExtent = -(lengthToIntersection * rd.y + ro.y - beamStartHeight); \n    float effBeamWidth = beamWidth * widthMod;\n\n    if (beamExtent < beamWideningPoint)\n        effBeamWidth += smoothstep(0., 11.7, beamWideningPoint - beamExtent) * 4.37;\n\n    effBeamWidth = min(effBeamWidth, 5.);\n\n    if (dot(ro.xz, rd.xz) < 0.  // viewed in 2D (looking down the beam) our rd goes towards the beam\n        && beamExtent > beamEnd)\n    {\n        float distanceToCenterLine = abs(dot(normalize(vec3(-rd.z, 0, rd.x)),ro));\n        if (distanceToCenterLine < effBeamWidth && -beamExtent < 0. * pyramidSize && lengthToIntersection < tmax)\n        {\n            float d = (effBeamWidth - distanceToCenterLine) / effBeamWidth;\n            float tailOff = smoothstep(beamEnd, beamEnd + beamTailOff, beamExtent);\n            return d * d * tailOff;\n        }\n    }\n    return 0.;\n}\n\n// Returns beam intensity for a pyramid\nfloat pyramidBeam(vec3 centre, vec3 ro, in vec3 rd, in float tmax, mat4 rot, float widthMod)\n{\n    float beamIntensity = 0.;\n    ro -= centre;\n    beamIntensity += pyramidBeamFace(f1mat * rot, ro, rd, tmax, widthMod);\n    beamIntensity += pyramidBeamFace(f3mat * rot, ro, rd, tmax, widthMod);\n    beamIntensity += pyramidBeamFace(f2mat * rot, ro, rd, tmax, widthMod);\n    beamIntensity += pyramidBeamFace(f4mat * rot, ro, rd, tmax, widthMod);\n    return beamIntensity;\n}\n\n// Returns beam intensity for whole scene\nfloat traceBeams(vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    float beamIntensity = 0.;\n\n    beamIntensity += pyramidBeam(pyramid1Pos, ro, rd, tmax, rot1, 1.);\n    beamIntensity += pyramidBeam(pyramid2Pos, ro, rd, tmax, rot2, 1.);\n\n    beamIntensity += 0.4 * pyramidBeam((vec3(1., -3.5, 0)) * 300., ro, rd, tmax, rot1 * rotA, 5.);\n    beamIntensity += 0.4 * pyramidBeam((vec3(0., 2.5, -3)) * 300., ro, rd, tmax, rot1 * rotB, 5.);\n    beamIntensity += 0.4 * pyramidBeam((vec3(-1., -0.5, 3)) * 300., ro, rd, tmax, rotB * rot1, 5.);\n\n    return beamIntensity;\n}\n\n//returns (rgb,dist)\nvec4 raytrace(vec3 ro, in vec3 rd, in float tmin, in float tmax, out vec3 normal, inout float beamIntensity)\n{\n    vec3 normal_;\n    vec4 a = vec4(0, 0, 0, tmax);\n\n    a = tracePyramid(pyramid2Pos, ro, rd, a, rot2, normal_);\n    a = tracePyramid(pyramid1Pos, ro, rd, a, rot1, normal_);\n\n    beamIntensity += traceBeams(ro,rd,tmin,a.w);\n\n    normal = normal_;\n    return a;\n}\n\nvec3 light(vec3 n, vec3 ld, vec3 c)\n{\n    return max(0., dot(n, ld)) *c;\n}\n\nvec3 shade(vec3 n)\n{\n    vec3 s = vec3(0.3, 0.3, 0.4);\n    s += light(n, vec3(0.707, 0.707, 0), light1.xyz);\n    s += light(n, vec3(-0.707, 0.707, 0), light2.xyz);\n    return s;\n}\n\n// Star field\nvec3 background(vec3 rd)  \n{\n    vec3 ird = floor(rd* 300. + 300.);\n    vec2 f = hash2(vec2(11,17) + ird.x * 1.42 + ird.y + 529.38 + ird.z*12.59);\n    float v = max(0.,(f.x-0.995)*200.);\n    vec3 col = skyColor2;\n    col = mix(col, skyColor1, smoothstep(-1.6, 1.6, rd.y + ((f.x + f.y)-1.) *0.2));\n    col *= (1. - abs(rd.y)*0.4) ;\n    col += v;\n    return col;\n}\n\nvec3 bezier(vec3 c1, vec3 c2, vec3 c3, vec3 c4, float t)\n{\n    float u = 1.0 - t;\n    vec3 p = u * u * u * c1; //first term\n    p += 3. * u * u * t * c2; //second term\n    p += 3. * u * t * t * c3; //third term\n    p += t * t * t * c4; //fourth term\n    return p;\n}\nvec3 evalCameraPath(int seg, float pos) \n{\n    vec3 c1,c2,c3,c4;\n    if (seg == 0)  // Webgl doesn't support non-const array indices\n    {\n        c1 = vec3(-69.15625,-37.01953,14.89063);\n        c2 = vec3(14.695648,-3.814006,13.818855);\n        c3 = vec3(-34.1875,-17.6355,4.976563);\n        c4 = vec3(-27.82813,-8.571045,7.039063);\n    }\n    else if (seg == 1)\n    {\n        c1 = vec3(-27.82813,-8.571045,7.039063);\n        c2 = vec3(-21.46875,0.4934082,9.101562);\n        c3 = vec3(0.07781601,16.25562,11.31726);\n        c4 = vec3(7.265625,15.62646,3.328125);\n    }\n    else if (seg == 2)\n    {\n        c1 = vec3(7.265625,15.62646,3.328125);\n        c2 = vec3(14.45343,14.99731,-4.661015);\n        c3 = vec3(12.55197,5.271613,17.65821);\n        c4 = vec3(-2.833279,4.214956,7.524496);\n    }\n    else if (seg == 3)\n    {\n        c1= vec3(-2.833279,4.214956,7.524496);\n        c2 = vec3(-18.21852,3.158299,-2.609218);\n        c3 = vec3(7.624943,-10.94614,8.888105);\n        c4 = vec3(20.26089,-2.148565,3.707624);\n    }\n    else if (seg == 4)\n    {\n        c1 = vec3(20.26089,-2.148565,3.707624);\n        c2 = vec3(32.89684,6.649014,-1.472857);\n        c3 = vec3(14.2766,37.21476,-26.53634);\n        c4 = vec3(6.103022,24.72848,-31.09239);\n    }\n    else if (seg == 5)\n    {\n        c1 = vec3(6.103022,24.72848,-31.09239);\n        c2 = vec3(-2.070557,12.24219,-35.64844);\n        c3 = vec3(-28.85156,6.828128,-17.52344);\n        c4 = vec3(6.235493,-9.495728,10.07811);\n    }\n    else if (seg == 6)\n    {\n        c1 = vec3(6.235493,-9.495728,10.07811);\n        c2 = vec3(41.32255,-25.81958,37.67965);\n        c3 = vec3(30.60639,-26.02213,49.62637);\n        c4 = vec3(47.02772,-15.55794,56.22538);\n    }\n    else if (seg == 7)\n    {\n        c1 = vec3(47.02772,-15.55794,56.22538);\n        c2 = vec3(63.44905,-5.09375,62.82439);\n        c3 = vec3(68.44682,0.9838867,59.15281);\n        c4 = vec3(0.06239128,0.1552048,-0.006980419);\n    }\n    return bezier(c1, c2, c3, c4, pos);\n}\n\nvoid animate(float t)\n{\n    float tos = t / segmentDuration;\n    float segment = floor(tos);\n    float posInSegment = fract(tos);\n    float posInLoop = fract(tos/(loopLen*2.0));\n    float pathSeg = mod(segment, loopLen);\n\n    float roll = 0.;\n    float heading = 0.;\n    darkMode = 0.;\n\n    if (posInLoop > 0.5)\n    {\n        darkMode = 1.;\n        roll = darkModeRoll;\n    }\n   \n    showInnerBeams = smoothstep(0.47,0.49,posInLoop);\n    beamWidth = fft[2]*1.6 + 0.16;\n\n    float rotTime = 24. * pi * posInLoop;\n\n    rot1 = mat4(rotate_y(2.5) * rotate_x(rotTime) * rotate_y(-2.5));\n    rot2 = mat4(rotate_y(rotTime));\n    rotA = mat4(rotate_z(5.));\n    rotB = mat4(rotate_x(rotTime*0.08333333));\n\n    if (pathSeg == 0.)\n        heading = transitionHeading * (1. - smoothstep(0.2, 1., posInSegment));\n\n    ro = evalCameraPath(int(pathSeg),posInSegment);\n\n    float op = posInLoop*20.*pi+5.2;\n    vec2 orbit = vec2(sin(op), cos(op));\n    orbitPos = orbit.xxy * 3. * smoothstep(0.01,0.025,abs(0.25-mod((posInLoop+0.25),0.5)));\n    cam = rotate_y(heading) *setLookAt(ro, orbitPos, roll);\n    ro_alt = length (ro- vec3(0.06239128,0.1552048,-0.006980419)) * vec3(-0.9296872740068233, -0.36815807186055766, 0.011883041) + vec3(-69.15625,-37.01953,14.89063);\n}\n\n//returns rgb\nvec3 scene(vec2 fragCoord)\n{\n    vec3 color = vec3(0, 0, 0);\n    float beamIntensity =  0.;\n    vec2 xy0 = (fragCoord - iResolution.xy * 0.5) * 2. / iResolution.y;\n\n    float sampleScale = 1.;\n\n#ifdef ANTIALIAS  // Doing AA on these two loops separately is quicker than on the whole function\n    sampleScale = 0.25;\n    float aastep = 1./ iResolution.y;\n    for (float i = 0.; i < 1.; i+=0.5)\n        for (float j = 0.; j < 1.; j+=0.5)\n        {\n            vec2 xy = xy0 + vec2(i,j) * aastep;\n#else\n            vec2 xy = xy0 ;\n#endif\n            vec3 rd = (cam*vec3(xy , fov));\n            rd = normalize(rd);\n            vec3 normal;\n            vec4 res = raytrace(ro, rd, 0., tmax, normal, beamIntensity); \n\n            if (res.w < tmax - surface)\n            {\n                color += vec3(res.xyz  * (0.2 + 0.8 * shade(normal)));\n            }\n            else\n            {\n                color += background(rd) * (1.-darkMode);\n            }\n#ifdef ANTIALIAS\n        }\n#endif\n    color *= sampleScale; \n    beamIntensity *= sampleScale;\n    color += beamColor * beamIntensity * 2.5;\n    color = clamp(mix(color, 1.- color, darkMode),0.,1.);\n   \n    if (beamIntensity > 0.165 && showInnerBeams > 0.01)  //todo fade in this effect\n    {\n        float roll = darkModeRoll * (1.-darkMode);\n        mat3 cam = rotate_y(transitionHeading) *setLookAt(ro_alt, orbitPos, roll);\n#ifdef ANTIALIAS\n        for (float i = 0.; i < 1.; i+=0.5)\n            for (float j = 0.; j < 1.; j+=0.5)\n            {\n            vec2 xy = xy0 + vec2(i,j) * aastep;\n#else\n            vec2 xy = xy0 ;\n#endif\n            vec3 rdd = normalize(cam*vec3(xy, fov));\n            color +=  (-1. + darkMode*2.) *traceBeams(ro_alt, rdd, 0., tmax)\n                      * smoothstep(0.165,0.24, beamIntensity) *2. * showInnerBeams * sampleScale;\n            if (darkMode > 0.)\n               color += darkMode * background(rdd) * sampleScale;  \n            }\n#ifdef ANTIALIAS         \n    }\n#endif   \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    scaledTime = iTime * animSpeed + 40.18; \n     \n    // Control points for bezier camera animation\n    \n\n    // fourier transform samples from music channel\n    fft[0] = texture( iChannel0, vec2( 96 ,0 )/512. ).x;\n    fft[1] = texture( iChannel0, vec2(113,0)/512.).x * 1.4; \n    fft[2] = texture( iChannel0, vec2(133,0)/512.).x * 1.3; \n    fft[3] = texture( iChannel0, vec2(146,0)/512.).x; \n    fft[4] = texture( iChannel0, vec2(232,0)/512.).x; \n    fft[5] = texture( iChannel0, vec2(424,0)/512.).x * 1.7; \n    fft[6] = texture( iChannel0, vec2(432,0)/512.).x * 2.; \n    fft[7] = texture( iChannel0, vec2(463,0)/512.).x * 2.; \n\n    animate(scaledTime);\n\n    fragColor = vec4(scene(fragCoord), 1.) ;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}