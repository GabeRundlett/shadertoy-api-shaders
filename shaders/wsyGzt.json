{
    "Shader": {
        "info": {
            "date": "1589483058",
            "description": "render a voxel scene with 3 dimensional voxel traversal",
            "flags": 0,
            "hasliked": 0,
            "id": "wsyGzt",
            "likes": 8,
            "name": "3D voxel traversal",
            "published": 3,
            "tags": [
                "3dvoxeltraversaltraverse"
            ],
            "usePreview": 0,
            "username": "ich",
            "viewed": 591
        },
        "renderpass": [
            {
                "code": "#define TRAVERSAL_MAX_IT 256\n\nfloat n21(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat n31(vec3 n)\n{\n\treturn fract(sin(dot(n, vec3(12.9898,78.233,12.5429))) * 43758.5453);\n}\n\nfloat on21(vec2 uv, float i, float m) {\n    m = pow(.5, i - 1. + m);\n    float c = 0.;\n    for (float j = 0.; j < i; ++j)\n    \tc += n21(floor(uv * m / pow(.5, j))) * pow(.5, j);\n    \n    return c / 2.;\n}\n\nmat3 look_at(vec3 d, vec3 u)\n{\n    vec3 r = normalize(cross(u, d));\n    u = normalize(cross(d, r));\n\treturn mat3(r, u, d);\n}\n\nmat3 rotX(float a)\n{\n\treturn mat3(\n    \tcos(a), -sin(a), 0,\n        sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nvec3 perspective_ray(vec2 uv, float fov)\n{\n\treturn normalize(vec3(uv, fov));\n}\n\nfloat grid(vec3 uv)\n{\n    /*const float sz = 64.;\n    return false \n        || uv.x < 0. || uv.y < 0. || uv.z < 0.\n        || uv.x > sz || uv.y > sz || uv.z > sz\n        || ((abs(uv.z) == sz / 2. || abs(uv.z) == floor(sz / 1.25) || abs(uv.z) == floor(sz / 1.1)) && n31(uv) < .1)\n        || (uv.x < sz / 2. && uv.y < sz / 2. && uv.z > sz / 2.)\n        ? 1. : 0.;\n    */\n    \n    return on21(uv.xz, 4., 0.) * 32. > uv.y ? 1. : 0.;\n    \n\t//return n31(uv + 5.) < .001 ? 1. : 0.;\n}\n\nbool traverse_voxel(vec3 ro, vec3 rd, out vec3 id, out vec3 n)\n{\n    // this magic is nesseccary for the algorithm to work. don't ask me why lol\n    rd = normalize(1. / rd);\n    \n    //const int size = 16;\n    int x = int(floor(ro.x));\n    int y = int(floor(ro.y));\n    int z = int(floor(ro.z));\n    int stepX = int(sign(rd.x));\n    int stepY = int(sign(rd.y));\n    int stepZ = int(sign(rd.z));\n    //int outX = size * stepX;\n    //int outY = size * stepY;\n    float tDeltaX = abs(rd.x);\n    float tDeltaY = abs(rd.y);\n    float tDeltaZ = abs(rd.z);\n    float tMaxX = tDeltaX - fract(ro.x * sign(rd.x)) * tDeltaX;\n    float tMaxY = tDeltaY - fract(ro.y * sign(rd.y)) * tDeltaY;\n    float tMaxZ = tDeltaZ - fract(ro.z * sign(rd.z)) * tDeltaZ;\n    int status = -1; // unresolved\n    int i = 0;\n    \n    do {\n        if(tMaxX < tMaxY) {\n            if (tMaxX < tMaxZ) {\n            \ttMaxX += tDeltaX;\n            \tx += stepX;\n                n = vec3(-stepX, 0, 0);\n            } else {\n            \ttMaxZ += tDeltaZ;\n            \tz += stepZ;\n                n = vec3(0, 0, -stepZ);\n            }\n        } else {\n            if (tMaxY < tMaxZ) {\n            \ttMaxY += tDeltaY;\n            \ty += stepY;\n                n = vec3(0, -stepY, 0);\n            } else {\n            \ttMaxZ += tDeltaZ;\n            \tz += stepZ;\n                n = vec3(0, 0, -stepZ);\n            }\n        }\n        \n        if (grid(vec3(x, y, z)) == 1.) {\n            status = 0; // hit\n            id = vec3(x, y, z);\n        }\n        \n        //if (x == outX || y == outY) status = 1; // outside\n    } while(status == -1 && i++ < TRAVERSAL_MAX_IT);\n    \n\treturn status == 0;\n}\n\nvec3 grass(vec2 uv) {\n    float n = on21(uv * iResolution.y, 4., 0.);\n    uv += n * vec2(9., 17.) / iResolution.y;\n    float t = iTime * 10.;\n    vec3 c = vec3(0);\n    \n    c += on21(uv * iResolution.y, 4., 0.);\n    c *= vec3(.9, 1., .35);\n    c *= on21(uv * iResolution.y, 3., -3.);\n    return c;\n}\n\nvec3 dirt(vec2 uv) {\n    float n = on21(uv * iResolution.y, 4., 0.);\n    uv += n * vec2(9., 17.) / iResolution.y;\n    float t = iTime * 10.;\n    vec3 c = vec3(0);\n    \n    c += on21(uv * iResolution.y, 4., 0.);\n    c *= vec3(1., .7, .35);\n    c *= on21(uv * iResolution.y, 4., 0.);\n    return c;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 uv = (frag_coord - iResolution.xy * .5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    //vec3 ro = vec3(vec2(iTime * .5), 0);\n    vec3 ro = vec3(vec2(0, 32) - m * 64., 0) + .001;\n    mat3 l = look_at(normalize(vec3(m * 2., 1)), vec3(0, 1, 0));\n    vec3 rd = l * perspective_ray(uv, .5);\n    \n    {\n    \tvec3 id, n;\n        if (traverse_voxel(ro, rd, id, n)) {\n        \tcol.b += (smoothstep(float(TRAVERSAL_MAX_IT), 0., length(id - ro))  * .5 + .5) * clamp(dot(rd, -n), 0., 1.);\n        }\n    }\n\n    frag_color = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}