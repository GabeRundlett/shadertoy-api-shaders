{
    "Shader": {
        "info": {
            "date": "1662401232",
            "description": "Clock constructed with distance fields. sdOrientedBox and the smoothMax functions are by @iq and the blackbody function is by @FabriceNeyret2 (modified by me). Added a bit of noise B). Added rainbow. Also made it better",
            "flags": 0,
            "hasliked": 0,
            "id": "flyyDt",
            "likes": 16,
            "name": "Glowing clock var. var.",
            "published": 3,
            "tags": [
                "time",
                "sdf",
                "clock"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592653\n#define date (iDate * 1.0)\n#define smooth 0.005\n\nfloat join( float d1, float d2)\n{\n    float h = max(smooth-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/smooth;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) // Made by iq\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdDisk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDiskOutline(vec2 p, float r1, float r2)\n{\n    return abs(length(p) - r1) - r2*0.5;\n}\n\nfloat sdRotatedLine(vec2 p, vec2 start, float offset, float len, float theta, float thick)\n{\n    return sdOrientedBox(p, start + vec2(sin(theta), cos(theta)) * offset, vec2(sin(theta), cos(theta)) * (len + offset), thick);\n}\n\nvec4 sd(vec2 p)\n{\n    float seconds = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.15, (floor(date.w)/60.0)*2.0*PI, -0.001);\n    float minutes = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.11, (date.w/60.0/60.0)*2.0*PI, 0.0);\n    float hours = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.1, (date.w/60.0/60.0/12.0)*2.0*PI, 0.0);\n    float centerDisk = sdDisk(p, 0.0);\n    float outerCircle = sdDiskOutline(p, 0.23, 0.0);\n    float ticks = 1000000.0;\n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/12.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.18, 0.03, i, 0.0));\n    }\n    \n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/60.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.2, 0.01, i, -0.005));\n    }\n    return vec4(join(join(join(join(join(seconds, minutes), hours), centerDisk), outerCircle), ticks), 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= ratio;\n    \n    float px = 1.0/ratio/max(iResolution.x, iResolution.y);\n    float intensity = mapRange(0.0, 1.0, 1.5, 2.0, erp(noise(vec2(uv.x, uv.x+iDate.w*0.05 + uv.y * 0.3)*10.0), 0.01));\n    vec3 col = blackbody(.005/max(0.0, sd(uv).x + 0.01), intensity).xyz;\n    col += max(vec3(0.0), blackbody(erp(abs(fragCoord.y/iResolution.y - 0.5)*2.0, 0.1) * 0.5, intensity).xyz) * 1.0;\n    col = rgb2Hsl(col);\n    col.x = (uv.x * 0.5 + uv.y * 0.2) + fract(iDate.w*0.1);\n    col = hsl2Rgb(col);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(uv.xy, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float mapRange(float x1, float x2, float y1, float y2, float v)\n{\n    return (v - x1) / (x2 - x1) * (y2 - y1) + y1;\n}\n\nvec4 blackbody(float x, float intensity) //By @FabriceNeyret2 (modified by me) https://www.shadertoy.com/view/4tdGWM\n{\n    vec4 O = vec4(0.0);\n    float m = .01+5.*intensity,\n        T = x*16000.; // absolute temperature (K)\n    \n    O -= O;\n    \n/*  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n*/\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i += .05) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\n#define ease 1.5\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n  \n    float tl = hash2(vec2(floor(p.x),  ceil(p.y)));\n    float bl = hash2(vec2(floor(p.x), floor(p.y)));\n    float tr = hash2(vec2( ceil(p.x),  ceil(p.y)));\n    float br = hash2(vec2( ceil(p.x), floor(p.y)));\n    \n    \n    float a = mix(bl, tl, erp(fract(p.y), ease));\n    float b = mix(br, tr, erp(fract(p.y), ease));\n    \n    return mix(a, b, erp(fract(p.x), ease));\n}\n\n\n//Both of these functions are from here: https://stackoverflow.com/questions/68901847/opengl-esconvert-rgb-to-hsv-not-hsl\nvec3 rgb2Hsl(vec3 c) { \n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); \n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); \n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r)); \n    \n    float d = q.x - min(q.w, q.y); \n    float e = 1.0e-10; \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); \n} \n\nvec3 hsl2Rgb(vec3 c) { \n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); \n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); \n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n} ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}