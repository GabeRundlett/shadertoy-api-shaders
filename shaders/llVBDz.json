{
    "Shader": {
        "info": {
            "date": "1542818166",
            "description": "Is it raytracing? It is raycasting? Who even knows. It's as much a mystery as which ones are cubes and which ones are holes.",
            "flags": 0,
            "hasliked": 0,
            "id": "llVBDz",
            "likes": 6,
            "name": "Cube Wall",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "_polymath",
            "viewed": 591
        },
        "renderpass": [
            {
                "code": "\n// #define COLOURS\n\nvec2 rotate(vec2 p, float theta) {\n\tfloat s = sin(theta), c = cos(theta);\n\treturn vec2(\n\t\tp.x * c + p.y * s,\n\t\tp.y * c - p.x * s);\n}\n\nstruct camera {\n\tvec3 cam;\n    vec3 ray;\n};\n\nconst float ffd = 3.1415927 * .25;\ncamera makeIsometric(camera cam) {\n    cam.cam.yz = rotate(cam.cam.yz, ffd);\n    cam.cam.xz = rotate(cam.cam.xz, ffd);\n    cam.ray.yz = rotate(cam.ray.yz, ffd);\n    cam.ray.xz = rotate(cam.ray.xz, ffd);\n    return cam;\n}\n\ncamera mixCameras(camera a, camera b, float x) {\n    x = smoothstep(0., 1., x);\n\treturn camera(\n        mix(a.cam, b.cam, x),\n        mix(a.ray, b.ray, x));\n}\n\ncamera getCamera(int n, vec2 uv) {\n    switch(n) {\n        // case 1: // a perspective camera\n        case 2: // an isometric orthographic camera\n            return makeIsometric(camera(\n                vec3(uv * 6., 0.),\n                vec3(0., 0., 1.)));\n        case 3: // a balls-tripping reverse perspective camera\n            return makeIsometric(camera(\n                vec3(uv * 12., 0.),\n                normalize(vec3(-uv, 3.))));\n    }\n    // fall back to camera 1:\n    // an isometric perspective camera\n    return makeIsometric(camera(\n    \tvec3(0.),\n    \tnormalize(vec3(uv, 3.))));\n}\n\ncamera mixedCamera(int a, int b, float x, vec2 uv) {\n    return mixCameras(getCamera(a, uv), getCamera(b, uv), x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n \tfloat bigTime = mod(iTime / 10., 3.),\n        smallTime = fract(bigTime);\n    \n    camera cam;\n    \n    if (bigTime < 1.)\n        cam = mixedCamera(2, 1, smallTime, uv);\n    else if (bigTime < 2.)\n        cam = mixedCamera(1, 3, smallTime, uv);\n    else\n        cam = mixedCamera(3, 2, smallTime, uv);\n    //cam = getCamera(3, uv);\n    //cam = getCamera(3, uv);\n        \n    cam.cam.x += sin(iTime * 0.1);\n    cam.cam.y += cos(iTime * 0.682);\n    \n\t// so we have to march the ray through the cubes\n    // nothing interesting happens within 16 units of the camera\n    vec3 p = cam.cam + cam.ray * 16., ray = cam.ray;\n    float face;\n    vec3 cube;\n    \n    for (int i = 0; i < 70; ++i) {\n        vec3 distToNextPixel = 1. - fract(p * sign(ray));\n        vec3 timeToNextPixel = abs(distToNextPixel / ray);\n\n        if (timeToNextPixel.x < timeToNextPixel.y\n            && timeToNextPixel.x < timeToNextPixel.z)\n        {\n            face = .3;\n            p += ray * timeToNextPixel.x;\n        }\n        else if (timeToNextPixel.y < timeToNextPixel.x\n                 && timeToNextPixel.y < timeToNextPixel.z)\n        {\n            face = .6;\n            p += ray * timeToNextPixel.y;\n        }\n        else {\n            face = .9;\n            p += ray * timeToNextPixel.z;\n        }\n        cube = floor(p);\n        if (abs(cube.x) + abs(cube.y) + abs(cube.z) >= 30.)\n            break;\n    }\n    \n    vec3 col;\n    \n    #ifdef COLOURS\n    switch (int(mod(cube.x + cube.y - cube.z, 3.))) {\n        case 0: switch(int(mod(cube.x, 3.))) {\n            case 1: col = vec3(.5, .9, .2); break;\n            case 2: col = vec3(.9, .4, .2); break;\n            case 0: col = vec3(.2, .3, .9); break;\n        } break;\n    \tcase 1: switch(int(mod(cube.x, 3.))) {\n            case 2: col = vec3(.5, .9, .2); break;\n            case 0: col = vec3(.9, .4, .2); break;\n            case 1: col = vec3(.2, .3, .9); break;\n        } break;\n    \tcase 2: switch(int(mod(cube.x, 3.))) {\n            case 0: col = vec3(.5, .9, .2); break;\n            case 1: col = vec3(.9, .4, .2); break;\n            case 2: col = vec3(.2, .3, .9); break;\n        } break;\n    }\n    #else\n    col = vec3(.9);\n    #endif\n\n    fragColor = vec4(col * face, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}