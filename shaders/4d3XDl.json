{
    "Shader": {
        "info": {
            "date": "1461962174",
            "description": "Just trying IQ's equations in 3d without really understanding the math. Seems to work fine on triplex numbers as well. Qk is a bounding radius and Rk is a conservative inner radius. (used here for coloring)",
            "flags": 0,
            "hasliked": 0,
            "id": "4d3XDl",
            "likes": 17,
            "name": "Rk and Qk",
            "published": 3,
            "tags": [
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 1195
        },
        "renderpass": [
            {
                "code": "//based on... (don't trust my math! go to the source)\n//https://www.shadertoy.com/view/4sdXWX\n//https://iquilezles.org/articles/mset1bulb\n\n//#define SHOW_RADII\nfloat k,qk,rk;\nfloat Rk(float k){return 1.0/pow(k,1./(k-1.))-1.0/pow(k,k/(k-1.));}\nfloat Qk(float k){return pow(2.,1./(k-1.));}\n\nvec3 mcol;\nfloat DE(vec3 z0){//mandelBulb by twinbee\n   vec4 c = vec4(z0,1.0),z = c;\n   float r = length(z.xyz),zo,zi,r1=r;\n   for (int n = 0; n < 7; n++) {\n      if(r>qk+0.25)break;//experimenting with early bailout\n      zo = asin(z.z / r) * k +iTime;\n      zi = atan(z.y, z.x) * 7.0;//even messing with the rotations stays in bounds\n      z=pow(r, k-1.0)*vec4(r*vec3(cos(zo)*vec2(cos(zi),sin(zi)),sin(zo)),z.w*k)+c;\n      r = length(z.xyz);\n   }\n   mcol=10.0*z.xxz/z.w+clamp(r-rk,0.0,3.0)*0.15;\n   return 0.5 * min(r1-rk,log(r) * r / z.w);\n}\nfloat rndStart(vec2 co){return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\nfloat sphere( in vec3 ro, in vec3 rd, in float r){\n   float b=dot(-ro,rd);\n   float h=b*b-dot(ro,ro)+r*r;\n   if(h<0.0)return -1.;\n   return b-sqrt(h);\n}\nmat3 lookat(vec3 fw,vec3 up){\n   fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   float pxl=1.0/iResolution.x;//find the pixel size\n   float tim=iTime*0.3;\n   k=7.0+sin(tim)*3.0;\n   qk=Qk(k);\n   rk=Rk(k);\n   //position camera\n   vec3 ro=vec3(abs(cos(tim)),sin(tim*0.3),abs(sin(tim)))*(qk+0.5);\n   vec3 rd=normalize(vec3((fragCoord-0.5*iResolution.xy)/iResolution.y,1.0));\n   rd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n   vec3 LDir=normalize(vec3(0.4,0.75,0.4));//direction to light\n   vec3 bcol=vec3(0.5+0.25*rd.y);\n   vec4 col=vec4(0.0);//color accumulator\n   //march\n   float t=sphere(ro,rd,qk+0.01);\n   \n  if(t>0.0){\n   t+=DE(ro+rd*t)*rndStart(fragCoord);\n   float d,od=1.0;\n   for(int i=0;i<99;i++){\n      d=DE(ro+rd*t);\n      float px=pxl*(1.+t);\n      if(d<px){\n         vec3 scol=mcol;\n         float d2=DE(ro+rd*t+LDir*px);\n         float shad=abs(d2/d),shad2=max(0.0,1.0-d/od);\n         scol=scol*shad+vec3(0.2,0.0,-0.2)*(shad-0.5)+vec3(0.1,0.15,0.2)*shad2;\n         scol*=3.0*max(0.2,shad2);\n         scol/=(1.0+t);//*(0.2+10.0*dL*dL);\n         \n         float alpha=(1.0-col.w)*clamp(1.0-d/(px),0.0,1.0);\n         col+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n         if(col.w>0.9)break;\n      }\n      od=d;\n      t+=d;\n      if(t>6.0)break;\n   }\n  }\n   col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n#ifdef SHOW_RADII\n   t=sphere(ro,rd,qk);\n   if(t<0.0)col.g=0.0;\n   t=sphere(ro,rd,rk);\n   if(t>0.0)col.b=1.0;\n#endif\n   fragColor=vec4(col.rgb,1.0);\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}