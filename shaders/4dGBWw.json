{
    "Shader": {
        "info": {
            "date": "1528957883",
            "description": "Part 2, aka can I fake ring lights with a negative gaussian as core? I'm interested in building a cone that preserves the same integration properties as gaussians. It seems to work for specular, but the diffuse approximation fails a bit. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4dGBWw",
            "likes": 9,
            "name": "Spherical gaussians, pt2",
            "published": 3,
            "tags": [
                "raymarching",
                "convolution",
                "rendering",
                "gaussian",
                "integration",
                "sphericalgaussians",
                "ringlight"
            ],
            "usePreview": 0,
            "username": "mmerchante",
            "viewed": 594
        },
        "renderpass": [
            {
                "code": "/* \n * Spherical gaussians test, pt.2\n * aka, can I generate a ring light?\n */\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MAX_STEPS 100\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 20.0\n#define MIN_DISTANCE 1.0\n#define EPSILON .001\n#define EPSILON_NORMAL .001\n\n// ---------------------------------------------------------\n\n// All SG math taken from \n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\nstruct SG\n{\n    vec3 Amplitude;\n    vec3 Axis;\n    float Sharpness;\n};\n    \nvec3 EvaluateSG(in SG sg, in vec3 dir)\n{\n    float cosAngle = dot(dir, sg.Axis);\n    return sg.Amplitude * exp(sg.Sharpness * (cosAngle - 1.0f));\n}\n\nSG SGProduct(in SG x, in SG y)\n{\n    vec3 um = (x.Sharpness * x.Axis + y.Sharpness * y.Axis) / (x.Sharpness + y.Sharpness);\n    float umLength = length(um);\n    float lm = x.Sharpness + y.Sharpness;\n \n    SG res;\n    res.Axis = um * (1.0f / umLength);\n    res.Sharpness = lm * umLength;\n    res.Amplitude = x.Amplitude * y.Amplitude * exp(lm * (umLength - 1.0f));\n \n    return res;\n}\n\nvec3 SGIntegral(in SG sg)\n{\n    float expTerm = 1.0f - exp(-2.0f * sg.Sharpness);\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness) * expTerm;\n}\n \nvec3 ApproximateSGIntegral(in SG sg)\n{\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness);\n}\n\n// Equals to the integral of the product of two SGs\nvec3 SGInnerProduct(in SG x, in SG y)\n{\n    float umLength = length(x.Sharpness * x.Axis + y.Sharpness * y.Axis);\n    vec3 expo = exp(umLength - x.Sharpness - y.Sharpness) *x.Amplitude * y.Amplitude;\n    float other = 1.0f - exp(-2.0f * umLength);\n    return (2.0f * 3.141592 * expo * other) / umLength;\n}\n\nfloat SGSharpnessFromThreshold(in float amplitude, in float epsilon, in float cosTheta)\n{\n    return (log(epsilon) - log(amplitude)) / (cosTheta - 1.0f);\n}\n\nSG CosineLobeSG(in vec3 direction)\n{\n    SG cosineLobe;\n    cosineLobe.Axis = direction;\n    cosineLobe.Sharpness = 2.133f;\n    cosineLobe.Amplitude = vec3(1.17f);\n    return cosineLobe;\n}\n\nvec3 SGIrradianceInnerProduct(in SG lightingLobe, in vec3 normal)\n{\n    SG cosineLobe = CosineLobeSG(normal);\n    return max(SGInnerProduct(lightingLobe, cosineLobe), 0.0f);\n}\n\nvec3 SGIrradianceFitted(in SG lightingLobe, in vec3 normal)\n{\n    float muDotN = dot(lightingLobe.Axis, normal);\n    float lambda = lightingLobe.Sharpness;\n \n    float c0 = 0.36f;\n    float c1 = 1.0f / (4.0f * c0);\n \n    float eml = exp(-lambda);\n    float em2l = eml * eml;\n    float rl = 1.0 / lambda;\n \n    float scale = 1.0f + 2.0f * em2l - rl;\n    float bias  = (eml - em2l) * rl - em2l;\n \n    float x  = sqrt(1.0f - scale);\n    float x0 = c0 * muDotN;\n    float x1 = c1 * x;\n \n    float n = x0 + x1;\n \n    float y = clamp(muDotN, 0.0, 1.0);\n    \n    if(abs(x0) <= x1)\n        y = (n * n) / x;\n \n    float result = scale * y + bias; \n    return result * ApproximateSGIntegral(lightingLobe);\n}\n\nvec3 SGDiffuseInnerProduct(in SG lightingLobe, in vec3 normal, in vec3 albedo)\n{\n    vec3 brdf = albedo / 3.141592;\n    return SGIrradianceFitted(lightingLobe, normal) * brdf;\n}\n\nSG DistributionTermSG(in vec3 direction, in float roughness)\n{\n    SG distribution;\n    distribution.Axis = direction;\n    float m2 = roughness * roughness;\n    distribution.Sharpness = 2.0 / m2;\n    distribution.Amplitude = vec3(1.0f / (3.141592 * m2)); \n    return distribution;\n}\n\nSG WarpDistributionSG(in SG ndf, in vec3 view)\n{\n    SG warp; \n    warp.Axis = reflect(-view, ndf.Axis);\n    warp.Amplitude = ndf.Amplitude;\n    warp.Sharpness = ndf.Sharpness;\n    warp.Sharpness /= (4.0f * max(dot(ndf.Axis, view), 0.0001f)); \n    return warp;\n}\n\nfloat GGX_V1(in float m2, in float nDotX)\n{\n    return 1.0f / (nDotX + sqrt(m2 + (1.0 - m2) * nDotX * nDotX));\n}\n \nvec3 SpecularTermSGWarp(in SG light, in vec3 normal, in float roughness, in vec3 view, in vec3 specAlbedo)\n{\n    SG ndf = DistributionTermSG(normal, roughness);\n    SG warpedNDF = WarpDistributionSG(ndf, view);\n \n    vec3 result = SGInnerProduct(warpedNDF, light);\n \n    vec3 warpDir = warpedNDF.Axis;\n    float m2 = roughness * roughness;\n    \n    // I'm still not sure I understand this, it's obscuring a lot of the fresnel contribution :/\n    float nDotL = saturate(dot(normal, warpDir));\n    result *= nDotL;\n    \n    float nDotV = saturate(dot(normal, view));\n    vec3 h = normalize(warpedNDF.Axis + view);\n \n    result *= GGX_V1(m2, nDotL) * GGX_V1(m2, nDotV);\n    \n    float powTerm = pow((1.0f - saturate(dot(warpDir, h))), 5.0);\n    result *= specAlbedo + (1.0f - specAlbedo) * powTerm;\n    \n    return max(result, 0.0f);\n}\n\n// ---------------------------------------------------------\n\nSG GetLightSG()\n{\n    float t = iTime * .5;\n    float height = .15;\n    vec3 p = vec3(cos(t), height, sin(t));\n    \n\tSG light;\n\tlight.Axis = normalize(p);\n    light.Sharpness = 10.0;\n    light.Amplitude = pow(vec3(2.5, 1.5, 1.05), vec3(2.2)) * .35;\n    return light;\n}\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n\nCamera GetCamera(vec2 uv, float zoom, float time)\n{\n    float dist = 2.35 / zoom;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nfloat sdf(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);\n\tfloat dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);\n\tfloat dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{    \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec3 c0 = texture(iChannel0, P.xy).rgb * Nb.z;\n    vec3 c1 = texture(iChannel0, P.yz).rgb * Nb.x;\n    vec3 c2 = texture(iChannel0, P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    SG lightSG = GetLightSG();    \n    SG innerSG = lightSG;\n    \n    // Play with these two\n    innerSG.Sharpness *= 1.8;\n    float innerAmplitude = 1.2;\n    \n    if(isect.sdf < EPSILON)\n    {\n        vec3 normal = sdfNormal(p, EPSILON_NORMAL);\n        vec3 diffuse = pow(vec3(.85, .15, .05), vec3(2.2)) * .3;\n        vec3 specular = pow(vec3(1.0, .9, .85), vec3(2.2)) * .5;\n\n        float roughness = mix(.025, .2, cos(iTime) * .5 + .5);\n        vec3 diff = SGDiffuseInnerProduct(lightSG, normal, diffuse);\n        vec3 spec = SpecularTermSGWarp(lightSG, normal, roughness, -camera.direction, specular);        \n        \n        diff -= innerAmplitude * SGDiffuseInnerProduct(innerSG, normal, diffuse);\n        spec -= innerAmplitude * SpecularTermSGWarp(innerSG, normal, roughness, -camera.direction, specular);\n        \n        spec = max(spec, vec3(0.0));\n        diff = max(diff, vec3(0.0));\n        \n        return spec + diff;\n    }\n    else\n    {\n     \tvec3 background = vec3(0.0);\n                \n        background += EvaluateSG(lightSG, camera.direction);\n        background -= innerAmplitude * EvaluateSG(innerSG, camera.direction);\n        \n        return background;\n    }\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf(p);\n\n\t\toutData.totalDistance += outData.sdf;\n                \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    return outData;\n}\n\nvec3 filmic(vec3 x)\n{\n\treturn ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    \n    if(abs(uv.y) > .8)\n        return;\n    \n    Camera camera = GetCamera(uv, 0.35, iTime * .25);\n    Intersection isect = Raymarch(camera);\n    vec3 color = Render(camera, isect, uv);    \n    \n    color = max(color, vec3(0.0));\n        \n\tvec3 vignette = mix(vec3(1.0, .8, .96) * .1, vec3(1.3), (1.0 - smoothstep(.0, 2.1, length(uv))));\n    vignette *= vignette;\n\t\n    \n\tvec3 whiteScale = 1.0f / filmic(vec3(6.2f));\n    color.rgb = filmic(color.rgb * 24.0 * vignette);    \n    color.rgb = clamp(color.rgb * whiteScale, vec3(0.0), vec3(1.0));\n    color = pow(color, vec3(.45454));\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}