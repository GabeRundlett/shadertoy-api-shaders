{
    "Shader": {
        "info": {
            "date": "1721670200",
            "description": "pulsar experiment",
            "flags": 48,
            "hasliked": 0,
            "id": "MXlGD8",
            "likes": 14,
            "name": "pulsar experiment",
            "published": 3,
            "tags": [
                "particle",
                "gravity"
            ],
            "usePreview": 1,
            "username": "GoldenRatioScience",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "vec2 getParticlePosition(in int particleID)\n{\n    int iChannel0_width = int(iChannelResolution[0].x);\n\tivec2 particleCoord = ivec2(particleID % iChannel0_width, particleID / iChannel0_width);\n    return texelFetch(iChannel0, particleCoord, 0).xy;\n}\nvec2 getParticleVelocity(in int particleID)\n{\n    int iChannel0_width = int(iChannelResolution[0].x);\n\tivec2 particleCoord = ivec2(particleID % iChannel0_width, particleID / iChannel0_width);\n    return texelFetch(iChannel0, particleCoord, 0).zw;\n}\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec3 inferno_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( -0.027780558, +1.228188385, +0.278906882, +3.892783760 ) ) + dot( x2.xy, vec2( -8.490712758, +4.069046086 ) ),\n\t\tdot( x1.xyzw, vec4( +0.014065206, +0.015360518, +1.605395918, -4.821108251 ) ) + dot( x2.xy, vec2( +8.389314011, -4.193858954 ) ),\n\t\tdot( x1.xyzw, vec4( -0.019628385, +3.122510347, -5.893222355, +2.798380308 ) ) + dot( x2.xy, vec2( -3.608884658, +4.324996022 ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bn = textureLod(iChannel1, fragCoord/1024.0f, 0.0f).r;\n    \n    vec4 particleData = texelFetch(iChannel0, ivec2(fragCoord * 0.5), 0);\n    \n    float d = 0.0f;\n    \n    float screenSize = .000618034 * length(iResolution.xy);\n    \n    vec3 color = vec3(0);\n    for(int i = 0; i < nParticles; ++i)\n    {\n        vec3 particlePos = vec3(getParticlePosition(i), 0.0);\n        vec2 r = fragCoord.xy - particlePos.xy;\n        float rMag = dot(r,r);\n        \n        float partd = 1.618034 * screenSize/rMag;\n\n        d = (d + partd) * smoothstep(0.0f, 6.5e0f, length(getParticleVelocity(i)*0.1f) - 1.0f);\n        \n        float h = (length(getParticleVelocity(i)) / 4e3f)*sqrt(partd);\n        float dscaled = 1e5f * partd;\n        float att = 1.0f / (1.0f + dscaled*dscaled);\n        \n        vec3 cloud = color * inferno_quintic(1.0f - att);\n        cloud = mix(vec3(h*h * 1e1f), vec3(0.999f * (1.0f - clamp(h, 0.0f, 1.0f)),0.11f,0.2f), h + 0.0000001f) * att;\n        color += cloud;\n        \n        color = color + h * 1e-1f;\n        color = color + phi * h * h * h * 3e3f;\n    }    \n    \n    vec3 particlePos = vec3(getParticlePosition(0), 0.0);\n    vec2 r = fragCoord.xy - iResolution.xy/2.;\n    float rMag = length(r);\n    \n    float t = (iTime + 1.0f) * 1.721f * mix(0.0721f, 0.0791f, abs(sin(fract(iTime) * 2.0f - 1.0f)));\n    \n    vec2 rot = vec2(cos(0.1f), sin(-0.1f * t));\n    float dp = 0.19191f * sqrt(rMag) / dot(normalize(r) * (1618034.999f * 0.1f) / (rMag*rMag), rot);\n    \n    float scale = 4e3f * d;\n    \n    d += (phi - d) * iphi * scale * max(0.0f, dp)*screenSize/rMag;\n    d += (phi - d) * iphi * scale * max(0.0f,-dp)*screenSize/rMag;\n    color = mix(inferno_quintic(d + bn * bn_scalar), color, smoothstep(1.0f, 0.0f, abs(d)));\n    \n    d += (phi - d) * phi * 11.0f * screenSize/rMag;\n    color += inferno_quintic(d);// mix(color * color, color, inferno_quintic(d));\n\n    float grey = dot(color, luma);\n    \n    fragColor.xyz = vec3(grey + bn * bn_scalar * grey);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define phi 1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243\n#define iphi 0.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243\n#define pi 3.14159265359\n#define eps 0.00001f\n#define luma vec3(0.2126f, 0.7152f, 0.0722f)\n#define bn_scalar (17.0f/255.0f)\n#define global_seed (iphi)\n\n#define fma(a,b,c)(a*b+c)\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n\t// mu is 0.0 (centered) sigma is 0.5\n\tconst float c = (pi / -1.25331414f);  // optimized magic value - bellcurve perfect match (to six digits of precision)\n\t\t\t\t\t\t\t           // removes sqrt\n\t\t\t\t\t\t\t           // https://www.desmos.com/calculator/xxwdiqa4sk\n\t\t\t\t\t\t\t\n\tx = 2.0f * (x * 2.0f - 1.0f);  // converts input range\n\t\t\n\treturn(exp(x * x * c));\n}\n\nconst int nParticles = 384 << 1;\nconst float dt = .0001618034 / 3.14f;\nconst float particlesSize = phi *.001; // normalized uv coords\nconst float mass = 3141. * 0.5f; // click r to restart, centripital velocities should resolve\nconst float collisionDamping = phi * 0.1; // should be 0 <> 1\n\n\nvec2 rotZ( float alpha, vec2 r)\n{\n    float xComp = r.x*cos(alpha) - r.y*sin(alpha);\n    float yComp = r.x*sin(alpha) + r.y*cos(alpha);\n    return vec2( xComp, yComp );\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int KEY_RESET  = 82;\n#define KEY(N) texelFetch( iChannel1, ivec2( N, 0 ), 0 ).x\n\n\n/* Get random float from 1 <> 0\n   used function(s) from https://www.shadertoy.com/view/Nsf3Ws, no idea how it works\n*/\n\n//------------------------//\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n//------------------------//\n\n\n/* Creating particles in shadertoy has been confusing to me\n   used a lot of logic from https://www.shadertoy.com/view/MdGfDc, still learning\n*/\n\nvoid initParticle(in vec2 fragCoord, inout vec2 particleVelocity, inout vec2 particlePosition)\n{\n    // need to create a random r and v, where v is 90deg xy rotated and vmag = sqrt(mass/rFromCenter)\n    // this is weird because rx and ry are in iResolution frame where velocity is in uv frame\n    // ¯\\_(ツ)_/¯ \n    \n   \n    float rx = random()*.8 + .1;\n    float ry = random()*.8 + .1;\n    vec2 randomR = vec2(iResolution.x*rx,iResolution.y*ry);\n    particlePosition = randomR;\n    randomR /= iResolution.xy;\n    randomR -= .5; // mass is at center so in uv [.5,.5]\n    float mag = sqrt((randomR.x*randomR.x) + (randomR.y*randomR.y));\n    particleVelocity =  - sqrt(mass/(mag)) * rotZ(3.141592654*0.5f,randomR/mag); // rotate normalized v vect\n    \n    \n    // all on x\n    //float r = 3. + 5.*random();\n\t//particlePosition = vec2(iResolution.x/r,iResolution.y/2.);\n    //particleVelocity = vec2(.0,sqrt(mass/(.5-1./r)));\n\n}\n\n\nvoid solveCollisions(inout vec2 particleVelocity, vec2 particlePosition)\n{\n    vec2 particlePositionFuture = particlePosition + particleVelocity*dt;\n    if( particlePositionFuture.x - particlesSize < 0. || particlePositionFuture.x + particlesSize > 1.)\n    {\n    \tparticleVelocity.x *= -1.*collisionDamping;\n    }   \n    if( particlePositionFuture.y - particlesSize < 0. || particlePositionFuture.y + particlesSize > 1.)\n    {\n    \tparticleVelocity.y *= -1.*collisionDamping;\n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n\n\n    int particleID = int(floor(fragCoord.x) + iResolution.x * floor(fragCoord.y));\n    \n    \n    // keep updating data unitl nParticles\n    if(particleID >= nParticles) return;\n    \n    // get data\n    vec4 particleData = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    \n    vec2 particleVelocity = particleData.zw;\n    vec2 particlePosition = particleData.xy;\n    \n    \n    if ( KEY(KEY_RESET) > 0.5 || iFrame < 10  ) \n    {\n        initRandomGenerator(fragCoord);\n        initParticle(fragCoord, particleVelocity, particlePosition);\n    };  \n\n    // normailze\n    particlePosition = particlePosition/iResolution.xy;\n\n    // mass is at [.5 , 5.] (uv)\n    \n    float rX = particlePosition.x - 0.5;\n    float rY = particlePosition.y - 0.5;\n    \n    //float rCubedSqrt = pow(rX * rX + rY * rY, 1.5);\n    \n    float rCubedSqrt = pow(rX * rX + rY * rY, 1.618034f) + .00001;\n\n    vec2 force = -mass*vec2(rX/rCubedSqrt,rY/rCubedSqrt);\n    \n    particleVelocity = (force)*dt + particleVelocity;\n    particlePosition = (particleVelocity)*dt + particlePosition;\n\n\n    solveCollisions(particleVelocity, particlePosition);\n    \n    \n    fragColor = vec4(particlePosition*iResolution.xy, particleVelocity);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}