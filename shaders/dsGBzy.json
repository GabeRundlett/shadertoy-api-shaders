{
    "Shader": {
        "info": {
            "date": "1698331202",
            "description": "For TDF 16ms #0 GLSL Graphics compo.\nT3 Puzzle is the simplest tiling pattern maker in the world.\nCheck it out! https://www.tessellation.jp/t3puzzle",
            "flags": 0,
            "hasliked": 0,
            "id": "dsGBzy",
            "likes": 7,
            "name": "[TDF16ms #0] Hello in T3 Puzzle",
            "published": 3,
            "tags": [
                "2d",
                "tessellation"
            ],
            "usePreview": 0,
            "username": "soma_arc",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "const int SIZE_X = 40;\nconst int SIZE_Y = 12;\nconst int OBJ_SIZE = SIZE_X * SIZE_Y;\nconst int[OBJ_SIZE] tiles = int[](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 1, 4, 1, 4, 1, 4, 1, 4, 1, 1, 0, 0, 0, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 6, 1, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 5, 6, 6, 5, 0, 0, 0, 3, 2, 4, 4, 1, 4, 1, 4, 1, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 5, 6, 6, 5, 0, 0, 0, 0, 0, 3, 2, 2, 6, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 4, 6, 6, 5, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 5, 1, 4, 1, 4, 6, 3, 4, 4, 1, 4, 1, 1, 0, 0, 3, 2, 6, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 3, 4, 4, 1, 4, 1, 4, 1, 1, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\nconst int SIZE_16MS_X = 45;\nconst int SIZE_16MS_Y = 12;\nconst int OBJ_SIZE_16MS = SIZE_16MS_X * SIZE_16MS_Y;\nconst int[OBJ_SIZE_16MS] tiles16ms = int[](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 1, 0, 0, 0, 5, 1, 4, 1, 4, 1, 4, 1, 1, 0, 0, 0, 5, 1, 1, 0, 5, 1, 1, 0, 5, 1, 1, 0, 5, 1, 4, 1, 4, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 4, 1, 0, 0, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 3, 5, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 4, 1, 0, 0, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 0, 2, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 4, 1, 0, 0, 3, 2, 4, 1, 3, 2, 4, 1, 3, 6, 4, 1, 3, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 4, 1, 4, 1, 6, 5, 0, 0, 0, 3, 2, 2, 6, 2, 3, 2, 3, 2, 3, 5, 0, 3, 3, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 5, 1, 1, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 4, 1, 4, 6, 6, 4, 1, 0, 0, 3, 2, 4, 4, 1, 4, 6, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 3, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\nconst int TILE_NONE = 0;\nconst int TILE_TOP = 1;\nconst int TILE_BOTTOM = 2;\nconst int TILE_TOP_RIGHT = 3;\nconst int TILE_BOTTOM_RIGHT = 4;\nconst int TILE_TOP_LEFT = 5;\nconst int TILE_BOTTOM_LEFT = 6;\n\nconst float PI = 3.14159265359;\nconst float PI_2 = PI * 0.5;\nconst float PI_3 = PI / 3.0;\n\nconst vec2 TRIANGLE_LEFT = vec2(0);\nconst vec2 TRIANGLE_RIGHT = vec2(1, 0);\nconst vec2 TRIANGLE_TOP = vec2(cos(PI_3), sin(PI_3));\nconst vec2 TRIANGLE_CENTER = (TRIANGLE_LEFT + TRIANGLE_RIGHT + TRIANGLE_TOP) / vec2(3);\nconst float TRIANGLE_HEIGHT = sin(PI_3);\nconst float TRIANGLE_EDGE_LENGTH = 1.0;\n\nconst mat2 ROT_120 = mat2(cos(2. * PI_3), -sin(2. * PI_3),\n                          sin(2. * PI_3), cos(2. * PI_3));\nconst mat2 ROT_120_REV = mat2(cos(2. * -PI_3), -sin(2. * -PI_3),\n                              sin(2. * -PI_3), cos(2. * -PI_3));\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nvec3 computeColor(const int tileType, vec2 p, const vec3 backgroundColor,\n                  const vec3 tileTopColor, const vec3 tileBottomColor) {\n    if(tileType == TILE_NONE) {\n        return backgroundColor;\n    } else if(tileType == TILE_TOP) {\n        if(p.y > TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_BOTTOM) {\n        if(p.y <= TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_TOP_RIGHT) {\n        vec2 np = ROT_120_REV * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y > TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_BOTTOM_RIGHT) {\n        vec2 np = ROT_120_REV * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y <= TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_TOP_LEFT) {\n        vec2 np = ROT_120 * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y > TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_BOTTOM_LEFT) {\n        vec2 np = ROT_120 * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y <= TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    }\n    return backgroundColor;\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nint g_currentLine = 90;\nint getTile(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_Y <= y - translateY) {\n        //return TILE_NONE;\n        if(g_currentLine < x) {\n            return int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return TILE_NONE;\n        }\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_X;\n    if(0 <= index && index < OBJ_SIZE) {\n        //return int(random(vec2(float(x) + time, float(y) - time)) * 7.);//a[index];\n        //return a[index];\n        // if(tiles[index] == TILE_NONE) {\n        //     return TILE_NONE;\n        // }\n        if(g_currentLine < x) {\n            return tiles[index] + int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return tiles[index];\n        }\n        \n    }\n    return TILE_NONE;\n}\n\nint getTileRandom(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_Y <= y - translateY) {\n        //return TILE_NONE;\n        return TILE_NONE;\n    }\n\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_X;\n    if((0 <= index && index < OBJ_SIZE)) {\n        if(tiles[index] != TILE_NONE) {\n            for(int xx = -1 ; xx <= 1; xx++) {\n                for(int yy = -1 ; yy <= 1; yy++) {\n                    int ii = (x + xx - translateX * 2) + (y + yy - translateY) * SIZE_X;\n                    if((0 <= ii && ii < OBJ_SIZE)) {\n                        //return tiles[index] + int(mod(time * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n                        return int(mod(float(tiles[ii]) + (iTime * 5. + (random(vec2(x + xx, y + yy)) * 10.0)), 7.));\n                    }\n                }\n            }\n        }\n    }\n    return TILE_NONE;\n}\n\nint getTileRandom2(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_Y <= y - translateY) {\n        //return TILE_NONE;\n        return TILE_NONE;\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_X;\n    if(0 <= index && index < OBJ_SIZE) {\n        if(tiles[index] != TILE_NONE) {\n            //return tiles[index] + int(mod(time * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n            return int(mod(float(tiles16ms[index]) + (iTime * 5. + (random(vec2(x, y)) * 10.0)), 7.));\n        }\n    }\n\n    int index2 = (x - translateX * 2) + (y - translateY) * SIZE_16MS_X;\n    if(0 <= index2 && index2 < OBJ_SIZE_16MS) {\n        if(tiles16ms[index2] != TILE_NONE) {\n            //return tiles16ms[index2] + int(mod(time * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n            return int(mod(float(tiles16ms[index2]) + (iTime * 5. + (random(vec2(x, y)) * 10.0)), 7.));\n        }\n    }\n    \n    return TILE_NONE;\n}\n\nint getTileRandom16ms(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_16MS_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_16MS_Y <= y - translateY) {\n        //return TILE_NONE;\n        return TILE_NONE;\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_16MS_X;\n    if((0 <= index && index < OBJ_SIZE_16MS)) {\n        if(tiles16ms[index] != TILE_NONE) {\n            for(int xx = -1 ; xx <= 1; xx++) {\n                for(int yy = -1 ; yy <= 1; yy++) {\n                    int ii = (x + xx - translateX * 2) + (y + yy - translateY) * SIZE_16MS_X;\n                    if((0 <= ii && ii < OBJ_SIZE_16MS)) {\n                        return int(mod(float(tiles16ms[ii]) + (iTime * 5. + (random(vec2(x + xx, y + yy)) * 10.0)), 7.));\n                    }\n                }\n            }\n        }\n    }\n    return TILE_NONE;\n}\n\n\nint getTile16ms(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_16MS_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_16MS_Y <= y - translateY) {\n        //return TILE_NONE;\n        if(g_currentLine < x) {\n            return int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return TILE_NONE;\n        }\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_16MS_X;\n    if(0 <= index && index < OBJ_SIZE_16MS) {\n        //return int(random(vec2(float(x) + time, float(y) - time)) * 7.);//a[index];\n        //return a[index];\n        // if(tiles[index] == TILE_NONE) {\n        //     return TILE_NONE;\n        // }\n        if(g_currentLine < x) {\n            return tiles16ms[index] + int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return tiles16ms[index];\n        }\n        \n    }\n    return TILE_NONE;\n}\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 hsv2rgb(float h, float s, float v){\n    vec3 c = vec3(h, s, v);\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec4 gammaCorrect(vec4 rgba) {\n    return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),\n                rgba.a);\n}\n\nvec4 plane1 = vec4(0, 0, 0, 1); // (x, y, normalX, normalY)\nvec4 plane2 = vec4(0, 0, sin(PI_3), -cos(PI_3));\nvec4 plane3 = vec4(1, 0, -sin(2. * PI_3), cos(2. * PI_3));\nint IIS(vec2 pos) {\n    int invNum = 0;\n    for (int i = 0; i < 1000; i++) {\n        pos -= plane1.xy;\n        float dHalfPlane1 = dot(pos, plane1.zw);\n        if(dot(pos, plane1.zw) < 0. ) {\n            invNum++;\n            pos -= 2.0 * min(0., dHalfPlane1) * plane1.zw;\n            pos += plane1.xy;\n            continue;\n        }\n        pos += plane1.xy;\n\n        pos -= plane2.xy;\n        float dHalfPlane2 = dot(pos, plane2.zw);\n        if(dot(pos, plane2.zw) < 0. ) {\n            invNum++;\n            pos -= 2.0 * min(0., dHalfPlane2) * plane2.zw;\n            pos += plane2.xy;\n            continue;\n        }\n        pos += plane2.xy;\n\n        pos -= plane3.xy;\n        float dHalfPlane3 = dot(pos, plane3.zw);\n        if(dot(pos, plane3.zw) < 0. ) {\n            invNum++;\n            pos -= 2.0 * min(0., dHalfPlane3) * plane3.zw;\n            pos += plane3.xy;\n            continue;\n        }\n        pos += plane3.xy;\n    }\n\n    return invNum;\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sum = vec3(0);\n\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 pos = ((fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        pos *= 12.;\n        pos += vec2(14, 5);\n        \n        float a = TRIANGLE_TOP.y / TRIANGLE_TOP.x;\n        float x = pos.y / a;\n\n        float translatedX = mod(pos.x - x, 1.) + x;\n        float xIndex = floor(pos.x - x);\n\n        float yIndex = floor(pos.y / TRIANGLE_HEIGHT);\n\n        vec2 fundamentalPos = vec2(translatedX, pos.y) - TRIANGLE_TOP * yIndex;\n\n        xIndex *= 2.0;\n\n        fundamentalPos -= plane3.xy;\n        float dplane = dot(fundamentalPos, normalize(plane3.zw));\n        if(dplane < 0.) {\n            xIndex++;\n        }\n        fundamentalPos -= 2.0 * min(0., dplane) * plane3.zw;\n        fundamentalPos += plane3.xy;\n\n        float t = mod(iTime, 18.);\n        float strokeWeight = 3.;\n        //float strokeWeight = 0.01;\n        float startTime = 0.;\n        float durations = 3.;\n        strokeWeight = mix(2., 0., scene(t, startTime, durations));\n\n        startTime += durations;\n\n        durations = 8.;\n        g_currentLine = int(mix(-15., 80., scene(t, startTime, durations)));\n        startTime += durations;\n\n        startTime += 3.;\n        \n        durations = 3.;\n        strokeWeight += mix(0., 0.5, scene(t, startTime, durations));\n        startTime += durations;\n        if(abs(dot(fundamentalPos - plane1.xy, plane1.zw)) < strokeWeight ||\n           abs(dot(fundamentalPos - plane2.xy, plane2.zw)) < strokeWeight ||\n           abs(dot(fundamentalPos - plane3.xy, plane3.zw)) < strokeWeight) {\n            continue;\n        }\n\n        if(t < 10.) {\n            int tile = getTile(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        } else if(t < 10.5){\n            g_currentLine = -15;\n            int tile = getTileRandom(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n            \n        } else if(t < 11.){\n            g_currentLine = -15;\n            int tile = getTileRandom2(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        } else if(t < 11.5){\n            g_currentLine = -15;\n            int tile = getTileRandom16ms(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        } else {\n            int tile = getTile16ms(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        }\n    }\n    vec3 col = (sum/SAMPLE_NUM);\n\n    fragColor = gammaCorrect(vec4(col, 1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}