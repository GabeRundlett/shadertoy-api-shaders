{
    "Shader": {
        "info": {
            "date": "1675300277",
            "description": "A raytracer. Added light objects support (Uses a single extra line).\nAdded boxes.\nThere is an error in flat surfaces that I find impossible to fix (Streaks of light values).",
            "flags": 32,
            "hasliked": 0,
            "id": "clfSWS",
            "likes": 6,
            "name": "Raytracer  (Release v1.6)",
            "published": 3,
            "tags": [
                "raytracing",
                "raytracer",
                "pathtracing",
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "raymarchingenthusiast",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n    irand(float(iFrame)*8.,i);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define F float(iFrame)+1.\nstruct Material {\n    float roughness;\n    float shininess;\n    float refrIdx;\n    vec3 color;\n};\n\nstruct Light {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};\n\n\n#define sfloor(a) sign(a)*floor(abs(a))\n\n#define A vec3(2903.,347.,503.)\n#define B vec3(4139.,1459.,1723.)\nfloat seed;\nbool mode = false;\nfloat rand(void){\n  vec3 a = mode?A:B;\n  mode = !mode;\n  seed = mod(seed*a.x+a.y,a.z)/a.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  vec3 a = mode?A:B;\n  mode = !mode;\n  return mod(s*a.x+a.y,a.z)/a.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(srand(p.x+p.y*t)*p.y-t*p.x);\n  mode = sign(p.y*p.y-t*p.x)<0.?true:false;\n}\nvec3 boxSurfP(vec3 b) {\n    vec3 p = vec3(rand(),rand2());\n    float f = floor(rand()*6.);\n    if(f==0.) p.x = 0.;\n    if(f==1.) p.x = 1.;\n    if(f==2.) p.y = 0.;\n    if(f==3.) p.y = 1.;\n    if(f==4.) p.z = 0.;\n    if(f==5.) p.z = 1.;\n    p = 2.*p-1.;\n    p *= b;\n    return p;\n}\nvec3 aabbNor(vec3 p,vec3 b){\n    vec3 n = sfloor(p/b);\n    return normalize(n);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 o,in vec2 i) {\n    vec4 prev = texelFetch(iChannel0,ivec2(i),0);\n    vec4 new = prev;\n    \n    o = new;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Inf 9999.\n#define IG 2.2\n#define G 1./IG\n\nvec3 cosDir(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector()\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 d,float t) {\n    return vec3(0.);//.5,.65,.95\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd,int lId,float t) {\n    float d0 = sphInt(ro,rd,vec3(-1.,-.2,3.),.8).x;\n    if(d0 < 0.||lId==0) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    float d2 = sphInt(ro,rd,vec3(-2.5,1.,5.),2.).x;\n    if(d2 < 0.) d2 = Inf;\n    float d3 = sphInt(ro,rd,vec3(2.,.5,4.5),1.5).x;\n    if(d3 < 0.) d3 = Inf;\n    float d4 = boxInt(ro-vec3(1.75,1.,2.),rd,vec3(.9,.3,.6)).x;\n    if(d4 < 0.) d4 = Inf;\n    float d5 = boxInt(ro-vec3(0.,3.5,5.5),rd,vec3(1.)).x;\n    if(d5 < 0.||lId==2) d5 = Inf;\n    \n    \n    float d = min(min(d0,min(d2,min(min(d3,d5),d4))),d1);\n    //d = min(min(min(d4,d5),d0),d1);\n    if(d==Inf) return vec2(-1.);\n    \n    float m = -1.;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    if(d==d2) m = 3.;\n    if(d==d3) m = 4.;\n    if(d==d4) m = 5.;\n    if(d==d5) m = 6.;\n    \n    return vec2(d,m);\n}\n\nLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return Light(i,c,p+o);\n}\nLight genLight(float i,vec3 c,vec3 p,vec3 b){\n    vec3 o = boxSurfP(b)+p;\n    return Light(i,c,o);\n}\n\nvec3 getCam(float t,out vec3 uu,out vec3 vv,out vec3 ww,vec2 m) {\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n    //Keep above\n    \n    //Write below\n    \n    \n    \n    //Keep below\n    uu = normalize(uu);\n    vv = normalize(vv);\n    ww = normalize(ww);\n    return vec3(0.,1.,0.);\n}\n\nvec3 getObjectNorm(vec3 p, float id,float t) {\n    if(id==1.) return normalize(p-vec3(-1.,-.2,3.));\n    if(id==2.) return normalize(vec3(0.,1.,0.));\n    if(id==3.) return normalize(p-vec3(-2.5,1.,5.));\n    if(id==4.) return normalize(p-vec3(2.,.5,4.));\n    if(id==5.) return normalize(aabbNor(p-vec3(1.75,1.,2.),vec3(.9,.3,.6)));\n    if(id==6.) return normalize(aabbNor(p-vec3(0.,3.5,5.5),vec3(1.)));\n    //return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id,float t) {\n    if(id==1.) return Material(.85,5.,.05,vec3(.2,.2,.2));\n    if(id==2.) return Material(.95,45.,.5,vec3(.2,.2,.2));\n    if(id==3.) return Material(.01,20.,.05,vec3(.2,.2,.2));\n    if(id==4.) return Material(.9,40.,.5,vec3(.05,.2,.125));\n    if(id==5.) return Material(.85,60.,.05,vec3(.2,.2,.2));\n    if(id==6.) return Material(.05,5.,.2,vec3(.2,.2,.2));\n}\n//Glossiness (3rd comp) and Roughness (1st comp) should NEVER be 0.\nvoid getRay(out vec3 ro,inout vec3 rd,float r,vec3 p,vec3 n){\n    ro = p;\n    rd = normalize(reflect(rd,n)*(1.-r)+uniformVector()*r);\n}\n\nbool inLight(vec3 ro,vec4 ld,int lID,float t){\n    vec2 tres = worldInt(ro,normalize(ld.xyz),lID,t);\n    return tres.x>=ld.w||tres.y<0.||tres.x==-1.;\n    return true;\n}\n\n\n#define   spp   5.\n#define numLvls 3\n#define    rt   false\n//Set to true if the camera or \n//objects can move\n\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    float ftime = rt?iTime:0.;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    //.6 is shutter aperture\n    float ctime = ftime + (.5/24.)*rand();\n    \n    vec3 uu;vec3 vv;vec3 ww;\n    vec3 ro = getCam(ctime,uu,vv,ww,iMouse.xy);\n    \n    vec3 er = normalize(vec3( p.xy, 1. ));\n    vec3 rd = er.x*uu+er.y*vv+er.z*ww;\n    \n    //.0015 is blur amount\n    vec3 go = .002*vec3( -1. + 2.*rand2(), 0.);\n    //1.3 is focus distance\n    vec3 gd = normalize( er*1.3 - go );\n    \n    ro += go.x*uu+go.y*vv;\n    rd += gd.x*uu+gd.y*vv;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    for(int i = 0; i < numLvls; i++){\n        vec2 tres = worldInt(ro,rd,-1,ctime);\n    \n        if(tres.y<0.) {tcol+=fcol*getSky(rd,ctime);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n     \n        vec3 nor     = getObjectNorm(pos,tres.y,ctime);\n        vec3 ofp     = pos + nor*.001;\n        Material dat = getObjectData(pos,tres.y,ctime);\n        \n        vec3 color = vec3(0.);\n        {\n            Light l = genLight(30.,vec3(1.,.5,0.),vec3(-1.,-.2,3.),.8);\n            vec4 ld = vec4(l.pos-pos,length(l.pos-pos));\n            if(tres.y==1.){color+=l.color*fcol;}\n            else{if(inLight(ofp,ld,0,ctime)){\n                vec3 nld = normalize(ld.xyz);\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,nld),0.);\n                vec3 h = normalize(ld.xyz+(ro-pos));\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }}\n        }\n        {\n            Light l = genLight(40.,vec3(.1,.55,1.),vec3(0.,3.5,5.5),vec3(.99));\n            vec4 ld = vec4(l.pos-pos,length(l.pos-pos));\n            if(tres.y==6.){color+=l.color*fcol;}\n            else{if(inLight(ofp,ld,2,ctime)){\n                vec3 nld = normalize(ld.xyz);\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,nld),0.);\n                vec3 h = normalize(ld.xyz+(ro-pos));\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }}\n        }\n        {\n             vec4 ld = vec4(cosDir(nor),Inf);\n             if(inLight(ofp,ld,1,ctime)) color += getSky(ld.xyz,ctime)*fcol*dat.color;\n        }\n        \n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,dat.roughness,ofp,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(clamp(getPixCol(I),0.,1.),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}