{
    "Shader": {
        "info": {
            "date": "1722092117",
            "description": "original https://www.shadertoy.com/view/lcSczm# https://www.shadertoy.com/view/4tyfWy",
            "flags": 0,
            "hasliked": 0,
            "id": "lf2czm",
            "likes": 2,
            "name": "apollian man",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 96
        },
        "renderpass": [
            {
                "code": "#define TAU 6.2831853\n#define SCALE 10.\n\n#define C_BASE vec3(0.,0.,0.25)\n#define C_DOT vec3(0.5,0.,1.)\n#define C_HI1 vec3(1.,1.,1.)\n#define C_HI2 vec3(0.,1.,1.)\n\n\nvec2 cmult(vec2 p, vec2 q){return vec2(p.x*q.x-p.y*q.y,p.x*q.y+p.y*q.x);}\n\nvec2 csqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\nvec3 cdt(in vec3 a, in vec3 b, in vec3 c, in bool pos){\n  float z = 2.*sqrt(a.z*b.z+a.z*c.z+b.z*c.z)*(pos?1.:-1.);\n  vec3 d = vec3(0.,0.,a.z+b.z+c.z+z);\n  if(d.z == 0.){\n    //A line.  Can't find the center if it doesn't have one.\n    return d;\n  }\n  if(z == 0.){\n    //the easy way results in 0/0.  Time for the hard way.\n    d.xy = (a.z*a.xy + b.z*b.xy + c.z*c.xy + 2.*csqrt(cmult(a.xy,b.xy)*a.z*b.z + cmult(a.xy,c.xy)*a.z*c.z + cmult(b.xy,c.xy)*b.z*c.z)*(pos?1.:-1.) )/d.z;\n    return d;\n  }\n  float s = a.z+b.z+c.z+d.z;\n  d.xy = -(a.z*a.xy*(2.*a.z-s)+b.z*b.xy*(2.*b.z-s)+c.z*c.xy*(2.*c.z-s))/(d.z*(2.*d.z-s));\n  return d;\n}\n\nbool inTri(in vec3 a, in vec3 b, in vec3 c, in vec3 p) {\n  a.z = 0.;\n  b.z = 0.;\n  c.z = 0.;\n  p.z = 0.;\n  a -= p;\n  b -= p;\n  c -=p;\n  float u = cross(b, c).z;\n  float v = cross(c, a).z;\n  float w = cross(a, b).z;\n  if (u*v < 0.) {\n      return false;\n  }\n  if (u*w < 0.) {\n      return false;\n  }\n  return true;\n}\n\nbool hitDot(in vec3 p, in vec3 a){\n    return length(p.xy-a.xy)*a.z < 1.;\n}\n\nvec3 mapDot(in vec3 p, in vec3 a){\n    p.xy = (p.xy-a.xy)*a.z;\n    //p.z += sqrt(1.-length(p.xy))/a.z;\n    p.z = sqrt(p.z*p.z+(1.-length(p.xy))/a.z);\n    return p;\n}\n\n\nfloat proj(vec2 a, vec2 b){\n    return dot(a,b)/dot(b,b);\n}\n\nvec3 roDot(vec3 a,float s){\n    vec3 o = a;\n    o.xy = cmult( a.xy, vec2( sin(iTime*TAU/SCALE*s/2.) , cos(iTime*TAU/SCALE*s/2.) ) );\n    return o;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n#define resolution iResolution.xy\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Normalize vector\n    vec3 uv = vec3((fragCoord-iResolution.xy*0.5)*2./min(iResolution.x,iResolution.y),0.);\n    \nvec2 uv3 = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n   vec2 uv4 = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    uv.xy*=rot(0.85);\n    \n     uv3.x-=0.2;\n       \n    uv4.x+=0.2;\n    uv3.y+=0.2;\n       \n    uv4.y-=0.2;\n    uv4*=rot(iTime);\n     uv3*=rot(iTime);\n    //For points outside the circle, invert them into the circle\n    if(length(uv.xy) > 1.){\n        uv.xy = uv.xy/dot(uv.xy,uv.xy);\n    }\n    \n    \n    vec2 uv2 = (gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;\n    \n    float angle = atan((gl_FragCoord.y - resolution.y / 2.0) / (gl_FragCoord.x - resolution.x / 2.0));\n    \n    float d = length(uv);\n    float d1 = abs(sin(d * 5.0 + angle + time*0.));\n    d1 = 0.2 / d1;\n    float d2 = abs(sin(d * 5.0 + angle + time*0.));\n    d2 = 0.2 / d2;\n    float d3 = abs(sin(d * 4.0 + angle + time*.0));\n    d3 = 0.2 / d3;\n    float d4 = abs(sin(d * .0 - angle + time*0.));\n    d4 = 0.2 / d4;\n\n   vec3 c23= vec3(d3,d2,d1+d4);\n   \n    uv.z += (1.-length(uv.xy));\n   \n    \n    float inv = 1.;\n    \n    vec3 pa = vec3(0.,0.,-1.);\n    vec3 pb = vec3(0.,-0.5,2.);\n    vec3 pc = vec3(0.,0.5,2.);\n    vec3 pd = vec3(0.);\n    vec3 pe = vec3(0.);\n    \n    for(int i=0;i<20;i++){\n        //See if we've hit one of the reference circles\n       \n     \n\n        //Generate two new circles via Complex Descartes Theorem\n        pd = cdt(pa,pb,pc,false);\n        pe = cdt(pa,pb,pc,true);\n        \n        //Only one of them is useful.  Figure out which one.\n        float pdm = max(pa.z,max(pb.z,pc.z));\n        if(pd.z <= pdm){\n            pd = pe;\n        }\n        else if(pe.z - pd.z >1.5){\n            pd = pe;\n        }\n        else if(length(uv.xy-pe.xy) < length(uv.xy-pd.xy)){\n            pd = pe;\n        }\n        \n        //Did we hit our new circle?\n        if(hitDot(uv,pd)){\n            uv = mapDot(uv,pd);\n            inv *= -pd.z*sign(pa.z);\n            pa = vec3(0.,0.,-1.);\n            pb = vec3(0.,-0.5,2.);\n            pc = vec3(0.,0.5,2.);\n            uv = roDot(uv*c23,inv);\n            continue;\n        }\n        \n        //Are we between three circles?\n        if(inTri(pb,pc,pd,uv)){\n            pa = pd;\n            continue;\n        }\n        //(only A can have negative curvature, so we cheat a bit)\n        if(pa.z > 0. && inTri(pa,pc,pd,uv)){\n            pb = pd;\n            continue;\n        }\n        if(pa.z > 0. && inTri(pa,pb,pd,uv)){\n            pc = pd;\n            continue;\n        }\n        \n        //OK, so we're on an edge. Figure out if B or C needs replacement\n        float dir = proj((uv-pd).xy,(pc-pb).xy);\n        if(dir > 0.){\n            pb = pd;\n            continue;\n        }else{\n            pc = pd;\n            continue;\n        }\n        \n        //In theory, we should never get here.\n        \n        \n    }\n    \n    float run = uv.z/1.5;\n    //float depth = ((log(abs(inv)+1.)/log(max(iResolution.x,iResolution.y))+1.)-1.)*1.5;\n    float depth = (  log(abs(inv))  /  log(max(iResolution.x,iResolution.y))  );\n    float edge = length(uv.xy);\n    float cycleTime = fract(iTime/SCALE)*1.;\n    \n    float breath = cos(cycleTime*1.0*TAU)/3.+2./3.;\n    \n    float starLev = fract(abs(inv)/7.)*7.;\n    float starBreath = cos((cycleTime+starLev/7.)*TAU*6.)/2.+0.5;\n    \n    vec3 hi = mix(C_HI1,C_HI2,breath);\n    //vec3 peak = mix(C_DOT,hi,(1.-edge)*(1.-edge));\n    //vec3 twinkle = mix(peak,C_DOT,starBreath);\n    \n    vec3 dc = mix(C_DOT,hi,run);\n    \n    float pulse = starBreath/2.+0.5;\n    \n    //depth*smoothstep(1.0,0.9,edge)\n    \n    vec3 col = mix(C_BASE,dc,sqrt(depth)*smoothstep(pulse,pulse/2.,edge));\n    \n    \n    //depth*smoothstep(1.0,0.9,edge)\n    //vec3 col = vec3(,run,0.);\n    //col = col * (1.-col)*4.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n     fragColor+= vec4(happy_star(uv3, anim) * vec3(0.35,0.2,.15)*0.1, 1.0);\n      fragColor+= vec4(happy_star(uv4, anim) * vec3(0.35,0.2,1.15)*0.1, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}