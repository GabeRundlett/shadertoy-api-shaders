{
    "Shader": {
        "info": {
            "date": "1482679886",
            "description": "ha",
            "flags": 0,
            "hasliked": 0,
            "id": "MlKSzR",
            "likes": 29,
            "name": "StructureFlyThough",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "bump",
                "gyroid",
                "schwarz"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 1100
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec3 path(float p)\n{\n   return vec3(sin(p*0.01)*cos(p*0.025)*20., sin(p*0.02)*cos(p*0.0125)*18.,0.);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat schwarz(vec3 p)\n{\n    return sin(p.x)*sin(p.y)*sin(p.z)+sin(p.x)*cos(p.y)*cos(p.z)+cos(p.x)*sin(p.y)*cos(p.z)+cos(p.x)*cos(p.y)*sin(p.z);\n}\n\nfloat map(vec3 p)\n{\n    p-=path(p.z);\n    float d0=4.0-length(p.xy*vec2(0.2,0.4));  // Tunnel\n    float d1=schwarz(p*0.08); // Schwarz\n    float d2=dot(sin(p*0.6),cos(p.yzx*0.3)); // Gyroid\n    float d=smax(d0,-d1,1.);\n    d=smax(d,-d2,1.0);\n    return d;\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.1*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.x * 3.0);\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    float c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<150; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 200.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = map(ro + rd*t);\n            d = c;\n\n            if(d > os)\n            {\n                os = 0.5 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>200.0) t=-1.0;\n    return t;\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n\tfloat h = 1.0;\n    for( int i=0; i<24; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.001 )break;\n        t += clamp( h, 0.01, 2. );\n    }\n    return clamp(res,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    if (abs(p.y)>.85) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec3 ro = vec3(0.0, 0., iTime*6.);\n\tvec3 look = ro + vec3(0.3*sin(iTime*0.4), 0., 0.5);\n\n    ro+=path(ro.z);\n    look+=path(look.z);\n    vec3 forward=normalize(look-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    float t=intersect(ro,rd);\n    vec3 col=0.1*vec3(1.1,0.8,0.5);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 lp0=ro+vec3(0.0,50.0,0.0);\n        lp0+=path(lp0.z);\n        vec3 ld0=normalize(lp0-pos);\n        \n        vec3 material=texcube(iChannel0,pos*0.1,n).xyz;\n        material=pow(material,vec3(1.1,1.8,1.8));\n        \n\t    n=bump_mapping(pos, n, 2./(1.+t*0.5));\n        \n        float ao=get_ao(pos,n);\n        \n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 16.0));\n        float sha=softshadow( pos+0.2*ld0, ld0, 20.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.3)*amb*ao;\n        lin+=vec3(7.,4.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.5,0.3)*bac*1.0*ao;\n        lin+=vec3(spec*8.2)*sha;\n        \n        col=lin*0.2*material;\n     }\n    col=mix(col, 0.1*vec3(1.1,0.8,0.5), 1.0-exp(-0.0001*t*t) );\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=pow(col,vec3(1.3,1.,1.));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}