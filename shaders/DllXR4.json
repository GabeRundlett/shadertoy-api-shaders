{
    "Shader": {
        "info": {
            "date": "1674600958",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "DllXR4",
            "likes": 20,
            "name": "Year of Truchets #004",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #004\n    01/24/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nfloat mid,sid;\nmat2 flip,turn;\n\nvec3 colorA = vec3(.65);\nvec3 colorB = vec3(.40);\nvec3 colorC = vec3(.80);\n\nconst vec3 size = vec3(1.75,2.5,1.75);\nconst vec3 hlf =  size/2.;\nconst vec3 bs = vec3(hlf*.9);\nconst vec3  grid = vec3(1,1,1);\nconst float thick = .45/size.x;\n\nfloat u_hash = .6938;\nconst vec3 d = vec3(0.957,0.439,0.043);\nvec3 hue(float t){ return .5 + .4*cos(PI2*t*(vec3(.95,.97,.98)*d)); }\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    \n    p.x+=T*.25;\n    float pd = floor((p.x+4.)/8.);\n    mid=pd;\n    p.x=mod(p.x+4.,8.)-4.;\n    \n    p.yz*=flip;\n    p.xz*=turn;\n\n\n    vec3 q = p;\n\n    vec3 id = floor((q + hlf)/size)-grid;\n    id+=pd;\n    \n    q = q-size*clamp(round(q/size),-grid,grid);\n    vec3 fq = q;\n\n    float hs = hash21(id.xz+id.y+u_hash);\n    if(hs>.5) q.z*=-1.;\n\n    vec2 d2 = vec2(length(q.xz-hlf.xz), length(q.xz+hlf.xz));\n    vec2 gx = d2.x<d2.y ? vec2(q.xz-hlf.xz) : vec2(q.xz+hlf.xz);\n    vec3 tq = vec3(gx.x,q.y,gx.y);\n\n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = 1e5;\n\n    if(fract(xhs+id.x*33.32)>.75) q.zx*=rot(1.5707);\n    \n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf.x,.25,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf.z))-thick,trh);\n    }else if(rhs>.7){\n        float qy = .15+.15*sin((q.z+.5)*size.z*2.);\n        float qx = .15+.15*sin((q.x+.5)*size.x*2.);\n        trh = cap(q-vec3(0,.25+qy,0),hlf.x,thick);\n        trh = min(cap(q.zyx-vec3(0,.25-qx,0),hlf.z,thick),trh);\n    } else{\n        trh = trs(tq-vec3(0,.25,0),vec2(hlf.x,thick));\n    }\n    \n \n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        gtile.xyz = vec3(id.xz,1.);\n        gtile.w=mt;\n        res = vec2(trh,mt);\n        hit = tq;\n    } \n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.4,thick*1.1);\n    bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.4,thick*1.1),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.34,thick*1.45);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.34,thick*1.45),crt);\n    \n    bls=max(crt,-bls);\n    \n    if(bls<res.x) {\n       res = vec2(bls,1.);\n       hit = q;\n    } \n\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = 1e-4*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    float ftx = 276.;\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    uv = floor(uv*(ftx*R.x/R.y))/(ftx*R.x/R.y);\n\n    //u_hash+=floor(T*.1);\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse //\n    float x = M.z < 0. || M.xy==vec2(0) ? 0.0 : (M.y/R.y*2.-1.)*PI;\n    float y = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : T*.063;\n    \n    mat2 rx =rot(-.65);\n    mat2 ry =rot(.0);\n    \n    flip=rot(x);\n    turn=rot(y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    float m = 0.;\n    float d = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<164;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<d*1e-5||d>35.)break;\n        d += i<42? ray.x*.25: ray.x*.5;\n        m  = ray.y;\n    } \n\n    sid=mid;\n    colorA = hue(.00+u_hash+sid);\n    colorB = hue(.15+u_hash+sid);\n    colorC = hue(.60+u_hash+sid);\n\n    float alpha = 1.;\n\n    if(d<35.)\n    {\n    \n        hitPoint = hit;\n        alpha *=1e-5;\n        \n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(5,5,9.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),0. , 1.);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n      \n        float shdw = 1.0;\n        float t=.01;\n        for( int i =0; i<64; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<1e-4 ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<1e-4 || t>35. ) break;\n        }\n        diff = mix(diff,diff*shdw,.5);\n\n        vec3 h = vec3(.0);\n        \n        if(m==1.) {h=vec3(.35);}\n        if(m==2.) {h=colorB;}\n        if(m==3.) {h=colorC;}\n        if(m==4.) {h=colorA;}\n        if(m==5.) {h=vec3(.05);}\n\n        float xiff = diff;\n        if(diff<.6 && (mod(F.x,4.)==mod(F.y,4.))) xiff*=.3;\n        if(diff<.4 && (mod(F.x,3.)==mod(F.y,3.))) xiff*=.3;\n        if(diff<.2 && (mod(F.x,2.)==mod(F.y,2.))) xiff*=.3;\n        \n        if(spec>.25) xiff=clamp(xiff*1.15,0.,1.);\n        if(spec>.5 && (mod(F.x,2.)==mod(F.y,2.))) xiff=clamp(xiff*1.5,0.,1.);\n      \n        C = h*xiff;\n    }\n    \n\n    C = mix(C,mix(vec3(.025),vec3(.95),(uv.y+.5)*.25),1.-exp(-.0005*d*d*d));\n    C = clamp(C,vec3(1e-3),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}