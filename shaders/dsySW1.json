{
    "Shader": {
        "info": {
            "date": "1681024996",
            "description": "Shadertoy adaptation of my livecoded shader during Hoffman's DJ set. Might be more glitchy in here than in bonzomatic.",
            "flags": 32,
            "hasliked": 0,
            "id": "dsySW1",
            "likes": 3,
            "name": "Revision 2023 ShaderJam - eimink",
            "published": 3,
            "tags": [
                "sdf",
                "livecode",
                "shaderjam",
                "fakeglow"
            ],
            "usePreview": 0,
            "username": "eimink",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hello Revision 2023!\n\nconst float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 64;\n\nfloat time;\nfloat fft;\nfloat ffts;\n\nvec3 glow = vec3(0.0);\n\nvoid rot(inout vec2 p, float a){\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat box(vec3 p, float b){\n  vec3 d = abs(p)-b;\n  return length(max(d,.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat scene(vec3 p){\n  vec3 pp = p;\n  \n  for(int i = 0; i < 4; ++i){\n    pp = abs(pp) - vec3(0.75, 2.0, 1.5);\n    rot(pp.xz, time*0.3+sin(4.*fft));\n    rot(pp.zy, fft*2.5);\n    rot(pp.xy, fft*0.5+time*0.1+cos(8.*ffts));\n  }\n  \n  float spheres = sphere(pp,1.0+ffts*50.);\n  float spheres2 = sphere(pp,3.+ffts*5.);\n  float spheres3 = sphere(pp,3.25+ffts*5.);\n  float spheres4 = sphere(pp,3.5+ffts*5.);\n  float spheres5 = sphere(pp,3.75+ffts*5.);\n  float spheres6 = sphere(pp,4.+ffts*5.);\n  \n  pp = p;\n  for (int i = 0; i < 3; ++i){\n    pp = abs(pp) - vec3(2.5,2.5,3.5);\n    rot(pp.xz, time*.5+cos(10.*ffts));\n    rot(pp.xy, fft*5.2);\n  }\n  float boxes = box(pp,1.0);\n  \n  pp = p;\n  \n  for (int i = 0; i < 5; ++i)\n  {\n    pp = abs(pp) - vec3(.5,3.0,5.5);\n    rot(pp.xy, time*.2+sin(6.*fft));\n    rot(pp.yz, time*.6+cos(12.*ffts));\n  }\n  \n  float boxes2 = box(pp,1.0*ffts*5.);\n  glow += vec3(0.9,0.04,0.5) * 0.05 / abs(boxes2)+0.01;    \n  glow += vec3(0.5,0.04,0.9) * 0.01 / abs(boxes)+0.001;\n  glow += vec3(0.08,0.45,0.85) * 0.02 / abs(spheres) +0.01;\n  glow += vec3(0.85,0.08,0.45) * 0.012 / abs(spheres3)+0.001;\n  glow += vec3(0.85,0.8,0.85) * 0.012 / abs(spheres4)+0.001;\n  glow += vec3(0.08,0.45,0.85) * 0.02 / abs(spheres2) +0.01;\n  glow += vec3(0.85,0.08,0.45) * 0.012 / abs(spheres5)+0.001;\n  glow += vec3(0.08,0.45,0.85) * 0.02 / abs(spheres6) +0.01;\n  return sphere(p,1.+ffts*12.);\n}\n\nfloat march (vec3 ro, vec3 rd){\n  float t = E;\n  vec3 p = ro;\n  for(int i = 0; i < STEPS; ++i)\n  {\n    float d = scene(p);\n    t += d;\n    p = ro+rd * t;\n    if (d < E || t > FAR) {\n      break;\n    }\n  }\n  return t;\n}\n\nvec3 normals(vec3 p){\n  vec3 e = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p + e.xyy) - scene(p - e.xyy),\n    scene(p + e.yxy) - scene(p - e.yxy),\n    scene(p + e.yyx) - scene(p - e.yyx)\n  ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 ld){\n  vec3 n = normals(p);\n  \n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(rd, ld), n), 0.0);\n  float s = pow(a, .1);\n  \n  return vec3(1.)*l + vec3(.9)*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 col = vec3(0.0);\n  time = iTime;\n  ffts = texelFetch( iChannel0, ivec2(85,.25), 0).x*.05; \n  fft = iTime*.05+abs(texelFetch( iChannel0, ivec2(.1,.25), 0).x)*.01; \n  \n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 q = -1.0 + 2.0*uv;\n  q.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(4.0-sin(2.0*time)+sin(4.0*time)*3., -4.0+sin(time+ffts)*3., 15.0+cos(time)*5.);\n  vec3 rt = vec3(0.0, 0.0, -1.0);\n  \n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z, vec3(0.0,1.0,0.0)));\n  vec3 y = normalize(cross(x,z));\n  vec3 rd = normalize(mat3(x,y,z)*vec3(q,1.0/radians(94.0)));\n  \n  float t = march(ro, rd);\n  vec3 p = ro + rd * t;\n  vec3 ld = normalize(vec3(0.0,0.0,-10.0)-p);\n  \n  rot(q, time*.5);\n  \n  if (t < FAR){\n    col = shade(rd, p, ld)*.05;\n  }\n  \n  col += glow;\n  \n  fragColor = vec4(col,1.);\n  \n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufA = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec4 bufB = texelFetch(iChannel1,ivec2(fragCoord),0);\n    fragColor = mix(bufB,bufA,0.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}