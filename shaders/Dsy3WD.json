{
    "Shader": {
        "info": {
            "date": "1678492715",
            "description": "It came to pass, that there were clouds and lightning, and an eye was formed. \nAn auto-VJ made from flattened spheres and line combinations.\n\nUse with music in iChannel0 & noise texture in iChannel1.",
            "flags": 64,
            "hasliked": 0,
            "id": "Dsy3WD",
            "likes": 8,
            "name": "Thunder Eye",
            "published": 3,
            "tags": [
                "music"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// Thunder Eye 0.93.230311 by QuantumSuper\n// auto-vj from 2d-spheres and lines\n// \n// - use with music in iChannel0 & noise texture in iChannel1 -\n\n#define PI 3.14159265359\nvec4 fft, ffts; //compressed frequency amplitudes\n\nmat2 rotM(float a){float c = cos(a), s = sin(a); return mat2(c,s,-s,c);} //2D rotation matrix from angle in radians\nfloat rand(float a, float b){return texture(iChannel1,vec2(a,b),0.).x;} //pseudo random from texture\n\nfloat sphere(vec2 pos, float r){ //inverse inner circle distance\n    float lPos = length(pos)/r;\n    return (lPos<1.) ? (1.-lPos) : 0.;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){ //a line between a and b in domain of p\n\tvec2 c = b-a;\n\treturn clamp(.001/length(a+(c)*clamp(dot(p-a,c)/dot(c,c),0.,1.)-p),.0,1.);\n}\n\nvoid compressFft(){ //compress sound in iChannel0 to simple frequency-range amplitude estimations \n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz, each sample\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz, second sample\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz, fourth sample\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n    //fft.x = step(.7,fft.x); //weaken weaker sounds, hard limit\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // General initializations\n    compressFft(); //initializes fft, ffts\n    vec2 uv = .5+2.*(fragCoord-.5*iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -.5 to 1.5\n    float aTime = 2.133333*iTime;\n    float sTime = .001*iTime;\n\n    // Background preparation\n    float isBack =  1.-smoothstep(.01,.0,length(uv-.5)-.5/(.95+.2*sin(aTime/16.)*fft.x));\n    uv = (step(.7,fft.x)<.5) ? uv : mix(2.*fract((4.*fract(.15-sTime)+1.)*uv*rotM(sTime))-.5, uv, 1.-isBack); //eye repetition\n \n    // Fog\n    float amp = 0.;\n    float aFrac;\n    for (float n=0.;n<1.;n+=.05){\n        aFrac = fract(.05*aTime+n);\n        amp += sphere(uv-vec2(rand(n,.456*sTime),rand(.254*sTime,n)),.1+rand(.5*n,.5*sTime)*aFrac)*smoothstep(1.,.33,aFrac)*smoothstep(.0,.66,aFrac);   \n    }\n    vec3 col = vec3(.1*fft.z*amp); //add fog\n    \n    // Lightning \n    float lightn = 0.;\n    vec4 lPos;\n    uv = uv-vec2(.5); //set 0,0 at screen center\n    uv *= .95+.2*sin(aTime/16.)*fft.x; //eye zoom\n    vec2 irisPos = (.1-.2*vec2(rand(.123*ceil(sTime),.456*ceil(aTime/2.)),rand(.123*floor(aTime/2.),.456*floor(sTime)))+.01*fft.w);\n    float irisRad = .2*(.9+.2*ffts.w);\n    mat2 myRotM = rotM(.2*PI); //m times equals full rotation\n    for (float m=.0;m<10.;m++){ //?I guess here is a lot of room for parallel computation optimization?\n        uv *= myRotM;\n        irisPos *= myRotM;\n        lPos = vec4(.5*irisRad)+irisPos.xyxy; //start pos\n        for (float n=.1;n<1.;n+=.1){\n            lPos.zw += .1*vec2(rand(n,.123*m*ceil(aTime))-.4*n,rand(.1*m+.456*ceil(aTime),n*n)-.3*n*fft.y);\n            lightn += line(uv, lPos.xy, lPos.zw);\n            lPos.xy = lPos.zw*1.014; //fast fix against overlap\n        }\n    }     \n    lightn *= .6*ffts.w*(smoothstep(.0,1.,.1/sphere(uv-irisPos,irisRad))-smoothstep(1.,0.,sphere(uv,.5))); //inner & outer \"vignette\"\n    lightn -= clamp(10.*sphere(uv-irisPos,irisRad),.0,1.-.8*clamp(amp,.0,1.)); //center iris\n    lightn /= amp*amp*amp; //dampen lightning by fog\n    col += lightn*mix( (vec3(fft.y>=fft.z,fft.z>=fft.w,fft.w>=fft.y)+vec3(ffts.y<=ffts.z,ffts.z<=ffts.x,ffts.x<=ffts.z))*vec3(sin(aTime),cos(aTime),.33), vec3(1), smoothstep(.0,-.03,length(uv-irisPos)-irisRad)); //add colored lightning\n    col += .5/clamp(amp*amp*amp,.5,5.)*ffts.w*sphere(((uv-.8*irisPos)*rotM(.8-isBack*sTime)-vec2(1.45*irisRad,.0))*vec2(.65,3.),.09); //highlight \n    \n    // Background finalization\n    uv = .5+2.*(fragCoord-.5*iResolution.xy) / max(iResolution.x, iResolution.y); //reset uv, long edge -.5 to 1.5\n    col = (step(.7,fft.x)<.5) ? col : mix(.66*clamp(col,.0,1.),col,1.-isBack); //set visibility\n    \n    // Output\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32880,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/neo_records/mirzika-dans-tes-raves-nrts06"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}