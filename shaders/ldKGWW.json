{
    "Shader": {
        "info": {
            "date": "1454547791",
            "description": "An experiment in building a scene using the Mercury GLSL Library and Inigo Quilez' distance functions, based on the\n\"Simple test/port of Mercury's SDF Library to WEBGL\" by tomkh, and code from other sources.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKGWW",
            "likes": 26,
            "name": "A Sphere Amid A Pyramid",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sphere",
                "pyramid",
                "mercury",
                "hgsdf"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 1285
        },
        "renderpass": [
            {
                "code": "/*  \n \tA SPHERE AMID A PYRAMID\n \n\tCode is mainly based on\n\t\n\thttps://www.shadertoy.com/view/Xs3GRB\n\tUploaded by tomkh on 2015-Dec-16\t\n\tSimple test/port of Mercury's SDF library to WebGL.\n\t\n\tMinor editing and modification by wjb. \n\tExcerpted functions with my comments that were removed from this code are\n\tattached at the bottom of this file, as well as a program flow analysis \n\tthat helped me figure out what was going on in the original code, in the hope\n    that someone else might find them useful.\n\n\tAdditional sources:\n\t===================\n\tHG_SDF GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n\thttp://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\thttps://github.com/ashima/webgl-noise\n\n\thttps://www.shadertoy.com/view/lll3z4\n\tGardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n\t\n\thttp://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n    Source - Raymarching.com\n    Author - Gary \"Shane\" Warne\n    eMail - mail@Raymarching.com, mail@Labyrinth.com\n    Last update: 28th Aug, 2014\n\n\thttps://iquilezles.org/articles/distfunctions\n\n*/\n//==============================================================================\n\n#define PI 3.141592653589793\n\nconst int nTerms = 10;\nconst int iterations = 160;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = 0.001; \nconst float cam_dist = 17.0;\nconst float eps = 0.005;\n\nvec3 surfNormal = vec3(0.0 );\n                                                           \n//------------------------------------------------------------------------------\n// Function declarations \nvec2 scene(vec3 p);\t\nfloat pMirror (inout float p, float dist);\nfloat fSphere(vec3 p, float r);\nfloat fBox(vec3 p, vec3 b);\nfloat fCylinder(vec3 p, float r, float height);\nfloat fOpUnionStairs(float a, float b, float r, float n);\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat snoise(vec3 v);\n\n//------------------------------------------------------------------------------\n// Triangular Prism - signed\n// https://iquilezles.org/articles/distfunctions\n// Modified from sdTriPrism()\n\n// Prism with apex parallel to z-axis\nfloat sdPrismZ( vec3 p, float angleRads, float height, float depth ) \n{\n    // sin 60 degrees = 0.866025\n    // sin 45 degrees = 0.707107\n    // sin 30 degrees = 0.5\n    // sin 15 degrees = 0.258819\n    vec3 q = abs( p );\n    return max( q.z - depth, \n           max( q.x * angleRads + p.y * 0.5, -p.y ) - height * 0.5 );\n}\n//------------------------------------------------------------------------------\n\n// Prism with apex parallel to x-axis\nfloat sdPrismX( vec3 p, float angleRads, float height, float depth ) \n{\n    vec3 q = abs( p );\n    return max( q.x - depth, \n           max( q.z * angleRads + p.y * 0.5, -p.y ) - height * 0.5 );                                                         \n}\n//------------------------------------------------------------------------------\n\n// For a 60 degree pyramid, height must be equal to depth. If height is greater\n// than depth, a square base is drawn beneath the pyramid. \n\n// If height is less than depth, the drawn depth will only be as large as height.\n\n// For angles less than 60 degrees, the depth must be proportionately larger\n// than the height to avoid a square base beneath the pyramid.\n\nfloat sdPyramid( vec3 p, float angleRads, float height, float depth )\n{\n    // Limited to range of 15 to 60 degrees ( for aesthetic reasons ).\n    angleRads = clamp( angleRads, 0.258819, 0.866025 );\n    vec3 q = abs( p );\n\t\n\t// Intersection of prisms along two perpendicular axes.\n\treturn max( sdPrismX( p, angleRads, height, depth ), \n\t            sdPrismZ( p, angleRads, height, depth ) );\n\n}\n//------------------------------------------------------------------------------\n\n// SCENE\n// -----\n\nvec2 scene( vec3 p )\n{\n\t// Domain Manipulation.\n\t//---------------------\n\t// Mirror at an axis-aligned plane which is at a specified distance \n\t// <dist> from the origin.\n\tpMirror( p.x, 0.0 );\n\tpMirror( p.z, 0.0 );\n\t\n\t// Object initialization.\n\t//------------------------\t\n\t// Center pyramid\n\t//---------------\n\tfloat objID = 1.0;\n\tvec2 pyramid = vec2( sdPyramid( p - vec3( 0.0, -0.25, 0.0 ), 0.866025, \n\t                                                       3.5, 3.5 ), objID );\n\n\tvec2 innerFrontPyramid = vec2( sdPyramid( p - vec3( 0.0, -0.25, 0.55 ), \n\t                                            0.866025, 2.6, 2.66 ), objID ); \n\n\tvec2 innerEastPyramid = vec2( sdPyramid( p - vec3( 0.55, -0.25, 0.0 ), \n\t                                            0.866025, 2.6, 2.66 ), objID ); \t\n\t// Sphere inside center pyramid\n\t//-----------------------------\n\tobjID = 2.0;\n\tvec2 centerSphere = vec2( fSphere( p - vec3( 0.0, -0.25, 0.0 ), 0.8 ), \n\t                                                                   objID );\t               \n\t// Sphere above center pyramid\n\t//----------------------------\n\tobjID = 3.0;\n\tvec2 upperSphere = vec2( fSphere( p - vec3( 0.0, 5.0, 0.0 ), 0.3 ), \n\t                                                                   objID );\t\t\n\t// Corner gazebo\n\t//--------------\n\tobjID = 4.0;\n\tvec2 cornerBox = vec2( fBox( p - vec3( 5.0, -0.225, 5.0 ), \n\t                                       vec3( 0.75, 1.75, 0.75 ) ), objID ); \t\n\n\tvec2 boxHollow = vec2( fCapsule( p, vec3( 5.0, -1.2, 5.0 ), \t                                     \n\t                                    vec3( 5.0,  0.6, 5.0 ), 0.9 ), objID );                             \n\t// Mound beneath corner gazebo                                                                   \t                                       \n\t//----------------------------\n\tobjID = 5.0;\n\tvec2 cornerMound = vec2( fSphere( p - vec3( 5.0, -4.25, 5.0 ), 3.0 ), \n\t                                                                   objID );\t\n\tvec2 sphereHide = vec2( fBox( p - vec3( 5.0, -5.0, 5.0 ),\n\t                                          vec3( 3.1, 3.0, 3.1 ) ), objID );\n\t// Pyramid atop gazebo\n\t//--------------------\n\tobjID = 6.0;\n\tvec2 cornerPyramid = vec2( sdPyramid( p - vec3( 5.0, 2.15, 5.0 ), 0.866025,\n\t                                                     1.25, 1.25 ), objID );\t\n\n\t// Because these cutout pyramids are not at origin, like the center pyramid,\n\t// one for each side is necessary.\n\tvec2 innerFrontCornerPyramid = vec2( sdPyramid( p - vec3( 5.0, 2.15, 5.15 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\n\tvec2 innerEastCornerPyramid = vec2( sdPyramid( p - vec3( 5.15, 2.15, 5.0 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\t                                                            \n\tvec2 innerBackCornerPyramid = vec2( sdPyramid( p - vec3( 5.0, 2.15, 4.85 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\n\tvec2 innerWestCornerPyramid = vec2( sdPyramid( p - vec3( 4.85, 2.15, 5.0 ), \n\t                                            0.866025, 1.0, 1.25 ), objID );\n\t// Corner sphere\n\t//--------------\n\tobjID = 8.0;\n\tvec2 cornerSphere = vec2( fSphere( p - vec3( 5.0, 2.25, 5.0 ), 0.25 ), \n\t                                                                   objID );\t\t\n\t// Upper corner sphere\n\t// -------------------\n\tobjID = 9.0;\n\tvec2 upperCornerSphere = vec2( fSphere( p - vec3( 5.0, 4.0, 5.0 ), 0.15 ), \n\t                                                                   objID );\t               \n\t// East globe platform\n\t//--------------------\n\tobjID = 16.0;\n\tvec2 eastGlobePlatform = vec2( fCylinder( p - vec3( 8.0, -1.95, 2.0 ),\n\t                                                     1.25, 0.05 ), objID );\t\t\n\t// East Globe\n\t//-----------\n\tobjID = 10.0;\n\tvec2 eastGlobe = vec2( fSphere( p - vec3( 8.0, -1.0, 2.0 ), 1.0 ), objID );\n\t\n\tvec2 innerEastHollowTop = vec2( fCapsule( p, \n\t           vec3( 7.0, 0.0, 2.0 ), vec3( 9.0, -2.0, 2.0 ), 0.475 ), objID );\t\n\t\n\tvec2 innerEastHollowBtm = vec2( fCapsule( p, \n\t           vec3( 9.0, 0.0, 2.0 ), vec3( 7.0, -2.0, 2.0 ), 0.475 ), objID );\n\t\n\tvec2 innerFrontHollowTop = vec2( fCapsule( p, \n\t           vec3( 8.0, 0.0, 3.0 ), vec3( 8.0, -2.0, 1.0 ), 0.475 ), objID );\t\n\t\n\tvec2 innerFrontHollowBtm = vec2( fCapsule( p, \n\t           vec3( 8.0, 0.0, 1.0 ), vec3( 8.0, -2.0, 3.0 ), 0.475 ), objID );\n\t\n\tvec2 innerFrontHollowLeft = vec2( fCapsule( p,\n\t          vec3( 7.0, -1.0, 3.0 ), vec3( 9.0, -1.0, 1.0 ), 0.475 ), objID );\n\t\n\tvec2 innerFrontHollowRight = vec2( fCapsule( p,\n\t          vec3( 9.0, -1.0, 3.0 ), vec3( 7.0, -1.0, 1.0 ), 0.475 ), objID );\n\t          \t\n\t// Pyramid above east globe\n\t//-------------------------\n\tobjID = 15.0;\n\tvec2 globePyramid = vec2( sdPyramid( p - vec3( 8.0, 1.0, 2.0 ), 0.866025,\n\t                                                     0.35, 0.35 ), objID );\t\n\t// Sphere in globe\n\t//----------------\n\tobjID = 11.0;\n\tvec2 sphereInGlobe = vec2( fSphere( p - vec3( 8.0, -1.0, 2.0 ), 0.5 ), \n\t                                                                   objID );\n\t// Front pyramid platform\n\t//-----------------------\n\tobjID = 12.0;\n\tvec2 frontPyramidPlatform = vec2( fCylinder( p - vec3( 0.0, -1.85, 8.0 ),\n\t                                                     2.25, 0.15 ), objID );\n\t// Front pyramid\n\t//--------------\t\n\tobjID = 13.0;\n\tvec2 frontPyramid = vec2( sdPyramid( p - vec3( 0.0, -0.8, 8.0 ), 0.866025, \n\t                                                     1.75, 1.75 ), objID );\t\n\tvec2 sphereHollow = vec2( fSphere( p - vec3( 0.0, -1.5, 8.0 ), 1.5 ), \n\t                                                                   objID );\n\t// Front pyramid sphere\n\tobjID = 14.0;\n\tvec2 frontPyramidSphere = vec2( fSphere( p - vec3( 0.0, -0.9, 8.0 ), 0.5 ), \n\t                                                                   objID );\n\t// Sphere above front pyramid\n\tobjID = 17.0;\n\tvec2 frontPyramidUpperSphere = \n\t                  vec2( fSphere( p - vec3( 0.0, 2.5, 8.0 ), 0.2 ), objID );\n\t                                                                    \n\t//------------------------------------------\n\t// Combination operations.\n\t\n\tpyramid = max( pyramid, -innerFrontPyramid );\n\tpyramid = max( pyramid, -innerEastPyramid );\n\t\n\tcornerMound = max( cornerMound, -sphereHide );\t\n\tcornerBox = max( cornerBox, -boxHollow );\n\t\n\tcornerPyramid = max( cornerPyramid, -innerFrontCornerPyramid );\n\tcornerPyramid = max( cornerPyramid, -innerEastCornerPyramid );\n\tcornerPyramid = max( cornerPyramid, -innerBackCornerPyramid );\n\tcornerPyramid = max( cornerPyramid, -innerWestCornerPyramid );\n\n\tobjID = 7.0;\n\tvec2 cornice = vec2( fOpUnionStairs( cornerBox.s, cornerPyramid.s,\n\t                                                      0.25, 4.0 ), objID );\n\n    eastGlobe = max( eastGlobe, -innerEastHollowTop );\n\teastGlobe = max( eastGlobe, -innerEastHollowBtm );\n\teastGlobe = max( eastGlobe, -innerFrontHollowTop );\n\teastGlobe = max( eastGlobe, -innerFrontHollowBtm );\n\teastGlobe = max( eastGlobe, -innerFrontHollowLeft );\n\teastGlobe = max( eastGlobe, -innerFrontHollowRight );\n\t\n\tfrontPyramid = max( frontPyramid, -sphereHollow );\n\t\n\t//-----------------------------------------------\n\t// Distance comparisons.\n    //----------------------\n\t// Note that the line comparing 'cornice' must be placed before both \n    // 'cornerBox' and 'cornerPyramid'; otherwise it changes their color\n    // and textures to its own.\n\tvec2 closer = pyramid.s < centerSphere.s ? pyramid : centerSphere;\n\tcloser = pyramid.s < centerSphere.s ? pyramid : centerSphere;\n\tcloser = closer.s < upperSphere.s ? closer : upperSphere;\n\tcloser = closer.s < cornice.s ? closer : cornice;\n\tcloser = closer.s < cornerBox.s ? closer : cornerBox;\n\tcloser = closer.s < cornerPyramid.s ? closer : cornerPyramid;\n\tcloser = closer.s < cornerMound.s ? closer : cornerMound;\n\tcloser = closer.s < cornerSphere.s ? closer : cornerSphere;\n\tcloser = closer.s < upperCornerSphere.s ? closer : upperCornerSphere;\n\tcloser = closer.s < eastGlobe.s ? closer : eastGlobe;\n\tcloser = closer.s < sphereInGlobe.s ? closer : sphereInGlobe;\n\tcloser = closer.s < frontPyramidPlatform.s ? closer : frontPyramidPlatform;\n\tcloser = closer.s < frontPyramid.s ? closer : frontPyramid;\n\tcloser = closer.s < frontPyramidSphere.s ? closer : frontPyramidSphere;\n\tcloser = closer.s < globePyramid.s ? closer : globePyramid;\n\tcloser = closer.s < eastGlobePlatform.s ? closer : eastGlobePlatform;\n\tcloser = closer.s < frontPyramidUpperSphere.s ? closer : \n\t                                                   frontPyramidUpperSphere;\t\n\treturn closer;\n}\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n    \n    // Updated 2-16-16 because the shader wouldn't auto-animate until clicked into. This if/else\n    // clause was intended to stop auto-animation if user was manipulating world with mouse.\n    // if ( iMouse.z < 0.0 )\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n    }\n    else\n    {\n    \tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n    }\n    sinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if ( iMouse.z < 0.0 )\n    {\n        ang = 1.5 * ( abs( 2.0 * fract( iTime * 0.01 ) - 1.0 ) - 0.25 );\n    }\n    else\n    {\n    \tang = ( iMouse.y - iResolution.y * 0.5 ) * rotRange; \n    }\n    sinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// http://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n\n// Source - Raymarching.com\n// Author - Gary \"Shane\" Warne\n// eMail - mail@Raymarching.com, mail@Labyrinth.com\n// Last update: 28th Aug, 2014\n\nvec3 getNormal( in vec3 p ) \n{\t\t\n\tvec2 e = vec2( eps, 0.0 );\n\treturn normalize( vec3( scene( p + e.xyy ).s - scene( p - e.xyy ).s, \n\t                        scene( p + e.yxy ).s - scene( p - e.yxy ).s, \n\t                        scene( p + e.yyx ).s - scene( p - e.yyx ).s ));\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// RAYMARCH\n// --------\n\nvec4 raymarch( vec3 rayOrig, vec3 rayDir )\n{\n   vec3 p = rayOrig;\n   vec2 nearest = vec2( 0.0 );\n   float rayLength = 0.0;\n   \n   for( int i = 0; i < iterations; ++i ) \n   {\n\t\tnearest = scene( p );\n\t\tfloat dist = nearest.s;\n\t\t\n\t\tif ( dist < dist_eps ) \tbreak;\t\t\n\t\tif ( rayLength > ray_max ) return vec4( 0.0 );\n\t\t\n\t\tp += dist * rayDir;\n\t\trayLength += dist;\n   }\n   \n   return vec4( p, nearest.t );\n}\n\n// end raymarch()\n\n//------------------------------------------------------------------------------\n\n// GET TEXTURE\n// -----------\n\n// Slightly modified and reformatted the original code from\n// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n// by David J. Eck : http://math.hws.edu/graphicsbook/\n// ---------------\n// Creative Commons Attribution-Noncommercial-ShareAlike 4.0 License.\n\nvec4 getTexture( int texNum, vec3 pos, float scale, float complexity, \n                                                  vec4 objClr, float mixVal )\n{\n\tvec3 v = vec3( 0.0 ),\n\t     color = vec3( 0.0 );\n\t     \n\tfloat value = 0.0;\n\t\n\tif ( texNum == 19 )\n\t{\n\t\t// wjb modified Perlin Noise 3D\n\t\t// With complexity = 1.0, squiggly lines in objColor on white\n\t\tv = pos * scale;\n\t\tvalue = log( pow( snoise( v ), 2.0 ) ) * complexity; \n\t    value = 0.75 + value * 0.25;\n\t    color = vec3( value);    \t\t    \n\t    return mix( vec4( color, 1.0 ), objClr, mixVal );        \t\t\t\t\n\t}\n\telse if ( texNum == 20 )\n\t{\n\t\t// wjb modified Perlin Noise 3D\n\t\t// white squiggly lines on objClr\n\t\tv = pos * scale;\n\t\tvalue = inversesqrt( pow( snoise( v ), 2.0 ) ) * complexity; \n\t    value = 0.75 + value * 0.25;\n\t    color = vec3( value);    \t\t    \n\t    return mix( vec4( color, 1.0 ), objClr, mixVal );\n\t}\n\telse if ( texNum == 21 )\n\t{        \t\t\t\t\n\t\t// wjb modified Perlin Noise 3D\n\t\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t\t// on white background\n\t\tv = pos * scale;\n\t\tvalue = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n\t    value = 0.75 + value * 0.25;\n\t    color = vec3( value);    \t\t    \n\t    return mix( vec4( color, 1.0 ), objClr, mixVal );        \t\t\t\t\n\t}\n\n\treturn vec4( 0.0 );\n}\n\n// end getTexture()\n\n//------------------------------------------------------------------------------\n\n// APPLY TEXTURE\n// -------------\n\nvec3 applyTexture( vec4 hitPosAndID )\n{\n\tvec4 objClr = vec4( 0.0 );\n\t\n\tvec3 pos = hitPosAndID.xyz,\n\t     base_color = vec3( 0.0 );\n\t\n\tfloat scale = 0.0,\n\t      complexity = 0.0,\n\t      mixVal = 0.0; \n\n\tint texNum = 0,\n\t    objNum = int ( hitPosAndID.w );\n\t      \n\t//  1: pyramid\n\t// 11: sphere in globe\n\t// 12: front pyramid platform\n\t// 16: east globe platform\t\n\tif ( objNum == 1 || objNum == 11 || objNum == 12 || objNum == 16 )\n\t{\t\t\t\t\n\t\ttexNum = 20;\n\t\tobjClr = vec4( 0.15, 0.5, 1.0, 1.0 );\n\t\tscale = 1.5;\n\t\tcomplexity = 4.0,\n\t\tmixVal = 0.85;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t//  2: center sphere\n\t// 15: globe pyramid\n\telse if ( objNum == 2 || objNum == 15 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t// 3: upper sphere\n\telse if ( objNum == 3 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 5.0;\n\t\tcomplexity = 5.0,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\t\t\n\t// 4: corner gazebo\n\telse if ( objNum == 4 )\n\t{\n\t\ttexNum = 19;\n\t\tobjClr = vec4( 0.2, 0.275, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 0.5,\n\t\tmixVal = 0.6;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t// 5: mound beneath corner gazebo\n\telse if ( objNum == 5 || objNum == 7 )\n\t{\t\n\t\ttexNum = 19;\n\t\tobjClr = vec4( 0.66, 0.66, 1.0, 1.0 );\n\t\tscale = 3.0;\n\t\tcomplexity = 0.75,\n\t\tmixVal = 0.5;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t//  6: pyramid atop corner gazebo\n\t// 14: front pyramid sphere\n\t// 17: front pyramid upper sphere\n\telse if ( objNum == 6 || objNum == 14 || objNum == 17 )\n\t{\n\t\ttexNum = 20;\n\t\tobjClr = vec4( 0.5, 0.4, 1.0, 1.0 );\n\t\tscale = 3.0;\n\t\tcomplexity = 5.0,\n\t\tmixVal = 0.85;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\n\t// 8: corner sphere\t\n\telse if ( objNum == 8 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\t\t\n\t// 9: upper corner sphere\n\telse if ( objNum == 9 )\n\t{\n\t\ttexNum = 21;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                      objClr, mixVal ).xyz;\n\t}\n\t// 10: east globe\n\t// 13: front pyramid\n\telse if ( objNum == 10 || objNum == 13 )\n\t{\n\t\ttexNum = 19;\n\t\tobjClr = vec4( 0.0, 0.15, 1.0, 1.0 );\n\t\tscale = 2.0;\n\t\tcomplexity = 1.5,\n\t\tmixVal = 0.9;\t  \n\t\tbase_color = getTexture( texNum, pos, scale, complexity, \n\t                                                  objClr, mixVal ).xyz;\t\t\n\t} \n\t\n\treturn base_color;\n}\n\n// end applyTexture()\n\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    //return mix( vec3(0.5, 0.55, 0.96 ), vec3( 1.0 ), cloudDensity );   \n    return mix( vec3(0.6, 0.66, 0.96 ), vec3( 1.0 ), cloudDensity * 4.0 );   \n\n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n\n// DEBUG PLANE\n// ===========\n \nvec4 debug_plane( vec3 rayOrig, vec3 rayDir, float cut_plane, \n                                                        inout float rayLength )\n{\n    if ( rayOrig.y > cut_plane && rayDir.y < 0.0 ) \n    {   \t\n        float d = ( rayOrig.y - cut_plane ) / -rayDir.y;\n        \n        if ( d < rayLength ) \n        {\n            vec3 hit = rayOrig + rayDir * d;\n            \n            float hit_dist = scene( hit ).s,\n                  contourSpacing = 10.0,\n\t\t\t      whole_iso = hit_dist * contourSpacing,           \n                  iso = fract( whole_iso ),                                   \n\t\t\t      markedContour = 5.0,\t\t\t\n\t\t\t\t  modContour = mod( whole_iso, markedContour );\n            \n            vec3 dist_color = mix( vec3( 0.3, 0.5, 0.7 ), \n                                   vec3( 0.3, 0.3, 0.5 ), iso );\n\t\t\t\t\n\t\t\tif ( modContour >= markedContour - 1.0 && \n\t\t\t     modContour <  markedContour )\n\t\t\t{\n\t            dist_color = mix( vec3( 0.1, 0.3, 0.6 ), \n\t                              vec3( 0.1, 0.1, 0.4 ), iso );\n\t\t\t}\n           \t           \t \n            dist_color *= 1.0 / ( max( 0.0, hit_dist ) + 0.001 );\n            rayLength = d;\n                     \n            return vec4( dist_color, 0.1 );\n       }\n    }\n    \n    return vec4( 0.0 );\n}\n\n// end debug_plane()\n\n//------------------------------------------------------------------------------\n\n// SHADE\n// -----\n \nvec3 shade( vec3 rayOrig, vec3 rayDir, vec3 lightDir, vec4 hit, vec2 curPix )                                                                 \n{\n\tvec3 fogColor = skyColor( curPix ) + vec3( 0.33, 0.66, 0.8 );\n\t\n\tfloat rayLength = 0.0;\n\tvec3 color = vec3( 0.0 );\n\t\n\tif ( hit.w == 0.0 ) \n\t{\n\t\trayLength = 1e16;\n\t\tcolor = fogColor;\n\t} \n\telse \n\t{\n\t\tvec3 dir = hit.xyz - rayOrig;\n\t\tvec3 surfNormal = getNormal(hit.xyz);\n\t\trayLength = length(dir);\n\t\t\n\t\t// Texture\n\t\t// -------\n\t\tvec3 base_color = applyTexture( hit );\n\t\tfloat diffuse = max( 0.0, dot( surfNormal, lightDir ) );\n\t\tfloat spec = max( 0.0, dot( reflect( lightDir, surfNormal ), \n\t\t                                                  normalize( dir ) ) );\n\t\tspec = pow( spec, 16.0 ) * 0.5;\n\t\tvec3 ambient = vec3( 0.1 );\n\t\tvec3 white = vec3( 1.0 );\n\t\tcolor = mix( ambient, white, diffuse ) * base_color + spec * white;\n\t\t                             \t\t\n\t\tfloat fog_dist = rayLength;\n\t\tfloat fog = 1.0 - 1.0 / exp( fog_dist * fog_density );\n\t\tcolor = mix( color, fogColor, fog );\n\t\n\t} // end else( hit.w != 0 )\n\t\n\t//------------------------------------------------------------\n\t// Debug Plane\n\t// -----------\n\tfloat planeY = -2.0,\t\t\n\t      mixVal = 0.75;\n\t\n\tvec4 dpcol = debug_plane( rayOrig, rayDir, planeY, rayLength );\n\tcolor = mix( color, dpcol.xyz, mixVal );\n\t\t\t\n\treturn color;\n}\n\n// end shade()\n\n//------------------------------------------------------------------------------\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For Gardner Cos Clouds skyColor()\n\tvec2 st = fragCoord.xy;\n\tst.x *= 0.4;\n\tst.y *= 1.5;\n\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * 0.5 ) / iResolution.y;\n\t\n\tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -cam_dist, 1.0 ) );\t\n\tvec3 rayDir = normalize( vec3( cam_mat * vec4( uv, 1.0, 1.0 ) ) );\n\tvec3 lightDir = normalize( vec3( 0.5, 1.0, -0.25 ) );\t\n\tvec4 hit = raymarch( camPos, rayDir );\n\tvec3 color = shade( camPos, rayDir, lightDir, hit, st );\t\t                                                                      \t\n\tcolor = pow( color, vec3( 0.3 ) );\n\tfragColor = vec4( color, 1.0 );\t\n}\n\n//------------------------------------------------------------------------------\n\n// This section is excerpted from:\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, 0., 1.)\n\n// Maximum/minumum elements of a vector\n float vmax(vec2 v){\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n    \n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n/*\n EXCERPTED FUNCTIONS that contained additional comments removed from the\n code above. Apologies if there are mistakes in my interpretations, or if some\n of the variable names are wrong; these comments were compiled from multiple\n older sources.\n \n//------------------------------------------------------------------------------\n// Function declarations allow function bodies to be placed below the position\n// in the program from which they're called.\n\n// This one's here because I ended up putting the IQ distance functions just\n// above it, because it was convenient while creating the scene.\nvec2 scene(vec3 p);\n\n// Functions from the Mercury SDF Library.\t\nvec2 pMirrorOctant (inout vec2 p, vec2 dist);\nfloat pMirror (inout float p, float dist);\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\nfloat fBox(vec3 p, vec3 b);\nfloat fCylinder(vec3 p, float r, float height);\nfloat fOpUnionColumns(float a, float b, float r, float n);\nfloat fOpUnionStairs(float a, float b, float r, float n);\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n\n// From the Ashima Arts 3D Noise code.\nfloat snoise(vec3 v);\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// I changed the code the day after this was uploaded to add mouse camera control,\n// but Shadertoy insisted that the rotation around the x-axis should be opposite\n// what I describe below ( actually I was too lazy to figure out what else needed\n// to change to keep it the way it was ).\n// So now, when the mouse is at the top of the screen, the camera is looking up\n// from the bottom, and vice-versa. I also changed the y-axis rotation, so now\n// moving the mouse right rotates the scene to the right.\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n\t// Rotation around x-axis = approx. +/- eightTenthsPI = approx 288 degrees\n\t// ----------------------\n\t// Assuming mouse at horizontal screen center is non-rotated position, and\n\t// rotations are viewed looking along the positive y-axis, i.e., looking up\n\t// from below scene:\n\t// Mouse at left of screen = 180 degree counterclockwise rotation from\n\t// non-rotated position.\n\t// Mouse at right of screen = 180 degree clockwise rotation from non-rotated\n\t// position.\n\t\n\t// A distance from screen center is calculated in screen coordinates, and\n\t// scaled to radian rotation angle values. (mouse vals are in screen coords)\n\t\n\t// When mouse.x = 0, rot angle = 2.494\n\t// When mouse.x = 1919, rot angle = -2.4911   =   +/- 0.79PI\n\t\t\n    if( iMouse.z < 0.0 ) \n    {\n\t\t// Steady auto rotation around the y-axis.\n\t\tang = iTime * 0.2;\n    }\n    else\n    {\n    \tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n    }\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n\t// Rotation around y-axis = approx +/- halfPI = approx 180 degrees\n\t// ----------------------\n\t// Mouse at top of screen = looking straight down negative y-axis from\n\t//                          above scene\n\t// Mouse at bottom of screen = looking straight up positive y-axis from\n\t//                          below scene\n\t\n\t// When mouse.y = 0 ( top of screen ), rotY = 1.566\n\t// When mouse.y = 1079 ( btm of screen ), rotY = -1.5631    = +/- 0.49PI\n\n\t// Auto rotation around the x-axis.\n\t// The value \"abs( 2.0 * fract( iTime ) - 1.0 )\" ranges from 1 to 0, then\n\t// *reverses* from 0 to 1. So it's a means to a steady value shuttling\n\t// between 1 -> 0 -> 1. \n\n\t// Multiplying by 1.5 allows the camera to go higher and lower above and\n\t// below the plane. The value range is now 1.5 -> 0 -> 1.5.\n\t// Subtracting -0.25 shifts the range to 1.25 to -0.25. This lets the camera\n\t// go higher above the plane, and not as low below the plane.\n\n    if ( iMouse.z < 0.0 )\n    {\n        ang = 1.5 * ( abs( 2.0 * fract( iTime * 0.01 ) - 1.0 ) - 0.25 );\n    }\n    else\n    {\n    \tang = ( iMouse.y - iResolution.y * 0.5 ) * rotRange; \n    }\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// http://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n\n// Source - Raymarching.com\n// Author - Gary \"Shane\" Warne\n// eMail - mail@Raymarching.com, mail@Labyrinth.com\n// Last update: 28th Aug, 2014\n\nvec3 getNormal( in vec3 p ) \n{\t\t\n\t// wjb: scene() now returns a vec2( dist, objID ), so reference only the\n\t// first component. ( modified from original which returned a float distance\n\t// only.\n\t\n\t// The remainder are Shane's comments.\n*/\n/*\n\t// 6-tap normalization. Probably the most accurate, but a bit of a cycle \n\t// waster.\n\treturn normalize( vec3(\n\tscene( vec3( p.x + eps, p.y, p.z ) ) - \n\t                                    scene( vec3( p.x - eps, p.y, p.z ) ).s,\n\tscene( vec3( p.x, p.y + eps, p.z ) ) - \n\t                                    scene( vec3( p.x, p.y - eps, p.z ) ).s,\n\tscene( vec3( p.x, p.y, p.z + eps ) ) - \n\t                                    scene( vec3( p.x, p.y, p.z - eps ) ).s\n\t));\n*/\n/*\n// Shorthand version of the above. \n\tvec2 e = vec2( eps, 0.0 );\n\treturn normalize( vec3( scene( p + e.xyy ).s - scene( p - e.xyy ).s, \n\t                        scene( p + e.yxy ).s - scene( p - e.yxy ).s, \n\t                        scene( p + e.yyx ).s - scene( p - e.yyx ).s ));\n\n\n\n// If speed is an issue, here's a slightly-less-accurate, 4-tap version.  \n// Visually speaking, it's virtually the same, so often this is the one I'll \n// use. However, if speed is really an issue, you could take away the \n// \"normalization\" step, then  divide by \"eps,\" but I'll usually avoid doing \n// that.\n*/\n/*    \n    float ref = scene( p );\n\treturn normalize( vec3( scene( vec3( p.x + eps, p.y, p.z ) ).s - ref,\n\t\t                    scene( vec3( p.x, p.y + eps, p.z ) ).s - ref,\n\t\t                    scene( vec3( p.x, p.y, p.z + eps ) ).s - ref ) ); \n\n*/\t\n/*\n// The tetrahedral version, which does involve fewer calculations, but doesn't \n// seem as accurate on some surfaces.\n\t\n\tvec2 e = vec2( -0.5 * eps, 0.5 * eps );   \n\treturn normalize( e.yxx * scene( p + e.yxx ).s + \n\t                  e.xxy * scene( p + e.xxy ).s + \n\t                  e.xyx * scene( p + e.xyx ).s +\n\t                  e.yyy * scene( p + e.yyy ).s ); \n*/\n/*\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// RAYMARCH\n// --------\n\nvec4 raymarch( vec3 rayOrig, vec3 rayDir )\n{\n   vec3 p = rayOrig;\n   vec2 nearest = vec2( 0.0 );\n   float rayLength = 0.0;\n   \n   for( int i = 0; i < iterations; ++i ) \n   {\n\t\t// Distance to the nearest object in scene.\n\t\tnearest = scene( p );\n\t\t\n\t\t// The first component of the vec2 contains the distance value.\n\t\tfloat dist = nearest.s;\n\t\t\n\t\t// Distance is within minimum range to be declared a hit.\n\t\tif ( dist < dist_eps ) \tbreak;\t\t\n\n\t\t// wjb : Distance is not within hit distance. If distance is greater \n\t\t// than back view plane, return background color, and ID 0.0.\n\t\tif ( rayLength > ray_max ) return vec4( 0.0 );\n\t\t\n\t\t// Distance indicates that neither an ojbect has been hit nor has \n\t\t// the back view plane been reached. Move current ray position along the\n\t\t// ray direction by distance, and continue marching.\n\t\tp += dist * rayDir;\n\n\t\t//Add distance to the ray length.\n\t\trayLength += dist;\n   }\n   \n   // A hit was declared. Return the current ray position, and the ID of\n   // the hit object\n   return vec4( p, nearest.t );\n}\n\n// end raymarch()\n\n//------------------------------------------------------------------------------\n\n// DEBUG PLANE\n// ===========\n * Draw a single debug plane. The original TestPortMercury code drew four\n * planes at varying heights.\n *\n * debug_plane() is called from the shade() function.\n *\n * 'rayOrig' is passed here unchanged from the call to shade() made from\n * main(). It represents the variable in main() : 'camPos', camera position.\n *\n * 'rayDir' is passed here unchanged from the call to shade() made from main().\n * It represents the variable 'rayDir' in main(), which is the normalized\n * concatenation of the current camera position with the up vector. 'rayDir'\n * represents a normalized step length along the ray from camera to object.\n *\n * 'cut_plane' represents the variable 'planeY' in the shade() function.\n * It's the y-position of the debug_plane(s) tested for here.\n *\n * 'rayLength' is the length of the ray measured from the camera to the hit \n * object position.\n \nvec4 debug_plane( vec3 rayOrig, vec3 rayDir, float cut_plane, \n                                                        inout float rayLength )\n{\n    // Test that the camera is above the cut_plane ( y-coord ) and that\n    // it's looking down the negative y-axis.\n    if ( rayOrig.y > cut_plane && rayDir.y < 0.0 ) \n    {   \t\n        // Since rayOrig.y must be above the cut_plane y position, the\n        // result of subtracting them must be a positive value. Dividing by\n        // the negative value of rayDir yields a ray step length oriented in\n        // the correct direction down the negative y-axis.\n        float d = ( rayOrig.y - cut_plane ) / -rayDir.y;\n               \n        // If d is >= the distance from the camera to a hit obect, there\n        // won't be any debug_plane in this case, return a vec4 debug plane\n        // color of 0.0.\n        if ( d < rayLength ) \n        {\n            // Otherwise, find out where the ray intersects the debug plane by\n            // starting at the camera and moving in the correct direction along\n            // the ray by the 'rayDir' step distance, d times.\n            vec3 hit = rayOrig + rayDir * d;\n            \n            // Send the vec3 representing the point where the ray hits the\n            // debug plane to the distance estimation function, which will \n            // return the distance to the nearest object.\n            float hit_dist = scene( hit ).s,\n            \n            // Spacing between debug plane contours can be adjusted here.\n            // Larger value = narrower contour spacing.\n                  contourSpacing = 10.0,\n\t\t\t      \n            // Calculate the non-fracted value of iso, for use in demarcating\n            // repeating distances in the contour colors.\n\t\t\t      whole_iso = hit_dist * contourSpacing,           \n                  iso = fract( whole_iso ),                                   \n\t\t\t      markedContour = 5.0,\t\t\t\n\t\t\t\t  modContour = mod( whole_iso, markedContour );\n            \n            // The contours are colored with a gradient created by mixing two\n            // colors, from the lighter top color, closer to the object, to the \n            // darker bottom color, farther from the object.\n            vec3 dist_color = mix( vec3( 0.3, 0.5, 0.7 ), \n                                   vec3( 0.3, 0.3, 0.5 ), iso );\n\t\t\t\t\n\t\t\t// Demarcate repeating distances from the objects\n\t\t\t// using a different color mix to represent the contour lines at\n\t\t\t// that repeated distance, i.e., make every fifth contour line a\n\t\t\t// different color.\n\t\t\tif ( modContour >= markedContour - 1.0 && \n\t\t\t     modContour <  markedContour )\n\t\t\t{\n\t\t\t\t// Create a gradient by mixing two colors, from the lighter\n\t            // top color, closer to the object, to the darker bottom \n\t            // color, farther from the object.\n\t            dist_color = mix( vec3( 0.1, 0.3, 0.6 ), \n\t                              vec3( 0.1, 0.1, 0.4 ), iso );\n\t\t\t}\n           \t           \t \n            dist_color *= 1.0 / ( max( 0.0, hit_dist ) + 0.001 );\n            rayLength = d;\n                     \n            return vec4( dist_color, 0.1 );\n       }\n    }\n    \n    return vec4( 0.0 );\n}\n\n// end debug_plane()\n\n//------------------------------------------------------------------------------\n\n// SHADE\n// -----\n * Called from main(), the returned vec3 is assigned to 'color'.\n * 'rayOrig' is 'camPos' in main() = current camera position\n * 'hit' is the vec4 returned from \"raymarch( pos, dir )\" in main()\n \nvec3 shade( vec3 rayOrig, vec3 rayDir, vec3 lightDir, vec4 hit, vec2 curPix )                                                                 \n{\n\tvec3 fogColor = skyColor( curPix ) + vec3( 0.33, 0.66, 0.8 );\n\t\n\tfloat rayLength = 0.0;\n\tvec3 color = vec3( 0.0 );\n\t\n\t// The raymarch() function is called in main() as the 4th argument to \n\t// shade(), and is represented here by the vec4 'hit'. The raymarch() \n\t// function returns a w-component value of 0.0 if the ray reaches the back \n\t// view plane without hitting an object.\n\tif ( hit.w == 0.0 ) \n\t{\n\t\trayLength = 1e16;\n\t\tcolor = fogColor;\n\t} \n\telse \n\t{\n\t\t// 'dir' is assigned the distance between the camera and the point\n\t\t// where an object was hit.\n\t\tvec3 dir = hit.xyz - rayOrig;\n\t\t\n\t\t// Calculate the surface normal at the hit-position of the hit object.\t  \n\t\tvec3 surfNormal = getNormal(hit.xyz);\n\t\t\n\t\trayLength = length(dir);\n\t\t\n\t\t// Texture\n\t\t// -------\n\t\tvec3 base_color = applyTexture( hit );\n\t\t\n\t\t// 'diffuse' is a non-negative value describing the angle between the  \n\t\t// hit object's normal and the direction from which the light is shining.\n\t\tfloat diffuse = max( 0.0, dot( surfNormal, lightDir ) );\n\t\t\n\t\t\n\t\t// Specular light:\n\t\t//----------------\n\t\t// reflect( lightDir, surfNormal ): reflect function returns a vector\n\t\t// that points in the direction of reflection. Two input parameters:\n\t\t// first, the incident vector, and second, the normal vector of the \n\t\t// reflecting surface.\n\t\t\n\t\t// The dot product returns the cosine of the angle between the two \n\t\t// normalized vectors ( reflection vector and ray direction vector ) \n\t\t// = a value between -1 and +1 \n\t\t\n\t\t// If this value is greater than 0, it's raised to a power, and results\n\t\t// in a value darker close to 0, and brighter as it approaches 1.\n\t\t// If the value is less than 0, it's clamped to 0.\n\t\tfloat spec = max( 0.0, dot( reflect( lightDir, surfNormal ), \n\t\t                                                  normalize( dir ) ) );\n\t\tspec = pow( spec, 16.0 ) * 0.5;\n\n\t\tvec3 ambient = vec3( 0.1 );\n\t\tvec3 white = vec3( 1.0 );\n\t\tcolor = mix( ambient, white, diffuse ) * base_color + spec * white;\n\t\t                             \t\t\n\t\tfloat fog_dist = rayLength;\n\t\tfloat fog = 1.0 - 1.0 / exp( fog_dist * fog_density );\n\t\tcolor = mix( color, fogColor, fog );\n\t\n\t} // end else( hit.w != 0 )\n\t\n\t//------------------------------------------------------------\n\t// Debug Plane\n\t// -----------\n\tfloat planeY = -2.0,\t\t\n\t      mixVal = 0.75;\n\t\n\tvec4 dpcol = debug_plane( rayOrig, rayDir, planeY, rayLength );\n\tcolor = mix( color, dpcol.xyz, mixVal );\n\t\t\t\n\treturn color;\n}\n\n// end shade()\n\n//------------------------------------------------------------------------------\n\n\n*/\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n/* PROGRAM FLOW ANALYSIS \n * =====================\n\nmain()\n------\t\n\tStore a non-normalized, scaled screen coord for use in skyColor();\n\t\n\tAdjust aspect ratio, normalize coords, translate origin to screen cntr.\n\t\n\tCreate camera rotation matrices for rotation around the x and y axes.\n\tMultiply them together to create the camera rotation matrix.\n\t\n\tThe rotation range is defined by a float value, which, when multiplied by\n\tmouse position offset from screen center in world coordinates, creates a\n\trange for vert and horiz movement in radians angles.\n\t\n\tThe mouse manipulation of the camera has been replaced in this version with\n\tautomatic rotations around the x and y axes.\n\t\n\tcamPos is initialized as the original, static cam position multiplied by\n\tthe camera rotation matrix.\n\t\n\tlightDir is initialized.\n\t\n\tcolor is calculated.\n\t\n\traymarch() : the ray marching\t\n\t-------\n\t'dist' is assigned a value returned from \n\t\n\t\tscene(), which checks for the nearest object in the world by calling\t\t\n\t\t--------  the Mercury SDF Library functions or IQ functions for each \n\t\t          object, each of which returns a distance from the current ray \n\t\t          position. This is combined with an object ID and returned to\n\t\t          raymarch() as a vec2.\n\t\t\n\tA vec4 'hit' is returned to main(), containing the vec3 hit position, 'p'. \n\t// The w-component contains the ID of the object that was hit.\n\t\n\tshade() :\n\t-------\n\t\tsky_color() is combined with a vec3 ambient light value, and assigned to \n\t\t----------- 'fogColor'.\n\t\t             \t\t            \n\t\tThe w-component flag is checked. If the back plane was reached, the ray\n\t\tlength is set to a tiny value, and color is set to fog.\n\t\t\n\t\tIf an object was hit, the distance from ray origin to hit position is\n\t\tcalculated, and \n\t\t\n\t\tgetNormal() : the average normal vector in the hit position vicinity is\t\t\n\t\t---------   calculated\n\t\t\n\t\tbase_color is assigned a vec3 from\n\t\t\n\t\t\tapplyTexture(). The object ID number determines the values sent to\t\t\t\n\t\t\t--------------\n\t\t\t\n\t\t\t\tgetTexture(), which calculates the pixel color for the current\n\t\t\t\t------------  pixel.\n\t\t\t\t\n\t\tDiffuse light value is calculated as the dot product of the hit normal\n\t\tand the light direction.\n\t\t\n\t\tSpecular light value is calculated.\n\t\n\t\tcolor is calculated as a mix of the base_color, and the diffuse and\n\t\tspecular colors, and a calculated fog color.\n\t\n\t\tdebug_plane() : a dist_color is calculated based on the distance from\t\t\n\t\t-------------   the ray position to the debug plane.\n\t\n\t\tcolor is mixed with the debug plane color.\n\t\nmain()\n------\n\ncolor is modified ( brightened ) by an exponent, and assigned to gl_FragColor.\t\n\t\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}