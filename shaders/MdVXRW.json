{
    "Shader": {
        "info": {
            "date": "1463279891",
            "description": "shader based for 90% of the code on shane shader  : [url=https://www.shadertoy.com/view/MscSDB]Cellular Tiled Tunnel[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "MdVXRW",
            "likes": 14,
            "name": "Cook-Torrance Light Model",
            "published": 3,
            "tags": [
                "model",
                "cook",
                "torrance"
            ],
            "usePreview": 1,
            "username": "aiekick",
            "viewed": 1215
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nantialiased code from shane simpleAA : https://www.shadertoy.com/view/4d3SWf\nshader in bufA based for 90% of the code on shane shader \nCellular Tiled Tunnel https://www.shadertoy.com/view/MscSDB \n*/\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    vec2 si = iResolution.xy;\n   \n    const float AA = 2.;\n    \n    vec2 uv = g/si;\n    \n    vec2 pix = 2./si/AA;\n\n    vec3 col = vec3(0);\n\n    for (float i=0.; i<AA; i++)\n    { \n        vec2 uvOffs = uv + vec2(floor(i/AA), mod(i, AA))*pix;\n        col += clamp(texture(iChannel0,uvOffs).rgb, 0., 1.);\n    }\n    \n    col /= AA;\n\n    f = vec4(col, 1.);   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265358979\n#define FAR 50. // Maximum allowable ray distance.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\nvec3 hash33(vec3 p){return fract(vec3(2097152, 262144, 32768)*sin(dot(p, vec3(7, 157, 113))));}\nmat2 rot2(float a){return mat2(cos(a), sin(a), -sin(a), cos(a));}\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\nfloat drawSphere(in vec3 p){return dot(p = cos(p*3.14159)*0.5, p);}\n\n///////////////////////////////////////////////////////////////////\n// https://en.wikipedia.org/wiki/Cook%E2%80%93Torrance\n///////////////////////////////////////////////////////////////////\nfloat CookTorranceModel(vec3 V, vec3 L, vec3 N)\n{\n\tfloat m = 0.26;\n\tfloat gamma = 1.1;\n\tfloat pi = 3.14159;\n\tvec3 H = normalize(V+L);\n\tfloat NdH = max(dot(N,H),0.0001);\n\tfloat VdN = max(dot(V,N),0.0001);\n\tfloat LdN = max(dot(L,N),0.0001);\n\tfloat VdH = max(dot(V,H),0.0001);\n\tfloat a = acos(NdH);\n\tfloat D = exp(-pow(tan(a),2.)/pow(m,2.))/(pi * pow(m,2.)*pow(cos(a),4.));\n\tfloat F = pow(1. + VdN, gamma);\n\tfloat G = min(1.,min(2. * NdH * VdN / VdH, 2. * NdH * LdN / VdH));\n\treturn D*F*G / (4.*VdN*LdN);\n}\n\nfloat cellTile(in vec3 p){\n    \n    vec4 v, d; \n    d.x = drawSphere(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawSphere(p - vec3(.39, .2, .11));\n\tp.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06));\n\tp.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawSphere(p - vec3(.2, .82, .64));\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n    d.x =  min(v.z, v.w) - min(v.x, v.y);\n    return d.x*2.66;\n}\n\nint cellTileID(in vec3 p)\n{\n    \n    int cellID = 0;\n    \n    // Storage for the closest distance metric, second closest and the current\n    // distance for comparisson testing.\n    vec3 d = (vec3(.75)); // Set the maximum.\n    \n    // Draw some overlapping objects (spheres, in this case) at various positions on the tile.\n    // Then do the fist and second order distance checks. Very simple.\n    d.z = drawSphere(p - vec3(.81, .62, .53)); if(d.z<d.x) cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawSphere(p - vec3(.39, .2, .11)); if(d.z<d.x) cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawSphere(p - vec3(.62, .24, .06)); if(d.z<d.x) cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n   \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawSphere(p - vec3(.2, .82, .64)); if(d.z<d.x) cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n    \n    return cellID;\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/16.); return vec2(s*9., 0); }\n\n// rotation z matrix\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A tunnel is just a tube \n// with a smoothly shifting center as you traverse lengthwise. The walls of the tube are perturbed by the\n// cheap 3D surface function I described above.\nfloat map(vec3 p)\n{\t\n\tfloat sf = cellTile(p/2.2);\n    p.xy -= path(p.z);\n\tp *= RotZ(p.z*.1);\n\tfloat sp = length(p.xy * vec2(1,1));\n\tsp = max(max(p.x, -p.x) + p.y, -p.y); // straight triangle tube\n\treturn 1.- \n\t\tsp * length(p.xy * vec2(1,1)) // a llitle bit rounded tube\n\t+ (0.1-sf)*0.4;\n}\n\nfloat map2(vec3 p)\n{\t\n    p.xy -= path(p.z);\n\tp *= RotZ(p.z*.1);\n\tvec3 tex = texture(iChannel1, (p.z*0.5 + p.xy) * 0.56).rgb;\n\treturn tex.r * 0.3*sin(p.z);\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h,ho,hh;\n    for(int i = 0; i < 60; i++){\n    \n        h = map(ro+rd*t) + map2(ro+rd*t);\n        h *= (h>ho?2.:1.); ho=h; // Enhanced Sphere Tracing => lgdv.cs.fau.de/get/2234 \n        if(abs(h)<0.002*t || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*(h>0.1?0.3:0.1);\n    }\n\n    return min(t, FAR);\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. By the way, there is an \n// aesthetic difference between this and the regular six tap version. Sometimes, it's noticeable,\n// and other times, like this example, it's not.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\te.xyy * (map(p + e.xyy) + map2(p + e.xyy)) + \n\t\te.yyx * (map(p + e.yyx) + map2(p + e.yyx)) + \n\t\te.yxy * (map(p + e.yxy) + map2(p + e.yxy)) + \n\t\te.xxx * (map(p + e.xxx) + map2(p + e.xxx)));\n}\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n\t\t}\n\t\n\t\treturn clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 8.0);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\t\n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x/32. )*rd.xy;\n\n    // Standard ray marching routine.\n    float t = trace(camPos, rd);\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR)\n\t{   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = calcNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./1.; \n        const float tSize1 = 1./1.;\n    \t\n    \t// Texture-based bump mapping.\n\t    //if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); // Floor.\n\t    //else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); // Walls.\n        \n        sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.02);\n        //sn = doBumpMap(sp, sn, 0.01);\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDdist = max(length(ld), 0.001);\n\t    float lDdist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDdist;\n\t    ld2 /= lDdist2;\n\t    \n\t    // Light attenuation, based on the distances above. In case it isn't obvious, this\n        // is a cheap fudge to save a few extra lines. Normally, the individual light\n        // attenuations would be handled separately... No one will notice, or care. :)\n\t    float atten = exp(-0.1*t*lDdist);\n        float atten2 =  exp(-0.05*t*lDdist2);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.75;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = CookTorranceModel(-rd, ld, sn)*0.0848;\n\t    float spec2 = CookTorranceModel(-rd, ld2, sn)*0.0204;\n\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.01)*0.8+0.2, .0, 1.);\n\n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = min(texCol*1.5, 1.);\n\n        //texCol = texCol*vec3(1., .5, .2); \n        int id = cellTileID(sp/2.2);\n        if(id == 4) texCol *= vec3(0,1,0); \n        if(id == 3) texCol *= vec3(0,0,1); \n\t\tif(id == 2) texCol *= vec3(0); \n\t\tif(id == 1) texCol *= vec3(1,0,0); \n\t\t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; \n    \t\n        // Shiny.\n        sceneCol = (texCol*(diff + ambience + spec) + spec*vec3(.7, .9, 1))*atten;\n        sceneCol += (texCol*(diff2 + ambience + spec2) + spec2*vec3(.7, .9, 1))*atten2;\n\n        // Shading.\n        sceneCol *= shading*ao;\n\t}\n    \n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}