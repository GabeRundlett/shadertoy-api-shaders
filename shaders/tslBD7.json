{
    "Shader": {
        "info": {
            "date": "1588430512",
            "description": "Playing with enslow's [url]https://www.shadertoy.com/view/wdlfW4[/url]\n\nDivide points into quadrants and only check lines between points in opposing quadrants. There is a subtle (fixable) bug, to do with the way lines are drawn.",
            "flags": 32,
            "hasliked": 0,
            "id": "tslBD7",
            "likes": 17,
            "name": "Graph Drawing",
            "published": 3,
            "tags": [
                "graph",
                "drawing"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Graph Drawing, Matthew Arcus, mla, 2020\n//\n// Playing with enslow's https://www.shadertoy.com/view/wdlfW4\n//\n// Divide points into quadrants and only check lines between points in opposing\n// quadrants. There is a subtle (fixable) bug, to do with the way lines are\n// drawn - sometimes a line is drawn twice due to overlap between quadrants. \n// Also generate points in bufferA to save a bit of work (and storage on the GPU).\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Store index set as packed integers\n#if 1\nint quad0[N/4], quad1[N/4], quad2[N/4], quad3[N/4];\n#define setq(q,i,x) (q[i>>2] |= (x<<(8*(i&3))), i++)\n#define getq(q,i) ((q[i>>2] >> (8*(i&3)))&255)\n#else\nint quad0[N], quad1[N], quad2[N], quad3[N];\n#define setq(q,i,x) (q[i++] = x)\n#define getq(q,i) (q[i])\n#endif\nint iquad0 = 0, iquad1 = 0, iquad2 = 0, iquad3 = 0;\n\nvec2 getpoint(int i, float t) {\n  //return mkpoint(i,t); // Generate points on the fly\n  return texelFetch(iChannel0,ivec2(i,0),0).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  uv *= 1.333;\n  vec3 col = vec3(1,1,0.5)*(0.7+0.3*texture(iChannel1,uv).y);    \n  float t = 0.25*iTime;\n    \n  for (int i = 0; i < N; i++) {\n    float eps = 0.01; // Need some overlap here\n    vec2 p = getpoint(i,t);\n    // Add point to appropriate quadrant list\n    // NB: it could end up in all of them\n    if (p.x <= uv.x+eps && p.y <= uv.y+eps) setq(quad0,iquad0,i);\n    if (p.x <= uv.x+eps && p.y > uv.y-eps) setq(quad1,iquad1,i);\n    if (p.x > uv.x-eps && p.y > uv.y-eps) setq(quad2,iquad2,i);\n    if (p.x > uv.x-eps && p.y <= uv.y+eps) setq(quad3,iquad3,i);\n  }\n  // Two loops, checking lines between points in opposite quadrants\n  float lwidth = max(0.01,fwidth(uv.x));\n  for (int i = 0; i < iquad0; i++) {\n    int i0 = getq(quad0,i);\n    vec2 p = getpoint(i0,t);\n    for (int j = 0; j < iquad2; j++) {\n      int j0 = getq(quad2,j);\n      vec2 q = getpoint(j0,t);\n      float t = 1.0-smoothstep(0.0,lwidth,segment(uv,p,q));\n      t *= 0.75*texture(iChannel1,uv).x;\n      col *= 1.0-t;\n    }\n  }\n  for (int i = 0; i < iquad1; i++) {\n    int i0 = getq(quad1,i);\n    vec2 p = getpoint(i0,t);\n    for (int j = 0; j < iquad3; j++) {\n      int j0 = getq(quad3,j);\n      vec2 q = getpoint(j0,t);\n      float t = 1.0-smoothstep(0.0,lwidth,segment(uv,p,q));\n      t *= 0.75*texture(iChannel1,uv).x;\n      col *= 1.0-t;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    float t = 1.0-smoothstep(0.02,0.03,distance(getpoint(i,t),uv));\n    t *= 2.0*texture(iChannel1,uv).x;\n    col = mix(vec3(1,0,0),col,1.0-t);\n  }\n  // Output to screen\n  fragColor = vec4(pow(col,vec3(0.4545)),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = 0.25*iTime;\n    int i = int(fragCoord.x), j = int(fragCoord.y);\n    if (j == 0 && i < N) {\n        fragColor = vec4(mkpoint(int(fragCoord.x),t),0,0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define N 32\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(int x) {\n  return float(ihash(uint(x)))/pow(2.0,32.0);\n}\n\nfloat hash2(int x) {\n  return hash(x^0x12345678);\n}\n\nvec2 mkpoint(int i, float t) {\n  return vec2(cos(t+float(i*23)),sin(t+float(i*31)))+vec2(hash(i),hash2(i))-0.5;\n}\n\n//Segment function credit: https://www.shadertoy.com/view/MlcGDB\n//User: gPlatl\n\nfloat segment(vec2 P, vec2 A, vec2 B) {\n  vec2 g = B - A;\n  vec2 h = P - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return d;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}