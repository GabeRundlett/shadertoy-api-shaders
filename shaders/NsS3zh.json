{
    "Shader": {
        "info": {
            "date": "1617242470",
            "description": "fork from https://www.shadertoy.com/view/4sVfWw",
            "flags": 0,
            "hasliked": 0,
            "id": "NsS3zh",
            "likes": 0,
            "name": "random octree (traversal)",
            "published": 3,
            "tags": [
                "octree"
            ],
            "usePreview": 0,
            "username": "ch3coohlink",
            "viewed": 109
        },
        "renderpass": [
            {
                "code": "#define detail 20\n// int(floor((sin(iTime)*0.5+0.5)*6.+6.))\n#define steps 60\n#define maxdistance 1.5\n#define emptycell 0.3\n#define subdivisions 1.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define sqr(a) (a*a)\n#define pi 3.1415926535\n#define outof1(a) a < -1.0 || 1.0 <= a\n#define samples 2\n#define scale .1\n\nfloat rnd(vec4 v) {\n  v = fract(v  * vec4(.1031, .1030, .0973, .1099));\n  v += dot(v, v.wzxy+33.33);\n  return fract((v.x + v.y) * (v.z + v.w));\n  // return fract(4e4 * sin(dot(v, vec4(13.46, 41.74, -73.36, 14.24)) + 17.34));\n}\nint getvoxel(vec3 p, float size) {\n  //if(outof1(p.x) || outof1(p.y) || outof1(p.z)) { return 0; }\n  float val = rnd(vec4(p, size));\n  if(val < emptycell) { return 0; }\n  else { return 1; }\n  //else if(val < subdivisions) { return 1; }\n  //else { return 2; }\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int i, j;\n  vec3 sp;\n  int spc = samples;\n  float t = iTime * 0.1;\n  for(j = 0; j < spc * spc; j++) {\n    float d = 1. / float(spc), radius = 2.;\n    vec2 spv = vec2(float(j % spc) * d - 0.5, float(j / spc) * d - 0.5);\n    vec2 uv = ((fragCoord.xy + spv) * 2.0 - iResolution.xy) / iResolution.y * scale;\n    vec3 ro = vec3(radius * sin(t), t, radius * cos(t)), rd = normalize(vec3(uv, 1.0));\n    rd.xz *= rot(t - pi);\n    \n    ro = ro + rd * (2.0 * sin(t * 2.0) + 2.0);\n    \n    vec3 sc = vec3(0), mask;\n    float size = 1., dist = 0.;\n    vec3 lro = mod(ro, size);\n    vec3 fro = ro - lro;\n    vec3 ird = 1.0 / max(abs(rd), 1e-10);\n    bool exit = false;\n    int level = 0;\n    \n    for(i = 0; i < steps;) {\n      //if(dist > maxdistance) { break; }\n      \n      if(exit) {\n        level--;\n        size *= 2.0;\n        vec3 newfro = floor(fro / size) * (size);\n        lro += fro - newfro;\n        fro = newfro;\n        exit = (level > 0) && (abs(dot(mod(fro / size + 0.5, 2.0) - 1.0 + mask * sign(rd) * 0.5, mask)) < 0.1);\n        continue;\n      }\n      \n      int v = getvoxel(fro, size); if(v == 1 && level >= detail) { v = 2; }\n      \n      if(v == 1) {\n        level++;\n        size *= 0.5;\n        vec3 mask2 = step(vec3(size), lro);\n        fro += mask2 * size;\n        lro -= mask2 * size;\n      } else if(v == 2) {\n        sc = vec3(float(i) * 0.02);\n        break;\n      } else { //move forward\n        float s = size * 0.5;\n        vec3 hit = -(sign(rd) * (lro - s) - s) * ird;\n        mask = hit.x < min(hit.y, hit.z) ? vec3(1, 0, 0) \n          : hit.y < hit.z ? vec3(0, 1, 0) : vec3(0, 0, 1);\n        float len = dot(hit, mask);\n        dist += len;\n        vec3 newfro = fro + mask * sign(rd) * size;\n        lro += rd * len - mask * sign(rd) * size;\n        exit = (level > 0) && (floor(newfro / size * 0.5 + 0.25) != floor(fro / size * 0.5 + 0.25));\n        fro = newfro;\n        \n        i++;\n      }\n    }\n    sc = i >= steps ? vec3(1, 0, 0) : sc;\n    sp += sc;\n  }\n  fragColor = vec4(sp / float(spc * spc), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}