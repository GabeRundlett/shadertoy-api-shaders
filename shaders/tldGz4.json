{
    "Shader": {
        "info": {
            "date": "1575819216",
            "description": "simple radar chart made with iq's polygon function",
            "flags": 0,
            "hasliked": 0,
            "id": "tldGz4",
            "likes": 3,
            "name": "radar chart",
            "published": 3,
            "tags": [
                "sdf",
                "chart"
            ],
            "usePreview": 0,
            "username": "ducklett",
            "viewed": 661
        },
        "renderpass": [
            {
                "code": "const int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float a = 3.1415/3.;\n    \n    //float[] ivs = float[](14.,0.,31.,31.,31.,31.);\n    \n    float center=2.;\n    float lim=31.;\n    \n    vec2[6] poly;\n    vec2[6] bg;\n    float[6] ivs;\n    for (int i=0;i<6;i++){\n        float fi = float(i);\n        ivs[i] = noise(vec2((iTime), fi*a))*lim;\n    \tpoly[i] = vec2(sin(fi*a), cos(fi*a))/(lim+center)*(ivs[i]+center);\n        bg[i] = vec2(sin(fi*a), cos(fi*a))/(lim+center)*(lim+center);\n    }\n\t\n\tfloat d = sdPoly(poly, p );\n    float db = sdPoly(bg, p );\n\n    vec3 gaugec = vec3(.5,.8,.8)*smoothstep(0.,-0.01,d);\n    vec3 bgc = vec3(.4,.4,.5)*smoothstep(0.,-0.01,db);\n    \n\tfragColor = vec4(max(gaugec, bgc),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}