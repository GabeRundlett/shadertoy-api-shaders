{
    "Shader": {
        "info": {
            "date": "1574122081",
            "description": "This generates a semi-random self-avoiding random walk of any size in a reasonable amount of time. Thanks to Shane for the inspiration! (Just cut it anywhere to make it a proper walk instead of a loop.)",
            "flags": 32,
            "hasliked": 0,
            "id": "wsKSWD",
            "likes": 21,
            "name": "Fast Self-Avoiding Random Walk",
            "published": 3,
            "tags": [
                "random",
                "curve",
                "saw",
                "walk",
                "avoid",
                "spacefill"
            ],
            "usePreview": 0,
            "username": "mathmasterzach",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "//RANDOM SELF-AVOIDING WALK (SAW) GENERATION FROM A MAZE\n//Author: @mathmasterzach\n//Feel free to ask any questions about the code or suggest improvements\n//Try changing the GRID_SIZE in the common tab\n\n//Disclaimer the SAW is not uniformly generated but it is good enough and fast\n//Also, this SAW is connected at the end.\n//Feel free to cut anywhere and make it a proper SAW ;-)\n\nbvec4 getFlags(vec2 p){\n    int a=int(texture(iChannel0,p).x);\n\treturn bvec4(a&1,a&2,a&4,a&8);\n}\n\n//View maze that is generated instead. Useful for tinkering and debugging\n/*void mainImage(out vec4 O,in vec2 U){\n    vec2 R=iResolution.xy,\n         p=((.6*GRID_SIZE*(2.*U-R)/R.y)+.5*GRID_SIZE);\n    ivec2 s=ivec2(3.*fract(p));\n    float c=0.;\n    if(p.x>=0.&&p.x<GRID_SIZE&&p.y>=0.&&p.y<GRID_SIZE){\n        bvec4 f=getFlags(p/R);\n        if(s==ivec2(1,1)){c=1.;}\n        if(s==ivec2(0,1)&&f.x){c=1.;}\n        if(s==ivec2(1,0)&&f.y){c=1.;}\n        if(s==ivec2(2,1)&&f.z){c=1.;}\n        if(s==ivec2(1,2)&&f.w){c=1.;}\n    }\n    O=vec4(c);\n}*/\n\n\nvoid mainImage(out vec4 O,in vec2 U){\n    vec2 R=iResolution.xy,\n         p=((.6*GRID_SIZE*(2.*U-R)/R.y)+.5*GRID_SIZE);\n    //id what 4x4 grid square we are in\n    ivec2 s=ivec2(4.*fract(p));\n    float c=0.;\n    if(s!=ivec2(1)&&p.x>=0.&&p.x<GRID_SIZE&&p.y>=0.&&p.y<GRID_SIZE){\n        if(abs(s-ivec2(1))==ivec2(1)){c=1.;}\n        bvec4 f=getFlags(p/R);\n        if(s==ivec2(0,1)&&!f.x){c=1.;}\n        if(s==ivec2(1,0)&&!f.y){c=1.;}\n        if(s==ivec2(2,1)&&!f.z){c=1.;}\n        if(s==ivec2(1,2)&&!f.w){c=1.;}\n        if((s==ivec2(0,3)||s==ivec2(2,3))&&f.w){c=1.;}\n        if((s==ivec2(3,0)||s==ivec2(3,2))&&f.z){c=1.;}\n    }\n    O=vec4(c);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Maze Generation Tab\n//Uses the lowest 4 bits to represent the 4 directions\n\n#define g(x,y) texture(iChannel0,(vec2(x,y)+U)/R).r\n#define r(x,y) int(4.*hash13(vec3(floor(vec2(x,y)+U+.5),iDate.a)))\n\n//Thanks to Dave_Hoskins for the fantastic hash functions!\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n\tp3=fract(p3*.1031);\n    p3+=dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\nvec2 hash21(float p){\n\tvec3 p3=fract(vec3(p)*vec3(.1031,.1030,.0973));\n\tp3+=dot(p3,p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//Proper Maze Generation\n//Based on an older project of mine, but now much faster and with guaranteed correctness\nvoid mainImage(out vec4 O,vec2 U){\n    if(iFrame%200==0||U.x>GRID_SIZE||U.y>GRID_SIZE||iMouse.z>0.){\n        //This is a sneaky bit of code:\n        //.1 is small enough to be discarded by the floored bit checks\n        //But large enough to trigger the float compares\n        //#define CENTER 1\n        #ifdef CENTER\n        O=.1*vec4(U-.5==vec2(floor(GRID_SIZE/2.)));\n        #else\n        //Chooses starting point randomly\n        O=.1*vec4(U-.5==vec2(floor(1.+hash21(iTime)*(GRID_SIZE-2.))));\n        #endif\n    }else{\n        vec2 R=iResolution.xy;\n        float a=g(0,0),\n              b=g(1,0),\n              c=g(0,1),\n              d=g(-1,0),\n              e=g(0,-1);\n        if(a==0.){\n            int r=r(0,0);\n            if(r==0&&b>0.){a=4.;}\n            if(r==1&&c>0.){a=8.;}\n            if(r==2&&d>0.){a=1.;}\n            if(r==3&&e>0.){a=2.;}\n        }else{\n            if(U.x<GRID_SIZE-1.&&b==0.&&r(1,0)==2){a+=4.;}\n            if(U.y<GRID_SIZE-1.&&c==0.&&r(0,1)==3){a+=8.;}\n            if(U.x>1.&&d==0.&&r(-1,0)==0){a+=1.;}\n            if(U.y>1.&&e==0.&&r(0,-1)==1){a+=2.;}\n        }\n        O.x=a;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRID_SIZE 15.",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}