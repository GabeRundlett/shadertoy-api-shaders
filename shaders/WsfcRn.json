{
    "Shader": {
        "info": {
            "date": "1584366021",
            "description": "Euclidean honeycombs and their duals: [url]https://en.wikipedia.org/wiki/Goursat_tetrahedron[/url]\n\nDisplay cycles through 4 mins of different options, or use manual controls (see code).\na,d: show/hide main honeycomb, dual\n<mouse>/<up>/<down>: move around",
            "flags": 48,
            "hasliked": 0,
            "id": "WsfcRn",
            "likes": 9,
            "name": "Euclidean Honeycombs",
            "published": 3,
            "tags": [
                "honeycomb",
                "euclidean",
                "goursat",
                "wythoff"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Euclidean Honeycombs\n//\n// Matthew Arcus, 2020.\n//\n// Using the Wythoff construction: https://en.wikipedia.org/wiki/Wythoff_construction\n// to construct honeycombs in 3D space. The fundamental region is a Goursat\n// Tetrahedron: https://en.wikipedia.org/wiki/Goursat_tetrahedron and the\n// Wythoff construction goes through in a similar way to the planar and spherical\n// case - a vertex is selected in the tetrahedron, then reflected in all ways in the\n// faces of the tetrahedron (this results in an infinite lattice of points). In each\n// image of the region, there is an edge from the vertex image to the vertex in each\n// adjacent region, perpendicular to the shared face.\n//\n// <mouse>: image rotation\n// <up>/<down>: move in/out\n// <left>/<right>: cycle through the 15 honeycombs of the tetrahedron\n// <page up>/<page down>: select centred vertex\n// a: show main honeycomb\n// d: show dual honeycomb\n// c: clip to sphere or cube\n// i: invert about origin\n// m: monochrome\n// o: put viewpoint at origin\n// r: autorotation\n// v: morph between trilinears\n// z: translate on z-axis (nice when inverting)\n//\n// Each region vertex is the centre of a polyhedron, which may however be of\n// zero volume (for example, if the region point coincides with that vertex).\n// The dual honeycomb is constructed by connecting the region vertices that\n// contain non-zero volume polyhedra.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Select basic tetrahedron here.\n#define T0 0 // Basic tetrahedron: (4,2,2,3,2,4)\n#define T1 1 // Two T0 tetrahedra joined\n#define T2 2 // Two T1 tetrahedra joined\n//#define SNUB // Special snub form\n// For a uniform snub, the four reflections of the region point should be\n// mutually  equidistant, but this is generally not possible, so the snub\n// forms are necessarily non-uniform.\n#define TYPE T1\n\nbool showdual = true;\nbool showmain = true;\nbool doinvert = true;\nbool dotranslate = false;\nbool dorotate = false;\nbool doclip = true;\nbool domorph = true;\nfloat clipsphere = 5.5;\nfloat clipcube = 2.1;\nint centre = 0; // The vertex index to centre\n\nconst float maxdepth = 20.0;\nconst float fogstart = 5.0;\n\nconst float sscale = 2.0; // Thickness of edges and vertices\nconst float swidth = sscale*0.05;\nconst float swidth2 = swidth*swidth;\nconst float twidth = sscale*0.02;\nconst float twidth2 = twidth*twidth;\nconst float fwidth = sscale*0.005;\n\nint alert = 0;\nvoid assert(bool test) {\n  if (!test) alert = 1;\n}\n\nconst float PI =  3.141592654;\n\n// PQRS is fundamental tetrahedron\n// Edges are PQ,PR,PS,QR,QS,RS\n#if TYPE==T0\nconst vec3 P = vec3(0,0,0);\nconst vec3 Q = vec3(1,0,0);\nconst vec3 R = vec3(1,1,0);\nconst vec3 S = vec3(1,1,1);\n#elif TYPE==T1\nconst vec3 P = vec3(0,0,0);\nconst vec3 Q = vec3(2,0,0);\nconst vec3 R = vec3(1,1,0);\nconst vec3 S = vec3(1,1,1);\n#elif TYPE==T2\nconst vec3 P = vec3(0,0,0);\nconst vec3 Q = vec3(2,0,0);\nconst vec3 R = vec3(1,1,-1);\nconst vec3 S = vec3(1,1,1);\n#endif\n\n// These are the planes of the tetrahedron.\n// Plane pP is opposite P, etc.\n// w coordinate is distance of plane from origin\n// Normals should face into the tetrahedron.\nconst float K = 1.414213562;\n#if TYPE==T0\nconst vec4 pP = vec4(-1,0,0,1);\nconst vec4 pQ = 0.5*K*vec4(1,-1,0,0);\nconst vec4 pR = 0.5*K*vec4(0,1,-1,0);\nconst vec4 pS = vec4(0,0,1,0);\n#elif TYPE==T1\nconst vec4 pP = 0.5*K*vec4(-1,-1,0,2);\nconst vec4 pQ = 0.5*K*vec4(1,-1,0,0);\nconst vec4 pR = 0.5*K*vec4(0,1,-1,0);\nconst vec4 pS = vec4(0,0,1,0);\n#elif TYPE==T2\nconst vec4 pP = 0.5*K*vec4(-1,-1,0,2);\nconst vec4 pQ = 0.5*K*vec4(1,-1,0,0);\nconst vec4 pR = 0.5*K*vec4(0,1,-1,0);\nconst vec4 pS = 0.5*K*vec4(0,1,1,0);\n#endif\n\nconst float lP = length(cross(Q-R,Q-S));\nconst float lQ = length(cross(R-S,R-P));\nconst float lR = length(cross(S-P,S-Q));\nconst float lS = length(cross(P-Q,P-R));\n\nconst vec4 tri2bary = vec4(lP,lQ,lR,lS); // The lengths of the unnormalized cross products\n\nvec4 T = vec4(1,1,1,1); // Trilinear coordinates of Wythoff point\nvec3 A; // The Wythoff point itself\nvec3 pA,qA,rA,sA; // A reflected in pP, pQ etc.\n\nvec4 trymirror(vec4 p4, vec4 m4, inout int flips) {\n  float t = dot(p4,m4);\n  flips += int(t < 0.0);\n  p4.xyz -= 2.0*min(0.0,t)*m4.xyz;\n  return p4;\n}\n\nvec3 fold(vec3 p, inout int flips) {\n  // Translate along z axis. Interesting when inverted.\n  if (dotranslate) p.z += 0.1*iTime;\n  // Move selected vertex to centre of image.\n  // P is the origin & therefore the default.\n  if (centre == 1) p += Q;\n  else if (centre == 2) p += R;\n  else if (centre == 3) p += S;\n\n  // Attempt to optimize folding for the three  tetrahedron types.\n#if TYPE==T0\n  // Fold in to unit cube\n  p = mod(p+1.0,2.0)-1.0;\n  flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n  p = abs(p);\n  vec4 p4 = vec4(p,1);\n  p4 = trymirror(p4,pQ,flips);\n  p4 = trymirror(p4,pR,flips);\n  p4 = trymirror(p4,pQ,flips);\n#elif TYPE==T1\n  p = mod(p+2.0,4.0)-2.0;\n  flips += int(p.x < 0.0) + int(p.y < 0.0);\n  p.xy = abs(p.xy);\n  vec4 p4 = vec4(p,1);\n  p4 = trymirror(p4,pS,flips);\n  for (int i = 0; i < 2; i++) {\n    p4 = trymirror(p4,pP,flips);\n    p4 = trymirror(p4,pQ,flips);\n    p4 = trymirror(p4,pR,flips);\n  }\n#elif TYPE==T2\n  p = mod(p+2.0,4.0)-2.0;\n  vec4 p4 = vec4(p,1);\n  for (int i = 0; i < 4; i++) {\n    p4 = trymirror(p4,pP,flips);\n    p4 = trymirror(p4,pQ,flips);\n    p4 = trymirror(p4,pR,flips);\n    p4 = trymirror(p4,pS,flips);\n  }\n#endif\n  return p4.xyz;\n}\n\nvec3 colors[] = vec3[](vec3(0.3),\n                       vec3(1,0,0),\n                       vec3(0,1,0),\n                       vec3(0,0,1),\n                       vec3(1,1,0),\n                       vec3(0,1,1),\n                       vec3(1,1,1),\n                       vec3(1,0,1),\n                       vec3(0.8,1,0.8)\n                      );\n         \n// Reflect p in mirror,normal M, distance d from origin.\nvec3 mirror(vec3 p, vec4 M) {\n  float t = dot(vec4(p,1),M);\n  return p - 2.0*t*M.xyz;\n}\n\nvec3 mp(vec3 p) {\n  return mirror(p,pP);\n}\nvec3 mq(vec3 p) {\n  p = mirror(p,pQ);\n  return p;\n}\nvec3 mr(vec3 p) {\n  return mirror(p,pR);\n}\nvec3 ms(vec3 p) {\n  return mirror(p,pS);\n}\n\n#if defined SNUB\nvec3 snubpoints[12];\nint snubcolors[12] = int[](4,4,6,3,2,2,5,1,1,6,3,5);\n#endif\n\nvoid init(vec4 tri) {\n  tri *= tri2bary;\n  A = tri.x*P + tri.y*Q + tri.z*R + tri.w*S;\n  A /= dot(tri,vec4(1));\n  pA = mp(A); qA = mq(A);\n  rA = mr(A); sA = ms(A);\n#if defined SNUB\n  // Reflections of a in P,Q,R,S\n  // Double reflections of Wythoff point A\n  // Currently just for T0 tetrahedron, and no dual\n  snubpoints[0] = mp(mq(A));\n  snubpoints[1] = mq(mp(A));\n  snubpoints[2] = mp(mr(A)); // p,r commute so no rp\n  snubpoints[3] = mp(ms(A)); // p,s commute so no sp\n  snubpoints[4] = mq(mr(A));\n  snubpoints[5] = mr(mq(A));\n  snubpoints[6] = mq(ms(A)); // q,s commute so no sp\n  snubpoints[7] = mr(ms(A));\n  snubpoints[8] = ms(mr(A));\n  snubpoints[9] = mr(mp(A)); // For T1, p,r don't commute!\n  snubpoints[10] = ms(mp(A));\n  snubpoints[11] = ms(mq(A));\n#endif\n}\n\nfloat face(vec3 p, vec3 q, vec3 r, vec3 s) {\n  p -= q;\n#if 0\n  r -= q;\n  s -= q;\n  r = normalize(r);\n  s = normalize(s);\n#endif\n  float rs = dot(r,s), pr = dot(p,r), ps = dot(p,s);\n  mat2 m = mat2(1,rs,rs,1);\n  vec2 t = inverse(m)*vec2(pr,ps);\n  t = max(t,0.0);\n  vec3 p1 = t[0]*r+t[1]*s;\n  return distance(p,p1);\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\n#if defined SNUB\n// A is the region point\n// For scene0, A is the vertex, with segments drawn\n// from A to the 12 double reflections of A in the\n// tetrahedron sides. Some of these segments might\n// coincide.\nfloat snubscene0(vec3 p, out int index) {\n  float d,d0 = 1e8;\n  d = length(p-A)-swidth;\n  if (d < d0) d0 = d, index = 0;\n  for(int i = 0; i < snubpoints.length(); i++) {\n    vec3 r = snubpoints[i];\n    d = segment(p,A,r)-twidth;\n    if (d < d0) d0 = d,  index = snubcolors[i];\n  }\n  return d0;\n }\n\n// For scene1, vertices are drawn for the four\n// reflections of A in the tetrahedron sides\n// and for the six segments connecting those\n// four reflections.\nfloat snubscene1(vec3 p, out int index) {\n  float d,d0 = 1e8;\n  d = segment(p,pA,qA)-twidth;\n  if (d < d0) d0 = d,  index = 4;\n  d = segment(p,pA,rA)-twidth;\n  if (d < d0) d0 = d,  index = 6;\n  d = segment(p,pA,sA)-twidth;\n  if (d < d0) d0 = d,  index = 3;\n  d = segment(p,qA,rA)-twidth;\n  if (d < d0) d0 = d,  index = 2;\n  d = segment(p,qA,sA)-twidth;\n  if (d < d0) d0 = d,  index = 5;\n  d = segment(p,rA,sA)-twidth;\n  if (d < d0) d0 = d,  index = 1;\n\n  // The vertex spheres of the adjacent regions\n  // might overlap with this region.\n  d = length(pA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  d = length(qA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  d = length(rA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  d = length(sA-p)-swidth;\n  if (d < d0) d0 = d,  index = 0;\n  return d0;\n}\n#endif\n\nvoid tryvertex(vec3 pos, vec3 P, int i, inout float d0, inout int index) {\n  float d = length(pos-P)-swidth;\n  if (d < d0) {\n    d0 = d; index = i;\n  }\n}\n\nvoid tryvertex(vec3 pos, vec3 A, vec3 P, vec3 nQ, vec3 nR, vec3 nS, int i, inout float d0, inout int index) {\n#if 1\n  float d = length(pos-P)-swidth;\n  if (d < d0) {\n    d0 = d; index = i;\n  }\n#else\n  float d = d0;\n  float t = 0.25;\n  //t = 0.5+0.5*sin(iTime);\n  //t = 0.8;\n  vec3 A1 = t*A + (1.0-t)*P;\n  d = min(d,face(pos,A1,nQ,nR)-fwidth);\n  d = min(d,face(pos,A1,nR,nS)-fwidth);\n  d = min(d,face(pos,A1,nS,nQ)-fwidth);\n  if (d < d0) { d0 = d; index = i; }\n#endif\n}\n\nfloat dualscene(vec3 pos, out int index) {\n  // For diagram: o-o-o-o\n  bool mp = bool(T[0]), mq = bool(T[1]);\n  bool mr = bool(T[2]), ms = bool(T[3]);\n  // Based on consideration of the Coxeter-Dynkin diagram:\n  // Dual node A appears if any of the b,c,d mirrors\n  // are activated, unless the diagram is 'o o-o', ie.\n  // a prism in which case the isolated node must be\n  // activated as well as one of the others (as is the\n  // case for Q and R in type T0).\n  float d = 1e8;\n#if TYPE==T0\n  // P-Q-R-S\n  if (mq || mr || ms) tryvertex(pos,A,P,-pQ.xyz,-pR.xyz,-pS.xyz,1,d,index);\n  if (mp && (mr || ms)) tryvertex(pos,A,Q,-pR.xyz,-pS.xyz,-pP.xyz,2,d,index);\n  if (ms && (mp || mq)) tryvertex(pos,A,R,-pS.xyz,-pP.xyz,-pQ.xyz,3,d,index);\n  if (mp || mq || mr) tryvertex(pos,A,S,-pP.xyz,-pQ.xyz,-pR.xyz,4,d,index);\n#elif TYPE==T1\n  // P\n  //  \\\n  //   R-S\n  //  /\n  // Q\n  if (mq || mr || ms) tryvertex(pos,A,P,-pQ.xyz,-pR.xyz,-pS.xyz,1,d,index);\n  if (mp || mr || ms) tryvertex(pos,A,Q,-pR.xyz,-pS.xyz,-pP.xyz,2,d,index);\n  if (ms && mp && mq) tryvertex(pos,A,R,-pS.xyz,-pP.xyz,-pQ.xyz,3,d,index);\n  if (mp || mq || mr) tryvertex(pos,A,S,-pP.xyz,-pQ.xyz,-pR.xyz,4,d,index);\n#elif TYPE==T2\n  // P-R\n  // | |\n  // S-Q\n  if (mq || mr || ms) tryvertex(pos,A,P,-pQ.xyz,-pR.xyz,-pS.xyz,1,d,index);\n  if (mp || mr || ms) tryvertex(pos,A,Q,-pR.xyz,-pS.xyz,-pP.xyz,2,d,index);\n  if (ms || mp || mq) tryvertex(pos,A,R,-pS.xyz,-pP.xyz,-pQ.xyz,3,d,index);\n  if (mp || mq || mr) tryvertex(pos,A,S,-pP.xyz,-pQ.xyz,-pR.xyz,4,d,index);\n#endif\n  float d0 = d;\n  // Again, look at reduced diagram with just 2 nodes -\n  // if connected, either mirror will do, if isolated,\n  // need both.\n#if TYPE==T0\n  if (mr || ms) d = min(d,segment(pos,P,Q)-twidth);\n  if (mq && ms) d = min(d,segment(pos,P,R)-twidth);\n  if (mq || mr) d = min(d,segment(pos,P,S)-twidth);\n  if (mp && ms) d = min(d,segment(pos,Q,R)-twidth);\n  if (mp && mr) d = min(d,segment(pos,Q,S)-twidth);\n  if (mp || mq) d = min(d,segment(pos,R,S)-twidth);\n#elif TYPE==T1\n  if (mr || ms) d = min(d,segment(pos,P,Q)-twidth);\n  if (mq && ms) d = min(d,segment(pos,P,R)-twidth);\n  if (mq || mr) d = min(d,segment(pos,P,S)-twidth);\n  if (mp && ms) d = min(d,segment(pos,Q,R)-twidth);\n  if (mp || mr) d = min(d,segment(pos,Q,S)-twidth);\n  if (mp && mq) d = min(d,segment(pos,R,S)-twidth);\n#elif TYPE==T2\n  if (mr && ms) d = min(d,segment(pos,P,Q)-twidth);\n  if (mq || ms) d = min(d,segment(pos,P,R)-twidth);\n  if (mq || mr) d = min(d,segment(pos,P,S)-twidth);\n  if (mp || ms) d = min(d,segment(pos,Q,R)-twidth);\n  if (mp || mr) d = min(d,segment(pos,Q,S)-twidth);\n  if (mp && mq) d = min(d,segment(pos,R,S)-twidth);\n#endif\n  if (d != d0) index = 8;\n  return d;\n}\n\nfloat mainscene(vec3 p, out int index) {\n  float d,d0 = 1e8;\n  d = length(p-A)-swidth;\n  if (d < d0) { d0 = d; index = 0; }\n  d = segment(p,A,pA)-twidth;\n  if (d < d0) { d0 = d; index = 1; }\n  d = segment(p,A,qA)-twidth;\n  if (d < d0) { d0 = d; index = 2; }\n  d = segment(p,A,rA)-twidth;\n  if (d < d0) { d0 = d; index = 3; }\n  d = segment(p,A,sA)-twidth;\n  if (d < d0) { d0 = d; index = 4; }\n  d = 1e8;\n  if (key(CHAR_0+1)) d = min(d,face(p,A,-pP.xyz,-pQ.xyz)-fwidth);\n  if (key(CHAR_0+2)) d = min(d,face(p,A,-pQ.xyz,-pR.xyz)-fwidth);\n  if (key(CHAR_0+3)) d = min(d,face(p,A,-pR.xyz,-pP.xyz)-fwidth);\n  if (key(CHAR_0+4)) d = min(d,face(p,A,-pP.xyz,-pS.xyz)-fwidth);\n  if (key(CHAR_0+5)) d = min(d,face(p,A,-pQ.xyz,-pS.xyz)-fwidth);\n  if (key(CHAR_0+6)) d = min(d,face(p,A,-pR.xyz,-pS.xyz)-fwidth);\n  if (d < d0) { d0 = d; index = 5; }\n  return d0;\n}\n\nfloat getdist(vec3 p, out int index) {\n  float iscale = 1.0;\n  int flips = 0;\n  if (doinvert) {\n    flips++;\n    // Invert in sphere, radius 2.\n    float r2 = 0.5*dot(p,p);\n    p /= r2;\n    iscale = r2;\n  }\n  p = fold(p,flips);\n#if defined SNUB\n  float d = flips%2 == 0 ? snubscene0(p,index) : snubscene1(p,index);\n#else\n  float d1,d = 1e8;\n  int index1;\n  if (showmain) {\n    d1 = mainscene(p,index1);\n    if (d1 < d) { d = d1; index = index1; }\n  }\n  if (showdual) {\n    d1 = dualscene(p,index1);\n    if (d1 < d) { d = d1; index = index1; }\n  }\n#endif\n  return iscale*d;\n}\n\nfloat eval(vec3 p) {\n  vec3 p0 = p;\n  int index;\n  float d = getdist(p,index);\n  if (doclip) {\n    if (doinvert) {\n      d = max(d,length(p0)-clipsphere); // Intersect with sphere\n    } else {\n      // Intersect with cube sides\n      d = max(d,abs(p0.x)-clipcube);\n      d = max(d,abs(p0.y)-clipcube);\n      d = max(d,abs(p0.z)-clipcube);\n    }\n  }\n  return d;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float precis = 0.001; // Should be resolution dependent\n  float t = 0.25; // Start a little way from the eye - less occlusion.\n  for (int i = 0; i < 200 && t < maxdepth; i++) {\n    // Do we need a rate limiter?\n    float h = eval(ro + rd * t);\n    // Rate limit and apply fudge for inversion.\n    if (doinvert) h = min(1.0,0.6*h);\n    t += h;\n    if (h < t*precis) return t;\n  }\n  return -1.0;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 getcolor(vec3 pos) {\n  int index;\n  getdist(pos,index);\n  assert(index >= 0 && index < colors.length());\n  return 0.2+0.6*colors[index];\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nvec4 gettrilinear(int n) {\n  n = mymod(n,15);\n  return 1.0-vec4(float((n>>0)&1),float((n>>1)&1),float((n>>2)&1),float((n>>3)&1));\n}\n\nvec4 gettrilinear() {\n  float t = 0.5*iTime;\n  int i = int(t);\n  doinvert = doinvert != (i/30%2 == 1);\n  doclip = doclip != (i/60%2 == 1);\n  float k = 0.0;\n  if (domorph) k = fract(t);\n  return mix(gettrilinear(i/2),gettrilinear((i+1)/2),k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  showdual = !key(CHAR_D);\n  showmain = !key(CHAR_A);\n  doclip = key(CHAR_C);\n  doinvert = key(CHAR_I);\n  dorotate = !key(CHAR_R);\n  dotranslate = key(CHAR_Z);\n  domorph = !key(CHAR_V);\n\n#if defined TEST\n  //doinvert = true;\n  showdual = false;\n#endif\n  \n#if defined SNUB\n  T = vec4(1);\n#else\n  int n = mymod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),16);\n  if (n == 0) T = gettrilinear();\n  else T = gettrilinear(n-1);\n#endif\n  centre = mymod(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),4);\n  init(T);\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy)/ iResolution.y;\n  vec3 ro = vec3(0, 0, 6.0);\n  //vec3 ro = vec3(0, 0, -0.2*iTime);\n  vec3 rd = normalize(vec3(p, -2.0));\n  if (key(CHAR_O)) ro = vec3(0);\n  ro = transform(ro);\n  ro *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  rd = transform(rd);\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  light = transform(light);\n\n  float t = march(ro,rd);\n  vec3 col = (doclip || doinvert) ? 0.05*(1.0-p.y)*vec3(1,0,1) : vec3(1,1,0.5);\n  if (t > 0.001) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    vec3 basecol = getcolor(pos);\n    float diffuse = clamp(dot(n, light), 0.0, 1.0);\n    float specular = pow(max(0.0,dot(reflect(light,n),vec3(rd))),4.0);\n    vec3 c = basecol;\n    c *= 0.3+0.5*diffuse;\n    vec3 speccol = basecol;\n    c += 0.3*specular*speccol;\n    col = mix(c,col,clamp((t-fogstart)/(maxdepth-fogstart),0.0,1.0));\n  }\n  if (key (CHAR_M)) col = vec3(0.333*dot(col,vec3(1)));\n  col = pow(col, vec3(0.4545));\n  if (alert != 0) col = vec3(1,0,0);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79; // Put viewpoint at origin\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}