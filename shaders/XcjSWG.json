{
    "Shader": {
        "info": {
            "date": "1706761633",
            "description": "it's a pattern, you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "XcjSWG",
            "likes": 2,
            "name": "eindacor_dynamic_houndstooth",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "#define AA .002f\n#define PI 3.141592653f\n#define TWOPI 6.28318530718f\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rotatePointAroundOtherPoint(vec2 center, vec2 p, float angleInRadians) {\n    mat2x2 rotationMatrix = mat2x2(\n    \tcos(angleInRadians), -sin(angleInRadians),\n        sin(angleInRadians), cos(angleInRadians)\n    );\n    \n    return (rotationMatrix * (p - center)) + center;\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getStepHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = holdTime + transitionTime;\n    float relativeTime = fract(time / period);\n    return mix(lower, upper, smoothstep(holdTime / 2., period - holdTime / 2., mod(time, period)));\n}\n\nfloat getStripe(float val, float size) {\n    return mod(val, size * 2.) < size ? 1. : 0.;\n}\n\nfloat stripe(float lower, float upper, float p) {\n    return (smoothstep(lower - AA, lower + AA, p) * smoothstep(upper + AA, upper - AA, p));\n}\n\nfloat getDivisor(float time, float interval, float steps, float holdRatio) {\n    int stepIndex = int(floor(time / interval));\n    int nextStepIndex = stepIndex + 1;\n    \n    float firstVal = hash(vec2(float(stepIndex)));\n    float secondVal = hash(vec2(float(nextStepIndex)));\n    \n    return mix(pow(2., floor(firstVal * 4.)), pow(2., floor(secondVal * 4.)), \n        getStepHoldTransitionValue(0., 1., interval * holdRatio, interval * (1. - holdRatio), time));\n    \n    float thisDivisor = float(stepIndex);\n    float nextDivisor = float(stepIndex + 1);\n}\n\nfloat getValInColorSpace(float val) {\n    float minVal = .1;\n    float maxVal = 1.;\n    float increment = (maxVal - minVal) / 4.;\n    \n    return minVal + increment * floor(val * 4.);\n}\n\nfloat getColorVal(float time, float interval, float steps, float noise, float holdRatio) {\n    int stepIndex = int(noise * 58. + floor(time / interval));\n    int nextStepIndex = stepIndex + 1;\n\n    float firstVal = hash(vec2(float(stepIndex)));\n    float secondVal = hash(vec2(float(nextStepIndex)));\n    \n    return mix(getValInColorSpace(firstVal), getValInColorSpace(secondVal), \n        getStepHoldTransitionValue(0., 1., interval * holdRatio, interval * (1. - holdRatio), time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float bendFactor = sin(iTime * .1) * .2;\n    \n    //uv.y += sin(uv.x) * bendFactor;\n    //uv.x += cos(uv.y) * bendFactor;\n    \n    float gridSize = .1;\n    \n    int gridRow = int(floor(uv.y/gridSize));\n    int gridCol = int(floor(uv.x/gridSize));\n    \n    float interval = 10.;\n    float steps = 10.;\n    \n    float currentStep = floor(iTime / interval);\n    float nextStep = currentStep + 1.;\n  \n    float holdRatio = .5;\n    \n    bool houndsTooth = false;\n    \n    vec4 color0, color1, color2, color3;\n    \n    if (houndsTooth) {\n        color0 = vec4(.2);\n        color1 = vec4(.8);\n        color2 = vec4(.2);\n        color3 = vec4(.8);\n    }\n    else {\n        color0 = vec4(getColorVal(iTime, interval, steps, hash(vec2(0.4)), holdRatio));\n        color1 = vec4(getColorVal(iTime, interval, steps, hash(vec2(- 0.4)), holdRatio));\n        color2 = vec4(getColorVal(iTime, interval, steps, hash(vec2(-0.1)), holdRatio));\n        color3 = vec4(getColorVal(iTime, interval, steps, hash(vec2(0.7)), holdRatio));\n    }\n    \n    float firstVal = getStripe(uv.x, gridSize);\n    float secondVal = getStripe(uv.y, gridSize);\n    \n    float divisor = houndsTooth ? 4. : getDivisor(iTime, interval, steps, holdRatio);\n    \n    float gridDiagonal = sqrt(2. * gridSize * gridSize);\n    float thirdVal = getStripe(rotatePointAroundOtherPoint(vec2(0.), uv, TWOPI / 8.).x, gridDiagonal / divisor);\n    \n    vec4 map1 = mix(color0, color1, firstVal);\n    vec4 map2 = mix(color2, color3, secondVal);\n    \n    fragColor = mix(map1, map2, thirdVal);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}