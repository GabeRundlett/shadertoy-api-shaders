{
    "Shader": {
        "info": {
            "date": "1457277951",
            "description": "Game: Click on your keyboard's arrow in the right moment and make the most points!! ;)\nReset: Click on \"Reset Time\" button\n\nMusic taken from the Toccata and Fugue.\nGameplay inspired by Boom Boom Rocket.\n\nNote: Optimzed version to load faster.",
            "flags": 56,
            "hasliked": 0,
            "id": "4d3XRr",
            "likes": 20,
            "name": "Toccata And Boom Game 2",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "distancefield",
                "game",
                "sound",
                "music",
                "city",
                "fireworks",
                "videogame",
                "buffer",
                "firework",
                "boomboomrocket"
            ],
            "usePreview": 1,
            "username": "ciberxtrem",
            "viewed": 2528
        },
        "renderpass": [
            {
                "code": "// Draws UI and compose final image\n\nfloat gT;\nfloat ar;\nvec2 uv;\n\nvec2 txPlayer = vec2(0., 0.);\nconst vec3 pinkColor = vec3(0.650, 0.117, 0.745);\nconst vec3 blueColor = vec3(0.117, 0.352, 0.745);\n\nconst float kFinishTime = 173.;\n\nfloat uRoundBox(vec2 p, vec2 c, float r)\n{\n    return length(max(abs(p) - c, 0.)) - r;\n}\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // reference P_Malin - https://www.shadertoy.com/view/4sf3RN\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\nvec4 LoadMem0(vec2 uv)\n{\n    return texture(iChannel0, (uv+0.5)/iChannelResolution[0].xy, -100.);\n}\n\nfloat dArrow(vec2 p)\n{\n    p.y-=0.1;\n    float d = p.y - p.x*1.5 -0.1;\n    d = max(d, p.y + p.x*1.5 -0.1);\n    d = max(d, -p.y - 0.1);\n    \n    float d2 = max(abs(p.x)-0.05, abs(p.y+0.15)-0.1);\n    d = min(d, d2);\n    \n    return d;\n}\n\nvoid DrawTopLine(vec2 p, inout vec3 color)\n{\n    vec2 q = p-vec2(0., 0.3);\n    float d = length(q*vec2(0.03, 1.))-0.001;\n        \n    vec3 barColor = mix(vec3(0.682, 0.184, 0.854), color, smoothstep(0., 0.05, d));\n    barColor = mix(vec3(1.), barColor, smoothstep(-0.01, 0.03, d));\n    \n    float deadT = max(0., gT - kFinishTime);\n    color = mix(barColor, color, min(deadT*0.25, 1.));\n}\n\nvoid DrawScore(vec2 p, float score, inout vec3 color)\n{\n    vec3 pinkColor = vec3(0.650, 0.117, 0.745);\n    vec3 blueColor = vec3(0.117, 0.352, 0.745);\n    \n    float deadt = max(0., gT - kFinishTime);\n    \n    vec2 startPos = vec2(0.);\n    vec2 endPos = vec2(-1.2, -1. + sin(gT)*0.05);\n    vec2 pos = mix(startPos, endPos, pow(min(deadt*0.45, 1.), 10.) );\n    \n    float scale = mix(1., 0.8, pow(min(deadt*0.45, 1.), 10.) );\n    p = (p-pos)*scale;\n    \n    vec2 q = p - vec2(1., 0.85);\n    q.x += q.y*0.35;\n    float d = uRoundBox(q, vec2(0.5, 0.068), 0.01);\n    vec3 bgColor = color*0.8 + blueColor*0.2;\n    bgColor = mix(bgColor, blueColor, smoothstep(-0.1, 0.2, q.y));\n    color = mix(bgColor, color, smoothstep(-0.0, 0.001, d));\n    color = mix(blueColor, color, smoothstep(0.0, 0.01, abs(d)-0.001));\n    \n    q = p - vec2(0.6, 0.80);\n\td = PrintInt(q*10., score);\n    vec3 lettersColor = vec3(1.);\n    lettersColor = mix(lettersColor, pinkColor, 1.-smoothstep(-0.1, 0.13, q.y));\n    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));\n}\n\nfloat dX(vec2 p)\n{\n    float d = max(abs(p.y-p.x*1.0)-0.1, length(p.xy)-0.5);\n    d = min(d, max(abs(-p.y-p.x*1.0)-0.1, length(p.xy)-0.5));\n    return d;\n}\n\nvoid DrawMultiplier(vec2 p, float score, float multiplier, inout vec3 icolor)\n{\n    multiplier += 1.;\n    \n    vec3 color = icolor;\n    \n    vec2 q = p - vec2(-1., 0.85);\n    q.x -= q.y*0.35;\n    float d = uRoundBox(q, vec2(0.5, 0.068), 0.01);\n    vec3 bgColor = color*0.8 + blueColor*0.2;\n    bgColor = mix(bgColor, blueColor, smoothstep(-0.1, 0.2, q.y));\n    color = mix(bgColor, color, smoothstep(-0.0, 0.001, d));\n    color = mix(blueColor, color, smoothstep(0.0, 0.01, abs(d)-0.001));\n    \n    // Paint the inner colors\n    q = p - vec2(-1.01, 0.85); q.x -= q.y*0.35;\n    d = uRoundBox(q, vec2(0.42, 0.02), 0.01);\n    float barD = smoothstep(-0.42, 0.42, q.x);\n    bgColor = mix(vec3(0.352, 0.886, 0.854), pinkColor, pow(barD, 0.6));\n    bgColor = mix(bgColor, color, step(score, barD));\n    color = mix(bgColor, color, smoothstep(-0.0, 0.001, d));\n    \n    // Paint the inner windows\n    q = p - vec2(-1.28, 0.85); q.x -= q.y*0.35;\n    d = uRoundBox(q, vec2(0.18, 0.04), 0.01);\n    color = mix(vec3(0.), color, smoothstep(-0.0, 0.001, abs(d)-0.004));\n    \n    q = p - vec2(-1.09, 0.85); \n    q.x -= q.y*0.35;\n    vec2 q2 = q; q2.x = mod(q2.x, 0.18) - 0.09;\n    d = uRoundBox(q2, vec2(0.08, 0.040), 0.01);\n    d = max(max(d, -q.x), q.x-0.54);\n    color = mix(vec3(0.), color, smoothstep(-0.0, 0.001, abs(d)-0.004));\n    \n    // Draw Multiplier number\n    q = p - vec2(-0.5, 0.78); \n    float scale = 1.0;\n    scale += 0.25 * (0.7+0.3*(sin(gT*8.) * step(7.0, multiplier)));\n    d = -PrintInt(q*6.*scale, multiplier);\n        vec3 lettersColor = vec3(1.);\n    lettersColor = mix(lettersColor, pinkColor, 1.-smoothstep(-0.1, 0.15, q.y));\n    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));\n    color = mix(lettersColor, color, step(0., d));\n    \n    d = dX((q-vec2(0.085, 0.04))*12.*scale);\n    color = mix(lettersColor, color, step(0., d));\n    \n    float deadT = max(0., gT - kFinishTime);\n    icolor = mix(color, icolor, min(deadT*0.25, 1.));\n}\n\nvoid DrawFinalWindow(in vec2 p, inout vec3 color)\n{\n    float deadt = max(0., gT - kFinishTime);\n    vec3 frameColor = mix(color, blueColor, 0.6+0.4*sin(gT*2.));\n    float d = uRoundBox(p, vec2(1.43, 0.63), 0.2);\n    frameColor = mix(color, frameColor, smoothstep(0., 0.4, d ));\n    color = mix(color, frameColor, min(deadt*0.25, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Draw Scene composition\n    vec4 texColorBg = texture(iChannel1, uv);\n    vec4 texColorFire = texture(iChannel2, uv);\n    vec3 color = clamp(texColorBg + texColorFire, 0., 1.).rgb;\n    \n    gT = iTime;\n    ar = iResolution.x/iResolution.y;\n\tuv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv *2. -1.;\n    p.x *= ar;\n    \n    // Load Player Data\n    vec4 player = LoadMem0(txPlayer.xy);\n    \n    DrawFinalWindow(p, color);\n    \n    DrawTopLine(p, color);\n    DrawScore(p, player.y*125., color);\n    DrawMultiplier(p, player.w, player.z, color);\n    \n\tfragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Gameplay Logic\n//Reference for Gameplay Save/Load: iq - https://www.shadertoy.com/view/MddGzf\n\nfloat gTime;\nfloat dt = 0.006;\nvec2 realFragCoord;\n\nconst float PI = 3.14159;\nconst float kMoveSpeed = 0.8;\nconst float kLifePerHit = 0.1;\n\nconst float BUBBLE_FADE_OUT_TIME = 2.5;\nconst int NUM_BUBBLES = 20;\nconst int BUBBLES_TO_WIN = 100;\nconst float KEY_RIGHT = 39.5/255.;\nconst float KEY_LEFT = 37.5/255.;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE = 32.5/255.;\n\nvec2 txPlayer = vec2(0., 0.);\t\t\t\t\t  \t// x:State, y:Points\nvec2 txSpawn = vec2(1., 0.);\t\t\t\t\t  \t// x:LastSpawnTime\nvec4 txBubble = vec4(0., 1., NUM_BUBBLES, 0.);    \t// xy:Pos, zy:vel\nvec4 txBubbleState = vec4(0., 2., NUM_BUBBLES, 0.); // x:Life, Rotation\n\nfloat gAR;\nfloat gMusicTimei;\n\n\n#define GF(h)\n#define tint 0.130\n\n//#define N(a, b, c) if( abs(gMusicTimei-sumx) < 1.0e-2) { note = 1.0 + step(4., c); }  sumx+=float(a)*2.;\n//#define N(a, b, c) note += (1.0 + step(4., c)) * step(abs(gMusicTimei-sumx), 1.0e-3); sumx += float(a)*2.;\n#define N(a, b, c) note += (1.0 + step(4., c)) * step(abs(gMusicTimei-sumx), 1.0e-3); sumx += float(a)*2.;\n\nfloat GetTocattaAndFugue(float t)\n{\n    float x = 0.0;\n    float sumx = 0.0;\n    float note = 0.0;\n    float presstime = 0.0;\n    \n    // Start\n    sumx = 0.0; x = t; presstime = 0.0;\n    //\n    N(1.0,GF(15.),1.) N(1.0,GF(13.),1.) N(9.+4.0,GF(15.),9.0)\n    N(2.,GF(13.),2.) N(1.5,GF(11.),1.5) N(0.5,GF(10.),0.5) N(1.5,GF(8.),0.) N(3.0+2.,GF(7.),3.0)\n\tN(7.0 + 15.,GF(8.),7.)\n\n\t//\n\tN(1.0,GF(7.),1.) N(1.0,GF(5.),1.) N(8.+4.0,GF(7.),8.0)\n\tN(3.0+0.5,GF(4.),3.0) N(2.+0.5,GF(5.), 2.0) N(3.0+1.,GF(1.),3.0)\n\tN(9.0 + 15.,GF(2.),9.)\n\n\t//\n\tN(1.0,GF(-1.),1.) N(1.0,GF(-3.),1.) N(8.+4.0,GF(-1.),8.0)\n\tN(2.,GF(-3.),2.) N(1.5,GF(-5.),1.5) N(0.5,GF(-6.),0.5) N(1.5,GF(-8.),0.) N(3.0+3.,GF(-9.),3.0)\n\tN(8.0 + 10.,GF(-8),8.)\n    \n    // First Chord\n    float startEndX = sumx;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(58.0,GF(-8.),58.)\n    \n    sumx = startEndX + 8.; x = t; presstime = 0.0;\n    N(25.0,GF(4.),25.) N(25.0,GF(5.),25.)\n    \n    sumx = startEndX + 12.; x = t; presstime = 0.0;\n    N(21.0 + 5.0,GF(7.),21.) N(6.0,GF(7.),6.)N(14.0,GF(9.),14.)\n    \n    sumx = startEndX + 15.; x = t; presstime = 0.0;\n    N(18.0+5.,GF(10.),18.+5.)\n    \n    sumx = startEndX + 18.; x = t; presstime = 0.0;\n    N(15.0,GF(13.),15.)N(25.0,GF(12.),25.)\n    \n    sumx = startEndX + 21.; x = t; presstime = 0.0;\n    N(12.0,GF(16.),12.)\n    \n    sumx = startEndX + 25.; x = t; presstime = 0.0;\n    N(8.0,GF(19.),8.)N(25.0,GF(17.),25.)\n    \n    // \n    startEndX = sumx;\n    sumx = startEndX + 7.; x = t; presstime = 0.0;\n    float baseNote = 16.;\n    N(2.0+1.5,GF(baseNote),2.0) N(2.5,GF(baseNote+1.),2.5) N(1.0,GF(baseNote+3.),1.0) \n    N(1.0+0.5,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.5,GF(baseNote+3.),1.5)\n    N(0.5+0.0,GF(baseNote),0.5) N(1.0,GF(baseNote+1.),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+1.,GF(baseNote+1.),1.5)\n        \n    baseNote = 19.;\n    N(1.5+0.5,GF(baseNote),1.5) N(1.5,GF(baseNote+1.),1.5) N(0.5,GF(baseNote+3.),0.5) \n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+1.),1.0) N(0.5,GF(baseNote+3.),0.5)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+0.5,GF(baseNote+1.),1.5)\n        \n    baseNote = 22.;\n    N(1.+1.0,GF(baseNote),1.0) N(1.5,GF(baseNote+2.),1.5) N(0.5+0.5,GF(baseNote+3.),0.5) \n    N(1.0+0.0,GF(baseNote+2.),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5,GF(baseNote+2.),1.5) N(1.5,GF(baseNote+3.),1.5)\n    N(1.0+0.5,GF(baseNote),1.0) N(7.0,GF(baseNote+2.),7.0)\n    \n    startEndX = sumx;\n    sumx = startEndX + 5.; x = t; presstime = 0.0;\n    baseNote = 20.;\n    N(2.0+1.5,GF(baseNote),2.0) N(2.5,GF(baseNote+1.),2.5) N(1.0,GF(baseNote+3.),1.0) \n    N(1.0+0.5,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.5,GF(baseNote+3.),1.5)\n    N(0.5+0.0,GF(baseNote),0.5) N(1.0,GF(baseNote+1.),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+1.,GF(baseNote+1.),1.5)\n        \n    baseNote = 23.;\n    N(1.5+0.5,GF(baseNote),1.5) N(1.5,GF(baseNote+1.),1.5) N(0.5,GF(baseNote+3.),0.5) \n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+1.),1.0) N(0.5,GF(baseNote+3.),0.5)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+0.5,GF(baseNote+1.0),1.5)\n        \n    baseNote = 26.;\n    N(1.0+0.5,GF(baseNote),1.0) N(1.5,GF(baseNote+2.0),1.5) N(1.0,GF(baseNote+3.),1.0) \n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+2.0),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+2.0),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.5,GF(baseNote),1.0) N(7.0 + 8.0,GF(baseNote+2.0),7.0)\n    \n    baseNote = 28.;\n    N(1.5+2.5,GF(baseNote+0.0),1.0)N(2.0,GF(baseNote-2.),2.0)N(1.0,GF(baseNote+1.),1.0)\n    N(1.0+0.0,GF(baseNote-5.0),1.0)N(1.0,GF(baseNote-2.),1.0)N(1.0,GF(baseNote+1.),1.0)\n        \n    baseNote = 23.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.5,GF(baseNote+1.),1.5)N(1.0,GF(baseNote+6.),1.0)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.5,GF(baseNote+1.),1.5)N(1.0,GF(baseNote+6.),1.0)\n        \n    baseNote = 21.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 19.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 17.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(1.0,GF(baseNote+6.),1.0)\n    N(1.0+0.0,GF(baseNote-1.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(0.5,GF(baseNote+6.),0.5)\n        \n    baseNote = 16.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(0.5,GF(baseNote+5.),0.5)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 14.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(1.0,GF(baseNote+5.),1.0)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(0.5,GF(baseNote+5.),0.25)\n        \n    baseNote = 12.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(1.0,GF(baseNote+5.),1.0)\n    N(1.0+0.0,GF(baseNote-1.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 10.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(1.0,GF(baseNote+6.),1.0)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(1.0,GF(baseNote+6.),1.0)\n        \n    baseNote = 8.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(1.0,GF(baseNote+5.),1.0)\n    N(1.5+0.0,GF(baseNote-1.0),1.5)N(1.0,GF(baseNote+2.),1.0)N(1.5,GF(baseNote+5.),1.5)\n    N(2.0+0.0,GF(baseNote-1.0),2.0)\n    \n    startEndX = sumx+2.;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(18.0+0.0,GF(0.0),18.0)\n    \n    baseNote = 8.;\n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+0.0),12.0)\n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+3.0),12.0)\n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+6.0),12.0)\n    \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+9.0),12.0)\n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+12.0),12.0)        \n    \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+15.0),12.0)\n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+18.0),12.0)        \n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(18.0,GF(baseNote+21.0),18.0) \n    N(3.5,GF(baseNote+20.0),3.5) N(2.5,GF(baseNote+18.0),2.5) N(2.5,GF(baseNote+16.0),2.5)\n    N(1.5,GF(baseNote+15.0),1.5) N(1.,GF(baseNote+13.0),1.) N(1.5,GF(baseNote+12.0),1.5)\n    N(1.0,GF(baseNote+10.0),1.0) N(1.5,GF(baseNote+12.0),1.5)\n    N(3.5,GF(baseNote+8.00),3.5) N(2.5,GF(baseNote+12.0),2.5) N(2.5,GF(baseNote+15.0),2.5)\n    N(2.0+1.0,GF(baseNote+18.0),2.0) N(2.5,GF(baseNote+18.0),2.5) N(1.0,GF(baseNote+16.0),1.0)\n    N(1.0,GF(baseNote+18.0),1.0) N(0.5,GF(baseNote+16.0),0.5) N(0.5,GF(baseNote+18.0),0.5)\n    N(6.0,GF(baseNote+16.0),6.0) N(6.0,GF(baseNote+15.0),6.0)\n    \n    //\n    startEndX = sumx;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(1.0),15.0)\n    \n    sumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+1.0),15.0)\n    \n\tsumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+4.0),15.0)\n    \n\tsumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+8.0),15.0)\n    \n    sumx = startEndX; x = t; presstime = 0.0;\n    N(9.0+0.0,GF(baseNote+13.0),15.0)\n    \n    sumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+16.0),15.0)\n    \n    baseNote = 26.;\n    startEndX = sumx+7.;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(1.5+3.0,GF(baseNote+0.0),1.5) N(1.5+1.0,GF(baseNote+3.0),1.5)\n    N(1.5+1.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+5.0),1.5)\n    N(1.5+1.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.5)\n    N(1.0+0.5,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+3.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+5.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+6.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+8.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+5.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+8.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+10.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+8.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+10.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+11.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+8.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+10.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+8.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+5.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+6.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+3.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+5.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+2.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(2.0+0.0,GF(baseNote+2.0),2.0)\n    N(1.0+0.5,GF(baseNote+0.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+1.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-2.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+0.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-4.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-2.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-5.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.5+0.0,GF(baseNote-4.0),1.5)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-6.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-2.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-5.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-4.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-7.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-5.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-8.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.5+0.0,GF(baseNote-7.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-11.),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-10.),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-13.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-11.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-15.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-13.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-16.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-15.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-17.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-13.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-15.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-14.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-17.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-15.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(2.0+0.0,GF(baseNote-13.),2.0)\n    N(2.0+0.0,GF(baseNote+0.0),2.0) N(7.0+0.0,GF(baseNote-12.),7.0)\n    \n    //\n    baseNote = 22.;\n    startEndX = sumx+4.;\n    sumx = startEndX+2.5; x = t; presstime = 0.0;\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+4.0),1.0) N(1.0+1.0,GF(baseNote+0.0),1.0) //6 (+1)\n    N(1.0+0.0,GF(baseNote-1.0),1.0) N(1.0+0.0,GF(baseNote+3.0),1.0) N(1.0+1.0,GF(baseNote-1.0),1.0) //7 + 3 = 10 (+1)\n    N(1.0+0.0,GF(baseNote-3.0),1.0) N(1.0+0.0,GF(baseNote+1.0),1.0) N(1.0+1.0,GF(baseNote-3.0),1.0) //11 + 3 = 14 +(+1)\n    N(1.0+0.0,GF(baseNote-4.0),1.0) N(1.0+0.0,GF(baseNote-1.0),1.0) N(1.0+1.0,GF(baseNote+3.0),1.0) //15 + 3 = 18\n        \n    //\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(4.0+2.0,GF(baseNote-3.0),4.0) N(4.0+0.0,GF(baseNote-5.0),4.0)N(4.0+0.0,GF(baseNote-7.0),4.0)N(4.0+0.0,GF(baseNote-8.0),4.0)\n\n    //\n    baseNote = 22.;\n    startEndX = sumx+2.;\n    sumx = startEndX+4.; x = t; presstime = 0.0;\n    N(2.0 + 4.5,GF(baseNote),2.0) N(2.0 + 4.5,GF(baseNote-1.),2.0) N(2.0 + 1.0,GF(baseNote-3.),2.0) N(15.0,GF(baseNote-1.),15.0)\n    //\n    baseNote = 18.;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(6.0 + 0.5,GF(baseNote),6.0)N(6.0 + 0.5,GF(baseNote-4.),6.0)N(6.0 + 1.0,GF(baseNote-3.),6.0)N(15.0,GF(baseNote-1.),15.0)\n        \n    return note;\n}\n//---------------------------------\n\nfloat IsInside(vec2 fragCoord, vec4 memPos)\n{\n    vec2 d = abs(fragCoord - 0.5 - memPos.xy - memPos.zw*0.5) - memPos.zw*0.5 - 0.5;\n    return -max(d.x, d.y);\n}\n\nfloat IsInside(vec2 fragCoord, vec2 memPos)\n{\n    vec2 d = abs(fragCoord - 0.5 - memPos) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec2 GetListId(vec2 fragCoord, vec4 memPos)\n{\n    return fragCoord - 0.5 - memPos.xy;\n}\n\nvoid Save(vec2 memPos, vec4 value, vec2 fragCoord, inout vec4 fragColor)\n{\n    fragColor = IsInside(fragCoord, memPos) > 0. ? value : fragColor;\n}\n\nvoid Save(vec4 memPos, vec4 value, vec2 fragCoord, inout vec4 fragColor)\n{\n    fragColor = IsInside(fragCoord, memPos) > 0. ? value : fragColor;\n}\n\nvec4 LoadMem0(vec2 memPos)\n{\n    return texture(iChannel0, (memPos+0.5)/iChannelResolution[0].xy, -100.);\n}\n\n//----------\nfloat hash(vec2 p)\n{\n    return fract(sin(length(p))*2958.16925);\n}\n\nfloat hash(float x) { return fract(sin(x)*2958.16925); }\n\nfloat rand(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f*(3.-2.*f);\n    \n    return mix(\n        mix(hash(i+vec2(0., 0.)), hash(i+vec2(0., 1.)), f.x), \n        mix(hash(i+vec2(1., 0.)), hash(i+vec2(1., 1.)), f.x), \n        f.y);\n}\n\nint GetNumBallsToSpawn(inout vec4 spawn)\n{   \n    float currTime = gTime / tint; \n    gMusicTimei = floor(currTime);\n    \n    // Avoid respawn in the same time window!!\n    if(abs(spawn.x - gMusicTimei) < 5.0e-1)\n    {\n        return 0;\n    }\n    spawn.x = gMusicTimei;\n    return int( 0.01 + min(2., GetTocattaAndFugue(currTime)));\n}\n\nvoid SpawnParticles(inout vec4 abubble, inout vec4 abubbleState, inout int numToSpawn, inout vec4 spawn, inout float lastArrowSide, in int i)\n{\n    const vec2 minXPos = vec2(-1.25, -1.);\n    const float cellSperation = 3.4/6.;\n    \n    if(numToSpawn > 0 && abubbleState.x <= 0. && (gTime - abubbleState.z) > BUBBLE_FADE_OUT_TIME)\n    {\n        numToSpawn--;\n        spawn.y++;\n        \n        // Modify the number of spawn to vary the position\n        float extraPos = max((hash(float(iFrame)) - 0.7)/0.3, 0.)*12.;\n\n        float posId = (mod(extraPos + spawn.y, 6.)/6.);\n        \n        float posX = -1.5 + 1.7*posId*gAR;\n        abubble = vec4(posX, -1., -sign(posX)*0.05 , kMoveSpeed);\n        float arrowSide = floor(4.0*abs(hash(vec2(10.478*gTime + float(i)*5098.45))));\n        if( abs(lastArrowSide-arrowSide) < 1.0e-3 )\n        {\n            arrowSide = mod(arrowSide +1., 4.);\n        }\n        lastArrowSide = arrowSide;\n        abubbleState = vec4(1., arrowSide , 0., 0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    realFragCoord = fragCoord;\n    if(fragCoord.x > float(NUM_BUBBLES)+1.5 || fragCoord.y > 2.5) return;\n    \n    dt = iTimeDelta;\n    gTime = iTime;\n    \n    gAR = iResolution.x/iResolution.y;\n    \n    vec2 coord = fragCoord.xy / iResolution.xy;\n    vec2 uv = coord * 2. -1.;\n    uv.x *= gAR;\n    \n    vec4 mouse = iMouse; mouse.xy /= iResolution.xy;\n    mouse.xy = mouse.xy * 2. -1.;\n    mouse.x *= gAR;\n    \n    // Load Values\n    vec4 bubble = LoadMem0(fragCoord -0.5);\n    vec4 bubbleState = LoadMem0(fragCoord -0.5);\n    vec4 bubbleFx = LoadMem0(fragCoord -0.5);\n    vec4 player = LoadMem0(txPlayer);\n    vec4 spawn = LoadMem0(txSpawn);\n    \n    if(iFrame == 0 || iTime == 0.)\n    {\n        player.x = -1.;\n    }\n    \n    // State: Reset\n    if(player.x < -0.5)\n    {\n        bubble = vec4(-999.);\n        bubbleState = vec4(-999.);\n        spawn = vec4(-999.);\n        player = vec4(1., 0., 0., 0.);\n    }\n\n    // State: Playing\n    else if(player.x < 1.5)\n    {   \n        int numToSpawn = GetNumBallsToSpawn(spawn);\n        float lastArrowSide = -1.;\n        \n        // Update multiplier\n        float multiplier = 0.;\n        multiplier += step(0.4, player.w);\n        multiplier += step(0.6, player.w);\n        multiplier += step(0.8, player.w);\n        multiplier += step(0.95, player.w)*4.;\n        player.z = multiplier;\n        \n        // Update bubbles\n        float isBallDestroyed = 0.;\n        for(int i = 0; i < NUM_BUBBLES; ++i)\n        {\n            vec4 aBubble = LoadMem0(txBubble.xy+vec2(i, 0.));\n            vec4 aBubbleState = LoadMem0(txBubbleState.xy+vec2(i, 0.));\n            \n            // Spawn Particle\n        \tSpawnParticles(aBubble, aBubbleState, numToSpawn, spawn, lastArrowSide, i);\n\n            // If alive\n            if(aBubbleState.x > 0.)\n            {\n                // Check it is destroyed by the player\n                if(isBallDestroyed < 0.5 && abs(aBubble.y - 0.30) < 0.1)\n                {\n                    if( aBubbleState.y < 0.5){\n                        if(texture(iChannel3, vec2(KEY_UP, 0.25)).x > 0. ) isBallDestroyed = 1.;}\n                    else if( aBubbleState.y < 1.5 ){\n                        if( texture(iChannel3, vec2(KEY_LEFT, 0.25)).x > 0. ) isBallDestroyed = 1.;}\n                    else if( aBubbleState.y < 2.5 ){\n                        if( texture(iChannel3, vec2(KEY_DOWN, 0.25)).x > 0. ) isBallDestroyed = 1.;}\n                    else if( aBubbleState.y < 3.5 ){\n                        if( texture(iChannel3, vec2(KEY_RIGHT, 0.25)).x > 0. ) isBallDestroyed = 1.;}\n                    \n                    if(isBallDestroyed > 0.)\n                    {   \n                        float points = 0.1 + 0.9*(1.0-(abs(aBubble.y - 0.30)/0.1));\n\t\t\t\t\t\tplayer.y += points * (multiplier + 1.);\n                        player.w = min(2.0, player.w + points*kLifePerHit);\n                        \n                        aBubbleState.x = -1.;\n                        aBubbleState.z = gTime;\n                    }\n\n                }\n                else if(aBubble.y - 0.35 > 0.0)\n                {\n                    aBubbleState.x = -1.;\n                    aBubbleState.z = gTime;\n                    player.w = max(0., player.w - kLifePerHit*0.5);\n                }\n                \n                // If still alive Update\n                if(aBubbleState.x > 0.)\n                {\n                    aBubble.xy += aBubble.zw * dt;\n                }\n            }\n            \n            // Save current bubble state\n            if(IsInside( fragCoord, txBubble.xy+vec2(i, 0.) ) > 0.)\n            {\n                bubble = aBubble;\n            }\n            if(IsInside( fragCoord, txBubbleState.xy+vec2(i, 0.) ) > 0.)\n            {\n                bubbleState = aBubbleState;\n            }\n        }\n    }\n    \n    // Store Values\n    Save(txBubble, bubble, fragCoord, fragColor);\n    Save(txBubbleState, bubbleState, fragCoord, fragColor);\n    Save(txPlayer, player, fragCoord, fragColor);\n    Save(txSpawn, spawn, fragCoord, fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// City Background\n\nconst float kRayEpsilon = 0.005;\nconst int kIterations = 40;\nconst float kTMax = 150.;\n\nfloat gTime;\nfloat gAmbientFactor = 0.127;\nvec3 gSpecColor = vec3(0.964, 0.972, 0.729);\nvec3 gLightpos = vec3(0., 10., 5.);\nvec3 gLightColor = vec3(1.);\n\n// fog\nconst vec3 fogColor1 = vec3(0.521, 0.525, 0.337)*0.20;\nconst vec3 fogColor2 = vec3(0.498, 0.345, 0.325)*0.20;\nconst vec3 glowColor = vec3(0.521, 0.525, 0.337)*0.60;\n\nfloat hash(float x) { return fract(sin(x)*146.6892); }\nfloat hash(vec2 x) { return fract(sin( dot(x, vec2(154.1573, 612.8961)))*1468.4892); }\nfloat maxcomp(vec3 x) { return max(max(x.x, x.y), x.z); }\nfloat mincomp(vec3 x) { return min(min(x.x, x.y), x.z); }\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.0 - 2.0*f);\n    \n    return mix( mix( hash(i+vec2(0.0, 0.0)), hash(i+vec2(1.0, 0.0)), f.x ),\n                mix( hash(i+vec2(0.0, 1.0)), hash(i+vec2(1.0, 1.0)), f.x ), f.y );\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    \n    p.y -= gTime * 0.08;\n    f += 0.500 * noise(p); p *= 2.124; p.x += gTime * 0.13;\n    f += 0.250 * noise(p); p *= 2.445; p.x -= gTime * 0.16;\n    f += 0.125 * noise(p); p *= 2.845; p.y += gTime * 0.07;\n    //f += 0.0625 * noise(p); p *= 3.15;\n    //f /= 0.9375;\n    f /= 0.875;\n    \n    return f;\n}\n\nfloat dBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p)-b, 0.)) - r;\n}\n\nfloat dBox(vec3 p, vec3 b)\n{\n    return maxcomp(abs(p)-b);\n}\n\nvec3 RotateY(vec3 p, float roll)\n{\n    vec2 cs = vec2(cos(roll), sin(roll));\n    mat3 mat = mat3(vec3(cs.x, 0., cs.y),\n                    vec3(0., 1., 0.),\n                    vec3(-cs.y, 0., cs.x)\n                   );\n    return p*mat;\n}\n\nfloat dBuilding(vec3 p, vec3 cube)\n{\n    return dBox(vec3(p.x, p.y, p.z), cube, 0.001);\n}\n\nvec3 GetCube(vec2 cell)\n{\n    float h = hash(152.325 + cell.xy*958.458);\n    h = 0.5 + 0.5*h;\n    float w = 0.25 + h*0.25;\n    float z = w; // 0.3 + h*0.15;\n    \n    h = pow(h, 3.)*3.0;\n\n    float d = cell.x+15. - cos(cell.y*0.06)*15.;\n    \n    d = sign(max(d, 0.));\n    h *= d;\n    h *= sign(hash(cell.xy) - 0.6);\n    \n    return vec3(w, h, z);\n}\n\nvec4 MapBuilding(vec3 p)\n{\n    vec2 cellId = floor(p.xz);\n    vec3 cube = GetCube(cellId);\n    \n    vec3 buildingPos = vec3(cellId.x + 0.5, cube.y, cellId.y + 0.5);\n    float d = dBuilding( p - buildingPos, cube);\n    \n    return vec4(d, p.xyz);\n}\n\nvec4 MapWater(vec3 p)\n{\n    vec4 res = vec4(-1.);\n    \n    // Water\n    float d = p.y+0.2;\n    res.xy = vec2(d, 0.);\n    \n    return res;\n}\n\nvec4 MapFloor(vec3 p)\n{\n    vec4 res = vec4(-1); res.y = 1.;\n    res.x = p.y;\n    res.x = max(res.x, -p.x-10.7 + cos(p.z*0.08)*10.);\n    return res;\n}\n\nvec4 MapEnv(vec3 p)\n{\n    vec4 res = MapWater(p);\n    vec4 res2 = MapFloor(p);\n    if(res2.x < res.x) { res = res2; }\n    \n    return res;\n}\n\nvec4 IntersectEnv(vec3 o, vec3 rd, float tmin, float tmax)\n{\n    vec4 res = vec4(-1.);\n    float t = tmin;\n    float d = 0.;\n    for(int i = 0; i < kIterations; ++i)\n    {\n        res = MapEnv(o + rd*t);\n        d = res.x;\n        t += d;\n        if(d < kRayEpsilon || t > tmax) { break; }\n    }\n    \n    res.x = t;\n    if(d > kRayEpsilon*2. )\n    {\n        res = vec4(-1); res.x = tmax;\n    }\n    \n    return res;\n}\n\n// Reference: iq - https://www.shadertoy.com/view/Msl3Rr\nvec4 IntersectBuildings(vec3 ro, vec3 rd, float tmin, float tmax, out vec3 cube, out float minD)\n{\n    minD = tmax;\n    vec4 res = vec4(-1.); res.x = tmax;\n\n    vec3 rdi = 1./rd;\n    vec3 rdia = abs(rdi);\n    vec3 rds = sign(rd);\n    \n    ro += tmin*rd;\n    vec2 cell = floor(ro.xz);\n    vec2 dis = (cell.xy + 0.5 + rds.xz*0.5 - ro.xz) * rdi.xz;\n    \n    // Traverse 2D Grid\n    for(int i = 0; i < 36; ++i)\n    {\n        cube = GetCube(cell);\n        \n        vec3 cellPos = vec3(cell.x + 0.5, cube.y, cell.y + 0.5);\n        vec3 cellDir = cellPos - ro;\n        \n        float distNear = max(mincomp(cellDir*rdi - cube*rdia), 0.);\n        float distFar = max(maxcomp(cellDir*rdi + cube*rdia), 0.);\n        \n        // RayMarch\n        if(distNear < distFar && cube.y > 0.0)\n        {\n            float s = distNear;\n            for(int j = 0; j < 14; ++j)\n            {\n                if(s > distFar)\n                {\n                    break;\n                }\n\n                vec3 currPos = rd*s - cellDir;\n                float d = dBuilding(currPos, vec3(cube.x,cube.y, cube.z));\n                minD = min(minD, d);\n                s += d;\n                if(d <= kRayEpsilon)\n                {\n                    res.x = s;\n                    res.yzw = currPos.xyz/cube.xyz;\n                    return res;\n                }\n            }\n        }\n        \n        // step to next cell\t\t\n\t\tvec2 mm = step( dis.xy, dis.yx ); \n\t\tdis += mm*rdia.xz;\n        cell += mm*rds.xz;\n    }\n    \n    return res;\n}\n\nvec3 CalcNormalBuilding( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0, -1.0)*0.01;\n    return normalize( e.xyy*MapBuilding( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*MapBuilding( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*MapBuilding( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*MapBuilding( pos + e.xxx ).x );\n\n}\n\nvec3 CalcNormalEnv( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*kRayEpsilon*t;\n    return normalize( e.xyy*MapEnv( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*MapEnv( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*MapEnv( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*MapEnv( pos + e.xxx ).x );\n}\n\n\nmat3 GetLookAt(vec3 o, vec3 t, float roll)\n{\n    vec3 w = normalize(t - o);\n    vec3 ytmp = vec3(sin(roll), cos(roll), 0.);\n    vec3 u = normalize( cross(ytmp,w ) );\n    vec3 v = normalize(cross(w, u));\n    \n    return mat3(u, v, w);\n}\n\nvec3 GetLightPos(vec3 ro, vec3 ta)\n{\n    vec3 lookAtDir = ta - ro; lookAtDir.y = 0.;\n    lookAtDir = normalize(lookAtDir);\n    return ro + lookAtDir*2.;\n}\n\nvec3 GetBgColor(vec3 rd)\n{\n    // Clouds\n    vec3 p = rd * (2./(rd.y+0.15));\n    vec3 color = vec3(0.027, 0.074, 0.294);\n    float ran = fbm(p.xz*0.2);\n    color = mix(color, vec3(0.376, 0.431, 0.482), ran);\n    color = mix(vec3(0.156, 0.062, 0.356), color, smoothstep(0., 0.7, ran));\n    color *= 0.2;\n    \n    // Moon\n    vec3 moonDir = normalize(vec3(-1., 0.28, -0.0));\n    float moonFactor = pow(max(dot(moonDir, rd), 0.), 20.)*0.4;\n         moonFactor += pow(max(dot(moonDir, rd), 0.), 100.)*0.8;\n    \t moonFactor += pow(max(dot(moonDir, rd), 0.), 270.)*0.8;\n    \n    moonFactor = mix(moonFactor, moonFactor*(0.2+0.8*(1.-smoothstep(0.25, 1.0, fbm(p.xz*4.)))), smoothstep(0.8, 1.0, moonFactor));\n    \n    color += moonFactor * vec3(0.788, 0.8, 0.560)*0.7;\n    \n    float y = rd.y+0.15;\n    vec3 horizonColor = vec3(0.207, 0.129, 0.329);\n    color = mix(fogColor1, color, smoothstep(0.1, 1., pow(max(abs(y)*3.0, 0.), 0.5)));\n    color = mix(fogColor2, color, smoothstep(0., 1., pow(max(abs(y)*4.5, 0.), 0.4)));\n    \n    return color;\n}\n\nfloat dBox(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b, 0.)) - r;\n}\n\nvec3 Shade(vec3 col, vec4 mat, vec3 p, vec3 n, vec3 rd)\n{\n    // Light\n    vec3 ld = (gLightpos - p);\n    float ldistxz = length(ld.xz);\n    ld = normalize(ld);\n    float latt =  0.5*pow(1.-smoothstep(5., 30., ldistxz), 5.);\n    \n    float df = gAmbientFactor + (1.-gAmbientFactor) * max(dot(ld, n), 0.);\n\n    vec3 hf = normalize( (-rd + ld)*0.5 );\n    float specf = pow(max(dot(n, hf), 0.), 6.)*mat.x;\n    vec3 specColor = specf * gSpecColor;\n    \n    float fresnelBase = dot(-rd, n);\n    float fresnel = pow(fresnelBase, 10.)*mat.y; \n    float rim = pow(max(1.-fresnelBase, 0.), 1.)*mat.z; \n    \n    vec3 refld = rd + 2.*dot(-rd, n)*n;\n    \n    vec3 bgColor = GetBgColor(refld);\n    vec3 fresnelColor = fresnel * bgColor;\n    vec3 rimColor = rim * bgColor;\n    \n    vec3 finalColor = (df*col + fresnelColor + rimColor) * gLightColor + specColor;\n    return (0.1 + 0.9*(finalColor * latt + col * gAmbientFactor))*0.1;\n}\n\n// mat: spec, fresnel, rim\nvoid GetBuildingColor(vec3 cube, vec4 res, vec3 p, vec3 n, vec3 rd, out vec3 color, out vec4 mat)\n{   \n    vec3 localPos = res.yzw;\n    vec2 uv = localPos.xy*abs(dot(n, vec3(0., 0., 1.)))\n        \t+ localPos.zy*abs(dot(n, vec3(1., 0., 0.)));\n \n    // Main CubeColor\n    color = mix(vec3(hash(cube.y)*0.5), vec3(hash(150.52 + cube.y), hash(cube.y*9.21), hash(cube.y*59.78)), 0.25);\n    color = sqrt(sqrt(color));\n    color *= texture(iChannel0, uv.yx*vec2(1., 2.)*1.0 + vec2(cube.y, 0.)).xyz;\n    color *= 0.15;\n    \n    // Windows\n    vec2 q = uv;\n    \n    vec2 winId = 125.692 * floor(q/vec2(0.4, 0.1));\n    \n    // Set Lighting Properties\n    float winLightInt = pow(hash(winId), 4.);\n    \n    vec2 q2 = q; q2 = mod(q2, vec2(0.4, 0.1)) - vec2(0.20, 0.05);\n    vec3 winLightColor = vec3(hash(125.+winId), hash(winId*12.56), hash(winId * 96.58));\n    winLightColor += vec3(0.745, 0.666, 0.152);\n    winLightColor = min(winLightColor*1.5, 1.);\n    \n    float dWindow = pow(max(-dBox(q2, vec2(0.15, 0.015), 0.01)/0.01, 0.), 5.5);\n    vec3 winColor = winLightInt*mix(color, winLightColor, smoothstep(0., 1., dWindow * step(n.y, 0.5)));\n    \n    float lFactor = 1.-smoothstep(0., 1., abs(q2.x)/0.15);\n    lFactor *= 1.-smoothstep(0., 1., abs(q2.y)/0.03);\n    float totalLFactor = pow(lFactor, 0.09);\n    totalLFactor  += pow(lFactor, 0.5)*2.;\n    totalLFactor  += pow(lFactor, 1.0);\n    totalLFactor  += pow(lFactor, 2.0);\n    \n    winColor += step(0.6, winLightInt)*mix(color, winLightColor, totalLFactor);\n    color = mix(winColor, color, smoothstep(0., 0.001, abs(q.x)-0.80) );\n\n    gAmbientFactor = mix(0.00, winLightInt, smoothstep(0., 1., dWindow));\n    mat = vec4(0.);\n    mat.x = 0.5; mat.y = 0.5; mat.z = 0.0;\n}\n\n// mat: spec, rim\nvoid GetEnvColor(in vec4 res, in vec3 p, inout vec3 n, inout vec3 rd, inout vec3 color, inout vec4 mat)\n{\n    // Water\n    if(res.y < 0.5)\n    {\n        // wave in x dir\n        float ran = 0.0;\n        ran += 0.5000 * sin(p.x*0.8 - gTime*0.5);\n        ran += 0.2500 * sin(1.6 + p.x*0.8 - gTime*1.);\n        ran += 0.1250 * sin(2.1 + p.x*1.4 - gTime*1.8);\n        ran += 0.0625 * sin(2.8 + p.x*2.1 - gTime*2.0);\n        ran /= 0.9375;\n        \n        // limit wave size\n        ran *= cos(gTime*0.1 + p.z*0.1 + cos(p.x*0.2))*2.;\n        \n        ran = 0.5+0.5*ran; ran *= 2.5;\n        ran *= smoothstep(-6., 25.0, -p.x);\n        \n        // add noise\n        ran += fbm(p.xz*vec2(1.5, 1.8))*1.0;\n        \n        vec3 nor = n;\n        n = normalize(n + vec3(((ran*2.-1.)*0.015)));\n        vec3 refN = normalize(n + vec3(((ran*2.-1.)*0.045)));\n        \n        vec3 reflDir = rd + 2.0*dot(-rd, n)*n;\n        float fresnelBase = max(dot(-rd, n), 0.);\n        float fresnelFactor = pow(0.10+0.90*fresnelBase, 8.); // water profundity color factor\n        float rimFactor = pow(min(0.2 + 0.80-0.80*fresnelBase, 4.), 4.); // water sky color factor\n        float specFactor = pow(max(dot(reflDir, normalize(vec3(0., 1.0, 0.))), 0.), 8.)*0.1;\n        \n        vec3 building = vec3(0.);\n        float minD = kTMax;\n        vec4 refRes = IntersectBuildings(p, reflDir, 0.5, kTMax, building, minD);\n        vec3 reflColor = GetBgColor(reflDir+vec3(0., 0.02, 0.));\n        if(refRes.x < kTMax)\n        {\n            GetBuildingColor(building, res, p, n, rd, reflColor, mat);\n            reflColor *= 0.05;\n        }\n        vec3 waterColor = vec3(0.113, 0.345, 0.2);\n        reflColor += pow(rimFactor, 4.) * texture(iChannel1, 0.8 + p.xz*vec2(0.016, 0.02) + n.xz*0.5).xyz;\n        color = reflColor * rimFactor;\n        color += waterColor * fresnelFactor;\n        color *= 0.2;\n    }\n    // Floor\n    else if(res.y < 1.5)\n    {\n        color = vec3(0.458, 0.494, 0.541)*0.5;\n        color *= pow( texture(iChannel0, p.xz*vec2(0.5, 0.25)).x, 4.);\n        \n    \tgAmbientFactor = 0.005;\n        color = max(vec3(0.01), Shade(color, vec4(0.5, 0.5, 0.5, 0.), p, n, rd));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime*1.5;\n    \n\tvec2 p = (fragCoord.xy*2. -iResolution.xy)  / iResolution.yy;\n    vec2 mouse = iMouse.xy/iResolution.xy *2. -1.;\n    \n    vec3 ro = RotateY(vec3(0.0, 7.5+sin(gTime*0.16)*1.5, -10.0 + sin(gTime*0.1)*5.), -1.5+gTime*0.025);\n    vec3 ta = vec3(-4.5+cos(gTime*0.1)*6., 5. + sin(gTime*0.15)*1.5, 0.) + vec3(mouse.x, mouse.y, 0.)*0.;\n    \n    mat3 ca = GetLookAt(ro, ta, 0.);\n    vec3 rd = normalize(ca * vec3(p, 1.5));\n\n    // Render\n    gLightpos = GetLightPos(ro, ta);\n    vec3 bgColor = GetBgColor(rd);\n    vec3 color = bgColor;\n    \n    float maxDistance = 250.;\n    vec3 building = vec3(0.);\n    \n    // Environment\n    vec4 res = IntersectEnv(ro, rd, 0.01, 250.);\n    maxDistance = min(maxDistance, res.x);\n    if(res.x < kTMax)\n    {\n        vec3 p = ro + res.x*rd;\n        \n        vec3 n = CalcNormalEnv(p, res.x);\n        vec3 nor = n;\n        \n        vec4 mat = vec4(0.);\n        GetEnvColor(res, p, n, rd, color, mat);\n    }\n    \n    // Building\n    float minD = kTMax;\n    res = IntersectBuildings(ro, rd, 0.01, 250., building, minD);\n    maxDistance = min(maxDistance, res.x*1.25);\n    if(res.x < kTMax)\n    {\n        vec3 p = ro + res.x*rd;\n        vec3 n = CalcNormalBuilding(p, res.x);\n        \n        vec4 mat = vec4(0.);\n        GetBuildingColor(building, res, p, n, rd, color, mat);\n        color = max(vec3(0.001), Shade(color, mat, p, n, rd));\n    }\n    \n    // Fog\n    color = mix(color, mix(bgColor, fogColor2, 0.5), smoothstep(5., 46., maxDistance));\n    \n    // Glow\n    //minD *= 1.0 + (0.5+0.5*sin(building.y*10. + gTime*1.0));\n    //vec3 glowColor = mix(glowColor, color, smoothstep(0., 1., max(minD, 0.)));\n    //color += glowColor * smoothstep(kRayEpsilon+0.01, kRayEpsilon+0.05, minD);\n    \n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Draws Fireworks\n// Reference for Fireworks: yibojiang - https://www.shadertoy.com/view/Xl2SRR\n\nconst float PI = 3.14159265359;\nconst float PI2 = 2.*PI;\nconst vec2 gGravity = vec2(0., -2.0);\nconst float expSize = 0.01;\n\nfloat gT;\nvec2 gUV;\n\n// Bubble parameters\nconst int NUM_BUBBLES = 20;\nconst float BUBBLE_FADE_OUT_TIME = 2.5;\nvec2 txPlayer = vec2(0., 0.);\nvec4 txBubble = vec4(0., 1., 5., 0.);\nvec4 txBubbleState = vec4(0., 2., NUM_BUBBLES, 0.); // x:Life, y:Rad\n\nvoid DrawLittleParts(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color);\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(16874.65123, 328749.2019)))*156.18563); }\nfloat hash(float p) { return fract(sin(p)*156.18563); }\n\nvec2 Rotate2D(vec2 p, float r)\n{\n    vec2 sc = vec2(sin(r), cos(r));\n    return vec2( p.x*sc.y + p.y*sc.x, p.y*sc.y - p.x*sc.x );\n}\n\nfloat noise(float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n    f *= f * (3. - 2.*f);\n    \n    return mix( hash(i-f), hash(i+f), f );\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f*(3.-2.*f);\n    \n    return mix( mix( hash(i+vec2(0., 0.)), hash(i+vec2(1., 0.)), f.x ),\n           mix( hash(i+vec2(0., 1.)), hash(i+vec2(1., 1.)), f.x ), f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float res = 0.;\n    \n    res += 0.500*noise(p); p *= 2.1;\n    res += 0.250*noise(p); p *= 2.8;\n    res += 0.125*noise(p); p *= 3.16;\n    res /= 0.875;\n    \n    return res;\n}\n\nvec2 GetDeltaPos(vec2 v, vec2 a, float t)\n{\n    return v*t + 0.5*a*t*t;\n}\n\nfloat GetFlicker(float i)\n{\n    return 0.25+0.75*noise(i);\n}\n\nvec4 DrawParticle(float id, vec2 p, float size, float t, vec3 color, float powFactor, float duration, float prevDuration, float distort)\n{\n    p.y *= 1. + sin(id*99.5+ dot(gUV,gUV)*40.+ gT*4.)*0.18 * distort;\n    p.x *= 1. + cos(id*189.1+ dot(gUV,gUV)*76.+ gT*3.5)*0.13 * distort;\n    \n    float dist = dot(p, p)/size;\n    float distNorm = smoothstep( 0., 1., pow(dist, powFactor) );\n    \n    duration = max(duration * (1.- smoothstep(0., 1., pow(dist, 0.1)) ), prevDuration);\n    \n    vec4 res = mix( vec4(color.rgb, duration), vec4(0., 0., 0., prevDuration), distNorm );\n    return mix(mix(vec4(0., 0., 0., max(res.a, prevDuration)), res, smoothstep(0.0, 0.15, t)), vec4(0., 0., 0., max(res.a, prevDuration)), smoothstep(0.5, 1., t));\n}\n\nvoid DrawGlow(vec2 p, float t, vec3 fireColor, inout vec4 color)\n{\n    vec4 pFinalColor = DrawParticle(0., p, 20., min(t/0.15, 1.), fireColor, 0.1, 0.01, color.a, 0.);\n    color.rgb += pFinalColor.rgb; color.a = pFinalColor.a;\n}\n\nvoid DrawHeart(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    float texpNormPow = pow(t, 0.45);\n    float gravityScale = max(t-0.55, 0.)/0.55;\n    \n    DrawGlow(p, t, fireColor, color);\n    \n    for(float i=0.; i < 20.5; ++i)\n    {\n        vec2 pDir = normalize( vec2(hash(i*198.9885), hash(45.6924*hash(i))) * 2. -1. );\n        float at = atan(pDir.y, pDir.x);\n        float r = (  2. -2.*sin(at) + sin(at)*sqrt(abs(cos(at)))/(sin(at)+1.4)  ) * 0.30;\n        vec2 q = p - (pDir*r * texpNormPow + 0.05*gGravity*gravityScale*gravityScale);\n\n        vec3 pColor = clamp(mix(fireColor, vec3(pDir.x, pDir.y, r), hash(i)*0.5), 0., 1.);\n\n        float flicker = GetFlicker(i + t*0.3);\n\n        float size = expSize * sin(texpNormPow*PI)*0.1;\n\n        vec4 pFinalColor = DrawParticle(i, q+0.*vec2(hash(i+t*0.1)*0.02, 0.), size + 0.5*size*(noise(i+t*0.05)*2.-1.), t, pColor, 0.5, 9.0*hash(i+t*10.), color.a, 1.);\n        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n}\n\nvoid DrawPalmTree(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    float t2 = min(t/0.8, 1.);\n    float texpNormPow = pow(t2, 0.5);\n\n    DrawGlow(p, t, fireColor, color);\n\n    for(float i=0.; i < 20.5; ++i)\n    {   \n        // Main Properties\n        float hashP = hash(i*642.856+198.5984);\n        float pSpeed = (0.5 + 1.0*hashP);\n        vec2 pVel = normalize( vec2(0., 1.25) + vec2(hash(i*98.985), hash(45.6924*hash(i))) * 2. -1.).xy;\n\n        vec3 pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.6), 0., 1.);\n\n        // Visibility Properties\n        float sizeScale = 0.1+0.90* max(sin(pow(t, 0.8)*PI) + (hashP*2.-1.)*0.5 , 0.);\n        \n        float flickerFactor = smoothstep(0.8, 1.0, texpNormPow);\n        float flicker = mix(1.0, max(sign(hash(i*958.15 + t) - 0.95), 0.), flickerFactor);\n        pColor = mix(pColor, vec3(1.), flickerFactor);\n        float size = sizeScale*expSize*0.4;\n\n        // Position\n        vec2 deltaPos = pVel*pSpeed*texpNormPow + (0.35*hashP+0.5)*gGravity*t2*t2;\n        vec2 q = p - deltaPos;\n\n        // Draw Particle\n        vec4 pFinalColor = DrawParticle(i, (q + flickerFactor * 0.08*vec2(hash(i*99.592+t*100.1), hash(i*125.151+t*185.458))), size, 0.5, pColor, 0.1, 9.*hash(i+t*10.), color.a, 1.);\n        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n}\n\nvoid DrawBigParts(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    DrawGlow(p, t, fireColor, color);\n    \n    float texpNormPow = pow(t, 0.5);\n    vec2 gravity = gGravity * 0.15;\n    \n    vec2 scaleDirection = normalize(vec2(hash(id+5.228), hash(id+9.8921)));\n    for(float i=0.; i < 10.5; ++i)\n    {   \n        // Main Properties\n        float iNorm = i/10.;\n        float hashP = hash(i*42.856+98.5984);\n        float pSpeed = 0.85;\n        vec2 pVel = normalize(vec2(cos(iNorm*PI2), sin(iNorm*PI2)));\n        pVel *= 0.60+0.4*pow(abs(dot(scaleDirection, pVel)), 0.70);\n        \n        vec3 pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.25), 0., 1.);\n\n        // Visibility Properties\n        float sizeScale = (0.6+0.4*hashP);\n        float flicker = (0.2+0.8*noise(i + t*0.2));\n        float size = sizeScale*expSize*0.20;\n\n        // Position\n        vec2 deltaPos = pVel*pSpeed*texpNormPow + (0.5*hashP+0.5)*gravity*t*t;\n        vec2 q = p - deltaPos;\n\n        // Draw Particle\n        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size, t, pColor, 0.7, 9.0*hash(i+t*10.), color.a, 1.);\n        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n    \n    DrawLittleParts(id, p, (t-0.05)/0.95, vec2(0., 0.0), fireColor, color);\n}\n\nvoid DrawLittleParts(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    float texpNormPow = pow(t, 0.5);\n    vec2 gravity = gGravity * 0.15;\n    \n    vec2 scaleDirection = normalize(vec2(hash(id+5.228), hash(id+9.8921)));\n    for(float i=0.; i < 20.5; ++i)\n    {   \n        // Main Properties\n        float iNorm = i*0.0334;\n        float hashP = hash(i*42.856+198.5984);\n        float pSpeed = ceil(hashP*5.)/5. * 0.60;\n        vec2 pVel = normalize(vec2(cos(iNorm*PI2), sin(iNorm*PI2)));\n        pVel *= 0.60+0.4*pow(abs(dot(scaleDirection, pVel)), 0.70);\n        \n        vec3 pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.5), 0., 1.);\n\n        // Visibility Properties\n        float sizeScale = (0.6+0.4*hashP);\n        float flicker = max(sign(hash(i + t)*2.-1. - 0.90), 0.);\n        flicker = mix(1., flicker, step(0.25, t + hashP*0.1));\n        float size = sizeScale*expSize*0.030;\n\n        // Position\n        vec2 deltaPos = pVel*pSpeed*texpNormPow + (0.5*hashP+0.5)*gravity*t*t;\n        vec2 q = p - deltaPos;\n\n        // Draw Particle\n        vec4 pFinalColor = DrawParticle(i, q, size, t, pColor, 10., 5.*hash(i+t*10.), color.a, 1.);\n        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n}\n\nvoid DrawBigBall(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    DrawGlow(p, t, fireColor, color);\n    \n    float texpNormPow = pow(t, 0.5);\n    vec2 gravity = gGravity * 0.15;\n    \n    vec3 pColor;\n    for(float i=0.; i < 20.5; ++i)\n    {   \n        // Main Properties\n        float hashP = hash(id+i*1492.8561);\n        float hashP2 = hash(id+(hashP*6915.8954)*1658.579);\n        float pSpeed = (0.7+hashP*0.05);\n        vec2 pVel = normalize( vec2(hash(i)*2.-1., hashP2*2.-1.) );\n        \n        pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.4), 0., 1.);\n\n        // Visibility Properties\n        float sizeScale = (0.8+0.2*hashP);\n        float flicker = 1.;\n        float size = sizeScale*expSize*0.2;\n\n        // Position\n        vec2 deltaPos = pVel*pSpeed* (0.1+texpNormPow) + (0.5*hashP+0.5)*gravity*t*t;\n        vec2 q = p - deltaPos;\n\n        // Draw Particle\n        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size*0.3, t, pColor, 0.8, 9.0*hash(i+t*10.), color.a, 1.);\n        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n    \n    vec4 pFinalColor = DrawParticle(0., p, expSize*0.3, t, mix(pColor, fireColor, dot(p, p)*90.), 0.5, 1.5*hash(t*10.), color.a, 1.);\n    color.rgb += hash(id + t) * pFinalColor.rgb; color.a = pFinalColor.a;\n}\n\nvoid DrawFlicker(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    DrawGlow(p, t, fireColor, color);\n    \n    vec2 gravity = gGravity * 0.15;\n    for(float i=0.; i < 16.5; ++i)\n    {   \n        // Main Properties\n        float hashP = hash(id+i*1492.8561);\n        float r = hashP*0.65;\n        vec2 pDir = vec2(hash(t+i*99.8954)*2.-1., hash(t*t+i*9.8954))*0.5;\n        \n        pDir += cos(atan(pDir.y, pDir.x) * 6.)*0.15;\n        \n        vec3 pColor = mix(vec3(1.), fireColor, hashP);\n\n        // Visibility Properties\n        float sizeScale = (0.8+0.2*hashP);\n        float size = sizeScale*expSize*0.1;\n\n        // Position\n        vec2 deltaPos = pDir + (0.5*hashP+0.5)*gravity*t*t;\n        vec2 q = p - deltaPos;\n        \n        float flicker = max(sign(hash(i+t) - 0.95), 0.);\n\n        // Draw Particle\n        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size, t, pColor, 0.5, 9.*hash(i+t*20.), color.a, 1.);\n        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n}\n\nvoid DrawFountain(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)\n{\n    if(t < 0. || t > 1.) return;\n\n    DrawGlow(p, t, fireColor, color);\n    \n    float texpNormPow = pow(t, 0.5);\n    vec2 gravity = gGravity * 0.15;\n    \n    for(float i=0.; i < 14.5; ++i)\n    {   \n        // Main Properties\n        float hashP = hash(id+i*1492.8561);\n        float pSpeed = (0.75+hashP*0.25);\n        vec2 pVel = vec2(sin((i/14.)*PI*0.5)*2.-1., 0.6);\n        \n        pVel = normalize(pVel);\n        \n        vec3 pColor = clamp(mix(fireColor, vec3(abs(pVel.x), pVel.y, pSpeed), hashP*1.0), 0., 1.);\n\n        // Visibility Properties\n        float sizeScale = (0.8+0.2*hashP);\n        float size = sizeScale*expSize*(0.05+sin(texpNormPow*PI*0.5)*0.1);\n\n        // Position\n        vec2 deltaPos = pVel*pSpeed* texpNormPow + (0.5*hashP+0.5)*gravity*t*t;\n        float flicker = smoothstep(0.5, 0.6, texpNormPow);\n        deltaPos += mix(vec2(0.), vec2( hash(i+t), noise(421.454+i*2.+t*flicker) )*0.08*flicker , flicker);\n        vec2 q = p - deltaPos;\n\n        // Draw Particle\n        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size, t, pColor, 0.6, 9.0*hash(i+t*10.), color.a, 1.);\n        color.rgb += pFinalColor.rgb; color.a = pFinalColor.a;\n    }\n    \n    DrawFlicker(id, p, (t-0.3)/0.7, vel, fireColor, color);\n}\n\nvec4 LoadMemoryChannel2(in vec2 uv)\n{\n    return texture(iChannel1, (uv+0.5)/iChannelResolution[2].xy, -100.)*255.;\n}\n\nvec4 LoadMem0(vec2 uv)\n{\n    return texture(iChannel0, (uv+0.5)/iChannelResolution[0].xy, -100.);\n}\n\nvoid DrawFireworks(vec2 p, float deadTime, float life, float id, vec3 ballColor, inout vec4 color)\n{\n    p += (hash(id*deadTime)*2.-1.)*0.15;\n    float kind = hash(deadTime + id)*5.;\n    if(kind < 1.0)\n    {\n    \tDrawHeart(id, p, life, vec2(0.3, 1.75), ballColor, color);\n    }\n    else if(kind < 2.)\n    {\n    \tDrawFountain(id, p, life, vec2(0.3, 1.75), ballColor, color);\n    }\n    else if(kind < 3.)\n    {\n    \tDrawBigBall(id, p, life, vec2(0.3, 1.75), ballColor, color);\n    }\n    else if(kind < 4.)\n    {\n    \tDrawPalmTree(id, p, life, vec2(0.3, 1.75), ballColor, color);\n    }\n    else\n    {\n    \tDrawBigParts(id, p, life, vec2(0.3, 1.75), ballColor, color);\n    }\n}\n\nfloat dArrow(vec2 p)\n{\n    p.y-=0.1;\n    float d = p.y - p.x*1.5 -0.1;\n    d = max(d, p.y + p.x*1.5 -0.1);\n    d = max(d, -p.y - 0.1);\n    \n    float d2 = max(abs(p.x)-0.05, abs(p.y+0.15)-0.1);\n    d = min(d, d2);\n    \n    return d;\n}\n\nvoid DrawBallEffect(vec2 p, vec3 ballColor, inout vec4 color)\n{\n    vec4 sceneColor = color;\n    \n    p *= vec2(1.+noise(ballColor.xx), 1.+noise(ballColor.yy));\n    p *= vec2(1., 0.75);\n    \n    p.x *= 1. + max(-p.y*28., 0.)*0.2;\n    \n    p.y += 0.25;\n    float noise = fbm(p*12.+gT*2.);\n    float d = max(abs(p.x)-noise*0.06, abs(p.y)-noise*0.20);\n    vec4 colorTemp = mix(vec4(ballColor*0.4+color.rgb*0.6, hash(gT*0.1) * 3.0), color, smoothstep(0., noise*0.15, d));\n    color.rgb = colorTemp.rgb; color.a = max(color.a, colorTemp.a);\n    \n    p.y += -0.05;\n    noise = fbm(p*34.-gT*4.);\n    d = max(abs(p.x)-noise*0.035, abs(p.y)-noise*0.25);\n    colorTemp = mix(vec4(ballColor, hash(gT*0.1) * 3.0), color, smoothstep(0., noise*0.15, d));\n    color.rgb = colorTemp.rgb; color.a = max(color.a, colorTemp.a);\n    \n    // fade by height\n    color = mix(sceneColor, color, smoothstep(-0.3, 0.3+sin(p.y*20. + color.r*10. + gT*4.)*0.25, p.y));\n}\n\nvoid DrawBubbles(vec2 p, vec4 player, inout vec4 color)\n{\n    float angles [4];\n    angles[0] = 0.; angles[1] = PI*0.5; angles[2] = PI; angles[3] = -PI*0.5;\n    \n    if(player.x > 1.5) return;\n    \n    for(int i = 0; i < NUM_BUBBLES; ++i)\n    {\n        vec4 bubble = LoadMem0(txBubble.xy + vec2(float(i), 0.));\n        vec4 bubbleState = LoadMem0(txBubbleState.xy + vec2(float(i), 0.));\n        \n\t\tfloat life = bubbleState.x > 0. ? 1. : 1.-min((iTime - bubbleState.z)/BUBBLE_FADE_OUT_TIME, 1.);\n        vec3 ballExternalColor = vec3(hash(vec2(225.*float(bubbleState.y))),hash(vec2(157.5*float(bubbleState.y)+4.)), hash( vec2(34.*float(bubbleState.y)+102.)));\n        if(life < 1.)\n        {\n            if(life > 0.)\n            {\n        \t\tDrawFireworks(p - bubble.xy, bubbleState.z, 1.-life, float(i), ballExternalColor, color);\n            }\n        }\n        else\n        { \n            vec2 pParticle = p- bubble.xy;\n            vec2 q = pParticle/0.7;\n\n            for(int aidx = 0; aidx < 4; aidx++)\n            {\n                if(bubbleState.y < float(aidx)+0.5)\n                {\n                    q = Rotate2D(q, angles[aidx]);\n                    break;\n                }\n            }\n\n            DrawBallEffect(pParticle, ballExternalColor, color);\n            \n            float d = dArrow(q*1.6);\n            vec4 ballColor = mix(vec4(0., 0., 0., 0.001), vec4(ballExternalColor, 0.001), smoothstep(-0.08, 0.0, d));\n            color = mix(ballColor, color, smoothstep(0., 0.01, d));\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gT  = iTime;\n    gUV = fragCoord/iResolution.xy;\n\n    vec2 p = (fragCoord.xy*2. - iResolution.xy) / iResolution.yy;\n    \n    vec4 prevTexColor = texture(iChannel1, fragCoord/iResolution.xy);\n    float life = prevTexColor.w*255. - iTimeDelta;\n    \n    vec4 color = vec4(0., 0., 0., life);\n    \n    // Load Player Data\n    vec4 player = LoadMem0(txPlayer.xy);\n    DrawBubbles(p, player, color);\n    \n    // Mix with previous color\n    vec3 prevColor = mix(vec3(0.), prevTexColor.rgb, smoothstep(0., 1.0, pow(clamp(life/10., 0., 1.), 1.)));\n    color.rgb += prevTexColor.rgb * pow(clamp(life/10., 0., 1.), 0.14);\n    \n\tfragColor.rgb = color.rgb;\n    fragColor.a = color.a/255.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Reference for sound generation: iq - https://www.shadertoy.com/view/ldXXDj\n\nconst float kMoveSpeed = 0.8;\nconst float gExplosionPosY = 0.30;\nconst float gStartArrowPosY = -1.0;\nconst float gBallRadius = 0.025;\n\nconst float PI = 3.14159;\nconst float PI2 = 6.2831;\nfloat hash(float x) { return fract(cos(x)*10.25); }\nfloat hash2(float x) { return fract(cos(x)*4.50); }\nfloat Explosion(float iTime)\n{\n    float finalWave = 0.;\n    \n    float freq = 0.;\n    float off = 0.;\n    float wave = 0.;\n    float amp = 1.;\n    float t = 0.0;\n    \n    // Phase\n    amp = 1.0; wave = 0.; freq = 25.; t = max(iTime-0., 0.);\n    wave += hash(freq*t); amp *= 0.5; freq *= 1.2;\n    wave += hash(freq*t); amp *= 0.5; freq *= 1.8;\n    wave += hash(freq*t); amp *= 0.5; freq *= 2.2;\n    wave = pow(wave, 2.0);\n    wave *= min(t/0.004, 1.) * exp(-t*5.);\n    finalWave += wave*0.5;\n    \n    // Phase\n    amp = 1.0; wave = 0.; freq = 100.; t = max(iTime-0., 0.);\n    wave += hash2(freq*t); amp *= 0.5; freq *= 1.2;\n    wave += hash2(freq*t); amp *= 0.5; freq *= 1.4;\n    wave += hash2(freq*t); amp *= 0.5; freq *= 1.3;\n    wave = pow(wave, 2.2);\n    wave *= min(t/0.004, 1.) * exp(-t*5.);\n    finalWave += wave;\n    \n    return finalWave;\n}\n\n// main instrument\nfloat instrument( float freq, float time, float presstime)\n{\n    presstime = max(time - presstime, 0.);\n    \n    float ph = 1.0;\n    ph *= sin(6.2831*freq*time);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    \n    float y = 0.0;\n    y += 0.70*sin(1.00*6.2831*freq*time+ph)*exp(-0.5*0.007*freq*presstime);\n    y += 0.20*sin(2.01*6.2831*freq*time+ph)*exp(-0.5*0.011*freq*presstime);\n    y += 0.20*sin(3.01*6.2831*freq*time+ph)*exp(-0.5*0.015*freq*presstime);\n    y += 0.16*sin(4.01*6.2831*freq*time+ph)*exp(-0.5*0.018*freq*presstime);\n    y += 0.13*sin(5.01*6.2831*freq*time+ph)*exp(-0.5*0.021*freq*presstime);\n    y += 0.10*sin(6.01*6.2831*freq*time+ph)*exp(-0.5*0.027*freq*presstime);\n    y += 0.09*sin(8.01*6.2831*freq*time+ph)*exp(-0.5*0.030*freq*presstime);\n    y += 0.07*sin(9.01*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n    \n    y += 0.70*sin(1.00*6.2831*freq*time+ph)*exp(-0.5*0.007*freq*presstime);\n    y += 0.5*sin(PI*0.45+0.50*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n    y += 0.3*sin(PI*0.45+0.250*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n    y += 0.15*sin(PI*0.45+0.1250*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n\n    y += 0.45*y*y*y;\n       \n    y *= 1.0 + 1.5*exp(-8.0);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\n    y *= 2.5-1.5*clamp( log2(freq)/10.0,0.0,1.0);\n    \n    y += Explosion(time)*0.5;\n    \n\treturn y;\t\n}\n\nfloat instrumentLow( float freq, float time, float presstime )\n{\n    freq = 440.0*pow(freq/440.0,1.003); // spread\n    \n    presstime = max(time - presstime, 0.);\n    \n    float ph = 1.0;\n    ph *= sin(6.2831*freq*time);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    //ph *= exp(-presstime*freq*0.2);\n    \n    float y = 0.0;\n    y += 0.70*sin(1.00*6.2831*freq*time+ph)*exp(-0.5*0.007*freq*presstime);\n    y += 0.20*sin(2.01*6.2831*freq*time+ph)*exp(-0.5*0.011*freq*presstime);\n    y += 0.10*sin(6.01*6.2831*freq*time+ph)*exp(-0.5*0.027*freq*presstime);\n    \n    y += 0.70*sin(1.00*6.2831*freq*1.5*time+ph)*exp(-0.5*0.007*freq*presstime);\n    y += 0.5*sin(PI*0.45+0.50*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n    y += 0.3*sin(PI*0.45+0.250*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n    y += 0.15*sin(PI*0.45+0.1250*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*presstime);\n\n    y += 0.45*y*y*y;\n       \n    y *= 1.0 + 1.5*exp(-8.0);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\n    y *= 2.5-1.5*clamp( log2(freq)/10.0,0.0,1.0);\n    y += Explosion(time)*0.5;\n    \n\treturn y;\t\n}\n\n#define N(a, b, c) if(t>sumx) { x=sumx; note = float(b); presstime = float(c); } sumx+=float(a)*2.;\n#define GF(h) 300.0 * pow(kNote, float(h))\n#define tint 0.130\n\nfloat GetTocattaAndFugue(float t);\n\nvec2 mainSound( in int samp, float time )\n{\t\n    float deltaMove = (gExplosionPosY-gBallRadius) - gStartArrowPosY;\n    time = max(time - deltaMove/kMoveSpeed, 0.);\n    float t = time / tint;\n    \n    vec2 y = vec2(0.7,0.7)*GetTocattaAndFugue(t);\n\ty *= 0.05;\n    \n\treturn y;\n}\n\n// note steps\nconst float kNote = pow(2., 1./12.);\n\nfloat GetTocattaAndFugue(float t)\n{\n\tfloat y = 0.0;\n    \n    float x = 0.0;\n    float sumx = 0.0;\n    float note = 0.0;\n    float presstime = 0.0;\n    \n    // Start\n    sumx = 0.0; x = t; presstime = 0.0;\n    //\n    N(1.0,GF(15.),1.) N(1.0,GF(13.),1.) N(9.+4.0,GF(15.),9.0)\n    N(2.,GF(13.),2.) N(1.5,GF(11.),1.5) N(0.5,GF(10.),0.5) N(1.5,GF(8.),0.) N(3.0+2.,GF(7.),3.0)\n\tN(7.0 + 15.,GF(8.),7.)\n\n\t//\n\tN(1.0,GF(7.),1.) N(1.0,GF(5.),1.) N(8.+4.0,GF(7.),8.0)\n\tN(3.0+0.5,GF(4.),3.0) N(2.+0.5,GF(5.), 2.0) N(3.0+1.,GF(1.),3.0)\n\tN(9.0 + 15.,GF(2.),9.)\n\n\t//\n\tN(1.0,GF(-1.),1.) N(1.0,GF(-3.),1.) N(8.+4.0,GF(-1.),8.0)\n\tN(2.,GF(-3.),2.) N(1.5,GF(-5.),1.5) N(0.5,GF(-6.),0.5) N(1.5,GF(-8.),0.) N(3.0+3.,GF(-9.),3.0)\n\tN(8.0 + 10.,GF(-8),8.)\n    y += instrument( note, tint*(t-x), tint*presstime );\n    \n    // First Chord\n    float startEndX = sumx;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(58.0,GF(-8.),58.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX + 8.; x = t; presstime = 0.0;\n    N(25.0,GF(4.),25.) N(25.0,GF(5.),25.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX + 12.; x = t; presstime = 0.0;\n    N(21.0 + 5.0,GF(7.),21.) N(6.0,GF(7.),6.)N(14.0,GF(9.),14.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX + 15.; x = t; presstime = 0.0;\n    N(18.0+5.,GF(10.),18.+5.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX + 18.; x = t; presstime = 0.0;\n    N(15.0,GF(13.),15.)N(25.0,GF(12.),25.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX + 21.; x = t; presstime = 0.0;\n    N(12.0,GF(16.),12.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX + 25.; x = t; presstime = 0.0;\n    N(8.0,GF(19.),8.)N(25.0,GF(17.),25.)\n    y += instrumentLow( note, tint*(t-x), tint*presstime );\n    \n    // \n    startEndX = sumx;\n    sumx = startEndX + 7.; x = t; presstime = 0.0;\n    float baseNote = 16.;\n    N(2.0+1.5,GF(baseNote),2.0) N(2.5,GF(baseNote+1.),2.5) N(1.0,GF(baseNote+3.),1.0) \n    N(1.0+0.5,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.5,GF(baseNote+3.),1.5)\n    N(0.5+0.0,GF(baseNote),0.5) N(1.0,GF(baseNote+1.),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+1.,GF(baseNote+1.),1.5)\n        \n    baseNote = 19.;\n    N(1.5+0.5,GF(baseNote),1.5) N(1.5,GF(baseNote+1.),1.5) N(0.5,GF(baseNote+3.),0.5) \n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+1.),1.0) N(0.5,GF(baseNote+3.),0.5)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+0.5,GF(baseNote+1.),1.5)\n        \n    baseNote = 22.;\n    N(1.+1.0,GF(baseNote),1.0) N(1.5,GF(baseNote+2.),1.5) N(0.5+0.5,GF(baseNote+3.),0.5) \n    N(1.0+0.0,GF(baseNote+2.),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5,GF(baseNote+2.),1.5) N(1.5,GF(baseNote+3.),1.5)\n    N(1.0+0.5,GF(baseNote),1.0) N(7.0,GF(baseNote+2.),7.0)\n    y += instrument( note, tint*(t-x), tint*presstime );\n    \n    startEndX = sumx;\n    sumx = startEndX + 5.; x = t; presstime = 0.0;\n    baseNote = 20.;\n    N(2.0+1.5,GF(baseNote),2.0) N(2.5,GF(baseNote+1.),2.5) N(1.0,GF(baseNote+3.),1.0) \n    N(1.0+0.5,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.5,GF(baseNote+3.),1.5)\n    N(0.5+0.0,GF(baseNote),0.5) N(1.0,GF(baseNote+1.),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+1.,GF(baseNote+1.),1.5)\n        \n    baseNote = 23.;\n    N(1.5+0.5,GF(baseNote),1.5) N(1.5,GF(baseNote+1.),1.5) N(0.5,GF(baseNote+3.),0.5) \n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+1.),1.0) N(0.5,GF(baseNote+3.),0.5)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5,GF(baseNote+1.),1.5) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.5+0.5,GF(baseNote+1.0),1.5)\n        \n    baseNote = 26.;\n    N(1.0+0.5,GF(baseNote),1.0) N(1.5,GF(baseNote+2.0),1.5) N(1.0,GF(baseNote+3.),1.0) \n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+2.0),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.0,GF(baseNote),1.0) N(1.0,GF(baseNote+2.0),1.0) N(1.0,GF(baseNote+3.),1.0)\n    N(1.0+0.5,GF(baseNote),1.0) N(7.0 + 8.0,GF(baseNote+2.0),7.0)\n    y += instrument( note, tint*(t-x), tint*presstime );\n    \n    baseNote = 28.;\n    N(1.5+2.5,GF(baseNote+0.0),1.0)N(2.0,GF(baseNote-2.),2.0)N(1.0,GF(baseNote+1.),1.0)\n    N(1.0+0.0,GF(baseNote-5.0),1.0)N(1.0,GF(baseNote-2.),1.0)N(1.0,GF(baseNote+1.),1.0)\n        \n    baseNote = 23.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.5,GF(baseNote+1.),1.5)N(1.0,GF(baseNote+6.),1.0)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.5,GF(baseNote+1.),1.5)N(1.0,GF(baseNote+6.),1.0)\n        \n    baseNote = 21.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 19.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 17.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(1.0,GF(baseNote+6.),1.0)\n    N(1.0+0.0,GF(baseNote-1.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(0.5,GF(baseNote+6.),0.5)\n        \n    baseNote = 16.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(0.5,GF(baseNote+5.),0.5)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 14.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(1.0,GF(baseNote+5.),1.0)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.5,GF(baseNote+2.),1.5)N(0.5,GF(baseNote+5.),0.25)\n        \n    baseNote = 12.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(1.0,GF(baseNote+5.),1.0)\n    N(1.0+0.0,GF(baseNote-1.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(0.5,GF(baseNote+5.),0.5)\n        \n    baseNote = 10.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(1.0,GF(baseNote+6.),1.0)\n    N(1.0+0.0,GF(baseNote-2.0),1.0)N(1.0,GF(baseNote+1.),1.0)N(1.0,GF(baseNote+6.),1.0)\n        \n    baseNote = 8.;\n    N(1.0+0.0,GF(baseNote+0.0),1.0)N(1.0,GF(baseNote+2.),1.0)N(1.0,GF(baseNote+5.),1.0)\n    N(1.5+0.0,GF(baseNote-1.0),1.5)N(1.0,GF(baseNote+2.),1.0)N(1.5,GF(baseNote+5.),1.5)\n    N(2.0+0.0,GF(baseNote-1.0),2.0)\n    y += instrument( note, tint*(t-x), tint*presstime );\n    \n    startEndX = sumx+2.;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(18.0+0.0,GF(0.0),18.0)\n    y += instrumentLow( note, tint*(t-x), tint*presstime ); // \n    \n    baseNote = 8.;\n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+0.0),12.0)\n   \ty += instrumentLow( note, tint*(t-x), tint*presstime ); // \n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+3.0),12.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); // \n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+6.0),12.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); // \n    \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+9.0),12.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); // \n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+12.0),12.0)        \n    y += instrument( note, tint*(t-x), tint*presstime ); // \n    \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+15.0),12.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); // \n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(12.0+0.0,GF(baseNote+18.0),12.0)        \n    y += instrument( note, tint*(t-x), tint*presstime ); // \n        \n    sumx = startEndX+6.; x = t; presstime = 0.0;\n    N(18.0,GF(baseNote+21.0),18.0) \n    N(3.5,GF(baseNote+20.0),3.5) N(2.5,GF(baseNote+18.0),2.5) N(2.5,GF(baseNote+16.0),2.5)\n    N(1.5,GF(baseNote+15.0),1.5) N(1.,GF(baseNote+13.0),1.) N(1.5,GF(baseNote+12.0),1.5)\n    N(1.0,GF(baseNote+10.0),1.0) N(1.5,GF(baseNote+12.0),1.5)\n    N(3.5,GF(baseNote+8.00),3.5) N(2.5,GF(baseNote+12.0),2.5) N(2.5,GF(baseNote+15.0),2.5)\n    N(2.0+1.0,GF(baseNote+18.0),2.0) N(2.5,GF(baseNote+18.0),2.5) N(1.0,GF(baseNote+16.0),1.0)\n    N(1.0,GF(baseNote+18.0),1.0) N(0.5,GF(baseNote+16.0),0.5) N(0.5,GF(baseNote+18.0),0.5)\n    N(6.0,GF(baseNote+16.0),6.0) N(6.0,GF(baseNote+15.0),6.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); // \n    \n    //\n    startEndX = sumx;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(1.0),15.0)\n    y += instrument( note, tint*(t-x), tint*presstime );\n    \n    sumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+1.0),15.0)\n   \ty += instrument( note, tint*(t-x), tint*presstime );\n    \n\tsumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+4.0),15.0)\n   \ty += instrument( note, tint*(t-x), tint*presstime ); //    \n    \n\tsumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+8.0),15.0)\n   \ty += instrument( note, tint*(t-x), tint*presstime ); //        \n    \n    sumx = startEndX; x = t; presstime = 0.0;\n    N(9.0+0.0,GF(baseNote+13.0),15.0)\n   \ty += instrument( note, tint*(t-x), tint*presstime ); //        \n    \n    sumx = startEndX; x = t; presstime = 0.0;\n    N(15.0+0.0,GF(baseNote+16.0),15.0)\n   \ty += instrument( note, tint*(t-x), tint*presstime ); //   \n    \n    baseNote = 26.;\n    startEndX = sumx+7.;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(1.5+3.0,GF(baseNote+0.0),1.5) N(1.5+1.0,GF(baseNote+3.0),1.5)\n    N(1.5+1.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+5.0),1.5)\n    N(1.5+1.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.5)\n    N(1.0+0.5,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+3.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+5.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+6.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+8.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+5.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+8.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+10.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+8.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+10.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+11.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+8.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+10.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+6.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+8.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+5.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+6.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+3.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+5.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote+2.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(2.0+0.0,GF(baseNote+2.0),2.0)\n    N(1.0+0.5,GF(baseNote+0.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+1.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-2.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote+0.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-4.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-2.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-5.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.5+0.0,GF(baseNote-4.0),1.5)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-6.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-2.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-5.0),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-4.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-7.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-5.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-8.0),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.5+0.0,GF(baseNote-7.0),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-11.),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-10.),1.0)\n    N(1.0+0.0,GF(baseNote+0.0),1.0) N(1.0+0.0,GF(baseNote-13.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-11.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-15.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-13.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-16.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-15.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-17.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-13.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote-15.),1.0)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-14.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-17.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.5+0.0,GF(baseNote-15.),1.5)\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(2.0+0.0,GF(baseNote-13.),2.0)\n    N(2.0+0.0,GF(baseNote+0.0),2.0) N(7.0+0.0,GF(baseNote-12.),7.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); //   \n    \n    //\n    baseNote = 22.;\n    startEndX = sumx+4.;\n    sumx = startEndX+2.5; x = t; presstime = 0.0;\n    N(1.5+0.0,GF(baseNote+0.0),1.5) N(1.0+0.0,GF(baseNote+4.0),1.0) N(1.0+1.0,GF(baseNote+0.0),1.0) //6 (+1)\n    N(1.0+0.0,GF(baseNote-1.0),1.0) N(1.0+0.0,GF(baseNote+3.0),1.0) N(1.0+1.0,GF(baseNote-1.0),1.0) //7 + 3 = 10 (+1)\n    N(1.0+0.0,GF(baseNote-3.0),1.0) N(1.0+0.0,GF(baseNote+1.0),1.0) N(1.0+1.0,GF(baseNote-3.0),1.0) //11 + 3 = 14 +(+1)\n    N(1.0+0.0,GF(baseNote-4.0),1.0) N(1.0+0.0,GF(baseNote-1.0),1.0) N(1.0+1.0,GF(baseNote+3.0),1.0) //15 + 3 = 18\n    y += instrument( note, tint*(t-x), tint*presstime ); //   \n        \n    //\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(4.0+2.0,GF(baseNote-3.0),4.0) N(4.0+0.0,GF(baseNote-5.0),4.0)N(4.0+0.0,GF(baseNote-7.0),4.0)N(4.0+0.0,GF(baseNote-8.0),4.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); //   \n\n    //\n    baseNote = 22.;\n    startEndX = sumx+2.;\n    sumx = startEndX+4.; x = t; presstime = 0.0;\n    N(2.0 + 4.5,GF(baseNote),2.0) N(2.0 + 4.5,GF(baseNote-1.),2.0) N(2.0 + 1.0,GF(baseNote-3.),2.0) N(15.0,GF(baseNote-1.),15.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); //   \n    y += instrumentLow( note*1.2, tint*(t-x), tint*presstime ); //   \n    //\n    baseNote = 18.;\n    sumx = startEndX; x = t; presstime = 0.0;\n    N(6.0 + 0.5,GF(baseNote),6.0)N(6.0 + 0.5,GF(baseNote-4.),6.0)N(6.0 + 1.0,GF(baseNote-3.),6.0)N(15.0,GF(baseNote-1.),15.0)\n    y += instrument( note, tint*(t-x), tint*presstime ); //   \n    y += instrumentLow( note*0.65, tint*(t-x), tint*presstime ); //   \n        \n    return y;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}