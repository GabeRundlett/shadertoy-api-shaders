{
    "Shader": {
        "info": {
            "date": "1593609443",
            "description": "Lots of firsts for me: Underwater, refraction (bubbles), 'god rays', and modelling of a (simple!) stingray.\n\nThanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!",
            "flags": 0,
            "hasliked": 0,
            "id": "WtfyWj",
            "likes": 26,
            "name": "Ocean Treasure",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sea",
                "water",
                "godrays",
                "caustics"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 1206
        },
        "renderpass": [
            {
                "code": "// 'Ocean Treasure'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n#define time (iTime + 37.0)\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRod(vec3 p, float h, float r) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSurface(vec2 p) {\n    float sh = texture(iChannel0, (p + vec2(0.0, 1.0) * (time + 1.0)) * 0.05).r;\n    sh -= texture(iChannel0, (p + vec2(0.7, 0.2) * time) * 0.05).r;\n    return clamp(0.05 + sh * 0.2, 0.0, 1.0);\n}\n\nfloat sdChest(vec3 p) {\n    if (length(p) > 4.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    float w = 1.0;\n    float l = 1.5;\n    float h = 0.6;\n    \n    vec3 pp = p + vec3(0.0, h, 0.0);\n    vec3 bs = vec3(w, h, l);\n    float box = sdBox(pp , bs);\n    float boxInner = sdBox(pp - vec3(0.0, 0.9, 0.0), bs);\n    box = max(box, -boxInner);\n\n    p.xy *= rot(0.2);\n    p.y -= 0.2;\n    float lid = max(max(-p.y, length(p.xy) - w), abs(p.z) - l);\n    \n    float d = min(lid, box) - texture(iChannel0, (p.xz + p.y) * 0.11).r * 0.1;\n    d -= abs(abs(p.z) - l * 0.5) < 0.15 ? 0.07 : 0.0;\n    \n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    float bh = textureLod(iChannel0, p.xz * rot(1.1) * 0.01, 2.5).r * 6.5;\n\t     bh += textureLod(iChannel0, (p.xz + vec2(12.3, 23.4)) * rot(0.5) * 0.02, 0.0).r * 1.2;\n    bh /= 2.5;\n    return p.y + 6.0 - bh;\n}\n\nfloat sdBubble(vec3 p, float t) {\n    float progress = pow(min(fract(t * 0.1) * 4.5, 1.0), 2.0);\n    float maxDepth = 4.2;\n    float depth = maxDepth * (1.0 - progress * progress);\n    float r = mix(0.01, 0.08, progress);\n    \n    float d = 1.2 - smoothstep(0.0, 1.0, min(progress * 5.0, 1.0)) * 0.3;\n    \n    return length(p + vec3(d, depth, -1.0 + 0.2 * progress * sin(progress * 10.0))) - r;\n}\n\nfloat sdPlant(vec3 p, float h) {\n    float r = 0.02 * -(p.y + 2.5) - 0.005 * pow(sin(p.y * 30.0), 2.0);\n    p.z += sin(time + h) * pow(0.2 * (p.y + 5.6), 3.0);\n    return sdRod(p + vec3(0.0, 5.7, 0.0), 3.0 * h, r);\n}\n\nfloat sdPlants(vec3 p) {\n    vec3 dd = vec3(0.2, 0.0, -0.5);\n    \n    // Make multiple copies, each one displaced and rotated.\n    float d = 1e10;\n    for (int i = 0; i < 4; i++) {\n        d = min(d, min(sdPlant(p, 1.2), min(sdPlant(p + dd.xyx, 0.5), sdPlant(p + dd, 0.8))));\n        p.x -= 1.0;\n        p.z -= 1.0;\n        p.xz *= rot(0.6);\n    }\n    \n    return d;\n}\n\nfloat sdManta(vec3 p) {\n    // Translate the origin to the center of the manta.\n    p.xz *= rot(3.141);\n    p.y += 3.5;\n    p.z += 22.0;\n    \n    float t = mod(iTime, 20.0);\n    p.x -= 30.0;\n    p.xz *= rot(-t * 0.07);\n    p.x += 30.0;\n\n    if (length(p) > 3.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    // Flap!\n    p.y -= sin(-time * 1.5) * 0.2;\n    p.y -= (abs(p.x) + 0.1) * sin(abs(p.x) + time * 1.5) * 0.4;\n    \n    // Wings.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 4.0);\n    float d = sdBox(pp, vec3(1.0, 0.015, 1.0));\n    d = smin(d, length(p.xz * vec2(0.5, 1.0)) - 1.18, -0.05); // Nose\n    \n    // Eyes\n    pp = p;\n    if (p.y > 0.0) {\n    \tpp.x = abs(pp.x) - 0.1;\n    \tpp.z -= 0.6;\n    \td = smin(d, length(pp) - 0.1, 0.05);\n    }\n    \n    // Tail.\n    p.z += 1.25;\n    d = smin(d, sdBox(p, vec3(0.005, 0.005, 2.0)), 0.3);\n    \n    return (d - 0.02) * 0.7;\n}\n\nfloat godLight(vec3 p, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 sp = p + lightDir * -p.y;\n\n    float f = 1.0 - clamp(sdSurface(sp.xz) * 10.0, 0.0, 1.0);\n    f *= 1.0 - length(lightDir.xz);\n    return smoothstep(0.2, 1.0, f * 0.7);\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    pp.xz *= rot(-.5);\n    \n    float surface = -p.y - sdSurface(p.xz);\n    float t = time * 0.6;\n    surface += (0.5 + 0.5 * (sin(p.z * 0.2 + t) + sin((p.z + p.x) * 0.1 + t * 2.0))) * 0.4;\n    \n    return min2(vec2(surface, 1.5),\n           min2(vec2(sdChest(pp + vec3(2.0, 4.4, 0.0)), 2.5),\n           min2(vec2(sdFloor(p), 3.5),\n           min2(vec2(sdPlants(p - vec3(6.0, 0.0, 7.0)), 5.5),\n           min2(vec2(sdManta(p), 6.5),\n           min2(vec2(sdBubble(pp, time - 0.3), 4.5),\n                vec2(sdBubble(pp, time), 4.5)))))));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0025;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcOcc(vec3 p, vec3 n) {\n    const float dist = 0.5;\n    return smoothstep(0.0, 1.0, 1.0 - (dist - map(p + n * dist).x));\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nfloat marchGodRay(vec3 ro, vec3 rd, vec3 light, float hitDist) {\n    // March through the scene, accumulating god rays.\n    vec3 p = ro;\n    vec3 st = rd * hitDist / 96.0;\n    float god = 0.0;\n    for (int i = 0; i < 96; i++) {\n        float distFromGodLight = 1.0 - godLight(p, light);\n        god += godLight(p, light);\n        p += st;\n    }\n    \n    god /= 96.0;\n\n    return smoothstep(0.0, 1.0, min(god, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera.\n    vec3 ro = vec3(-0.4, -2.0, -4.0);\n    ro.xz *= rot(0.03 * sin(time * 0.3));\n    ro.y += sin(time * 0.2) * 0.3;\n    vec3 rd = getRayDir(ro, vec3(0.0, -3.0, 0.0), uv);\n\n    // Raymarching loop.\n    int hit = 0; // ID of the object we hit.\n    float d = 0.01; // Ray distance travelled.\n    float maxd = 50.0; // Max ray distance.\n    vec3 p;\n    float outside = 1.0; // Tracks inside/outside of bubble (for refraction)\n    for (float steps = 0.0; steps < 100.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            if (h.y == 4.5) {\n                // Bubble refraction.\n                rd = refract(rd, calcNormal(p) * sign(outside), 1.0);\n                outside *= -1.0;\n                continue;\n            }\n            \n            hit = int(h.y);\n            break;\n        }\n        \n        if (d > maxd)\n            break;\n\n        d += h.x;\n    }\n\n    vec3 deepColor = vec3(0.02, 0.08, 0.2) * 0.1;\n    vec3 lightPos = vec3(1.0, 4.0, 3.0);\n    vec3 col = deepColor;\n    if (hit > 0) {\n        \n        vec3 n = calcNormal(p);\n        vec3 mat = vec3(0.15, 0.25, 0.6);\n        if (hit == 1) {\n            // Sea\n            n.y = -n.y;\n        } else {\n        \tif (hit == 2)\n                mat = mix(mat, vec3(0.2, 0.15, 0.125), 0.5); // Chest\n            else if (hit == 3)\n                mat += vec3(0.1, 0.1, 0.0); // Sand\n        \telse if (hit == 5)\n                mat += vec3(0.0, 0.2, 0.0); // Plant\n        \telse if (hit == 6)\n                mat += vec3(0.5); // Manta\n\n            mat *= 0.4 + 0.6 * godLight(p, lightPos);\n            mat *= calcOcc(p, n); // Ambient occlusion.\n                \n            // Shadows.\n            vec3 lightDir = normalize(lightPos - p);\n\t\t\tfloat sha1 = max(0.0, map(p + lightDir * 0.25).x / 0.25);\n            float sha2 = max(0.0, map(p + lightDir).x);\n            mat *= clamp((sha1 + sha2) * 0.5, 0.0, 1.0);\n        }\n        \n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        \n        float amb = 0.1;\n        float diff = max(0.0, dot(lightToPoint, n));\n\n        col = (amb + diff) * mat;\n    }\n    \n    // Fog.\n    float fog = clamp(pow(d / maxd * 2.0, 1.5), 0.0, 1.0);\n    col = mix(col, deepColor, fog);\n    \n    // God rays.\n    col = mix(col, vec3(0.15, 0.25, 0.3) * 12.0, marchGodRay(ro, rd, lightPos, d));\n    \n    // Output to screen\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}