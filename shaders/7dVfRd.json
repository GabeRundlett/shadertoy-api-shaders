{
    "Shader": {
        "info": {
            "date": "1658933371",
            "description": "Simple 2D render of fast moving shapes/patterns, rendered multiple times to get high quality motion blur and anti-aliasing.\nChange the STYLE define from 1 to 4 to see some nice variations.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dVfRd",
            "likes": 18,
            "name": "Motion Graphics Doodle",
            "published": 3,
            "tags": [
                "motionblur",
                "antialiasing",
                "motiongraphics"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "// choose between a few different presets, or mess with the numbers for a preset to create your own!\n#define STYLE 1\n\n#if STYLE==1\n    // Clean\n    const int SAMPLES_PER_PIXEL = 12;\n    const float PIXEL_SCALE = 1.;\n    const float FPS = 60.;\n    const float SHUTTER_DURATION = 0.7; // relative to 1 frame duration\n    const float DISC_OF_CONFUSION_RADIUS = 1.; // relative to minimum for anti-aliasing\n\n    // subtley blow out red so it feels a tad flourescent\n    const vec3 palette[3] = vec3[](\n            vec3(.8),\n            vec3(3,.12,.1),\n            vec3(.06)\n        );\n#endif\n\n#if STYLE==2\n    // Neon Grunge Stop-motion\n    const int SAMPLES_PER_PIXEL = 12;\n    const float PIXEL_SCALE = 4.;\n    const float FPS = 12.;\n    const float SHUTTER_DURATION = 0.7; // relative to 1 frame duration\n    const float DISC_OF_CONFUSION_RADIUS = 3.; // relative to minimum for anti-aliasing\n\n    // negative + overbright colours for that \"my camera can't handle strong colour\" neon look\n    const vec3 palette[3] = vec3[](\n            vec3(-6,.5,8),\n            vec3(.03,.03,-1),\n            vec3(3,-1,.3)\n        );\n#endif\n\n\n#if STYLE==3\n    // Daylight out of focus\n    const int SAMPLES_PER_PIXEL = 64;\n    const float PIXEL_SCALE = 1.;\n    const float FPS = 60.;\n    const float SHUTTER_DURATION = 0.3; // relative to 1 frame duration\n    #define DISC_OF_CONFUSION_RADIUS iResolution.x*.05\n\n    // subtley blow out red so it feels a tad flourescent\n    const vec3 palette[3] = vec3[](\n            vec3(7,4,2),\n            vec3(.1,.12,.16),\n            vec3(.05,.055,.065)\n        );\n#endif\n\n#if STYLE==4\n    // Video Grunge\n    const int SAMPLES_PER_PIXEL = 30;\n    const float PIXEL_SCALE = 3.;\n    const float FPS = 30.;\n    const float SHUTTER_DURATION = 8.*0.7; // relative to 1 frame duration\n    const float DISC_OF_CONFUSION_RADIUS = 8.; // relative to minimum for anti-aliasing\n\n    // negative + overbright colours for that \"my camera can't handle strong colour\" neon look\n    const vec3 palette[3] = vec3[](\n            vec3(.2,1,-2),\n            vec3(0,-1,2),\n            vec3(3,.2,-1)\n        );\n#endif\n\nvec3 quasirandomFactor3 = vec3(0.8191725,0.6710436,0.5497005);\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nvec2 UVAnimation( in vec2 uv, in float time )\n{\n    float time2 = time*.3;\n    float a = (floor(time2)+smoothstep(.0,.2,fract(time2))) * .618*6.283;\n    uv = uv*cos(a) + uv.yx*vec2(1,-1)*sin(a);\n    uv += (time*vec2(5,2) + sin(time)*vec2(2,3))*4.;\n    return uv;\n}\n\nvec3 animation( in vec2 fragCoord, in float time )\n{\n    vec2 screenUV = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    screenUV *= exp2(2.6+.6*sin(time*.2));\n    \n    screenUV *= PIXEL_SCALE; // delete this to make PIXEL_SCALE actually zoom\n\n    vec2 uv = UVAnimation(screenUV,time);\n\n//    vec2 check = fract(uv)-.5; return mix( vec3(.3,0,.1), vec3(.5,1,.2), step(0.,check.x*check.y) );\n\n    vec2 cameraFloor = UVAnimation(vec2(0),time);\n    float gridStep = 1.41;\n    vec2 gridFloor = floor(uv/gridStep);\n    vec2 gridFrac = abs(fract(uv/gridStep)-.5)*2.;\n    \n    float thresh = 1.*smoothstep(14.,0.,length(gridFloor*gridStep-1.5-cameraFloor));\n    \n    float gridChecker = float((int(gridFloor.x)^int(gridFloor.y))&1);\n\n    vec3 colour = mix(\n            palette[0], palette[1],\n            \n            // different patterns:\n            //step( max(gridFrac.x,gridFrac.y), thresh )\n            //step( length(gridFrac), thresh*1.41 )\n            step( (1.-mix( thresh, max(thresh*2.-.2,thresh), gridChecker ))*1.41, length(gridFrac) )\n            //step( gridFrac.x+gridFrac.y, thresh*2. )\n        );\n\n\n// I'd like a pattern with some features of different sizes, and different colours - more like motion graphics\n// e.g. maybe a rectangle that lags behind the scroll but follows the rotation\n\n    vec2 rectPos = UVAnimation(vec2(0), time-.5)+vec2(7,0);\n//    vec2 rectUV = uv-rectPos;\n    vec2 rectUV = UVAnimation(screenUV,time-.3)-rectPos;\n    vec2 rectUV1 = abs(rectUV+vec2(1,0)) - vec2(5,1.2);\n    vec2 rectUV2 = abs(rectUV+vec2(0,1)) - vec2(1.2,5);\n    colour = mix( colour,\n            palette[2],\n            max(max(\n                step(abs(min(min(max(rectUV1.x,rectUV1.y),length(rectUV-vec2(4,0))-1.2),length(rectUV-vec2(-3.5,-3.5))-1.))-.1,.0),\n                step(max(rectUV2.x,rectUV2.y),.0) ),\n                step(length(rectUV-vec2(0,5.8)),1.4)\n            )\n        );\n    \n    return colour;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // zoom so I can look at aa\n    fragCoord = floor(fragCoord/PIXEL_SCALE+iResolution.xy*(.5-.5/PIXEL_SCALE));\n\n    float time = floor(iTime*FPS)/FPS;\n\n    fragColour.rgb = animation(fragCoord,iTime);\n\n    int sampleCount = SAMPLES_PER_PIXEL;\n    fragColour.rgb = vec3(0);\n    for ( int tap=0; tap < sampleCount; tap++ )\n    {\n        float idx = float(tap)+dot(vec3(time*FPS,fragCoord),quasirandomFactor3);\n        vec3 jitter = fract( idx * quasirandomFactor3 ); // quasirandom sequence\n\n        // break up regularity\n        // adapted from http://extremelearning.com.au/a-simple-method-to-construct-isotropic-quasirandom-blue-noise-point-sequences/\n        jitter = fract( jitter + hash3(coord1(uint(idx*256.))) * 0.238  / sqrt(float(sampleCount)) );        \n\n        jitter = jitter.yxz; // tweak order to reduce patterned artefacts\n\n        // disc of confusion not perfect pixel\n        float discRadius = 0.7071 * DISC_OF_CONFUSION_RADIUS;\n        jitter.x *= 6.283185;\n        jitter.y = sqrt(jitter.y);\n        //jitter.y *= smoothstep(0.,1.,jitter.y); discRadius *= 2.; // softer look\n        jitter.xy = vec2(cos(jitter.x),sin(jitter.x))*jitter.y*discRadius;\n        \n        fragColour.rgb += animation(fragCoord+jitter.xy,time+jitter.z*SHUTTER_DURATION/FPS);\n    }\n    fragColour.rgb /= float(sampleCount);\n    \n//fragColour.rgb = .5+.5*cos(vec3(.9,1.9,3.9)*6.283*fragColour.g);\n    \n/*    // tone mapping - squash bright colours so they never quite hit 1\n    const float whitePointSoftening = .1;\n    float brightness = dot(fragColour.rgb,vec3(0.21,0.72,0.07));\n    float toneMapped = mix( brightness, 1.-length(vec2(1.-brightness,whitePointSoftening))), .5 );\n    //fragColour.rgb *= toneMapped/max(brightness,.001); // per overall brightness\n    fragColour.rgb = mix( fragColour.rgb, 1.-sqrt((1.-fragColour.rgb)*(1.-fragColour.rgb) + whitePointSoftening*whitePointSoftening)), .5 ); // per component\n*/\n    \n    // linear to sRGB\n    fragColour.rgb = mix( fragColour.rgb*12.92, 1.055*pow(fragColour.rgb,vec3(1./2.4))-.055, step(.0031308,fragColour.rgb) );\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}