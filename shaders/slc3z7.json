{
    "Shader": {
        "info": {
            "date": "1635873616",
            "description": "Same but different, wasn't really inspired.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "slc3z7",
            "likes": 9,
            "name": "[Inercia 2021] Le Royal Cheater ",
            "published": 3,
            "tags": [
                "shaderroyale"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 320
        },
        "renderpass": [
            {
                "code": "/******\nThanks the Shader Showdown Scene folks for all the fun ! \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n\n\n\n# \n    This is the first scripted shader showdown / royale entry.\n    It was 'coded' live before the event, the bonzomatic network message has been recoreded via a script, \n    and then was replayed step by step thanks to another script and the bonzomatic network\n    during the Intercia 2021 Shader Royale\n#\n\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box2(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n     return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n  }\n \nvec2 sdf(vec3 p){\n  p.y -=.2;\n    p.xy *=rot(-.785*.5);\n  float bump = fract(iTime);\n  vec2 h;\n  vec3 hp = p;\n  hp.y -=1.;\n  hp.x +=1.;\n  h.x =  max(abs(hp.z)-.1-bump,box2(hp.xy,vec2(.5)));\n  h.y = 1.;\n  \n  vec2 t;\n  vec3 tp = p;\n  tp.x +=1.;\n  tp.y +=1.;\n  t.x =  max(abs(tp.z)-.1-bump,box2(tp.xy,vec2(.5,1.)));\n  t.y = 1.;\n  \n  h = t.x < h.x ? t:h;\n  \n  tp = p;\n  tp.y+=.3;\n  tp.x +=.1;\n  t.x = max(abs(tp.z)-.1-bump,length(tp.xy)-1.75);\n  t.x = max(-tp.x+.1,t.x);\n  \n  float tt  = max(abs(tp.z)-.2-bump,length(tp.xy)-1.);\n  tt = max(-tp.x,tt);\n  t.x= max(-tt,t.x);\n  t.y = 2.;\n  \n    h = t.x < h.x ? t:h;\n  return h;\n  }\n#define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nfloat diam2(vec2 p,float s){\n    p = abs(p);\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\nvec3 txt(vec2 uv){\n  uv*=4.;\n  uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.1415;\n  uv.x -=iTime;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n     vec3 col = vec3(.8,.2,.2);\n  if(mod(id.x,2.)==0.){\n       uv*=4.;\n       uv.y +=iTime;\n       uv = fract(uv)-.5;\n    col = vec3(.2,.8,.2);\n    }\n  float d = diam2(uv,.2);\n  d=  mix(d,abs(d)-.01,asin(sin(uv.x+uv.y))); // NOT SQUIDGAME \n  d=  smoothstep(1.7*fwidth(d),0.,d);\n \n  return .5*col*d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = txt(uv);\n  \n  vec3 ro = vec3(sin(iTime),0.,-5.);\n  vec3 rt = vec3(0.);\n  vec3 rp = ro;\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  float time = mod(iTime,10.);\nfor(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n     \n     \n     if(time < 5. && length(rp-vec3(.25,.1,.0)) >.6 ) acc += (d.y ==1. ? vec3(.2,.9,.2):vec3(.9,.2,.2))*exp(-abs(d.x))/(50.-min(40.,fract(iTime)*50.));\n     if(time < 5. &&  fract(iTime+ length(rp)*.5)<0.5){  d.x = max(.001,abs(d.x));}\n    \n    if(d.x <.0001){\n        vec3 n = norm(rp,.001);\n        vec3 nn = norm(rp,.01);\n        float diff = max(0.,dot(normalize(light-rp),n));\n        float spc = max(0.,dot(normalize(light-ro),reflect(-normalize(light),n)));\n      spc  = pow(spc,32.);\n        if(d.y == 1.){\n             col = vec3(.2,.9,.2)*diff;\n        }  else {\n             col = vec3(.9,.2,.2)*diff;\n          \n          }\n         col = time < 5. ?col : mix(col, col*step(.2,length(nn-n)),floor(asin(sin(rp.y+iTime)*.5)*10.)*.5+.5);\n         col +=spc*vec3(1.);\n      break;\n      }\n      rp +=rd*d.x;\n  \n  }  \n  col +=acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}