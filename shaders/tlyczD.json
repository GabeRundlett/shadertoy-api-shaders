{
    "Shader": {
        "info": {
            "date": "1610587587",
            "description": "LoicVDB and I are making volumetric Path-Tracers.",
            "flags": 32,
            "hasliked": 0,
            "id": "tlyczD",
            "likes": 28,
            "name": "Spectral Volumetric Path-Tracing",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "volumetric",
                "pathtrace",
                "trace",
                "path",
                "spectral"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 825
        },
        "renderpass": [
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// Common is for settings and some functions\n// Buffer A is for rendering\n// Buffer B is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor\n// This is for drawing the shader on the left (or above if you are in portrait mode)\n\n// Spectral Volumetric Path Tracing by Zi7ar21 --- January 13th, 2020\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n\n// Adjustable settings (Feel free to change these!)\n#define maxsteps 8192\n#define stepsize 0.01\n#define camerafov 1.0\n\n// Constants (I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Spectral colors, from https://www.shadertoy.com/view/ls2Bz1\n// Alan Zucconi\nfloat saturate(float x){return min(1.0, max(0.0, x));}\nvec3 saturate(vec3 x){return min(vec3(1.0, 1.0, 1.0), max(vec3(0.0, 0.0, 0.0), x));}\nvec3 bump3y (vec3 x, vec3 yoffset){\n\tvec3 y = vec3(1.0, 1.0, 1.0)-x*x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectralzucconi6(float w){\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w-400.0)/300.0);\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\treturn bump3y(c1*(x-x1), y1)+bump3y(c2*(x-x2), y2);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n\n// 4D Julia set Distance Estimator\nvec4 qsqr(vec4 a){return vec4(a.x*a.x-a.y*a.y-a.z*a.z-a.w*a.w, 2.0*a.x*a.y, 2.0*a.x*a.z, 2.0*a.x*a.w);}\nfloat distanceestimator(vec3 pos, float wavelength){\n\tvec4 z = vec4(pos, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    for(int i = 0; i < 8; i++){\n        md2 *= 4.0*mz2;\n        //z = qsqr(z)+vec4(-0.5, 0.35, 0.5, ((wavelength-400.0)/600.0));\n        z = qsqr(z)+vec4(-0.5, 0.35, 0.5, 0.0);\n        mz2 = dot(z,z);\n        if(mz2 > 4.0) break;}\n    return 0.25*sqrt(mz2/md2)*log(mz2);}\n\n/*float distanceestimator(vec3 pathposition, float wavelength){\n    return distance(pathposition, vec3(0.0))-0.5;\n}*/\n\n// 3D Volumetric Density Function\nfloat densityfunction(vec3 pathposition, float wavelength){\n    float distanceestimation = distanceestimator(pathposition, wavelength);\n    if(distanceestimation < 0.0){return 50.0;}\n    else{return 0.05;}\n}\n\n// Light Collision Checker\nbool light(vec3 pathposition){\n    if(distance(pathposition, vec3(pathposition.x/2.0, 2.0, pathposition.z/2.0))-1.0 < 0.0){return true;}\n    else{return false;}\n}\n\n// Path-Tracing\nfloat pathtrace(vec3 pathdirection, vec3 cameraposition, float wavelength){\n    float density, absorbance, distancetravelled;\n    vec3 pathposition = cameraposition+(pathdirection)+(pathdirection*stepsize*2.0*(rand()-0.5));\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathposition, wavelength)/pow(wavelength/500.0, 4.0);\n        absorbance = exp(-density*stepsize);\n        if(absorbance*1.25 < rand()){return 0.0;}\n        if(absorbance < rand()){pathdirection = normalize(nrand3(1.0, vec3(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(light(pathposition)){return 8.0;}\n        if(distance(pathposition, vec3(0.0)) > 4.0 || distancetravelled > 100.0){break;}\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = oldFragColor;\n    INIT_RNG;\n    vec2 uv = ((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/iResolution.x;\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 pathdirection = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n    float wavelength = (rand()*300.0)+400.0;\n    float pathtraced = pathtrace(pathdirection, vec3(0.0, 0.0, -4.0), wavelength);\n    vec3 col = pathtraced*spectralzucconi6(wavelength);\n    fragColor += vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}