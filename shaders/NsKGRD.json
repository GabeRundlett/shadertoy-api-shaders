{
    "Shader": {
        "info": {
            "date": "1631195450",
            "description": "this is just a fork, i keep destorying the other shader, and i should keep it as backup",
            "flags": 96,
            "hasliked": 0,
            "id": "NsKGRD",
            "likes": 9,
            "name": "Fork Islands in Arrangemon 275",
            "published": 3,
            "tags": [
                "terrain",
                "water",
                "islands"
            ],
            "usePreview": 0,
            "username": "Arrangemonk",
            "viewed": 732
        },
        "renderpass": [
            {
                "code": "\n// Created by Arrangemonk 2021, arrangemonk@gmail.com\n// where i have a clear source i added shadertoy link\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(-0.5,-0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 29281,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/extandnb/meteor?in=royaltyfreemusic-nocopyrightmusic/sets/creative-commons-music"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//https://www.shadertoy.com/view/XttyRX\n#define tau 6.28318530718\n#define pi 3.141592653589\n\n#define tile_factor .25\n#define noise_factor 0.03\n#define textureGammaOffset 2.\n#define heightMapResolution iChannelResolution[0]\n#define normalStrength 10.0\n//#define steadycam\n\nfloat DrawDistance = 100.0;\nfloat DrawDistanceFract = 0.01;\nfloat angle = 0.0;\nfloat time;\nfloat waterline = 2.9;\nfloat raymarchIterations =120.;\n\n \n\nvec3 skytop= vec3(0.459,0.749,1.05);\nvec3 skybottom = vec3(1.1,0.533,0.000);\n\nvec4 textureGamma(in sampler2D tex,in vec2 uv)\n{\n    return pow(texture(tex,uv),vec4(2.2));\n}\n\nvec4 textureGamma(in sampler3D tex,in vec3 uvw)\n{\n    return pow(texture(tex,uvw),vec4(2.2));\n}\n\n\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)*.5;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)*.5;\n}\n\n\nfloat Mask(float x){\n    x= x -.5;\n    return .5+sign(.5*(.25 -x*x))*.5;\n}\n\nvec3 rampBiome(float inx)\n{   \n    inx = clamp(inx,.0001,.9999);\n    float x = 2.* inx * inx;\n     vec3 col = (.4 + .4*cos((1.-x)*vec3(4,2,1)))*Mask(x) \n     + (.4 + .4*cos((x-1.)*vec3(2,1.25,2)))*Mask(x-1.);\n     col = mix(vec3(.4,.7,.6),mix(col, col*col,.5)*2.,.5);\n     return col;\n}\n \n vec3 rampSky(float x){\n     vec3 col = mix(skybottom,skytop,x*1.2);\n     col *= col * 1.1+ .4;\n    return col;\n}\n\nvec3 target(in vec3 origin,in vec3 direction,in float distance)\n    {\n        return origin + (direction * distance);\n    }\n\n\n//foam from https://www.shadertoy.com/view/ldj3Dm\nvec3 foam (vec2 uv,sampler2D iChannel2,sampler2D iChannel3,vec3 col,float proximity)\n{\n\tfloat sur = texture( iChannel3,  0.05 * uv ).x;\n\tsur = smoothstep( 0.4, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, uv * 0.25 ).x);\n    sur = sur * sur * 5.;\n\n    return mix( col, vec3(1.0),  sur);\n}\n\n\n// rand func from theartofcode (youtube channel)\nvec2 rand01(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.5, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    \n    return fract (vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat circ(vec2 uv, vec2 pos, float r) {\n    return smoothstep(r, 0., length(uv - pos));\n}\n\nfloat smoothFract(float x, float blurLevel) {\n\treturn pow(cos01(x), 1./blurLevel);\n}\n\nfloat manDist(vec2 from, vec2 to) {\n    return abs(from.x - to.x) + abs(from.y - to.y);\n}\n\n\nfloat distFn(vec2 from, vec2 to) {\n\tfloat x = length (from - to);\n    return pow (x, 4.);\n}\n\nfloat voronoi(vec2 uv, float t, float seed, float size) {\n    \n    float minDist = 100.;\n    \n    float gridSize = size;\n    \n    vec2 cellUv = fract(uv * gridSize) - 0.5;\n    vec2 cellCoord = floor(uv * gridSize);\n    \n    for (float x = -1.; x <= 1.; ++ x) {\n        for (float y = -1.; y <= 1.; ++ y) {\n            vec2 cellOffset = vec2(x,y);\n            \n            // Random 0-1 for each cell\n            vec2 rand01Cell = rand01(cellOffset + cellCoord + seed);\n\t\t\t\n            // Get position of point\n            vec2 point = cellOffset + sin(rand01Cell * (t+10.)) * .5;\n            \n\t\t\t// Get distance between pixel and point\n            float dist = distFn(cellUv, point);\n    \t\tminDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\n\nvec3 fbm8(in vec2 uv,sampler2D tex)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult -= texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult -= texture(tex,uv*  8.).rgb /  8.;\nresult += texture(tex,uv* 16.).rgb / 16.;\nresult -= texture(tex,uv* 32.).rgb / 32.;\nresult += texture(tex,uv* 64.).rgb / 64.;\nresult -= texture(tex,uv*128.).rgb /128.;\nreturn result;\n}\n\nvec3 fbm6(in vec2 uv,sampler2D tex)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult -= texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult -= texture(tex,uv*  8.).rgb /  8.;\nresult += texture(tex,uv* 16.).rgb / 16.;\nresult -= texture(tex,uv* 32.).rgb / 32.;\nreturn result;\n}\n\nvec3 fbm4(in vec2 uv,sampler2D tex)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult -= texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult -= texture(tex,uv*  8.).rgb /  8.;\nreturn result;\n}\n\nvec3 color( in vec2 uv,float height,sampler2D tex)\n{ \n    vec3 biome =rampBiome(height*0.25 + textureGamma(tex,uv *3.).x *.2)+vec3(.1,.15,.1);\n    vec3 stuff = .2 +texture(tex,uv * .125).rgb;\n    return mix(biome,stuff,.40);\n\n}\n\n\n    //https://www.shadertoy.com/view/4sXXRj\nvec3 waterripple(vec2 uv, sampler2D tex,float iTime)\n    {\n\tvec2 p = uv * vec2(-1.0, -2.0);\n    \n    \tfloat t = iTime/300.0;\n\t\n\t\tvec2 waterCoord = vec2(p.x, 1.0-uv.y);\n\t\tvec2 texCoordNormal0 = waterCoord * tile_factor;\n\t\ttexCoordNormal0 += t ;\n\t\t\n\t\tvec2 texCoordNormal1 = waterCoord * tile_factor;\n\t\ttexCoordNormal1.s -= t ;\n\t\ttexCoordNormal1.t += t ;\n\t\t\n\t\tvec3 normal0 = texture(tex, texCoordNormal0).rgb * 2.0 - 1.0;\n\t\tvec3 normal1 = texture(tex, texCoordNormal1).rgb * 2.0 - 1.0;\n\t\treturn normalize(normal0 + normal1);\n    }\n    \n    \nfloat height(in vec2 uv,sampler2D heightmap,float time)\n    {\n        float result = (1.-fbm6(uv*0.005,heightmap).x)*5. -1.6;\n        result = (result - waterline);\n        result = mix(result,result * abs(result),.2);\n        return result + waterline;\n    }\n    \nfloat wheight(in vec2 uv,sampler2D heightmap,float time)\n    {\n        return waterline -waterripple(uv*0.03,heightmap,time).x;\n    }\n    \n   \n    \n//lost link, most likely iqs doing\nfloat RayMarch(vec3 origin,vec3 direction,sampler2D hmap,float time, out bool result)\n{\n    float t = 0.;\n    for (float i = 0.; i < raymarchIterations; i+=1.)\n    {\n        vec3 rp = target(origin,direction,t);\n        float h = rp.y - (height(rp.xz,hmap,time));\n        if (abs(h) < (.00001 * t) || t > DrawDistance) break;\n        t += h;\n    }\n    result = t < DrawDistance;\n    return t;\n}\n\nfloat wRayMarch(vec3 origin,vec3 direction,sampler2D hmap,float time, out bool result)\n{\n    float t = 0.;\n    for (float i = 0.; i < raymarchIterations; i+=1.)\n    {\n        vec3 rp = target(origin,direction,t);\n        float h = rp.y - (wheight(rp.xz,hmap,time));\n        if (abs(h) < (.0015 * t) || t > DrawDistance) break;\n        t += h;\n    }\n    result = t < DrawDistance;\n    return t;\n}\n    \n//https://www.shadertoy.com/view/3sSSW1\nvec3 texNormalMap(in vec2 uv,float scale,sampler2D h,float time)\n{ \n    float p  = height(uv,h,time);\n    float h1 = height(uv + vec2(scale,0),h,time);\n    float v1 = height(uv +  vec2(0,scale),h,time);\n       \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1)) * normalStrength;\n    \n    return normalize(vec3(normal, 1.));\n}\n\n//https://www.shadertoy.com/view/3sSSW1\nvec3 wtexNormalMap(in vec2 uv,float scale,sampler2D wh,float time)\n{ \n    float p  = wheight(uv,wh,time);\n    float h1 = wheight(uv + vec2(scale,0),wh,time);\n    float v1 = wheight(uv +  vec2(0,scale),wh,time);\n       \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1))*0.5;\n    \n    return normalize(vec3(normal, 1.));\n}\n\n    \nmat2 rotationMatrix(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\nfloat caustics(vec2 uv,float time)\n{\n    float t = time * .35;\n    \n    float amplitude = .12;\n    float turbulence = .5;\n    vec2 uva = uv.xy + sin01(uv.x*turbulence + t) * amplitude;\n    uva.xy -= cos01(uv.y*turbulence + t) * amplitude;\n    vec2 uvb = uv.xy + sin01(uv.x*turbulence + t*1.3-2.) * amplitude * 0.7;\n    uvb.xy -= cos01(uv.y*turbulence + t*1.-2.3) * amplitude * 0.7;\n    uvb = uvb * rotationMatrix(1.04);\n    vec2 uvc = uv.xy + sin01(uv.x*turbulence + t*1.4 + 3.) * amplitude * 0.3;\n    uvc.xy -= cos01(uv.y*turbulence + t*1.4 + 3.) * amplitude * 0.3;\n    uvc = uvc * rotationMatrix(2.08);\n    \n    float v;\n    v += voronoi(uva, t * 2., 0.5, 2.5)/2.;\n    v += voronoi(uvb, t * 3., 0., 3.) / 2.;\n    v += voronoi(uvc, t * 4., 0., 4.) / 2.;\n    \n    return v;\n}\n\nfloat caustics3D( in vec3 p, in vec3 n ,float time){\n   \n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n    \n    \treturn (caustics(p.yz,time)*n.x + caustics( p.zx,time)*n.y + caustics(p.xy,time)*n.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Created by Arrangemonk 2021, arrangemonk@gmail.com\n// where i have a clear source i added shadertoy link\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sunDir =      normalize(vec3(0.,0.6, -1.));\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 uvx= vec2((1.- 2. * uv.x) * aspect + sin(time * 0.1)*0.2+sin(time *3.)*.01,-1. + 2. * uv.y-0.6+sin(time *3.)*.01);\n    \n    vec3 rd = normalize(vec3(uvx, -3.0));\n    vec3 ro = vec3(sin(time * 0.1)*3.+sin(time *3.)*.01,5.+sin(time *5.)*.009, -time+sin(time *4.)*.011);\n    #ifdef steadycam\n    ro = vec3(0.,5.+sin(time *5.)*.009,10.8 +sin(time *4.)*.011);\n    #endif\n\n    bool result;\n    float distance = RayMarch(ro,rd,iChannel0,time,result);\n    float distfract = clamp(distance*DrawDistanceFract,0.,1.);\n    \n     vec3 c = rampSky((uv.y-0.4)*1.1);\n     \n \n     if(result)\n     {\n         vec3 point = target(ro,rd,distance);\n         float h = height(point.xz,iChannel0,time);\n         float waterheight = wheight(point.xz,iChannel0,time);\n         if(h < waterheight)\n         {\n            distance = wRayMarch(ro,rd,iChannel0,time,result);\n            distfract = clamp(distance*DrawDistanceFract,0.,1.);\n            vec3 point = target(ro,rd,distance);\n            h = wheight(point.xz,iChannel0,time);\n            \n            vec3 waternormal = wtexNormalMap(point.xz,1.,iChannel3,time);\n            //vec3 waternormal = normalize(waterripple(point.xz * 0.02 + distance * 0.002,iChannel3,iTime) + vec3(0,0,2.+ (distfract * distfract) * 10.));\n            vec3 wd = refract(rd,waternormal, .97);\n            vec3 wr = normalize(reflect(rd,waternormal));\n             float wdistance = RayMarch(point,wd,iChannel0,time,result);\n             float wdistfract = clamp(wdistance*DrawDistanceFract,0.,1.);\n             vec3 wp = target(point,wd,wdistance);\n             float wheight =  height(wp.xz,iChannel0,time)-0.1;\n             \n             float reflectdist = RayMarch(point,reflect(rd,mix(wr,vec3(0.,1.,0.),0.99)),iChannel0,time,result);\n             \n             float hilight = 0.;\n             if(!result){\n                 hilight = clamp((dot(wr,waternormal)/(abs(uvx.x)+.2) * 0.5 + 0.5)* distance *0.02,0.,1.);\n                 }\n             vec3 skyreflect = rampSky(1.1 - texture(iChannel2,-wr).x* 0.6);\n             skyreflect = mix(skyreflect,texture(iChannel2,wr).xyz,.5);\n             \n             float wsun = dot( texNormalMap(wp.xz,1.,iChannel0,time), sunDir);\n             wsun += dot( texNormalMap(wp.xz,0.25,iChannel0,time), sunDir )*2.;\n             wsun += dot( texNormalMap(wp.xz,0.02,iChannel0,time), sunDir )*4.,\n             wsun *= 0.143;\n             wsun = clamp( wsun, 0.0, 1.0 )-0.6;\n             float absorbtion = mix(2.9-(wdistfract*25.),wheight,.5);\n             \n             float cst = caustics3D(wp ,texNormalMap(wp.xz,1.,iChannel0,time),time*3.5)*0.1* absorbtion; // * clamp(wdistance,0.,1.)*clamp(wp.y/3.,0.,1.);\n             \n             vec3 c1 = mix(color(wp.xz,absorbtion,iChannel1) + wsun,skyreflect,hilight) +cst;\n       \n             c = mix(c1,c,distfract);\n             c = foam(point.xz + waternormal.xy *0.15,iChannel3,iChannel1,c,h-wheight);\n         }\n         else{\n         vec3 normal =texNormalMap(point.xz,1.,iChannel0,time);\n         vec3 normal2 =texNormalMap(point.xz,0.25,iChannel0,time);\n          vec3 normal3 = texNormalMap(point.xz,0.02,iChannel0,time);\n        \n         \n             float sun = dot( normal, sunDir);\n             sun += dot( normal2, sunDir )*2.;\n             sun += dot( normal3, sunDir )*4.,\n             sun *= 0.143;\n             sun = clamp( sun, 0.0, 1.0 )-0.6;\n             c = mix(color(point.xz,h,iChannel1) + sun,c,distfract);\n             c = mix(c+ vec3(0.08,0.06,0.04),c,distfract);\n         }\n     }else\n     {\n     c += vec3(1.2,1.1,1.)*0.5 * (1.0-smoothstep(length( uvx* vec2(.5,1.) +vec2(0.,0.05)),0.0,0.01)/ 0.9);\n     }\n    fragColor = vec4(c,distfract);\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(0.5,0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(0.5,-0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(-0.5,0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}