{
    "Shader": {
        "info": {
            "date": "1634240924",
            "description": "Look around with mouse drag and move with WASD.",
            "flags": 48,
            "hasliked": 0,
            "id": "ssyXRz",
            "likes": 2,
            "name": "Computer Graphics assignment 1",
            "published": 3,
            "tags": [
                "sdf",
                "camera",
                "spheretracing"
            ],
            "usePreview": 0,
            "username": "Borisz42",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const int k = 4;\n    fragColor = vec4(0);\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\n//Primitives begin\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//Primitives end\n\n//Rotations begin\nvec3 rotX(vec3 z, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(z.x, c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvec3 rotY(vec3 z, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c*z.x - s*z.z, z.y, c*z.z + s*z.x);\n}\nvec3 rotZ(vec3 z, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c*z.x + s*z.y, c*z.y - s*z.x, z.z);\n}\n//Rotations end\n\nfloat sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    float head = sdSphere(p-vec3(0,12,0), 2.);\n    float g = sdBox(p,vec3(4,1,4));\n    float body = sdVerticalCapsule(p, 9.2, 0.8);\n    float torus = sdTorus(p-vec3(0,14.5,0), vec2(1.5,0.1));\n    float arms= sdCappedTorus(rotY(p-vec3(0,6,0), pi/2.), vec2(sin(1.7),cos(1.7)), 3., 0.7);\n    \n    float hornl = sdSphere(p-vec3(0,13.5,1.8), 1.);\n    float p1 = sdPlane(p-vec3(0,13.5,1.8), normalize(vec3(0,1,-1)), 0.);\n    hornl = max(hornl, p1);\n    \n    float hornr = sdSphere(p-vec3(0,13.5,-1.8), 1.);\n    float p2 = sdPlane(p-vec3(0,13.5,-1.8), normalize(vec3(0,1,1)), 0.);\n    hornr = max(hornr, p2);\n    \n    float eyel = sdSphere(p-vec3(-2,12,0.8), 0.5);\n    head = max(head,-eyel);\n    float eyer = sdSphere(p-vec3(-2,12,-0.8), 0.5);\n    head = max(head,-eyer);\n    \n    float mouth = sdSphere(p-vec3(-2,11.4,0), 0.95);\n    float mouthneg = sdSphere(p-vec3(-2,11.9,0), 1.);\n    mouth = max(mouth, -mouthneg);\n    head = max(head,-mouth);\n    \n    float frame = sdBoxFrame(p, vec3(4,16,4), 0.15);    \n    \n    float minDist = min(head, g);        \n    minDist = min(minDist, body);\n    minDist = min(minDist, torus);\n    minDist = min(minDist, arms);\n    minDist = min(minDist, hornl);\n    minDist = min(minDist, hornr);\n    minDist = min(minDist, frame);\n    minDist = min(minDist, p.y+1.);\n    return minDist;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    vec4 col = vec4(0.7, 0.7, 0.9, 1.0) - max(ray.V.y,0.0);\n    return vec4( clamp(col,0.0,1.0) );\n    //return vec4(texture(iChannel2, ray.V).xyz,1.); //eredeti\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    \n        //light1 bengin\n        vec3 lightPos=rotY(vec3(10.,10.*(sin(iTime*0.7)+1.1),10.), iTime*0.7+pi);\n    \n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = vec3(1./pi);\n    \n    //specular\n    vec3 k_s = vec3(0.4);\n    \n    vec3 h = normalize(l+v);\n    float si = pow(clamp(dot(h,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    //light1 end\n    \n        //light2 begin\n        vec3 lightPos2=rotY(vec3(10.,10.*(sin(iTime*0.7+pi)+1.1),10.), iTime*0.7);\n    \n    vec3 l2 = normalize(lightPos2-p);\n    \n    //diffuse\n    float costheta2 = max(dot(n,l2),0.);\n    vec3 k_d2 = vec3(1./pi);\n    \n    //specular\n    vec3 k_s2 = vec3(0.4);\n    \n    vec3 h2 = normalize(l2+v);\n    float si2 = pow(clamp(dot(h2,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col2 = (k_d2 + si2*k_s2)*costheta2;\n    //light2 end\n    \n        //light3 begin\n        vec3 lightPos3=rotY(vec3(100.,30.,0.), iTime*0.1);\n    \n    vec3 l3 = normalize(lightPos3-p);\n    \n    //diffuse\n    float costheta3 = max(dot(n,l3),0.);\n    vec3 k_d3 = vec3(1./pi);\n    \n    //specular\n    vec3 k_s3 = vec3(0.4);\n    \n    vec3 h3 = normalize(l3+v);\n    float si3 = pow(clamp(dot(h3,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col3 = (k_d3 + si3*k_s3)*costheta3;\n    //light3 end\n    \n    \n    return vec4(col+col2/1.+col3/1.,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-30.,10.,3.);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.001, 256);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n   // else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n    vec3 prevcol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    float lambda = 0.3;\n    fragColor.rgb = (1.-lambda)*fragColor.rgb + lambda*prevcol;\n\n    fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}