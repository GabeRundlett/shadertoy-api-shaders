{
    "Shader": {
        "info": {
            "date": "1485252542",
            "description": "Using cylindrical coordinates to construct a steel-plated tunnel with an industrial feel.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tKXzV",
            "likes": 69,
            "name": "Industrial Tunnel",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "bump",
                "polar",
                "cylindrical"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 6090
        },
        "renderpass": [
            {
                "code": "/*\n\n\tIndustrial Tunnel\n\t-----------------\n\n\tUsing repeat cylindrical coordinates (polar plus Z) to construct a steel-plated tunnel \n\twith an industrial feel. I think I've mentioned it before, but I never quite appreciate \n\tjust how well Dr2's examples run until I try to construct a scene with a fraction of the \n\tdetail... then watch the FPS counter plummet. :)\n\n\tMy fastest machine pushes this scene out with ease. However, my slowest machine didn't\n\tfare as well. I'd set myself a limit of 40 FPS, but could only manage 30 FPS... for now, \n\tanyway. I could get to 40 FPS, but would really have to mess the code up, so I've left \n\tit alone. Obviously, the key to faster scenes is insuring that the distance function is \n\teasy to hone-in on and involves fewer instructions. Unfortunately, that's not so easy to \n\tachieve when adding more detail. On top of that, my slow machine isn't a fan of the \"atan\"\n\tfunction, which is pretty difficult to avoid when doing angular-based calculations.\n\n\tThe scene itself is very loosely based on a section of the Greenwich pedestrian tunnel. \n\tThe lighting is not very realistic, but works well enough. The scene relies on a heavy \n\tcurvature setting to give it a quasi hand painted look. Anyway, I'd like to put up a \n\tsimpler abstract geometric version at some stage that'll be easier to read, and\n\thopefully, faster.\n\n\n\t// Other examples:\n\n\t// Cylindrical-coordinate-based tunnel. I've seen it pop up in many forms on the net.\n\tTunnel #1 -  WAHa_06x36\n\thttps://www.shadertoy.com/view/4dfGDr\n\n\t// Great example making use of polar coordinates. Really stylish and great atmosphere.\n\tMetro Tunnel - fb39ca4\n\thttps://www.shadertoy.com/view/ldsGRS\n\n\t// Very cool. Amazingly detailed for a shader.\n\tGotthard Tunnel - dr2\n    https://www.shadertoy.com/view/MlSXRR\n\t\n\t\n\n*/\n\n// Maximum ray distance.\n#define FAR 50. \n\n// Comment this out to omit the detailing. Basically, the bump mapping won't be included.\n#define SHOW_DETAILS\n\n// Object ID, used for the gold trimming in the bump mapping section.\nfloat svObjID;\nfloat objID;\n\n#define TUN 0. // Tunnel: Basically, the metal plates.\n#define FLR 1. // Floor:  Concrete curbs and underflooring.\n#define MTL 2. // Metal:  The metallic mesh and the light casings.\n#define LGT 3. // Lights: The lights attached to the top mesh.\n#define BLT 4. // Bolts:  The hexagonal bolts.\n#define PIP 5. // Pipes:  The cyclinders beside the lights.\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Layered noise.\nfloat fBm(vec3 p){ \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; \n    //return n3D(p)*.5333 + n3D(p*2.)*.2667 + n3D(p*4.)*.1333 + n3D(p*8.)*.0667; \n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    // return vec3(0, 0, t); // Straight path.\n    \n    // Curvy path. Weaving around the columns.\n    float a = sin(t*3.14159265/16. + 1.5707963*1.);\n    float b = cos(t*3.14159265/16.);\n    \n    return vec3(a*2., b*a, t);    \n}\n\n// Minimum - with corresponding object ID.\nvec2 objMin(vec2 a, vec2 b){ \n    \n    // Returning the minimum distance along with the ID of the\n    // object. This is one way to do it. There are others.\n    \n    //Equivalent to: return a.x < b.x ? a: b; \n    float s = step(a.x, b.x);\n    return s*a + (1. - s)*b;\n}\n\n// The tunnel scene. There's a bit of code, but it's nothing more than a bunch of boxes\n// and cylinders spread out around some repeat cylindrical coordinates.\nfloat map(vec3 p){\n    \n    const float depth = .1; // Depth of the rounded metal plates.\n    \n    // Mold the scene around the path.\n    p.xy -= camPath(p.z).xy;\n    \n    // The edge of the tunnel. Set at a radius of one, plus the depth.\n    float tun = (1. + depth) - length(p.xy); \n    \n    //////////////\n    \n    // The concrete floor. Just a plane, with a circular chunk cut out. It gives it\n    // a curb-like appearance.\n    float flr = p.y + .695;\n    flr = max(flr, tun - depth - .1);\n    \n    ///////////////\n    \n    // The tunnel walls. Due to the amount of detailing and the polar conversion, it \n    // looks more complicated than it actually is. To repeat across the XY plane we\n    // do something along the lines of \"p.xz = mod(p.xz, c) - c/2.\" To repeat around\n    // a circle in the XY plane, we convert to polar coordinates, \"p.xy = rot(angle),\"\n    // (angle is based on \"atan(p.y, p.x),\" then do the same thing. The rest is basic\n    // unit circle trigonometry, etc. By the way, this is a rough description, so if\n    // something doesn't quite make sense, it probably doesn't. :)\n    \n    // Converting the XY plane to polar coordinates. I'm handling the panels (six per\n    // circle) and the bolts (18 per circle) at the same time to share some calculations.\n    // I'd love to use the geometry of one to constuct the other - in order to save\n    // some instructions, but I'm leaving it alone for now.\n    vec3 q = p; \n    vec3 q2 = p;    \n    \n    float a = atan(q.y, q.x)/6.2831853; // Polar angle of \"p.xy\" coordinate.\n    float ia = (floor(a*6.) + .5)/6.*6.2831853; // Angle between \"PI/6\" intervals.\n    float ia2 = (floor(a*18.) + .5)/18.*6.2831853; // Angle between \"PI/18\" intervals.\n    \n     // Polar conversion for 6 segments, but offset every second panel... and shifted\n    // to the center-cell position (see the Z-repetition).\n    q.xy *= rot(ia + sign(mod(q.z + .25, 1.) - .5)*3.14159/18.);\n    q2.xy *= rot(ia2); // Polar conversion for 18 segments (for the bolts).\n   \n    // The X-coordinate is now the radial coordinate, which radiates from the center\n    // to infinity. We want to break it into cells that are 2 units wide, but centered\n    // in the middle. The result is that the panels will start at radius one.\n    q.x = mod(q.x, 2.) - 1.;\n    // Plain old linear Z repetion. We want the panels and bolts to be repeated in the\n    // Z-direction (down the tunnel) every half unit.\n    q.z = mod(q.z, .5) - .25; \n    \n    // Moving the bolts out to a distance of 2.1.\n    q2.x = mod(q2.x, (2. + depth)) - (2. + depth)/2.;\n    \n    // Now, it's just a case of drawing an positioning some basic shapes. Boxes and\n    // tubes with a hexagonal cross-section.\n    q = abs(q);\n    q2 = abs(q2);\n\n    // Bolts. Hexagon shapes spaced out eighteen times around the tunnel walls. The \n    // panels are spaced out in sixths, so that means three per panel.\n    float blt = max(max(q2.x*.866025 + q2.y*.5, q2.y) - .02, q.z - .08);\n\n    \n    // Putting in some extra rails where the mesh and curb meets the tunnel. The extra\n    // code is fiddly (not to mention, slows things down), but it makes the structure\n    // look a little neater.\n    q2 = p;\n    q2.xy *= rot(ia - sign(p.x)*3.14159/18.);\n    q2 = abs(q2);\n    \n    // Lines and gaps on the tunnel to give the illusion of metal plating.\n    float tunDetail = max(min(min(q.y - .06, q.z - .06), max(q2.y - .06, p.y)), \n                          -min(min(q.y - .01, q.z - .01), max(q2.y - .01, p.y))); \n \n    // Adding the tunnel details (with a circular center taken out) to the tunnel.\n    tun = min(tun, max(tunDetail, tun-depth));  \n    \n    ///////////////\n    \n    // The metalic mesh elements and light casings. The lights are calculated in this\n    // block too.\n        // The metalic mesh elements and light casings. The lights are calculated in this\n    // block too.\n       \n    q = abs(p);    \n    float mtl = max(q.x - .14, abs(p.y - .88) - .02);  // Top mesh.\n    mtl = min(mtl, max(q.x - .396, abs(p.y + .82) - .02)); // Bottom mesh.//.81\n    \n    q.z = abs(mod(p.z, 2.) - 1.);\n    \n    float lgt = max(max(q.x - .07, q.z - .07), abs(p.y - 1.) - .255);\n    float casings = max(max(q.x - .1, q.z - .1), abs(p.y - 1.) - .23);\n    \n    q.xz = abs(mod(q.xz, 1./8.) - .5/8.);\n    \n    mtl = max(mtl, -max(max(q.x - .045, q.z - .045), abs(abs(p.x) - .19) - .14)); // Holes in the mesh.\n    mtl = min(mtl, casings ); // Add the light casings to the top mesh.\n    \n    /*\n    // Alternative mesh setup with smaller holes. I like it more, but Moire patterns are a problem\n    // with smaller window sizes.\n    q = abs(p);    \n    float mtl = max(q.x - .13, abs(p.y - .88) - .02);  // Top mesh.\n    mtl = min(mtl, max(q.x - .396, abs(p.y + .82) - .02)); // Bottom mesh.//.81\n    \n    q.z = abs(mod(p.z, 2.) - 1.);\n    \n    float lgt = max(max(q.x - .07, q.z - .07), abs(p.y - 1.) - .255);\n    float casings = max(max(q.x - .1, q.z - .1), abs(p.y - 1.) - .23);\n    \n    q.xz = abs(mod(q.xz, 1./16.) - .5/16.);\n    \n    mtl = max(mtl, -max(max(q.x - .025, q.z - .025), abs(abs(p.x) - .19) - .155)); // Holes in the mesh.\n    mtl = min(mtl, casings ); // Add the light casings to the top mesh.\n    */    \n    ///////////////\n    \n    // Pipes. Electricity... water? Not sure what their function is, but I figured I \n    // should slow the distance function down even more, so put some in. :)\n    q = p;\n    const float th = 6.283/18.;\n    float sx = sign(p.x);\n    float pip = length(q.xy - vec2(sx*sin(th*1.4), cos(th*1.4))*1.05) - .015;\n    pip = min(pip, length(q.xy - vec2(sx*sin(th*1.6), cos(th*1.6))*1.05) - .015);\n    \n    ///////////////\n    \n    // Determine the overall closest object and its corresponding object ID. There's a way\n    // to save some cycles and take the object-ID calculations out of the distance function, \n    // but I'm leaving them here for simplicity.\n    vec2 d = objMin(vec2(tun, TUN), vec2(blt, BLT));\n    d = objMin(d, vec2(mtl, MTL));\n    d = objMin(d, vec2(lgt, LGT));\n    d = objMin(d, vec2(flr, FLR));\n\td = objMin(d, vec2(pip, PIP));\n    \n    ///////////////\n    \n    \n    objID = d.y; // Set the global object ID.\n    \n    return d.x; // Return the closest distance.\n    \n    \n}\n\n\n// Raymarching.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n\n    p.xy -= camPath(p.z).xy;\n\n    // Adding a bit of functional noise variations to the\n    // concrete floor and the tunnel. Not a great deal of \n    // effort went into it.\n    float res = 0.;\n    if(svObjID==FLR) {\n        p.xy *= 16.;\n        res = n3D(p*4.)*.66 + n3D(p*8.)*.34;\n        res = 1.-abs(res - .75)/.75;\n    }\n    else if(svObjID==TUN){\n        //res = fBm(p*16.);\n        res = n3D(p*16.)*.66 + n3D(p*32.)*.34;\n    }\n    \n    \n    // Subtle metal bump. More thought needs to be put into it. :)\n    if(svObjID==MTL){\n        \n        p.xz = abs(mod(p.xz + 1./8.,  1./8.) - .5/8.);\n        res = max(p.x, p.z) - .25/8.;\n        \n        res = max(res*8., 0.);\n        \n        //res = 1. - smoothstep(0., .5, res);    \n        \n    }\n    \n     \n    \n    return res; // Range: [0, 1].\n   \n}\n\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpFunction(p);                 \n    vec3 grad = (vec3(bumpFunction(p - e.xyy),\n                      bumpFunction(p - e.yxy),\n                      bumpFunction(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n// The normal function with some curvature rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float crv, float ef){ \n\t//ef/iResolution.y\n    vec2 e = vec2(ef/450., 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p);\t// The hit point itself - Doubled to cut down on calculations. See below.\n    \n    // Seven-tap curvature calculation. You can get away with four taps, but this is a little\n    // more accurate.\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*6.)*32. + .5, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.002, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 2.;\n    vec3 ro = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    \n    vec3 lk = camPath(iTime*speed + .5);  // \"Look At\" position.\n    //ro.y -= .1; // Hack to lower the camera.\n    //lk.y -= .1;\n    \n    vec3 lp = camPath(iTime*speed + 2.25); // Light position, somewhere near the moving camera.\n    lp.y += .6;\n    // Alternative. Moving the light to the right a bit. \n    //float th = 6.283*1./12.;\n    //lp += vec3(sin(th)*.6, cos(th)*.6, 0); \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    // Mild lens distortion to fit more of the scene in, and to mix things up a little.\n    vec3 rd = fwd + FOV*(u.x*rgt + u.y*up);\n    rd = normalize(vec3(rd.xy, (rd.z - length(rd.xy)*.3)*.7));\n    \n    // Swiveling the camera from left to right when turning corners.\n    float swivel = camPath(lk.z).x;\n    rd.xy = rot(swivel/48. )*rd.xy;\n    rd.xz = rot(swivel/16. )*rd.xz;\n \n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    svObjID = objID;\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Offset path. Only used for one thing here, but it's handy to have an\n    // adjusted hit point that aligns with the path contour.\n    vec3 pathSp = sp - camPath(sp.z);\n    \n    \n    // Normal with curvature component.\n    float crv = 1., ef = 12.; // ef - Edge and curvature factor.\n    vec3 sn = nr(sp, crv, ef);\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    lp -= sp;\n    float lDist = max(length(lp), .0001);\n    lp /= lDist;\n    \n    // Attenuation.\n    float atten = 1./(1.0 + lDist*.25 + lDist*lDist*.025);\n    \n    // Texturing the object.\n    const float tSize0 = 1./2.;\n    vec3 tx = tex3D(iChannel0, sp*tSize0, sn);\n    tx = smoothstep(0., .5, tx);\n\n    // Ugly \"if\" statements for object coloring. They do the job though. \n\tif(svObjID==BLT || svObjID==PIP) tx *= vec3(1.25, 1, .75);\n    else if(svObjID==TUN) tx *= vec3(1., .4, .2);    \n    else if(svObjID==MTL) tx *= vec3(1.1, .8, .7);\n    else if(svObjID==FLR) tx *= vec3(1.5, .78, .62);\n    else if(svObjID==LGT) tx *= vec3(5, 4, 3); // Really bright for fake glow.\n        \n        \n    // More fake lighting. This was just a bit of trial-and-error to produce some repetitive,\n    // slightly overhead, spotlights throughout the space. Cylinder in XY, sine repeat\n    // in the Z direction over three rows... Something like that. I tried to code in some\n    // flickering, but in the end, decided working lights were better. :)\n    \n    float spot = max(2. - length(pathSp.xy - vec2(0, 1.)), 0.)*(cos((sp.z + 1.)*3.14159)*.5+.5);\n    spot = smoothstep(0.5, 1., spot); \n    //float flicker = smoothstep(-1., -.9, sin(iTime*1. + hash(floor(sp.z/2.))*6.283));\n    //float flicker = sin(iTime*8. + hash(floor(sp.z/2.))*6.283)*.2 + 1.;\n    //spot *= flicker;\n    //tx += (tx)*spot*2.;\n\n\n   \n    // Function bump.\n    #ifdef SHOW_DETAILS\n    float bf =.005;\n    if(svObjID==FLR || svObjID==MTL) bf = .02;\n    sn = doBumpMap(sp, sn, bf/(1. + t/FAR));\n    // tx *= bumpFunction(sp)*.75 + .25; // Accentuates the bump, but not needed here.\n    #endif\n    \n    // Texture-based bump mapping.\n    float tbf = .03;\n    if(svObjID==LGT) tbf = .0;\n    sn = texBump(iChannel0, sp*tSize0*2., sn, tbf);\n \n    // Adding a bit of mold build-up to the scene. Very hacky, and in need of a tweak, but it works well enough.\n    float slm = fBm(sp*4.);\n    float slf = 1.;  // Slime factor.\n    if(svObjID!=TUN && svObjID!=FLR) slf = .75;\n    tx = mix(vec3(1), vec3(.25, .6, .2), (slm*.75 + .25)*slf)*tx; //\n    tx = mix(vec3(1), vec3(.25, .4, .15)*.1, (1.-abs(slm - .5)*2.)*.75*slf)*tx;\n \n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(lp, sn), 0.);\n    float spe = pow(max(dot(reflect(-lp, sn), -rd), 0.), 32.);\n    float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 2.);\n\n    \n     \n    // Combining the terms above to produce the final color.\n    vec3 fc = tx*(dif + .125 + vec3(1, .8, .5)*fre*8. + vec3(1, .9, .7)*spot*4.) + vec3(1, .7, .5)*spe*1.;\n    fc *= atten*sh*ao*clamp(crv*1.5, 0., 1.);\n    \n \n    //fc = mix(vec3(1), vec3(.25, 1, .15)*.2, slm*.75)*fc; // More mold.\n \n    \n    // Mixing in some fog.\n    vec3 bg = vec3(.4, .35, .3);\n    fc = mix(fc, bg, smoothstep(0., .95, t/FAR));\n    \n    \n    // Post processing.\n    //float gr = dot(fc, vec3(.299, .587, .114));\n    //fc = fc*.5 + pow(min(vec3(1.5, 1, 1)*gr, 1.), vec3(1, 3, 16))*.5;\n    \n     // Approximate gamma correction.\n\tfragColor = vec4(sqrt(clamp(fc, 0., 1.)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}