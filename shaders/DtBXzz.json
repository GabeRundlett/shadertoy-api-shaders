{
    "Shader": {
        "info": {
            "date": "1675971108",
            "description": "\"Showcase of different lighting models\" or simply: \"Remembering good old stuff\".",
            "flags": 0,
            "hasliked": 0,
            "id": "DtBXzz",
            "likes": 9,
            "name": "Lighting models showcase",
            "published": 3,
            "tags": [
                "raymarching",
                "lighting",
                "lightingmodels"
            ],
            "usePreview": 0,
            "username": "VPaltoDance",
            "viewed": 221
        },
        "renderpass": [
            {
                "code": "//------------------------------------------------------------------------\n// This shader is designed to showcase different lighting models.\n// The user can change the lighting and material parameters which include ambient lighting, light direction, light color, material color\n// and others to see, how they impact the lighting in each case. Some lighting models have their own parameters, that can be modified.\n// By using this shader, you can gain a deeper understanding of how lighting works in computer graphics and how to implement different lighting \n// models in your own shaders.\n//------------------------------------------------------------------------\n// References:\n//\n// 1. https://www.shadertoy.com/view/ldfSWs by iq was used as a starting project.\n// 2. \"Computer Graphics From Pixels to Programmable Graphics Hardware\" by Brian A. Barsky was used as a hint for recalling lighting models.\n// 3. https://learnopengl.com/PBR/Lighting helped me to recall BRDF related stuff.\n\n\n\n\n// Lighting macros\n#define BACKGROUND_COLOR vec3(0.0, 0.0125, 0.025)\n#define LIGHT_COLOR vec3(0.5, 0.5, 0.5)\n#define DIFFUSE_COLOR vec3(0.5, 0.0, 0.0)\n#define SPECULAR_COLOR vec3(0.5, 0.33, 0.157)\n\n// Material macros\n#define METALNESS 0.8\n#define ROUGHNESS 0.25\n#define SHINESS 16.0\n\n// Constant macros\n#define PI  3.1415926\n#define EXP 2.7182818284\n\n#define RM_MAX_DISTANCE 20.0\n#define RM_DISTANCE_EPS 0.01\n#define RM_MAX_ITER 64\n\n#define SAT(x) clamp(x, 0.0, 1.0)\n\n// Buffers for passing arguments to lighting functions. Makes code more clean and orgnized\n\n// Buffer with data for lighting calculations\nstruct LightBuffer\n{\n    vec3 worldPos;\n    vec3 normal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec3 viewDir;\n    vec3 lightDir;\n    vec3 lightCol;\n    vec3 halfVec;\n    float lambert;\n};\n\n// Buffer with data for material properties of the rendered object\nstruct MaterialBuffer\n{\n    vec3 diffuse;\n    vec3 specular;\n    float roughness;\n    float metalness;\n    float shiness;\n};\n\n// Signed distance field for our object\nfloat sphereSDF(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\n// Function for setting cmera properties\nvoid fillCameraData(out vec3 camPos, out vec3 camLookAt)\n{\n    camPos = vec3(0.0, 0.0, 5.0);\n    camLookAt = vec3(0.0, 0.0, 0.0);\n}\n\n// Function for setting environment properties\nvec3 backgroundColor(vec2 uv)\n{\n    return BACKGROUND_COLOR*(1.0-0.2*length(uv));\n}\n\n// Main ray marching function\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tconst float maxd = 20.0;           \n    float t = 0.0;\n    \n    for( int i = 0; i < RM_MAX_ITER; i++ )          \n    {\n\t    float d = sphereSDF( rayOrigin+rayDir*t, 1.0);\n        if(d < RM_DISTANCE_EPS || t > RM_MAX_DISTANCE) break;  \n        t += d;\n    }\n    return t < RM_MAX_DISTANCE ? t : -1.0;\n}\n\n// Function for filling material buffer data\nMaterialBuffer fillMaterialData()\n{\n    MaterialBuffer mb;\n\n    mb.diffuse = DIFFUSE_COLOR;\n    mb.specular = SPECULAR_COLOR;\n    mb.roughness = ROUGHNESS;\n    mb.metalness = METALNESS;\n    mb.shiness = SHINESS;\n    \n    return mb;\n}\n\n// Filling main geometry properties needed for lighting calculations\nLightBuffer fillLightData(vec3 worldPos, vec3 rayDir)\n{\n    LightBuffer lb;\n    \n    lb.worldPos = worldPos;\n    lb.normal = normalize(worldPos);  // Straightforward way to find normals to a sphere centered at the origin\n    \n    // Calculating tangent and bitangent (needed for some lighting models)\n    if (lb.normal == vec3(0.0, 1.0, 0.0))\n        lb.tangent = vec3(1.0, 0.0, 0.0);\n     else\n        lb.tangent = normalize(cross(vec3(0.0, 1.0, 0.0), lb.normal)); \n    lb.bitangent = normalize(cross(lb.normal, lb.tangent));\n    \n    lb.viewDir = -rayDir;  // We need direction from the pixel to the camera.\n    lb.lightDir = normalize(vec3(sin(iTime), 1.0, cos(iTime)));  // Rotating the light direction around y axis\n    lb.halfVec = normalize(lb.viewDir + lb.lightDir);  // Half vector calculation as it is needed in most of the algorithms\n    lb.lightCol = LIGHT_COLOR;\n    lb.lambert = max(0.0, dot(lb.normal, lb.lightDir));  // Calculation of lambert term\n    \n    return lb;\n}\n\n// Functions for calculating fresnel term\n// It is the ratio of how much the surface reflects vs how much it refracts based on some parameter cosTheta\n// F0 is a parameter, that shows the minimum amount of light, that could be reflected by the object\n// Or \"surface reflection at zero incidence\" (means, when cosTheta is one)\n\nvec3 fresnelSchlick3(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(SAT(1.0 - cosTheta), 5.0);\n}  \n\nfloat fresnelSchlick1(float cosTheta, float F0)\n{\n    return F0 + (1.0 - F0) * pow(SAT(1.0 - cosTheta), 5.0);\n}  \n\n//------------------------------------------------------------------------\n// Blinn-Phong model\n//------------------------------------------------------------------------\nvec3 blinnPhong(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Nothing fancy, using lambert ndotl for diffuse term and halfvec approximation for specular term\n    float diff = lightBuff.lambert;\n    float spec = pow(max(dot(lightBuff.normal, lightBuff.halfVec), 0.0), matBuff.shiness);\n    spec = diff > 0.0 ? spec : 0.0;  // One of possible ways to restrict specular light on the shadowed side of the object\n    \n    return matBuff.diffuse * diff + matBuff.specular * spec;\n}\n\n\n//------------------------------------------------------------------------\n// Phong model\n//------------------------------------------------------------------------\nvec3 phong(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Nothing fancy, using lambert ndotl for diffuse term and reflected view direction approximation for specular term\n    vec3 r = reflect(-lightBuff.viewDir, lightBuff.normal);\n    float diff = lightBuff.lambert;\n    float spec = pow(max(dot(lightBuff.lightDir, r), 0.0), matBuff.shiness);\n    \n    return matBuff.diffuse * diff + matBuff.specular * spec;\n}\n\n//------------------------------------------------------------------------\n// Cook-Torrance model\n//------------------------------------------------------------------------\nvec3 cookTorrance(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Based on the empirical observation, that roughness squared gives a better look\n    float a = matBuff.roughness * matBuff.roughness;\n    \n    // Calculating dot pproducts\n    float nDotH = max(dot (lightBuff.normal, lightBuff.halfVec), 0.0);\n    float vDotH = max(dot (lightBuff.viewDir, lightBuff.halfVec), 0.0);\n    float nDotV = max(dot (lightBuff.normal, lightBuff.viewDir) , 0.0);\n    float nDotH2 = nDotH * nDotH;\n    \n    // Surface reflection of the object at zero incidence depends on its' metalness parameter\n    vec3 F0 = vec3(0.04); // if the object is pure dielectric - its' F0 is simply 0.04\n    F0 = mix(F0, matBuff.specular, matBuff.metalness);\n    vec3 F = fresnelSchlick3(nDotV, F0);\n    \n    // Here we use the Beckmann distribution function for calculating microfacets' alignment term\n    float power = - (1.0 - nDotH2) / (nDotH2 * a);\n    float BDF = pow (EXP, power) / (a * nDotH2 * nDotH2);\n    \n    // Geometrical attenuation factor\n    float c = 2.0 * nDotH / vDotH;\n    float G = min (1.0, min (c * nDotV, c * lightBuff.lambert));\n    \n    vec3 specBRDF   = F*BDF*G / (PI * nDotV * lightBuff.lambert);  // Combining the terms to get our specular BRDF term\n\n    float  diff = lightBuff.lambert;  // The diffuse BRDF term is immortal lambert\n    vec3  spec = max (vec3(0.0), specBRDF);\n\n    return matBuff.diffuse * diff + matBuff.specular * spec;\n}\n\n//------------------------------------------------------------------------\n// Oren–Nayar model\n//------------------------------------------------------------------------\n\n// We start with functions for computing main coefficients in the Oren–Nayar formula\nfloat computeA(float roughness)\n{\n    float rsqr = roughness * roughness;\n    return 1.0 - 0.5 * rsqr / (rsqr + 0.33);\n}\n\nfloat computeB(float roughness)\n{\n    float rsqr = roughness * roughness;\n    return 0.45 * rsqr / (rsqr + 0.09);\n}\n\n// The actual model function\nvec3 orenNayar(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Computing coefficients\n    float A = computeA(0.5);\n    float B = computeB(0.5);\n    \n    // Computing dot staff\n    float nDotL = dot(lightBuff.normal, lightBuff.lightDir);\n    float nDotV = dot(lightBuff.normal, lightBuff.viewDir);\n    \n    // Projecting vectors on the plane, that is tangent to the current surface point\n    // D - direction, S - surface, P - projection\n    vec3  lightDSP = normalize ( lightBuff.lightDir - lightBuff.normal * nDotL );\n    vec3  viewDSP = normalize ( lightBuff.viewDir - lightBuff.normal * nDotV );\n    \n    // Find cos between projections\n    float projCos    = max(dot(lightDSP, viewDSP), 0.0);\n    \n    // Calculating trigonometry for the formula\n    float cosAlpha = max(nDotL, nDotV);\n    float cosBeta  = min(nDotL, nDotV);\n    float sinAlpha = 1.0 - cosAlpha * cosAlpha;\n    float sinBeta = 1.0 - cosBeta * cosBeta;\n    float sinTan = sqrt (sinAlpha * sinBeta) / cosBeta;\n    \n    float diff = lightBuff.lambert * (A + B * projCos * sinTan);\n\n    return matBuff.diffuse * diff;\n\n}\n\n//------------------------------------------------------------------------\n// Minnaert model\n//------------------------------------------------------------------------\n\n// Coefficients needed for the formula\n#define mnrt_K 1.0  \n\nvec3 minnaert(LightBuffer lightBuff, MaterialBuffer matBuff)\n{   \n    // Nothing fancy, just following the formula\n    float nDotV = max(dot(lightBuff.normal, lightBuff.viewDir), 0.0);\n    float minnaert = pow(lightBuff.lambert, 1.0 + mnrt_K ) * pow(1.0 - nDotV, 1.0 - mnrt_K );\n\n    return matBuff.diffuse * minnaert;\n}\n\n//------------------------------------------------------------------------\n// Ashikhmin-Shirley model\n//------------------------------------------------------------------------\n#define as_DIFF 2.0  // Should be 28.0 / (23.0 * PI)\n#define as_PU 15.5\n#define as_PV 15.5\n\nfloat computeC()\n{\n    return sqrt((as_PU + 1.0) * (as_PV + 1.0)) / (8.0 * PI);\n}\n\nvec3 ashikhminShirley(LightBuffer lightBuff, MaterialBuffer matBuff)\n{    \n    // Computing the dots\n    float ndotV = max(0.0, dot (lightBuff.normal, lightBuff.viewDir ) );\n    float ndotH = max(0.0, dot (lightBuff.normal, lightBuff.halfVec ) );\n    float hDotL = max(0.0, dot (lightBuff.halfVec, lightBuff.lightDir ) );\n    float hDotV = max(0.0, dot (lightBuff.halfVec, lightBuff.viewDir ) );\n    float bDotH = dot(lightBuff.bitangent, lightBuff.halfVec);\n    float tDotH = dot(lightBuff.tangent, lightBuff.halfVec);\n\n    float C = computeC();  // Calculating main coefficient\n    \n    vec3 F0 = vec3(0.04); // If the object is pure dielectric - its' F0 is simply 0.04\n    F0 = mix(F0, matBuff.specular, matBuff.metalness);\n    vec3 F = fresnelSchlick3(hDotL, F0);  // Calculating the fresnel\n    \n    // Diffuse term\n    vec3 diff = as_DIFF * ( vec3(1.0) - F0) * ( 1.0 - pow ( 1.0 - 0.5*ndotV, 5.0 ) ) * \n                ( 1.0 - pow (1.0 - 0.5 * lightBuff.lambert, 5.0) );\n\t\n    // Specular term\n    float B  = pow ( ndotH, (as_PU * bDotH * bDotH + as_PV * tDotH * tDotH)/(1.0 - ndotH * ndotH) );\n    float denom = hDotV * max(ndotV, lightBuff.lambert);\n    vec3 spec = C * B * F / denom;\n\n    return lightBuff.lambert * (matBuff.diffuse  * diff + matBuff.specular * spec );\n}\n\n\n//------------------------------------------------------------------------\n// Lommel-Seeliger model\n//------------------------------------------------------------------------\nvec3 lommelSeeliger(LightBuffer lightBuff, MaterialBuffer matBuff)\n{    \n    // Another diffuse-only model, that came from astronomy\n\tfloat denom = lightBuff.lambert + max(0.0, dot(lightBuff.normal, lightBuff.viewDir));\n\treturn matBuff.diffuse * lightBuff.lambert / denom;\n}\n\n\n//------------------------------------------------------------------------\n// Strauss model\n//------------------------------------------------------------------------\n\n#define\tstr_K  0.1\n#define\tstr_Kf 1.12\n#define\tstr_Ks 1.01\n\n// Strauss model defines its' own fresnel\nfloat strFresnel ( float x, float kf )\n{\n\tfloat\tdx  = x - kf;\n\tfloat\td1 = 1.0 - kf;\n\tfloat\tkf2 = kf * kf;\n\t\n    return (1.0 / (dx * dx) - 1.0 / kf2) / \n            (1.0 / (d1 * d1) - 1.0 / kf2 );\n}\n\nfloat strShadow ( float x, float ks )\n{\n\n\tfloat\tdx  = x - ks;\n\tfloat\td1 = 1.0 - ks;\n\tfloat\tks2 = ks * ks;\n\t\n\treturn (1.0 / (dx * dx) - 1.0 / ks2) / (1.0 / (d1 * d1) - 1.0 / ks2 );\n}\n\nvec3 strauss(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Smoothness is opposite to roughness\n    float smoothness = 1.0 - matBuff.roughness;\n    const float transparency = 0.0;\n\t\n    // Сalculating dots and coefficients for the formula\n\tvec3 lrn = reflect(lightBuff.lightDir, lightBuff.normal);\n\tfloat nDotV = dot(lightBuff.normal, lightBuff.viewDir);\n\tfloat hDotV = dot(lrn, lightBuff.viewDir);\n\tfloat strF  = strFresnel(lightBuff.lambert, str_Kf);\n\tfloat smoothness3 = smoothness * smoothness * smoothness;\n \n    // Diffuse formula\n\tfloat\tomst = (1.0 - smoothness3) * (1.0 - transparency);\n\tvec3\tdiff = lightBuff.lambert * (1.0 - matBuff.metalness * smoothness) * omst * matBuff.diffuse;\n    \n    // Specular formula\n\tfloat\tr = (1.0 - transparency) - omst;\n\tfloat\tj = strF * strShadow (lightBuff.lambert, str_Ks) * strShadow ( nDotV, str_Ks);\n\tfloat\trefl = min ( 1.0, r + j * ( r + str_K) );\n\tvec3 \tCs = vec3 ( 1.0 ) + matBuff.metalness * (1.0 - strF) * (matBuff.diffuse - vec3 ( 1.0 )); \n\tvec3\tspec    = Cs * pow (-hDotV, 3.0 / (1.0 - smoothness) ) * refl;\n \n\tdiff = max(vec3(0.0), diff);\n\tspec = max(vec3(0.0), spec);\n    \n    // Combining\n\treturn diff + spec * matBuff.specular;\n}\n\n\n//------------------------------------------------------------------------\n// Ward model (isotropic)\n//------------------------------------------------------------------------\n#define wrd_K 10.0\n\nvec3 ward(LightBuffer lightBuff, MaterialBuffer matBuff)\n{    \n    // (N, H) product is all we need for specular term\n    float nDotH = dot(lightBuff.halfVec, lightBuff.normal);\n    float nDotH2 = nDotH * nDotH;\n    float  spec = exp(-wrd_K * (1.0 - nDotH2) / nDotH2);\n    spec = lightBuff.lambert > 0.0 ? spec : 0.0;\n    // Combining with lambert for diffuse\n    return matBuff.diffuse * lightBuff.lambert + matBuff.specular * spec;\n}\n\n// Manage lighting procedures for according \"screen\"\nvec3 doLighting(LightBuffer lightBuff, MaterialBuffer matBuff, vec2 screenIdx)\n{\n    // Calculating the lighting model index from the current screen index\n    int lightIdx = int(screenIdx.y * 3.0 + screenIdx.x);\n    \n    // Apply corresponding lighting model\n    vec3 linLight = blinnPhong(lightBuff, matBuff);\n    switch(lightIdx)\n    {\n        case 1:\n        linLight = phong(lightBuff, matBuff);\n        break;\n        case 2:\n        linLight = cookTorrance(lightBuff, matBuff);\n        break;\n        case 3:\n        linLight = orenNayar(lightBuff, matBuff);\n        break;\n        case 4:\n        linLight = minnaert(lightBuff, matBuff);\n        break;\n        case 5:\n        linLight = ashikhminShirley(lightBuff, matBuff);\n        break;\n        case 6:\n        linLight = lommelSeeliger(lightBuff, matBuff);\n        break;\n        case 7:\n        linLight = strauss(lightBuff, matBuff);\n        break;\n        case 8:\n        linLight = ward(lightBuff, matBuff);\n        break;\n    }\n    \n    // Add main light\n    linLight *= lightBuff.lightCol;\n    \n    // Add ambient light\n    linLight += (BACKGROUND_COLOR + matBuff.diffuse) * 0.033;\n\n    \n    return linLight;\n}\n\n\nvec3 render(vec2 uv, vec2 screenIdx)\n{\n    // Set up camera variables\n    vec3 camPos, camLookAt;\n    fillCameraData(camPos, camLookAt);\n    \n    // Construct view matrix from camera basis vectors\n    vec3 camForward = normalize(camLookAt - camPos);\n    vec3 camRight = normalize(cross(camForward,vec3(0.0,1.0,0.0)));\n    vec3 camUp = normalize(cross(camRight,camForward));\n    mat3 camMatrix = mat3(camRight, camUp, camForward);\n    \n    // This is how far from the screen the ray starts\n    const float focalLength = 2.0;\n    // Point on screen, through which a ray will pass (in view space)\n    vec3 onScreenPoint = vec3(uv, focalLength);\n    // Create a ray and transform it to world space\n    vec3 rayDir = normalize(camMatrix * onScreenPoint);\n    \n    // Start with background color\n    vec3 col = backgroundColor(uv);\n    \n    float t = rayMarch(camPos, rayDir);\n    \n    if(t > -0.5)\n    {\n        // Compute geometry variables\n        vec3 worldPos = camPos + rayDir * t;        \n        \n        LightBuffer lightBuff = fillLightData(worldPos, rayDir);\n        MaterialBuffer matBuff = fillMaterialData();\n        \n        col = doLighting( lightBuff, matBuff, screenIdx);\n        \n    }\n    \n    vec2 postProcessUV = uv * 0.5 + 0.5;\n    // Apply vignette\n    col *= pow(16. * postProcessUV.x * postProcessUV.y * (1. - postProcessUV.x) * (1. - postProcessUV.y), .2);\n    \n    col = pow(SAT(col), vec3(0.4545));\n    \n    \n    //return vec3(uv, 0.0);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 fragCoordScaled = vec2(3.0, 3.0) * fragCoord;\n    vec2 uv = (mod(fragCoordScaled, iResolution.xy) - 0.5 * iResolution.xy)/ min(iResolution.x, iResolution.y);\n    vec2 screenIdx = floor(fragCoordScaled/ iResolution.xy);\n    \n    fragColor = vec4(render(uv, screenIdx), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}