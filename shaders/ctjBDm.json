{
    "Shader": {
        "info": {
            "date": "1694185964",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nI dont think I have the layering correct, and totally doing it my own special / messed up way. But always fun trying to figure something!",
            "flags": 0,
            "hasliked": 0,
            "id": "ctjBDm",
            "likes": 31,
            "name": "Year of Truchets #054",
            "published": 3,
            "tags": [
                "truchet",
                "multiscale",
                "quadtree",
                "recreation"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #054\n    09/06/2023  @byt3_m3chanic\n    \n    Trying to multiscale on my own / using @Shanes neighbor loop\n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { float n = sin(dot(p,vec2(57,27)));return fract(vec2(274134,32768)*n);}\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq hsv2rgb palettes & box\nvec3 hsv(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n    return c.z * mix( vec3(1),rgb,c.y);\n}\n\nfloat box( vec2 p, vec2 b){ vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 suv= uv;\n\n    // upscale\n    uv*=2.5;\n    \n    // turn and move\n    uv *= rot(-T*.08);\n    uv.x -= T*.35;\n\n    // threshold values\n    const vec2 rndX[4]=vec2[4]( vec2(.35, .55), vec2(.5, .25), vec2(.5, .5), vec2(.5, .7));\n    // distance field values.\n    vec4 d=vec4(1e5), s=vec4(1e5), b=vec4(1e5), e=vec4(1e5), f=vec4(1e5);\n    // start level\n    float level=1., grid = 1e5;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n        vec2 id = floor(uv*level);\n        float frnd = hash22(id).x;\n        \n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n            \n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 home = id+neighbors;\n                vec2 rnd = hash22(home);\n      \n                // neighboring cell hash values.\n                vec2 rnd2 = hash22(floor(home/2.));\n                vec2 rnd4 = hash22(floor(home/4.));\n                vec2 rnd8 = hash22(floor(home/8.));\n\n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rnd2.y<rndX[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rnd2.y<rndX[1].y || rnd4.y<rndX[0].y)) continue;\n                // If any of the three previous larger tiles have been rendered, continue.\n                if(k==3 && (rnd2.y<rndX[2].y || rnd4.y<rndX[1].y  || rnd8.y<rndX[0].y )) continue;\n\n                // threshold\n                if(rnd.y<rndX[k].y) {\n     \n                    vec2 p = uv -(id+.5+neighbors)/level;\n                    if(rnd.x<rndX[k].x) p.x = -p.x;\n  \n                    float bx = (.5)/level;\n                    float tk = .16666/level;\n                    float hf = .5/level;\n                    float qf = .25/level;\n                    float df = qf/3.;\n                    float mf = .05/level;\n                    \n                    float square = box(p,vec2(bx));\n                    vec2 pv = length(p-vec2(hf,-hf))<length(p+vec2(hf,-hf))? p-vec2(hf,-hf):p+vec2(hf,-hf);\n   \n                    // truchet\n                    float cd = abs(length(pv)-hf)-tk;\n                    \n                    // all the dots\n                    float bc = length(abs(p)-hf)-tk;\n                    float bd = min(length(vec2(abs(p.x)-hf,p.y))-tk,length(vec2(p.x,abs(p.y)-hf))-tk);\n                    float be = min(length(vec2(abs(p.x)-hf,abs(p.y)-qf))-df,length(vec2(abs(p.x)-qf,abs(p.y)-hf))-df);\n                    \n                    // alt title\n                    if(rnd.x>.8) cd = min(length(p.x),length(p.y))-tk;\n                    // rnd blank\n                    if(rnd.x<.1&&(k<3)) cd = 1e5;\n                    \n                    cd = max(cd,square);\n                    cd = min(cd,bd);\n         \n                    if(mod(float(k),2.)==0.) cd = min(cd,bc);\n\n                    grid = min(grid, abs(square)-.0025/2.);\n                    s[k] = min(s[k], square);\n                    d[k] = min(d[k], cd);\n                    b[k] = min(b[k], bd);\n                    e[k] = min(e[k], be);\n                    f[k] = min(f[k], bc);\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    float px = fwidth(uv.x/2.);\n    float ml = 1e5;\n\n    float cvv = uv.x + .25*sin(uv.y*PI2+T*.4);\n    cvv += uv.y + .25*sin(uv.x*PI+T*.3);\n    vec3 cb = (suv.x>0.)? vec3(.8) : hsv(vec3(floor(cvv*6.)*2.045,1.,.5));\n        \n    vec3 C = vec3(.005);\n\n    C = mix(C,vec3(.05),smoothstep(px,-px,grid));\n    \n    vec4 tk = vec4(1e5);\n    for(int k=0; k<4; k++){\n\n        \n        if(mod(float(k),2.)==0.){\n            d[k]=max(min(d[k],-s[k]),-e[k]);\n            tk.x=min(tk.x,-d[k]);\n            C = mix(C,cb,smoothstep(-px,px,d[k]));\n        }else {\n            tk.x=min(tk.x,d[k]);\n            C = mix(C,cb,smoothstep(px,-px,d[k]));\n        }\n\n    }\n    \n    if(suv.x<0.) C = mix(C,vec3(1),smoothstep(px,-px,abs(tk.x)-.005));   \n    if(suv.x<0.) C = mix(C,vec3(1),smoothstep(px,-px,abs(tk.x+.06)-.0075));\n    if(M.z>0.) C = mix(C,vec3(.7),smoothstep(px,-px,grid));\n    if(suv.x>0.&&suv.x<.0025) C = vec3(1);\n    \n    // Output to screen\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n// end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}