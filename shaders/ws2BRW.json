{
    "Shader": {
        "info": {
            "date": "1589640104",
            "description": "how the square + circle shape is built",
            "flags": 0,
            "hasliked": 0,
            "id": "ws2BRW",
            "likes": 7,
            "name": "Square + Circle Construction",
            "published": 3,
            "tags": [
                "construction"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat antialias(float x) {\n    float pixelsize = 4./iResolution.y;\n    return smoothstep(pixelsize, 0., x);\n}\n\nconst float PI = acos(-1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.; mouse*=3.;\n    \n    \n    float col = 0.;\n    float animlen = 27.;\n    float timeline = abs(asin(sin(iTime*PI/animlen/2.))*animlen/PI*2.);\n    \n    float radius = 1.;\n    float sharpness = pow(asin(sin(max(4.7, timeline*1.2)))/PI+1.,8.);\n    float offset = sin(iTime*0.65)*0.25+0.25;\n    \n    float axis_fade = smoothstep(0., 1., timeline);\n    float sphere_fade = smoothstep(2., 3., timeline);\n    float point_fade = smoothstep(17., 16., timeline);\n    float mirror_fade = smoothstep(9., 10., timeline)*smoothstep(20., 19., timeline);\n    float cut_fade = abs(uv.x) > uv.y ? smoothstep(14., 13., timeline) : 1.;\n    float rep_fade = smoothstep(16., 17., timeline+uv.y*.1);\n    float sector_pulse = smoothstep(.5,0.,abs(timeline-13.5));\n    \n    col += antialias(min(abs(uv.x), abs(uv.y)))*.33*axis_fade; //axes\n    col += antialias(abs(abs(uv.x)-abs(uv.y))/sqrt(2.))*.66*mirror_fade; //mirror axes\n    col += antialias(abs(uv.x)-uv.y)*.2*sector_pulse; //sector to be mirrored\n    col += antialias(length(uv+vec2(0, sharpness))-.01)*sphere_fade*point_fade; //circle center\n\tcol += antialias(abs(length(uv+vec2(0, sharpness))-radius-sharpness))*sphere_fade*cut_fade*(1.-rep_fade); //circle\n    vec2 uv_mapped = abs(uv); if (uv_mapped.x > uv_mapped.y) uv_mapped = uv_mapped.yx;\n    col += antialias(abs(length(uv_mapped+vec2(0, sharpness))-radius-sharpness))*rep_fade; //mirrored circle\n\n\tfragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}