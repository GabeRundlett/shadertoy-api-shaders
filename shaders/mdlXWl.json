{
    "Shader": {
        "info": {
            "date": "1669746224",
            "description": "A Sphere Made of connected pipes using wang face tiling.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdlXWl",
            "likes": 26,
            "name": "Pipe sphere",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "voxel",
                "wangtiles",
                "pipes"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "#define AA 2\nconst float eps = 0.0001;\nfloat s2;\nvec3 getRay(in vec3 cameraDir, in vec2 uv) {\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nfloat j(in float x) {\n    return fract(x)*mod(floor(x), 2.0)+floor(x*0.5)+2.0;\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nconst uint k = 1234543210U;\nuint hash( uvec3 x )\n{\n\tvec3 z = vec3(x)-1000000.+0.5;\n    if (length(z) > s2-1.0) return 0u;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return uint((64.0*(float(x.x)/float(0xffffffffU))));\n}\nconst float s = 0.15;\nconst float ku = 0.68;\nfloat edge(in vec3 p, in uint d, in bool n) {\n    float ds = 1000.0;\n    if ((d&1u) != 0u) ds = min(ds, min(max(length(p.yz), -p.x+s)-s,max(length(p.yz), -p.x+ku)-s*1.3));\n    if ((d&2u) != 0u) ds = min(ds, min(max(length(p.yz), p.x+s)-s,max(length(p.yz), p.x+ku)-s*1.3));\n    if ((d&4u) != 0u) ds = min(ds, min(max(length(p.xz), -p.y+s)-s,max(length(p.xz), -p.y+ku)-s*1.3));\n    if ((d&8u) != 0u) ds = min(ds, min(max(length(p.xz), p.y+s)-s,max(length(p.xz), p.y+ku)-s*1.3));\n    if ((d&16u) != 0u) ds = min(ds, min(max(length(p.xy), -p.z+s)-s,max(length(p.xy), -p.z+ku)-s*1.3));\n    if ((d&32u) != 0u) ds = min(ds, min(max(length(p.xy), p.z+s)-s,max(length(p.xy), p.z+ku)-s*1.3));\n   \tif (d > 0u) ds = min(ds, length(p)-s); \n    return n?ds:max(ds, box(p, vec3(0.5)));\n}\nuint getState(in uvec3 id) {\n\t uint v = hash(id);\n    if ((id.x+id.y+id.z)%2u == 1u) {\n        v = ((hash(id-uvec3(1, 0, 0))&1u)<<1)|\n            ((hash(id+uvec3(1, 0, 0))&2u)>>1)|\n            ((hash(id-uvec3(0, 1, 0))&4u)<<1)|\n            ((hash(id+uvec3(0, 1, 0))&8u)>>1)|\n            ((hash(id-uvec3(0, 0, 1))&16u)<<1)|\n            ((hash(id+uvec3(0, 0, 1))&32u)>>1);\n    }\n    return v;\n}\nvec3 norm( vec3 p, in uint id)\n{\n    const float h = eps;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * edge(p + k.xyy * h, id, true) +\n                     k.yyx * edge(p + k.yyx * h, id, true) +\n                     k.yxy * edge(p + k.yxy * h, id, true) +\n                     k.xxx * edge(p + k.xxx * h, id, true));\n}\nfloat sphere(in vec3 ro, in vec3 rd, in float ra) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra*ra;\n    float h = b*b-c;\n    if (h < 0.0) return -1.;\n    h = sqrt(h);\n    return -b-h;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    float s = sphere(ro, rd, j(iTime));\n    if (s < 0.0) return vec3(1);\n    ro = ro+rd*(s*0.7);\n    vec3 p = vec3(ro);\n    vec3 mp = floor(p);\n    vec3 p1 = mp;\n    vec3 dd = 1./rd;\n    int ii;\n    bool h = false;\n    int c = 0;\n    for (int i = 0; i < 100; i += 1) {\n    \tvec3 a = -(p-mp)*dd;\n    \tvec3 b = -((p-mp)-1.0)*dd;\n        vec3 ax = max(a, b);\n        float m = min(min(ax.x, ax.y), ax.z);\n        p += rd*m;\n        if (m == ax.x) {p.x += sign(a.x-b.x);p1.x -= sign(a.x-b.x);};\n        if (m == ax.y) {p.y += sign(a.y-b.y);p1.y -= sign(a.y-b.y);};\n        if (m == ax.z) {p.z += sign(a.z-b.z);p1.z -= sign(a.z-b.z);};\n        if (length(p1) > s2*2.0) break;\n        float d0 = 0.0;\n        vec3 o = (p-mp)-0.5;//(fract(p)-0.5);\n        bool hit = false;\n        int n;\n        uint s = getState(uvec3((p1)+1000000.));\n        if (s != 0u) {\n            h = true;\n        \tfor (int n = 0; n < 200; n += 1) {\n                ii += 1;\n        \t\tvec3 pppp = o+rd*d0;\n        \t\tfloat ddd = edge(pppp, s, false);\n        \t    d0 += ddd;\n        \t    if (ddd < eps || d0 > 1.) {\n        \t    \tbreak;\n        \t    }\n        \t}\n        \tvec3 pp = o+rd*d0;\n            vec3 n = norm(pp, s);\n        \tif (d0 < 1.) return (1.-exp(-0.05/vec3(float(ii)*0.1*(dot(n, rd)+1.0))));\n    \t} else {\n            if (h) c += 1;\n        }\n        if (c > 10) break;\n    }\n    return vec3(1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s2 = j(iTime);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.z<1.0?vec2(iTime*0.25+0.5, 3.141592*0.5+sin(iTime*0.5+2.0)*0.5):((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*3.0*s2*0.7;\n    vec3 rd = getRay(-normalize(ro), uv);\n    vec3 color = (1.-exp(-getColor(ro, rd)*2.0));\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}