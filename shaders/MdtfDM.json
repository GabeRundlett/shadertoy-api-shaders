{
    "Shader": {
        "info": {
            "date": "1525510446",
            "description": "Just an early experiment. Use the mouse ...",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtfDM",
            "likes": 66,
            "name": "Conelight sphere",
            "published": 3,
            "tags": [
                "experiment",
                "light",
                "volumetric",
                "glow",
                "iteration"
            ],
            "usePreview": 0,
            "username": "Virgill",
            "viewed": 1764
        },
        "renderpass": [
            {
                "code": "// ***********************************************************\n// Conelight sphere\n// by Jochen \"Virgill\" Feldk√∂tter\n//\n// Just an early experiment for my 4k intro \"the explorer\"\n// http://www.pouet.net/prod.php?which=75741\n// ***********************************************************\n\n\nvec3 lightpos = vec3(0),schein;\nfloat scatter =0.;\n\n\nfloat rnd(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nvoid pR(inout vec2 p,float a) \n{\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nfloat map(in vec3 p) \n{\n\t\t\n\tfloat d = p.y-.5*log(1.*pow(length(p.xz),1.)+0.2);\n \td = min(d,length(p)-0.4);\n   \tschein=(p-lightpos);\n    pR(schein.zx,iMouse.x*-0.03+0.8);\n    pR(schein.yz,iMouse.y*0.03-.5);\n\tfloat s= sdCone(schein,normalize(vec2(1,.9)))/length(schein*schein);\n    scatter += max(-s,0.)*0.2;\n   \n    float f = length(p-lightpos)-0.1; \n    return min(f,d);\n}\n\n\nvec3 calcNormal(vec3 pos)\n{\n    float eps = 0.0002, d = map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {\n\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float t = -3.5+rnd(co+0.01*iTime)*7.;\n    for(int i = 0; i < 200; i++) \n    {\n    \tif(abs(h) < precis || t > maxt) break;\n        h = map(ro+rd*t);\n        t += 0.5*h;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t// camera setup (iq)   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float theta = iTime * 3.141592 * 0.20;\n    float x = 5.0 * cos(theta*0.5);\n    float z = 5.0 * sin(theta*0.5);\n    vec3 ro = vec3(0.5*x, 4.0, 5.3);\n    \n    vec3 ta = vec3(0.0, 0.25, 0.0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n   \n    lightpos = vec3(1,0.7 + 0.2 * sin(theta*2.0),1); \n\n    vec3 col = vec3(0);\n   \tfloat t= castRay(ro, rd, 15.0,uv);    \n\tfloat depth = clamp(t/5.-1.3,0.,1.);\n\tif (t>15.) t=-1000000.;\n\n\tcol+=0.3*scatter*vec3(1,0.8,0.6);\n\n\n\tfragColor = vec4(col,0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}