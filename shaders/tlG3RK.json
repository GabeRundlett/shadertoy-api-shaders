{
    "Shader": {
        "info": {
            "date": "1579341120",
            "description": "I was curious how does it look if we make smoothstep simply based on pow(x, p).",
            "flags": 0,
            "hasliked": 0,
            "id": "tlG3RK",
            "likes": 3,
            "name": "Smooth smooth step",
            "published": 3,
            "tags": [
                "2d",
                "plot"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 393
        },
        "renderpass": [
            {
                "code": "// Misc\n#define SCALE_BEND 8.0\n#define SCALE_TIME 0.7\n#define COLOR vec3(0.0, 1.0, 1.0) * 1.0\n\n#define SCALE_UV  (1.0 / 1.2)\n#define OFFSET_UV vec2(((iResolution.x / iResolution.y / SCALE_UV) - 1.0) * 0.5, 0.1)\n\n// AA\n#define LINE_HALF_WIDTH (2.5 / iResolution.y / SCALE_UV)\n#define DISTANCE_RESOLUTION (0.2 / iResolution.y / SCALE_UV)\n#define NUM_ANGLES 8.0\n\n// Background\n#define COLOR_CHECKER1 vec3(1.0) * 0.35\n#define COLOR_CHECKER2 vec3(1.0) * 0.70\n#define SCALE_CHECKER 4.0\n\n\nfloat smoothSmoothStep(float t, float p) {\n  // Odd around (0.5, 0.5) with f(u \\in [0, 0.5]) = (2 t)^p / 2.\n  float u = clamp(t, 0.0, 1.0);\n  float b = float(u >= 0.5);\n  float s = 2.0 * b - 1.0;\n  return b - s * pow((2.0 * (b - s * u)), p) * 0.5;\n}\n\n\nfloat getDistance(vec2 uv, float p) {\n  float result = LINE_HALF_WIDTH;\n  bool init_state = uv.y < smoothSmoothStep(uv.x, p);\n\n  // Search NUM_ANGLES directions\n  for (float t = 0.0; t < NUM_ANGLES; t++) {\n    vec2 dire = vec2(cos(2.0 * 3.1415 * t / NUM_ANGLES), sin(2.0 * 3.1415 * t / NUM_ANGLES));\n\n    // Search up-to DISTANCE_RESOLUTION\n    bool state = init_state;\n    for (float i = 1.0; i < LINE_HALF_WIDTH / DISTANCE_RESOLUTION; i++) {\n      float curr_step = i * DISTANCE_RESOLUTION;\n      vec2 xy = uv + curr_step * dire;\n      bool curr_state = xy.y < smoothSmoothStep(xy.x, p);\n      if (state != curr_state && curr_step < result) {\n        result = curr_step - DISTANCE_RESOLUTION;\n        break;\n      }\n\n      state = curr_state;\n    }\n  }\n\n  return result;\n}\n\n\nvec3 checker(vec2 uv) {\n  float xi = floor(SCALE_CHECKER * uv.x);\n  float yi = floor(SCALE_CHECKER * uv.y);\n  bool even_spot = mod(xi + yi, 2.0) == 0.0;\n  return even_spot ? COLOR_CHECKER1 : COLOR_CHECKER2;\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = (frag_coord + vec2(0.5, 0.5)) / iResolution.y / SCALE_UV - OFFSET_UV;\n\n  float q = cos(SCALE_TIME * 3.1415 * iTime);\n  float p = pow(SCALE_BEND, q);\n  float d = getDistance(uv, p);\n\n  float fac = smoothstep(LINE_HALF_WIDTH, 0.0, d);\n  frag_color = vec4(mix(checker(uv), COLOR, fac), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// History\n//\n\n//\n// AA version 1\n//\n\n/*\n#define LINE_HALF_HEIGHT 4.0\n#define SCALE 6.0\n#define COLOR vec3(0.0, 1.0, 1.0) * 0.95\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = (frag_coord + vec2(0.5, 0.5)) / iResolution.y;\n\n  float q = cos(3.1415 * iTime);\n  float p = pow(SCALE, q);\n\n  frag_color = vec4(vec3(0.0), 1.0);\n  if (uv.x <= 1.0) {\n    float fx = smoothSmoothStep(uv.x, p);\n    float d = abs(fx - uv.y);\n\n    float fac = smoothstep((LINE_HALF_HEIGHT / iResolution.y), 0.0, d);\n    frag_color = vec4(fac * COLOR, 1.0);\n  }\n}\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}