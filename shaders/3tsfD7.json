{
    "Shader": {
        "info": {
            "date": "1596912423",
            "description": "tunnel",
            "flags": 1,
            "hasliked": 0,
            "id": "3tsfD7",
            "likes": 10,
            "name": "proceedural_track",
            "published": 3,
            "tags": [
                "tunnel"
            ],
            "usePreview": 0,
            "username": "slackmage",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "mat2 rot2(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s,-s, c);\n}\nvec3 rotate(vec3 p, vec3 a){\n    vec3 q=p;\n    q.yz=rot2(a.y)*q.yz;\n    q.xy=rot2(a.z)*q.xy;\n    q.xz=rot2(a.x)*q.xz;\n\treturn q;\n}\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat smax( in float a, in float b, in float s ){\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\nvec2 path(float z){\n    return vec2(.01*sin(z*40.)+.03*sin(z*13.),.03*cos(z*21.)+.08*cos(z*3.)+1.*z);\n}\nfloat de(vec3 p){\n    vec2 pth=path(p.z);\n    float t = max(abs(p.x+pth.x),abs(p.y+pth.y));\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.;\n    for (int i = 1 ; i <= 50; i++) {\n        float m = dot(p,p)*.7;\n        p/=m;\n        p.xy = fract(p.xy)-0.5;\n        s *= m;\n        p.xyz=p.yzx;\n    }\n    float f=1.0;\n    d=min(d,(length(p)-f)*s);\n    return smax(d,-t, 0.05);\n}\nfloat deSM(vec3 p){\n    vec2 pth=path(p.z);\n    float t = max(abs(p.x+pth.x),abs(p.y+pth.y));\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.;\n    for (int i = 1 ; i <= 8; i++) {\n        float m = dot(p,p)*.7;\n        p/=m;\n        p.xy = fract(p.xy)-0.5;\n        s *= m;\n        p.xyz=p.yzx;\n    }\n    float f=1.0;\n    d=min(d,(length(p)-f)*s);\n    return smax(d,-t, 0.05);\n}\nfloat map(vec3 p){\n    float d=de(p);\n    p.xy+=path(p.z);\n    d=max(d,.01-max(abs(p.x),abs(p.y)));\n    p.y+=.01;\n    d=min(d,max(abs(p.x)-.001,abs(p.y)-.001));\n    return d;\n}\nconst float FAR_DIST=50.0;\nconst float NEAR_DIST=.0001;\nconst int ITERATIONS=128;\nvec3 trace(vec3 o, vec3 r){\n    float t = 0.;\n    vec3 p;\n    float steps=0.;\n    for (int i = 0; i < ITERATIONS; i++){\n        p = o + r * t;\n        float d = map(p);\n        t += d*.5;\n        if(d<NEAR_DIST){\n        \tbreak;\n        }\n        if(t>FAR_DIST){\n    \t\treturn vec3(0.0);\n    \t}\n        steps++;\n    }\n    vec2 eps = vec2(0.0, .0001);\n    vec3 normal = normalize(vec3(\n        map(p + eps.yxx) - map(p - eps.yxx),\n        map(p + eps.xyx) - map(p - eps.xyx),\n        map(p + eps.xxy) - map(p - eps.xxy)));\n    float diffuse = max(0.0, dot(-normalize(r), normal)*.5+.4);\n    //light in front of person\n    //vec3 p2=vec3(-path((iTime+1.)/20.),(iTime+1.)/20.);\n    //float diffuse = max(0.0, dot(-normalize(p-p2), normal));\n    float specular = pow(diffuse, 32.0);\n    //smooth color\n    vec3 albedo = hsv2rgb(vec3(40.*deSM(p),1.,1.));\n    //hard bands of color\n    //vec3 albedo = hsv2rgb(vec3(.1*floor(de8xSM(p)*400.),1.,1.));\n    return mix(albedo*(diffuse + specular),vec3(0.),steps/float(ITERATIONS));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 o = vec3(-path(iTime/20.),iTime/20.);\n    vec3 ta = vec3(-path(.01+(iTime/20.)),.01+(iTime/20.));\n    mat3 ca = setCamera( o, ta, 0.0 );\n    //vec3 r = ca * normalize( vec3(uv.xy,1.5));\n    vec2 nMouse = vec2(10.0*(iMouse.x/iResolution.x)-5.,3.0*((iMouse.y/iResolution.y)-.5));\n    vec3 r;\n    if(iMouse.x==0.&&iMouse.y==0.){\n    \tr = ca *  normalize( vec3(uv.xy,1.5));\n    }else{\n    \tr = ca *  normalize( rotate(vec3(uv.xy,1.5),vec3(nMouse.x,nMouse.y,0.0)));\n    }\n    fragColor = vec4(trace(o, r),2.0);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ){\n    vec3 o = (fragRayOri/160.)+vec3(-path(iTime/20.),iTime/20.);\n    vec3 ta = (fragRayOri/160.)+vec3(-path(.01+(iTime/20.)),.01+(iTime/20.));\n    mat3 ca = setCamera( o, ta, 0.0 );\n    vec3 r = ca * fragRayDir;\n    vec3 col=trace(o, r);\n    fragColor = vec4(col,4.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}