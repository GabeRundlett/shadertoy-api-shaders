{
    "Shader": {
        "info": {
            "date": "1542926415",
            "description": "morph with raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "MlyfRy",
            "likes": 6,
            "name": "scaffold morph",
            "published": 3,
            "tags": [
                "raymarching",
                "morph"
            ],
            "usePreview": 0,
            "username": "anneka",
            "viewed": 525
        },
        "renderpass": [
            {
                "code": "#define repeat(p,r) (mod(p,r)-r/2.)\n#define PI 3.14159265358979323846\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 eye() {\n    return vec3(.2, .5, 2.);\n}\n\nmat2 rotation(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat subtract(float a, float b) {\n\treturn max(-a, b);\n}\n\nfloat wireframe_cube(vec3 p, float size, float weight) {\n\tfloat cut_size = size - weight;\n\tfloat long_size = size + 1.;\n\tfloat base = sdBox(p, vec3(size));\n\tfloat cut1 = sdBox(p, vec3(long_size, cut_size, cut_size));\n\tfloat cut2 = sdBox(p, vec3(cut_size, long_size, cut_size));\n\tfloat cut3 = sdBox(p, vec3(cut_size, cut_size, long_size));\n\treturn\n\tsubtract(cut1,\n\t\tsubtract(cut2,\n\t\t\tsubtract(cut3, base)\n\t\t)\n\t);\n}\n\nfloat sdf(vec3 pos) {\n    float scene = 100.;\n\tvec3 eye = eye();\n\tfloat lerp = (sin(iTime*.5)*.5)+.5;\n\tvec3 p1 = pos;\n\tvec3 p2 = pos;\n\tvec3 p3 = pos;\n\n\tmat2 rot1 = rotation(iTime*.1);\n\tmat2 rot2 = rotation(iTime*.1 + PI*.25);\n\tmat2 rot3 = rotation(iTime*.1 + PI*.5);\n\n    p1.yz *= rot1;\n\tp1.xy *= rot1;\n\tp1.xz *= rot1;\n\n\tp2.yz *= rot2;\n\tp2.xy *= rot2;\n\tp2.xz *= rot2;\n\n\tp3.yz *= rot3;\n\tp3.xy *= rot3;\n\tp3.xz *= rot3;\n\n\tfloat torus1 = sdTorus(p1, vec2(.4, .05));\n\tfloat torus2 = sdTorus(p2, vec2(.4, .05));\n\tfloat torus3 = sdTorus(p3, vec2(.4, .05));\n\n\tfloat tori = min(min(torus1, torus2), torus3);\n\n\tfloat wireframes = min(wireframe_cube(p1, .3, .05), wireframe_cube(p2, .3, .05));\n\n\tscene = mix(wireframes, tori, lerp);\n\n\tscene = max(scene, -sdSphere(eye-pos, .5));\n    return scene;\n}\n\nvec3 lookAt (vec3 from, vec3 target, vec2 uv) {\n    vec3 forward = normalize(target - from);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward * .5 + uv.x * right + uv.y * up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv-.5) / 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec4 color = vec4(0.);\n\n    float shade = 0.;\n    float distTotal = 0.;\n\n    vec3 eye = eye();\n    vec3 target = vec3(0);\n    vec3 ray = lookAt(eye, target, uv);\n    const float count = 50.;\n\n    for (float i = count; i > 0.; --i) {\n\n        float dist = sdf(eye);\n\n        if (dist < .0001) {\n            shade = i/count;\n            break;\n        }\n\n        eye += ray * dist;\n        distTotal += dist;\n    }\n\n\tcolor = vec4(vec3(pow(shade, 2.)), 1.);\n    color.rgb += rand(uv+vec2(iTime*.00001))*.15;\n   \n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}